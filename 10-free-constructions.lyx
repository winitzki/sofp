#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 10: Free type constructions]{Chapter 10: Free type constructions}
%\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-11-22}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\usepackage[nocenter]{qtree}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\newcommand{\shui}{\begin{CJK}{UTF8}{gbsn}水\end{CJK}}
\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.
\end_preamble
\options ,russian
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Beginning of slides.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern I.
 Expression trees
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Main idea: Represent a program as a data structure, run it later
\end_layout

\begin_layout Itemize
Example: a simple DSL for complex numbers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
val a = "1+2*i".toComplex
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val b = a * "3-4*i".toComplex
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
b.conj
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
Conj(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Mul(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
   Str("1+2*i"), Str("3-4*i")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
))
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\end_layout

\begin_layout Itemize

\emph on
Unevaluated
\emph default
 operations 
\family typewriter
\size footnotesize
\color blue
Str
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Mul
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Conj
\family default
\size default
\color inherit
 are defined as case classes:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Str(s: String) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul(p1: Prg, p2: Prg) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Conj(p: Prg) extends Prg
\end_layout

\begin_layout Itemize
An 
\emph on
interpreter
\emph default
 will 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 the program and return a complex number
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run(prg: Prg): (Double, Double) = ...
\end_layout

\begin_layout Itemize
Benefits: programs are data, can compose & transform before running
\end_layout

\begin_layout Itemize
Shortcomings: this DSL works only with simple expressions
\end_layout

\begin_deeper
\begin_layout Itemize
Cannot represent variable binding and conditional computations
\end_layout

\begin_layout Itemize
Cannot use any non-DSL code (e.g.
\begin_inset space ~
\end_inset

a numerical algorithms library)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern II.
 Variable binding
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

A DSL with variable binding and conditional computations
\end_layout

\begin_layout Itemize
Example: imperative API for reading and writing files
\end_layout

\begin_deeper
\begin_layout Itemize
Need to bind a 
\emph on
non-DSL variable
\emph default
 to a value computed by DSL
\end_layout

\begin_layout Itemize
Later, need to use that non-DSL variable in DSL expressions
\end_layout

\begin_layout Itemize
The rest of the DSL program is a (Scala) function of that variable
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
val p = path("/file")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val str: String = read(p)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  read(path(str))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
else "Error: empty path"
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
Bind(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Read(Path(Literal("/file"))),
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  { str 
\begin_inset Formula $\Rightarrow$
\end_inset


\color darkgray
 // read value `str`
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      Read(Path(Literal(str)))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Literal("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  })
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.1cm}
\end_layout

\end_inset

Unevaluated operations are implemented via case classes:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg, f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg) extends Prg 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg) extends Prg
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run(prg: Prg): String = ...

\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern III.
 Type safety
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
So far, the DSL has no type safety: every value is a 
\family typewriter
\size footnotesize
\color blue
Prg
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
We want to avoid errors, e.g.
 
\family typewriter
\size footnotesize
\color blue
Read(Read(...))
\family default
\size default
\color inherit
 should not compile
\end_layout

\end_deeper
\begin_layout Itemize
Let 
\family typewriter
\size footnotesize
\color blue
Prg[A]
\family default
\size default
\color inherit
 denote a DSL program returning value of type 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 
\emph on
when run
\emph default
:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg[String], f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[String])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg[String] 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg[String]) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg[nio.file.Path]) extends Prg[String]
\end_layout

\begin_layout Itemize
Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run(prg: Prg[String]): String = ...
\end_layout

\begin_layout Itemize
Our example DSL program is type-safe now:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val prg: Prg[String] = Bind(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Read(Path(Literal("/file"))),
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
     { str: String 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      Read(Path(Literal(str)))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Literal("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  })
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern IV.
 Cleaning up the DSL
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

Our DSL so far:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg[String], f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[String])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg[String]) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg[nio.file.Path]) extends Prg[String]
\end_layout

\begin_layout Standard
Problems with this DSL:
\end_layout

\begin_layout Itemize
Cannot use 
\family typewriter
\size footnotesize
\color blue
Read(p: nio.file.Path)
\family default
\size default
\color inherit
, only 
\family typewriter
\size footnotesize
\color blue
Read(p: Prg[nio.file.Path])
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Cannot bind variables or return values other than 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
To fix these problems, make 
\family typewriter
\size footnotesize
\color blue
Literal
\family default
\size default
\color inherit
 a fully parameterized operation and replace 
\family typewriter
\size footnotesize
\color blue
Prg[A]
\family default
\size default
\color inherit
 by 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 in case class arguments
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: String) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: nio.file.Path) extends Prg[String]
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset

The type signatures of 
\family typewriter
\size footnotesize
\color blue
Bind
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Literal
\family default
\size default
\color inherit
 are like 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern V.
 Define 
\family typewriter
Monad
\family default
-like methods
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset

We can actually define the methods 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A] {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def flatMap[B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[B]): Prg[B] = Bind(this, f)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def map[B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): Prg[B] = flatMap(this, f andThen Prg.pure)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
object Prg { def pure[A](a: A): Prg[A] = Literal(a) }
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

These methods don't run anything, only create unevaluated structures
\end_layout

\begin_layout Itemize
DSL programs can now be written as functor blocks and composed:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def readPath(p: String): Prg[String] = for {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  path 
\begin_inset Formula $\leftarrow$
\end_inset

 Path(p)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  str  
\begin_inset Formula $\leftarrow$
\end_inset

 Read(path)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
} yield str
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val prg: Prg[String] = for {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  str 
\begin_inset Formula $\leftarrow$
\end_inset

 readPath("/file")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  result 
\begin_inset Formula $\leftarrow$
\end_inset

  if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      readPath(str)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Prg.pure("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
} yield result
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run[A](prg: Prg[A]): A = ...

\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VI.
 Refactoring to an abstract DSL
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Write a DSL for complex numbers in a similar way:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A] { def flatMap ...
 }
\family default
\color darkgray
 // no code changes
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type Complex = (Double, Double)
\family default
\color darkgray
 // custom code starts here
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Str(s: String) extends Prg[Complex]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul(c1: Complex, C2: Complex) extends Prg[Complex]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Conj(c: Complex) extends Prg[Complex]
\end_layout

\begin_layout Itemize
Refactor this DSL to separate common code from custom code:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait DSL[F[_], A] { def flatMap ...
 }
\family default
\color darkgray
 // no code changes
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type Prg[A] = DSL[F, A]
\family default
\color darkgray
 // just for convenience
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Ops[A](f: F[A]) extends Prg[A]
\family default
\color darkgray
 // custom operations here
\end_layout

\begin_layout Itemize
Interpreter is parameterized by a 
\begin_inset Quotes eld
\end_inset

value extractor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[F[_], A](ex: Ex[F])(prg: DSL[F, A]): A = ...
\end_layout

\begin_layout Itemize
The constructor 
\family typewriter
\size footnotesize
\color blue
DSL[F[_], A]
\family default
\size default
\color inherit
 is called a 
\series bold
free monad
\series default
 over 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VII.
 Handling errors
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

To handle errors, we want to evaluate 
\family typewriter
\size footnotesize
\color blue
DSL[F[_], A]
\family default
\size default
\color inherit
 to 
\family typewriter
\size footnotesize
\color blue
Either[Err, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Suppose we have a value extractor of type 
\begin_inset Formula $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow\text{Err}+A\right)$
\end_inset


\end_layout

\begin_layout Itemize
The code of the interpreter is almost unchanged:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
def run[F[_], A](extract: Ex[F])(prg: DSL[F, A]): Either[Err, A] =
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  prg match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case b: Bind[F, _, A] ⇒ b match { case Bind(p, f) ⇒ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
        run(extract)(p).flatMap(f andThen run(extract))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    }
\family default
\color darkgray
     // Here, the .flatMap is from Either.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case Literal(a) ⇒ Right(a)
\family default
\color darkgray
 // pure: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Err + A
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case Ops(f) ⇒ extract(f)     
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

The code of 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 only uses 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 from 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
We can generalize to any other monad 
\begin_inset Formula $M^{A}$
\end_inset

 instead of 
\family typewriter
\size footnotesize
\color blue
Either[Err, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The resulting construction:
\end_layout

\begin_layout Itemize
Start with an 
\begin_inset Quotes eld
\end_inset

operations type constructor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $F^{A}$
\end_inset

 (often not a functor)
\end_layout

\begin_layout Itemize
Use 
\begin_inset Formula $\text{DSL}^{F,A}$
\end_inset

 and interpreter 
\size footnotesize

\begin_inset Formula $\text{run}:\left(\forall X.F^{X}\Rightarrow M^{X}\right)\Rightarrow\text{DSL}^{F,A}\Rightarrow M^{A}$
\end_inset


\end_layout

\begin_layout Itemize
Create a DSL program 
\begin_inset Formula $\text{prg}:\text{DSL}^{F,A}$
\end_inset

 and an extractor 
\begin_inset Formula $\text{ex}^{X}:F^{X}\Rightarrow M^{X}$
\end_inset


\end_layout

\begin_layout Itemize
Run the program with the extractor: 
\begin_inset Formula $\text{run}\left(\text{ex}\right)\left(\text{prg}\right)$
\end_inset

; get a value 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VIII.
 Monadic DSLs: summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Begin with a number of operations, which are typically functions of fixed
 known types such as 
\begin_inset Formula $A_{1}\Rightarrow B_{1}$
\end_inset

, 
\begin_inset Formula $A_{2}\Rightarrow B_{2}$
\end_inset

 etc.
\end_layout

\begin_layout Itemize
Define a type constructor (typically not a functor) encapsulating all the
 operations as case classes, with or without type parameters
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait F[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Op1(a1: A1) extends F[B1]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Op2(a1: A2) extends F[B2]
\end_layout

\begin_layout Itemize
Use 
\family typewriter
\size footnotesize
\color blue
DSL[F,A]
\family default
\size default
\color inherit
 with this 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
 to write monadic DSL programs 
\family typewriter
\size footnotesize
\color blue
prg:
\begin_inset space ~
\end_inset

DSL[F,A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Choose a target monad 
\family typewriter
\size footnotesize
\color blue
M[A]
\family default
\size default
\color inherit
 and implement an extractor 
\family typewriter
\size footnotesize
\color blue
ex:F[A]
\begin_inset Formula $\Rightarrow$
\end_inset

M[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Run the program with the extractor, 
\family typewriter
\size footnotesize
\color blue
val res:
\begin_inset space ~
\end_inset

M[A] = run(ex)(prg)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Further directions (out of scope for this chapter):
\end_layout

\begin_layout Itemize
May choose another monad 
\family typewriter
\size footnotesize
\color blue
N[A]
\family default
\size default
\color inherit
 and use interpreter 
\family typewriter
\size footnotesize
\color blue
M[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 N[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
E.g.
\begin_inset space ~
\end_inset

transform into another monadic DSL to optimize, test, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Since 
\family typewriter
\size footnotesize
\color blue
DSL[F,A]
\family default
\size default
\color inherit
 has a monad API, we can use monad transformers on it
\end_layout

\begin_layout Itemize
Can combine two or more DSLs in a disjunction: 
\begin_inset Formula $\text{DSL}^{F+G+H,A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Monad laws for DSL programs
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Monad laws hold for DSL programs only after evaluating them
\end_layout

\begin_layout Itemize
Consider the law 
\begin_inset Formula $\text{flm}\left(\text{pure}\right)=\text{id}$
\end_inset

; both functions 
\begin_inset Formula $\text{DSL}^{F,A}\Rightarrow\text{DSL}^{F,A}$
\end_inset


\end_layout

\begin_layout Itemize
Apply both sides to some 
\begin_inset Formula $\text{prg}:\text{DSL}^{F,A}$
\end_inset

 and get the new value
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
prg.flatMap(pure) == Bind(prg, a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Literal(a))
\end_layout

\begin_layout Itemize
This new value is 
\emph on
not equal
\emph default
 to 
\family typewriter
\size footnotesize
\color blue
prg
\family default
\size default
\color inherit
, so this monad law fails!
\end_layout

\begin_deeper
\begin_layout Itemize
Other laws fail as well because operations never reduce anything
\end_layout

\end_deeper
\begin_layout Itemize
After interpreting this program into a target monad 
\begin_inset Formula $M^{A}$
\end_inset

, the law holds:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
run(ex)(prg).flatMap((a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Literal(a)) andThen run(ex)) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg).flatMap(a 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(ex)(Literal(a)) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg).flatMap(a 
\begin_inset Formula $\Rightarrow$
\end_inset

 pure(a))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg)
\end_layout

\begin_layout Itemize
Here we have assumed that the laws hold for 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\begin_layout Itemize
All other laws also hold after interpreting into a lawful monad 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The monad law violations are 
\begin_inset Quotes eld
\end_inset

not observable
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Free constructions in mathematics: Example I
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider the Russian letter ц (tsè) and the Chinese word 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

(shu
\begin_inset IPA

\begin_layout Standard
̌i
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
We want to 
\emph on
multiply
\emph default
 ц by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

.
 Multiply how?
\end_layout

\begin_layout Itemize
Say, we want an associative (but noncommutative) product of them
\end_layout

\begin_deeper
\begin_layout Itemize
So we want to define a 
\emph on
semigroup
\emph default
 that 
\emph on
contains
\emph default
 ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

as elements
\end_layout

\begin_deeper
\begin_layout Itemize
while we still know nothing about ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Consider the set of all 
\emph on
unevaluated expressions
\emph default
 such as ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Here ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is different from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц but 
\begin_inset Formula $\left(a\cdot b\right)\cdot c=a\cdot\left(b\cdot c\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
All these expressions form a 
\series bold
free semigroup
\series default
 generated by ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the most unrestricted semigroup that contains ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Example calculation: (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)
\begin_inset Formula $\cdot$
\end_inset

(ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)
\begin_inset Formula $\cdot$
\end_inset

ц 
\begin_inset Formula $=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\end_layout

\begin_layout Standard
How to represent this as a data type:
\end_layout

\begin_layout Itemize

\series bold
Tree encoding
\series default
: the full expression tree: (((
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

),(ц,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)),ц)
\end_layout

\begin_deeper
\begin_layout Itemize
Implement the operation 
\begin_inset Formula $a\cdot b$
\end_inset

 as pair constructor (easy)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Reduced encoding
\series default
, as a 
\begin_inset Quotes eld
\end_inset

smart
\begin_inset Quotes erd
\end_inset

 structure: List(
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,ц,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,ц)
\end_layout

\begin_deeper
\begin_layout Itemize
Implement 
\begin_inset Formula $a\cdot b$
\end_inset

 by concatenating the lists (more expensive)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Free constructions in mathematics: Example II
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Want to define a product operation for 
\begin_inset Formula $n$
\end_inset

-dimensional vectors: 
\begin_inset Formula $\mathbf{v}_{1}\otimes\mathbf{v}_{2}$
\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $\otimes$
\end_inset

 must be linear and distributive (but not commutative):
\begin_inset Formula 
\begin{align*}
\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\left(\mathbf{u}_{2}\otimes\mathbf{v}_{2}+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\right) & =\left(\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}\right)+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\\
\mathbf{u}\otimes\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & =a_{1}\left(\mathbf{u}\otimes\mathbf{v}_{1}\right)+a_{2}\left(\mathbf{u}\otimes\mathbf{v}_{2}\right)\\
\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & \otimes\mathbf{u}=a_{1}\left(\mathbf{v}_{1}\otimes\mathbf{u}\right)+a_{2}\left(\mathbf{v}_{2}\otimes\mathbf{u}\right)
\end{align*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We have such a product for 3-dimensional vectors only; ignore that
\end_layout

\end_deeper
\begin_layout Itemize
Consider 
\emph on
unevaluated
\emph default
 
\emph on
expressions
\emph default
 of the form 
\begin_inset Formula $\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}+...$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A free vector space generated by pairs of vectors
\end_layout

\end_deeper
\begin_layout Itemize
Impose the equivalence relationships shown above
\end_layout

\begin_deeper
\begin_layout Itemize
The result is known as the 
\series bold
tensor product
\end_layout

\end_deeper
\begin_layout Itemize
Tree encoding: full unevaluated expression tree
\end_layout

\begin_deeper
\begin_layout Itemize
A list of any number of vector pairs 
\begin_inset Formula $\sum_{i}\mathbf{u}_{i}\otimes\mathbf{v}_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding: an 
\begin_inset Formula $n\times n$
\end_inset

 matrix
\end_layout

\begin_deeper
\begin_layout Itemize
Reduced encoding requires proofs and more complex operations
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: Free semigroup
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Implement a free semigroup 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 generated by two types 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
A value of 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 can be an 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
; it can also be a 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
y
\family default
\size default
\color inherit
 are of type 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 then so is 
\family typewriter
\size footnotesize
\color blue
x |+| y
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait FSIS 
\family default
\color darkgray
// tree encoding: full expression tree
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap1(x: Int) extends FSIS
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap2(x: String) extends FSIS
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Comb(x: FSIS, y: FSIS) extends FSIS
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Short type notation: 
\begin_inset Formula $\text{FSIS}\equiv\text{Int}+\text{String}+\text{FSIS}\times\text{FSIS}$
\end_inset

 
\end_layout

\begin_layout Itemize
For a semigroup 
\begin_inset Formula $S$
\end_inset

 and given 
\begin_inset Formula $\text{Int}\Rightarrow S$
\end_inset

 and 
\begin_inset Formula $\text{String}\Rightarrow S$
\end_inset

, map 
\begin_inset Formula $\text{FSIS}\Rightarrow S$
\end_inset


\end_layout

\begin_layout Itemize
Simplify and generalize this construction by setting 
\begin_inset Formula $Z=\text{Int}+\text{String}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The tree encoding is 
\begin_inset Formula $\text{FS}^{Z}\equiv Z+\text{FS}^{Z}\times\text{FS}^{Z}$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def |+|(x: FS[Z], y: FS[Z]): FS[Z] = Comb(x, y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[S: Semigroup, Z](extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 S): FS[Z] 
\begin_inset Formula $\Rightarrow$
\end_inset

 S = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(extract)(x) |+| run(extract)(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} 
\family default
\color darkgray
// Semigroup laws will hold after applying run().
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The reduced encoding is 
\begin_inset Formula $\text{FSR}^{Z}\equiv Z\times\text{List}^{Z}$
\end_inset

 (non-empty list of 
\begin_inset Formula $Z$
\end_inset

's)
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
x |+| y
\family default
\size default
\color inherit
 requires concatenating the lists, but 
\family typewriter
\size footnotesize
\color blue
run()
\family default
\size default
\color inherit
 is faster
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: Free monoid
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Implement a free monoid 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 generated by type 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
A value of 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 can be the empty value; it can also be a 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
y
\family default
\size default
\color inherit
 are of type 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 then so is 
\family typewriter
\size footnotesize
\color blue
x |+| y
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait FM[Z] 
\family default
\color darkgray
// tree encoding
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Empty[Z]() extends FM[Z]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap[Z](z: Z) extends FM[Z]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Comb[Z](x: FM[Z], y: FM[Z]) extends FM[Z]
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Short type notation: 
\begin_inset Formula $\text{FM}^{Z}\equiv1+Z+\text{FM}^{Z}\times\text{FM}^{Z}$
\end_inset

 
\end_layout

\begin_layout Itemize
For a monoid 
\begin_inset Formula $M$
\end_inset

 and given 
\begin_inset Formula $Z\Rightarrow M$
\end_inset

, map 
\begin_inset Formula $\text{FM}^{Z}\Rightarrow M$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def |+|(x: FM[Z], y: FM[Z]): FM[Z] = Comb(x, y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[M: Monoid, Z](extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 M): FM[Z] 
\begin_inset Formula $\Rightarrow$
\end_inset

 M = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Empty() 
\begin_inset Formula $\Rightarrow$
\end_inset

 Monoid[M].empty
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(extract)(x) |+| run(extract)(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} 
\family default
\color darkgray
// Monoid laws will hold after applying run().
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The reduced encoding is 
\begin_inset Formula $\text{FMR}^{Z}\equiv\text{List}^{Z}$
\end_inset

 (list of 
\begin_inset Formula $Z$
\end_inset

's)
\end_layout

\begin_deeper
\begin_layout Itemize
Implementing 
\family typewriter
\size footnotesize
\color blue
|+|
\family default
\size default
\color inherit
 requires concatenating the lists 
\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding and tree encoding give identical results after 
\family typewriter
\size footnotesize
\color blue
run()
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Mapping a free semigroup to different targets
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
What if we interpret 
\begin_inset Formula $\text{FS}^{X}$
\end_inset

 into 
\emph on
another
\emph default
 free semigroup?
\end_layout

\begin_layout Itemize
Given 
\begin_inset Formula $Y\Rightarrow Z$
\end_inset

, can we map 
\begin_inset Formula $\text{FS}^{Y}\Rightarrow\text{FS}^{Z}$
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
Need to map 
\begin_inset Formula $\text{FS}^{Y}\equiv Y+\text{FS}^{Y}\times\text{FS}^{Y}\Rightarrow Z+\text{FS}^{Z}\times\text{FS}^{Z}$
\end_inset


\end_layout

\begin_layout Itemize
This is straightforward since 
\begin_inset Formula $\text{FS}^{X}$
\end_inset

 is a functor in 
\begin_inset Formula $X$
\end_inset

:
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def fmap[Y, Z](f: Y 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z): FS[Y] 
\begin_inset Formula $\Rightarrow$
\end_inset

 FS[Z] = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Wrap(f(y))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(a, b) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Comb(fmap(f)(a), fmap(f)(b))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Now we can use 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 to interpret 
\begin_inset Formula $\text{FS}^{X}\Rightarrow\text{FS}^{Y}\Rightarrow\text{FS}^{Z}\Rightarrow S$
\end_inset

, etc.
\end_layout

\begin_deeper
\begin_layout Itemize
Functor laws hold for 
\begin_inset Formula $\text{FS}^{X}$
\end_inset

, so 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 is composable as usual
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

interpreter
\begin_inset Quotes erd
\end_inset

 commutes with 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 as well (naturality law):
\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & \text{FS}^{Y}\ar[rd]\sp(0.6){\ \text{run}^{S}g^{\underline{Y\Rightarrow S}}}\\
\text{FS}^{X}\ar[ru]\sp(0.45){\text{fmap}\,f^{\underline{X\Rightarrow Y}}}\ar[rr]\sb(0.5){\text{run}^{S}(f\circ g)^{\underline{X\Rightarrow S}}} &  & S
}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Combine two free semigroups: 
\begin_inset Formula $\text{FS}^{X+Y}$
\end_inset

; inject parts: 
\begin_inset Formula $\text{FS}^{X}\Rightarrow\text{FS}^{X+Y}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Continuation encoding I.
 Motivation
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\size default
Multiple target semigroups 
\begin_inset Formula $S_{i}$
\end_inset

 require many 
\begin_inset Quotes eld
\end_inset

extractors
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\text{ex}_{i}:Z\Rightarrow S_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Refactor extractors 
\begin_inset Formula $\text{ex}_{i}$
\end_inset

 into evidence of a typeclass constraint on 
\begin_inset Formula $S_{i}$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Typeclass ExZ[S] has the single method `extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 S`.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
implicit val extractS: ExZ[MySemigroup] = { z 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
 }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[S: ExZ: Semigroup](fm: FM[Z]): S = fm match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 implicitly[ExZ[S]].extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(x) |+| run(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\size default
Refactor 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 using a helper function 
\family typewriter
\size footnotesize
\color blue
wrap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def wrap[S: ExZ](z: Z): S = implicitly[ExZ[S]].extract(z)
\end_layout

\begin_layout Itemize
To create free monoid values, define functions with constraint 
\family typewriter
\size footnotesize
\color blue
[S: ExZ]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def x[S: ExZ : Semigroup]: S = wrap(1) |+| wrap(2)
\end_layout

\begin_layout Itemize
The type of 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 is 
\size footnotesize

\begin_inset Formula $\forall S.\left(Z\Rightarrow S\right)\times\left(S\times S\Rightarrow S\right)\Rightarrow S$
\end_inset


\size default
; equivalently:
\size footnotesize

\begin_inset Formula 
\[
\forall S.\left(Z\Rightarrow S\right)\times\left(S\times S\Rightarrow S\right)\Rightarrow S\ \cong\ \forall S.\left(\left(Z+S\times S\right)\Rightarrow S\right)\Rightarrow S
\]

\end_inset


\size default
which is similar to the type of the continuation monad, 
\begin_inset Formula $\left(A\Rightarrow R\right)\Rightarrow R$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
That's why I propose to call this a 
\begin_inset Quotes eld
\end_inset


\series bold
continuation encoding
\series default

\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Continuation encoding works for any type: 
\begin_inset Formula $A\cong\forall X.\left(A\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Continuation encoding II.
 Further examples
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider the continuation encoding for the disjunction type 
\begin_inset Formula $P+Q$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
The encoding is 
\size footnotesize

\begin_inset Formula $\forall X.\left(P+Q\Rightarrow X\right)\Rightarrow X\cong\forall X.\left(P\Rightarrow X\right)\times\left(Q\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
trait Disj[P, Q] { def run[X](cp: P 
\begin_inset Formula $\Rightarrow$
\end_inset

 X)(cq: Q 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X }
\end_layout

\begin_layout Itemize
Define some values of this type:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def inLeft[P, Q](p: P) = new Disj[P, Q] {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 def run[X](cp: P 
\begin_inset Formula $\Rightarrow$
\end_inset

 X)(cq: Q 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X = cp(p) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Now we can implement the analog of the 
\family typewriter
\size footnotesize
\color blue
case
\family default
\size default
\color inherit
 expression simply as
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = disj.run {p 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...} {q 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...}
\end_layout

\begin_layout Itemize
This works in programming languages that have no disjunction types
\end_layout

\begin_layout Itemize
General recipe for continuation encoding: 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
trait Blah { def run[X](cont: ...
 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X }
\end_layout

\begin_layout Itemize
For convenience, define a type class 
\family typewriter
\size footnotesize
\color blue
Ex
\family default
\size default
\color inherit
 describing the inner function
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
trait Ex[X] { def cp: P 
\begin_inset Formula $\Rightarrow$
\end_inset

 X; def cq: Q 
\begin_inset Formula $\Rightarrow$
\end_inset

 X }
\end_layout

\begin_layout Itemize
Different methods of this class return 
\family typewriter
\size footnotesize
\color blue
X
\family default
\size default
\color inherit
; convenient with disjunctions
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
General properties of free type constructions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Generalizing from our examples so far:
\end_layout

\begin_layout Itemize
We 
\begin_inset Quotes eld
\end_inset

enriched
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $Z$
\end_inset

 to a monoid 
\begin_inset Formula $\text{FM}^{Z}$
\end_inset

 and 
\begin_inset Formula $F^{A}$
\end_inset

 to a monad 
\begin_inset Formula $\text{DSL}^{F,A}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

enrichment
\begin_inset Quotes erd
\end_inset

 adds case classes representing the needed operations
\end_layout

\begin_layout Itemize
Very similar results for a type 
\begin_inset Formula $Z$
\end_inset

 and for a type constructor 
\begin_inset Formula $F^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Obtain a 
\series bold
free type construction
\series default
, which performs no computations
\end_layout

\begin_layout Standard
Questions:
\end_layout

\begin_layout Itemize
Can we promote any type constructor 
\begin_inset Formula $F^{A}$
\end_inset

 to any typeclass 
\begin_inset Formula $C$
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
Useful typeclasses: functor, filterable, monad, applicative
\end_layout

\end_deeper
\begin_layout Itemize
What are the laws for the 
\begin_inset Quotes eld
\end_inset

free instance of 
\begin_inset Formula $C$
\end_inset

 generated by 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
For all 
\begin_inset Formula $F^{A}$
\end_inset

, must have 
\family typewriter
\size footnotesize
\color blue
wrap
\family default
\size default
\color inherit
 
\begin_inset Formula $:F^{A}\Rightarrow\text{FreeC}^{F,A}$
\end_inset


\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $M^{A}:C$
\end_inset

, given 
\begin_inset Formula $F^{A}\Rightarrow M^{A}$
\end_inset

, must have 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 
\begin_inset Formula $:\text{FreeC}^{F,A}\Rightarrow M^{A}$
\end_inset


\end_layout

\begin_layout Itemize
The laws of typeclass 
\begin_inset Formula $C$
\end_inset

 must hold after interpreting into an 
\begin_inset Formula $M^{A}:C$
\end_inset


\end_layout

\begin_layout Itemize
Given any 
\family typewriter
\size footnotesize
\color blue
f
\family default
\size default
\color inherit

\begin_inset Formula $:F^{A}\Rightarrow G^{A}$
\end_inset

, must have 
\family typewriter
\size footnotesize
\color blue
fmap(f)
\family default
\size default
\color inherit

\begin_inset Formula $:\text{FreeC}^{F,A}\Rightarrow\text{FreeC}^{G,A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Which of the possible encodings to use?
\end_layout

\begin_deeper
\begin_layout Itemize
Tree encoding, reduced encodings, continuation encoding
\end_layout

\end_deeper
\begin_layout Itemize
Look at further examples
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: free functor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Generalize 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: free pointed functor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Also consider the case when we start from a functor 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Itemize
Free monad when starting from a functor 
\begin_inset Formula $F$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: free filterable
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Generalie
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: free applicative
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Generalize
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Implement a free semigroup generated by a type parameter 
\begin_inset Formula $Z$
\end_inset

 in the tree encoding and in the reduced encoding.
 Show that the semigroup laws hold for the reduced encoding but not for
 the tree encoding before interpreting into a lawful semigroup 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
