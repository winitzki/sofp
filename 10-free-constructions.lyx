#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 10: Free type constructions]{Chapter 10: Free type constructions}
%\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-11-22}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\usepackage[nocenter]{qtree}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\newcommand{\shui}{\begin{CJK}{UTF8}{gbsn}水\end{CJK}}
\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.
\end_preamble
\options ,russian
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Beginning of slides.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern I.
 Expression trees
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Main idea: Represent a program as a data structure, run it later
\end_layout

\begin_layout Itemize
Example: a simple DSL for complex numbers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
val a = "1+2*i".toComplex
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val b = a * "3-4*i".toComplex
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
b.conj
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
Conj(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Mul(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
   Str("1+2*i"), Str("3-4*i")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
))
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\end_layout

\begin_layout Itemize

\emph on
Unevaluated
\emph default
 operations 
\family typewriter
\size footnotesize
\color blue
Literal
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Mul
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Conj
\family default
\size default
\color inherit
 are defined as case classes:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Str(s: String) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul(p1: Prg, p2: Prg) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Conj(p: Prg) extends Prg
\end_layout

\begin_layout Itemize
An 
\emph on
interpreter
\emph default
 will 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 the program and return a complex number
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run(prg: Prg): (Double, Double) = ...
\end_layout

\begin_layout Itemize
Benefits: programs are data, can compose & transform before running
\end_layout

\begin_layout Itemize
Shortcomings: this DSL works only with simple expressions
\end_layout

\begin_deeper
\begin_layout Itemize
Cannot represent variable binding and conditional computations
\end_layout

\begin_layout Itemize
Cannot use any non-DSL code (e.g.
\begin_inset space ~
\end_inset

a numerical algorithms library)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern II.
 Variable binding
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

A DSL with variable binding and conditional computations
\end_layout

\begin_layout Itemize
Example: imperative API for reading and writing files
\end_layout

\begin_deeper
\begin_layout Itemize
Need to bind a 
\emph on
non-DSL variable
\emph default
 to a value computed by DSL
\end_layout

\begin_layout Itemize
Later, need to use that non-DSL variable in DSL expressions
\end_layout

\end_deeper
\begin_layout Itemize
The rest of the DSL program is a (Scala) function of that variable
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
val p = path("/file")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val str: String = read(p)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  read(path(str))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
else "Error: empty path"
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
Bind(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Read(Path(Literal("/file"))),
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  { str 
\begin_inset Formula $\Rightarrow$
\end_inset


\color darkgray
 // read value `str`
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      Read(Path(Literal(str)))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Literal("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  })
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.1cm}
\end_layout

\end_inset

Unevaluated operations are implemented via case classes:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg, f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg) extends Prg 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg) extends Prg
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run(prg: Prg): String = ...

\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern III.
 Type safety
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
So far, the DSL has no type safety: every value is a 
\family typewriter
\size footnotesize
\color blue
Prg
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
We want to avoid errors, e.g.
 
\family typewriter
\size footnotesize
\color blue
Read(Read(...))
\family default
\size default
\color inherit
 should not compile
\end_layout

\begin_layout Itemize
Let 
\family typewriter
\size footnotesize
\color blue
Prg[A]
\family default
\size default
\color inherit
 denote a DSL program returning value of type 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 
\emph on
when run
\emph default
:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg[String], f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[String])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg[String] 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg[String]) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg[nio.file.Path]) extends Prg[String]
\end_layout

\begin_layout Itemize
Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run(prg: Prg[String]): String = ...
\end_layout

\begin_layout Itemize
Our example DSL program is type-safe now:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val prg: Prg[String] = Bind(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Read(Path(Literal("/file"))),
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
     { str: String 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      Read(Path(Literal(str)))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Literal("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  })
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern IV.
 Cleaning up the DSL
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Our DSL so far:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A] { def bind(f: String
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[String]): Prg[String] }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg[String]) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg[nio.file.Path]) extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg[String]
\end_layout

\begin_layout Standard
Problems with this DSL:
\end_layout

\begin_layout Itemize
Cannot use 
\family typewriter
\size footnotesize
\color blue
Read(p: nio.file.Path)
\family default
\size default
\color inherit
, only 
\family typewriter
\size footnotesize
\color blue
Read(p: Prg[nio.file.Path])
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Cannot bind variables or return values other than 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
To fix these problems:
\end_layout

\begin_layout Itemize
Promote 
\family typewriter
\size footnotesize
\color blue
Literal
\family default
\size default
\color inherit
 to a fully parameterized operation
\end_layout

\begin_layout Itemize
Replace 
\family typewriter
\size footnotesize
\color blue
Prg[A]
\family default
\size default
\color inherit
 by 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 in case class arguments
\end_layout

\begin_layout Standard
Resulting DSL:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: String) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: nio.file.Path) extends Prg[String]
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Note the 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
-like type signature of 
\family typewriter
\size footnotesize
\color blue
Bind
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern V.
 Define 
\family typewriter
Monad
\family default
-like methods
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset

We can actually define the methods 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A] {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def flatMap[B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[B]): Prg[B] = Bind(this, f)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def map[B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): Prg[B] = flatMap(this, f andThen Prg.pure)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
object Prg { def pure[A](a: A): Prg[A] = Literal(a) }
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

These methods don't run anything, only create unevaluated structures
\end_layout

\begin_layout Itemize
DSL programs can now be written as functor blocks and composed:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def readPath(p: String): Prg[String] = for {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  path 
\begin_inset Formula $\leftarrow$
\end_inset

 Path(p)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  str  
\begin_inset Formula $\leftarrow$
\end_inset

 Read(path)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
} yield str
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val prg: Prg[String] = for {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  str 
\begin_inset Formula $\leftarrow$
\end_inset

 readPath("/file")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  result 
\begin_inset Formula $\leftarrow$
\end_inset

  if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      readPath(str)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Prg.pure("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
} yield result
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run[A](prg: Prg[A]): A = ...

\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VI.
 Refactoring to an abstract DSL
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Write a DSL for complex numbers in a similar way:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A] { def flatMap ...
 }
\family default
\color darkgray
 // no code changes
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type Complex = (Double, Double)
\family default
\color darkgray
 // custom code starts here
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Str(s: String) extends Prg[Complex]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul(c1: Complex, C2: Complex) extends Prg[Complex]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Conj(c: Complex) extends Prg[Complex]
\end_layout

\begin_layout Itemize
Refactor this DSL to separate common code from custom code:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait DSL[F[_], A] { def flatMap ...
 }
\family default
\color darkgray
 // no code changes
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type Prg[A] = DSL[F, A]
\family default
\color darkgray
 // just for convenience
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Ops[A](f: F[A]) extends Prg[A]
\family default
\color darkgray
 // custom operations here
\end_layout

\begin_layout Itemize
Interpreter is parameterized by a 
\begin_inset Quotes eld
\end_inset

value extractor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[F[_], A](ex: Ex[F])(prg: DSL[F, A]): A = ...
\end_layout

\begin_layout Itemize
The constructor 
\family typewriter
\size footnotesize
\color blue
DSL[F[_], A]
\family default
\size default
\color inherit
 is called a 
\series bold
free monad
\series default
 over 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VII.
 Handling errors
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

To handle errors, we want to evaluate 
\family typewriter
\size footnotesize
\color blue
DSL[F[_], A]
\family default
\size default
\color inherit
 to 
\family typewriter
\size footnotesize
\color blue
Either[Err, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Suppose we have a value extractor of type 
\begin_inset Formula $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow\text{Err}+A\right)$
\end_inset


\end_layout

\begin_layout Itemize
The code of the interpreter is almost unchanged:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
def run[F[_], A](extract: Ex[F])(prg: DSL[F, A]): Either[Err, A] =
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  prg match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case b: Bind[F, _, A] ⇒ b match { case Bind(p, f) ⇒ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
        run(extract)(p).flatMap(f andThen run(extract))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    }
\family default
\color darkgray
     // Here, the .flatMap is from Either.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case Literal(a) ⇒ Right(a)
\family default
\color darkgray
 // pure: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Err + A
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case Ops(f) ⇒ extract(f)     
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

The code of 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 only uses 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 from 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
We can generalize to any other monad 
\begin_inset Formula $M^{A}$
\end_inset

 instead of 
\family typewriter
\size footnotesize
\color blue
Either[Err, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The resulting construction:
\end_layout

\begin_layout Itemize
Start with an 
\begin_inset Quotes eld
\end_inset

operations type constructor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $F^{A}$
\end_inset

 (often not a functor)
\end_layout

\begin_layout Itemize
Use 
\begin_inset Formula $\text{DSL}^{F,A}$
\end_inset

 and interpreter 
\size footnotesize

\begin_inset Formula $\text{run}:\left(\forall X.F^{X}\Rightarrow M^{X}\right)\Rightarrow\text{DSL}^{F,A}\Rightarrow M^{A}$
\end_inset


\end_layout

\begin_layout Itemize
Create a DSL program 
\begin_inset Formula $\text{prg}:\text{DSL}^{F,A}$
\end_inset

 and an extractor 
\begin_inset Formula $\text{ex}^{X}:F^{X}\Rightarrow M^{X}$
\end_inset


\end_layout

\begin_layout Itemize
Run the program with the extractor: 
\begin_inset Formula $\text{run}\left(\text{ex}\right)\left(\text{prg}\right)$
\end_inset

; get a value 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Monad laws for DSL programs
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Monad laws hold for DSL programs only after evaluating them
\end_layout

\begin_layout Itemize
Consider the law 
\begin_inset Formula $\text{flm}\left(\text{pure}\right)=\text{id}$
\end_inset

; both functions 
\begin_inset Formula $\text{DSL}^{F,A}\Rightarrow\text{DSL}^{F,A}$
\end_inset


\end_layout

\begin_layout Itemize
Apply both sides to some 
\begin_inset Formula $\text{prg}:\text{DSL}^{F,A}$
\end_inset

 and get the new value
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
prg.flatMap(pure) == Bind(prg, a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Literal(a))
\end_layout

\begin_layout Itemize
This new value is 
\emph on
not equal
\emph default
 to 
\family typewriter
\size footnotesize
\color blue
prg
\family default
\size default
\color inherit
, so this monad law fails!
\end_layout

\begin_deeper
\begin_layout Itemize
Other laws fail as well because operations never reduce anything
\end_layout

\end_deeper
\begin_layout Itemize
After interpreting this program into a target monad 
\begin_inset Formula $M^{A}$
\end_inset

, the law holds:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
run(ex)(prg).flatMap((a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Literal(a)) andThen run(ex)) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg).flatMap(a 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(ex)(Literal(a)) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg).flatMap(a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Right(a))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg)
\end_layout

\begin_layout Itemize
Here we have assumed that the laws hold for 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\begin_layout Itemize
All other laws also hold after interpreting into a lawful monad 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The monad law violations are 
\begin_inset Quotes eld
\end_inset

not observable
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Free constructions in mathematics: Example I
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider the Russian letter ц (tsè) and the Chinese word 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{CJK}{UTF8}{gbsn}水
\backslash
end{CJK}
\end_layout

\end_inset

 (shu
\begin_inset IPA

\begin_layout Standard
̌i
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
We want to 
\emph on
multiply
\emph default
 ц by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

.
 Multiply how?
\end_layout

\begin_layout Itemize
Say, we want an associative (but noncommutative) product of them
\end_layout

\begin_deeper
\begin_layout Itemize
So we want to define a 
\emph on
semigroup
\emph default
 that 
\emph on
contains
\emph default
 ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

as elements
\end_layout

\begin_deeper
\begin_layout Itemize
while we still know nothing about ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Consider the set of all 
\emph on
unevaluated expressions
\emph default
 such as ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Here ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is different from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц but 
\begin_inset Formula $\left(a\cdot b\right)\cdot c=a\cdot\left(b\cdot c\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
All these expressions form a 
\series bold
free semigroup
\series default
 generated by ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Example calculation: (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)
\begin_inset Formula $\cdot$
\end_inset

(ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)
\begin_inset Formula $\cdot$
\end_inset

ц 
\begin_inset Formula $=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\end_layout

\begin_layout Standard
How to represent this as a data type:
\end_layout

\begin_layout Itemize
Tree encoding: the full expression tree: ((
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

),(ц,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)),ц)
\end_layout

\begin_deeper
\begin_layout Itemize
Implement the operation 
\begin_inset Formula $a\cdot b$
\end_inset

 as pair constructor (easy)
\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding, as a 
\begin_inset Quotes eld
\end_inset

smart
\begin_inset Quotes erd
\end_inset

 structure: List(
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,ц,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,ц)
\end_layout

\begin_deeper
\begin_layout Itemize
Implement 
\begin_inset Formula $a\cdot b$
\end_inset

 by concatenating the lists (more expensive)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Free constructions in mathematics: Example II
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Want to define a product operation for 
\begin_inset Formula $n$
\end_inset

-dimensional vectors: 
\begin_inset Formula $\mathbf{v}_{1}\otimes\mathbf{v}_{2}$
\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $\otimes$
\end_inset

 must be linear and distributive (but not commutative):
\begin_inset Formula 
\begin{align*}
\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\left(\mathbf{u}_{2}\otimes\mathbf{v}_{2}+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\right) & =\left(\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}\right)+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\\
\mathbf{u}\otimes\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & =a_{1}\left(\mathbf{u}\otimes\mathbf{v}_{1}\right)+a_{2}\left(\mathbf{u}\otimes\mathbf{v}_{2}\right)\\
\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & \otimes\mathbf{u}=a_{1}\left(\mathbf{v}_{1}\otimes\mathbf{u}\right)+a_{2}\left(\mathbf{v}_{2}\otimes\mathbf{u}\right)
\end{align*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We have such a product for 3-dimensional vectors only; ignore that
\end_layout

\end_deeper
\begin_layout Itemize
Consider 
\emph on
unevaluated
\emph default
 
\emph on
expressions
\emph default
 of the form 
\begin_inset Formula $\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}+...$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A free vector space generated by pairs of vectors
\end_layout

\end_deeper
\begin_layout Itemize
Impose the equivalence relationships shown above
\end_layout

\begin_deeper
\begin_layout Itemize
The result is known as the 
\series bold
tensor product
\end_layout

\end_deeper
\begin_layout Itemize
Tree encoding: full unevaluated expression tree
\end_layout

\begin_deeper
\begin_layout Itemize
A list of any number of vector pairs 
\begin_inset Formula $\sum_{i}\mathbf{u}_{i}\otimes\mathbf{v}_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding: a matrix
\end_layout

\begin_deeper
\begin_layout Itemize
Reduced encoding requires proof and more complex operations
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: Free semigroup
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Implement a free semigroup 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 generated by two types 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
A value of 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 can be an 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
; it can also be a 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
y
\family default
\size default
\color inherit
 are of type 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 then so is 
\family typewriter
\size footnotesize
\color blue
Mul(x, y)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait FSIS 
\family default
\color darkgray
// tree encoding: full expression tree
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap1(x: Int) extends FSIS
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap2(x: String) extends FSIS
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul(x: FSIS, y: FSIS) extends FSIS
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Short type notation: 
\begin_inset Formula $\text{FSIS}\equiv\text{Int}+\text{String}+\text{FSIS}\times\text{FSIS}$
\end_inset

 
\end_layout

\begin_layout Itemize
For a semigroup 
\begin_inset Formula $S$
\end_inset

 and given 
\begin_inset Formula $\text{Int}\Rightarrow S$
\end_inset

 and 
\begin_inset Formula $\text{String}\Rightarrow S$
\end_inset

, map 
\begin_inset Formula $\text{FSIS}\Rightarrow S$
\end_inset


\end_layout

\begin_layout Itemize
Simplify and generalize this construction by setting 
\begin_inset Formula $Z=\text{Int}+\text{String}$
\end_inset


\end_layout

\begin_layout Itemize
The redundant encoding is 
\begin_inset Formula $\text{FS}^{Z}=Z+\text{FS}^{Z}\times\text{FS}^{Z}$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def mul(x: FS[Z], y: FS[Z]): FS[Z] = Mul(x, y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[S: Semigroup, Z](extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 S): FS[Z] 
\begin_inset Formula $\Rightarrow$
\end_inset

 S = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case F(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Mul(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(extract)(x) |+| run(extract)(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} 
\family default
\color darkgray
// Semigroup laws will hold after applying run().
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The reduced encoding is 
\begin_inset Formula $\text{FSR}^{Z}\equiv Z\times\text{List}^{Z}$
\end_inset

 (non-empty list of 
\begin_inset Formula $Z$
\end_inset

's)
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
Mul(x, y)
\family default
\size default
\color inherit
 requires concatenating the lists but 
\family typewriter
\size footnotesize
\color blue
run()
\family default
\size default
\color inherit
 is faster
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example: Free monoid
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Implement a free monoid 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 generated by type 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
A value of 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 can be the empty value; it can also be a 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
y
\family default
\size default
\color inherit
 are of type 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 then so is 
\family typewriter
\size footnotesize
\color blue
Mul(x, y)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait FM[Z] 
\family default
\color darkgray
// tree encoding
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Empty[Z]() extends FM[Z]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap[Z](z: Z) extends FM[Z]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul[Z](x: FM[Z], y: FM[Z]) extends FM[Z]
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Short type notation: 
\begin_inset Formula $\text{FM}^{Z}\equiv1+Z+\text{FM}^{Z}\times\text{FM}^{Z}$
\end_inset

 
\end_layout

\begin_layout Itemize
For a monoid 
\begin_inset Formula $M$
\end_inset

 and given 
\begin_inset Formula $Z\Rightarrow M$
\end_inset

, map 
\begin_inset Formula $\text{FM}^{Z}\Rightarrow M$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def mul(x: FM[Z], y: FM[Z]): FM[Z] = Mul(x, y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[M: Monoid, Z](extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 M): FM[Z] 
\begin_inset Formula $\Rightarrow$
\end_inset

 M = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Empty() 
\begin_inset Formula $\Rightarrow$
\end_inset

 Monoid[M].empty
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Mul(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(extract)(x) |+| run(extract)(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} 
\family default
\color darkgray
// Monoid laws will hold after applying run().
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The reduced encoding is 
\begin_inset Formula $\text{FMR}^{Z}\equiv\text{List}^{Z}$
\end_inset

 (list of 
\begin_inset Formula $Z$
\end_inset

's)
\end_layout

\begin_deeper
\begin_layout Itemize
The multiplication requires concatenating the lists 
\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding and tree encodings give identical results after 
\family typewriter
\size footnotesize
\color blue
run()
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Implement a free semigroup generated by a type parameter 
\begin_inset Formula $Z$
\end_inset

 in the tree encoding and in the reduced encoding.
 Show that the semigroup laws hold for the reduced encoding but not for
 the tree encoding before interpreting into a lawful semigroup 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
