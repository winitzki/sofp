#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 10: Free type constructions]{Chapter 10: Free type constructions}
%\subtitle{Part 2: Their laws and structure}
\author{Sergei Winitzki}
\date{2018-11-22}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy}
\usepackage[nocenter]{qtree}
\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY
\newcommand{\shui}{\begin{CJK}{UTF8}{gbsn}水\end{CJK}}
\usepackage{CJKutf8} % For occasional Chinese characters. Also, add "russian" to documentclass.
\end_preamble
\options ,russian
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Beginning of slides.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern I.
 Expression trees
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Main idea: Represent a program as a data structure, run it later
\end_layout

\begin_layout Itemize
Example: a simple DSL for complex numbers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
val a = "1+2*i".toComplex
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val b = a * "3-4*i".toComplex
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
b.conj
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
Conj(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Mul(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
   Str("1+2*i"), Str("3-4*i")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
))
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\end_layout

\begin_layout Itemize

\emph on
Unevaluated
\emph default
 operations 
\family typewriter
\size footnotesize
\color blue
Str
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Mul
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Conj
\family default
\size default
\color inherit
 are defined as case classes:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Str(s: String) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul(p1: Prg, p2: Prg) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Conj(p: Prg) extends Prg
\end_layout

\begin_layout Itemize
An 
\emph on
interpreter
\emph default
 will 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 the program and return a complex number
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run(prg: Prg): (Double, Double) = ...
\end_layout

\begin_layout Itemize
Benefits: programs are data, can compose & transform before running
\end_layout

\begin_layout Itemize
Shortcomings: this DSL works only with simple expressions
\end_layout

\begin_deeper
\begin_layout Itemize
Cannot represent variable binding and conditional computations
\end_layout

\begin_layout Itemize
Cannot use any non-DSL code (e.g.
\begin_inset space ~
\end_inset

a numerical algorithms library)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern II.
 Variable binding
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

A DSL with variable binding and conditional computations
\end_layout

\begin_layout Itemize
Example: imperative API for reading and writing files
\end_layout

\begin_deeper
\begin_layout Itemize
Need to bind a 
\emph on
non-DSL variable
\emph default
 to a value computed by DSL
\end_layout

\begin_layout Itemize
Later, need to use that non-DSL variable in DSL expressions
\end_layout

\begin_layout Itemize
The rest of the DSL program is a (Scala) function of that variable
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
val p = path("/file")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val str: String = read(p)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  read(path(str))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
else "Error: empty path"
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color blue
Bind(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Read(Path(Literal("/file"))),
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  { str 
\begin_inset Formula $\Rightarrow$
\end_inset


\color darkgray
 // read value `str`
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      Read(Path(Literal(str)))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Literal("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  })
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.1cm}
\end_layout

\end_inset

Unevaluated operations are implemented via case classes:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg, f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg) extends Prg 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg) extends Prg
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg) extends Prg
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run(prg: Prg): String = ...

\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern III.
 Type safety
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
So far, the DSL has no type safety: every value is a 
\family typewriter
\size footnotesize
\color blue
Prg
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
We want to avoid errors, e.g.
 
\family typewriter
\size footnotesize
\color blue
Read(Read(...))
\family default
\size default
\color inherit
 should not compile
\end_layout

\end_deeper
\begin_layout Itemize
Let 
\family typewriter
\size footnotesize
\color blue
Prg[A]
\family default
\size default
\color inherit
 denote a DSL program returning value of type 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 
\emph on
when run
\emph default
:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg[String], f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[String])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg[String] 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg[String]) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg[nio.file.Path]) extends Prg[String]
\end_layout

\begin_layout Itemize
Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run(prg: Prg[String]): String = ...
\end_layout

\begin_layout Itemize
Our example DSL program is type-safe now:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val prg: Prg[String] = Bind(
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  Read(Path(Literal("/file"))),
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
     { str: String 
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      Read(Path(Literal(str)))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Literal("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  })
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern IV.
 Cleaning up the DSL
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

Our DSL so far:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind(p: Prg[String], f: String 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[String])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal(s: String) extends Prg[String]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: Prg[String]) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: Prg[nio.file.Path]) extends Prg[String]
\end_layout

\begin_layout Standard
Problems with this DSL:
\end_layout

\begin_layout Itemize
Cannot use 
\family typewriter
\size footnotesize
\color blue
Read(p: nio.file.Path)
\family default
\size default
\color inherit
, only 
\family typewriter
\size footnotesize
\color blue
Read(p: Prg[nio.file.Path])
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Cannot bind variables or return values other than 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
To fix these problems, make 
\family typewriter
\size footnotesize
\color blue
Literal
\family default
\size default
\color inherit
 a fully parameterized operation and replace 
\family typewriter
\size footnotesize
\color blue
Prg[A]
\family default
\size default
\color inherit
 by 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
 in case class arguments
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Path(s: String) extends Prg[nio.file.Path]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Read(p: nio.file.Path) extends Prg[String]
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.0cm}
\end_layout

\end_inset

The type signatures of 
\family typewriter
\size footnotesize
\color blue
Bind
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Literal
\family default
\size default
\color inherit
 are like 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern V.
 Define 
\family typewriter
Monad
\family default
-like methods
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset

We can actually define the methods 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A] {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def flatMap[B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Prg[B]): Prg[B] = Bind(this, f)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def map[B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): Prg[B] = flatMap(this, f andThen Prg.pure)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
object Prg { def pure[A](a: A): Prg[A] = Literal(a) }
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

These methods don't run anything, only create unevaluated structures
\end_layout

\begin_layout Itemize
DSL programs can now be written as functor blocks and composed:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def readPath(p: String): Prg[String] = for {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  path 
\begin_inset Formula $\leftarrow$
\end_inset

 Path(p)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  str  
\begin_inset Formula $\leftarrow$
\end_inset

 Read(path)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
} yield str
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val prg: Prg[String] = for {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  str 
\begin_inset Formula $\leftarrow$
\end_inset

 readPath("/file")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  result 
\begin_inset Formula $\leftarrow$
\end_inset

  if (str.nonEmpty)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
      readPath(str)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    else Prg.pure("Error: empty path")
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
} yield result
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Interpreter: 
\family typewriter
\size footnotesize
\color blue
def run[A](prg: Prg[A]): A = ...

\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VI.
 Refactoring to an abstract DSL
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Write a DSL for complex numbers in a similar way:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Prg[A] { def flatMap ...
 }
\family default
\color darkgray
 // no code changes
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type Complex = (Double, Double)
\family default
\color darkgray
 // custom code starts here
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Str(s: String) extends Prg[Complex]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Mul(c1: Complex, C2: Complex) extends Prg[Complex]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Conj(c: Complex) extends Prg[Complex]
\end_layout

\begin_layout Itemize
Refactor this DSL to separate common code from custom code:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
sealed trait DSL[F[_], A] { def flatMap ...
 }
\family default
\color darkgray
 // no code changes
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type Prg[A] = DSL[F, A]
\family default
\color darkgray
 // just for convenience
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Bind[A, B](p: Prg[A], f: A
\begin_inset Formula $\Rightarrow$
\end_inset

Prg[B]) extends Prg[B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Literal[A](a: A) extends Prg[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Ops[A](f: F[A]) extends Prg[A]
\family default
\color darkgray
 // custom operations here
\end_layout

\begin_layout Itemize
Interpreter is parameterized by a 
\begin_inset Quotes eld
\end_inset

value extractor
\begin_inset Quotes erd
\end_inset

 
\size footnotesize

\begin_inset Formula $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[F[_], A](ex: Ex[F])(prg: DSL[F, A]): A = ...
\end_layout

\begin_layout Itemize
The constructor 
\family typewriter
\size footnotesize
\color blue
DSL[F[_], A]
\family default
\size default
\color inherit
 is called a 
\series bold
free monad
\series default
 over 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VII.
 Handling errors
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

To handle errors, we want to evaluate 
\family typewriter
\size footnotesize
\color blue
DSL[F[_], A]
\family default
\size default
\color inherit
 to 
\family typewriter
\size footnotesize
\color blue
Either[Err, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Suppose we have a value extractor of type 
\begin_inset Formula $\text{Ex}^{F}\equiv\forall A.\left(F^{A}\Rightarrow\text{Err}+A\right)$
\end_inset


\end_layout

\begin_layout Itemize
The code of the interpreter is almost unchanged:
\end_layout

\begin_layout LyX-Code
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\family typewriter
\size footnotesize
\color blue
def run[F[_], A](extract: Ex[F])(prg: DSL[F, A]): Either[Err, A] =
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  prg match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case b: Bind[F, _, A] ⇒ b match { case Bind(p, f) ⇒ 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
        run(extract)(p).flatMap(f andThen run(extract))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    }
\family default
\color darkgray
     // Here, the .flatMap is from Either.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case Literal(a) ⇒ Right(a)
\family default
\color darkgray
 // pure: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 Err + A
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
    case Ops(f) ⇒ extract(f)     
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

The code of 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 only uses 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 from 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
We can generalize to any other monad 
\begin_inset Formula $M^{A}$
\end_inset

 instead of 
\family typewriter
\size footnotesize
\color blue
Either[Err, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The resulting construction:
\end_layout

\begin_layout Itemize
Start with an 
\begin_inset Quotes eld
\end_inset

operations type constructor
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $F^{A}$
\end_inset

 (often not a functor)
\end_layout

\begin_layout Itemize
Use 
\begin_inset Formula $\text{DSL}^{F,A}$
\end_inset

 and interpreter 
\size footnotesize

\begin_inset Formula $\text{run}^{M,A}:\left(\forall X.F^{X}\Rightarrow M^{X}\right)\Rightarrow\text{DSL}^{F,A}\Rightarrow M^{A}$
\end_inset


\end_layout

\begin_layout Itemize
Create a DSL program 
\begin_inset Formula $\text{prg}:\text{DSL}^{F,A}$
\end_inset

 and an extractor 
\begin_inset Formula $\text{ex}^{X}:F^{X}\Rightarrow M^{X}$
\end_inset


\end_layout

\begin_layout Itemize
Run the program with the extractor: 
\family typewriter
\size footnotesize
\color blue
run(ex)(prg)
\family default
\size default
\color inherit
; get a value 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The interpreter pattern VIII.
 Monadic DSLs: summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Begin with a number of operations, which are typically functions of fixed
 known types such as 
\begin_inset Formula $A_{1}\Rightarrow B_{1}$
\end_inset

, 
\begin_inset Formula $A_{2}\Rightarrow B_{2}$
\end_inset

 etc.
\end_layout

\begin_layout Itemize
Define a type constructor (typically not a functor) encapsulating all the
 operations as case classes, with or without type parameters
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait F[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Op1(a1: A1) extends F[B1]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Op2(a1: A2) extends F[B2]
\end_layout

\begin_layout Itemize
Use 
\family typewriter
\size footnotesize
\color blue
DSL[F,A]
\family default
\size default
\color inherit
 with this 
\family typewriter
\size footnotesize
\color blue
F
\family default
\size default
\color inherit
 to write monadic DSL programs 
\family typewriter
\size footnotesize
\color blue
prg:
\begin_inset space ~
\end_inset

DSL[F,A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Choose a target monad 
\family typewriter
\size footnotesize
\color blue
M[A]
\family default
\size default
\color inherit
 and implement an extractor 
\family typewriter
\size footnotesize
\color blue
ex:F[A]
\begin_inset Formula $\Rightarrow$
\end_inset

M[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Run the program with the extractor, 
\family typewriter
\size footnotesize
\color blue
val res:
\begin_inset space ~
\end_inset

M[A] = run(ex)(prg)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Further directions (out of scope for this chapter):
\end_layout

\begin_layout Itemize
May choose another monad 
\family typewriter
\size footnotesize
\color blue
N[A]
\family default
\size default
\color inherit
 and use interpreter 
\family typewriter
\size footnotesize
\color blue
M[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 N[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
E.g.
\begin_inset space ~
\end_inset

transform into another monadic DSL to optimize, test, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Since 
\family typewriter
\size footnotesize
\color blue
DSL[F,A]
\family default
\size default
\color inherit
 has a monad API, we can use monad transformers on it
\end_layout

\begin_layout Itemize
Can combine two or more DSLs in a disjunction: 
\begin_inset Formula $\text{DSL}^{F+G+H,A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Monad laws for DSL programs
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Monad laws hold for DSL programs only after evaluating them
\end_layout

\begin_layout Itemize
Consider the law 
\begin_inset Formula $\text{flm}\left(\text{pure}\right)=\text{id}$
\end_inset

; both functions 
\begin_inset Formula $\text{DSL}^{F,A}\Rightarrow\text{DSL}^{F,A}$
\end_inset


\end_layout

\begin_layout Itemize
Apply both sides to some 
\begin_inset Formula $\text{prg}:\text{DSL}^{F,A}$
\end_inset

 and get the new value
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
prg.flatMap(pure) == Bind(prg, a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Literal(a))
\end_layout

\begin_layout Itemize
This new value is 
\emph on
not equal
\emph default
 to 
\family typewriter
\size footnotesize
\color blue
prg
\family default
\size default
\color inherit
, so this monad law fails!
\end_layout

\begin_deeper
\begin_layout Itemize
Other laws fail as well because operations never reduce anything
\end_layout

\end_deeper
\begin_layout Itemize
After interpreting this program into a target monad 
\begin_inset Formula $M^{A}$
\end_inset

, the law holds:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
run(ex)(prg).flatMap((a 
\begin_inset Formula $\Rightarrow$
\end_inset

 Literal(a)) andThen run(ex)) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg).flatMap(a 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(ex)(Literal(a)) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg).flatMap(a 
\begin_inset Formula $\Rightarrow$
\end_inset

 pure(a))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  == run(ex)(prg)
\end_layout

\begin_layout Itemize
Here we have assumed that the laws hold for 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\begin_layout Itemize
All other laws also hold after interpreting into a lawful monad 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The monad law violations are 
\begin_inset Quotes eld
\end_inset

not observable
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Free constructions in mathematics: Example I
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider the Russian letter ц (tsè) and the Chinese word 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

(shu
\begin_inset IPA

\begin_layout Standard
̌i
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
We want to 
\emph on
multiply
\emph default
 ц by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

.
 Multiply how?
\end_layout

\begin_layout Itemize
Say, we want an associative (but noncommutative) product of them
\end_layout

\begin_deeper
\begin_layout Itemize
So we want to define a 
\emph on
semigroup
\emph default
 that 
\emph on
contains
\emph default
 ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

as elements
\end_layout

\begin_deeper
\begin_layout Itemize
while we still know nothing about ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Consider the set of all 
\emph on
unevaluated expressions
\emph default
 such as ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Here ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is different from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц but 
\begin_inset Formula $\left(a\cdot b\right)\cdot c=a\cdot\left(b\cdot c\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
All these expressions form a 
\series bold
free semigroup
\series default
 generated by ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the most unrestricted semigroup that contains ц and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Example calculation: (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)
\begin_inset Formula $\cdot$
\end_inset

(ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)
\begin_inset Formula $\cdot$
\end_inset

ц 
\begin_inset Formula $=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\begin_inset Formula $\cdot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset


\begin_inset Formula $\cdot$
\end_inset

ц
\end_layout

\begin_layout Standard
How to represent this as a data type:
\end_layout

\begin_layout Itemize

\series bold
Tree encoding
\series default
: the full expression tree: (((
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

),(ц,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

)),ц)
\end_layout

\begin_deeper
\begin_layout Itemize
Implement the operation 
\begin_inset Formula $a\cdot b$
\end_inset

 as pair constructor (easy)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Reduced encoding
\series default
, as a 
\begin_inset Quotes eld
\end_inset

smart
\begin_inset Quotes erd
\end_inset

 structure: List(
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,ц,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shui
\end_layout

\end_inset

,ц)
\end_layout

\begin_deeper
\begin_layout Itemize
Implement 
\begin_inset Formula $a\cdot b$
\end_inset

 by concatenating the lists (more expensive)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Free constructions in mathematics: Example II
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Want to define a product operation for 
\begin_inset Formula $n$
\end_inset

-dimensional vectors: 
\begin_inset Formula $\mathbf{v}_{1}\otimes\mathbf{v}_{2}$
\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $\otimes$
\end_inset

 must be linear and distributive (but not commutative):
\begin_inset Formula 
\begin{align*}
\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\left(\mathbf{u}_{2}\otimes\mathbf{v}_{2}+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\right) & =\left(\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}\right)+\mathbf{u}_{3}\otimes\mathbf{v}_{3}\\
\mathbf{u}\otimes\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & =a_{1}\left(\mathbf{u}\otimes\mathbf{v}_{1}\right)+a_{2}\left(\mathbf{u}\otimes\mathbf{v}_{2}\right)\\
\left(a_{1}\mathbf{v}_{1}+a_{2}\mathbf{v}_{2}\right) & \otimes\mathbf{u}=a_{1}\left(\mathbf{v}_{1}\otimes\mathbf{u}\right)+a_{2}\left(\mathbf{v}_{2}\otimes\mathbf{u}\right)
\end{align*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We have such a product for 3-dimensional vectors only; ignore that
\end_layout

\end_deeper
\begin_layout Itemize
Consider 
\emph on
unevaluated
\emph default
 
\emph on
expressions
\emph default
 of the form 
\begin_inset Formula $\mathbf{u}_{1}\otimes\mathbf{v}_{1}+\mathbf{u}_{2}\otimes\mathbf{v}_{2}+...$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A free vector space generated by pairs of vectors
\end_layout

\end_deeper
\begin_layout Itemize
Impose the equivalence relationships shown above
\end_layout

\begin_deeper
\begin_layout Itemize
The result is known as the 
\series bold
tensor product
\end_layout

\end_deeper
\begin_layout Itemize
Tree encoding: full unevaluated expression tree
\end_layout

\begin_deeper
\begin_layout Itemize
A list of any number of vector pairs 
\begin_inset Formula $\sum_{i}\mathbf{u}_{i}\otimes\mathbf{v}_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding: an 
\begin_inset Formula $n\times n$
\end_inset

 matrix
\end_layout

\begin_deeper
\begin_layout Itemize
Reduced encoding requires proofs and more complex operations
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example I: Free semigroup
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Implement a free semigroup 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 generated by two types 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
A value of 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 can be an 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
; it can also be a 
\family typewriter
\size footnotesize
\color blue
String
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
y
\family default
\size default
\color inherit
 are of type 
\family typewriter
\size footnotesize
\color blue
FSIS
\family default
\size default
\color inherit
 then so is 
\family typewriter
\size footnotesize
\color blue
x |+| y
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait FSIS 
\family default
\color darkgray
// tree encoding: full expression tree
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap1(x: Int) extends FSIS
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap2(x: String) extends FSIS
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Comb(x: FSIS, y: FSIS) extends FSIS
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Short type notation: 
\begin_inset Formula $\text{FSIS}\equiv\text{Int}+\text{String}+\text{FSIS}\times\text{FSIS}$
\end_inset

 
\end_layout

\begin_layout Itemize
For a semigroup 
\begin_inset Formula $S$
\end_inset

 and given 
\begin_inset Formula $\text{Int}\Rightarrow S$
\end_inset

 and 
\begin_inset Formula $\text{String}\Rightarrow S$
\end_inset

, map 
\begin_inset Formula $\text{FSIS}\Rightarrow S$
\end_inset


\end_layout

\begin_layout Itemize
Simplify and generalize this construction by setting 
\begin_inset Formula $Z=\text{Int}+\text{String}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The tree encoding is 
\begin_inset Formula $\text{FS}^{Z}\equiv Z+\text{FS}^{Z}\times\text{FS}^{Z}$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def |+|(x: FS[Z], y: FS[Z]): FS[Z] = Comb(x, y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[S: Semigroup, Z](extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 S): FS[Z] 
\begin_inset Formula $\Rightarrow$
\end_inset

 S = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(extract)(x) |+| run(extract)(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} 
\family default
\color darkgray
// Semigroup laws will hold after applying run().
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The reduced encoding is 
\begin_inset Formula $\text{FSR}^{Z}\equiv Z\times\text{List}^{Z}$
\end_inset

 (non-empty list of 
\begin_inset Formula $Z$
\end_inset

's)
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
x |+| y
\family default
\size default
\color inherit
 requires concatenating the lists, but 
\family typewriter
\size footnotesize
\color blue
run()
\family default
\size default
\color inherit
 is faster
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example II: Free monoid
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Implement a free monoid 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 generated by type 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
A value of 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 can be the empty value; it can also be a 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
y
\family default
\size default
\color inherit
 are of type 
\family typewriter
\size footnotesize
\color blue
FM[Z]
\family default
\size default
\color inherit
 then so is 
\family typewriter
\size footnotesize
\color blue
x |+| y
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait FM[Z] 
\family default
\color darkgray
// tree encoding
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Empty[Z]() extends FM[Z]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap[Z](z: Z) extends FM[Z]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Comb[Z](x: FM[Z], y: FM[Z]) extends FM[Z]
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Short type notation: 
\begin_inset Formula $\text{FM}^{Z}\equiv1+Z+\text{FM}^{Z}\times\text{FM}^{Z}$
\end_inset

 
\end_layout

\begin_layout Itemize
For a monoid 
\begin_inset Formula $M$
\end_inset

 and given 
\begin_inset Formula $Z\Rightarrow M$
\end_inset

, map 
\begin_inset Formula $\text{FM}^{Z}\Rightarrow M$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def |+|(x: FM[Z], y: FM[Z]): FM[Z] = Comb(x, y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[M: Monoid, Z](extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 M): FM[Z] 
\begin_inset Formula $\Rightarrow$
\end_inset

 M = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Empty() 
\begin_inset Formula $\Rightarrow$
\end_inset

 Monoid[M].empty
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(extract)(x) |+| run(extract)(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} 
\family default
\color darkgray
// Monoid laws will hold after applying run().
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The reduced encoding is 
\begin_inset Formula $\text{FMR}^{Z}\equiv\text{List}^{Z}$
\end_inset

 (list of 
\begin_inset Formula $Z$
\end_inset

's)
\end_layout

\begin_deeper
\begin_layout Itemize
Implementing 
\family typewriter
\size footnotesize
\color blue
|+|
\family default
\size default
\color inherit
 requires concatenating the lists 
\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding and tree encoding give identical results after 
\family typewriter
\size footnotesize
\color blue
run()
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Mapping a free semigroup to different targets
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
What if we interpret 
\begin_inset Formula $\text{FS}^{X}$
\end_inset

 into 
\emph on
another
\emph default
 free semigroup?
\end_layout

\begin_layout Itemize
Given 
\begin_inset Formula $Y\Rightarrow Z$
\end_inset

, can we map 
\begin_inset Formula $\text{FS}^{Y}\Rightarrow\text{FS}^{Z}$
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
Need to map 
\begin_inset Formula $\text{FS}^{Y}\equiv Y+\text{FS}^{Y}\times\text{FS}^{Y}\Rightarrow Z+\text{FS}^{Z}\times\text{FS}^{Z}$
\end_inset


\end_layout

\begin_layout Itemize
This is straightforward since 
\begin_inset Formula $\text{FS}^{X}$
\end_inset

 is a functor in 
\begin_inset Formula $X$
\end_inset

:
\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def fmap[Y, Z](f: Y 
\begin_inset Formula $\Rightarrow$
\end_inset

 Z): FS[Y] 
\begin_inset Formula $\Rightarrow$
\end_inset

 FS[Z] = {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Wrap(f(y))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(a, b) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Comb(fmap(f)(a), fmap(f)(b))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Now we can use 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 to interpret 
\begin_inset Formula $\text{FS}^{X}\Rightarrow\text{FS}^{Y}\Rightarrow\text{FS}^{Z}\Rightarrow S$
\end_inset

, etc.
\end_layout

\begin_deeper
\begin_layout Itemize
Functor laws hold for 
\begin_inset Formula $\text{FS}^{X}$
\end_inset

, so 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 is composable as usual
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

interpreter
\begin_inset Quotes erd
\end_inset

 commutes with 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 as well (naturality law):
\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & \text{FS}^{Y}\ar[rd]\sp(0.6){\ \text{run}^{S}g^{:Y\Rightarrow S}}\\
\text{FS}^{X}\ar[ru]\sp(0.45){\text{fmap}\,f^{:X\Rightarrow Y}}\ar[rr]\sb(0.5){\text{run}^{S}(f\circ g)^{:X\Rightarrow S}} &  & S
}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Combine two free semigroups: 
\begin_inset Formula $\text{FS}^{X+Y}$
\end_inset

; inject parts: 
\begin_inset Formula $\text{FS}^{X}\Rightarrow\text{FS}^{X+Y}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Church encoding I: Motivation
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\size default
Multiple target semigroups 
\begin_inset Formula $S_{i}$
\end_inset

 require many 
\begin_inset Quotes eld
\end_inset

extractors
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\text{ex}_{i}:Z\Rightarrow S_{i}$
\end_inset


\end_layout

\begin_layout Itemize
Refactor extractors 
\begin_inset Formula $\text{ex}_{i}$
\end_inset

 into evidence of a typeclass constraint on 
\begin_inset Formula $S_{i}$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// Typeclass ExZ[S] has a single method, extract: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 S.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
implicit val exZ: ExZ[MySemigroup] = { z 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
 }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def run[S: ExZ : Semigroup](fs: FS[Z]): S = fs match {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Wrap(z) 
\begin_inset Formula $\Rightarrow$
\end_inset

 implicitly[ExZ[S]].extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  case Comb(x, y) 
\begin_inset Formula $\Rightarrow$
\end_inset

 run(x) |+| run(y)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\family typewriter
\color blue
run()
\family default
\size default
\color inherit
 replaces case classes by fixed functions parameterized by 
\family typewriter
\size footnotesize
\color blue
S:
\begin_inset space ~
\end_inset

ExZ
\family default
\size default
\color inherit
; instead we can represent 
\family typewriter
\size footnotesize
\color blue
FS[Z]
\family default
\size default
\color inherit
 directly by such functions, for example:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def wrap[S: ExZ](z: Z): S = implicitly[ExZ[S]].extract(z)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def x[S: ExZ : Semigroup]: S = wrap(1) |+| wrap(2)
\end_layout

\begin_layout Itemize
The type of 
\family typewriter
\size footnotesize
\color blue
x
\family default
\size default
\color inherit
 is 
\size footnotesize

\begin_inset Formula $\forall S.\left(Z\Rightarrow S\right)\times\left(S\times S\Rightarrow S\right)\Rightarrow S$
\end_inset


\size default
; an equivalent type is
\size footnotesize

\begin_inset Formula 
\[
\forall S.\left(\left(Z+S\times S\right)\Rightarrow S\right)\Rightarrow S
\]

\end_inset


\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\size default
This is the 
\begin_inset Quotes eld
\end_inset


\series bold
Church encoding
\series default

\begin_inset Quotes erd
\end_inset

 (of the free semigroup over 
\begin_inset Formula $Z$
\end_inset

)
\end_layout

\begin_layout Itemize
The Church encoding is based on the theorem 
\size footnotesize

\begin_inset Formula $A\cong\forall X.\left(A\Rightarrow X\right)\Rightarrow X$
\end_inset


\size default
 
\end_layout

\begin_deeper
\begin_layout Itemize
this 
\emph on
resembles
\emph default
 the type of the continuation monad, 
\begin_inset Formula $\left(A\Rightarrow R\right)\Rightarrow R$
\end_inset

 
\end_layout

\begin_layout Itemize
but 
\begin_inset Formula $\forall X$
\end_inset

 makes the function fully generic, like a natural transformation
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Church encoding II: Disjunction types
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Consider the Church encoding for the disjunction type 
\begin_inset Formula $P+Q$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
The encoding is 
\size footnotesize

\begin_inset Formula $\forall X.\left(P+Q\Rightarrow X\right)\Rightarrow X\cong\forall X.\left(P\Rightarrow X\right)\Rightarrow\left(Q\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
trait Disj[P, Q] { def run[X](cp: P 
\begin_inset Formula $\Rightarrow$
\end_inset

 X)(cq: Q 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X }
\end_layout

\begin_layout Itemize
Define some values of this type:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def left[P, Q](p: P) = new Disj[P, Q] {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 def run[X](cp: P 
\begin_inset Formula $\Rightarrow$
\end_inset

 X)(cq: Q 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X = cp(p) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\size default
Now we can implement the analog of the 
\family typewriter
\size footnotesize
\color blue
case
\family default
\size default
\color inherit
 expression simply as
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = disj.run {p 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...} {q 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...}
\end_layout

\begin_layout Itemize
This works in programming languages that have no disjunction types
\end_layout

\begin_layout Standard
General recipe for implementing the Church encoding: 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
trait Blah { def run[X](cont: ...
 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X }
\end_layout

\begin_layout Itemize
For convenience, define a type class 
\family typewriter
\size footnotesize
\color blue
Ex
\family default
\size default
\color inherit
 describing the inner function:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
trait Ex[X] { def cp: P 
\begin_inset Formula $\Rightarrow$
\end_inset

 X; def cq: Q 
\begin_inset Formula $\Rightarrow$
\end_inset

 X }
\end_layout

\begin_layout Itemize
Different methods of this class return 
\family typewriter
\size footnotesize
\color blue
X
\family default
\size default
\color inherit
; convenient with disjunctions
\end_layout

\end_deeper
\begin_layout Itemize
Church-encoded types have to be 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 for pattern-matching
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Church encoding III: How it works
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Why is the type 
\begin_inset Formula $\text{Ch}^{A}\equiv\forall X.\left(A\Rightarrow X\right)\Rightarrow X$
\end_inset

 equivalent to the type 
\begin_inset Formula $A$
\end_inset

?
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
trait Ch[A] { def run[X](cont: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X }
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "65text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\size default
If we have a value of 
\begin_inset Formula $A$
\end_inset

, we can get a 
\begin_inset Formula $\text{Ch}^{A}$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\family typewriter
\color blue
def a2c[A](a: A): Ch[A] = new Ch[A] { 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  def run[X](cont: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 X): X = cont(a)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset


\size default
If we have a 
\begin_inset Formula $\text{ch}:\text{Ch}^{A}$
\end_inset

, we can get an 
\begin_inset Formula $a:A$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5cm}
\end_layout

\end_inset


\family typewriter
\color blue
def c2a[A](ch: Ch[A]): A = ch.run[A](a
\begin_inset Formula $\Rightarrow$
\end_inset

a)
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc}\text{id}:\left(A\Rightarrow A\right)\ar[r]\sp(0.65){\text{ch}.\text{run}^{A}}\ar[d]\sp(0.5){\text{fmap}_{\text{Reader}_{A}}\left(f\right)} & A\ar[d]\sp(0.45){f}\\
f:\left(A\Rightarrow X\right)\ar[r]\sb(0.65){\text{ch}.\text{run}^{X}} & X
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Itemize
The functions 
\family typewriter
\size footnotesize
\color blue
a2c
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
c2a
\family default
\size default
\color inherit
 are inverses of each other
\end_layout

\begin_deeper
\begin_layout Itemize
To implement a value 
\begin_inset Formula $\text{ch}^{:\text{Ch}^{A}}$
\end_inset

, we must compute an 
\begin_inset Formula $x^{:X}$
\end_inset

 given 
\begin_inset Formula $f^{:A\Rightarrow X}$
\end_inset

, for 
\emph on
any
\emph default
 
\begin_inset Formula $X$
\end_inset

, which 
\emph on
requires
\emph default
 having a value 
\begin_inset Formula $a^{:A}$
\end_inset

 available
\end_layout

\end_deeper
\begin_layout Itemize
To show that 
\family typewriter
\size footnotesize
\color blue
ch = a2c(c2a(ch))
\family default
\size default
\color inherit
, apply both sides to an 
\family typewriter
\size footnotesize
\color blue
f:
\begin_inset space ~
\end_inset

A
\begin_inset Formula $\Rightarrow$
\end_inset

X
\family default
\size default
\color inherit
 and get 
\family typewriter
\size footnotesize
\color blue
ch.run(f) = a2c(c2a(ch)).run(f) = f(c2a(ch)) = f(ch.run(a
\begin_inset Formula $\Rightarrow$
\end_inset

a))
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
This is naturality of 
\family typewriter
\size footnotesize
\color blue
ch.run
\family default
\size default
\color inherit
 as a transformation between 
\family typewriter
\size footnotesize
\color blue
Reader
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Id
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Naturality of 
\family typewriter
\size footnotesize
\color blue
ch.run
\family default
\size default
\color inherit
 follows from parametricity of its code
\end_layout

\end_deeper
\begin_layout Itemize
It is straightforward to compute 
\family typewriter
\size footnotesize
\color blue
c2a(a2c(a)) = identity(a) = a
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Itemize
Church encoding satisfies laws: it is built up from parts of 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 method
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example III: Free functor I
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue
Functor
\family default
\size default
\color inherit
 type class has one method, 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
: 
\begin_inset Formula $\left(Z\Rightarrow A\right)\Rightarrow F^{Z}\Rightarrow F^{A}$
\end_inset

 
\end_layout

\begin_layout Itemize
The tree encoding of a free functor over 
\begin_inset Formula $F^{\bullet}$
\end_inset

 needs two case classes:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait FF[F[_], A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Wrap[F[_], A](fa: F[A]) extends FF[F, A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Fmap[F[_], A, Z](f: Z ⇒ A)(ffz: FF[F, Z]) extends FF[F, A]
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
The constructor 
\family typewriter
\size footnotesize
\color blue
Fmap
\family default
\size default
\color inherit
 has an extra type parameter 
\begin_inset Formula $Z$
\end_inset

, which is 
\begin_inset Quotes eld
\end_inset

hidden
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Consider a simple example of this:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Q[A]; case class QZ[A, Z](a: A, z: Z) extends Q[A]
\end_layout

\begin_layout Itemize
Need to use specific type 
\begin_inset Formula $Z$
\end_inset

 when constructing a value of 
\family typewriter
\size footnotesize
\color blue
Q[A]
\family default
\size default
\color inherit
, e.g.,
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val q: Q[Int] = QZ[Int, String](123, "abc")
\end_layout

\begin_layout Itemize
The type 
\begin_inset Formula $Z$
\end_inset

 is hidden inside 
\begin_inset Formula $q:Q^{\text{Int}}$
\end_inset

; all we know is that 
\begin_inset Formula $Z$
\end_inset

 
\begin_inset Quotes eld
\end_inset

exists
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Type notation for this: 
\begin_inset Formula $Q^{A}\equiv\exists Z.A\times Z$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The existential quantifier applies to the 
\begin_inset Quotes eld
\end_inset

hidden
\begin_inset Quotes erd
\end_inset

 type parameter
\end_layout

\begin_layout Itemize
The constructor 
\family typewriter
\size footnotesize
\color blue
QZ
\family default
\size default
\color inherit
 has type 
\begin_inset Formula $\exists Z.\left(A\times Z\Rightarrow Q^{A}\right)$
\end_inset


\end_layout

\begin_layout Itemize
It is not 
\begin_inset Formula $\forall Z$
\end_inset

 because a specific 
\begin_inset Formula $Z$
\end_inset

 is used when building up a value
\end_layout

\begin_layout Itemize
The code does not show 
\begin_inset Formula $\exists Z$
\end_inset

 explicitly! We need to keep track of that
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Encoding with an existential type: How it works
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Show that 
\begin_inset Formula $P^{A}\equiv\exists Z.Z\times\left(Z\Rightarrow A\right)\cong A$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\family typewriter
\color blue
sealed trait P[A]; case class PZ[A, Z](z: Z, f: Z 
\begin_inset Formula $\Rightarrow$
\end_inset

 A) extends P[A]
\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
How to construct a value of type 
\begin_inset Formula $P^{A}$
\end_inset

 for a given 
\begin_inset Formula $A$
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
Have a function 
\begin_inset Formula $Z\Rightarrow A$
\end_inset

 and a 
\begin_inset Formula $Z$
\end_inset

, construct 
\begin_inset Formula $Z\times\left(Z\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout Itemize
Particular case: 
\begin_inset Formula $Z\equiv A$
\end_inset

, have 
\begin_inset Formula $a:A$
\end_inset

 and build 
\begin_inset Formula $a\times\text{id}^{:A\Rightarrow A}$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def a2p[A](a: A): P[A] = PZ[A, A](a, identity)
\end_layout

\end_deeper
\begin_layout Itemize
Cannot extract 
\begin_inset Formula $Z$
\end_inset

 out of 
\begin_inset Formula $P^{A}$
\end_inset

 – the type 
\begin_inset Formula $Z$
\end_inset

 is hidden
\end_layout

\begin_layout Itemize

\emph on
Can
\emph default
 extract 
\begin_inset Formula $A$
\end_inset

 out of 
\begin_inset Formula $P^{A}$
\end_inset

 – do not need to know 
\begin_inset Formula $Z$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def p2a[A]: P[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 A = { case PZ(z, f) 
\begin_inset Formula $\Rightarrow$
\end_inset

 f(z) }
\end_layout

\end_deeper
\begin_layout Itemize
Cannot transform 
\begin_inset Formula $P^{A}$
\end_inset

 into anything else other than 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Itemize
A value of type 
\begin_inset Formula $P^{A}$
\end_inset

 is observable only via 
\family typewriter
\size footnotesize
\color blue
p2a
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Therefore the functions 
\family typewriter
\size footnotesize
\color blue
a2p
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
p2a
\family default
\size default
\color inherit
 are 
\begin_inset Quotes eld
\end_inset

observational
\begin_inset Quotes erd
\end_inset

 inverses (i.e.
\begin_inset space ~
\end_inset

we need to use 
\family typewriter
\size footnotesize
\color blue
p2a
\family default
\size default
\color inherit
 in order to compare values of type 
\begin_inset Formula $P^{A}$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
If 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a functor then 
\begin_inset Formula $Q^{A}\equiv\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)\cong F^{A}$
\end_inset


\end_layout

\begin_layout Itemize
A value of 
\begin_inset Formula $Q^{A}$
\end_inset

 can be observed only by extracting an 
\begin_inset Formula $F^{A}$
\end_inset

 from it
\end_layout

\begin_layout Itemize
Can define 
\family typewriter
\size footnotesize
\color blue
f2q
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
q2f
\family default
\size default
\color inherit
 and show that they are observational inverses
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example III: Free functor II
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tree encoding of 
\family typewriter
\size footnotesize
\color blue
FF
\family default
\size default
\color inherit
 has type 
\begin_inset Formula $\text{FF}^{F^{\bullet},A}\equiv F^{A}+\exists Z.\text{FF}^{F^{\bullet},Z}\times\left(Z\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout Itemize
Derivation of the reduced encoding:
\end_layout

\begin_deeper
\begin_layout Itemize
A value of type 
\begin_inset Formula $\text{FF}^{F^{\bullet},A}$
\end_inset

 must be of the form 
\size footnotesize

\begin_inset Formula 
\[
\exists Z_{1}.\exists Z_{2}...\exists Z_{n}.F^{Z_{n}}\times\left(Z_{n}\Rightarrow Z_{n-1}\right)\times...\times\left(Z_{2}\Rightarrow Z_{1}\right)\times\left(Z_{1}\Rightarrow A\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
The functions 
\begin_inset Formula $Z_{1}\Rightarrow A$
\end_inset

, 
\begin_inset Formula $Z_{2}\Rightarrow Z_{1}$
\end_inset

, etc., must be composed associatively
\end_layout

\begin_layout Itemize
The equivalent type is 
\begin_inset Formula $\exists Z_{n}.F^{Z_{n}}\times\left(Z_{n}\Rightarrow A\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding: 
\begin_inset Formula $\text{FreeF}^{F^{\bullet},A}\equiv\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Substituted 
\begin_inset Formula $F^{Z}$
\end_inset

 instead of 
\begin_inset Formula $\text{FreeF}^{F^{\bullet},Z}$
\end_inset

 and eliminated the case 
\begin_inset Formula $F^{A}$
\end_inset


\end_layout

\begin_layout Itemize
The reduced encoding is non-recursive
\end_layout

\begin_layout Itemize
Requires a proof that this encoding is equivalent to the tree encoding
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is already a functor, can show 
\begin_inset Formula $F^{A}\cong\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Church encoding (starting from the tree encoding): 
\begin_inset Formula $\text{FreeF}^{F^{\bullet},A}\equiv\forall P^{\bullet}.\left(\forall C.\big(F^{C}+\exists Z.P^{Z}\times\left(Z\Rightarrow C\right)\big)↝P^{C}\right)\Rightarrow P^{A}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The structure of the type expression: 
\begin_inset Formula $\forall P^{\bullet}.\left(\forall C.(...)^{C}↝P^{C}\right)\Rightarrow P^{A}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Cannot move 
\begin_inset Formula $\forall C$
\end_inset

 or 
\begin_inset Formula $\exists Z$
\end_inset

 to the outside of the type expression!
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Church encoding IV: Recursive types and type constructors
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider the recursive type 
\size footnotesize

\begin_inset Formula $P\equiv Z+P\times P$
\end_inset


\size default
 (tree with 
\begin_inset Formula $Z$
\end_inset

-valued leaves)
\end_layout

\begin_deeper
\begin_layout Itemize
The Church encoding is 
\size footnotesize

\begin_inset Formula $\forall X.\left(\left(Z+X\times X\right)\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\begin_layout Itemize
This is 
\emph on
non-recursive
\emph default
: the inductive use of 
\begin_inset Formula $P$
\end_inset

 is replaced by 
\begin_inset Formula $X$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Generalize to recursive type 
\begin_inset Formula $P\equiv S^{P}$
\end_inset

 where 
\begin_inset Formula $S^{\bullet}$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

induction functor
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
The Church encoding of 
\begin_inset Formula $P$
\end_inset

 is 
\size footnotesize

\begin_inset Formula $\forall X.\left(S^{X}\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Church encoding of recursive types is non-recursive
\end_layout

\begin_layout Itemize
Example: Church encoding of 
\family typewriter
\size footnotesize
\color blue
List[Int]
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Church encoding of a type constructor 
\begin_inset Formula $P^{\bullet}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Notation: 
\begin_inset Formula $P^{\bullet}$
\end_inset

 is a type function; Scala syntax is 
\family typewriter
\size footnotesize
\color blue
P[_]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
The Church encoding is 
\size footnotesize

\begin_inset Formula $\text{Ch}^{P^{\bullet},A}=\forall F^{\bullet}.\left(\forall X.P^{X}\Rightarrow F^{X}\right)\Rightarrow F^{A}$
\end_inset


\end_layout

\begin_layout Itemize
Note: 
\begin_inset Formula $\forall X.P^{X}\Rightarrow F^{X}$
\end_inset

 or 
\begin_inset Formula $P^{\bullet}↝F^{\bullet}$
\end_inset

 resembles a natural transformation
\end_layout

\begin_deeper
\begin_layout Itemize
Except that 
\begin_inset Formula $P^{\bullet}$
\end_inset

 and 
\begin_inset Formula $F^{\bullet}$
\end_inset

 are not necessarily functors, so no naturality law
\end_layout

\end_deeper
\begin_layout Itemize
Example: Church encoding of 
\family typewriter
\size footnotesize
\color blue
Option[_]
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Itemize
Church encoding of a 
\emph on
recursively
\emph default
 defined type constructor 
\begin_inset Formula $P^{\bullet}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Definition: 
\begin_inset Formula $P^{A}\equiv S^{P^{\bullet},A}$
\end_inset

 where 
\begin_inset Formula $S^{P^{\bullet},A}$
\end_inset

 describes the 
\begin_inset Quotes eld
\end_inset

induction principle
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Notation: 
\size footnotesize

\begin_inset Formula $S^{\bullet^{\bullet},A}$
\end_inset


\size default
 is a higher-order type function; Scala syntax: 
\family typewriter
\size footnotesize
\color blue
S[_[_],A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset


\size default
Example: 
\begin_inset Formula $\text{List}^{A}\equiv1+A\times\text{List}^{A}\equiv S^{\text{List}^{\bullet},A}$
\end_inset

 where 
\begin_inset Formula $S^{P^{\bullet},A}\equiv1+A\times P^{A}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
The Church encoding of 
\begin_inset Formula $P^{A}$
\end_inset

 is 
\size footnotesize

\begin_inset Formula $\text{Ch}^{P^{\bullet},A}=\forall F^{\bullet}.\big(S^{F^{\bullet}}↝F^{\bullet}\big)\Rightarrow F^{A}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The Church encoding of 
\family typewriter
\size footnotesize
\color blue
List[_]
\family default
\size default
\color inherit
 is non-recursive
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Church encoding V: Type classes
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Look at the Church encoding of the free semigroup:
\size footnotesize

\begin_inset Formula 
\[
\text{ChFS}^{Z}\equiv\forall X.\left(Z\Rightarrow X\right)\times\left(X\times X\Rightarrow X\right)\Rightarrow X
\]

\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $X$
\end_inset

 is constrained to the 
\family typewriter
\size footnotesize
\color blue
Semigroup
\family default
\size default
\color inherit
 typeclass, we will already have a value 
\size footnotesize

\begin_inset Formula $X\times X\Rightarrow X$
\end_inset


\size default
, so we can omit it: 
\size footnotesize

\begin_inset Formula $\text{ChFS}^{Z}=\forall X^{:\text{Semigroup}}.\left(Z\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

induction functor
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

semigroup over 
\begin_inset Formula $Z$
\end_inset


\begin_inset Quotes erd
\end_inset

 is 
\size footnotesize

\begin_inset Formula $\text{SemiG}^{X}\equiv Z+X\times X$
\end_inset


\end_layout

\begin_layout Itemize
So the Church encoding is 
\begin_inset Formula $\forall X.\big(\text{SemiG}^{X}\Rightarrow X\big)\Rightarrow X$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Generalize to arbitrary type classes:
\end_layout

\begin_layout Itemize
Type class 
\begin_inset Formula $C$
\end_inset

 is defined by its operations
\size footnotesize
 
\begin_inset Formula $C^{X}\Rightarrow X$
\end_inset


\size default
 (with a suitable 
\begin_inset Formula $C^{\bullet}$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
call 
\begin_inset Formula $C^{\bullet}$
\end_inset

 the 
\series bold
method functor
\series default
 of the inductive typeclass 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Tree encoding of 
\begin_inset Quotes eld
\end_inset

free 
\begin_inset Formula $C$
\end_inset

 over 
\begin_inset Formula $Z$
\end_inset


\begin_inset Quotes erd
\end_inset

 is recursive, 
\begin_inset Formula $\text{FreeC}^{Z}\equiv Z+C^{\text{FreeC}^{Z}}$
\end_inset


\end_layout

\begin_layout Itemize
Church encoding is 
\begin_inset Formula $\text{FreeC}^{Z}\equiv\forall X.\left(Z+C^{X}\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Equivalently, 
\begin_inset Formula $\text{FreeC}^{Z}\equiv\forall X^{:C}.\left(Z\Rightarrow X\right)\Rightarrow X$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Laws of the typeclass are satisfied automatically after 
\begin_inset Quotes eld
\end_inset

running
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Works similarly for type constructors: operations 
\begin_inset Formula $C^{P^{\bullet},A}\Rightarrow P^{A}$
\end_inset


\end_layout

\begin_layout Itemize
Free typeclass 
\begin_inset Formula $C$
\end_inset

 over 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is 
\begin_inset Formula $\text{FreeC}^{F^{\bullet},A}\equiv\forall P^{\bullet:C}.\left(F^{\bullet}↝P^{\bullet}\right)\Rightarrow P^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Properties of free type constructions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Generalizing from our examples so far:
\end_layout

\begin_layout Itemize
We 
\begin_inset Quotes eld
\end_inset

enriched
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $Z$
\end_inset

 to a monoid 
\begin_inset Formula $\text{FM}^{Z}$
\end_inset

, and 
\begin_inset Formula $F^{A}$
\end_inset

 to a monad 
\begin_inset Formula $\text{DSL}^{F,A}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

enrichment
\begin_inset Quotes erd
\end_inset

 adds case classes representing the needed operations
\end_layout

\begin_layout Itemize
Works for a generating type 
\begin_inset Formula $Z$
\end_inset

 and for a generating type constructor 
\begin_inset Formula $F^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Obtain a 
\series bold
free type construction
\series default
, which performs no computations
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\text{FM}^{Z}$
\end_inset

 wraps 
\begin_inset Formula $Z$
\end_inset

 in 
\begin_inset Quotes eld
\end_inset

just enough
\begin_inset Quotes erd
\end_inset

 stuff to make it look like a monoid
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{FreeF}^{F^{\bullet},A}$
\end_inset

 wraps 
\begin_inset Formula $F^{A}$
\end_inset

 in 
\begin_inset Quotes eld
\end_inset

just enough
\begin_inset Quotes erd
\end_inset

 stuff to make it look like a functor
\end_layout

\end_deeper
\begin_layout Itemize
A value of a free construction can be 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 to yield non-free values 
\end_layout

\begin_layout Standard
Questions:
\end_layout

\begin_layout Itemize
Can we construct a free typeclass 
\begin_inset Formula $C$
\end_inset

 over any type constructor 
\begin_inset Formula $F^{A}$
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
Yes, with typeclasses: (contra)functor, filterable, monad, applicative
\end_layout

\end_deeper
\begin_layout Itemize
Which of the possible encodings to use?
\end_layout

\begin_deeper
\begin_layout Itemize
Tree encoding, reduced encodings, Church encoding
\end_layout

\end_deeper
\begin_layout Itemize
What are the laws for the
\size footnotesize
 
\begin_inset Formula $\text{FreeC}^{F,A}$
\end_inset


\size default
 – 
\begin_inset Quotes eld
\end_inset

free instance of 
\begin_inset Formula $C$
\end_inset

 over 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_deeper
\begin_layout Itemize
For all 
\begin_inset Formula $F^{\bullet}$
\end_inset

, must have 
\family typewriter
\size footnotesize
\color blue
wrap[A]
\family default
\size default
\color inherit
 
\begin_inset Formula $:F^{A}\Rightarrow\text{FreeC}^{F,A}$
\end_inset

 or 
\begin_inset Formula $F^{\bullet}↝\text{FreeC}^{F,\bullet}$
\end_inset


\end_layout

\begin_layout Itemize
For all 
\begin_inset Formula $M^{\bullet}:C$
\end_inset

, must have 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
 
\begin_inset Formula $:\left(F^{\bullet}\leadsto M^{\bullet}\right)\Rightarrow\text{FreeC}^{F,\bullet}↝M^{\bullet}$
\end_inset


\end_layout

\begin_layout Itemize
The laws of typeclass 
\begin_inset Formula $C$
\end_inset

 must hold after interpreting into an 
\begin_inset Formula $M^{\bullet}:C$
\end_inset


\end_layout

\begin_layout Itemize
Given any 
\family typewriter
\size footnotesize
\color blue
t
\family default
\size default
\color inherit

\begin_inset Formula $:F^{\bullet}↝G^{\bullet}$
\end_inset

, must have 
\family typewriter
\size footnotesize
\color blue
fmap(t)
\family default
\size default
\color inherit

\begin_inset Formula $:\text{FreeC}^{F,\bullet}↝\text{FreeC}^{G,\bullet}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Recipes for encoding free typeclass instances
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Build a free instance of typeclass 
\begin_inset Formula $C$
\end_inset

 over 
\begin_inset Formula $F^{\bullet}$
\end_inset

, as a type constructor 
\begin_inset Formula $P^{\bullet}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
The typeclass 
\begin_inset Formula $C$
\end_inset

 can be functor, contrafunctor, monad, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Assume that 
\begin_inset Formula $C$
\end_inset

 has methods 
\begin_inset Formula $m_{1}$
\end_inset

, 
\begin_inset Formula $m_{2}$
\end_inset

, ..., with type signatures 
\size footnotesize

\begin_inset Formula $m_{1}:Q_{1}^{P^{\bullet},A}\Rightarrow P^{A}$
\end_inset


\size default
, 
\size footnotesize

\begin_inset Formula $m_{2}:Q_{2}^{P^{\bullet},A}\Rightarrow P^{A}$
\end_inset


\size default
, etc., where 
\begin_inset Formula $Q_{i}^{P^{\bullet},A}$
\end_inset

 are covariant in 
\begin_inset Formula $P^{\bullet}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Inductive typeclass
\series default
 is defined via a methods functor, 
\begin_inset Formula $S^{P^{\bullet}}↝P^{\bullet}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The tree encoded 
\begin_inset Formula $\text{FC}^{A}$
\end_inset

 is a disjunction defined recursively by
\size footnotesize

\begin_inset Formula 
\[
\text{FC}^{A}\equiv F^{A}+Q_{1}^{\text{FC}^{\bullet},A}+Q_{2}^{\text{FC}^{\bullet},A}+...
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\family typewriter
\color blue
sealed trait FC[A]; case class Wrap[A](fa: F[A]) extends FC[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Q1[A](...) extends FC[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Q2[A](...) extends FC[A]; ...
\end_layout

\begin_layout Itemize
Any type parameters within 
\begin_inset Formula $Q_{i}$
\end_inset

 are then existentially quantified
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
run()
\family default
\size default
\color inherit
 maps 
\begin_inset Formula $F^{\bullet}↝M^{\bullet}$
\end_inset

 in the disjunction and recursively for other parts
\end_layout

\end_deeper
\begin_layout Itemize
Derive a reduced encoding via reasoning about possible values of 
\begin_inset Formula $\text{FC}^{A}$
\end_inset

 and by taking into account the laws of the typeclass 
\begin_inset Formula $C$
\end_inset


\end_layout

\begin_layout Itemize
A Church encoding can use the tree encoding or the reduced encoding
\end_layout

\begin_deeper
\begin_layout Itemize
Church encoding is 
\begin_inset Quotes eld
\end_inset

automatically reduced
\begin_inset Quotes erd
\end_inset

, but performance may differ
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Properties of inductive typeclasses
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
If a typeclass 
\begin_inset Formula $C$
\end_inset

 is inductive with methods 
\begin_inset Formula $C^{X}\Rightarrow X$
\end_inset

 then:
\end_layout

\begin_layout Itemize
A free instance of 
\begin_inset Formula $C$
\end_inset

 over 
\begin_inset Formula $Z$
\end_inset

 can be tree-encoded as 
\size footnotesize

\begin_inset Formula $\text{FreeC}^{Z}\equiv Z+C^{\text{FreeC}^{Z}}$
\end_inset


\size default
 
\end_layout

\begin_deeper
\begin_layout Itemize
All inductive typeclasses have free instances, 
\begin_inset Formula $\text{FreeC}^{Z}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If 
\begin_inset Formula $P^{:C}$
\end_inset

 and 
\begin_inset Formula $Q^{:C}$
\end_inset

 then 
\begin_inset Formula $P\times Q$
\end_inset

 and 
\begin_inset Formula $Z\Rightarrow P$
\end_inset

 also belong to typeclass 
\begin_inset Formula $C$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
but not necessarily 
\begin_inset Formula $P+Q$
\end_inset

 or 
\begin_inset Formula $Z\times P$
\end_inset


\end_layout

\begin_layout Itemize
Proof: can implement 
\begin_inset Formula $(C^{P}\Rightarrow P)\times(C^{Q}\Rightarrow Q)\Rightarrow C^{P\times Q}\Rightarrow P\times Q$
\end_inset

 and 
\begin_inset Formula $\left(C^{P}\Rightarrow P\right)\Rightarrow C^{Z\Rightarrow P}\Rightarrow Z\Rightarrow P$
\end_inset

, but cannot implement 
\begin_inset Formula $\left(...\right)\Rightarrow P+Q$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Analogous properties hold for type constructor typeclasses
\end_layout

\begin_deeper
\begin_layout Itemize
Methods described as 
\begin_inset Formula $C^{F^{\bullet},A}\Rightarrow F^{A}$
\end_inset

 with type constructor parameter 
\begin_inset Formula $F^{\bullet}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
What typeclasses 
\emph on
cannot
\emph default
 be tree-encoded (or have no 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 instances)?
\end_layout

\begin_layout Itemize
Any typeclass with a method 
\emph on
not ultimately returning
\emph default
 a value of 
\begin_inset Formula $P^{A}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Example: a typeclass with methods 
\begin_inset Formula $\text{pt}:A\Rightarrow P^{A}$
\end_inset

 and 
\begin_inset Formula $\text{ex}:P^{A}\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Such typeclasses are not inductive
\end_layout

\begin_deeper
\begin_layout Itemize
Typeclasses with methods of the form 
\begin_inset Formula $P^{A}\Rightarrow...$
\end_inset

 are 
\series bold
co-inductive
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example IV: Free contrafunctor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Method 
\begin_inset Formula $\text{contramap}:C^{A}\times\left(B\Rightarrow A\right)\Rightarrow C^{B}$
\end_inset

 
\end_layout

\begin_layout Itemize
Tree encoding: 
\begin_inset Formula $\text{FreeCF}^{F^{\bullet},B}\equiv F^{B}+\exists A.\text{FreeCF}^{F^{\bullet},A}\times\left(B\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout Itemize
Reduced encoding: 
\begin_inset Formula $\text{FreeCF}^{F^{\bullet},B}\equiv\exists A.F^{A}\times\left(B\Rightarrow A\right)$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
A value of type 
\begin_inset Formula $\text{FreeCF}^{F^{\bullet},B}$
\end_inset

 must be of the form 
\size footnotesize

\begin_inset Formula 
\[
\exists Z_{1}.\exists Z_{2}...\exists Z_{n}.F^{Z_{1}}\times\left(B\Rightarrow Z_{n}\right)\left(Z_{n}\Rightarrow Z_{n-1}\right)\times...\times\left(Z_{2}\Rightarrow Z_{1}\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
The functions 
\begin_inset Formula $B\Rightarrow Z_{n}$
\end_inset

, 
\begin_inset Formula $Z_{n}\Rightarrow Z_{n-1}$
\end_inset

, etc., are composed associatively
\end_layout

\begin_layout Itemize
The equivalent type is 
\begin_inset Formula $\exists Z_{1}.F^{Z_{1}}\times\left(B\Rightarrow Z_{1}\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The reduced encoding is non-recursive
\end_layout

\begin_layout Itemize
Example: 
\begin_inset Formula $F^{A}\equiv A$
\end_inset

, 
\begin_inset Quotes eld
\end_inset

interpret
\begin_inset Quotes erd
\end_inset

 into the contrafunctor 
\begin_inset Formula $C^{A}\equiv A\Rightarrow\text{String}$
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\family typewriter
\color blue
def prefixLog[A](p: A): A 
\begin_inset Formula $\Rightarrow$
\end_inset

 String = a 
\begin_inset Formula $\Rightarrow$
\end_inset

 p.toString + a.toString
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is already a contrafunctor then 
\begin_inset Formula $\text{FreeCF}^{F^{\bullet},A}\cong F^{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example V: Free pointed functor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Over an arbitrary type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

:
\end_layout

\begin_layout Itemize
Pointed functor methods 
\size footnotesize

\begin_inset Formula $\text{pt}:A\Rightarrow\text{P}^{A}$
\end_inset


\size default
 and 
\size footnotesize

\begin_inset Formula $\text{map}:P^{A}\times\left(A\Rightarrow B\right)\Rightarrow P^{B}$
\end_inset


\end_layout

\begin_layout Itemize
Tree encoding: 
\size footnotesize

\begin_inset Formula $\text{FreeP}^{F^{\bullet},A}\equiv A+F^{A}+\exists Z.\text{FreeP}^{F^{\bullet},Z}\times\left(Z\Rightarrow A\right)$
\end_inset


\end_layout

\begin_layout Itemize
Derivation of the reduced encoding:
\end_layout

\begin_deeper
\begin_layout Itemize
The tree encoding of a value 
\begin_inset Formula $\text{FreeP}^{F^{\bullet},A}$
\end_inset

 is either
\size footnotesize

\begin_inset Formula 
\[
\exists Z_{1}.\exists Z_{2}...\exists Z_{n}.F^{Z_{n}}\times\left(Z_{n}\Rightarrow Z_{n-1}\right)\times...\times\left(Z_{2}\Rightarrow Z_{1}\right)\times\left(Z_{1}\Rightarrow A\right)
\]

\end_inset


\size default
or
\size footnotesize

\begin_inset Formula 
\[
\exists Z_{1}.\exists Z_{2}...\exists Z_{n}.Z_{n}\times\left(Z_{n}\Rightarrow Z_{n-1}\right)\times...\times\left(Z_{2}\Rightarrow Z_{1}\right)\times\left(Z_{1}\Rightarrow A\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
Compose all functions by associativity; one function 
\begin_inset Formula $Z_{n}\Rightarrow A$
\end_inset

 remains
\end_layout

\begin_layout Itemize
The case 
\begin_inset Formula $\exists Z_{n}.Z_{n}\times\left(Z_{n}\Rightarrow A\right)$
\end_inset

 is equivalent to just 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding: 
\size footnotesize

\begin_inset Formula $\text{FreeP}^{F^{\bullet},A}\equiv A+\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)$
\end_inset

, 
\size default
non-recursive
\end_layout

\begin_layout Itemize
This reuses the free functor as 
\begin_inset Formula $\text{FreeP}^{F^{\bullet},A}=A+\text{FreeF}^{F^{\bullet},A}$
\end_inset


\end_layout

\begin_layout Standard
If the type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is 
\emph on
already
\emph default
 a functor, 
\begin_inset Formula $\text{FreeF}^{F^{\bullet},A}\cong F^{A}$
\end_inset

 and so:
\end_layout

\begin_layout Itemize
Free pointed functor over a functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is simplified: 
\begin_inset Formula $A+F^{A}$
\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is already a pointed functor, need not use the free construction
\end_layout

\begin_deeper
\begin_layout Itemize
If we do, we will have 
\begin_inset Formula $\text{FreeP}^{F^{\bullet},A}\not\cong F^{A}$
\end_inset

 
\end_layout

\begin_layout Itemize
only functors and contrafunctors do not change under 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example VI: Free filterable functor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
(See Chapter 6.) Methods:
\begin_inset Formula 
\begin{align*}
\text{map} & :F^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow F^{B}\\
\text{mapOpt} & :F^{A}\Rightarrow\left(A\Rightarrow1+B\right)\Rightarrow F^{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
We can recover 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 from 
\family typewriter
\size footnotesize
\color blue
mapOpt
\family default
\size default
\color inherit
, so we keep only 
\family typewriter
\size footnotesize
\color blue
mapOpt
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Tree encoding: 
\begin_inset Formula $\text{FreeFi}^{F^{\bullet},A}\equiv F^{A}+\exists Z.\text{FreeFi}^{F^{\bullet},Z}\times\left(Z\Rightarrow1+A\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is already a functor, can simplify the tree encoding using the identity
 
\begin_inset Formula $\exists Z.P^{Z}\times\left(Z\Rightarrow1+A\right)\cong P^{A}$
\end_inset

 and obtain 
\begin_inset Formula $\text{FreeFi}^{F^{\bullet},A}\equiv F^{A}+\text{FreeFi}^{F^{\bullet},1+A}$
\end_inset

, which is equivalent to 
\begin_inset Formula $\text{FreeFi}^{F^{\bullet},A}=F^{A}+F^{1+A}+F^{1+1+A}+...$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding: 
\begin_inset Formula $\text{FreeFi}^{F^{\bullet},A}\equiv\exists Z.F^{Z}\times\left(Z\Rightarrow1+A\right)$
\end_inset

, non-recursive
\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\size default
Derivation: 
\begin_inset Formula $\forall Z_{1}...\forall Z_{n}.F^{Z_{n}}\times\left(Z_{n}\Rightarrow1+Z_{n-1}\right)\times...\times\left(Z_{1}\Rightarrow1+A\right)$
\end_inset

 is simplified using the laws of 
\family typewriter
\size footnotesize
\color blue
mapOpt
\family default
\size default
\color inherit
 and Kleisli composition, and yields 
\begin_inset Formula $\exists Z_{n}.F^{Z_{n}}\times\left(Z_{n}\Rightarrow1+A\right)$
\end_inset

.
 Encode 
\begin_inset Formula $F^{A}$
\end_inset

 as 
\begin_inset Formula $\exists Z.F^{Z}\times\left(Z\Rightarrow0+Z\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is already a functor, the reduced encoding is 
\begin_inset Formula $\text{FreeFi}^{F^{\bullet},A}=F^{1+A}$
\end_inset


\end_layout

\begin_layout Itemize
Free filterable over a filterable functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is not equivalent to 
\begin_inset Formula $F^{\bullet}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Free filterable contrafunctor is constructed in a similar way
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example VII: Free monad
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\size default
Methods:
\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\size default

\begin_inset Formula 
\begin{align*}
\text{pure} & :A\Rightarrow F^{A}\\
\text{flatMap} & :F^{A}\Rightarrow(A\Rightarrow F^{B})\Rightarrow F^{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.25cm}
\end_layout

\end_inset


\size default
Can recover 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 from 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
, so we keep only 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Tree encoding: 
\size footnotesize

\begin_inset Formula $\text{FreeM}^{F^{\bullet},A}\equiv F^{A}+A+\exists Z.\text{FreeM}^{F^{\bullet},Z}\times\big(Z\Rightarrow\text{FreeM}^{F^{\bullet},A}\big)$
\end_inset


\end_layout

\begin_layout Itemize
Derivation of reduced encoding: 
\end_layout

\begin_deeper
\begin_layout Itemize
can simplify 
\begin_inset Formula $A\times\big(A\Rightarrow\text{FreeM}^{F^{\bullet},B}\big)\cong\text{FreeM}^{F^{\bullet},B}$
\end_inset


\end_layout

\begin_layout Itemize
use associativity to replace 
\begin_inset Formula $\text{FreeM}^{A}\times(A\Rightarrow\text{FreeM}^{B})\times(B\Rightarrow\text{FreeM}^{C})$
\end_inset

 by 
\begin_inset Formula $\text{FreeM}^{A}\times\big(A\Rightarrow\text{FreeM}^{B}\times(B\Rightarrow\text{FreeM}^{C})\big)$
\end_inset


\end_layout

\begin_layout Itemize
therefore we can replace 
\begin_inset Formula $\exists Z.\text{FreeM}^{F^{\bullet},Z}\times...$
\end_inset

 by 
\begin_inset Formula $\exists Z.F^{Z}\times...$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Reduced encoding: 
\begin_inset Formula $\text{FreeM}^{F^{\bullet},A}\equiv A+\exists Z.F^{Z}\times\big(Z\Rightarrow\text{FreeM}^{F^{\bullet},A}\big)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\series bold
Final
\series default
 
\series bold
Tagless
\series default
 style
\begin_inset Quotes erd
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

Church encoding of free monad over 
\begin_inset Formula $F^{\bullet}$
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Free monad over a functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is 
\begin_inset Formula $\text{FreeM}^{F^{\bullet},A}\equiv A+F^{\text{FreeM}^{F^{\bullet},A}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Free monad 
\begin_inset Formula $\text{FreeM}^{M^{\bullet},\bullet}$
\end_inset

 over a monad 
\begin_inset Formula $M^{\bullet}$
\end_inset

 is not equivalent to 
\begin_inset Formula $M^{\bullet}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Free monad over a pointed functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is 
\size footnotesize

\begin_inset Formula $\text{FreeM}^{F^{\bullet},A}\equiv F^{A}+F^{\text{FreeM}^{F^{\bullet},A}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
start from half-reduced encoding 
\begin_inset Formula $F^{A}+\exists Z.F^{Z}\times\big(Z\Rightarrow\text{FreeM}^{F^{\bullet},A}\big)$
\end_inset

 
\end_layout

\begin_layout Itemize
replace the existential type by an equivalent type 
\begin_inset Formula $F^{\text{FreeM}^{F^{\bullet},A}}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked example VIII: Free applicative functor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Methods:
\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default

\begin_inset Formula 
\begin{align*}
\text{pure} & :A\Rightarrow F^{A}\\
\text{ap} & :F^{A}\Rightarrow F^{A\Rightarrow B}\Rightarrow F^{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
We can recover 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 from 
\family typewriter
\size footnotesize
\color blue
ap
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
, so we omit 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Tree encoding: 
\size footnotesize

\begin_inset Formula $\text{FreeAp}^{F^{\bullet},A}\equiv F^{A}+A+\exists Z.\text{FreeAp}^{F^{\bullet},Z}\times\text{FreeAp}^{F^{\bullet},Z\Rightarrow A}$
\end_inset


\end_layout

\begin_layout Itemize
Reduced encoding:
\size footnotesize
 
\begin_inset Formula $\text{FreeAp}^{F^{\bullet},A}\equiv A+\exists Z.F^{Z}\times\text{FreeAp}^{F^{\bullet},Z\Rightarrow A}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Derivation: a 
\begin_inset Formula $\text{FreeAp}^{A}$
\end_inset

 is either 
\begin_inset Formula $\exists Z_{1}...\exists Z_{n}.Z_{1}\times\text{FreeAp}^{Z_{1}\Rightarrow Z_{2}}\times...$
\end_inset

 or 
\begin_inset Formula $\exists Z_{1}...\exists Z_{n}.F^{Z_{1}}\times\text{FreeAp}^{Z_{1}\Rightarrow Z_{2}}\times...$
\end_inset

; encode 
\begin_inset Formula $Z_{1}\times\text{FreeAp}^{Z_{1}\Rightarrow Z_{2}}$
\end_inset

 equivalently as 
\begin_inset Formula $\text{FreeAp}^{Z_{1}\Rightarrow Z_{2}}\times\left(\left(Z_{1}\Rightarrow Z_{2}\right)\Rightarrow Z_{2}\right)$
\end_inset

 using the identity law; so the first 
\begin_inset Formula $\text{FreeAp}^{Z}$
\end_inset

 is always 
\begin_inset Formula $F^{A}$
\end_inset

, or we have a pure value 
\end_layout

\end_deeper
\begin_layout Itemize
Free applicative over a functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
\text{FreeAp}^{F^{\bullet},A} & \equiv A+\text{FreeZ}^{F^{\bullet},A}\\
\text{FreeZ}^{F^{\bullet},A} & \equiv F^{A}+\exists Z.F^{Z}\times\text{FreeZ}^{F^{\bullet},Z\Rightarrow A}
\end{align*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\text{FreeZ}^{F^{\bullet},\bullet}$
\end_inset

 is the reduced encoding of 
\begin_inset Quotes eld
\end_inset

free zippable
\begin_inset Quotes erd
\end_inset

 (no 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\text{FreeAp}^{F^{\bullet},\bullet}$
\end_inset

 over an applicative functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is not equivalent to 
\begin_inset Formula $F^{\bullet}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Laws for free typeclass constructions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Consider an inductive typeclass 
\begin_inset Formula $C$
\end_inset

 with methods 
\begin_inset Formula $C^{A}\Rightarrow A$
\end_inset


\end_layout

\begin_layout Standard
Define a free instance of 
\begin_inset Formula $C$
\end_inset

 over 
\begin_inset Formula $Z$
\end_inset

 recursively, 
\size footnotesize

\begin_inset Formula $\text{FreeC}^{Z}\equiv Z+C^{\text{FreeC}^{Z}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{FreeC}^{Z}$
\end_inset

 has an instance of 
\begin_inset Formula $C$
\end_inset

, i.e.
\begin_inset space ~
\end_inset

we can implement 
\begin_inset Formula $C^{\text{FreeC}^{Z}}\Rightarrow\text{FreeC}^{Z}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{FreeC}^{Z}$
\end_inset

 is a functor in 
\begin_inset Formula $Z$
\end_inset

; 
\size footnotesize

\begin_inset Formula $\text{fmap}_{\text{FreeC}}:\left(Y\Rightarrow Z\right)\Rightarrow\text{FreeC}^{Y}\Rightarrow\text{FreeC}^{Z}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.45cm}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "64col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Itemize
For a 
\begin_inset Formula $P^{:C}$
\end_inset

 we can implement the functions 
\size footnotesize

\begin_inset Formula 
\begin{align*}
\text{run}^{P} & :\left(Z\Rightarrow P\right)\Rightarrow\text{FreeC}^{Z}\Rightarrow P\\
\text{wrap} & :Z\Rightarrow\text{FreeC}^{Z}
\end{align*}

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "36col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5pc}\text{FreeC}^{Y}\ar[d]\sb(0.45){\text{fmap}\,f^{:Y\Rightarrow Z}}\ar[rd]\sp(0.65){\ \text{run}\left(f\circ g\right)}\\
\text{FreeC}^{Z}\ar[r]\sp(0.5){\text{run}(g^{:Z\Rightarrow P})} & P
}
\]

\end_inset


\end_layout

\end_inset


\size default

\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Standard
Law 1: 
\size footnotesize

\begin_inset Formula $\text{run}\left(\text{wrap}\right)=\text{id}$
\end_inset


\size default
; law 2: 
\size footnotesize

\begin_inset Formula $\text{fmap}\,f\circ\text{run}\,g=\text{run}\left(f\circ g\right)$
\end_inset


\size default
 (naturality of 
\family typewriter
\size footnotesize
\color blue
run
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
For any 
\begin_inset Formula $P^{:C},Q^{:C},g^{:Z\Rightarrow P}$
\end_inset

, and a typeclass-preserving 
\begin_inset Formula $f^{:P\Rightarrow Q}$
\end_inset

, we have
\size footnotesize

\begin_inset Formula 
\[
\text{run}^{P}(g)\circ f=\text{run}^{Q}\left(g\circ f\right)\quad\quad\text{– “universal property” of }\text{run}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{3pc}\text{FreeC}^{Z}\ar[d]\sb(0.4){\text{run}^{P}(g^{:Z\Rightarrow P})}\ar[rd]\sp(0.55){\quad\text{run}^{Q}(g\circ f)} &  &  & C^{P}\ar[d]\sb(0.4){\text{fmap}_{S}f}\ar[r]\sp(0.5){\text{ops}_{P}} & P\ar[d]\sb(0.4){f}\\
P\ar[r]\sp(0.5){f^{:P\Rightarrow Q}} & Q &  & C^{Q}\ar[r]\sp(0.5){\text{ops}_{Q}} & Q
}
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $f^{:P\Rightarrow Q}$
\end_inset

 
\series bold
preserves typeclass
\series default
 
\begin_inset Formula $C$
\end_inset

 if the diagram on the right commutes
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Combining the generating constructors in a free typeclass
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Consider 
\begin_inset Formula $\text{FreeC}^{Z}$
\end_inset

 for an inductive typeclass 
\begin_inset Formula $C$
\end_inset

 with methods 
\begin_inset Formula $C^{X}\Rightarrow X$
\end_inset


\end_layout

\begin_layout Itemize
We would like to combine generating constructors 
\begin_inset Formula $Z_{1}$
\end_inset

, 
\begin_inset Formula $Z_{2}$
\end_inset

, etc.
\end_layout

\begin_deeper
\begin_layout Itemize
In a monadic DSL – combine different operations defined separately
\end_layout

\begin_deeper
\begin_layout Itemize
Note: monads do not compose in general
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
To combine generators, use 
\begin_inset Formula $\text{FreeC}^{Z_{1}+Z_{2}}$
\end_inset

; an 
\begin_inset Quotes eld
\end_inset

instance over 
\begin_inset Formula $Z_{1}$
\end_inset

 and 
\begin_inset Formula $Z_{2}$
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
but need to inject parts into disjunction, which is cumbersome
\end_layout

\end_deeper
\begin_layout Itemize
Church encoding makes this easier to manage:
\end_layout

\begin_deeper
\begin_layout Itemize

\size footnotesize
\begin_inset Formula $\text{FreeC}^{Z}\equiv\forall X.\left(Z\Rightarrow X\right)\times\big(C^{X}\Rightarrow X\big)\Rightarrow X$
\end_inset


\size default
 and then 
\size footnotesize

\begin_inset Formula 
\[
\text{FreeC}^{Z_{1}+Z_{2}}\equiv\forall X.\left(Z_{1}\Rightarrow X\right)\times\left(Z_{2}\Rightarrow X\right)\times\big(C^{X}\Rightarrow X\big)\Rightarrow X
\]

\end_inset


\end_layout

\begin_layout Itemize
Encode the functions 
\begin_inset Formula $Z_{i}\Rightarrow X$
\end_inset

 via typeclasses 
\family typewriter
\size footnotesize
\color blue
ExZ1
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
ExZ2
\family default
\size default
\color inherit
, etc., where typeclass 
\family typewriter
\size footnotesize
\color blue
ExZ1
\family default
\size default
\color inherit
 has method 
\begin_inset Formula $Z_{1}\Rightarrow X$
\end_inset

, etc.
\end_layout

\begin_layout Itemize
Then 
\size footnotesize

\begin_inset Formula 
\[
\text{FreeC}^{Z_{1}+Z_{2}}=\forall X^{:E_{Z_{1}}:E_{Z_{2}}}.\big(C^{X}\Rightarrow X\big)\Rightarrow X
\]

\end_inset


\size default
or equivalently
\size footnotesize

\begin_inset Formula 
\[
\text{FreeC}^{Z_{1}+Z_{2}}=\forall X^{:C~:E_{Z_{1}}:E_{Z_{2}}}.X
\]

\end_inset


\end_layout

\begin_layout Itemize
The code is easier to maintain
\end_layout

\end_deeper
\begin_layout Itemize
This works for all typeclasses 
\begin_inset Formula $C$
\end_inset

 and any number of generators 
\begin_inset Formula $Z_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Combining different free typeclasses
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

To combine free instances of different typeclasses 
\begin_inset Formula $C_{1}$
\end_inset

 and 
\begin_inset Formula $C_{2}$
\end_inset

:
\end_layout

\begin_layout Itemize
Option 1: use functor composition, 
\begin_inset Formula $\text{FreeC}_{12}^{Z}\equiv\text{FreeC}_{1}^{\text{FreeC}_{2}^{Z}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Order of composition matters!
\end_layout

\begin_layout Itemize
Operations of 
\begin_inset Formula $C_{2}$
\end_inset

 need to be lifted into 
\begin_inset Formula $C_{1}$
\end_inset


\end_layout

\begin_layout Itemize
Works only for positive inductive typeclasses
\end_layout

\end_deeper
\begin_layout Itemize
Option 2: use disjunction of method functors, 
\begin_inset Formula $C^{X}\equiv C_{1}^{X}+C_{2}^{X}$
\end_inset

, and build the free typeclass instance using 
\begin_inset Formula $C^{X}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Church encoding: 
\begin_inset Formula $\text{FreeC}_{12}^{Z}\equiv\forall X.\left(Z\Rightarrow X\right)\times\big(C_{1}^{X}+C_{2}^{X}\Rightarrow X\big)\Rightarrow X$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Example 1: 
\begin_inset Formula $C_{1}$
\end_inset

 is functor, 
\begin_inset Formula $C_{2}$
\end_inset

 is contrafunctor
\end_layout

\begin_deeper
\begin_layout Itemize
Interpret a free functor/contrafunctor into a profunctor
\end_layout

\end_deeper
\begin_layout Itemize
Example 2: 
\begin_inset Formula $C_{1}$
\end_inset

 is monad, 
\begin_inset Formula $C_{2}$
\end_inset

 is applicative functor
\end_layout

\begin_deeper
\begin_layout Itemize
Interpret into a monad that has an optimized 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 implementation
\end_layout

\begin_layout Itemize
Example: interpret into 
\family typewriter
\size footnotesize
\color blue
Future
\family default
\size default
\color inherit
 and convert 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 into parallel execution
\end_layout

\begin_layout Itemize
Each 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 creates parallel branch, each 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 creates sequential chain
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

Implement a free semigroup generated by a type 
\begin_inset Formula $Z$
\end_inset

 in the tree encoding and in the reduced encoding.
 Show that the semigroup laws hold for the reduced encoding but not for
 the tree encoding before interpreting into a lawful semigroup 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Enumerate

\size footnotesize
Type 
\begin_inset Formula $P$
\end_inset

 is of typeclass 
\begin_inset Formula $\text{Mod}_{L}$
\end_inset

 (called 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $L$
\end_inset

-module
\begin_inset Quotes erd
\end_inset

) if a fixed monoid 
\begin_inset Formula $L$
\end_inset

 
\begin_inset Quotes eld
\end_inset

acts
\begin_inset Quotes erd
\end_inset

 on 
\begin_inset Formula $P$
\end_inset

 via 
\family typewriter
\color blue
act
\family default
\color inherit

\begin_inset Formula $:L\Rightarrow P\Rightarrow P$
\end_inset

, with laws 
\begin_inset Formula $\text{act}\,x\circ\text{act}\,y=\text{act}\left(x\circ y\right)$
\end_inset

 and 
\begin_inset Formula $\text{act}\left(1^{:L}\right)=\text{id}$
\end_inset

.
 Show that 
\begin_inset Formula $\text{Mod}_{L}$
\end_inset

 is an inductive typeclass.
 Implement a free 
\begin_inset Formula $L$
\end_inset

-module over a type 
\begin_inset Formula $Z$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\size footnotesize
Implement a monadic DSL with operations 
\family typewriter
\color blue
put
\family default
\color inherit

\begin_inset Formula $:A\Rightarrow1$
\end_inset

 and 
\family typewriter
\color blue
get
\family default
\color inherit

\begin_inset Formula $:A$
\end_inset

; run examples.
 
\end_layout

\begin_layout Enumerate

\size footnotesize
Implement the Church encoding of the type constructor 
\begin_inset Formula $P^{A}\equiv\text{Int}+A\times A$
\end_inset

.
 For the resulting type constructor, implement a 
\family typewriter
\color blue
Functor
\family default
\color inherit
 instance.
\end_layout

\begin_layout Enumerate

\size footnotesize
Describe the monoid type class via a method functor 
\begin_inset Formula $C^{\bullet}$
\end_inset

 (such that the monoid's operations are combined into the type 
\begin_inset Formula $S^{M}\Rightarrow M$
\end_inset

).
 Using 
\begin_inset Formula $S^{\bullet}$
\end_inset

, implement the free monoid over a type 
\begin_inset Formula $Z$
\end_inset

 in the Church encoding.
\end_layout

\begin_layout Enumerate

\size footnotesize
Assuming that 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a functor, define 
\begin_inset Formula $Q^{A}\equiv\exists Z.F^{Z}\times\left(Z\Rightarrow A\right)$
\end_inset

 and implement 
\family typewriter
\color blue
f2q
\family default
\color inherit

\begin_inset Formula $:F^{A}\Rightarrow Q^{A}$
\end_inset

 and 
\family typewriter
\color blue
q2f
\family default
\color inherit

\begin_inset Formula $:Q^{A}\Rightarrow F^{A}$
\end_inset

.
 Show that these functions are natural transformations, and that they are
 inverses of each other 
\begin_inset Quotes eld
\end_inset

observationally
\begin_inset Quotes erd
\end_inset

, i.e.
\begin_inset space ~
\end_inset

after applying 
\family typewriter
\color blue
q2f
\family default
\color inherit
 in order to compare values of 
\begin_inset Formula $Q^{A}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\size footnotesize
Show: 
\begin_inset Formula $\forall X.X=0$
\end_inset

; 
\begin_inset Formula $\exists Z.Z\cong1$
\end_inset

; 
\begin_inset Formula $\exists Z.Z\times A\cong A$
\end_inset

; 
\begin_inset Formula $\forall A.\left(A\times A\times A\Rightarrow A\right)\cong1+1+1$
\end_inset

.
\end_layout

\begin_layout Enumerate

\size footnotesize
Derive a reduced encoding for a free applicative functor over a pointed
 functor.
\end_layout

\begin_layout Enumerate

\size footnotesize
Implement a 
\begin_inset Quotes eld
\end_inset

free pointed filterable
\begin_inset Quotes erd
\end_inset

 typeclass (combining pointed and filterable) over a type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 in the tree encoding.
 Derive a reduced encoding.
 Simplify these encodings when 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is already a functor.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
