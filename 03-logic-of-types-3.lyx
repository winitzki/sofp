#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 3: Logic of Types III]{Chapter 3: The Logic of Types, Part III}
\subtitle{The Curry-Howard correspondence}
\author{Sergei Winitzki}
\date{December 16, 2017}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Types and propositional logic
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
The Curry-Howard correspondence
\end_layout

\begin_layout Standard
The code 
\family typewriter
\size footnotesize
\color blue
val x:
\begin_inset space \space{}
\end_inset

T =
\family default
\size default
\color inherit
 ...
 shows that 
\emph on
we can compute a value
\emph default
 of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 as part of our program expression
\end_layout

\begin_layout Itemize
Let's denote this 
\emph on
proposition
\emph default
 by 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 – 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathcal{C}$
\end_inset

ode 
\begin_inset Formula $\mathcal{H}$
\end_inset

as a value of type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Correspondence between types and propositions, for a given program:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Short notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(T)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
and
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
or
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A+B$
\end_inset

, 
\begin_inset Formula $A\vee B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\emph on
implies
\emph default
 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
Nothing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Type parameter 
\family typewriter
\size footnotesize
\color blue
[T]
\family default
\size default
\color inherit
 in a function type means 
\begin_inset Formula $\forall T$
\end_inset


\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size footnotesize
\color blue
def dupl[A]:
\begin_inset space \space{}
\end_inset

A 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, A)
\family default
\size default
\color inherit
.
 The type of this function corresponds to the (valid) proposition 
\begin_inset Formula $\forall A:A\Rightarrow A\times A$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Convert Scala types to short notation and back
\end_layout

\begin_layout Standard
Example 1: A disjunction type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetName(first: String, last: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetEmail(email: String) extends UserAction
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class SetUserId(id: Long) extends UserAction
\end_layout

\begin_layout Itemize
Short notation: 
\begin_inset Formula 
\[
\text{UserAction}\equiv\text{String}\times\text{String}+\text{String}+\text{Long}
\]

\end_inset


\end_layout

\begin_layout Standard
Example 2: A parameterized disjunction type
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Left[A, B, C](x: A) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Middle[A, B, C](x: B) extends Either3[A, B, C]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
case class Right[A, B, C](x: C) extends Either3[A, B, C]
\end_layout

\begin_layout Itemize
Short notation: 
\begin_inset Formula 
\[
\text{Either3}^{A,B,C}\equiv A+B+C
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Any valid formula can be implemented in code
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proposition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def identity[A](x:A):A = x
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A:A\Rightarrow1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def toUnit[A](x:A): Unit = ()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def inLeft[A,B](x:A):
\begin_inset space \space{}
\end_inset

Either[A,B] = Left(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\times B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def first[A,B](p:(A,B)):A = p._1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A\forall B:A\Rightarrow(B\Rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def const[A,B](x:A):B
\begin_inset Formula $\Rightarrow$
\end_inset

A = (y:B)
\begin_inset Formula $\Rightarrow$
\end_inset

x
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Invalid formulas 
\emph on
cannot be implemented
\emph default
 in code 
\end_layout

\begin_deeper
\begin_layout Itemize
Examples of invalid formulas:
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $\forall A:1\Rightarrow A$
\end_inset

; 
\begin_inset Formula $\forall A\forall B:A\vee B\Rightarrow A$
\end_inset

; 
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall A\forall B:A\Rightarrow A\times B$
\end_inset

; 
\begin_inset space \space{}
\end_inset

 
\begin_inset Formula $\quad\forall A\forall B:(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given a type's formula, can we implement it in code?
\end_layout

\begin_deeper
\begin_layout Itemize
Example: 
\begin_inset Formula $\forall A\forall B:((((A\Rightarrow B)\Rightarrow A)\Rightarrow A)\Rightarrow B)\Rightarrow B$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Constructive propositional logic has a decision algorithm
\end_layout

\begin_layout Itemize
See code examples using the 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"

\end_inset

 library
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Using known properties of propositional logic and arithmetic
\end_layout

\begin_layout Standard
Are 
\begin_inset Formula $A+B,\:A\times B$
\end_inset

 more like logic 
\begin_inset Formula $\left(A\vee B,\;A\wedge B\right)$
\end_inset

 or like arithmetic?
\end_layout

\begin_layout Itemize
Some standard identities in logic (
\begin_inset Formula $\forall A\forall B\forall C$
\end_inset

 is assumed):
\begin_inset Formula 
\begin{align*}
A\times1=A; & \quad A\times B=B\times A\\
A\vee1=1; & \quad A\vee B=B\vee A\\
(A\times B)\times C=A\times(B\times C); & \quad A\vee(B\times C)=(A\vee B)\times(A\vee C)\\
(A\vee B)\vee C=A\vee(B\vee C); & \quad A\times(B\vee C)=(A\times B)\vee(A\times C)\\
(A\times B)\Rightarrow C & =A\Rightarrow(B\Rightarrow C)\\
A\Rightarrow(B\times C) & =(A\Rightarrow B)\times(A\Rightarrow C)\\
(A\vee B)\Rightarrow C & =(A\Rightarrow C)\times(B\Rightarrow C)
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Each identity means 2 function types: 
\begin_inset Formula $X=Y$
\end_inset

 is 
\begin_inset Formula $X\Rightarrow Y\text{ \emph{and} }Y\Rightarrow X$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
Do these functions convert values between the types 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are isomorphic, 
\begin_inset Formula $A\equiv B$
\end_inset

, if there is a 1-to-1 correspondence between the sets of values of these
 types
\end_layout

\begin_deeper
\begin_layout Itemize
Need to find two functions 
\begin_inset Formula $f:A\Rightarrow B$
\end_inset

 and 
\begin_inset Formula $g:B\Rightarrow A$
\end_inset

 such that 
\begin_inset Formula $f\circ g=id$
\end_inset

 and 
\begin_inset Formula $g\circ f=id$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Example 1: Is 
\begin_inset Formula $\forall A:A\times1\equiv A$
\end_inset

? Types in Scala: 
\family typewriter
\size footnotesize
\color blue
(A, Unit)
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
A
\end_layout

\begin_layout Itemize
Two functions with types 
\begin_inset Formula $\forall A:A\times1\Rightarrow A$
\end_inset

 and 
\begin_inset Formula $\forall A:A\Rightarrow A\times1$
\end_inset

:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A]: ((A, Unit)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 A = { case (a, ()) 
\begin_inset Formula $\Rightarrow$
\end_inset

 a }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A]: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, Unit) = a 
\begin_inset Formula $\Rightarrow$
\end_inset

 (a, ())
\end_layout

\begin_layout Itemize
Verify that their compositions equal 
\family typewriter
\size footnotesize
\color blue
identity
\family default
\size default
\color inherit
 (see test code)
\end_layout

\begin_layout Standard
Example 2: Is 
\begin_inset Formula $\forall A:A+1\equiv1$
\end_inset

? (The logic formula 
\begin_inset Formula $\forall A:A\vee1=1$
\end_inset

 is valid.)
\end_layout

\begin_layout Itemize
Types in Scala: 
\family typewriter
\size footnotesize
\color blue
Option[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_deeper
\begin_layout Itemize
These types are obviously 
\emph on
not
\emph default
 equivalent
\end_layout

\end_deeper
\begin_layout Standard

\emph on
Some
\emph default
 logic identities yield
\emph on
 
\emph default
isomorphisms of types
\end_layout

\begin_layout Itemize
Which ones 
\emph on
do
\emph default
 
\emph on
not
\emph default
 yield isomorphisms, and why?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Verifying type equivalence by implementing isomorphisms
\end_layout

\begin_layout Itemize
Need to verify that 
\begin_inset Formula $f_{1}\circ f_{2}=id$
\end_inset

 and 
\begin_inset Formula $f_{2}\circ f_{1}=id$
\end_inset


\end_layout

\begin_layout Standard
Example 3: 
\begin_inset Formula $\forall A\forall B\forall C:(A\times B)\times C\equiv A\times(B\times C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: (((A, B), C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A, (B, C)) = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: ((A, (B, C))) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ((A, B), C) = ???
\end_layout

\begin_layout Standard
Example 4: 
\begin_inset Formula $\forall A\forall B\forall C:(A+B)\times C\equiv A\times C+B\times C$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: ((Either[A,B], C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[(A,C), (B,C)] = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: Either[(A,C), (B,C)] 
\begin_inset Formula $\Rightarrow$
\end_inset

 (Either[A, B], C) = ???
\end_layout

\begin_layout Standard
Example 5: 
\begin_inset Formula $\forall A\forall B\forall C:(A+B)\Rightarrow C\equiv(A\Rightarrow C)\times(B\Rightarrow C)$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: (Either[A, B] 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) 
\begin_inset Formula $\Rightarrow$
\end_inset

 (A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C, B 
\begin_inset Formula $\Rightarrow$
\end_inset

 C) = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: ((A 
\begin_inset Formula $\Rightarrow$
\end_inset

 C, B 
\begin_inset Formula $\Rightarrow$
\end_inset

 C)) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[A, B] 
\begin_inset Formula $\Rightarrow$
\end_inset

 C = ???
\end_layout

\begin_layout Standard
Example 6: 
\begin_inset Formula $\forall A\forall B\forall C:A+B\times C\not\equiv(A+B)\times(A+C)$
\end_inset

 – 
\begin_inset Quotes eld
\end_inset

information loss
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f1[A,B,C]: Either[A,(B,C)]
\begin_inset Formula $\Rightarrow$
\end_inset

(Either[A,B],Either[A,C]) = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f2[A,B,C]: ((Either[A,B],Either[A,C])) 
\begin_inset Formula $\Rightarrow$
\end_inset

 Either[A,(B,C)] = ???
\end_layout

\begin_layout Itemize
See example code for methods of testing these properties
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type isomorphisms III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Logic CH vs.
\begin_inset space \space{}
\end_inset

arithmetic CH for elementary (
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

) types
\end_layout

\begin_layout Itemize
WLOG, consider types 
\begin_inset Formula $A,B,...$
\end_inset

 that have 
\emph on
finite
\emph default
 sets of possible values
\end_layout

\begin_deeper
\begin_layout Itemize
Sum type 
\begin_inset Formula $A+B$
\end_inset

 (size 
\begin_inset Formula $\left|A\right|+\left|B\right|$
\end_inset

) provides a disjoint union of sets
\end_layout

\begin_layout Itemize
Product type 
\begin_inset Formula $A\times B$
\end_inset

 (size 
\begin_inset Formula $\left|A\right|\cdot\left|B\right|$
\end_inset

) provides a Cartesian product of sets
\end_layout

\begin_layout Itemize
Function type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 provides the set of all maps between sets
\end_layout

\begin_deeper
\begin_layout Itemize
The size of 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 is 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset


\end_layout

\begin_layout Itemize
Note the identities 
\begin_inset Formula $a^{c}b^{c}=\left(ab\right)^{c}$
\end_inset

, 
\begin_inset Formula $a^{b+c}=a^{b}a^{c}$
\end_inset

, 
\begin_inset Formula $a^{bc}=\left(a^{b}\right)^{c}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
If the set size (cardinality) differs, 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 cannot be equivalent 
\end_layout

\begin_deeper
\begin_layout Itemize
Logic identities give only the 
\begin_inset Quotes eld
\end_inset

equal implementability
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The meaning of the types/logic/arithmetic correspondence:
\end_layout

\begin_layout Itemize
Arithmetic formulas are related to type equivalence
\end_layout

\begin_layout Itemize
Logic formulas are related to implementability
\end_layout

\begin_layout Standard
Reasoning about types is 
\emph on
school-level algebra
\emph default
 with polynomials and powers
\end_layout

\begin_layout Itemize

\series bold
Exp-polynomial 
\series default
expressions: constants, sums, products, exponentials
\end_layout

\begin_deeper
\begin_layout Itemize
exp-poly types: primitive types, disjunctions, tuples, functions
\end_layout

\begin_layout Itemize
polynomial types are commonly called 
\begin_inset Quotes eld
\end_inset

algebraic types
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Using school-level algebra to reason about types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Recursive type: 
\begin_inset Quotes eld
\end_inset

list of integers
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case object Empty extends IntList
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Nonempty(head: Int, tail: IntList) extends IntList
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{IntList}\equiv1+\text{Int}\times\text{IntList}
\]

\end_inset


\end_layout

\begin_layout Standard
Parameterized recursive type: 
\begin_inset Quotes eld
\end_inset

list of 
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

, short notation: 
\begin_inset Formula $\text{List}^{A}$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
sealed trait List[A]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case object Nil extends List[Nothing]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class ::(head: A, tail: List[A]) extends List[A]
\end_layout

\begin_layout Standard
Short notation: (the sign 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\equiv$
\end_inset


\begin_inset Quotes erd
\end_inset

 means type equivalence)
\family typewriter
\size footnotesize

\begin_inset Formula 
\begin{align*}
\text{List}^{A} & \equiv1+A\times\text{List}^{A}\equiv1+A\times(1+A\times(1+A\times(...)...)\\
 & \equiv1+A+A\times A+A\times A\times A+...+A\times...\times A\times\text{List}^{A}
\end{align*}

\end_inset


\family default
\size default
A curious analogy with calculus: 
\begin_inset Formula $\text{List}(t)=1+t\cdot\text{List}(t)$
\end_inset

; 
\begin_inset Quotes eld
\end_inset

solve
\begin_inset Quotes erd
\end_inset

 this as 
\begin_inset Formula 
\[
\text{List}(t)=\frac{1}{1-t}=1+t+t^{2}+t^{3}+...+\frac{t^{n}}{1-t}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Define a parameterized type 
\family typewriter
\size footnotesize
\color blue
MyT[T]
\family default
\size default
\color inherit
 for the short type notation 
\size footnotesize

\begin_inset Formula $\text{Boolean}\Rightarrow\left(1+T+\text{Int}\times T+(\text{String}\Rightarrow T)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Transform 
\family typewriter
\size footnotesize
\color blue
(Either[A,B],Either[C,D])
\family default
\size default
\color inherit
 into an equivalent sum type
\end_layout

\begin_layout Enumerate
Show that 
\size footnotesize

\begin_inset Formula $A+A\not\equiv A$
\end_inset


\size default
 and 
\size footnotesize

\begin_inset Formula $A\times A\not\equiv A$
\end_inset


\size default
, although these hold in logic
\end_layout

\begin_layout Enumerate
Show that
\size footnotesize
 
\begin_inset Formula $(A\times B)\Rightarrow C\neq(A\Rightarrow C)+(B\Rightarrow C)$
\end_inset


\size default
 in logic
\end_layout

\begin_layout Enumerate
Denote 
\size footnotesize

\begin_inset Formula $\text{Reader}^{E,T}\equiv E\Rightarrow T$
\end_inset


\size default
 and implement functions with types 
\size footnotesize

\begin_inset Formula $A\Rightarrow\text{Reader}^{E,A}$
\end_inset


\size default
 and 
\size footnotesize

\begin_inset Formula $\text{Reader}^{E,A}\Rightarrow(A\Rightarrow B)\Rightarrow\text{Reader}^{E,B}$
\end_inset


\end_layout

\begin_layout Enumerate
Show that one cannot implement 
\family typewriter
\size footnotesize
\color blue
Reader[A,T]
\begin_inset Formula $\Rightarrow$
\end_inset

(A
\begin_inset Formula $\Rightarrow$
\end_inset

B)
\begin_inset Formula $\Rightarrow$
\end_inset

Reader[B,T]
\end_layout

\begin_layout Enumerate
Implement 
\size footnotesize

\begin_inset Formula $map^{A,B}:1+A\Rightarrow(A\Rightarrow B)\Rightarrow1+B$
\end_inset

 
\size default
with no 
\begin_inset Quotes eld
\end_inset

information loss
\begin_inset Quotes erd
\end_inset

, that is, 
\family typewriter
\size footnotesize
\color blue
map(opt)(x 
\begin_inset Formula $\Rightarrow$
\end_inset

 x) = opt
\end_layout

\begin_deeper
\begin_layout Enumerate
Implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
Either[L,R]
\family default
\size default
\color inherit
 by preferring 
\family typewriter
\size footnotesize
\color blue
R
\family default
\size default
\color inherit
 over 
\family typewriter
\size footnotesize
\color blue
L
\end_layout

\end_deeper
\begin_layout Enumerate
Denoting 
\size footnotesize

\begin_inset Formula $\text{State}^{S,T}\equiv S\Rightarrow T\times S$
\end_inset


\size default
, implement the functions:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\text{pure}^{S,A}:A\Rightarrow\text{State}^{S,A}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\text{map}^{S,A,B}:\text{State}^{S,A}\Rightarrow(A\Rightarrow B)\Rightarrow\text{State}^{S,B}$
\end_inset


\end_layout

\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $\text{flatMap}^{S,A,B}:\text{State}^{S,A}\Rightarrow(A\Rightarrow\text{State}^{S,B})\Rightarrow\text{State}^{S,B}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Define recursive type 
\family typewriter
\size footnotesize
\color blue
NEList[A]
\family default
\size default
\color inherit
 by
\size footnotesize
 
\begin_inset Formula $\text{NEList}^{A}\equiv A+A\times\text{NEList}^{A}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
concat
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
NEList
\family default
\size default
\color inherit
 (tail recursion not necessary)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Define type 
\family typewriter
\size footnotesize
\color blue
MyTU[T,U]
\family default
\size default
\color inherit
 for 
\size footnotesize

\begin_inset Formula $1+T\times U+\text{Int}\times T+\text{String}\times U$
\end_inset


\end_layout

\begin_layout Enumerate
Show that 
\size footnotesize

\begin_inset Formula $A\Rightarrow(B+C)\neq(A\Rightarrow B)+(A\Rightarrow C)$
\end_inset

 
\size default
in logic
\end_layout

\begin_layout Enumerate
Transform 
\family typewriter
\size footnotesize
\color blue
(Either[A,Int],Either[A,Char],Either[A,Float])
\family default
\size default
\color inherit
 into an equivalent type of the form 
\size footnotesize

\begin_inset Formula $A\times(...)$
\end_inset

 
\size default
and
\size footnotesize
 
\size default
write
\size footnotesize
 
\size default
the
\size footnotesize
 
\size default
equivalence tests
\size footnotesize
 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
Define type 
\size footnotesize

\begin_inset Formula $\text{OptEither}^{A,B}=1+A+B$
\end_inset

 
\size default
and implement
\family typewriter
\size footnotesize
\color blue
 map
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 for it, without information loss, preferring 
\begin_inset Formula $B$
\end_inset

 over 
\begin_inset Formula $A$
\end_inset

.
 Get the same result using the equivalent type 
\size footnotesize

\begin_inset Formula $(1+A)+B$
\end_inset


\size default
, i.e.
 
\family typewriter
\size footnotesize
\color blue
Either[Option[A], B]
\end_layout

\begin_layout Enumerate
Implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
MyT[T]
\family default
\size default
\color inherit
 (see worked example 1) and for 
\family typewriter
\size footnotesize
\color blue
MyTU[T,U]
\end_layout

\begin_layout Enumerate
Implement type-parametric functions with the following types:
\end_layout

\begin_deeper
\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $\text{State}^{S,A}\Rightarrow\left(S\times A\Rightarrow S\times B\right)\Rightarrow\text{State}^{S,B}$
\end_inset


\end_layout

\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $A+Z\Rightarrow(A\Rightarrow B)\Rightarrow B+Z$
\end_inset

 and 
\begin_inset Formula $A+Z\Rightarrow B+Z\Rightarrow(A\Rightarrow B\Rightarrow C)\Rightarrow C+Z$
\end_inset


\end_layout

\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $\text{flatMap}^{E,A,B}:\text{Reader}^{E,A}\Rightarrow(A\Rightarrow\text{Reader}^{E,B})\Rightarrow\text{Reader}^{E,B}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
* Denoting 
\family typewriter
\size footnotesize
\color blue
Density[Z,T] = (T
\begin_inset Formula $\Rightarrow$
\end_inset

Z)
\begin_inset Formula $\Rightarrow$
\end_inset

T
\family default
\size default
\color inherit
, implement the functions:
\end_layout

\begin_deeper
\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $\text{map}^{Z,A,B}:\text{Density}^{Z,A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{Density}^{Z,B}$
\end_inset


\end_layout

\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $\text{flatMap}^{Z,A,B}:\text{Density}^{Z,A}\Rightarrow(A\Rightarrow\text{Density}^{Z,B})\Rightarrow\text{Density}^{Z,B}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
* Denote 
\family typewriter
\size footnotesize
\color blue
Cont[R,T] = (T
\begin_inset Formula $\Rightarrow$
\end_inset

R)
\begin_inset Formula $\Rightarrow$
\end_inset

R
\family default
\size default
\color inherit
 and implement the functions:
\end_layout

\begin_deeper
\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $\text{map}^{R,T,U}:\text{Cont}^{R,T}\Rightarrow(T\Rightarrow U)\Rightarrow\text{Cont}^{R,U}$
\end_inset


\end_layout

\begin_layout Enumerate

\size footnotesize
\begin_inset Formula $\text{flatMap}^{R,T,U}:\text{Cont}^{R,T}\Rightarrow(T\Rightarrow\text{Cont}^{R,U})\Rightarrow\text{Cont}^{R,U}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Define recursive type 
\size footnotesize

\begin_inset Formula $\text{Tr3}{}^{A}\equiv1+A\times A\times A\times\text{Tr3}^{A}$
\end_inset


\size default
; implement 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 for it.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence IV
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for designing new programming languages
\end_layout

\begin_layout Itemize
The CH correspondence maps the type system of each programming language
 into a certain system of logical propositions 
\end_layout

\begin_layout Itemize
Scala, Haskell, OCaml, F#, Swift, Rust, etc.
\begin_inset space ~
\end_inset

are mapped into the full constructive logic (all logical operations are
 available)
\end_layout

\begin_deeper
\begin_layout Itemize
C, C++, Java, C#, etc.
\begin_inset space ~
\end_inset

are mapped to 
\emph on
incomplete
\emph default
 
\emph on
logics
\emph default
 – without 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

 and without 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Python, JavaScript, Ruby, Clojure, etc.
\begin_inset space ~
\end_inset

have only one type (
\begin_inset Quotes eld
\end_inset

any value
\begin_inset Quotes erd
\end_inset

) and are mapped to logics with only one proposition
\end_layout

\end_deeper
\begin_layout Itemize
The CH correspondence is a principle for designing type systems:
\end_layout

\begin_deeper
\begin_layout Itemize
Choose a complete logic, free of inconsistency
\end_layout

\begin_deeper
\begin_layout Itemize
Mathematicians have studied all kinds of logics and determined which ones
 are interesting, and found the minimal sets of axioms for them
\end_layout

\begin_layout Itemize
Modal logic, temporal logic, linear logic, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Provide a type constructor for each basic operation (e.g.
\begin_inset space ~
\end_inset


\begin_inset Quotes eld
\end_inset


\emph on
or
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
and
\emph default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Working with the CH correspondence V
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Implications for actually writing code
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Itemize
Use the short type notation for reasoning about types
\end_layout

\begin_layout Itemize
Given a fully parametric type, decide whether it can be implemented in code
 (
\begin_inset Quotes eld
\end_inset

type is inhabited
\begin_inset Quotes erd
\end_inset

); if so, 
\emph on
generate
\emph default
 the code
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "Gentzen-Vorobiev-Hudelmaier algorithm"
target "http://apt13.unibe.ch/slides/Dyckhoff.pdf"

\end_inset

 and its generalizations
\end_layout

\begin_layout Itemize
See also the 
\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"

\end_inset

 project
\end_layout

\end_deeper
\begin_layout Itemize
Given some expression, infer the most general type it can have
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset CommandInset href
LatexCommand href
name "Damas-Hindley-Milner algorithm"
target "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"

\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "Scala code"
target "http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/"

\end_inset

) and generalizations
\end_layout

\end_deeper
\begin_layout Itemize
Decide type isomorphism, simplify type formulas (the 
\begin_inset Quotes eld
\end_inset

arithmetic CH
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
Compute the necessary types before starting to write code
\end_layout

\begin_layout Standard
What problems cannot be solved with these tools?
\end_layout

\begin_layout Itemize
Automatically generate code satisfying properties (e.g.
\begin_inset space \space{}
\end_inset

isomorphism)
\end_layout

\begin_layout Itemize
Express complicated conditions via types (e.g.
\begin_inset space \space{}
\end_inset


\begin_inset Quotes eld
\end_inset

array is sorted
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Need dependent types for that (Coq, Agda, Idris, ...)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Addendum
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Random remarks regarding the topics of this section
\end_layout

\begin_layout Itemize
The CH correspondence becomes informative only with parameterized types.
 For concrete types, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
Array[Int]
\family default
\size default
\color inherit
, we can always produce 
\emph on
some
\emph default
 value even with no previous data, so 
\begin_inset Formula $\mathcal{CH}(\text{Int})$
\end_inset

 is always true.
\end_layout

\begin_layout Itemize
Functions such as 
\family typewriter
\size footnotesize
\color blue
(x:
\begin_inset space \space{}
\end_inset

Int) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x + 1
\family default
\size default
\color inherit
 have type 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit

\begin_inset Formula $\Rightarrow$
\end_inset


\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
, so the type information is insufficient to specify the code.
 It is only the fully type-parametric functions that have types informative
 enough for deriving the code automatically from the type.
\end_layout

\begin_layout Itemize
Having an arithmetic identity does not guarantee that we have a type equivalence
 via CH (it is a necessary but not a sufficient condition); but it does
 yield a type equivalence in all cases I looked at so far.
\end_layout

\begin_layout Itemize
When using a type-parametric 
\family typewriter
\size footnotesize
\color blue
sealed trait
\family default
\size default
\color inherit
 in Scala, there is a difference between representing a 
\begin_inset Quotes eld
\end_inset

named 
\family typewriter
\size footnotesize
\color blue
Unit
\family default
\size default
\color inherit
 type
\begin_inset Quotes erd
\end_inset

 via 
\family typewriter
\size footnotesize
\color blue
case object A
\family default
\size default
\color inherit
 vs.
\begin_inset space \space{}
\end_inset

via 
\family typewriter
\size footnotesize
\color blue
case class A[T]()
\family default
\size default
\color inherit
.
 Because a 
\family typewriter
\size footnotesize
\color blue
case object
\family default
\size default
\color inherit
 cannot have type parameters, some further features of Scala (covariance
 annotations) need to be used to get this working.
 May prefer 
\family typewriter
\size footnotesize
\color blue
case class A[T]()
\end_layout

\end_deeper
\end_body
\end_document
