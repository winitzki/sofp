#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Chapter 5: Type classes etc.]{Chapter 5: Type classes
 and their applications}
\subtitle{Pointed, co-pointed, and filtered functors}
\author{Sergei Winitzki}
\date{January 14, 2018}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{navigation symbols}{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for type classes I: Restricting type arguments
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
We need different 
\family typewriter
\size footnotesize
\color blue
sum
\family default
\size default
\color inherit
 implementations for 
\family typewriter
\size footnotesize
\color blue
Seq[Int], Seq[Double]
\family default
\size default
\color inherit
, etc.
\end_layout

\begin_layout Itemize
But we cannot generalize 
\family typewriter
\size footnotesize
\color blue
sum
\family default
\size default
\color inherit
 to arbitrary types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 like this:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def sum[T](s: Seq[T]): T = ???
\end_layout

\begin_layout Itemize
This can work only for 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 that have a zero value and a 
\family typewriter
\size footnotesize
\color blue
+
\family default
\size default
\color inherit
 method
\end_layout

\begin_layout Standard
We cannot generalize 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 to arbitrary type constructors 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def fmap[F[_], A, B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[B] = ???
\end_layout

\begin_layout Itemize
This can work only for type constructors 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
 that are functors
\end_layout

\begin_layout Standard
We would like to define functions whose type arguments, such as 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
, are constrained to belong to a 
\emph on
certain subset
\emph default
 of possible types
\end_layout

\begin_layout Itemize
We could then use the guaranteed properties of these type arguments
\end_layout

\begin_layout Itemize
This is similar to 
\emph on
partial functions
\emph default
 – but at type level
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for type classes II: Partial type-level functions
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Functions can be 
\series bold
total
\series default
 or 
\series bold
partial
\end_layout

\begin_deeper
\begin_layout Itemize
Total function: has a result for all argument values
\end_layout

\begin_layout Itemize
Partial function: has 
\emph on
no result
\emph default
 for some argument values
\end_layout

\end_deeper
\begin_layout Itemize
Also, functions can be, in principle, {from/to} {values/types}:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
functions:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def f(x:
\begin_inset space \space{}
\end_inset

Int):
\begin_inset space \space{}
\end_inset

Int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
def point[A]: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 List[A]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
to type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
dependent types
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
type Data[A] = Either[Int, A]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
value to value = run time, type to type / to value = compile time
\end_layout

\begin_deeper
\begin_layout Itemize
if we use JVM reflection, type-to-* can become run-time (boo!)
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
designation:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from value (PF)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
from type (PTTF; PTVF)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
example:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
{ case Some(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 ...
\begin_inset space \space{}
\end_inset

}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GADTs; 
\family typewriter
\size footnotesize
\color blue
implicitly[T]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when misapplied:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exception at run time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
error at compile time
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Type classes are a systematic way of managing your PTFs
\end_layout

\begin_deeper
\begin_layout Itemize
It is safe to apply a PTF to type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 if 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset

belongs to a certain type class
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example of uses of PFs: The caveats
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Filter a 
\family typewriter
\size footnotesize
\color blue
Seq[Either[Int, Boolean]]
\family default
\size default
\color inherit
, then apply 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 with a PF:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val s: Seq[Int] = Seq( Left(1), Right(true), Left(2) )
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .filter(_.isLeft) 
\family roman
\color gray
// result here is still of type 
\family default
\color blue
Seq[Either[...]]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .map { case Left(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x } 
\family roman
\color gray
// result is of type 
\family default
\color blue
Seq[Int]
\family roman
\color gray
 but unsafe
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

We know
\begin_inset Quotes erd
\end_inset

 it is okay to apply this PF here...
\end_layout

\begin_deeper
\begin_layout Itemize
But the types do not show this, – compile-time checking doesn't help
\end_layout

\begin_layout Itemize
If refactored, the code may become wrong and break 
\emph on
at run time
\end_layout

\end_deeper
\begin_layout Itemize
The type-safe version uses 
\family typewriter
\size footnotesize
\color blue
.collect
\family default
\size default
\color inherit
 instead of 
\family typewriter
\size footnotesize
\color blue
.filter().map()
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val s: Seq[Int] = Seq( Left(1), Right(true), Left(2) )
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  .collect { case Left(x) 
\begin_inset Formula $\Rightarrow$
\end_inset

 x }
\family roman
\color gray
  // result is safe, of type 
\family default
\color blue
Seq[Int]
\end_layout

\begin_layout Itemize
PFs are only safe to use in certain places, such as 
\family typewriter
\size footnotesize
\color blue
.collect()
\end_layout

\begin_deeper
\begin_layout Itemize
In all other cases, value-level functions should better be total
\end_layout

\begin_layout Itemize
Can use 
\begin_inset Quotes eld
\end_inset

refined
\begin_inset Quotes erd
\end_inset

 types such as 
\begin_inset Quotes eld
\end_inset

non-empty list
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

positive number
\begin_inset Quotes erd
\end_inset

 etc.
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
def f(xs: NonEmptyList[Int]) = {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  val h = xs.head
\family roman
\color gray
  // safe and checked at compile time
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand I: GADTs
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTTFs: Partial Type-to-Type Functions
\end_layout

\begin_layout Itemize
A type constructor that accepts only certain types as parameters:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
sealed trait 
\family typewriter
MyTC
\family default
[Z] 
\family roman
\color gray
// 
\begin_inset Quotes eld
\end_inset

sealed
\begin_inset Quotes erd
\end_inset

 – user code can't add cases
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class Case1(d: Double) extends 
\family typewriter
MyTC
\family default
[Int]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
final case class Case2() extends 
\family typewriter
MyTC
\family default
[String]
\family roman
\color gray
 // whatever
\end_layout

\begin_layout Itemize
It looks like we have defined 
\family typewriter
\size footnotesize
\color blue
MyTC[Z]
\family default
\size default
\color inherit
 for any type 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 ?...
\end_layout

\begin_deeper
\begin_layout Itemize
no, we can only ever create values of 
\family typewriter
\size footnotesize
\color blue
MyTC[Int]
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
MyTC[String]
\end_layout

\end_deeper
\begin_layout Itemize
So 
\family typewriter
\size footnotesize
\color blue
MyTC[Z]
\family default
\size default
\color inherit
 is a PTTF defined only for 
\family typewriter
\size footnotesize
\color blue
Z = Int
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Z = String
\end_layout

\begin_layout Itemize
This type constraint is checked and enforced 
\emph on
at compile time
\emph default
!
\end_layout

\begin_layout Itemize
When to use GADTs:
\end_layout

\begin_deeper
\begin_layout Itemize
for domain modeling (e.g.
\begin_inset space \space{}
\end_inset

queries with a fixed set of result types)
\end_layout

\begin_layout Itemize
for DSLs that have typed expressions
\end_layout

\end_deeper
\begin_layout Itemize
Instead of GADTs, a PTTF can be a trait with implementation code
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
\color blue
trait MyPTTF[Z] {...} 
\family roman
\color gray
// not 
\begin_inset Quotes eld
\end_inset

sealed
\begin_inset Quotes erd
\end_inset

 – user code may extend
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
class C1(...) extends MyPTTF[Int] {...}
\family roman
\color gray
 // arbitrary code
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand II: 
\begin_inset Quotes eld
\end_inset

Type Evidence
\begin_inset Quotes erd
\end_inset

 arguments
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTVFs: Partial Type-to-Value Functions
\end_layout

\begin_layout Standard
To define a function 
\family typewriter
\size footnotesize
\color blue
def func[T](...)
\family default
\size default
\color inherit
 only for certain types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Enumerate
Create a PTTF defined only for the relevant types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
IsGood[T]
\end_layout

\begin_layout Enumerate
Add an extra argument of type 
\family typewriter
\size footnotesize
\color blue
IsGood[T]
\family default
\size default
\color inherit
 (
\series bold
type evidence
\series default
) to 
\family typewriter
\size footnotesize
\color blue
func[T]
\end_layout

\begin_layout Enumerate
Create some values of type 
\family typewriter
\size footnotesize
\color blue
IsGood[T]
\family default
\size default
\color inherit
 as needed, for relevant types 
\family typewriter
\size footnotesize
\color blue
T 
\end_layout

\begin_layout Standard
What we gained:
\end_layout

\begin_layout Itemize
it is now impossible to call 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
 with an unsupported type 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_layout Itemize
trying to do so will fail 
\emph on
at compile time
\emph default
, because TE won't type-check
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
IsGood[T]
\family default
\size default
\color inherit
 is not 
\family typewriter
\size footnotesize
\color blue
sealed
\family default
\size default
\color inherit
, more types 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 can be added via user code
\end_layout

\begin_layout Standard
The cost:
\end_layout

\begin_layout Itemize
all calls to 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
 now need TE values as extra argument(s)
\end_layout

\begin_layout Itemize
we need to keep passing the TE values around the code
\end_layout

\begin_layout Itemize
the TE values need to be created for each supported type 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_layout Standard
How we mitigate this problem in Scala: use 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 values
\end_layout

\begin_layout Itemize
TE arguments are needed only at declaration site of 
\family typewriter
\size footnotesize
\color blue
func
\end_layout

\begin_layout Itemize
Once defined as 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
, TE values are passed around automatically
\end_layout

\begin_layout Itemize
New TE values can be often built up automatically (and recursively!)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Scala's mechanism of 
\begin_inset Quotes eld
\end_inset


\family typewriter
implicit
\family default
 values
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Implicit values are:
\end_layout

\begin_layout Itemize
declared as 
\family typewriter
\size footnotesize
\color blue
implicit val x:
\begin_inset space \space{}
\end_inset

SomeType = ...
\end_layout

\begin_layout Itemize
automatically passed into functions that declare extra arguments as
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f(args...)(implicit x: SomeType) = ...
\end_layout

\begin_layout Itemize
searched in local scope, imports, companion objects, parent classes
\end_layout

\begin_layout Itemize
standard library has 
\family typewriter
\size footnotesize
\color blue
def implicitly[T](implicit t:
\begin_inset space \space{}
\end_inset

T):
\begin_inset space \space{}
\end_inset

T = t
\end_layout

\begin_layout Standard
Special syntax for declaring implicit TE arguments in a PTVF:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def func[T: MyTypeClass](args...) = ...
\end_layout

\begin_layout Standard
This is equivalent to
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def func[T](args...)(implicit ev: MyTypeClass[T]) = ...
\end_layout

\begin_layout Standard
We still need to:
\end_layout

\begin_layout Itemize
declare 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 as a PTTF elsewhere
\end_layout

\begin_layout Itemize
create TE values of various types and declare them as 
\family typewriter
\size footnotesize
\color blue
implicit
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Managing PTFs by hand III: Traits with inheritance
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
PTVFs: Partial Type-to-Value Functions, the object-oriented way
\end_layout

\begin_layout Itemize
A trait with methods and a few implementations:
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
trait HasPlus[Z] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  def plus(z1: Z, z2: Z): Z
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
implicit object CaseInt extends HasPlus[Int] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  def plus(z1: Int, z2: Int): Int = z1 + z2
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
implicit object CaseString extends HasPlus[String] {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
  def plus(z1: String, z2: String): String = z1 + z2
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\begin_layout Itemize
Similar to having 
\family typewriter
\size footnotesize
\color blue
plus[Z]
\family default
\size default
\color inherit
 only for two types, 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
String
\end_layout

\begin_deeper
\begin_layout Itemize
We can only access 
\family typewriter
\size footnotesize
\color blue
plus[Z]
\family default
\size default
\color inherit
 via a TE value of type 
\family typewriter
\size footnotesize
\color blue
HasPlus[Z]
\end_layout

\end_deeper
\begin_layout Standard
See example code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type classes I: The definition
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A 
\series bold
type class
\series default
 is a set of PTVFs that all have the same type domain
\end_layout

\begin_layout Itemize
In terms of specific code to be written, a type class is:
\end_layout

\begin_deeper
\begin_layout Enumerate
a PTTF, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
, defining the type domain, 
\emph on
together with
\end_layout

\begin_layout Enumerate
some code (usually, library imports) that creates some TE values, 
\emph on
and
\end_layout

\begin_layout Enumerate
one or more PTVFs that use this PTTF for TE arguments
\end_layout

\begin_layout Itemize
for many important use cases, the PTVFs must satisfy certain laws
\end_layout

\end_deeper
\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset


\series bold
belongs to
\series default
 the type class 
\family typewriter
\size footnotesize
\color blue
MyTypeClass
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 if a TE value exists
\end_layout

\begin_deeper
\begin_layout Itemize
i.e.
\begin_inset space \space{}
\end_inset

if 
\emph on
some
\emph default
 value of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 can be found
\end_layout

\begin_deeper
\begin_layout Itemize
(usually, as a library import)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
A function 
\family typewriter
\size footnotesize
\color blue
func[T]
\family default
\size default
\color inherit
 
\begin_inset Quotes eld
\end_inset

requires the type class 
\family typewriter
\size footnotesize
\color blue
MyTypeClass
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit

\begin_inset Quotes erd
\end_inset

 if one of 
\family typewriter
\size footnotesize
\color blue
func
\family default
\size default
\color inherit
's arguments is a value of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\end_layout

\begin_deeper
\begin_layout Itemize
that argument is the 
\series bold
type class instance
\series default
 for the type parameter 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_layout Itemize
this 
\series bold
constrains
\series default
 the type parameter 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 to belong to the type class
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Type classes II: Implementation in Scala
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A type class is typically implemented in Scala as:
\end_layout

\begin_layout Itemize
a trait with a type parameter, e.g.
\begin_inset space \space{}
\end_inset


\family typewriter
\size footnotesize
\color blue
trait MyTypeClass[T]
\end_layout

\begin_layout Itemize
code that creates values of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 for various 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\begin_deeper
\begin_layout Itemize
these values must be defined as 
\family typewriter
\size footnotesize
\color blue
implicit
\family default
\size default
\color inherit
 and made available via imports or in the 
\emph on
companion objects
\emph default
 for the specific types 
\family typewriter
\size footnotesize
\color blue
T
\end_layout

\end_deeper
\begin_layout Itemize
some functions with an implicit argument of type 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\end_layout

\begin_deeper
\begin_layout Itemize
laws for these functions may need to be enforced by tests
\end_layout

\end_deeper
\begin_layout Standard
Usually, all information about the type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is contained in the TE value
\end_layout

\begin_layout Itemize
the trait 
\family typewriter
\size footnotesize
\color blue
MyTypeClass[T]
\family default
\size default
\color inherit
 contains all relevant PTVFs as 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
's
\end_layout

\begin_layout Itemize
in simpler cases, TE can be a data type (not a trait with 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 methods)
\end_layout

\begin_deeper
\begin_layout Itemize
a trait with 
\family typewriter
\size footnotesize
\color blue
def
\family default
\size default
\color inherit
 methods is necessary for higher-order type functions
\end_layout

\end_deeper
\begin_layout Standard
See example code
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of type classes I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Some simple PTFs and their use cases
\end_layout

\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is 
\series bold
pointed
\series default
 if there exists a function 
\family typewriter
\size footnotesize
\color blue
point:
\begin_inset space \space{}
\end_inset

T
\end_layout

\begin_deeper
\begin_layout Itemize
There is a special, somehow naturally selected value of that type
\end_layout

\end_deeper
\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is a 
\series bold
semigroup
\series default
 if it has an associative binary operation
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def op(x: T, y: T): T
\end_layout

\begin_layout Itemize
A type 
\family typewriter
\size footnotesize
\color blue
T
\family default
\size default
\color inherit
 is a 
\series bold
monoid
\series default
 if there exist functions
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def zero[T]: T
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def append[T](x: T, y: T): T
\end_layout

\begin_layout Itemize
such that the usual algebraic laws hold:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
append
\family default
\size default
\color inherit
 is associative
\end_layout

\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
append(zero, x) == append(x, zero) == x
\end_layout

\end_deeper
\begin_layout Standard
See examples of implementing the 
\family typewriter
\size footnotesize
\color blue
Monoid
\family default
\size default
\color inherit
 type class in various ways
\end_layout

\begin_layout Itemize
by using a case class as a PTTF
\end_layout

\begin_layout Itemize
by combining 
\family typewriter
\size footnotesize
\color blue
Pointed
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Semigroup
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of type classes II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout FrameSubtitle
Higher-order PTFs
\end_layout

\begin_layout Itemize
A type constructor 
\begin_inset Formula $F^{A}$
\end_inset

 is a functor if it has a 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
or, equivalently, 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
that satisfies the functor laws
\end_layout

\end_deeper
\begin_layout Itemize
We would like to write a generic function that tests the functor laws
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def checkFunctorLaws[F[_], A, B, C](): Assertion = ???
\end_layout

\begin_layout Itemize
Need to get access to the function 
\family typewriter
\size footnotesize
\color blue
map[A, B]
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
F[_]
\end_layout

\begin_layout Itemize
We treat 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 as a PTVF whose type domain is all functors 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def map[F[_], A, B](fa: F[A], f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B): F[B] = ???
\end_layout

\begin_layout Itemize
We constrain 
\family typewriter
\size footnotesize
\color blue
F[_]
\family default
\size default
\color inherit
 to belong to the 
\family typewriter
\size footnotesize
\color blue
Functor
\family default
\size default
\color inherit
 type class
\end_layout

\begin_deeper
\begin_layout Itemize
by adding 
\family typewriter
\size footnotesize
\color blue
implicit ev: Functor[F]
\end_layout

\begin_deeper
\begin_layout Itemize
here 
\family typewriter
\size footnotesize
\color blue
Functor[F]
\family default
\size default
\color inherit
 is a 
\emph on
higher-order
\emph default
 PTTF
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
See test code for implementation and functor laws checking
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Worked examples I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Define a PTVF 
\family typewriter
\size footnotesize
\color blue
def bitsize[T]: Int
\family default
\size default
\color inherit
 such that 
\family typewriter
\size footnotesize
\color blue
bitsize[Int]
\family default
\size default
\color inherit
 returns 
\begin_inset Formula $32$
\end_inset

 and 
\family typewriter
\size footnotesize
\color blue
bitsize[Long]
\family default
\size default
\color inherit
 returns 
\begin_inset Formula $64$
\end_inset

, but undefined on other types 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Enumerate
Define a monoid instance for the type 
\begin_inset Formula $1+\left(\text{Int}\Rightarrow\text{Int}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are monoids, define monoid instance for 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $A$
\end_inset

 is a monoid and 
\begin_inset Formula $B$
\end_inset

 is a semigroup then 
\begin_inset Formula $A+B$
\end_inset

 is a monoid
\end_layout

\begin_layout Enumerate
Define a functor instance for 
\family typewriter
\size footnotesize
\color blue
type F[T] = Seq[Try[T]]
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are functors, define functor instance for 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

 
\end_layout

\begin_layout Enumerate
Define a 
\family typewriter
\size footnotesize
\color blue
ContraFunctor
\family default
\size default
\color inherit
 type class having 
\family typewriter
\size footnotesize
\color blue
contrafmap
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def contrafmap[A, B](f: B 
\begin_inset Formula $\Rightarrow$
\end_inset

 A): F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[B] = ???
\end_layout

\begin_layout Standard
Define a 
\family typewriter
\size footnotesize
\color blue
ContraFunctor
\family default
\size default
\color inherit
 instance for type constructor 
\begin_inset Formula $C^{A}\equiv A\Rightarrow\text{Int}$
\end_inset


\family typewriter
\size footnotesize
\color blue
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Exercises I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Define a PTVF 
\family typewriter
\size footnotesize
\color blue
def isLong[T]: Boolean
\family default
\size default
\color inherit
 that returns 
\family typewriter
\size footnotesize
\color blue
true
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
Long
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Double
\family default
\size default
\color inherit
, returns 
\family typewriter
\size footnotesize
\color blue
false
\family default
\size default
\color inherit
 for 
\family typewriter
\size footnotesize
\color blue
Int
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Short
\family default
\size default
\color inherit
, and 
\family typewriter
\size footnotesize
\color blue
Float
\family default
\size default
\color inherit
, otherwise undefined
\end_layout

\begin_layout Enumerate
Define a monoid instance for the type 
\begin_inset Formula $\text{String}\times(1+\text{Int})$
\end_inset


\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $A$
\end_inset

 is a monoid and 
\begin_inset Formula $R$
\end_inset

 any type, define monoid instance for 
\begin_inset Formula $R\Rightarrow A$
\end_inset


\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size footnotesize
\color blue
S
\family default
\size default
\color inherit
 is a semigroup then 
\family typewriter
\size footnotesize
\color blue
Option[S]
\family default
\size default
\color inherit
 is a monoid
\end_layout

\begin_layout Enumerate
Define a functor instance for 
\family typewriter
\size footnotesize
\color blue
type F[T] = Future[Seq[T]]
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are functors, define functor instance for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

 
\end_layout

\begin_layout Enumerate
Define a 
\family typewriter
\size footnotesize
\color blue
ProFunctor
\family default
\size default
\color inherit
 type class having 
\family typewriter
\size footnotesize
\color blue
bimap
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def bimap[A, B](f: A 
\begin_inset Formula $\Rightarrow$
\end_inset

 B, g: B 
\begin_inset Formula $\Rightarrow$
\end_inset

 A): F[A] 
\begin_inset Formula $\Rightarrow$
\end_inset

 F[B] = ???
\end_layout

\begin_layout Standard
Define a 
\family typewriter
\size footnotesize
\color blue
ProFunctor
\family default
\size default
\color inherit
 instance for type constructor 
\begin_inset Formula $P^{A}\equiv A\Rightarrow\left(\text{Int}\Rightarrow A\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Define a 
\family typewriter
\size footnotesize
\color blue
Functor
\family default
\size default
\color inherit
 instance for 
\begin_inset Formula $F^{A}\Rightarrow G^{A}$
\end_inset

 where 
\begin_inset Formula $F^{A}$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $G^{A}$
\end_inset

 is a functor
\family typewriter
\size footnotesize
\color blue
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Other topics:
\end_layout

\begin_layout Itemize
Implementing Functor instance using Cats and Scalaz
\end_layout

\begin_layout Itemize
Implementing Functor instance for recursive types 
\end_layout

\begin_layout Itemize
Functor typeclass derivation using Shapeless
\end_layout

\begin_layout Itemize
Functions that are parameterized by a Functor type constructor
\end_layout

\begin_layout Itemize
Examples of APIs that consume a functor, with type class constraint
\end_layout

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
