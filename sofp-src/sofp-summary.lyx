#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\end_layout

\begin_layout Chapter
Summary of the book
\begin_inset CommandInset label
LatexCommand label
name "chap:Summary-of-the"

\end_inset


\end_layout

\begin_layout Standard
The book has been written in a tutorial format, motivating and deriving
 the results gradually.
 This makes it easier to learn but harder to navigate.
 In this summary chapter, the results are listed without detailed explanations
 or proofs.
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Section
Additional exercises and problems
\begin_inset CommandInset label
LatexCommand label
name "chap:Exercises-in-AFTT"

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following exercises can be solved using techniques developed in this
 book.
\end_layout

\begin_layout Enumerate
Compute the smallest integer expressible as a sum of two cubed integers
 in more than one way.
\end_layout

\begin_layout Enumerate
Read a text file, split it by spaces into words, and print the word counts,
 sorted by decreasing count.
\begin_inset Note Comment
status collapsed

\begin_layout Enumerate
FPIS exercise 2.2: Check whether a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 is sorted according to a given ordering function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A) => Boolean
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
FPIS exercise 3.24: Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hasSubsequence
\end_layout

\end_inset

 that checks whether a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 contains another 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 as a subsequence.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2,3,4)
\end_layout

\end_inset

 would have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(2,3)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(4)
\end_layout

\end_inset

 as subsequences, among others.
 (Dynamic programming?)
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The Seasoned Schemer, chapter 13: Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def remberUptoLast[A](a: A, s: List[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

def remberBeyondLast[A](a: A, s: List[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> remberUptoLast(4, List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

List(5, 6, 7, 8)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> remberBeyondLast(4, List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

List(1, 2, 3, 4, 5)
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 removes all elements from a list up to and including the last occurrence
 of a given value.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

 removes all elements from a list starting from the last occurrence of a
 given value.
 Both functions return the original list if the given value does not occur
 in the list.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
We first define extension method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastOption
\end_layout

\end_inset

 for Scala's Iterator:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class IteratorOps[A](val it: Iterator[A]) extends AnyVal {
\end_layout

\begin_layout Plain Layout

  def lastOption: Option[A] = {
\end_layout

\begin_layout Plain Layout

   @tailrec def lastKnown(x: A): Some[A] = if (it.hasNext) lastKnown(it.next)
 else Some(x)
\end_layout

\begin_layout Plain Layout

   if (it.hasNext) lastKnown(it.next) else None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Then the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

 is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def remberUptoLast[A](a: A, s: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  s.tails.filter(_.headOption contains a).lastOption.map(_.tail).getOrElse(s)
\end_layout

\begin_layout Plain Layout

def remberBeyondLast[A](a: A, s: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  s.reverse.tails.filter(_.headOption contains a).nextOption.map(_.tail.reverse).getOrEls
e(s)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
(Bird-de Moor, page 20) Derive the following identity between functions
 
\begin_inset Formula $F^{A}\rightarrow F^{A}$
\end_inset

, for any filterable functor 
\begin_inset Formula $F$
\end_inset

 and any predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

: 
\begin_inset Formula 
\[
\text{filt}_{F}(p)=(\Delta\bef\text{id}\boxtimes p)^{\uparrow F}\bef\text{filt}_{F}(\pi_{2})\bef\pi_{1}^{\uparrow F}\quad.
\]

\end_inset


\end_layout

\begin_layout Enumerate
Define a monoid of partial functions with fixed types 
\begin_inset Formula $P\rightarrow Q$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class PFM[P, Q](pf: PartialFunction[P, Q])
\end_layout

\begin_layout Plain Layout

// After defining a monoid instance, the following code must work:
\end_layout

\begin_layout Plain Layout

val p1 = PFM[Option[Int], String] { case Some(3) => 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

 }
\end_layout

\begin_layout Plain Layout

val p2 = PFM[Option[Int], String] {
\end_layout

\begin_layout Plain Layout

  case Some(20)   => 
\begin_inset Quotes eld
\end_inset

twenty
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case None       => 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

p1 |+| p2 // Must be the same as the concatenation of all `case` clauses.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Consider a typeclass called 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Splittable
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 for functors
\begin_inset Index idx
status open

\begin_layout Plain Layout
splittable functor
\end_layout

\end_inset

 
\begin_inset Formula $F^{\bullet}$
\end_inset

 that have an additional method 
\begin_inset Formula 
\[
\text{split}^{A,B}:F^{A+B}\rightarrow F^{A}+B\quad,
\]

\end_inset

with a non-degeneracy law:
\begin_inset Formula 
\[
(x^{:A}\rightarrow x+\bbnum 0^{:B})^{\uparrow F}\bef\text{split}=y^{:F^{A}}\rightarrow y+\bbnum 0^{:B}\quad,
\]

\end_inset

and a special associativity law, which is an equation for functions of type
 
\begin_inset Formula $F^{A+B+C}\rightarrow F^{A}+B+C$
\end_inset

:
\begin_inset Formula 
\[
\text{split}^{A+B,C}\bef\,\begin{array}{|c||cc|}
 & F^{A}+B & C\\
\hline F^{A+B} & \text{split}^{A,B} & \bbnum 0\\
C & \bbnum 0 & \text{id}
\end{array}\,=\text{split}^{A,B+C}\quad.
\]

\end_inset

Show that all polynomial functors 
\begin_inset Formula $F^{\bullet}$
\end_inset

 belong to this typeclass.
 Show that exponential functors such as 
\begin_inset Formula $F^{A}\triangleq Z\rightarrow A$
\end_inset

 do not.
\end_layout

\begin_layout Enumerate
Given a monad 
\begin_inset Formula $M$
\end_inset

 and a fixed type 
\begin_inset Formula $Z$
\end_inset

, consider the functor 
\begin_inset Formula $F^{A}\triangleq(A\rightarrow M^{Z})\rightarrow Z$
\end_inset

.
 Show that 
\begin_inset Formula $F$
\end_inset

 is a semimonad but not a full monad.
 Hint: use the flipped Kleisli technique.
\end_layout

\begin_layout Enumerate
Given two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 that are not known to be equivalent, consider the contrafunctors 
\begin_inset Formula $F^{A}\triangleq\left(\left(A\rightarrow P\right)\rightarrow P\right)\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $G^{A}\triangleq A\rightarrow Q$
\end_inset

.
 Show that there exist natural transformations 
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}\leadsto F^{\bullet}$
\end_inset

.
 Show that these transformations are 
\emph on
not
\emph default
 isomorphisms.
\end_layout

\begin_layout Enumerate
Given two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 that are not known to be equivalent, show that the functor 
\begin_inset Formula $L^{A}\triangleq\left(\left(\left(A\rightarrow P\right)\rightarrow Q\right)\rightarrow Q\right)\rightarrow P$
\end_inset

 is a semimonad but not a full monad.
 (When 
\begin_inset Formula $P\cong Q$
\end_inset

, the functor 
\begin_inset Formula $L$
\end_inset

 is also not a full monad because 
\begin_inset Formula $L$
\end_inset

 is then equivalent to a composition of the continuation monad with itself.
 See Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-composition-mm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Enumerate
When 
\begin_inset Formula $M$
\end_inset

 is a given semimonad, show that 
\begin_inset Formula $M\circ M\circ...\circ M$
\end_inset

 (with finitely many 
\begin_inset Formula $M$
\end_inset

) is also a lawful semimonad.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $M$
\end_inset

 is any lawful monad then 
\begin_inset Formula $M^{A+M^{A}}$
\end_inset

 is also a lawful monad.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $M$
\end_inset

 is a commutative monad then 
\begin_inset Formula $M\circ M$
\end_inset

 is also a lawful commutative monad.
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $M^{\bullet}$
\end_inset

 is a commutative monad and 
\begin_inset Formula $W$
\end_inset

 is a commutative monoid then the monoid 
\begin_inset Formula $M^{W}$
\end_inset

 is commutative.
\end_layout

\begin_layout Enumerate
** Define a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 representing 
\begin_inset Quotes eld
\end_inset

triangular matrices
\begin_inset Quotes erd
\end_inset

 with elements of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Example values 
\begin_inset Formula $t_{1}$
\end_inset

, 
\begin_inset Formula $t_{2}$
\end_inset

, 
\begin_inset Formula $t_{3}$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 could be of the form:
\begin_inset Formula 
\[
t_{1}=\left|\begin{array}{c}
a_{1}\end{array}\right|\quad,\quad\quad t_{2}=\left|\begin{array}{cc}
a_{1}\\
a_{2} & a_{3}
\end{array}\right|\quad,\quad\quad t_{3}=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{4} & a_{5} & a_{6}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad.
\]

\end_inset

Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

, it should 
\emph on
not
\emph default
 be possible to have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 that has an unexpected shape:
\begin_inset Formula 
\[
t=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad\text{is not of type }\text{Triang}^{A}\quad.
\]

\end_inset

 Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instances for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Define a monad transformer 
\begin_inset Formula $T_{\text{Cod}_{F}^{L}}^{M,A}$
\end_inset

 for the composed codensity monad (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-combined-codensity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with type parameters 
\begin_inset Formula $F$
\end_inset

 (an arbitrary but fixed functor), 
\begin_inset Formula $L$
\end_inset

 (an arbitrary but fixed monad), 
\begin_inset Formula $M$
\end_inset

 (a foreign monad), and 
\begin_inset Formula $A$
\end_inset

 (the value type).
 Find out which laws hold for that transformer.
\end_layout

\begin_layout Enumerate
** 
\series bold
(a)
\series default
 For any fixed type 
\begin_inset Formula $Z$
\end_inset

, functor 
\begin_inset Formula $F$
\end_inset

 and lawful monad 
\begin_inset Formula $P$
\end_inset

, show that 
\begin_inset Formula $L^{A}\triangleq F^{A\rightarrow P^{Z}}\rightarrow P^{A}$
\end_inset

 is a lawful monad.
 
\series bold
(b)
\series default
 Show that 
\begin_inset Formula $L$
\end_inset

's monad transformer is 
\begin_inset Formula $T_{L}^{M,A}\triangleq F^{A\rightarrow T_{P}^{M,Z}}\rightarrow T_{P}^{M,A}$
\end_inset

, where 
\begin_inset Formula $T_{P}^{M,A}$
\end_inset

 is 
\begin_inset Formula $P$
\end_inset

's monad transformer.
\end_layout

\begin_layout Subsection
Open problems
\begin_inset Index idx
status open

\begin_layout Plain Layout
open problems
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The author of this book does not know how to answer the following questions.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Are there any polynomial monads not obtained by a chain of constructions
 shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-polynomial-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

? The available constructions are:
\end_layout

\begin_layout Itemize
The polynomial monad 
\begin_inset Formula $F^{A}\triangleq Z+W\times A$
\end_inset

, where 
\begin_inset Formula $W$
\end_inset

 is a monoid and 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
\end_layout

\begin_layout Itemize
The free pointed monad 
\begin_inset Formula $L^{A}\triangleq A+F^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a monad.
\end_layout

\begin_layout Itemize
The product monad 
\begin_inset Formula $L^{A}\triangleq F^{A}\times G^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are monads.
\end_layout

\begin_layout Itemize
The composed monad 
\begin_inset Formula $L^{A}\triangleq F^{Z+W\times A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a monad, 
\begin_inset Formula $W$
\end_inset

 is a monoid, and 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Do all polynomial functors of the form 
\begin_inset Formula $P_{n}^{A}\triangleq\bbnum 1+\overbrace{A\times A\times...\times A}^{n\text{ times, }n\ge2}$
\end_inset

 fail to be monads? An example is the functor 
\begin_inset Formula $P_{2}^{A}\triangleq\bbnum 1+A\times A$
\end_inset

, which is not a monad because all possible implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods for 
\begin_inset Formula $P_{2}$
\end_inset

 fail the monad laws.
\begin_inset Foot
status open

\begin_layout Plain Layout
See discussion here: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/49742377"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-co-pointed-applicative"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-co-pointed-applicative"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-pointed-applicative-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that co-pointed applicative functors of the form 
\begin_inset Formula $L^{A}\triangleq A\times G^{A}$
\end_inset

 satisfy the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-of-extract-and-zip"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-pointed-applicative-example-failing-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $L^{A}\triangleq Z\times\left(Z\rightarrow A\right)$
\end_inset

 is applicative and co-pointed but fails the compatibility law.
 Do there exist any co-pointed applicative functors that satisfy the compatibili
ty law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-of-extract-and-zip"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and are 
\emph on
not
\emph default
 of the form 
\begin_inset Formula $A\times G^{A}$
\end_inset

 with some applicative functor 
\begin_inset Formula $G^{\bullet}$
\end_inset

? 
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-traverse-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-traverse-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the applicative naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 guarantee that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 evaluates each 
\begin_inset Formula $F$
\end_inset

- effect exactly once.
 (Possibly, use the composition of an applicative functor 
\begin_inset Formula $F$
\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad to count the number of times 
\begin_inset Formula $F$
\end_inset

-effects have been evaluated.)
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Does a monad transformer exist for every monad whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods are implemented using fully parametric code? Given the code for
 an arbitrary monad, can we derive the type constructor and the implementation
 of the corresponding monad transformer?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
We know that the monad transformers 
\begin_inset Formula $T_{L}$
\end_inset

 can be defined using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function for certain monads.
 Is this also the case for any monad stacks built out of such monads? If
 each of the monads 
\begin_inset Formula $L_{1}$
\end_inset

, 
\begin_inset Formula $L_{2}$
\end_inset

, ..., 
\begin_inset Formula $L_{k}$
\end_inset

 admits a transformer defined via a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function, will the monad 
\begin_inset Formula $L_{1}\varangle L_{2}\varangle...\varangle L_{k}$
\end_inset

 also admit a transformer with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function? (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Does-a-composition-have-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for some partial results.)
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-identity-natural-monad-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-identity-natural-monad-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Are there any monadically natural monad morphisms 
\begin_inset Formula $M\leadsto M$
\end_inset

 that are not identity? (Equivalently, are there any natural transformations
 
\begin_inset Formula $\text{Id}^{\bullet}\leadsto\text{Id}^{\bullet}$
\end_inset

 between identity functors in the category of monads, other than the identity
 transformation?)
\end_layout

\begin_layout Standard
We look for a monad morphism 
\begin_inset Formula $\varepsilon^{M,A}:M^{A}\rightarrow M^{A}$
\end_inset

 that is defined for all monads 
\begin_inset Formula $M$
\end_inset

 and is monadically natural in the parameter 
\begin_inset Formula $M$
\end_inset

.
 So, the function 
\begin_inset Formula $\varepsilon$
\end_inset

 must satisfy the following laws:
\begin_inset Formula 
\begin{align*}
\text{naturality law}:\quad & \varepsilon^{M,A}\bef(f^{:A\rightarrow B})^{\uparrow M}=(f^{:A\rightarrow B})^{\uparrow M}\bef\varepsilon^{M,B}\quad,\\
\text{monad morphism laws}:\quad & \text{pu}_{M}\bef\varepsilon=\text{pu}_{M}\quad,\quad\quad\varepsilon^{\uparrow M}\bef\varepsilon\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\varepsilon\quad,\\
\text{monadic naturality law}:\quad & \varepsilon^{M,A}\bef\phi^{:M^{:A}\rightarrow N^{A}}=\phi^{:M^{A}\rightarrow N^{A}}\bef\varepsilon^{N,A}\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is an arbitrary function, 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 are arbitrary monads, and 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 is an arbitrary monad morphism.
 The problem is either to prove that any such 
\begin_inset Formula $\varepsilon$
\end_inset

 must be an identity function, 
\begin_inset Formula $\varepsilon=\text{id}^{:M^{A}\rightarrow M^{A}}$
\end_inset

, or to show an example of such 
\begin_inset Formula $\varepsilon$
\end_inset

 not equal to identity.
\begin_inset Foot
status open

\begin_layout Plain Layout
See discussion here: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/61444425/"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If it were possible to show that any natural monad morphism 
\begin_inset Formula $M\leadsto M$
\end_inset

 is identity, there would be no need to verify the non-degeneracy law for
 monad transformers' base runners (see page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "par:Open-question-monad-id-trans"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Rigid functors
\begin_inset Quotes erd
\end_inset

 are defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Are there any rigid functors that are not monads? 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Are there any rigid functors that are not applicative?
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Is it true that any applicative rigid functor is a monad?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $L$
\end_inset

 be a fixed monad and 
\begin_inset Formula $H$
\end_inset

 be an 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctor.
 Then the functor 
\begin_inset Formula $F^{A}\triangleq H^{A}\rightarrow L^{A}$
\end_inset

 is a lawful monad (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-M-filterables"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 What is a monad transformer for the monad 
\begin_inset Formula $F$
\end_inset

? 
\end_layout

\begin_layout Standard
Two nontrivial examples of 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctors are 
\begin_inset Formula $H^{A}\triangleq A\rightarrow L^{Z}$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq L^{A}\rightarrow Z$
\end_inset

 (where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type).
 For these cases, the monad transformers are defined by
\begin_inset Formula 
\begin{align*}
 & \text{monad: }(A\rightarrow L^{Z})\rightarrow L^{A}\quad,\quad\quad\text{transformer: }(A\rightarrow T_{L}^{M,Z})\rightarrow T_{L}^{M,A}\quad,\\
 & \text{monad: }(L^{A}\rightarrow Z)\rightarrow L^{A}\quad,\quad\quad\text{transformer: }(T_{L}^{M,A}\rightarrow Z)\rightarrow T_{L}^{M,A}\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 is the monad 
\begin_inset Formula $L$
\end_inset

's transformer applied to the foreign monad 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
The problem is to implement the monad 
\begin_inset Formula $F$
\end_inset

's transformer for an arbitrary 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctor 
\begin_inset Formula $H$
\end_inset

 and to prove that the transformer laws hold.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume an arbitrary unknown monad 
\begin_inset Formula $M$
\end_inset

 and define recursively 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}$
\end_inset

.
 Can one define a lawful monad instance for the functor 
\begin_inset Formula $L$
\end_inset

? (This is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's transformer without the outer layer of 
\begin_inset Formula $M$
\end_inset

.
 See Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-effectful-list-not-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-2-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
These questions concern the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 transformer: 
\begin_inset Formula 
\[
T^{A}\triangleq M^{L^{A}}\quad,\quad\quad L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}\quad,
\]

\end_inset

where 
\begin_inset Formula $M$
\end_inset

 is an arbitrary foreign monad.
 Normally, we cannot implement fully parametric base runner 
\begin_inset Formula $T^{A}\rightarrow M^{A}$
\end_inset

 because we cannot have a fully parametric runner 
\begin_inset Formula $\text{List}^{A}\rightarrow A$
\end_inset

 operating on arbitrary types 
\begin_inset Formula $A$
\end_inset

.
 However, for a monoid type 
\begin_inset Formula $R$
\end_inset

 with binary operation 
\begin_inset Formula $\oplus_{R}$
\end_inset

 and empty element 
\begin_inset Formula $e_{R}$
\end_inset

, the type signature 
\begin_inset Formula $\text{List}^{R}\rightarrow R$
\end_inset

 is implemented by the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 operation: 
\begin_inset Formula 
\[
\text{reduce}:\text{List}^{R}\rightarrow R\quad,\quad\quad\text{reduce}\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline \bbnum 1 & 1\rightarrow e_{R}\\
R\times\text{List}^{R} & h\times t\rightarrow h\oplus_{R}\overline{\text{reduce}}\,(t)
\end{array}\quad.
\]

\end_inset

We can similarly implement a base runner (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

) for the transformer 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 if we restrict its usage to 
\emph on
monoid
\emph default
 types 
\begin_inset Formula $R$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $M^{L^{R}}\rightarrow M^{R}$
\end_inset

 aggregates all elements of the effectful list into a single value of type
 
\begin_inset Formula $M^{R}$
\end_inset

 (which is also a monoid type):
\begin_inset Formula 
\[
\text{brun}:M^{L^{R}}\rightarrow M^{R}\quad,\quad\quad\text{brun}\triangleq\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{R}\\
\hline \bbnum 1 & 1\rightarrow\text{pu}_{M}(e_{R})\\
R\times M^{L^{R}} & h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\quad.
\]

\end_inset

Here, we use the binary operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

 of the monoid 
\begin_inset Formula $M^{R}$
\end_inset

, defined by
\begin_inset Formula 
\[
p^{:M^{R}}\oplus_{M}q^{:M^{R}}\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 a monoid morphism 
\begin_inset Formula $T^{A}\rightarrow A$
\end_inset

? (Note that 
\begin_inset Formula $T^{A}$
\end_inset

 is a monoid since 
\begin_inset Formula $T$
\end_inset

 is a lawful monad.) The monoid morphism identity law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

.
 Does the composition law hold?
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Do the monad morphism laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 hold when restricted to a monoid type 
\begin_inset Formula $A$
\end_inset

?
\begin_inset Formula 
\begin{align*}
\text{for all monoid types }A:\quad & a^{:A}\triangleright\text{pu}_{T}\bef\text{brun}=a^{:A}\triangleright\text{pu}_{M}\quad,\\
\text{composition law}:\quad & p^{:T^{T^{A}}}\triangleright\text{ftn}_{T}\bef\text{brun }=p^{:T^{T^{A}}}\triangleright\text{brun}\bef\text{brun}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

(If so, Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 would show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 is also a 
\emph on
monoid
\emph default
 morphism 
\begin_inset Formula $M^{L^{A}}\rightarrow M^{A}$
\end_inset

.) 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Failed attempts to verify the composition law:
\end_layout

\begin_layout Plain Layout
Write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{T}\bef\text{brun}=\text{flm}_{M}(\text{prod})\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
\text{associativity of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}\bigg(\text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\bigg)\quad,\\
\text{right-hand side}:\quad & \text{brun}^{T^{R}}\bef\text{brun}^{\uparrow M}\bef\text{ftn}_{M}=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bigg)\bef\text{flm}_{M}(\text{brun})\\
\text{associativity of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\bigg)\quad.
\end{align*}

\end_inset

The remaining difference (under 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

) is an equation between functions of type 
\begin_inset Formula $L^{M^{L^{R}}}\rightarrow M^{R}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)=\text{prod}\bef\text{brun}\\
 & \quad\overset{?}{=}\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r^{:T^{R}}\times t^{:T^{T^{R}}}\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\quad.
\end{align*}

\end_inset

It is inconvenient to use matrices at this step because the code of 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

 is unknown.
 Instead, we will substitute into both sides an arbitrary value of type
 
\begin_inset Formula $L^{M^{L^{R}}}$
\end_inset

, which can be one of two possibilities, 
\begin_inset Formula $\text{Nil}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+h^{:T^{R}}\times t^{T^{T^{R}}}$
\end_inset

.
 Substituting 
\begin_inset Formula $\text{Nil}$
\end_inset

, we get:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \gunderline{\text{Nil}\triangleright\text{prod}}\bef\text{brun}=\text{Nil}\triangleright\text{pu}_{M}\bef\text{brun}\\
\text{use Eq.~(\ref{eq:listt-brun-derivation1})}:\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.\\
\text{right-hand side}:\quad & \text{Nil}\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=e_{T^{R}}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(\text{brun})=e_{R}\triangleright\gunderline{\text{pu}_{T}\bef\text{brun}}\\
\text{identity law of }\text{brun}:\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.
\end{align*}

\end_inset

The two sides are now equal.
 It remains to substitute the second possibility:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (\bbnum 0+h\times t)\triangleright\text{prod}\bef\text{brun}=\\
 & \quad=(\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\text{flm}_{M}(\overline{\text{prod}})
\end{array}\bef\text{brun}\\
 & \quad=\big(\text{comb}\,(h)(t\triangleright\text{flm}_{M}(\overline{\text{prod}}))\big)\triangleright\text{brun}\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\triangleright\xi\big)\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\xi\bef\text{brun}\big)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\big)\\
\text{right-hand side}:\quad & (\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=(\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t))\triangleright\text{flm}_{M}(\text{brun})\\
 & \quad=t\triangleright\overline{\text{brun}}\triangleright(v\rightarrow h\oplus_{R}v)^{\uparrow M}\triangleright\text{flm}_{M}(\text{brun})
\end{align*}

\end_inset

This is suspicious: we need to show that an expression 
\begin_inset Formula $h\triangleright\text{flm}_{M}(t\triangleright...)$
\end_inset

 is equal to 
\begin_inset Formula $t\triangleright...$
\end_inset

, and it seems impossible to convert one into another, given that 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

 are arbitrary values.
\end_layout

\begin_layout Plain Layout
Note that
\begin_inset Formula 
\[
\text{pu}_{M}(r^{:R})\oplus_{M}q^{:M^{R}}=r\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M})=q\triangleright(v\rightarrow r\oplus_{R}v)^{\uparrow M}\quad.
\]

\end_inset

In particular,
\begin_inset Formula 
\[
\text{pu}_{M}(p)\oplus_{M}\text{pu}_{M}(q)=q\triangleright\text{pu}_{M}\triangleright(v\rightarrow p\oplus_{R}v)^{\uparrow M}=q\triangleright(v\rightarrow p\oplus_{R}v)\triangleright\text{pu}_{M}=\text{pu}_{M}(p\oplus_{R}q)\quad.
\]

\end_inset

We also have the property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \big(\text{comb}\,(p)(q)\big)\triangleright\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}(q\triangleright\xi)\bef\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}((q\triangleright\xi)\bef\text{flm}_{M}(g))\\
 & =p\triangleright\text{flm}_{M}\bigg(\begin{array}{||c|}
1\rightarrow q\\
h\times t\rightarrow\text{pu}_{M}\big(\bbnum 0+h\times\overline{\text{comb}}\,(t)(q)
\end{array}\,\bef\text{flm}_{M}(g)\bigg)
\end{align*}

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-monatron-lift-reset-and-shift"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-monatron-lift-reset-and-shift"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The continuation monad's operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reset
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shift
\end_layout

\end_inset

 are defined by:
\begin_inset Formula 
\begin{align*}
 & \text{reset}:\forall S.\,\text{Cont}^{R,R}\rightarrow\text{Cont}^{S,R}\quad,\quad\quad\text{reset}\triangleq c^{:\left(R\rightarrow R\right)\rightarrow R}\rightarrow k^{:R\rightarrow S}\rightarrow k(c(\text{id}))\quad,\\
 & \text{shift}:\forall A.\,((A\rightarrow R)\rightarrow\text{Cont}^{R,R})\rightarrow\text{Cont}^{R,A}\quad,\quad\quad\text{shift}\triangleq g^{:\left(A\rightarrow R\right)\rightarrow\text{Cont}^{R,R}}\rightarrow k^{:A\rightarrow R}\rightarrow g(k)(\text{id})\quad.
\end{align*}

\end_inset

How to lift these operations to an arbitrary monad stack 
\begin_inset Formula $P$
\end_inset

 that contains a continuation monad?
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/renormalist/pugs/blob/master/src/Pugs/AST/Eval.hs"
literal "false"

\end_inset


\family default
 for custom code (in Haskell) that lifts 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reset
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shift
\end_layout

\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT
\end_layout

\end_inset

 monad transformer.
\end_layout

\end_inset

 What are the appropriate type signatures for the lifted operations?
\end_layout

\end_body
\end_document
