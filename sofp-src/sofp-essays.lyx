#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset Quotes eld
\end_inset

Applied functional type theory
\begin_inset Quotes erd
\end_inset

: A proposal
\begin_inset CommandInset label
LatexCommand label
name "chap:Applied-functional-type"

\end_inset


\end_layout

\begin_layout Standard
What exactly is the extent of 
\begin_inset Quotes eld
\end_inset

theory
\begin_inset Quotes erd
\end_inset

 that a software engineer should know in order to be a proficient functional
 programmer? This book proposes an answer to that question by presenting
 a coherent body of theoretical knowledge that, in the author's view, 
\emph on
is
\emph default
 the theory that underlies the practice of functional programming and guides
 software engineers in writing code.
 This body of knowledge may be viewed as a new emerging sub-branch of computer
 science, tentatively called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
applied functional type theory
\end_layout

\end_inset

applied functional type theory
\series default
 (AFTT).
 
\end_layout

\begin_layout Standard
In order to discover the proper scope of AFTT, this book appraises the various
 inventions made in the field of functional programming in the last 30 years,
 such as the “functional pearls” papers
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://wiki.haskell.org/Research_papers/Functional_pearls"
target "https://wiki.haskell.org/Research_papers/Functional_pearls"
literal "false"

\end_inset


\end_layout

\end_inset

 and various online tutorials, looking for theoretical material that has
 demonstrated its pragmatic usefulness.
 As a first step towards formulating AFTT from the ground up, the results
 are presented in the form of a tutorial, with motivations and rigorous
 derivations of substantially all relevant mathematical facts.
\end_layout

\begin_layout Standard
In this book, code examples are written in Scala because the author is fluent
 in that language.
 However, most of the material will work equally well in Haskell, OCaml,
 and other FP languages.
 This is because AFTT is the science of functional programming and not a
 set of tricks specific to Scala or Haskell.
 An advanced user of any functional programming language will have to face
 the same questions and struggle with the same practical issues.
\end_layout

\begin_layout Section
AFTT is not covered by courses in computer science
\end_layout

\begin_layout Standard
Traditional courses of computer science (algorithms and data structures,
 complexity theory, distributed systems, databases, network systems, compilers,
 operating systems) are largely not relevant to AFTT.
 Courses in programming language theory are more relevant but are not presented
 at an appropriate level.
 To an academic computer scientist, the theory behind Haskell is the version
 of 
\begin_inset Formula $\lambda$
\end_inset

-calculus known as
\begin_inset Index idx
status open

\begin_layout Plain Layout
System 
\begin_inset Formula $F_{\omega}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

System 
\begin_inset Formula $F_{\omega}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://babel.ls.fi.upm.es/~pablo/Papers/Notes/f-fw.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 This theory guided the design of the Haskell language and defines rigorously
 what a Haskell program means in a mathematical sense.
 The theory behind Scala is the 
\begin_inset Quotes eld
\end_inset

dependent object type
\begin_inset Quotes erd
\end_inset

 (DOT) calculus.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html"

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent object type (DOT) calculus
\end_layout

\end_inset

 That theory guided the design of Scala version 3.
\end_layout

\begin_layout Standard
However, a practicing Haskell or Scala programmer is not concerned with
 designing Haskell or Scala, or with proving theoretical properties of those
 languages.
 Instead, the programmer is mainly concerned with 
\emph on
using
\emph default
 a chosen programming language to write code.
 
\end_layout

\begin_layout Standard
Knowing how to prove various properties of DOT or System 
\begin_inset Formula $F_{\omega}$
\end_inset

 will not actually help programmers to write code.
 So, these theories are outside the scope of AFTT.
 Functional programming does not require graduate-level theoretical studies.
\end_layout

\begin_layout Standard
As an example of theoretical material that 
\emph on
is
\emph default
 within the scope of AFTT, consider applicative functors (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative functors
\end_layout

\end_inset

 It is helpful for a practicing functional programmer to be able to recognize
 and use applicative functors.
 An applicative functor is a data structure specifying declaratively a set
 of operations that can run independently of each other.
 Programs may combine these operations, for example, to execute them in
 parallel, or to refactor the program for better maintainability.
\end_layout

\begin_layout Standard
To use this functionality, the programmer must begin by checking whether
 a given data structure satisfies the laws of applicative functors.
 In a given application, the choice of a data structure may be dictated
 in part by the business logic.
 The programmer first writes down the type of that data structure and the
 code implementing the required methods.
 The programmer can then check whether the laws hold.
 The data structure may need to be adjusted in order to fit the definition
 of an applicative functor or to make the laws hold.
\end_layout

\begin_layout Standard
So, the programmer needs to perform a certain amount of symbolic derivations
 before coding.
 The derivations can be done using pen and paper by writing equations in
 a concise mathematical notation.
 Once the applicative laws are verified, the programmer proceeds to write
 code.
\end_layout

\begin_layout Standard
The mathematical proofs and derivations assure that the chosen data structure
 will satisfy the laws of applicative functors, no matter how the rest of
 the program is written.
 So, for example, it is assured that the relevant operations can be automaticall
y parallelized and will still work correctly.
 In this way, AFTT directly guides the programmer and helps write correct
 code.
\end_layout

\begin_layout Standard
Applicative functors were discovered by practitioners who were using Haskell
 to implement parser combinators for compilers.
 However, applicative functors are not a feature of Haskell: they can be
 used in Scala or any other functional programming language.
 A prominent example of an applicative functor is Apache Spark's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RDD
\end_layout

\end_inset

 data type, which is widely used for implementing large-scale parallel computati
ons.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://spark.apache.org/docs/latest/rdd-programming-guide.html"
literal "false"

\end_inset


\end_layout

\end_inset

 And yet, no standard computer science textbook defines applicative functors,
 motivates their laws, explores their structure on examples, or shows data
 types that are 
\emph on
not
\emph default
 applicative functors (and explains why not).
 
\end_layout

\begin_layout Section
AFTT is not category theory, type theory, or formal logic
\end_layout

\begin_layout Standard
One often hears that functional programming is based on category theory.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.47deg.com/blog/science-behind-functional-programming/"
literal "false"

\end_inset


\end_layout

\end_inset

 Indeed, the material shown in this book includes a (small) number of notions
 from category theory (as well as from formal logic and type theory).
 However, software engineers would not benefit from traditional academic
 courses in those subjects: their presentation is too abstract and at the
 same time lacks specific results necessary for practical programming.
 Those courses answer questions that academic mathematicians have, not questions
 that practicing functional programmers have.
\end_layout

\begin_layout Standard
There exist books intended as presentations of category theory for computer
 scientists
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/dp/0262660717"

\end_inset


\end_layout

\end_inset

 or for programmers.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/hmemcpy/milewski-ctfp-pdf"

\end_inset


\end_layout

\end_inset

 However, those books do not cover certain concepts relevant to programming,
 such as applicative
\begin_inset Foot
status open

\begin_layout Plain Layout
Applicative functors are known in mathematics as 
\begin_inset Quotes eld
\end_inset

monoidal
\begin_inset Quotes erd
\end_inset

: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Monoidal_functor"

\end_inset


\end_layout

\end_inset

 or traversable functors.
 Instead, those books dwell on concepts (e.g., limits, enriched categories,
 topoi) that have no applications in practical functional programming today.
\end_layout

\begin_layout Standard
Typical questions in academic books are 
\begin_inset Quotes eld
\end_inset

Is 
\begin_inset Formula $X$
\end_inset

 an introduction rule or an elimination rule
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Does property 
\begin_inset Formula $Y$
\end_inset

 hold in non-small categories or only in the category of sets
\begin_inset Quotes erd
\end_inset

.
 Questions a Scala programmer might ask are 
\begin_inset Quotes eld
\end_inset

Can we compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Z, R => A]
\end_layout

\end_inset

 from a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R => Either[Z, A]
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Is the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] = Option[(A,A,A)]
\end_layout

\end_inset

 a monad or only an applicative functor
\begin_inset Quotes erd
\end_inset

.
 The scope of AFTT includes answering the last two questions but 
\emph on
not
\emph default
 the first two.
\end_layout

\begin_layout Standard
A software engineer hoping to understand the theory behind functional programmin
g will not find the concepts of filterable, applicative, or traversable
 functors in any currently available books on category theory, including
 books intended for programmers.
 And yet, these concepts are necessary for correct implementations of the
 important and widely used operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To compensate for the lack of AFTT textbooks, programmers have written many
 online tutorials, aiming to explain the theoretical concepts necessary
 for practical work.
 The term 
\begin_inset Quotes eld
\end_inset

monad tutorial
\begin_inset Quotes erd
\end_inset

 became infamous because so many were  posted online.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.johndcook.com/blog/2014/03/03/monads-are-hard-because/"

\end_inset


\end_layout

\end_inset

 Tutorials were also written about applicative functors, traversable functors,
 free monads, etc., showing a real unfulfilled need for presenting practice-relev
ant fragments of theory in an applied setting.
 
\end_layout

\begin_layout Standard
For example, 
\begin_inset Quotes eld
\end_inset

free monads
\begin_inset Quotes erd
\end_inset

 became popular in the Scala community around 2015.
 Many talks about free monads were presented at Scala engineering conferences,
 giving different implementations but never formulating rigorously the propertie
s required for a piece of code to be a valid implementation of the free
 monad.
 Without knowing the required mathematical properties of free monads, a
 programmer cannot make sure that a given implementation is correct.
 However, books on category theory define free monads in a way that is unsuitabl
e for programming applications (a free monad is an adjoint functor to a
 forgetful functor from a Kleisli category to the category of sets).
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\emph on
A monad is just a monoid in the category of endofunctors.
 What's the problem?
\emph default

\begin_inset Quotes erd
\end_inset

 as the joke goes.
 For background information about that joke, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/3870088/"

\end_inset


\end_layout

\end_inset

 Such 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 definitions can be used neither as guidance for writing code or checking
 code correctness, nor as a conceptual explanation that a learner would
 find helpful.
\end_layout

\begin_layout Standard
Perhaps the best selection of AFTT tutorial material today can be found
 in the 
\begin_inset Quotes eld
\end_inset

Haskell Wikibooks
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikibooks.org/wiki/Haskell"
target "https://en.wikibooks.org/wiki/Haskell"
literal "false"

\end_inset


\end_layout

\end_inset

 However, those tutorials are incomplete and limited to explaining the use
 of Haskell.
 Many of them are suitable neither as a first introduction nor as a reference
 on AFTT.
 Also, the Haskell Wikibooks tutorials rarely show any derivations of laws
 or explain the required techniques.
\end_layout

\begin_layout Standard
Apart from referring to some notions from category theory, AFTT also uses
 concepts from type theory and formal logic.
 However, existing textbooks on type theory and formal logic focus on domain
 theory and proof theory.
 From a practicing programmer's viewpoint, these books present a lot of
 difficult-to-learn material that will not help in writing code.
 At the same time, those academic books never mention practical techniques
 used in many functional programming libraries today, such as reasoning
 about and implementing types with quantifiers, types parameterized by type
 constructors, or partial type-level functions (known as 
\begin_inset Quotes eld
\end_inset

typeclasses
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
The proper scope of AFTT is to help the programmer with practical tasks
 such as:
\end_layout

\begin_layout Enumerate
Deciding whether two data types are equivalent and implementing the isomorphism
 transformations.
 For example, the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, Either[B, C])
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, B), (A, C)]
\end_layout

\end_inset

, but the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Either[B, C]
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A => B, A => C]
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Checking whether a definition of a recursive type is 
\begin_inset Quotes eld
\end_inset

valid
\begin_inset Quotes erd
\end_inset

, i.e., does not lead to infinite loops.
 A simple example of an 
\begin_inset Quotes eld
\end_inset

invalid
\begin_inset Quotes erd
\end_inset

 recursive type definition in Scala is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class Bad(x: Bad)
\end_layout

\end_inset

.
 A small change transforms that example into a 
\begin_inset Quotes eld
\end_inset

valid
\begin_inset Quotes erd
\end_inset

 recursive type: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class Good(x: Option[Good])
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Deciding whether a function with a given type signature can be implemented.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[Z,A,R]: (R => Either[Z, A]) => Either[Z, R => A] = ???   // Cannot
 be implemented.
\end_layout

\begin_layout Plain Layout

def g[Z,A,R]: Either[Z, R => A] => (R => Either[Z, A]) = ???   // Can be
 implemented.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Deriving an implementation of a function from its type signature and checking
 required laws.
 For example, deriving the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method and checking its laws for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[Z, A, B](r: Z => A)(f: A => Z => B): Z => B = ???
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Deriving a simpler but equivalent code by calculating with functions and
 laws.
\end_layout

\begin_layout Standard
These are real-world applications of type theory and the Curry-Howard correspond
ence, but existing books on type theory and logic do not give practical
 recipes for performing these tasks.
\begin_inset Foot
status open

\begin_layout Plain Layout
Task 5 is addressed in several programming-oriented books such as 
\emph on
Pearls of functional algorithm design
\emph default
 by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bird
\end_layout

\end_inset

Richard Bird (
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.cambridge.org/9780521513388"
literal "false"

\end_inset


\family default
).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Books such as 
\emph on
Scala with Cats
\emph default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://underscore.io/books/scala-with-cats/"
target "https://underscore.io/books/scala-with-cats/"
literal "false"

\end_inset


\end_layout

\end_inset

 
\emph on
Functional programming simplified
\emph default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://alvinalexander.com/scala/functional-programming-simplified-book"
target "https://alvinalexander.com/scala/functional-programming-simplified-book"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\emph on
Functional programming for mortals
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.lulu.com/shop/search.ep?contributorId=1600066"

\end_inset


\end_layout

\end_inset

 are primarily focused on explaining practical aspects of functional programming
 and do not derive the mathematical laws for, e.g., filterable, monadic, applicati
ve, or traversable functors.
\end_layout

\begin_layout Standard
The only currently available Scala-based AFTT textbook is 
\emph on
Functional Programming in Scala
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://www.manning.com/books/functional-programming-in-scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\end_layout

\end_inset

 It balances practical coding with theoretical developments and laws.
 
\emph on
Program design by calculation
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www4.di.uminho.pt/~jno/ps/pdbc.pdf"

\end_inset


\end_layout

\end_inset

 is another (Haskell-oriented) AFTT book in progress.
 The present book is written at about the same level but aims at better
 motivation for mathematical concepts and a wider range of pedagogical examples
 that help build the necessary intuition and facility with the techniques
 of formal derivation.
 
\end_layout

\begin_layout Standard
Figures
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Randomly-chosen-pages"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Randomly-chosen-pages-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 illustrate the difference between AFTT books, programming books, and academic
 science books, by showing randomly chosen pages from such books.
 Programming-oriented books contain code examples and explanations in words,
 but no formal derivations.
 Books on AFTT, as well as books on mathematics and science, will typically
 show equations, diagrams, and derivations.
 The present book contains both code examples and mathematical manipulations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming simplified
\emph default
, by A.
\begin_inset space ~
\end_inset

Alexander
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
\begin_inset VSpace -160baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming for mortals
\emph default
, by S.
\begin_inset space ~
\end_inset

Halliday
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
\begin_inset VSpace -190baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Practical functional programming in Scala
\emph default
, by G.
\begin_inset space ~
\end_inset

Volpe (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://leanpub.com/pfp-scala"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Mastering advanced Scala
\emph default
, by D.
\begin_inset space ~
\end_inset

Kalinin (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://leanpub.com/mastering-advanced-scala"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on Scala programming.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -40baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Linear algebra
\emph default
, by J.
\begin_inset space ~
\end_inset

Hefferon (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "http://joshua.smcvt.edu/linearalgebra/"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Classical mechanics
\emph default
, by T.
\begin_inset space ~
\end_inset

W.
\begin_inset space ~
\end_inset

B.
\begin_inset space ~
\end_inset

Kibble and F.
\begin_inset space ~
\end_inset

H.
\begin_inset space ~
\end_inset

Berkshire (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://archive.org/details/116772449ClassicalMechanics"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on mathematics and physics.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming in Scala
\emph default
, by P.
\begin_inset space ~
\end_inset

Chiusano and R.
\begin_inset space ~
\end_inset

Bjarnason
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Program design by calculation
\emph default
, by J.
\begin_inset space ~
\end_inset

N.
\begin_inset space ~
\end_inset

Oliveira
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
The science of functional programming
\emph default
 (this book)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on applied functional type theory.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Essay: Software engineers and software artisans
\end_layout

\begin_layout Standard
Let us examine what we ordinarily understand by 
\emph on
engineering
\emph default
 as opposed to artisanship or craftsmanship.
 It will then become apparent that today's computer programmers must be
 viewed as 
\begin_inset Quotes eld
\end_inset

software artisans
\begin_inset Quotes erd
\end_inset

 rather than software engineers.
\end_layout

\begin_layout Section
Engineering disciplines 
\end_layout

\begin_layout Standard
Consider the way mechanical engineers, chemical engineers, or electrical
 engineers work, and look at the studies they require for becoming proficient
 in their fields.
\end_layout

\begin_layout Standard
A mechanical engineer studies
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.colorado.edu/mechanical/academics/undergraduate-program/curriculum"
literal "false"

\end_inset


\end_layout

\end_inset

 calculus, linear algebra, differential geometry, and several areas of physics
 such as theoretical mechanics, thermodynamics, and elasticity theory, and
 then uses calculations to guide the design of a bridge.
 A chemical engineer studies
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.colorado.edu/engineering/sample-undergraduate-curriculum-chemical"
literal "false"

\end_inset


\end_layout

\end_inset

 chemistry, thermodynamics, calculus, linear algebra, differential equations,
 some areas of physics such as thermodynamics and kinetic theory, and uses
 calculations to guide the design of a chemical process.
 An electrical engineer studies
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/XYLyE"
literal "false"

\end_inset


\end_layout

\end_inset

 advanced calculus, linear algebra, and several areas of physics such as
 electrodynamics and quantum theory, and uses calculations to design an
 antenna or a microchip.
\end_layout

\begin_layout Standard
The pattern here is that an engineer uses mathematics and natural sciences
 in order to create new devices.
 Mathematical calculations and scientific reasoning are performed 
\emph on
before
\emph default
 designing or building a real machine.
\end_layout

\begin_layout Standard
Some of the studies required for engineers include arcane abstract concepts
 such as the 
\begin_inset Quotes eld
\end_inset

Fourier transform of the delta function
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.youtube.com/watch?v=KAbqISZ6SHQ"
literal "false"

\end_inset


\end_layout

\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

inverse 
\begin_inset Formula $Z$
\end_inset

-transform
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/SsJqP"
literal "false"

\end_inset


\end_layout

\end_inset

 in digital signal processing, 
\begin_inset Quotes eld
\end_inset

rank-4 elasticity tensors
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral_physics/tensors.html"
literal "false"

\end_inset


\end_layout

\end_inset

 in calculations of elasticity of materials, 
\begin_inset Quotes eld
\end_inset

Lagrangians with non-holonomic constraints
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/abs/math/0008147"
literal "false"

\end_inset


\end_layout

\end_inset

 in robotics, and the 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

 in chemical reactor design.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Introduction-Chemical-Engineering-Kinetics-Reactor/dp/1118368258"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To be sure, a significant part of what engineers do is not covered by any
 theory: the 
\emph on
know-how
\emph default
, the informal reasoning, the traditional knowledge passed on from expert
 to novice,  — all those skills that are hard to formalize are important.
 Nevertheless, engineering is crucially based on natural science and mathematics
 for some of its decision-making about new designs.
\end_layout

\begin_layout Section
Artisanship: Trades and crafts 
\end_layout

\begin_layout Standard
Now consider what kinds of things shoemakers, plumbers, or home painters
 do, and what they have to learn in order to become proficient in their
 profession.
\end_layout

\begin_layout Standard
A novice shoemaker, for example, begins by copying some drawings
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://youtu.be/cY5MY0czMAk?t=141"
literal "false"

\end_inset


\end_layout

\end_inset

 and goes on to cutting leather in a home workshop.
 Apprenticeships proceed via learning by doing, with comments and instructions
 from an expert.
 After a few years of study (for example, a painter apprenticeship in California
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.calapprenticeship.org/programs/painter_apprenticeship.php"
literal "false"

\end_inset


\end_layout

\end_inset

 can be as short as 2 years), a new artisan is ready to start productive
 work.
 
\end_layout

\begin_layout Standard
All trades operate entirely from tradition and practical experience.
 It takes a prolonged learning effort to become a good artisan in any profession.
 But the trades do not require academic study because there is no formal
 theory from which to proceed.
 There are no Fourier transforms applied to delta functions, no Lagrangians
 with non-holonomic constraints, no rank-4 tensors to calculate, nor any
 differential equations to solve.
\end_layout

\begin_layout Standard
Artisans do not study science or mathematics because their professions do
 not make use of any formal theory for guiding their designs or processes.
\end_layout

\begin_layout Section
Programmers today are artisans, not engineers 
\end_layout

\begin_layout Standard
Programmers are 
\emph on
not engineers
\emph default
 in the sense normally used in the engineering professions.
\end_layout

\begin_layout Subsection
No requirements of licensing or formal study
\end_layout

\begin_layout Standard
Mechanical, electrical, chemical engineers are required to pass a license
 exam to become certified to work.
 The license exam certifies that the person is proficient in applying a
 known set of engineering tools and methods.
 But in software engineering, no certifications or licenses are required
 for the job (although many certification programs exist).
\end_layout

\begin_layout Standard
Working software engineers are also not required to have studied software
 engineering or computer science (CS).
 According to a recent Stack Overflow survey,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://thenextweb.com/insider/2016/04/23/dont-need-go-college-anymore-programmer/"
literal "false"

\end_inset


\end_layout

\end_inset

 about 56% of working programmers have no CS degree.
 The author of this book is a self-taught programmer who has degrees in
 physics but never formally studied CS or taken any academic courses in
 algorithms, data structures, computer networks, compilers, programming
 languages, or other CS topics.
 
\end_layout

\begin_layout Standard
A large fraction of successful programmers have no college degrees and perhaps
 
\emph on
never
\emph default
 studied formally.
 They acquired all their knowledge and skills through self-study and practical
 work.
 A prominent example is Robert C.
\begin_inset space ~
\end_inset

Martin
\begin_inset Index idx
status open

\begin_layout Plain Layout
Robert C.
\begin_inset space ~
\end_inset

Martin
\end_layout

\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Robert_C._Martin"
literal "false"

\end_inset


\end_layout

\end_inset

 an outspoken guru in the arts of programming.
 He routinely refers to programmers as artisans
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2013/02/01/The-Humble-Craftsman.html"
literal "false"

\end_inset


\end_layout

\end_inset

 and uses the appropriate imagery: novices and masters, trade and craft,
 the honor of the guild, etc.
 He compares programmers to plumbers, electricians, lawyers, and surgeons,
 but never to mathematicians, physicists, or engineers of any kind.
 According to one of his blog posts,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2013/11/25/Novices-Coda.html"
literal "false"

\end_inset


\end_layout

\end_inset

 he started working at age 17 as a self-taught programmer, and then went
 on to more jobs in the software industry; he never mentions going to college.
 It is clear that R.
\begin_inset space ~
\end_inset

C.
\begin_inset space ~
\end_inset

Martin 
\emph on
is
\emph default
 an expert craftsman and that he did 
\emph on
not
\emph default
 need academic study to master his craft.
\end_layout

\begin_layout Standard
Here is another opinion
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/tAKQ3"
literal "false"

\end_inset


\end_layout

\end_inset

 (emphasis is theirs):
\end_layout

\begin_layout Quotation

\size small
Software Engineering is unique among the STEM careers in that it absolutely
 does 
\emph on
not
\emph default
 require a college degree to be successful.
 It most certainly does not require licensing or certification.
 
\emph on
It requires experience
\emph default
.
\end_layout

\begin_layout Standard
This description fits a career in crafts — but certainly not a career, say,
 in electrical engineering.
\end_layout

\begin_layout Standard
The high demand for software developers gave rise to 
\begin_inset Quotes eld
\end_inset

developer boot camps
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/GkOL9"
literal "false"

\end_inset


\end_layout

\end_inset

 — vocational schools that educate new programmers in a few months through
 purely practical training, with no formal theory or mathematics involved.
 These vocational schools are successful
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/E9FXP"
literal "false"

\end_inset


\end_layout

\end_inset

 in job placement.
 But it is unimaginable that a 
\begin_inset Formula $6$
\end_inset

-month crash course or even a 
\begin_inset Formula $2$
\end_inset

-year vocational school could prepare engineers to work successfully on
 designing, e.g., analog quantum computers
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.dwavesys.com/quantum-computing"

\end_inset


\end_layout

\end_inset

 without ever teaching them quantum physics or calculus.
\end_layout

\begin_layout Subsection
No mathematical formalism guides software development
\end_layout

\begin_layout Standard
Most books on software engineering contain no formulas or equations, no
 mathematical derivations, and no precise definitions of the various technical
 terms they are using (such as 
\begin_inset Quotes eld
\end_inset

object-oriented
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

module's responsibilities
\begin_inset Quotes erd
\end_inset

).
 Some of those books
\begin_inset Foot
status open

\begin_layout Plain Layout
E.g., 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Object-Oriented-Software-Engineering-Unified-Methodology/dp/0073376256"

\end_inset


\end_layout

\end_inset

 also have almost no program code in them; instead they are filled with
 words and illustrative diagrams.
 These books talk about how programmers should write their programs in vague
 and general terms: 
\begin_inset Quotes eld
\end_inset

code is about detail
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

you must never abandon the big picture
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

avoid tight coupling in your modules
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a class must serve a single responsibility
\begin_inset Quotes erd
\end_inset

, and so on.
 Practitioners such as R.
\begin_inset space \space{}
\end_inset

C.
\begin_inset space \space{}
\end_inset

Martin never studied any formalisms and do not think in terms of formalisms.
 Instead, they summarize their programming experience in vaguely formulated
 heuristic “principles”.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In contrast, textbooks on mechanical or electrical engineering include a
 significant amount of mathematics.
 The design of a microwave antenna is guided not by an 
\begin_inset Quotes eld
\end_inset

open and closed module principle
\begin_inset Quotes erd
\end_inset

 but by solving the relevant differential equations
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://youtu.be/8KpfVsJ5Jw4?t=447"
literal "false"

\end_inset


\end_layout

\end_inset

 of electrodynamics.
\end_layout

\begin_layout Standard
An example of the aversion of software engineers to mathematical tools is
 found in the 
\begin_inset Quotes eld
\end_inset

Liskov substitution principle
\begin_inset Index idx
status open

\begin_layout Plain Layout
Liskov substitution principle
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 that describes subtyping
\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Liskov_substitution_principle"
literal "false"

\end_inset


\family default
.
 Let us note that the LSP always holds in functional programming where values
 are immutable and subtyping is viewed as an automatic insertion of a type
 conversion function (see Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-subtyping"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 A property 
\begin_inset Formula $\phi(y)$
\end_inset

 is rewritten as 
\begin_inset Formula $\phi(c(y))$
\end_inset

 by inserting a suitable type conversion function, 
\begin_inset Formula $c:S\rightarrow T$
\end_inset

.
 Since 
\begin_inset Formula $c(y)$
\end_inset

 has type 
\begin_inset Formula $T$
\end_inset

 and 
\begin_inset Formula $\phi(x)$
\end_inset

 holds for all values 
\begin_inset Formula $x:T$
\end_inset

, we find that the property 
\begin_inset Formula $\phi(c(y))$
\end_inset

 always holds.
\end_layout

\end_inset

 Its rigorous formulation (
\begin_inset Quotes eld
\end_inset

for any property 
\begin_inset Formula $\phi(x)$
\end_inset

 that holds for all 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $T$
\end_inset

, and for any subtype 
\begin_inset Formula $S$
\end_inset

 of 
\begin_inset Formula $T$
\end_inset

, the property 
\begin_inset Formula $\phi(y)$
\end_inset

 must also hold for all 
\begin_inset Formula $y$
\end_inset

 of type 
\begin_inset Formula $S$
\end_inset


\begin_inset Quotes erd
\end_inset

) is not used by programmers.
 Instead, the literature on object-oriented programming formulates the principle
 as 
\begin_inset Quotes eld
\end_inset

objects of type 
\begin_inset Formula $T$
\end_inset

 may be substituted by objects of type 
\begin_inset Formula $S$
\end_inset

 without changing the correctness of the program
\begin_inset Quotes erd
\end_inset

.
 This formulation 
\begin_inset Index idx
status open

\begin_layout Plain Layout
object-oriented programming
\end_layout

\end_inset

 is both vague (it does not specify how to choose the substituted objects
 of type 
\begin_inset Formula $S$
\end_inset

) and, strictly speaking, incorrect: If the program consists of a function
 
\begin_inset Formula $f(t)$
\end_inset

 where 
\begin_inset Formula $t$
\end_inset

 is a value of type 
\begin_inset Formula $T$
\end_inset

, it is not always possible to find some value 
\begin_inset Formula $s$
\end_inset

 of type 
\begin_inset Formula $S$
\end_inset

 such that 
\begin_inset Formula $f(s)=f(t)$
\end_inset

.
 The reason is that some subtyping relations are not surjective, as shown
 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Subtyping-with-injective"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Donald Knuth's classic textbook is called 
\begin_inset Quotes eld
\end_inset


\emph on
The Art of Programming
\emph default

\begin_inset Quotes erd
\end_inset

.
 Knuth indeed treats programming as an art rather than as a science.
 He shows many algorithms and derives their mathematical properties but
 gives almost no examples of program code and does not provide any formal
 theory that could guide programmers in actually 
\emph on
writing
\emph default
 programs.
 Knuth assumes that the reader who understands the mathematical details
 of an algorithm will be able 
\emph on
somehow
\emph default
 to translate the mathematics into correct code without further guidance.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
His books do not propose a formalism that could guide the process of writing
 programs (say, choosing the data types to be used), similarly to how calculatio
ns with 
\begin_inset Quotes eld
\end_inset

Green's functions
\begin_inset Quotes erd
\end_inset

 in electrodynamics are at the foundation of the design of a radar, while
 calculations in theoretical mechanics involving 
\begin_inset Quotes eld
\end_inset

non-holonomic constraints
\begin_inset Quotes erd
\end_inset

 are at the foundation of the design of a robot arm.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The books 
\begin_inset Quotes eld
\end_inset

The Science of Programming
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Science-Programming-Monographs-Computer/dp/0387964800"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Program derivation
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Program-Derivation-Development-Specifications-International/dp/0201416247"
literal "false"

\end_inset


\end_layout

\end_inset

 are attempts to provide a mathematical basis for writing programs starting
 from formal specifications.
 The books give some methods that guide programmers in writing code and
 at the same time produce a proof that the code conforms to the specification.
 However, the scope of proposed methods is limited to design of simple algorithm
s for iterative manipulation of data (such as, sorting and searching altorighms).
 The procedures suggested in those books are far from a formal mathematical
 
\emph on
derivation
\emph default
 of arbitrary software programs from specifications.
 In any case, almost all programmers today are oblivious to these books
 and do not use the methods explained there, even when those methods could
 apply.
\end_layout

\begin_layout Standard
Today's computer science courses do not teach a true 
\emph on
engineering
\emph default
 approach to software construction.
 They do, however, teach analysis of programs using formal mathematical
 methods.
 Two such methods are complexity analysis
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html"
literal "false"

\end_inset


\end_layout

\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

big-
\begin_inset Formula $O$
\end_inset

 notation
\begin_inset Quotes erd
\end_inset

) and formal verification.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Formal_verification"
literal "false"

\end_inset


\end_layout

\end_inset

 But programs are analyzed or verified only 
\emph on
after
\emph default
 they are somehow written.
 Theory does not guide the actual 
\emph on
process
\emph default
 of writing code, does not suggest good ways of organizing the code (e.g.,
 how to decompose the code into modules, classes, or functions), does not
 tell programmers which data structures and type signatures of functions
 will be useful to implement.
 Programmers make such design decisions on the basis of experience and intuition
, trial-and-error, copy-paste, guesswork, and debugging.
 
\end_layout

\begin_layout Standard
In this context, program analysis and verification is analogous to writing
 mathematical equations describing the surface of a shoe made by a fashion
 designer.
 The resulting 
\begin_inset Quotes eld
\end_inset

shoe equations
\begin_inset Quotes erd
\end_inset

 are mathematically rigorous and can be analyzed or 
\begin_inset Quotes eld
\end_inset

verified
\begin_inset Quotes erd
\end_inset

.
 But the equations are merely written after the fact — they do not guide
 the fashion designers in actually making shoes.
 It is understandable that fashion designers do not study the mathematical
 theory of surfaces.
\end_layout

\begin_layout Subsection
Programmers avoid academic terminology 
\end_layout

\begin_layout Standard
Programmers jokingly grumble about terms such as 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

monad
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

lambda-functions
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Quote

\size small
Those fancy words used by functional programmers purists really annoy me.
 Monads, functors...
 Nonsense!!! 
\size default

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/65K3D"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perhaps only a small minority of software developers actually complain about
 this; the vast majority seems to remain unaware of 
\begin_inset Quotes eld
\end_inset

traversable functors
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

free monads
\begin_inset Quotes erd
\end_inset

, or other arcane terminology.
\end_layout

\begin_layout Standard
However, chemical engineers accept the need for studying differential equations
 and do not mind using the terms 
\begin_inset Quotes eld
\end_inset

phase diagram
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

.
 Electrical engineers do not complain that the word 
\begin_inset Quotes eld
\end_inset

Fourier
\begin_inset Quotes erd
\end_inset

 is difficult to spell, or that 
\begin_inset Quotes eld
\end_inset

delta-function
\begin_inset Quotes erd
\end_inset

 is a weird thing to say.
 Mechanical engineers take it for granted that they need to calculate with
 
\begin_inset Quotes eld
\end_inset

tensors
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Lagrangians
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

non-holonomic constraints
\begin_inset Quotes erd
\end_inset

.
 The arcane terminology seems to be the least of their difficulties, as
 their textbooks are full of complicated equations and long derivations.
\end_layout

\begin_layout Standard
Similarly, software engineers would not complain about the word 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

, or about having to study the derivation of the algebraic laws for 
\begin_inset Quotes eld
\end_inset

monads,
\begin_inset Quotes erd
\end_inset

 — if they were true engineers.
 Textbooks on true software engineering would have been full of equations
 and derivations, in order to teach engineers how to perform certain calculation
s that are required 
\emph on
before
\emph default
 starting to write code.
\end_layout

\begin_layout Section
Towards true engineering in software
\end_layout

\begin_layout Standard
It is now clear that we do not presently have true software engineering.
 The people employed under that job title are actually artisans.
 They work using artisanal methods, and their culture and processes are
 that of a crafts guild.
\end_layout

\begin_layout Standard
True software engineering means having a mathematical theory that guides
 the process of writing programs, — not just theory that describes or analyzes
 programs after they are 
\emph on
somehow
\emph default
 written.
\end_layout

\begin_layout Standard
It is true that the numerical methods required for physics or the matrix
 calculations required for data science are 
\begin_inset Quotes eld
\end_inset

mathematical
\begin_inset Quotes erd
\end_inset

.
 These programming tasks are indeed formulated using mathematical theory.
 However, mathematical 
\emph on
subject matter
\emph default
 (aerospace control, physics or astronomy simulations, or statistics) does
 not mean that engineering is used for the process of writing code.
 Data scientists, aerospace engineers, and physicists often write programs
 — but they almost always work as artisans when implementing their computations
 in program code.
\end_layout

\begin_layout Standard
We expect that software engineers
\family sans
'
\family default
 textbooks should be full of equations and derivations.
 What theory would those equations represent?
\end_layout

\begin_layout Standard
This theory is what this book calls 
\series bold
applied functional type theory
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
applied functional type theory
\end_layout

\end_inset

 (see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Applied-functional-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It represents the mathematical foundation of the modern practice of functional
 programming, as implemented in languages such as OCaml, Haskell, and Scala.
 This theory is a blend of type theory, category theory, and logical proof
 theory, adapted for the needs of programmers.
 It has been in development since late 1990s and is still being actively
 worked on by a community of software practitioners and academic computer
 scientists.
\end_layout

\begin_layout Standard
To appreciate that functional programming, unlike any other programming
 paradigm, is based on a 
\emph on
theory that guides coding
\emph default
, we can look at some recent software engineering conferences such as 
\begin_inset Quotes eld
\end_inset

Scala By the Bay
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://2015.scala.bythebay.io/"
literal "false"

\end_inset


\end_layout

\end_inset

 or BayHac,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://bayhac.org/"
literal "false"

\end_inset


\end_layout

\end_inset

 or at the numerous FP-related online tutorials and blogs.
 We cannot fail to notice that speakers devote significant time to a peculiar
 kind of applied mathematical reasoning.
 Rather than focusing on one or another API or algorithm, as it is often
 the case with other software engineering blogs or presentations, an FP
 speaker describes a 
\emph on
mathematical structure
\emph default
 — such as the 
\begin_inset Quotes eld
\end_inset

applicative functor
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.youtube.com/watch?v=bmIxIslimVY"
literal "false"

\end_inset


\end_layout

\end_inset

 or the 
\begin_inset Quotes eld
\end_inset

free monad
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.youtube.com/watch?v=U0lK0hnbc4U"
literal "false"

\end_inset


\end_layout

\end_inset

 — and illustrates its use for practical coding.
\end_layout

\begin_layout Standard
These people are not graduate students showing off their theoretical research;
 they are practitioners, software engineers who use FP on their jobs.
 It is just the nature of FP that certain mathematical tools — coming from
 formal logic and category theory — are now directly applicable to practical
 programming tasks.
\end_layout

\begin_layout Standard
These mathematical tools are not mere tricks for a specific programming
 language; they apply equally to all FP languages.
 Before starting to write code, the programmer can jot down certain calculations
 in a mathematical notation (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-calculation-in-type-theory"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The results of those calculations will help design the code fragment the
 programmer is about to write.
 This activity is similar to that of an engineer who performs some mathematical
 calculations before embarking on a design project.
 
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "50text%"
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset VSpace 25baselineskip%
\end_inset


\begin_inset Graphics
	filename ftt-example.jpg
	width 100line%

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset Caption Standard

\begin_layout Plain Layout
A programmer performs a derivation before writing Haskell code.
\begin_inset CommandInset label
LatexCommand label
name "fig:Example-calculation-in-type-theory"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\noindent
A recent example of a development in applied functional type theory is the
 
\begin_inset Quotes eld
\end_inset

free applicative functor
\begin_inset Quotes erd
\end_inset

 construction.
 It was first described in a 2014 paper;
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/pdf/1403.0749.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 a couple of years later, a combined free applicative/free monad data type
 was designed and its implementation proposed 
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/typelevel/cats/issues/983"
literal "false"

\end_inset


\end_layout

\end_inset

 as well as in Haskell.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://elvishjerricco.github.io/2016/04/08/applicative-effects-in-free-monads.html"
literal "false"

\end_inset


\end_layout

\end_inset

 This technique allows programmers to implement declarative side-effect
 computations where some parts are sequential but other parts are computed
 in parallel, and to achieve the parallelism 
\emph on
automatically
\emph default
 while maintaining the composability of the resulting programs.
 The new technique has distinct advantages over using monad transformers,
 which was a previously used method of composing declarative side-effects.
 The combined 
\begin_inset Quotes eld
\end_inset

free applicative / free monad
\begin_inset Quotes erd
\end_inset

 was designed and implemented by true software engineers.
 They first derived the type constructor that has the necessary algebraic
 properties.
 Guided by the resulting type formula, they wrote the code that was guaranteed
 to work as intended.
\end_layout

\begin_layout Standard
Another example of applied functional type theory is the  
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
tagless final
\end_layout

\end_inset

tagless final
\begin_inset Quotes erd
\end_inset

 encoding of effects, first described
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://okmij.org/ftp/tagless-final/index.html"

\end_inset


\end_layout

\end_inset

 in 2009.
 That technique (called 
\begin_inset Quotes eld
\end_inset

Church-encoded free monad
\begin_inset Index idx
status open

\begin_layout Plain Layout
free monad
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 in the present book) has several advantages over the ordinary free monad
 and can improve upon it in a number of cases — just as the free monad itself
 was designed to cure certain problems with monad transformers.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/"
literal "false"

\end_inset


\end_layout

\end_inset

 The new encoding is not tied to a specific programming language.
 Rather, it is a language-agnostic construction that was originally described
 in OCaml and later used in Haskell and Scala, but can be made to work even
 in Java,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/rLAh9"
literal "false"

\end_inset


\end_layout

\end_inset

 which is not an FP language.
\end_layout

\begin_layout Standard
This example shows that we may need several more years of work before the
 practical aspects of using applied functional type theory are sufficiently
 well understood by the FP community.
 The theory is in active development, and its design patterns — as well
 as the exact scope of the requisite theoretical material — are still being
 figured out.
 If the 40-year gap hypothesis
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/rJc4A"
literal "false"

\end_inset


\end_layout

\end_inset

 holds, we should expect applied functional type theory (perhaps under a
 different name) to become mainstream by 2030.
 This book is a step towards a clear designation of the scope of that theory.
\end_layout

\begin_layout Section
Does software need engineers, or are artisans good enough? 
\end_layout

\begin_layout Standard
The demand for programmers is growing.
 
\begin_inset Quotes eld
\end_inset

Software developer
\begin_inset Quotes erd
\end_inset

 was #1 best job
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/cGJ2T"
literal "false"

\end_inset


\end_layout

\end_inset

 in the US in 2018.
 But is there a demand for engineers or just for artisans?
\end_layout

\begin_layout Standard
We do not seem to be able to train enough software artisans.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/137b8"
literal "false"

\end_inset


\end_layout

\end_inset

 So, it is probably impossible to train as many software engineers in the
 true sense of the word.
 Modern computer science courses do not actually train engineers in that
 sense; at best, they train academic researchers who write code as software
 artisans.
 Recalling the situation in construction business, with a few architects
 and hundreds of construction workers, we might also conclude that, perhaps,
 only a few software engineers are required per hundred software artisans.
\end_layout

\begin_layout Standard
What is the price of 
\emph on
not
\emph default
 having engineers, of replacing them with artisans?
\end_layout

\begin_layout Standard
Software practitioners have long bemoaned the mysterious difficulty of software
 development.
 Code 
\begin_inset Quotes eld
\end_inset

rots with time
\begin_inset Quotes erd
\end_inset

, its complexity grows 
\begin_inset Quotes eld
\end_inset

out of control
\begin_inset Quotes erd
\end_inset

, and operating systems have been notorious for ever-appearing security
 flaws
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.fo/HtQzw"
literal "false"

\end_inset


\end_layout

\end_inset

 despite many thousands of programmers and testers employed.
 Clearly, we overestimated the capacity of the human brain for artisanal
 programming.
\end_layout

\begin_layout Standard
It is precisely in designing large and robust software systems that we would
 benefit from true engineering.
 Artisans has been building bridges and using chemical reactions by trial
 and error and via tradition, long before mechanical or chemical engineering
 disciplines were developed and founded upon rigorous theory.
 But once the theory became available, engineers were able to design unimaginabl
y more powerful and complicated structures, devices, and processes.
 It is clear that trial, error, and adherence to tradition is inadequate
 for some of the software development tasks in front of us.
 
\end_layout

\begin_layout Standard
To build large and reliable software, such as new mobile or embedded operating
 systems or distributed peer-to-peer trust architectures, we will most likely
 need the qualitative increase in productivity and reliability that can
 only come from replacing artisanal programming by a true engineering discipline.
 Applied functional type theory and functional programming are steps in
 that direction.
\end_layout

\begin_layout Chapter
Essay: Towards functional data engineering with Scala
\end_layout

\begin_layout Standard
Data engineering is among the highest-demand
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/mK59h"
literal "false"

\end_inset


\end_layout

\end_inset

 novel occupations in the IT world today.
 Data engineers create software pipelines that process large volumes of
 data efficiently.
 Why did the Scala programming language emerge as a premier tool
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.slideshare.net/noootsab/scala-the-unpredicted-lingua-franca-for-data-science"
literal "false"

\end_inset


\end_layout

\end_inset

 for crafting the foundational data engineering technologies such as Spark
 or Akka? Why is Scala in high demand
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://techcrunch.com/2016/06/14/scala-is-the-new-golden-child/"
literal "false"

\end_inset


\end_layout

\end_inset

 within the world of big data?
\end_layout

\begin_layout Standard
There are reasons to believe that the choice of Scala was not accidental.
\end_layout

\begin_layout Section
Data is math
\end_layout

\begin_layout Standard
Humanity has been working with data at least since Babylonian tax tables
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.nytimes.com/2017/08/29/science/trigonometry-babylonian-tablet.html"
literal "false"

\end_inset


\end_layout

\end_inset

 and the ancient Chinese number books.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://quatr.us/china/science/chinamath.htm"
target "https://web.archive.org/web/20170425233550/https://quatr.us/china/science/chinamath.htm"
literal "false"

\end_inset


\end_layout

\end_inset

 Mathematics summarizes several millennia's worth of data processing experience
 in a few fundamental tenets:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement I
overhang 0in
width "34col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset Graphics
	filename type-error.jpg
	width 96line%

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Mixing incompatible data types produces nonsensical results.
\begin_inset CommandInset label
LatexCommand label
name "fig:A-nonsensical-calculation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -350baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Data is 
\emph on
immutable
\emph default
, because facts are immutable.
 
\end_layout

\begin_layout Itemize
Each 
\emph on
type
\emph default
 of values (population count, land area, distances, prices, times, etc.)
 needs to be handled separately; it is meaningless to add a distance to
 a population count.
\end_layout

\begin_layout Itemize
Data processing should be performed according to 
\emph on
mathematical formulas
\emph default
.
 
\end_layout

\begin_layout Standard
Violating these tenets produces nonsense (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-nonsensical-calculation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a real-life illustration).
\end_layout

\begin_layout Standard
The power of the principles of mathematics extends over all epochs and all
 cultures; math is the same in San Francisco, in Rio de Janeiro, in Kuala-Lumpur
, and in Pyongyang (Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-Pyongyang-method-of-error-free-programming"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
Functional programming is math
\end_layout

\begin_layout Standard
The functional programming paradigm is based on mathematical principles:
 values are immutable, data processing is coded through formula-like expressions
, and each type of data is required to match correctly during the computations.
 The type-checking process automatically prevents programmers from making
 many kinds of coding errors.
 In addition, programming languages such as Scala and Haskell have a set
 of features adapted to building powerful abstractions and domain-specific
 languages.
 This power of abstraction is not accidental.
 Since mathematics is the ultimate art of building abstractions, math-based
 functional programming languages capitalize on having a few millennia of
 mathematical experience.
\end_layout

\begin_layout Standard
A prominent example of how mathematics informs the design of programming
 languages is the connection between constructive logic
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Intuitionistic_logic"
literal "false"

\end_inset


\end_layout

\end_inset

 and the programming language's type system, called the Curry-Howard (CH)
 correspondence.
 The main idea of the CH correspondence
\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

 is to think of programs as mathematical formulas that compute a value of
 a certain type 
\begin_inset Formula $A$
\end_inset

.
 The CH correspondence is between programs and logical propositions: To
 any program that computes a value of type 
\begin_inset Formula $A$
\end_inset

, there corresponds a proposition stating that 
\begin_inset Quotes eld
\end_inset

a value of type 
\begin_inset Formula $A$
\end_inset

 can be computed
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
This may sound rather theoretical so far.
 To see the real value of the CH correspondence, recall that formal logic
 has operations 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
and
\series default
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
or
\series default
\emph default

\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
implies
\series default
\emph default

\begin_inset Quotes erd
\end_inset

.
 For any two propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, we can construct the propositions 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
and
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
or
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
implies
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 These three logical operations are foundational; without one of them, the
 logic is 
\emph on
incomplete
\emph default
 (you cannot derive some theorems).
\end_layout

\begin_layout Standard
A programming language 
\series bold
obeys the CH correspondence
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

 with the logic if for any types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, the language also contains composite types corresponding to the logical
 formulas 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
or
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
and
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
implies
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 In Scala, these composite types are 
\family typewriter
Either[A,B]
\family default
, the tuple 
\family typewriter
(A,B)
\family default
, and the function type, 
\family typewriter
A
\begin_inset Formula $\rightarrow$
\end_inset

B
\family default
.
 All modern functional languages such as OCaml, Haskell, Scala, F#, Swift,
 Elm, and PureScript support these three type constructions and thus are
 faithful to the CH correspondence.
 Having a 
\emph on
complete
\emph default
 logic in a language's type system enables declarative domain-driven code
 design.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://fsharpforfunandprofit.com/ddd/"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement I
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Graphics
	filename no-bugs.jpg
	width 100line%

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The Pyongyang method of error-free software engineering.
\begin_inset CommandInset label
LatexCommand label
name "fig:The-Pyongyang-method-of-error-free-programming"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -300baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is interesting to note that most older programming languages (C/C++,
 Java, JavaScript, Python) do not support some of these composite types.
 In other words, these programming languages have type systems based on
 an incomplete logic.
 As a result, users of these languages have to implement burdensome workarounds
 that make for error-prone code.
 Failure to follow mathematical principles has real costs (Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-Pyongyang-method-of-error-free-programming"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
The power of abstraction
\end_layout

\begin_layout Standard
Early adopters of Scala, such as Netflix, LinkedIn, and Twitter, were implementi
ng what is now called 
\begin_inset Quotes eld
\end_inset

big data engineering
\begin_inset Quotes erd
\end_inset

.
 The required software needs to be highly concurrent, distributed, and resilient
 to failure.
 Those software companies used Scala as their main implementation language
 and reaped the benefits of functional programming.
\end_layout

\begin_layout Standard
What makes Scala suitable for big data tasks? The only reliable way of managing
 massively concurrent code is to use sufficiently high-level abstractions
 that make application code declarative.
 The two most important such abstractions are the 
\begin_inset Quotes eld
\end_inset

resilient distributed dataset
\begin_inset Quotes erd
\end_inset

 (RDD) of Apache Spark and the 
\begin_inset Quotes eld
\end_inset

reactive stream
\begin_inset Quotes erd
\end_inset

 used in systems such as Kafka, Akka Streams, and Apache Flink.
 While these abstractions are certainly implementable in Java or Python,
 a fully declarative and type-safe usage is possible only in a programming
 language with a sophisticated type system.
 Among the currently available mature functional languages, only Scala and
 Haskell are technically adequate for that task, due to their support for
 typeclasses and higher-order types.
 The early adopters of Scala were able to benefit from the powerful abstractions
 Scala supports.
 In this way, Scala enabled those businesses to engineer and to scale up
 their massively concurrent computations.
\end_layout

\begin_layout Standard
It remains to see why Scala (and not, say, OCaml or Haskell) became the
 
\emph on
lingua franca
\emph default
 of big data.
\end_layout

\begin_layout Section
Scala is Java on math 
\end_layout

\begin_layout Standard
The recently invented general-purpose functional programming languages may
 be divided into 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 (OCaml, Haskell) and 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 (F#, Scala, Swift).
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages are clean-room implementations of well-researched mathematical
 principles of programming language design (the CH correspondence being
 one such principle).
 These languages are not limited by requirements of compatibility with any
 existing platforms or libraries.
 Because of this, the 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages have been designed and used for pursuing various mathematical
 ideas to their logical conclusion.
\begin_inset Foot
status open

\begin_layout Plain Layout
OCaml has arbitrary recursive product and co-product types that can be freely
 combined with object-oriented types.
 Haskell removes all side effects from the language and supports partial
 type functions of arbitrarily high order.
\end_layout

\end_inset

 At the same time, software practitioners struggle to adopt these programming
 languages due to a steep learning curve, a lack of enterprise-grade libraries
 and tool support, and immature package management.
\end_layout

\begin_layout Standard
The languages from the 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 group are based on existing and mature software ecosystems: F# on .NET,
 Scala on JVM, and Swift on the MacOS/iOS platform.
 One of the important design requirements for these languages is 100% binary
 compatibility with their 
\begin_inset Quotes eld
\end_inset

parent
\begin_inset Quotes erd
\end_inset

 platforms and languages (F# with C#, Scala with Java, and Swift with Objective-
C).
 Because of this, developers can immediately take advantage of the existing
 tooling, package management, and industry-strength libraries, while slowly
 ramping up the idiomatic usage of new language features.
 However, the same compatibility requirements dictate certain limitations
 in the languages, making their design less than fully satisfactory from
 the functional programming viewpoint.
\end_layout

\begin_layout Standard
It is now easy to see why the adoption rate of the 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 group of languages is much higher
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.tiobe.com/tiobe-index/"
literal "false"

\end_inset


\family default
, archived in 2019 at 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/RsNH8"

\end_inset


\end_layout

\end_inset

 than that of the 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages.
 The transition to the functional paradigm is also smoother for software
 developers because F#, Scala, and Swift seamlessly support the familiar
 object-oriented programming
\begin_inset Index idx
status open

\begin_layout Plain Layout
object-oriented programming
\end_layout

\end_inset

 paradigm.
 At the same time, these new languages still have logically complete type
 systems, which gives developers an important benefit of type-safe domain
 modeling.
\end_layout

\begin_layout Standard
Nevertheless, the type systems of these languages are not equally powerful.
 For instance, F# and Swift are similar to OCaml in many ways but omit OCaml's
 parameterized modules and some other features.
 Of all mentioned languages, only Scala and Haskell directly support typeclasses
 and higher-order functions on types, which are helpful for expressing abstracti
ons such as automatically parallelized data sets or asynchronous data streams.
\end_layout

\begin_layout Standard
To see the impact of these advanced features, consider LINQ, a domain-specific
 language for database queries on .NET, implemented in C# and F# through
 a special built-in syntax supported by Microsoft's compilers.
 Analogous functionality is provided in Scala as a 
\emph on
library
\emph default
, without need to modify the Scala compiler, by several open-source projects
 such as Slick and Quill.
 Similar libraries exist for Haskell — but not in languages with less powerful
 type systems.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
Only Scala has all of the features required for industrial-grade functional
 programming:
\end_layout

\begin_layout Enumerate
Functional collections in the standard library.
\end_layout

\begin_layout Enumerate
A sophisticated type system with support for typeclasses and higher-order
 types.
\end_layout

\begin_layout Enumerate
Seamless compatibility with a mature software ecosystem (JVM).
\end_layout

\begin_layout Standard
Based on this assessment, we may be confident in Scala's future as a main
 implementation language for big data engineering.
\end_layout

\begin_layout Chapter
Essay: Why category theory is useful in functional programming
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
category theory!in functional programming
\end_layout

\end_inset

This essay is for readers who are already somewhat familiar with category
 theory.
\end_layout

\begin_layout Section
A 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category for a programming language
\end_layout

\begin_layout Standard
We consider programming languages that support various data types, such
 as integers (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

), floating-point numbers (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

), strings (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

), arrays of strings (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

), and so on.
 Such languages allow programmers to define functions with specified types
 of arguments and return values.
 The compiler will then verify that all functions are always applied to
 arguments of correct types, and that all return values have the expected
 types.
 
\end_layout

\begin_layout Standard
To each programming language of that kind, there corresponds a 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category:
\end_layout

\begin_layout Itemize
The objects of the category are all the data types supported by the language
 (including user-defined data types).
 As an example, for Scala there will be an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

, an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

, and so on.
\end_layout

\begin_layout Itemize
The morphisms of the category are all functions 
\emph on
of a single argument
\emph default
 that can be implemented in the language.
 A morphism between objects 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is any function that takes a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The category defined in this way will typically have a large number of morphisms
 between most objects.
 For example, morphisms between objects 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 are functions that take a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 and return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 There are as many such functions as pairs of integers.
 Scala code for one of those morphisms looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def morphismBooleanToInt: Boolean => Int = { b => if (b) 123 else 456 }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why do the category laws hold? The composition of morphisms corresponds
 to composition of functions, which we can implement by writing code that
 applies the first function and then applies the second function.
 In Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def composeMorphisms[A, B, C](f: A => B, g: B => C): A => C   =   { a =>
 g(f(a)) }
\end_layout

\end_inset

Equivalent functionality can be implemented in most programming languages.
\end_layout

\begin_layout Standard
The category's identity law says that there must be a morphism between objects
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 This can be implemented in most programming languages as a function that
 returns its argument unchanged:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def identity[A]: A => A = { x => x }
\end_layout

\end_inset

One can check that morphism composition is associative and agrees with the
 identity morphism.
\end_layout

\begin_layout Standard
We have thus defined a category (the 
\begin_inset Quotes eld
\end_inset

types/functions category
\begin_inset Quotes erd
\end_inset

 for a given programming language).
 Most of the time, we will be working with that category, or with the category
 of its endofunctors, or with a sub-category of these categories.
\end_layout

\begin_layout Standard
Different programming languages will give rise to different 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 categories, but all those categories have many common features that are
 especially important in languages designed for functional programming (the
 
\begin_inset Quotes eld
\end_inset

FP languages
\begin_inset Quotes erd
\end_inset

, such as OCaml, Haskell, Scala and others).
\end_layout

\begin_layout Section
The use of endofunctors
\end_layout

\begin_layout Standard
An endofunctor in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category is a mapping of types together with a mapping of functions.
 A good example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 data type.
 In some programming languages, the type of an array's elements can be specified
 and enforced throughout the code.
 For example, in Scala one can use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Int]
\end_layout

\end_inset

 for an array of integers, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

 for an array of strings, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Array[Int]]
\end_layout

\end_inset

 for an array containing nested arrays of integers, etc.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 can be seen as a mapping from types to types: it maps the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Int]
\end_layout

\end_inset

, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

, etc.
 For any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, we have the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[X]
\end_layout

\end_inset

.
 This is the object-to-object map of an endofunctor.
\end_layout

\begin_layout Standard
An endofunctor also needs a map from morphisms to morphisms.
 Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: X => Y
\end_layout

\end_inset

, we need to implement a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[X] => Array[Y]
\end_layout

\end_inset

.
 This can be done by writing a loop over the array and applying the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each element (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

).
 The resulting values (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

) are then collected in a new array, of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Y]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This code can be written in many programming languages in a generic manner,
 using type parameters such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

.
 The same code will then work for arrays and functions of any given type.
 In Scala, the code could be written as the following function (usually
 called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 in FP libraries):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[X, Y: ClassTag](f: X => Y): Array[X] => Array[Y] = { arrayX: Array[X]
 =>
\end_layout

\begin_layout Plain Layout

  val arrayY = new Array[Y](arrayX.size)
\end_layout

\begin_layout Plain Layout

  for { i <- arrayX.indices } arrayY(i) = f(arrayX(i))
\end_layout

\begin_layout Plain Layout

  arrayY  // Return this array of type Array[Y].
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

One can then check that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 satisfies the identity and composition laws of endofunctors.
 This completes the implementation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 endofunctor.
\end_layout

\begin_layout Standard
Why does 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 satisfy the laws of endofunctors? The categorical properties of functions
 are preserved if we apply functions to each element of an array and collect
 the results 
\emph on
in the same order
\emph default
.
 An identity function applied to every element will not modify the array.
 Function composition is preserved because a composition of two functions
 will be applied separately to each array element.
\end_layout

\begin_layout Standard
The same construction can be applied to many data structures other than
 arrays.
 It turns out that many programs can be reformulated using the operation
 of applying a function to every value in a data structure (i.e., the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

).
 This reformulation leads to code that avoids loops: the loops are replaced
 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions of some endofunctors, and all those 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions are implemented in a standard library.
 In practice, code written via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 instead of loops is more concise and admits fewer opportunities for errors.
 The programmer's intuition about 
\begin_inset Quotes eld
\end_inset

applying functions to every value held within a data structure
\begin_inset Quotes erd
\end_inset

 is then directly represented by the formal laws of endofunctors.
 Once those laws are verified, the programmer is assured that the code written
 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 will work according to the programmer's intuitive expectations.
\end_layout

\begin_layout Section
The use of natural transformations
\end_layout

\begin_layout Standard
What is a natural transformation between endofunctors in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category? For two given endofunctors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

, a natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t: F ~> G
\end_layout

\end_inset

 is defined by its components.
 The component at object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[X] => G[X]
\end_layout

\end_inset

; this must be defined for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

.
 Some programming languages support functions with type parameters.
 In Scala, the syntax is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t[X]: F[X] => G[X] = ...
\end_layout

\end_inset

The code of such a function is written once and will work in the same way
 for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
An example is a function that reverses the order of elements in an array:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[X]: Array[X] => Array[X] = ...
\end_layout

\end_inset

The algorithm is 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset

: it is written in the same way for all type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It turns out that, by the Reynolds-Wadler parametricity theorem, any code
 written in a fully parametric manner will satisfy the law of a natural
 transformation (the naturality law).
 The naturality law states that applying the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

's morphism map before a natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 must be equal to applying the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

's map after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

.
 In Scala syntax, the law is written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

t(fmap_F(f)(x)) == fmap_G(f)(t(x))
\end_layout

\end_inset

This law can be verified directly for a given code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 and with known code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap_F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap_G
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Naturality laws are satisfied by transformations that rearrange data items
 in a data structure in some way that does not depend on specific values
 or types.
 In this way, the formal laws of natural transformations directly represent
 programmers' intuitions about code that works 
\begin_inset Quotes eld
\end_inset

in the same way for all type parameters
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
As we have just seen, the notions of endofunctors and natural transformations
 are useful in programming languages that support types with type parameters
 (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[X]
\end_layout

\end_inset

) and functions with type parameters (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse[X]
\end_layout

\end_inset

).
 Programming languages that do not support those features cannot benefit
 from the powerful reasoning tools of category theory.
\end_layout

\begin_layout Section
Other properties of the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category
\end_layout

\begin_layout Standard
Morphisms in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category are always functions of a single argument.
 However, programming languages usually support functions with many arguments.
 There are two ways to imitate such functions: tupling and currying.
\end_layout

\begin_layout Standard
Tupling means that we put all arguments into a compound structure (a pair,
 a triple, etc.).
 The function is still viewed as having a single argument, but the type
 of that argument is the type of a pair, or a triple, or a longer tuple
 type.
 This works when the programming language supports tuple types.
 A tupled function's type is written (in Scala) as, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B, C)) => D
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Tuple types correspond to finite products of objects in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
 So, it is useful if the category has (finite) products.
 
\end_layout

\begin_layout Standard
Currying means that we create a function that takes the first argument and
 returns a curried function that handles the rest of the arguments in the
 same way (takes the second argument and again returns a function, etc.).
 A curried function's type is written in Scala as, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => D
\end_layout

\end_inset

.
 To support this method, the programming language should have function types.
 The corresponding categorical construction is the 
\begin_inset Quotes eld
\end_inset

exponential
\begin_inset Quotes erd
\end_inset

 object.
 
\end_layout

\begin_layout Standard
In the practice of functional programming, it has been found useful to have
 the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, which has exactly one value, and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, which has no values.
 In the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category, these types correspond to the terminal and the initial objects.
\end_layout

\begin_layout Standard
Finally, disjunctive types correspond to co-products in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
\end_layout

\begin_layout Standard
In this way, we find that various well-known mathematical properties of
 the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category (initial and terminal objects, finite products and co-products,
 exponentials) correspond to properties of the programming language that
 proved useful in the practice of software engineering.
\end_layout

\begin_layout Section
Some useful sub-categories of endofunctors
\end_layout

\begin_layout Standard
Besides loops that apply functions to array elements, other frequently used
 computations are nested loops and 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

-loops that are repeated while a given condition holds and then stopped.
 It turns out that category theory provides a convenient language for reasoning
 about such computations.
 Similarly to representing loops via endofunctors, the various kinds of
 loops are encoded via certain sub-categories of endofunctors in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
\end_layout

\begin_layout Standard
To see how this works, we need to define an auxiliary sub-category called
 the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

-lifted
\begin_inset Quotes erd
\end_inset

 (where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 may be any given endofunctor, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

).
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

-lifted sub-category is the image of the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

.
 The objects of that sub-category are types of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 The morphisms of that sub-category are functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] => F[B]
\end_layout

\end_inset

 that are obtained by lifting some function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 through the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

's morphism map (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method).
 
\end_layout

\begin_layout Subsection
Filterable endofunctors
\end_layout

\begin_layout Standard
To describe 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

-loops using category theory, we begin by reformulating the loop as a 
\emph on
mathematical function
\emph default
 rather than as a sequence of computer instructions.
 To be specific, consider a program with a loop that stops when a certain
 condition first becomes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 A loop of this kind may be modeled by a function that takes an initial
 array as argument and returns a new array that is truncated when a given
 condition first becomes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 The condition is represented by a function evaluated on each element of
 the array.
 The Scala standard library includes such a function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

).
 An example of its usage is:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

scala> Array(1, 2, 3, 4, 5).takeWhile(x => x < 4) // Truncate the array when
 $
\backslash
color{dkgreen} x 
\backslash
geq 4$.
\end_layout

\begin_layout Plain Layout

res0: Array[Int] = Array(1, 2, 3) 
\end_layout

\end_inset

The next step is to extend this function to work with arbitrary types instead
 of integers.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 may be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def takeWhile[X](p: X => Boolean): Array[X] => Array[X]
\end_layout

\end_inset

Here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 is a type parameter.
 The first argument is a predicate of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X => Boolean
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Finally, we write the laws that we expect this function to satisfy.
 For instance, if the given predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, the function should not change the given array (the 
\begin_inset Quotes eld
\end_inset

identity law
\begin_inset Quotes erd
\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

takeWhile(x => true)  ==  identity
\end_layout

\end_inset

Another plausible law is called the 
\begin_inset Quotes eld
\end_inset

composition law
\begin_inset Quotes erd
\end_inset

.
 If we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 with a predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1
\end_layout

\end_inset

 and then again apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 with another predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2
\end_layout

\end_inset

, the resulting truncated array should be the same as if we applied 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 just once with a Boolean conjunction of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

takeWhile(p1) andThen takeWhile(p2) == takeWhile( x => p1(x) && p2(x) )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The identity and composition laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 are analogous to the identity and composition laws of functors.
 More precisely, one can derive the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 from the laws of an auxiliary functor between a certain Kleisli category
 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

-lifted category (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-category-definition-of-filterable-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details).
 That auxiliary functor exists only for some endofunctors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

, which are called 
\begin_inset Quotes eld
\end_inset

filterable
\begin_inset Quotes erd
\end_inset

 in this book.
 Filterable endofunctors are a sub-category of all endofunctors of the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
 
\end_layout

\begin_layout Standard
With this construction, one may now regard the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 not as arbitrarily postulated properties but as a consequence of the functor
 laws.
 In this way, category theory validates the programmer's intuition for the
 choice of the laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Monadic endofunctors
\end_layout

\begin_layout Standard
To evaluate a nested loop, which may be written in Scala as, e.g.,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {
\end_layout

\begin_layout Plain Layout

  x <- 1 to 10
\end_layout

\begin_layout Plain Layout

  y <- 1 to x / 2
\end_layout

\begin_layout Plain Layout

} yield f(x, y) // Some computation that may use x and y.
\end_layout

\end_inset

the computer will perform ten repetitions of the inner loop over 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 This computation is equivalent to converting the nested loop into an ordinary,
 
\begin_inset Quotes eld
\end_inset

flattened
\begin_inset Quotes erd
\end_inset

 loop that has a larger total number of repetitions (in this example, 
\begin_inset Formula $25$
\end_inset

 repetitions).
 To describe this situation using category theory, we start by reformulating
 a nested loop into a mathematical function.
 The arguments of that function are the first array (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 to 10
\end_layout

\end_inset

) for iterating with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, and a function from a value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to the nested array (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => 1 to x / 2
\end_layout

\end_inset

).
 The function returns a 
\begin_inset Quotes eld
\end_inset

flattened
\begin_inset Quotes erd
\end_inset

 array of 
\begin_inset Formula $25$
\end_inset

 values.
 
\end_layout

\begin_layout Standard
The Scala library contains such a function, named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 An example of usage is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).toArray.flatMap(x => 1 to x / 2)
\end_layout

\begin_layout Plain Layout

res0: Array[Int] = Array(1, 1, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4,
 1, 2, 3, 4, 1, 2, 3, 4, 5)
\end_layout

\end_inset

This function can be used repeatedly to convert arbitrarily deeply nested
 loops into 
\begin_inset Quotes eld
\end_inset

flat
\begin_inset Quotes erd
\end_inset

 loops.
\end_layout

\begin_layout Standard
The next step is to formulate a fully parametric type signature for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[A, B](f: A => Array[B]): Array[A] => Array[B]
\end_layout

\end_inset

In this way, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 can transform arrays with elements of any type.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 function must satisfy certain properties that are useful for practical
 programming.
 One of these properties is 
\begin_inset Quotes eld
\end_inset

associativity
\begin_inset Quotes erd
\end_inset

.
 A deeply nested loop may be flattened by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 first to the outer layers and then to the inner layers, or by applying
 flatMap first to the inner layers; the results must be the same.
 This and other properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 are analogous to the laws of a category: there are two identity laws and
 one associativity law.
 More precisely, one can derive the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 from the requirement that the Kleisli category on the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 is well-defined (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monads-in-category-theory-monad-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details).
 This is equivalent to saying that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 is a monad.
 Monads form a sub-category of endofunctors of the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
\end_layout

\begin_layout Section
Category theory and the laws of FP idioms
\end_layout

\begin_layout Standard
We have seen that 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

-loops and nested loops can be reformulated through type-parameterized functions
 satisfying certain laws.
 Those laws are then equivalent to the laws of suitably chosen functors
 or categories.
 This turns out to be a general pattern:
\end_layout

\begin_layout Itemize
Begin with a known idiom of computation (e.g., a certain kind of a loop).
\end_layout

\begin_layout Itemize
Reformulate that idiom through functions with parameterized argument types.
\end_layout

\begin_layout Itemize
Write the laws that programmers expect those functions to satisfy.
\end_layout

\begin_layout Itemize
Prove that those laws are equivalent to the laws of a suitable functor and/or
 category.
\end_layout

\begin_layout Standard
The derivations in Chapters
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 of this book follow this pattern.
 One can show that this pattern holds for at least 
\emph on
eleven
\emph default
 sub-categories of endofunctors used in FP practice: functors, contrafunctors,
 filterable functors, filterable contrafunctors, applicative functors, applicati
ve contrafunctors, monads, comonads, traversable functors, monad transformers,
 and comonad transformers.
 
\end_layout

\begin_layout Standard
It appears that category theory and its basic tools (functors, natural transform
ations, commutative diagrams) provide a powerful and versatile language
 for reasoning about laws of various FP idioms.
 By invoking category theory, programmers avoid having to memorize a large
 number of laws and constructions.
 Without the underlying categorical justification, the laws for different
 endofunctors will appear to be chosen arbitrarily, with no clearly recognizable
 system or pattern.
\end_layout

\begin_layout Standard
In addition, category theory guides programmers in creating highly abstract
 libraries that work uniformly with all endofunctors of a certain sub-category.
 In programmer's terms, such libraries contain functions parameterized by
 type constructors satisfying appropriate constraints.
 Examples are functions that define the product or the co-product of any
 two given functors, or define a free monad on a given functor.
 Implementing libraries of that kind requires formulating and verifying
 the relevant laws.
 Category theory is a reliable foundation for such libraries.
\end_layout

\end_body
\end_document
