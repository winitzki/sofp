#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Nil,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset Quotes eld
\end_inset

Applied functional type theory
\begin_inset Quotes erd
\end_inset

: A proposal
\begin_inset CommandInset label
LatexCommand label
name "chap:Applied-functional-type"

\end_inset


\end_layout

\begin_layout Standard
What exactly is the extent of 
\begin_inset Quotes eld
\end_inset

theory
\begin_inset Quotes erd
\end_inset

 that a software engineer should know in order to be a proficient functional
 programmer? This book proposes an answer to that question by presenting
 a coherent body of theoretical knowledge that, in the author's view, 
\emph on
is
\emph default
 the theory that underlies the practice of functional programming and guides
 software engineers in writing code.
 This body of knowledge may be viewed as a new emerging sub-branch of computer
 science, tentatively called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
applied functional type theory
\end_layout

\end_inset

applied functional type theory
\series default
 (AFTT).
 
\end_layout

\begin_layout Standard
In order to discover the proper scope of AFTT, this book appraises the various
 inventions made in the field of functional programming in the last 30 years,
 such as the “functional pearls” papers
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://wiki.haskell.org/Research_papers/Functional_pearls"
target "https://wiki.haskell.org/Research_papers/Functional_pearls"
literal "false"

\end_inset


\end_layout

\end_inset

 and various online tutorials, looking for theoretical material that has
 demonstrated its pragmatic usefulness.
 As a first step towards formulating AFTT from the ground up, the results
 are presented in the form of a tutorial, with motivations and rigorous
 derivations of substantially all relevant mathematical facts.
\end_layout

\begin_layout Standard
In this book, code examples are written in Scala because the author is fluent
 in that language.
 However, most of the material will work equally well in Haskell, OCaml,
 and other FP languages.
 This is because AFTT is the science of functional programming and not a
 set of tricks specific to Scala or Haskell.
 An advanced user of any functional programming language will have to face
 the same questions and struggle with the same practical issues.
\end_layout

\begin_layout Section
AFTT is not covered by courses in computer science
\end_layout

\begin_layout Standard
Traditional courses of computer science (algorithms and data structures,
 complexity theory, distributed systems, databases, network systems, compilers,
 operating systems) are largely not relevant to AFTT.
 Courses in programming language theory are more relevant but are not presented
 at an appropriate level.
 To an academic computer scientist, the theory behind Haskell is the version
 of 
\begin_inset Formula $\lambda$
\end_inset

-calculus known as
\begin_inset Index idx
status open

\begin_layout Plain Layout
System 
\begin_inset Formula $F_{\omega}$
\end_inset


\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

System 
\begin_inset Formula $F_{\omega}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://babel.ls.fi.upm.es/~pablo/Papers/Notes/f-fw.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 This theory guided the design of the Haskell language and defines rigorously
 what a Haskell program means in a mathematical sense.
 The theory behind Scala is the 
\begin_inset Quotes eld
\end_inset

dependent object type
\begin_inset Quotes erd
\end_inset

 (DOT) calculus.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html"

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent object type (DOT) calculus
\end_layout

\end_inset

 That theory guided the design of Scala version 3.
\end_layout

\begin_layout Standard
However, a practicing Haskell or Scala programmer is not concerned with
 designing Haskell or Scala, or with proving theoretical properties of those
 languages.
 Instead, the programmer is mainly concerned with 
\emph on
using
\emph default
 a chosen programming language to write code.
 
\end_layout

\begin_layout Standard
Knowing how to prove various properties of DOT or System 
\begin_inset Formula $F_{\omega}$
\end_inset

 will not actually help programmers to write code.
 So, these theories are outside the scope of AFTT.
 Functional programming does not require graduate-level theoretical studies.
\end_layout

\begin_layout Standard
As an example of theoretical material that 
\emph on
is
\emph default
 within the scope of AFTT, consider applicative functors (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunc"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative functors
\end_layout

\end_inset

 It is essential for a practicing functional programmer to be able to recognize
 and use applicative functors.
 An applicative functor is a data structure specifying declaratively a set
 of operations that can run independently of each other.
 Programs may combine these operations, for example, to execute them in
 parallel, or to refactor the program for better maintainability.
\end_layout

\begin_layout Standard
To use this functionality, the programmer must begin by checking whether
 a given data structure satisfies the laws of applicative functors.
 In a given application, the choice of a data structure may be dictated
 in part by the business logic.
 The programmer first writes down the type of that data structure and the
 code implementing the required methods.
 The programmer can then check whether the laws hold.
 The data structure may need to be adjusted in order to fit the definition
 of an applicative functor or to make the laws hold.
\end_layout

\begin_layout Standard
So, the programmer needs to perform a certain amount of symbolic derivations
 before coding.
 The derivations can be done using pen and paper by writing equations in
 a concise mathematical notation.
 Once the applicative laws are verified, the programmer proceeds to write
 code.
\end_layout

\begin_layout Standard
The mathematical proofs and derivations assure that the chosen data structure
 will satisfy the laws of applicative functors, no matter how the rest of
 the program is written.
 So, for example, it is assured that the relevant operations can be automaticall
y parallelized and will still work correctly.
 In this way, AFTT directly guides the programmer and helps write correct
 code.
\end_layout

\begin_layout Standard
Applicative functors were discovered by practitioners who were using Haskell
 in programs such as parser combinators, compilers, and domain-specific
 languages for parallel computing.
 However, applicative functors are not a feature of Haskell: they can be
 used in Scala or any other functional programming language.
 A prominent example of an applicative functor is Spark's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RDD
\end_layout

\end_inset

 data type, which is widely used for implementing large-scale parallel computati
ons.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://spark.apache.org/docs/latest/rdd-programming-guide.html"
literal "false"

\end_inset


\end_layout

\end_inset

 And yet, no standard computer science textbook defines applicative functors,
 motivates their laws, explores their structure on examples, or shows data
 types that are 
\emph on
not
\emph default
 applicative functors (and explains why not).
 
\end_layout

\begin_layout Section
AFTT is not category theory, type theory, or formal logic
\end_layout

\begin_layout Standard
One often hears that functional programming is based on category theory.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.47deg.com/blog/science-behind-functional-programming/"
literal "false"

\end_inset


\end_layout

\end_inset

 Indeed, the material shown in this book includes a (small) number of notions
 from category theory (as well as from formal logic and type theory).
 However, software engineers would not benefit from traditional academic
 courses in those subjects: their presentation is too abstract and at the
 same time lacks specific results necessary for practical programming.
 Those courses answer questions that academic mathematicians have, not questions
 that practicing functional programmers have.
\end_layout

\begin_layout Standard
There exist books intended as presentations of category theory for computer
 scientists
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/dp/0262660717"

\end_inset


\end_layout

\end_inset

 or for programmers.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/hmemcpy/milewski-ctfp-pdf"

\end_inset


\end_layout

\end_inset

 However, those books do not cover certain concepts relevant to programming,
 such as applicative
\begin_inset Foot
status open

\begin_layout Plain Layout
Applicative functors are known in mathematics as 
\begin_inset Quotes eld
\end_inset

monoidal
\begin_inset Quotes erd
\end_inset

: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Monoidal_functor"

\end_inset


\end_layout

\end_inset

 or traversable functors.
 Instead, those books dwell on concepts (e.g., limits, enriched categories,
 topoi) that have no applications in practical functional programming today.
\end_layout

\begin_layout Standard
Typical questions in academic books are 
\begin_inset Quotes eld
\end_inset

Is 
\begin_inset Formula $X$
\end_inset

 an introduction rule or an elimination rule
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Does property 
\begin_inset Formula $Y$
\end_inset

 hold in non-small categories or only in the category of sets
\begin_inset Quotes erd
\end_inset

.
 Questions a Scala programmer might ask are 
\begin_inset Quotes eld
\end_inset

Can we compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Z, R => A]
\end_layout

\end_inset

 from a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R => Either[Z, A]
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Is the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] = Option[(A,A,A)]
\end_layout

\end_inset

 a monad or only an applicative functor
\begin_inset Quotes erd
\end_inset

.
 The scope of AFTT includes answering the last two questions but 
\emph on
not
\emph default
 the first two.
\end_layout

\begin_layout Standard
A software engineer hoping to understand the theory behind functional programmin
g will not find the concepts of filterable, applicative, or traversable
 functors in any currently available books on category theory, including
 books intended for programmers.
 And yet, these concepts are necessary for correct implementations of the
 important and widely used operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To compensate for the lack of AFTT textbooks, programmers have written many
 online tutorials, aiming to explain the theoretical concepts necessary
 for practical work.
 The term 
\begin_inset Quotes eld
\end_inset

monad tutorial
\begin_inset Quotes erd
\end_inset

 became infamous because so many were  posted online.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.johndcook.com/blog/2014/03/03/monads-are-hard-because/"

\end_inset


\end_layout

\end_inset

 Tutorials were also written about applicative functors, traversable functors,
 free monads, etc., showing a real unfulfilled need for presenting practice-relev
ant fragments of theory in an applied setting.
 
\end_layout

\begin_layout Standard
For example, 
\begin_inset Quotes eld
\end_inset

free monads
\begin_inset Quotes erd
\end_inset

 became popular in the Scala community around 2015.
 Many talks about free monads were presented at Scala engineering conferences,
 giving different implementations but never formulating rigorously the propertie
s required for a piece of code to be a valid implementation of the free
 monad.
 Without knowing the required mathematical properties of free monads, a
 programmer cannot make sure that a given implementation is correct.
 However, books on category theory define free monads in a way that is unsuitabl
e for programming applications (a free monad is an adjoint functor to a
 forgetful functor from a Kleisli category to the category of sets).
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\emph on
A monad is just a monoid in the category of endofunctors.
 What's the problem?
\emph default

\begin_inset Quotes erd
\end_inset

 as the joke goes.
 For background information about that joke, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/3870088/"

\end_inset


\end_layout

\end_inset

 Such 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 definitions can be used neither as guidance for writing code or checking
 code correctness, nor as a conceptual explanation that a learner would
 find helpful.
\end_layout

\begin_layout Standard
Perhaps the best selection of AFTT tutorial material today can be found
 in the Haskell Wikibooks.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikibooks.org/wiki/Haskell"
target "https://en.wikibooks.org/wiki/Haskell"
literal "false"

\end_inset


\end_layout

\end_inset

 However, those tutorials are incomplete and limited to explaining the use
 of Haskell.
 Many of them are suitable neither as a first introduction nor as a reference
 on AFTT.
 Also, the Haskell Wikibooks tutorials rarely show any derivations of laws
 or explain the required techniques.
\end_layout

\begin_layout Standard
Apart from referring to some notions from category theory, AFTT also uses
 concepts from type theory and formal logic.
 However, existing textbooks on type theory and formal logic focus on domain
 theory and proof theory.
 For practicing programmers, these books present a lot of difficult-to-learn
 material that will be never applicable in their daily work.
 At the same time, those academic books never mention practical techniques
 used in many functional programming libraries today, such as reasoning
 about and implementing types with quantifiers, types parameterized by type
 constructors, or partial type-level functions (known as 
\begin_inset Quotes eld
\end_inset

typeclasses
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
The proper scope of AFTT is to help the programmer with practical tasks
 such as:
\end_layout

\begin_layout Enumerate
Deciding whether two data types are equivalent and implementing the isomorphism
 transformations.
 For example, the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, Either[B, C])
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, B), (A, C)]
\end_layout

\end_inset

, but the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Either[B, C]
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A => B, A => C]
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Checking whether a definition of a recursive type is 
\begin_inset Quotes eld
\end_inset

valid
\begin_inset Quotes erd
\end_inset

, i.e., does not lead to infinite loops.
 A simple example of an 
\begin_inset Quotes eld
\end_inset

invalid
\begin_inset Quotes erd
\end_inset

 recursive type definition in Scala is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class Bad(x: Bad)
\end_layout

\end_inset

.
 A small change transforms that example into a 
\begin_inset Quotes eld
\end_inset

valid
\begin_inset Quotes erd
\end_inset

 recursive type: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class Good(x: Option[Good])
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Deciding whether a function with a given type signature can be implemented.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[Z,A,R]: (R => Either[Z, A]) => Either[Z, R => A] = ???   // Cannot
 be implemented.
\end_layout

\begin_layout Plain Layout

def g[Z,A,R]: Either[Z, R => A] => (R => Either[Z, A]) = ???   // Can be
 implemented.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Deriving an implementation of a function from its type signature and checking
 required laws.
 For example, deriving the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method and checking its laws for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[Z, A, B](r: Z => A)(f: A => Z => B): Z => B = ???
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Deriving a simpler but equivalent code by calculating with functions and
 laws.
\end_layout

\begin_layout Standard
These are real-world applications of type theory and the Curry-Howard correspond
ence, but existing books on type theory and logic do not give practical
 recipes for performing these tasks.
\begin_inset Foot
status open

\begin_layout Plain Layout
Task 5 is addressed in several programming-oriented books such as 
\emph on
Pearls of functional algorithm design
\emph default
 by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bird
\end_layout

\end_inset

Richard Bird (
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.cambridge.org/9780521513388"
literal "false"

\end_inset


\family default
).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Books such as 
\emph on
Scala with Cats
\emph default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://underscore.io/books/scala-with-cats/"
target "https://underscore.io/books/scala-with-cats/"
literal "false"

\end_inset


\end_layout

\end_inset

 
\emph on
Functional programming simplified
\emph default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://alvinalexander.com/scala/functional-programming-simplified-book"
target "https://alvinalexander.com/scala/functional-programming-simplified-book"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\emph on
Functional programming for mortals
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.lulu.com/shop/search.ep?contributorId=1600066"

\end_inset


\end_layout

\end_inset

 are primarily focused on explaining practical aspects of functional programming
 and do not derive the mathematical laws for, e.g., filterable, monadic, applicati
ve, or traversable functors.
\end_layout

\begin_layout Standard
The only currently available Scala-based AFTT textbook is 
\emph on
Functional Programming in Scala
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://www.manning.com/books/functional-programming-in-scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\end_layout

\end_inset

 It balances practical coding with theoretical developments and laws.
 
\emph on
Program design by calculation
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www4.di.uminho.pt/~jno/ps/pdbc.pdf"

\end_inset


\end_layout

\end_inset

 is another (Haskell-oriented) AFTT book in progress.
 The present book is written at about the same level but aims at better
 motivation for mathematical concepts and a wider range of pedagogical examples
 that help build the necessary intuition and facility with the techniques
 of formal derivation.
 
\end_layout

\begin_layout Standard
Figures
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Randomly-chosen-pages"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Randomly-chosen-pages-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 illustrate the difference between AFTT books, programming books, and academic
 science books, by showing randomly chosen pages from such books.
 Programming-oriented books contain code examples and explanations in words,
 but no formal derivations.
 Books on AFTT, as well as books on mathematics and science, will typically
 show equations, diagrams, and derivations.
 The present book contains both code examples and mathematical manipulations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming simplified
\emph default
, by A.
\begin_inset space ~
\end_inset

Alexander
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
\begin_inset VSpace -160baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming for mortals
\emph default
, by S.
\begin_inset space ~
\end_inset

Halliday
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
\begin_inset VSpace -190baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Practical functional programming in Scala
\emph default
, by G.
\begin_inset space ~
\end_inset

Volpe (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://leanpub.com/pfp-scala"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Mastering advanced Scala
\emph default
, by D.
\begin_inset space ~
\end_inset

Kalinin (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://leanpub.com/mastering-advanced-scala"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on Scala programming.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -40baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Linear algebra
\emph default
, by J.
\begin_inset space ~
\end_inset

Hefferon (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "http://joshua.smcvt.edu/linearalgebra/"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Classical mechanics
\emph default
, by T.
\begin_inset space ~
\end_inset

W.
\begin_inset space ~
\end_inset

B.
\begin_inset space ~
\end_inset

Kibble and F.
\begin_inset space ~
\end_inset

H.
\begin_inset space ~
\end_inset

Berkshire (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://archive.org/details/116772449ClassicalMechanics"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on mathematics and physics.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming in Scala
\emph default
, by P.
\begin_inset space ~
\end_inset

Chiusano and R.
\begin_inset space ~
\end_inset

Bjarnason
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Program design by calculation
\emph default
, by J.
\begin_inset space ~
\end_inset

N.
\begin_inset space ~
\end_inset

Oliveira
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
The science of functional programming
\emph default
 (this book)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on applied functional type theory.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Essay: Software engineers and software artisans
\end_layout

\begin_layout Standard
Let us examine what we ordinarily understand by 
\emph on
engineering
\emph default
 as opposed to artisanship or craftsmanship.
 It will then become apparent that today's computer programmers must be
 viewed as 
\begin_inset Quotes eld
\end_inset

software artisans
\begin_inset Quotes erd
\end_inset

 rather than software engineers.
\end_layout

\begin_layout Section
Engineering disciplines 
\end_layout

\begin_layout Standard
Consider the way mechanical engineers, chemical engineers, or electrical
 engineers work, and look at the studies they require for becoming proficient
 in their fields.
\end_layout

\begin_layout Standard
A mechanical engineer studies
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.colorado.edu/mechanical/undergraduate-students/curriculum"
literal "false"

\end_inset


\end_layout

\end_inset

 calculus, linear algebra, differential geometry, and several areas of physics
 such as theoretical mechanics, thermodynamics, and elasticity theory, and
 then uses calculations to guide the design of a bridge.
 A chemical engineer studies
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.colorado.edu/engineering/sample-undergraduate-curriculum-chemical"
literal "false"

\end_inset


\end_layout

\end_inset

 chemistry, thermodynamics, calculus, linear algebra, differential equations,
 some areas of physics such as thermodynamics and kinetic theory, and uses
 calculations to guide the design of a chemical process.
 An electrical engineer studies
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/XYLyE"
literal "false"

\end_inset


\end_layout

\end_inset

 advanced calculus, linear algebra, and several areas of physics such as
 electrodynamics and quantum theory, and uses calculations to design an
 antenna or a microchip.
\end_layout

\begin_layout Standard
The pattern here is that an engineer uses mathematics and natural sciences
 in order to create new devices.
 Mathematical calculations and scientific reasoning are performed 
\emph on
before
\emph default
 designing or building a real machine.
\end_layout

\begin_layout Standard
Some of the studies required for engineers include arcane abstract concepts
 such as a 
\begin_inset Quotes eld
\end_inset

rank-4 elasticity tensor
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral_physics/tensors.html"
literal "false"

\end_inset


\end_layout

\end_inset

 (used in calculations of elasticity of materials), 
\begin_inset Quotes eld
\end_inset

Lagrangian with non-holonomic constraints
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/abs/math/0008147"
literal "false"

\end_inset


\end_layout

\end_inset

 (used in robotics), the 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

 (for chemical reactor design
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Introduction-Chemical-Engineering-Kinetics-Reactor/dp/1118368258"
literal "false"

\end_inset


\end_layout

\end_inset

), or the 
\begin_inset Quotes eld
\end_inset

Fourier transform of the delta function
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.youtube.com/watch?v=KAbqISZ6SHQ"
literal "false"

\end_inset


\end_layout

\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

inverse 
\begin_inset Formula $Z$
\end_inset

-transform
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/SsJqP"
literal "false"

\end_inset


\end_layout

\end_inset

 (for digital signal processing).
\end_layout

\begin_layout Standard
To be sure, a significant part of what engineers do is not covered by any
 theory: the 
\emph on
know-how
\emph default
, the informal reasoning, the traditional knowledge passed on from expert
 to novice,  — all those skills that are hard to formalize are important.
 Nevertheless, engineering is crucially based on natural science and mathematics
 for some of its decision-making about new designs.
\end_layout

\begin_layout Section
Artisanship: Trades and crafts 
\end_layout

\begin_layout Standard
Now consider what kinds of things shoemakers, plumbers, or home painters
 do, and what they have to learn in order to become proficient in their
 profession.
\end_layout

\begin_layout Standard
A novice shoemaker, for example, begins by copying some drawings
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://youtu.be/cY5MY0czMAk?t=141"
literal "false"

\end_inset


\end_layout

\end_inset

 and goes on to cutting leather in a home workshop.
 Apprenticeships proceed via learning by doing, with comments and instructions
 from an expert.
 After a few years of study (for example, a painter apprenticeship in California
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.calapprenticeship.org/programs/painter_apprenticeship.php"
literal "false"

\end_inset


\end_layout

\end_inset

 can be as short as 2 years), a new artisan is ready to start productive
 work.
 
\end_layout

\begin_layout Standard
All trades operate entirely from tradition and practical experience.
 It takes a prolonged learning effort to become a good artisan in any profession.
 But the trades do not require academic study because there is no formal
 theory from which to proceed.
 There are no Fourier transforms applied to delta functions, no Lagrangians
 with non-holonomic constraints, no rank-4 tensors to calculate, nor any
 differential equations to solve.
\end_layout

\begin_layout Standard
Artisans do not study science or mathematics because their professions do
 not make use of any formal theory for guiding their designs or processes.
\end_layout

\begin_layout Section
Programmers today are artisans, not engineers 
\end_layout

\begin_layout Standard
Programmers are 
\emph on
not engineers
\emph default
 in the sense we normally apply to the engineering professions.
\end_layout

\begin_layout Subsection
No requirement of formal study 
\end_layout

\begin_layout Standard
According to a recent Stack Overflow survey
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://thenextweb.com/insider/2016/04/23/dont-need-go-college-anymore-programmer/"
literal "false"

\end_inset


\end_layout

\end_inset

, about 56% of working programmers have no CS degree.
 The author of this book is a self-taught programmer who has degrees in
 physics but never formally studied computer science or taken any academic
 courses in algorithms, data structures, computer networks, compilers, programmi
ng languages, or other computer science topics.
 
\end_layout

\begin_layout Standard
A large fraction of successful programmers have no college degrees and perhaps
 
\emph on
never
\emph default
 studied formally.
 They acquired all their knowledge and skills through self-study and practical
 work.
 A prominent example is Robert C.
\begin_inset space ~
\end_inset

Martin
\begin_inset Index idx
status open

\begin_layout Plain Layout
Robert C.
\begin_inset space ~
\end_inset

Martin
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Robert_C._Martin"
literal "false"

\end_inset


\end_layout

\end_inset

, an outspoken guru in the arts of programming.
 He routinely refers to programmers as artisans
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2013/02/01/The-Humble-Craftsman.html"
literal "false"

\end_inset


\end_layout

\end_inset

 and uses the appropriate imagery: novices and masters, trade and craft,
 the honor of the guild, etc.
 He compares programmers to plumbers, electricians, lawyers, and surgeons,
 but never to mathematicians, physicists, or engineers of any kind.
 According to one of his blog posts
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2013/11/25/Novices-Coda.html"
literal "false"

\end_inset


\end_layout

\end_inset

, he started working at age 17 as a self-taught programmer, and then went
 on to more jobs in the software industry; he never mentioned going to college.
 It is clear that R.
\begin_inset space ~
\end_inset

C.
\begin_inset space ~
\end_inset

Martin 
\emph on
is
\emph default
 an expert craftsman and that he did 
\emph on
not
\emph default
 need academic study to master his craft.
\end_layout

\begin_layout Standard
Here is another opinion
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/tAKQ3"
literal "false"

\end_inset


\end_layout

\end_inset

 (emphasis is theirs):
\end_layout

\begin_layout Quotation

\size small
Software Engineering is unique among the STEM careers in that it absolutely
 does 
\emph on
not
\emph default
 require a college degree to be successful.
 It most certainly does not require licensing or certification.
 
\emph on
It requires experience
\emph default
.
\end_layout

\begin_layout Standard
This description fits a career in crafts — but certainly not a career, say,
 in electrical engineering.
\end_layout

\begin_layout Standard
The high demand for software developers gave rise to 
\begin_inset Quotes eld
\end_inset

developer boot camps
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/GkOL9"
literal "false"

\end_inset


\end_layout

\end_inset

 — vocational schools that educate new programmers in a few months through
 purely practical training, with no formal theory or mathematics involved.
 These vocational schools are successful
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/E9FXP"
literal "false"

\end_inset


\end_layout

\end_inset

 in job placement.
 But it is unimaginable that a 
\begin_inset Formula $6$
\end_inset

-month crash course or even a 
\begin_inset Formula $2$
\end_inset

-year vocational school could prepare engineers to work successfully on
 designing, e.g., analog quantum computers
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.dwavesys.com/quantum-computing"

\end_inset


\end_layout

\end_inset

 
\emph on
without
\emph default
 ever teaching them quantum physics or calculus.
\end_layout

\begin_layout Subsection
No mathematical formalism guides software development
\end_layout

\begin_layout Standard
Most books on software engineering contain no formulas or equations, no
 mathematical derivations, and no precise definitions of the various technical
 terms they are using (such as 
\begin_inset Quotes eld
\end_inset

object-oriented
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

module's responsibilities
\begin_inset Quotes erd
\end_inset

).
 Some of those books
\begin_inset Foot
status open

\begin_layout Plain Layout
E.g., 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Object-Oriented-Software-Engineering-Unified-Methodology/dp/0073376256"

\end_inset


\end_layout

\end_inset

 also have almost no program code in them; instead they are filled with
 words and illustrative diagrams.
 These books talk about how programmers should approach their job, how to
 organize the work flow and the code architecture, etc., in vague and general
 terms: 
\begin_inset Quotes eld
\end_inset

code is about detail
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

you must never abandon the big picture
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

avoid tight coupling in your modules
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a class must serve a single responsibility
\begin_inset Quotes erd
\end_inset

, and so on.
 Practitioners such as R.
\begin_inset space \space{}
\end_inset

C.
\begin_inset space \space{}
\end_inset

Martin never studied any formalisms and do not think in terms of formalisms;
 instead, they summarize their programming experience in vaguely formulated
 heuristic “principles”.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In contrast, textbooks on mechanical or electrical engineering include a
 significant amount of mathematics.
 The design of a microwave antenna is guided not by an 
\begin_inset Quotes eld
\end_inset

open and closed module principle
\begin_inset Quotes erd
\end_inset

 but by solving the relevant differential equations
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://youtu.be/8KpfVsJ5Jw4?t=447"
literal "false"

\end_inset


\end_layout

\end_inset

 of electrodynamics.
\end_layout

\begin_layout Standard
Donald Knuth's classic textbook is called 
\begin_inset Quotes eld
\end_inset


\emph on
The Art of Programming
\emph default

\begin_inset Quotes erd
\end_inset

.
 It is full of tips and tricks about how to program; but it does not provide
 any formal theory that could guide programmers in actually 
\emph on
writing
\emph default
 programs.
 There is nothing in that book that would be similar to the way mathematical
 formalism guides designs in electrical or mechanical engineering.
 If Knuth's books were based on such formalism, they would have looked quite
 differently: some theory would be first explained and then applied to help
 us write code.
\end_layout

\begin_layout Standard
Knuth's books provide many rigorously derived algorithms.
 But algorithms are similar to patented inventions: they can be used immediately
 without further study.
 Understanding an algorithm is not similar to understanding a mathematical
 theory.
 Knowing one algorithm does not make it easier to develop another algorithm
 in an unrelated domain.
 In comparison, knowing how to solve differential equations will be applicable
 to thousands of different areas of science and engineering.
\end_layout

\begin_layout Standard
A book exists
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Science-Programming-Monographs-Computer/dp/0387964800"
literal "false"

\end_inset


\end_layout

\end_inset

 with the title 
\begin_inset Quotes eld
\end_inset

Science of Programming
\begin_inset Quotes erd
\end_inset

, but the title is misleading.
 The author does not propose a science, similar to physics, at the foundation
 of the process of designing programs, similarly to how calculations in
 quantum physics predict the properties of a quantum device.
 The book claims to give precise methods that guide programmers in writing
 code, but the scope of proposed methods is narrow: the design of simple
 algorithms for iterative manipulation of data.
 The procedure suggested in that book is far from a formal mathematical
 
\emph on
derivation
\emph default
 of programs from specifications.
 (A book with that title
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Program-Derivation-Development-Specifications-International/dp/0201416247"
literal "false"

\end_inset


\end_layout

\end_inset

 similarly disappoints.) In any case, programmers today are oblivious to
 these books and do not use the methods explained there.
\end_layout

\begin_layout Standard
Standard computer science courses today do not teach a true 
\emph on
engineering
\emph default
 approach to software construction.
 They do teach analysis of programs using formal mathematical methods; the
 main such methods are complexity analysis
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html"
literal "false"

\end_inset


\end_layout

\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

big-
\begin_inset Formula $O$
\end_inset

 notation
\begin_inset Quotes erd
\end_inset

) and formal verification
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Formal_verification"
literal "false"

\end_inset


\end_layout

\end_inset

.
 But programs are analyzed or verified only 
\emph on
after
\emph default
 they are somehow written.
 Theory does not guide the actual 
\emph on
process
\emph default
 of writing code, does not suggest good ways of organizing the code (e.g.,
 how to decompose the code into modules, classes, or functions), does not
 tell programmers which data structures and type signatures of functions
 will be useful to implement.
 Programmers make such design decisions purely on the basis of experience
 and intuition, trial-and-error, copy-paste, and guesswork.
 
\end_layout

\begin_layout Standard
In this context, program analysis and verification is analogous to writing
 mathematical equations describing the surface of a shoe made by a fashion
 designer.
 True, the 
\begin_inset Quotes eld
\end_inset

shoe surface equations
\begin_inset Quotes erd
\end_inset

 are mathematically rigorous and can be 
\begin_inset Quotes eld
\end_inset

analyzed
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

verified
\begin_inset Quotes erd
\end_inset

; but the equations are written after the fact and do not guide the fashion
 designers in actually making shoes.
 It is understandable that fashion designers do not study the mathematical
 theory of surfaces.
\end_layout

\begin_layout Subsection
Programmers avoid academic terminology 
\end_layout

\begin_layout Standard
Programmers jokingly grumble about terms such as 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

monad
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

lambda-functions
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Quote

\size small
Those fancy words used by functional programmers purists really annoy me.
 Monads, functors...
 Nonsense!!! 
\size default

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/65K3D"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perhaps only a small minority of software developers actually complain about
 this; the vast majority seems to remain unaware of 
\begin_inset Quotes eld
\end_inset

traversable functors
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

free monads
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
However, chemical engineers accept the need for studying differential equations
 and do not mind using the terms 
\begin_inset Quotes eld
\end_inset

phase diagram
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

.
 Electrical engineers do not complain that the word 
\begin_inset Quotes eld
\end_inset

Fourier
\begin_inset Quotes erd
\end_inset

 is difficult to spell, or that 
\begin_inset Quotes eld
\end_inset

delta-function
\begin_inset Quotes erd
\end_inset

 is a weird thing to say.
 Mechanical engineers take it for granted that they need to calculate with
 
\begin_inset Quotes eld
\end_inset

tensors
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Lagrangians
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

non-holonomic constraints
\begin_inset Quotes erd
\end_inset

.
 The arcane terminology seems to be the least of their difficulties, as
 their textbooks are full of complicated equations and long derivations.
\end_layout

\begin_layout Standard
Similarly, software engineers would not complain about the word 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

, or about having to study the derivation of the algebraic laws for 
\begin_inset Quotes eld
\end_inset

monads,
\begin_inset Quotes erd
\end_inset

 — if they were true engineers.
 Textbooks on true software engineering would have been full of equations
 and derivations, in order to teach engineers how to perform certain calculation
s that are required 
\emph on
before
\emph default
 starting to write code.
\end_layout

\begin_layout Section
Towards true engineering in software
\end_layout

\begin_layout Standard
It is now clear that we do not presently have true software engineering.
 The people employed under that job title are actually artisans.
 They work using artisanal methods, and their culture and processes are
 that of a crafts guild.
\end_layout

\begin_layout Standard
True software engineering means having a mathematical theory that guides
 the process of writing programs, — not theory that describes or analyzes
 programs after they are 
\emph on
somehow
\emph default
 written.
\end_layout

\begin_layout Standard
It is true that the numerical methods required for physics or the matrix
 calculations required for data science are 
\begin_inset Quotes eld
\end_inset

mathematical
\begin_inset Quotes erd
\end_inset

.
 These programming tasks are indeed formulated using mathematical theory.
 However, mathematical 
\emph on
subject matter
\emph default
 (aerospace control, physics or astronomy simulations, or statistics) does
 not mean that engineering is used for the process of writing code.
 Data scientists, aerospace engineers, and physicists often write programs
 — but they almost always work as artisans when implementing their computations
 in program code.
\end_layout

\begin_layout Standard
We expect that software engineers
\family sans
'
\family default
 textbooks should be full of equations and derivations.
 What theory would those equations represent?
\end_layout

\begin_layout Standard
This theory is what this book calls 
\series bold
applied functional type theory
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
applied functional type theory
\end_layout

\end_inset

 (see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Applied-functional-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It represents the mathematical foundation of the modern practice of functional
 programming, as implemented in languages such as OCaml, Haskell, and Scala.
 This theory is a blend of type theory, category theory, and logical proof
 theory, adapted for the needs of programmers.
 It has been in development since late 1990s and is still being actively
 worked on by a community of software practitioners and academic computer
 scientists.
\end_layout

\begin_layout Standard
To appreciate that functional programming, unlike any other programming
 paradigm, is based on a 
\emph on
theory that guides coding
\emph default
, we can look at some recent software engineering conferences such as 
\begin_inset Quotes eld
\end_inset

Scala By the Bay
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://2015.scala.bythebay.io/"
literal "false"

\end_inset


\end_layout

\end_inset

 or BayHac
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://bayhac.org/"
literal "false"

\end_inset


\end_layout

\end_inset

, or at the numerous FP-related online tutorials and blogs.
 We cannot fail to notice that speakers devote significant time to a peculiar
 kind of applied mathematical reasoning.
 Rather than focusing on one or another API or algorithm, as it is often
 the case with other software engineering blogs or presentations, an FP
 speaker describes a 
\emph on
mathematical structure
\emph default
 — such as the 
\begin_inset Quotes eld
\end_inset

applicative functor
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.youtube.com/watch?v=bmIxIslimVY"
literal "false"

\end_inset


\end_layout

\end_inset

 or the 
\begin_inset Quotes eld
\end_inset

free monad
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.youtube.com/watch?v=U0lK0hnbc4U"
literal "false"

\end_inset


\end_layout

\end_inset

 — and illustrates its use for practical coding.
\end_layout

\begin_layout Standard
These people are not graduate students showing off their theoretical research;
 they are practitioners, software engineers who use FP on their jobs.
 It is just the nature of FP that certain mathematical tools — coming from
 formal logic and category theory — are now directly applicable to practical
 programming tasks.
\end_layout

\begin_layout Standard
These mathematical tools are not mere tricks for a specific programming
 language; they apply equally to all FP languages.
 Before starting to write code, the programmer can jot down certain calculations
 in a mathematical notation (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-calculation-in-type-theory"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The results of those calculations will help design the code fragment the
 programmer is about to write.
 This activity is similar to that of an engineer who performs some mathematical
 calculations before embarking on a design project.
 
\begin_inset Wrap figure
lines 0
placement I
overhang 0in
width "50text%"
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset VSpace 25baselineskip%
\end_inset


\begin_inset Graphics
	filename ftt-example.jpg
	width 100line%

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
\begin_inset Caption Standard

\begin_layout Plain Layout
A programmer performs a derivation before writing Haskell code.
\begin_inset CommandInset label
LatexCommand label
name "fig:Example-calculation-in-type-theory"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
A recent example of a development in applied functional type theory is the
 
\begin_inset Quotes eld
\end_inset

free applicative functor
\begin_inset Quotes erd
\end_inset

 construction.
 It was first described in a 2014 paper
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/pdf/1403.0749.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

; a couple of years later, a combined free applicative / free monad data
 type was designed and its implementation proposed 
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/typelevel/cats/issues/983"
literal "false"

\end_inset


\end_layout

\end_inset

 as well as in Haskell
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://elvishjerricco.github.io/2016/04/08/applicative-effects-in-free-monads.html"
literal "false"

\end_inset


\end_layout

\end_inset

.
 This technique allows programmers to implement declarative side-effect
 computations where some parts are sequential but other parts are computed
 in parallel, and to achieve the parallelism 
\emph on
automatically
\emph default
 while maintaining the composability of the resulting programs.
 The new technique has distinct advantages over using monad transformers,
 which was a previously used method of composing declarative side-effects.
 The combined 
\begin_inset Quotes eld
\end_inset

free applicative / free monad
\begin_inset Quotes erd
\end_inset

 was designed and implemented by true software engineers.
 They first derived the type constructor that has the necessary algebraic
 properties.
 Guided by the resulting type formula, they wrote the code that was guaranteed
 to work as intended.
\end_layout

\begin_layout Standard
Another example of applied functional type theory is the  
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
tagless final
\end_layout

\end_inset

tagless final
\begin_inset Quotes erd
\end_inset

 encoding of effects, first described
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://okmij.org/ftp/tagless-final/index.html"

\end_inset


\end_layout

\end_inset

 in 2009.
 That technique (called 
\begin_inset Quotes eld
\end_inset

Church-encoded free monad
\begin_inset Index idx
status open

\begin_layout Plain Layout
free monad
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 in the present book) has several advantages over the ordinary free monad
 and can improve upon it in a number of cases — just as the free monad itself
 was designed to cure certain problems with monad transformers
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/"
literal "false"

\end_inset


\end_layout

\end_inset

.
 The new encoding is not tied to a specific programming language.
 Rather, it is a language-agnostic construction that was originally described
 in OCaml and later used in Haskell and Scala, but can be made to work even
 in Java
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/rLAh9"
literal "false"

\end_inset


\end_layout

\end_inset

, which is not an FP language.
\end_layout

\begin_layout Standard
This example shows that we may need several more years of work before the
 practical aspects of using applied functional type theory are sufficiently
 well understood by the FP community.
 The theory is in active development, and its design patterns — as well
 as the exact scope of the requisite theoretical material — are still being
 figured out.
 If the 40-year gap hypothesis
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/rJc4A"
literal "false"

\end_inset


\end_layout

\end_inset

 holds, we should expect applied functional type theory (perhaps under a
 different name) to become mainstream by 2030.
 This book is a step towards a clear designation of the scope of that theory.
\end_layout

\begin_layout Section
Does software need engineers, or are artisans good enough? 
\end_layout

\begin_layout Standard
The demand for programmers is growing.
 
\begin_inset Quotes eld
\end_inset

Software developer
\begin_inset Quotes erd
\end_inset

 was #1 best job
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/cGJ2T"
literal "false"

\end_inset


\end_layout

\end_inset

 in the US in 2018.
 But is there a demand for engineers or just for artisans?
\end_layout

\begin_layout Standard
We do not seem to be able to train enough software artisans.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/137b8"
literal "false"

\end_inset


\end_layout

\end_inset

 So, it is probably impossible to train as many software engineers in the
 true sense of the word.
 Modern computer science courses do not actually train engineers in that
 sense; at best, they train academic researchers who write code as software
 artisans.
 Recalling the situation in construction business, with a few architects
 and hundreds of construction workers, we might also conclude that, perhaps,
 only a few software engineers are required per hundred software artisans.
\end_layout

\begin_layout Standard
What is the price of 
\emph on
not
\emph default
 having engineers, of replacing them with artisans?
\end_layout

\begin_layout Standard
Software practitioners have long bemoaned the mysterious difficulty of software
 development.
 Code 
\begin_inset Quotes eld
\end_inset

rots with time
\begin_inset Quotes erd
\end_inset

, its complexity grows 
\begin_inset Quotes eld
\end_inset

out of control
\begin_inset Quotes erd
\end_inset

, and operating systems have been notorious for ever-appearing security
 flaws
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.fo/HtQzw"
literal "false"

\end_inset


\end_layout

\end_inset

 despite many thousands of programmers and testers employed.
 Clearly, we overestimated the capacity of the human brain for artisanal
 programming.
\end_layout

\begin_layout Standard
It is precisely in designing large and robust software systems that we would
 benefit from true engineering.
 Artisans has been building bridges and using chemical reactions by trial
 and error and via tradition, long before mechanical or chemical engineering
 disciplines were developed and founded upon rigorous theory.
 But once the theory became available, engineers were able to design unimaginabl
y more powerful and complicated structures, devices, and processes.
 It is clear that trial, error, and adherence to tradition is inadequate
 for some of the software development tasks in front of us.
 
\end_layout

\begin_layout Standard
To build large and reliable software, such as new mobile or embedded operating
 systems or distributed peer-to-peer trust architectures, we will most likely
 need the qualitative increase in productivity and reliability that can
 only come from replacing artisanal programming by a true engineering discipline.
 Applied functional type theory and functional programming are steps in
 that direction.
\end_layout

\begin_layout Chapter
Essay: Towards functional data engineering with Scala
\end_layout

\begin_layout Standard
Data engineering is among the most in-demand
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/mK59h"
literal "false"

\end_inset


\end_layout

\end_inset

 novel occupations in the IT world today.
 Data engineers create software pipelines that process large volumes of
 data efficiently.
 Why did the Scala programming language emerge as a premier tool
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.slideshare.net/noootsab/scala-the-unpredicted-lingua-franca-for-data-science"
literal "false"

\end_inset


\end_layout

\end_inset

 for crafting the foundational data engineering technologies such as Spark
 or Akka? Why is Scala in high demand
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://techcrunch.com/2016/06/14/scala-is-the-new-golden-child/"
literal "false"

\end_inset


\end_layout

\end_inset

 within the world of big data?
\end_layout

\begin_layout Standard
There are reasons to believe that the choice of Scala was not accidental.
\end_layout

\begin_layout Section
Data is math
\end_layout

\begin_layout Standard
Humanity has been working with data at least since Babylonian tax tables
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.nytimes.com/2017/08/29/science/trigonometry-babylonian-tablet.html"
literal "false"

\end_inset


\end_layout

\end_inset

 and the ancient Chinese number books
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://quatr.us/china/science/chinamath.htm"
literal "false"

\end_inset


\end_layout

\end_inset

.
 Mathematics summarizes several millennia's worth of data processing experience
 in a few fundamental tenets:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement I
overhang 0in
width "34col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset Graphics
	filename type-error.jpg
	width 96line%

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Mixing incompatible data types produces nonsensical results.
\begin_inset CommandInset label
LatexCommand label
name "fig:A-nonsensical-calculation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -350baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Data is 
\emph on
immutable
\emph default
, because facts are immutable.
 
\end_layout

\begin_layout Itemize
Each 
\emph on
type
\emph default
 of values (population count, land area, distances, prices, times, etc.)
 needs to be handled separately; it is meaningless to add a distance to
 a population count.
\end_layout

\begin_layout Itemize
Data processing should be performed according to 
\emph on
mathematical formulas
\emph default
.
 
\end_layout

\begin_layout Standard
Violating these tenets produces nonsense (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-nonsensical-calculation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a real-life illustration).
\end_layout

\begin_layout Standard
The power of the principles of mathematics extends over all epochs and all
 cultures; math is the same in San Francisco, in Rio de Janeiro, in Kuala-Lumpur
, and in Pyongyang (Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-Pyongyang-method-of-error-free-programming"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
Functional programming is math
\end_layout

\begin_layout Standard
The functional programming paradigm is based on mathematical principles:
 values are immutable, data processing is coded through formula-like expressions
, and each type of data is required to match correctly during the computations.
 The type-checking process automatically prevents programmers from making
 many kinds of coding errors.
 In addition, programming languages such as Scala and Haskell have a set
 of features adapted to building powerful abstractions and domain-specific
 languages.
 This power of abstraction is not accidental.
 Since mathematics is the ultimate art of building abstractions, math-based
 functional programming languages capitalize on the advantage of millennia
 of mathematical experience.
\end_layout

\begin_layout Standard
A prominent example of how mathematics informs the design of programming
 languages is the connection between constructive logic
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Intuitionistic_logic"
literal "false"

\end_inset


\end_layout

\end_inset

 and the programming language's type system, called the Curry-Howard (CH)
 correspondence
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence"
literal "false"

\end_inset


\end_layout

\end_inset

.
 The main idea of the CH correspondence
\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

 is to think of programs as mathematical formulas that compute a value of
 a certain type 
\begin_inset Formula $A$
\end_inset

.
 The CH correspondence is between programs and logical propositions: To
 any program that computes a value of type 
\begin_inset Formula $A$
\end_inset

, there corresponds a proposition stating that 
\begin_inset Quotes eld
\end_inset

a value of type 
\begin_inset Formula $A$
\end_inset

 can be computed
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
This may sound rather theoretical so far.
 To see the real value of the CH correspondence, recall that formal logic
 has operations 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
and
\series default
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
or
\series default
\emph default

\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset


\series bold
\emph on
implies
\series default
\emph default

\begin_inset Quotes erd
\end_inset

.
 For any two propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, we can construct the propositions 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
and
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
or
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
implies
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 These three logical operations are foundational; without one of them, the
 logic is 
\emph on
incomplete
\emph default
 (you cannot derive some theorems).
\end_layout

\begin_layout Standard
A programming language 
\series bold
obeys the CH correspondence
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

 with the logic if for any types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, the language also contains composite types corresponding to the logical
 formulas 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
or
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
and
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $A$
\end_inset

 
\series bold
\emph on
implies
\series default
\emph default
 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 In Scala, these composite types are 
\family typewriter
Either[A,B]
\family default
, the tuple 
\family typewriter
(A,B)
\family default
, and the function type, 
\family typewriter
A
\begin_inset Formula $\rightarrow$
\end_inset

B
\family default
.
 All modern functional languages such as OCaml, Haskell, Scala, F#, Swift,
 Elm, and PureScript support these three type constructions and thus are
 faithful to the CH correspondence.
 Having a 
\emph on
complete
\emph default
 logic in a language's type system enables declarative domain-driven code
 design
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://fsharpforfunandprofit.com/ddd/"
literal "false"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement I
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Graphics
	filename no-bugs.jpg
	width 100line%

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The Pyongyang method of error-free software engineering.
\begin_inset CommandInset label
LatexCommand label
name "fig:The-Pyongyang-method-of-error-free-programming"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -300baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is interesting to note that most older programming languages (C/C++,
 Java, JavaScript, Python) do not support some of these composite types.
 In other words, these programming languages have type systems based on
 an incomplete logic.
 As a result, users of these languages have to implement burdensome workarounds
 that make for error-prone code.
 Failure to follow mathematical principles has real costs (Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-Pyongyang-method-of-error-free-programming"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
The power of abstraction
\end_layout

\begin_layout Standard
Early adopters of Scala, such as Netflix, LinkedIn, and Twitter, were implementi
ng what is now called 
\begin_inset Quotes eld
\end_inset

big data engineering
\begin_inset Quotes erd
\end_inset

.
 The required software needs to be highly concurrent, distributed, and resilient
 to failure.
 Those software companies used Scala as their main implementation language
 and reaped the benefits of functional programming.
\end_layout

\begin_layout Standard
What makes Scala suitable for big data tasks? The only reliable way of managing
 massively concurrent code is to use sufficiently high-level abstractions
 that make application code declarative.
 The two most important such abstractions are the 
\begin_inset Quotes eld
\end_inset

resilient distributed dataset
\begin_inset Quotes erd
\end_inset

 (RDD) of Apache Spark and the 
\begin_inset Quotes eld
\end_inset

reactive stream
\begin_inset Quotes erd
\end_inset

 used in systems such as Kafka, Akka Streams, and Apache Flink.
 While these abstractions are certainly implementable in Java or Python,
 a fully declarative and type-safe usage is possible only in a programming
 language with a sophisticated type system.
 Among the currently available mature functional languages, only Scala and
 Haskell are technically adequate for that task, due to their support for
 typeclasses and higher-order types.
 The early adopters of Scala were able to benefit from the powerful abstractions
 Scala supports.
 In this way, Scala enabled those businesses to engineer and to scale up
 their massively concurrent computations.
\end_layout

\begin_layout Standard
It remains to see why Scala and not, say, Haskell became the 
\emph on
lingua franca
\emph default
 of big data.
\end_layout

\begin_layout Section
Scala is Java on math 
\end_layout

\begin_layout Standard
The recently invented general-purpose functional programming languages can
 be grouped into 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 (F#, Scala, Swift) and 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 (OCaml, Haskell).
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages are clean-room implementations of well-researched mathematical
 principles of programming language design (the CH correspondence being
 one such principle).
 These languages are unencumbered by requirements of compatibility with
 any existing platform or libraries.
 Because of this, the 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages are perfect playgrounds for taking various mathematical ideas
 to their logical conclusion.
 At the same time, software practitioners struggle to adopt these languages
 due to a steep learning curve, a lack of enterprise-grade libraries and
 tool support, and immature package management.
\end_layout

\begin_layout Standard
The languages from the 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 group are based on existing and mature software ecosystems: F# on .NET,
 Scala on JVM, and Swift on the MacOS/iOS platform.
 One of the important design requirements for these languages is 100% binary
 compatibility with their 
\begin_inset Quotes eld
\end_inset

parent
\begin_inset Quotes erd
\end_inset

 platforms and languages (F# with C#, Scala with Java, and Swift with Objective-
C).
 Because of this, developers can immediately take advantage of the existing
 tooling, package management, and industry-strength libraries, while slowly
 ramping up the idiomatic usage of new language features.
 However, the same compatibility requirements dictated certain limitations
 in the languages, making their design less than fully satisfactory from
 the functional programming viewpoint.
\end_layout

\begin_layout Standard
It is now easy to see why the adoption rate of the 
\begin_inset Quotes eld
\end_inset

industrial
\begin_inset Quotes erd
\end_inset

 group of languages is much higher
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.tiobe.com/tiobe-index/"
literal "false"

\end_inset


\family default
, archived in 2019 at 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/RsNH8"

\end_inset


\end_layout

\end_inset

 than that of the 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 languages.
 The transition to the functional paradigm is also smoother for software
 developers because F#, Scala, and Swift seamlessly support the familiar
 object-oriented programming paradigm.
 At the same time, these new languages still have logically complete type
 systems, which gives developers an important benefit of type-safe domain
 modeling.
\end_layout

\begin_layout Standard
Nevertheless, the type systems of these languages are not equally powerful.
 For instance, F# and Swift are similar to OCaml in many ways but omit OCaml's
 parameterized modules and some other features.
 Of all mentioned languages, only Scala and Haskell directly support typeclasses
 and higher-order types, which are helpful for expressing abstractions such
 as automatically parallelized data sets or asynchronous data streams.
\end_layout

\begin_layout Standard
To see the impact of these advanced features, consider LINQ, a domain-specific
 language for database queries on .NET, implemented in C# and F# through
 a special built-in syntax supported by Microsoft's compilers.
 Analogous functionality is provided in Scala as a 
\emph on
library
\emph default
, without need to modify the Scala compiler, by several open-source projects
 such as Slick, Squeryl, or Quill.
 Similar libraries exist for Haskell — but not in languages with less powerful
 type systems.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
The decisive advantages of Scala over other contenders (such as OCaml, Haskell,
 F#, or Swift) are:
\end_layout

\begin_layout Enumerate
Functional collections in the standard library.
\end_layout

\begin_layout Enumerate
A sophisticated type system with support for typeclasses and higher-order
 types.
\end_layout

\begin_layout Enumerate
Seamless compatibility with a mature software ecosystem (JVM).
\end_layout

\begin_layout Standard
Based on this assessment, we may be confident in Scala's great future as
 a main implementation language for big data engineering.
 
\end_layout

\end_body
\end_document
