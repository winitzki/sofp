#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset


\end_layout

\begin_layout Chapter
Traversable functors
\begin_inset CommandInset label
LatexCommand label
name "chap:9-Traversable-functors-and"

\end_inset


\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
Starting from the year 2004, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 programming style
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
map
\family default
/
\family typewriter
reduce
\family default
 programming style
\end_layout

\end_inset

 was the first significant industrial use of functional programming.
 Other methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 were added later to increase the expressive power of that programming style.
 Previous chapters examined systematically the properties of some of those
 methods and generalized them to many different type constructors.
 This chapter uses the same approach to study and generalize the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method.
 In this way, we obtain a complete understanding of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 programming.
\end_layout

\begin_layout Subsection
From 
\family typewriter
reduce
\family default
 and 
\family typewriter
foldLeft
\family default
 to 
\family typewriter
foldMap
\end_layout

\begin_layout Standard
The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](la: Seq[A])(update: (A, A) => A): A
\end_layout

\begin_layout Plain Layout

def foldLeft[A, B](la: Seq[A])(init: B)(update: (B, A) => B): B
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{reduce}:\text{Seq}^{A}\rightarrow(A\times A\rightarrow A)\rightarrow A\quad,\quad\quad\text{foldLeft}:\text{Seq}^{A}\rightarrow B\rightarrow(B\times A\rightarrow B)\rightarrow B\quad.
\]

\end_inset

We can see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is a generalized version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

: in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, the accumulated result is of a different type (
\begin_inset Formula $B$
\end_inset

) than the type of sequence elements (
\begin_inset Formula $A$
\end_inset

).
 It is easy to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](la: Seq[A])(update: (A, A) => A): A = reduce.tail.foldLeft(reduce.hea
d)(update)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 operations will go over each element of the sequence and accumulate the
 state updates, returning the final value.
 We have seen many examples of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Now we would like to generalize these functions to data structures other
 than sequences.
 Such a generalization must be based on requiring suitable laws, but it
 is not obvious what laws 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 must satisfy (other than naturality laws that will hold automatically for
 any fully parametric code).
 To make progress, we need to simplify these type signatures and to reformulate
 them in a more suggestive form.
 We will achieve this reformulation in two steps, generalizing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 first to a new function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and then to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The way to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 starts by changing the type of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

update: (B, A) => B
\end_layout

\end_inset

 to an equivalent curried form with flipped argument order:
\begin_inset Formula 
\[
\text{upd}:A\rightarrow B\rightarrow B\quad.
\]

\end_inset

So, 
\begin_inset Formula $\text{upd}\left(x^{:A}\right)$
\end_inset

 has type 
\begin_inset Formula $B\rightarrow B$
\end_inset

.
 The key observation is that all functions of type 
\begin_inset Formula $B\rightarrow B$
\end_inset

 form a 
\emph on
monoid
\emph default
 (denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidFunc
\end_layout

\end_inset

 in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
monoid
\end_layout

\end_inset

 For brevity, let us denote that monoid by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MF
\end_layout

\end_inset

.
 The empty element of that monoid is the identity function (
\begin_inset Formula $e_{\text{MF}}\triangleq\text{id}^{:B\rightarrow B}$
\end_inset

), and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

 operation is the function composition (
\begin_inset Formula $f^{:B\rightarrow B}\oplus_{\text{MF}}g^{:B\rightarrow B}\triangleq f\bef g$
\end_inset

).
 With this formulation, the evaluation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 function can be written like this:
\begin_inset Formula 
\begin{align*}
 & \text{foldl}\left(\left[x_{1},x_{2},x_{3}\right]\right)\left(b_{0}\right)\left(\text{upd}\right)=b_{0}\triangleright\text{upd}\left(x_{1}\right)\triangleright\text{upd}\left(x_{2}\right)\triangleright\text{upd}\left(x_{3}\right)\\
 & =b_{0}\triangleright\text{upd}\left(x_{1}\right)\bef\text{upd}\left(x_{2}\right)\bef\text{upd}\left(x_{3}\right)=b_{0}\triangleright\big(\text{upd}\left(x_{1}\right)\oplus_{\text{MF}}\text{upd}\left(x_{2}\right)\oplus_{\text{MF}}\text{upd}\left(x_{3}\right)\big)\quad.
\end{align*}

\end_inset

This formulation suggests that we could replace the specific monoid (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MF
\end_layout

\end_inset

) by an arbitrary monoid (
\begin_inset Formula $M$
\end_inset

).
 The new, more general function is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 To obtain that function, we first change the order of the curried arguments
 for convenience:
\begin_inset Formula 
\[
\text{foldMap}\left(\text{upd}\right)\left(xs\right)\left(b_{0}\right)\triangleq\text{foldl}\left(xs\right)\left(b_{0}\right)\left(\text{upd}\right)\quad.
\]

\end_inset

Omitting the argument 
\begin_inset Formula $b_{0}$
\end_inset

, we may visualize the computation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
\text{foldMap}\left(\text{upd}\right)\left(\left[x_{1},x_{2},x_{3}\right]\right)=\text{upd}\left(x_{1}\right)\oplus_{M}\text{upd}\left(x_{2}\right)\oplus_{M}\text{upd}\left(x_{3}\right)\quad.
\]

\end_inset

Now, the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

upd
\end_layout

\end_inset

 is 
\begin_inset Formula $A\rightarrow M$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow B\rightarrow B$
\end_inset

.
 So, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 must be:
\begin_inset Formula 
\[
\text{foldMap}:(A\rightarrow M)\rightarrow\text{Seq}^{A}\rightarrow M\quad.
\]

\end_inset

This type signature assumes that 
\begin_inset Formula $M$
\end_inset

 is a monoid type.
 We can now implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldMap[M: Monoid, A](f: A => M): Seq[A] => M =
\end_layout

\begin_layout Plain Layout

  _.foldLeft(Monoid[M].empty) { (m, a) => m |+| f(a) }
\end_layout

\end_inset

We can also implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 by using the monoid instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FM
\end_layout

\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def monoidFunc[A]: Monoid[A => A] = ...
\end_layout

\begin_layout Plain Layout

def foldLeft[A, B](la: Seq[A])(init: B)(update: (B, A) => B): B =
\end_layout

\begin_layout Plain Layout

  foldMap[B => B, A](identity)(a => b => update(b, a))(init)
\end_layout

\end_inset

We will prove later than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are in fact equivalent.
\end_layout

\begin_layout Standard
The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 suggests further to replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 by another type constructor (say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

).
 We may call 
\series bold
foldable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
foldable functor
\end_layout

\end_inset

 a type constructor 
\begin_inset Formula $L^{\bullet}$
\end_inset

 for which the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 method is defined:
\begin_inset Formula 
\[
\text{foldMap}_{L}:\left(A\rightarrow M\right)\rightarrow L^{A}\rightarrow M\quad,\quad\text{assuming that }M\text{ is a monoid}\quad.
\]

\end_inset

The function 
\begin_inset Formula $\text{foldMap}_{L}$
\end_inset

 works in the same way for all monoids 
\begin_inset Formula $M$
\end_inset

 (but differently for each 
\begin_inset Formula $L^{\bullet}$
\end_inset

).
 
\end_layout

\begin_layout Standard
The second step that will bring us to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method replaces the arbitrary monoid 
\begin_inset Formula $M$
\end_inset

 by an arbitrary applicative functor 
\begin_inset Formula $F^{B}$
\end_inset

 applied to a type parameter 
\begin_inset Formula $B$
\end_inset

.
 Since this step is not straightforward, we will give an independent motivation
 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method in the next subsection.
\end_layout

\begin_layout Subsection
The 
\family typewriter
traverse
\family default
 operation
\end_layout

\begin_layout Standard
It is often necessary to wait for several concurrent operations to finish.
 As a simple example, assume that we are given a list of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 and a processing function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Future[B]
\end_layout

\end_inset

.
 We are required to apply the processing function to all items from the
 list in parallel and wait until the entire data set is processed.
\end_layout

\begin_layout Standard
The Scala standard library method to use in this situation is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.traverse
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val data: List[A] = ...
\end_layout

\begin_layout Plain Layout

val processing: A => Future[B] = ...
\end_layout

\begin_layout Plain Layout

implicit val ec: ExecutionContext = ...
\end_layout

\begin_layout Plain Layout

val results: Future[List[B]] = Future.traverse(data)(processing)
\end_layout

\end_inset

Since the processing of each element is asynchronous, the result must be
 also wrapped in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 type constructor.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method will mark that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 value as finished only when all processing operations are done.
\end_layout

\begin_layout Standard
If we ignore the implicit argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ExecutionContext
\end_layout

\end_inset

 (which is specific to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 data type) and also flip the first two curried arguments, we will arrive
 at the following type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{trav}$
\end_inset


\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\[
\text{trav}:(A\rightarrow\text{Future}^{B})\rightarrow\text{List}^{A}\rightarrow\text{Future}^{\text{List}^{B}}\quad.
\]

\end_inset

Generalizing to other type constructors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, we obtain:
\begin_inset Formula 
\[
\text{trav}_{L}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}\quad.
\]

\end_inset

In this type signature, we have chosen the names 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 specifically to help us avoid errors (e.g., writing 
\begin_inset Formula $L^{F^{B}}$
\end_inset

 instead of 
\begin_inset Formula $F^{L^{B}}$
\end_inset

) by recalling the example with 
\begin_inset Formula $F=$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset Formula $L=$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It turns out that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method can work in the same way for any 
\emph on
applicative
\emph default
 functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

.
 A functor 
\begin_inset Formula $L^{\bullet}$
\end_inset

 having a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method of this type is called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
traversable
\end_layout

\end_inset


\series bold
traversable
\series default
.
\end_layout

\begin_layout Standard
The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are similar except that 
\begin_inset Formula $M$
\end_inset

 is replaced by 
\begin_inset Formula $F^{B}$
\end_inset

 or 
\begin_inset Formula $F^{L^{B}}$
\end_inset

 as appropriate.
 To see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 is a special case of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, consider a constant functor 
\begin_inset Formula $F^{A}\triangleq M$
\end_inset

, which is applicative if 
\begin_inset Formula $M$
\end_inset

 is a monoid (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-applicative-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 With this choice of 
\begin_inset Formula $F^{\bullet}$
\end_inset

, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 reduces to that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Before studying the properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, we will look at some examples of its practical use.
\end_layout

\begin_layout Section
Practical use of 
\family typewriter
foldMap
\family default
 and 
\family typewriter
traverse
\end_layout

\begin_layout Subsection
Implementing 
\family typewriter
traverse
\family default
 for various data types
\end_layout

\begin_layout Standard
To understand how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 works, let us implement it for some simple data types.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traverse-for-1+a*a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-for-1+a*a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the type constructor 
\begin_inset Formula $L^{\bullet}$
\end_inset

 defined by:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type L[A] = Option[(A, A)]
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For the given type constructor 
\begin_inset Formula $L^{\bullet}$
\end_inset

, write an equivalent type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]]
\end_layout

\end_inset

Here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 is an unknown applicative functor.
 In the short type notation, this type signature is:
\begin_inset Formula 
\[
\text{trav}_{L}:(A\rightarrow F^{B})\rightarrow(\bbnum 1+A\times A)\rightarrow F^{\bbnum 1+B\times B}\quad.
\]

\end_inset

 Let us implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

, aiming to preserve information.
 We need to compute a value of type 
\begin_inset Formula $F^{\bbnum 1+B\times B}$
\end_inset

.
 Since 
\begin_inset Formula $F$
\end_inset

 is applicative, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 could just always return an empty value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] =
\end_layout

\begin_layout Plain Layout

  F.pure(None)   // Assuming F.pure is defined.
\end_layout

\end_inset

We reject this implementation since it ignores all arguments and loses informati
on.
 Instead, we begin by pattern matching on the argument of type 
\begin_inset Formula $\bbnum 1+A\times A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] = {
\end_layout

\begin_layout Plain Layout

  case None             => F.pure(None)   // We must return this value in
 this case.
\end_layout

\begin_layout Plain Layout

  case Some((a1, a2))   => ???            // Would like a value of type
 F[Some[(B, B)]] here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The only way of getting values of type 
\begin_inset Formula $B$
\end_inset

 is by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to some arguments.
 We can apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

; the result will be two values of type 
\begin_inset Formula $F^{B}$
\end_inset

.
 Since 
\begin_inset Formula $F$
\end_inset

 is applicative, we may use its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method and obtain a single value of type 
\begin_inset Formula $F^{B\times B}$
\end_inset

.
 It remains to use 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and transform that value to the required type 
\begin_inset Formula $F^{\bbnum 1+B\times B}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] = {
\end_layout

\begin_layout Plain Layout

  case None             => F.pure(None)         // Here we must return an
 empty value.
\end_layout

\begin_layout Plain Layout

  case Some((a1, a2))   => F.zip(f(a1), f(a2)).map { case (b1, b2)  => Some((b1,
 b2)) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the code notation, this is written as:
\begin_inset Formula 
\[
\text{trav}_{L}(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{\bbnum 1+B\times B}\\
\hline \bbnum 1 & \_\rightarrow\text{pu}_{F}(\bbnum 1+\bbnum 0^{:B\times B})\\
A\times A & (f\boxtimes f)\bef\text{zip}_{F}\bef(b_{1}^{:B}\times b_{2}^{:B}\rightarrow\bbnum 0^{:\bbnum 1}+b_{1}\times b_{2})^{\uparrow F}
\end{array}\quad.
\]

\end_inset

The code uses 
\begin_inset Formula $F$
\end_inset

's methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

.
 This makes it clear why 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 requires 
\begin_inset Formula $F$
\end_inset

 to be an applicative functor.
 Apart from that requirement, the code works in the same way for all 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traversable-seq"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversable-seq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type constructor.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to implement the following type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): List[A] => F[List[B]]
\end_layout

\end_inset

A list may be empty, or may have a head and a tail.
 Similarly to the code in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-for-1+a*a"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we use 
\begin_inset Formula $F$
\end_inset

's methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to compute a suitable value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[Seq[B]]
\end_layout

\end_inset

 in these cases.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): List[A] => F[List[B]]
 = {
\end_layout

\begin_layout Plain Layout

  case Nil            => F.pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => F.zip(f(head), trav(f)(tail)).map { case (headB,
 tailB)  => headB :: tailB }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code iterates over each element of the list (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

) and accumulates the effect expressed by the applicative functor 
\begin_inset Formula $F$
\end_inset

.
 The 
\begin_inset Formula $F$
\end_inset

-effects are merged using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method.
\end_layout

\begin_layout Standard
In the code notation, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 looks like this:
\begin_inset Formula 
\[
\text{trav}_{\text{List}}(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{\bbnum 1+B\times\text{List}^{B}}\\
\hline \bbnum 1 & \_\rightarrow\text{pu}_{F}(\bbnum 1+\bbnum 0^{:B\times\text{List}^{B}})\\
A\times\text{List}^{A} & \big(f\boxtimes\overline{\text{trav}}_{\text{List}}(f)\big)\bef\text{zip}_{F}\bef(h^{:B}\times t^{:\text{List}^{B}}\rightarrow\bbnum 0^{:\bbnum 1}+h\times t)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traverse-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for the binary tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tree2
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Binary-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 similarly to the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Binary-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Tree2[A] => F[Tree2[B
]] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)          => f(a).map(b => Leaf(b))                    // Reproduce
 the Leaf structure.
\end_layout

\begin_layout Plain Layout

  case Branch(t1, t2)   =>
\end_layout

\begin_layout Plain Layout

    val (r1, r2) = (trav(f)(t1), trav(f)(t2))    // Traverse the two branches
 and obtain two results.
\end_layout

\begin_layout Plain Layout

    F.zip(r1, f2).map { case (b1, b2)   => Branch(b1, b2) }        // Reproduce
 the Branch structure.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the code notation, this function looks like this:
\begin_inset Formula 
\[
\text{trav}\,(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{B+\text{Tree}_{2}^{B}\times\text{Tree}_{2}^{B}}\\
\hline A & f\bef(b^{:B}\rightarrow b+\bbnum 0^{:\text{Tree}_{2}^{B}\times\text{Tree}_{2}^{B}})^{\uparrow F}\\
\text{Tree}_{2}^{A}\times\text{Tree}_{2}^{A} & \big(\overline{\text{trav}}\,(f)\boxtimes\overline{\text{trav}}\,(f)(f)\big)\bef\text{zip}_{F}\bef(l^{:\text{Tree}_{2}^{B}}\times r^{:\text{Tree}_{2}^{B}}\rightarrow\bbnum 0^{:B}+l\times r)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The code first traverses the two sub-branches (using recursive calls to
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

) and then combines the resulting values.
 So, this implementation represents a depth-first traversal of the tree.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
These examples show how one would implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for a data structure of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 Each element of type 
\begin_inset Formula $A$
\end_inset

 contained in the data structure should be processed using the given function
 
\begin_inset Formula $f:A\rightarrow F^{B}$
\end_inset

.
 All of the resulting 
\begin_inset Formula $F$
\end_inset

-effects need to be collected and merged (using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

) into a single 
\begin_inset Formula $F$
\end_inset

-effect that wraps a value of type 
\begin_inset Formula $L^{B}$
\end_inset

.
 That value should (as closely as possible) repeat the data structure that
 was present in the input value of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
In all examples above, we all 
\begin_inset Formula $F$
\end_inset

-effects together, making sure that each 
\begin_inset Formula $F$
\end_inset

-effect is collected exactly once.
 It would be strange if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation were to repeat some 
\begin_inset Formula $F$
\end_inset

-effects, as the following code shows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def badtrav[A, B, F[_]: Functor : Applicative](f: A => F[B]): List[A] =>
 F[List[B]] = {
\end_layout

\begin_layout Plain Layout

  case Nil            => F.pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => F.zip(f(head), F.zip(f(head), badtrav(f)(tail)))
  // Use the F-effect twice.
\end_layout

\begin_layout Plain Layout

                          .map { case (headB, (_, tailB))  => headB :: tailB
 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Although this implementation fits the right type signature, it goes against
 the intuition of traversing the sequence only once.
 When 
\begin_inset Formula $F=$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

, the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

badtrav(f)(xs)
\end_layout

\end_inset

 would start 
\emph on
two
\emph default
 parallel computations for each element of the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and ignore one of the results.
 When 
\begin_inset Formula $F$
\end_inset

's effect describes parsing (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Parsing-with-applicative-and-monadic-parsers"
plural "false"
caps "false"
noprefix "false"

\end_inset

) or other computations that maintain an internal state, invoking such an
 
\begin_inset Formula $F$
\end_inset

-effect twice will likely lead to incorrect results.
 Below we will see that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 prohibit implementations that either repeat some of the 
\begin_inset Formula $F$
\end_inset

-effects or ignore some of the values.
\end_layout

\begin_layout Subsection
Converting foldable data types to lists 
\end_layout

\begin_layout Subsection
Folding for aggregating tree-like data
\end_layout

\begin_layout Subsection
Decorating a tree with depth-first traversal
\end_layout

\begin_layout Subsection
Using 
\family typewriter
traverse
\family default
 and the 
\family typewriter
State
\family default
 monad
\end_layout

\begin_layout Standard
Implement scanMap and scanLeft
\end_layout

\begin_layout Subsection
Traversing a regular-shaped binary tree
\end_layout

\begin_layout Standard
\begin_inset Formula $T^{A}\triangleq A+T^{A\times A}$
\end_inset


\end_layout

\begin_layout Standard
The corresponding construction is 
\begin_inset Formula $L^{A}\triangleq S^{A,L^{R^{A}}}$
\end_inset

 where 
\begin_inset Formula $R$
\end_inset

 is applicative and traversable and 
\begin_inset Formula $S$
\end_inset

 is bitraversable
\end_layout

\begin_layout Subsection
Examples of tasks that 
\emph on
cannot
\emph default
 be implemented as a traversal
\end_layout

\begin_layout Standard
Breadth-first traversal for a tree as 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ 2 [ 3 4 ] ] 1 ] 
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Depth labeling of a tree as 
\size footnotesize

\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ 2 [ 3 3 ] ] 1 ] 
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Laws and structure
\end_layout

\begin_layout Section
Slides
\end_layout

\begin_layout Paragraph
Motivation for the 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 operation
\end_layout

\begin_layout Standard
Which functors 
\begin_inset Formula $L$
\end_inset

 can have this operation?
\end_layout

\begin_layout Standard
Can we express 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 through a simpler operation?
\end_layout

\begin_layout Standard
What are the required laws for 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Standard
What about contrafunctors or profunctors?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Deriving the 
\family typewriter
\size footnotesize
\color blue
sequence
\family default
\size default
\color inherit
 operation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

The type signature of 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 is a complicated 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 is often equivalent to a simpler natural transformation
\end_layout

\begin_layout Standard
To derive it, ask: what is missing from 
\family typewriter
\size footnotesize
\color blue
fmap
\family default
\size default
\color inherit
 to do the job of 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
?
\size footnotesize

\begin_inset Formula 
\[
\text{fmap}_{L}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow L^{F^{B}}
\]

\end_inset


\end_layout

\begin_layout Standard
We need 
\begin_inset Formula $F^{L^{B}}$
\end_inset

, but the 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 operation gives us 
\begin_inset Formula $L^{F^{B}}$
\end_inset

 instead
\end_layout

\begin_layout Standard
What's missing is a natural transformation 
\family typewriter
\size footnotesize
\color blue
sequence
\family default
\size default
\color inherit
 
\begin_inset Formula $:L^{F^{B}}\rightarrow F^{L^{B}}$
\end_inset

 
\end_layout

\begin_layout Standard
The functions 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
sequence
\family default
\size default
\color inherit
 are computationally equivalent:
\size footnotesize

\begin_inset Formula 
\[
\text{trav}(f^{:A\rightarrow F^{B}})=f^{\uparrow L}\bef\text{seq}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & L^{F^{B}}\ar[rd]\sp(0.45){\text{seq}}\\
L^{A}\ar[ru]\sp(0.45){\big(f^{:A\rightarrow F^{B}}\big)^{\uparrow L}}\ar[rr]\sb(0.45){\text{trav}\,f^{\underline{A\rightarrow F^{B}}}} &  & F^{L^{B}}
}
\]

\end_inset


\size default
Here 
\begin_inset Formula $F$
\end_inset

 is an 
\emph on
arbitrary
\emph default
 applicative functor
\end_layout

\begin_layout Standard
Keep in mind the example 
\family typewriter
\size footnotesize
\color blue
Future.sequence
\family default
\size default
\color inherit
 
\begin_inset Formula $:\text{List}^{\text{Future}^{X}}\rightarrow\text{Future}^{\text{List}^{X}}$
\end_inset


\end_layout

\begin_layout Standard
Examples: 
\begin_inset Formula $L^{A}\triangleq A\times A\times A$
\end_inset

; 
\begin_inset Formula $L^{A}=\text{List}^{A}$
\end_inset

; finite trees 
\end_layout

\begin_layout Standard
Non-traversable: 
\begin_inset Formula $L^{A}\triangleq R\rightarrow A$
\end_inset

; lazy list (
\begin_inset Quotes eld
\end_inset

infinite product
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Note: We 
\emph on
cannot have
\emph default
 the opposite transformation 
\begin_inset Formula $F^{L^{B}}\rightarrow L^{F^{B}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Polynomial functors are traversable
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Generalize from the example 
\begin_inset Formula $L^{A}\triangleq A\times A\times A$
\end_inset

 to other polynomials
\end_layout

\begin_layout Standard
Polynomial functors have the form 
\size small

\begin_inset Formula 
\[
L^{A}\triangleq Z\times A\times...\times A+Y\times A\times...\times A+...+Q\times A+P
\]

\end_inset


\end_layout

\begin_layout Standard
To implement 
\size small

\begin_inset Formula $\text{seq}:L^{F^{B}}\rightarrow F^{L^{B}}$
\end_inset


\size default
, consider monomial 
\size small

\begin_inset Formula $L^{A}\triangleq Z\times A\times...\times A$
\end_inset


\end_layout

\begin_layout Standard
We have 
\begin_inset Formula $L^{F^{B}}=Z\times F^{B}\times...\times F^{B}$
\end_inset

; apply 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 and get 
\begin_inset Formula $Z\times F^{B\times...\times B}$
\end_inset

 
\end_layout

\begin_layout Standard
Lift 
\begin_inset Formula $Z$
\end_inset

 into the functor 
\begin_inset Formula $F$
\end_inset

 using 
\begin_inset Formula $Z\rightarrow F^{A}\rightarrow F^{Z\times A}$
\end_inset

 (or with 
\begin_inset Formula $F.\text{pure}$
\end_inset

)
\end_layout

\begin_layout Standard
The result is 
\begin_inset Formula $F^{Z\times B\times...\times B}\triangleq F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
For a polynomial 
\begin_inset Formula $L^{A}$
\end_inset

, do this to each monomial, then lift to 
\begin_inset Formula $F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
Note that we could apply 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 in various different orders
\end_layout

\begin_layout Standard
The traversal order is arbitrary, may be application-specific
\end_layout

\begin_layout Standard
Non-polynomial functors are not traversable (see 
\begin_inset CommandInset href
LatexCommand href
name "Bird et al., 2013"
target "http://www.cs.ox.ac.uk/jeremy.gibbons/publications/uitbaf.pdf"
literal "false"

\end_inset

)
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $L^{A}\triangleq E\rightarrow A$
\end_inset

; 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

; can't have 
\size small

\begin_inset Formula $\text{seq}:L^{F^{B}}\rightarrow F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
All polynomial functors are traversable, and usually in several ways
\end_layout

\begin_layout Standard
It is still useful to have a type class for traversable functors
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Motivation for the laws of the 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 operation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

The 
\begin_inset CommandInset href
LatexCommand href
name "law of traversals paper"
target "https://arxiv.org/pdf/1202.2919.pdf"
literal "false"

\end_inset

 by M.
\begin_inset space ~
\end_inset

Jaskelioff
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mauro Jaskelioff
\end_layout

\end_inset

 (2012) argues that 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 should 
\begin_inset Quotes eld
\end_inset

visit each element
\begin_inset Quotes erd
\end_inset

 of the container 
\begin_inset Formula $L^{A}$
\end_inset

 exactly once, and evaluate each corresponding 
\begin_inset Quotes eld
\end_inset

effect
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $F^{B}$
\end_inset

 exactly once; then they formulate the laws
\end_layout

\begin_layout Standard
To derive the laws, use the 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 intuition for 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
,
\size footnotesize

\begin_inset Formula 
\[
\text{trav}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}
\]

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
L
\size default
ook for 
\begin_inset Quotes eld
\end_inset

identity
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

composition
\begin_inset Quotes erd
\end_inset

 laws:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Identity
\begin_inset Quotes erd
\end_inset

 as 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 
\begin_inset Formula $:A\rightarrow F^{A}$
\end_inset

 must be lifted to 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 
\begin_inset Formula $:L^{A}\rightarrow F^{L^{A}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Identity
\begin_inset Quotes erd
\end_inset

 as 
\begin_inset Formula $\text{id}^{\underline{A\rightarrow A}}$
\end_inset

 with 
\begin_inset Formula $F^{A}\triangleq A$
\end_inset

 (identity functor) lifted to 
\begin_inset Formula $\text{id}^{\underline{L^{A}\rightarrow L^{A}}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Compose
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $f:A\rightarrow F^{B}$
\end_inset

 and 
\begin_inset Formula $g:B\rightarrow G^{C}$
\end_inset

 to get 
\begin_inset Formula $h:A\rightarrow F^{G^{C}}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

 are applicative; a traversal with 
\begin_inset Formula $h$
\end_inset

 maps 
\begin_inset Formula $L^{A}$
\end_inset

 to 
\begin_inset Formula $F^{G^{L^{C}}}$
\end_inset

 and must be equal to the composition of traversals with 
\begin_inset Formula $f$
\end_inset

 and then with 
\begin_inset Formula $g^{F\uparrow}$
\end_inset


\end_layout

\begin_layout Standard
Questions:
\end_layout

\begin_layout Standard
Are the laws for the 
\family typewriter
\size footnotesize
\color blue
sequence
\family default
\size default
\color inherit
 operation simpler?
\end_layout

\begin_layout Standard
Are all these laws independent?
\end_layout

\begin_layout Standard
What functors 
\begin_inset Formula $L$
\end_inset

 satisfy these laws 
\emph on
for all
\emph default
 applicative functors 
\begin_inset Formula $F$
\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Formulation of the laws for 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Identity law: For any applicative functor 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula 
\[
\text{trav}\left(\text{pure}\right)=\text{pure}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc}\ L^{A}\ar[rr]\sp(0.45){\text{pure}^{\underline{L^{A}\rightarrow F^{L^{A}}}}}\ar[rr]\sb(0.45){\text{trav}\,(\text{pure}^{\underline{A\rightarrow F^{A}}})} &  & F^{L^{A}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Second identity law: 
\begin_inset Formula $\text{trav}^{\text{Id}}(\text{id}^{A})=\text{id}^{L^{A}}$
\end_inset

 is a consequence with 
\begin_inset Formula $F=\text{Id}$
\end_inset


\end_layout

\begin_layout Standard
So, we need only one identity law
\end_layout

\begin_layout Standard
Composition law: For any 
\begin_inset Formula $f^{\underline{A\rightarrow F^{B}}}$
\end_inset

 and 
\begin_inset Formula $g^{\underline{B\rightarrow G^{C}}}$
\end_inset

, & applicative 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

,
\begin_inset Formula 
\[
\text{trav}\,f\bef\left(\text{trav}\,g\right)^{F\uparrow}=\text{trav}\,\big(f\bef g^{F\uparrow}\big)
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{L^{B}}\ar[rd]\sp(0.55){\ \ \ \ \text{fmap}_{F}\big(\text{trav}^{G}\,g\big)^{\underline{L^{B}\rightarrow G^{L^{C}}}}}\\
L^{A}\ar[ru]\sp(0.45){\text{trav}^{F}\,f^{\underline{A\rightarrow F^{B}}}}\ar[rr]\sb(0.45){\text{trav}^{F^{G}}\,h^{\underline{A\rightarrow F^{G^{C}}}}} &  & F^{G^{L^{C}}}
}
\]

\end_inset

where 
\begin_inset Formula $h^{\underline{A\rightarrow F^{G^{C}}}}\triangleq f\bef g^{F\uparrow}$
\end_inset

.
 (Note: 
\begin_inset Formula $H^{A}\triangleq F^{G^{A}}$
\end_inset

 is applicative!)
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Derivation of the laws for 
\family typewriter
\size footnotesize
\color blue
sequence
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Express 
\begin_inset Formula $\text{trav}\,f=f^{L\uparrow}\bef\text{seq}$
\end_inset

 and substitute into the laws for 
\begin_inset Formula $\text{trav}$
\end_inset

:
\end_layout

\begin_layout Standard
Identity law:
\size small
 
\begin_inset Formula $\text{trav}\left(\text{pure}\right)=\text{pure}^{L\uparrow}\bef\text{seq}=\text{pure}$
\end_inset


\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & L^{F^{A}}\ar[rd]\sp(0.45){\text{seq}}\\
L^{A}\ar[rr]\sb(0.45){\text{pure}^{L^{A}}}\ar[ru]\sp(0.45){\text{fmap}_{L}\,\text{pure}^{A}} &  & F^{L^{A}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
Naturality law: 
\begin_inset Formula $\text{seq}\bef g^{F\uparrow L\uparrow}=g^{L\uparrow F\uparrow}\bef\text{seq}$
\end_inset

 with 
\begin_inset Formula $g^{\underline{A\rightarrow B}}$
\end_inset

, mapping 
\begin_inset Formula $L^{F^{A}}\rightarrow F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
Composition law: 
\size footnotesize

\begin_inset Formula 
\begin{align*}
\text{trav}\,f\bef\left(\text{trav}\,g\right)^{F\uparrow} & =f^{L\uparrow}\bef\text{seq}\bef\left(g^{L\uparrow}\bef seq\right)^{F\uparrow}\\
 & =f^{L\uparrow}\bef\text{seq}\bef g^{L\uparrow F\uparrow}\bef\text{seq}^{F\uparrow}=f^{L\uparrow}\bef g^{F\uparrow L\uparrow}\bef\text{seq}\bef\text{seq}^{F\uparrow}\\
\text{trav}\,\big(f\bef g^{F\uparrow}\big) & =\big(f\bef g^{F\uparrow}\big)^{L\uparrow}\bef\text{seq}=f^{L\uparrow}\bef g^{F\uparrow L\uparrow}\bef\text{seq}
\end{align*}

\end_inset


\size default
Now omit the common prefix 
\begin_inset Formula $f^{...}\bef g^{...}$
\end_inset

 and obtain: 
\begin_inset Formula $\text{seq}\bef\text{seq}^{F\uparrow}=\text{seq}$
\end_inset


\size footnotesize

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{L^{G^{A}}}\ar[rd]\sp(0.6){\ (\text{seq}^{G})^{F\uparrow}}\\
L^{F^{G^{A}}}\ar[ru]\sp(0.45){\text{seq}^{F}}\ar[rr]\sb(0.45){\text{seq}^{F^{G^{?}}}} &  & F^{G^{L^{A}}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Constructions of traversable and bitraversable functors
\end_layout

\begin_layout Standard
Constructions of traversable functors:
\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq Z$
\end_inset

 (constant functor) and 
\begin_inset Formula $L^{A}\triangleq A$
\end_inset

 (identity functor)
\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq G^{A}\times H^{A}$
\end_inset

 for any traversable 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq G^{A}+H^{A}$
\end_inset

 for any traversable 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset

 (recursive) for a bitraversable bifunctor 
\begin_inset Formula $S^{A,B}$
\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L^{A}$
\end_inset

 is infinite, laws will appear to hold but 
\family typewriter
\size footnotesize
\color blue
seq
\family default
\size default
\color inherit
 will not terminate
\end_layout

\begin_layout Standard
A bifunctor 
\begin_inset Formula $S^{A,B}$
\end_inset

 is 
\series bold
bitraversable
\series default
 if 
\family typewriter
\size footnotesize
\color blue
bisequence
\family default
\size default
\color inherit
 exists such that
\begin_inset Formula 
\[
\text{biseq}:S^{F^{A},F^{B}}\rightarrow F^{S^{A,B}}
\]

\end_inset

 for any applicative functor 
\begin_inset Formula $F$
\end_inset

; the analogous laws must hold
\end_layout

\begin_layout Standard
Constructions of bitraversable bifunctors:
\end_layout

\begin_layout Standard
\begin_inset Formula $S^{A,B}\triangleq Z$
\end_inset

, 
\begin_inset Formula $S^{A,B}\triangleq A$
\end_inset

, and 
\begin_inset Formula $S^{A,B}=B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S^{A,B}\triangleq G^{A,B}\times H^{A,B}$
\end_inset

 for any bitraversable 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S^{A,B}\triangleq G^{A,B}+H^{A,B}$
\end_inset

 for any bitraversable 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Standard
All polynomial bifunctors are bitraversable
\end_layout

\begin_layout Standard
All polynomial functors, including recursive functors, are traversable
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Foldable functors: traversing with respect to a monoid
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Take 
\begin_inset Formula $F^{A}\triangleq Z$
\end_inset

 where 
\begin_inset Formula $Z$
\end_inset

 is a monoid
\end_layout

\begin_layout Standard
The 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 operation is the monoid operation 
\begin_inset Formula $\oplus$
\end_inset


\end_layout

\begin_layout Standard
The type signature of 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 becomes 
\begin_inset Formula $\left(A\rightarrow Z\right)\rightarrow L^{A}\rightarrow Z$
\end_inset


\end_layout

\begin_layout Standard
This method is called 
\family typewriter
\size footnotesize
\color blue
foldMap
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The type signature of 
\family typewriter
\size footnotesize
\color blue
seq
\family default
\size default
\color inherit
 becomes 
\begin_inset Formula $L^{Z}\rightarrow Z$
\end_inset


\end_layout

\begin_layout Standard
This is called 
\family typewriter
\size footnotesize
\color blue
mconcat
\family default
\size default
\color inherit
  combines all values in 
\begin_inset Formula $L^{Z}$
\end_inset

 with 
\begin_inset Formula $Z$
\end_inset

's 
\begin_inset Formula $\oplus$
\end_inset


\end_layout

\begin_layout Standard
It is convenient to define the 
\family typewriter
\size footnotesize
\color blue
Foldable
\family default
\size default
\color inherit
 type class
\end_layout

\begin_layout Standard
But it has no laws any more
\end_layout

\begin_layout Standard
All traversable functors are also foldable
\end_layout

\begin_layout Standard
The 
\family typewriter
\size footnotesize
\color blue
foldLeft
\family default
\size default
\color inherit
 method can be defined via 
\family typewriter
\size footnotesize
\color blue
foldMap
\family default
\size default
\color inherit
 with 
\begin_inset Formula $Z\triangleq(B\rightarrow B)$
\end_inset

:
\begin_inset Formula 
\[
\text{foldl}:\left(A\rightarrow B\rightarrow B\right)\rightarrow L^{A}\rightarrow B\rightarrow B
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Traversable contrafunctors and profunctors are not useful
\end_layout

\begin_layout Standard
Traversing profunctors with respect to functors 
\begin_inset Formula $F$
\end_inset

: effects of 
\begin_inset Formula $F$
\end_inset

 are ignored
\end_layout

\begin_layout Standard
All contrafunctors 
\begin_inset Formula $C^{A}$
\end_inset

 are traversable w.r.t.
\begin_inset space ~
\end_inset

applicative profunctors 
\begin_inset Formula $F^{A}$
\end_inset

,
\size footnotesize

\begin_inset Formula 
\[
\text{seq}:C^{F^{A}}\rightarrow F^{C^{A}}\triangleq\text{pure}^{C\downarrow}\bef\text{pure}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{C^{F^{A}}\ar[r]\sp(0.5){\text{cmap}_{C}\text{pure}_{F}^{A}}\xyScaleY{0.2pc}\xyScaleX{3pc} & C^{A}\ar[r]\sp(0.5){\text{pure}_{F}^{C^{A}}} & F^{C^{A}}}
\]

\end_inset


\end_layout

\begin_layout Standard
But not profunctors that are neither functors not contrafunctors
\end_layout

\begin_layout Standard
Counterexample: 
\begin_inset Formula $P^{A}\triangleq A\rightarrow A$
\end_inset

; need 
\begin_inset Formula $\text{seq}:\left(F^{A}\rightarrow F^{A}\right)\rightarrow F^{A\rightarrow A}$
\end_inset

; we can't get an 
\begin_inset Formula $A\rightarrow A$
\end_inset

, so the only implementation is to return 
\begin_inset Formula $\text{pure}_{F}\left(\text{id}\right)$
\end_inset

, which ignores its argument and so will fail the identity law 
\end_layout

\begin_layout Standard
Traversing profunctors 
\begin_inset Formula $L$
\end_inset

 with respect to profunctors 
\begin_inset Formula $F$
\end_inset

: effects are ignored
\end_layout

\begin_layout Standard
Counterexample 1: contrafunctor 
\begin_inset Formula $L^{A}\triangleq A\rightarrow R$
\end_inset

 and contrafunctor 
\begin_inset Formula $F^{A}\triangleq A\rightarrow S$
\end_inset

, a 
\family typewriter
\size footnotesize
\color blue
seq
\family default
\size default
\color inherit
 of type 
\begin_inset Formula $L^{F^{A}}\rightarrow F^{L^{A}}$
\end_inset

 must return ***
\end_layout

\begin_layout Standard
Counterexample 2: contrafunctor 
\begin_inset Formula $F^{A}\triangleq\left(R\rightarrow A\right)\rightarrow S$
\end_inset

 and functor 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A$
\end_inset

; 
\family typewriter
\size footnotesize
\color blue
seq
\family default
\size default
\color inherit
 must return 
\begin_inset Formula $1+\bbnum 0$
\end_inset


\end_layout

\begin_layout Standard
So, the result is trivial and probably not useful
\end_layout

\begin_layout Standard
Laws of traversables allow ignoring the effects of 
\begin_inset Formula $F$
\end_inset

 
\end_layout

\begin_layout Paragraph
Naturality with respect to applicative functor as parameter
\end_layout

\begin_layout Standard
The
\size footnotesize
 
\family typewriter
\color blue
traverse
\family default
\size default
\color inherit
 method must be 
\begin_inset Quotes eld
\end_inset

generic in the functor 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\size footnotesize

\begin_inset Formula 
\[
\text{trav}^{F,A,B}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}
\]

\end_inset


\size default
Which means: The code of 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 can only use 
\family typewriter
\size footnotesize
\color blue
pure
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 from 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Standard
A functor 
\size footnotesize

\begin_inset Formula $F^{A}$
\end_inset

 
\size default
is 
\begin_inset Quotes eld
\end_inset

generic in 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

: have 
\size footnotesize

\begin_inset Formula $\text{fmap}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Generic in 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 means mapping 
\size footnotesize

\begin_inset Formula $\left(F\rightarrow G\right)\rightarrow\text{trav}^{F}\rightarrow\text{trav}^{G}$
\end_inset


\size default
 in some way
\end_layout

\begin_layout Standard
Mathematical formulation:
\end_layout

\begin_layout Standard
For any natural transformation 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

 between applicative functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 such that 
\begin_inset Formula $F.\text{pure}$
\end_inset

 and 
\begin_inset Formula $F.\text{zip}$
\end_inset

 are mapped into 
\begin_inset Formula $G.\text{pure}$
\end_inset

 and 
\begin_inset Formula $G.\text{zip}$
\end_inset

, the result of transforming 
\begin_inset Formula $\text{trav}^{F}$
\end_inset

 is 
\begin_inset Formula $\text{trav}^{G}$
\end_inset


\end_layout

\begin_layout Standard
Such a natural transformation is a morphism of applicative functors
\end_layout

\begin_layout Standard
Category theory can describe 
\size footnotesize

\begin_inset Formula $\left(F\rightarrow G\right)\rightarrow\text{trav}^{F}\rightarrow\text{trav}^{G}$
\end_inset


\size default
 as a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Use a more general definition of category than what we had so far (morphisms
 between type constructors)
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that any traversable functor 
\begin_inset Formula $L$
\end_inset

 admits a method 
\begin_inset Formula 
\[
\text{consume}:(L^{A}\rightarrow B)\rightarrow L^{F^{A}}\rightarrow F^{B}
\]

\end_inset

for any applicative functor 
\begin_inset Formula $F$
\end_inset

.
 Show that traverse and consume are equivalent.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $\text{seq}:L^{F^{A}}\rightarrow F^{L^{A}}=\text{id}$
\end_inset

 if we choose 
\begin_inset Formula $F^{A}\triangleq A$
\end_inset

 as the identity functor.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the identity law is not satisfied by an implementation of 
\begin_inset Formula $\text{seq}:L^{F^{A}}\rightarrow F^{L^{A}}$
\end_inset

 for 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

 when 
\begin_inset Formula $\text{seq}$
\end_inset

 always returns an empty option.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $K^{A}\triangleq G^{H^{A}}$
\end_inset

 is traversable if 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are traversable.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that all the bitraversable laws hold for the bifunctor 
\begin_inset Formula $S^{A,B}\triangleq A\times B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the tree-like type defined as 
\begin_inset Formula $T^{A}\triangleq\bbnum 1+A\times T^{A}\times T^{A}$
\end_inset

, define a traversable instance.
 Verify that the laws hold, using a suitable bifunctor 
\begin_inset Formula $S^{X,Y}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a binary tree type of your choice, implement a traversable instance
 for right-to-left traversal order, and test that the tree is decorated
 with labels as 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ 4 [ 3 2 ] ] 1 ] 
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a traversable instance for a 
\begin_inset Quotes eld
\end_inset

rose tree
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $T^{A}\triangleq A+\text{List}^{T^{A}}$
\end_inset

.
 Represent 
\begin_inset Formula $T^{A}$
\end_inset

 via a suitable bifunctor 
\begin_inset Formula $S^{X,Y}$
\end_inset

 and show that 
\begin_inset Formula $S$
\end_inset

 is bitraversable (use constructions).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Is the recursive type constructor 
\begin_inset Formula $L^{A}\triangleq A+L^{\text{List}^{A}}$
\end_inset

 traversable? Explain what sort of data container it is.
\end_layout

\begin_layout Standard
The following definition is used in the next few exercises:
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-monoid-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-monoid-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any two monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, a function 
\begin_inset Formula $\phi:M\rightarrow N$
\end_inset

 is called a 
\series bold
monoid morphism
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monoid morphism
\end_layout

\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 satisfies the following two laws:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \phi(e_{M})=e_{N}\quad,\\
\text{composition law}:\quad & \phi(p\oplus_{M}q)=\phi(p)\oplus_{N}\phi(q)\quad.
\end{align*}

\end_inset

These laws mean that 
\begin_inset Formula $\phi$
\end_inset

 translates the operations of 
\begin_inset Formula $M$
\end_inset

 into the operations of 
\begin_inset Formula $N$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that for any two monoid morphisms 
\begin_inset Formula $\phi:M\rightarrow N$
\end_inset

 and 
\begin_inset Formula $\psi:N\rightarrow P$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

, and 
\begin_inset Formula $P$
\end_inset

 are monoids), the composition 
\begin_inset Formula $\phi\bef\psi:M\rightarrow P$
\end_inset

 is again a monoid morphism.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monad 
\begin_inset Formula $M$
\end_inset

 and a monoid morphism 
\begin_inset Formula $\phi^{:R\rightarrow S}$
\end_inset

 between some monoid types 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, prove that 
\begin_inset Formula $\phi^{\uparrow M}:M^{R}\rightarrow M^{S}$
\end_inset

 is also a monoid morphism.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
The empty elements of the monoids 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 (by definition) are 
\begin_inset Formula $\text{pu}_{M}(e_{R})$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{M}(e_{S})$
\end_inset

 respectively.
 The binary operations of 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are
\begin_inset Formula 
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{M^{S}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:S}\rightarrow q\triangleright(v^{:S}\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

To verify the properties of a monoid morphism, begin with the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }e_{M^{S}}:\quad & \gunderline{e_{M^{R}}}\triangleright\phi^{\uparrow M}=e_{R}\triangleright\gunderline{\text{pu}_{M}\triangleright\phi^{\uparrow M}}=\gunderline{e_{R}\triangleright\phi}\triangleright\text{pu}_{M}=e_{S}\triangleright\text{pu}_{M}=e_{M^{S}}\quad.
\end{align*}

\end_inset

Now check the composition law: for any 
\begin_inset Formula $p^{:M^{R}}$
\end_inset

 and 
\begin_inset Formula $q^{:M^{R}}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}:\quad & (p\triangleright\phi^{\uparrow M})\underset{M^{S}}{\oplus}(q\triangleright\phi^{\uparrow M})\\
 & =(p\triangleright\gunderline{\phi^{\uparrow M})\triangleright\text{flm}_{M}}\big(u\rightarrow q\triangleright\phi^{\uparrow M}\triangleright(v\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\\
\text{naturality of }\text{flm}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(\gunderline{\phi\bef(}v\rightarrow\phi(u)\oplus_{S}v))^{\uparrow M}\big)\\
\text{compute composition}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\gunderline{\phi(u)\oplus_{S}\phi(v)}))^{\uparrow M}\big)\\
\text{composition law of }\phi:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\phi(u\oplus_{R}v))^{\uparrow M}\big)\\
\text{move }\phi^{\uparrow M}\text{ outside}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi^{\uparrow M}\big)\\
\text{naturality of }\text{flm}_{M}:\quad & =\gunderline{p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)}\bef\phi^{\uparrow M}\\
 & =(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monoid type 
\begin_inset Formula $R$
\end_inset

 and a monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between some monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, prove that 
\begin_inset Formula $\phi:M^{R}\rightarrow N^{R}$
\end_inset

 is a monoid morphism between 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
The empty elements of the monoids 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 (by definition) are 
\begin_inset Formula $\text{pu}_{M}(e_{R})$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{N}(e_{R})$
\end_inset

 respectively.
 The binary operations of 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are
\begin_inset Formula 
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{N^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{N}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow N}\big)\quad.
\end{align*}

\end_inset

To verify the properties of a monoid morphism, begin with the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }e_{N^{R}}:\quad & \gunderline{e_{M^{R}}}\triangleright\phi=\gunderline{e_{R}\triangleright\text{pu}_{M}}\triangleright\phi=e_{R}\triangleright\text{pu}_{N}=e_{N^{R}}\quad.
\end{align*}

\end_inset

Now check the composition law: for any 
\begin_inset Formula $p^{:M^{R}}$
\end_inset

 and 
\begin_inset Formula $q^{:M^{R}}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi:\quad & (p\triangleright\phi)\underset{N^{R}}{\oplus}(q\triangleright\phi)=(p\triangleright\phi)\triangleright\text{flm}_{N}\big(u\rightarrow q\triangleright\gunderline{\phi\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow N}}\big)\\
\text{naturality of }\phi:\quad & =p\triangleright\gunderline{\phi\bef\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi\big)^{\uparrow N}}\bef\text{ftn}_{N}\\
\text{naturality of }\phi:\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)^{\uparrow M}\bef\gunderline{\phi\bef\phi^{\uparrow N}\bef\text{ftn}_{N}}\\
\text{composition law of }\phi:\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\gunderline{\big)^{\uparrow M}\bef\text{ftn}_{M}}\bef\phi\\
\text{definition of }\text{ftn}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\bef\phi=(p\underset{M^{R}}{\oplus}q)\triangleright\phi\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given an applicative functor 
\begin_inset Formula $M$
\end_inset

 and a monoid morphism 
\begin_inset Formula $\phi^{:R\rightarrow S}$
\end_inset

 between some monoid types 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, prove that 
\begin_inset Formula $\phi^{\uparrow M}:M^{R}\rightarrow M^{S}$
\end_inset

 is also a monoid morphism.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monoid type 
\begin_inset Formula $R$
\end_inset

 and an applicative morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between some applicative functors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, prove that 
\begin_inset Formula $\phi:M^{R}\rightarrow N^{R}$
\end_inset

 is a monoid morphism between 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this is chapter 9 of the functional programming tutorial traversable functors
 to motivate the interrupted introduction of these factors into practice
 I always remember the example that you have a list of some data items and
 you want to process it by using a function like this where you have a future
 as a as a result of this function and the usual way of doing this in Scala
 is to use a function called future dot sequence and I have seen this I
 have shown this in a previous tutorial and the idea is that you want to
 process each element of this list with this function and you have to wait
 until the entire list is done so we have many separate computations for
 each element of the list encapsulated by the future for each one of them
 you want to wait until the entire list is done and basically this is the
 type signature that you want in order to implement this computation you
 have a list of a you have a function from a to future B and you want to
 get a list of B as a result and you can get it in the future so you have
 a future of lists of it as a result and that is the type signature that
 the function future that sequence will allow you to have with some work
 but in order to understand what this kind of computation does we want to
 generalize from the future to an arbitrary type constructor F and we want
 to understand what properties these type constructors must answer so the
 list we have L and instead the future we have F and the type signature
 of the function is like this so this function is called Traverse I believe
 there's also a future of traders with a type signature like this that works
 on sequences we want to generalize to some type constructors F and L and
 that's what we will be able to do once we understand the properties of
 this operation so this operation can be implemented for instance if L is
 this type constructor then what can we do in order to implement this operation
 well clearly we have an LA and we can apply map F so f is this function
 we can apply map F and the result will be this now in other words we have
 not what we want probably wanders F lb Inc which would be this so how can
 we get F of a triple from a triple of F's or clearly we need an operation
 that's similar to zip zip would be FB times F be going to F of B times
 B now we need to apply zip twice and then we get from here to here so once
 we have the zip we will be able to implement this traverse operation that's
 the conclusion so far so it seems that F needs to be a quick ative in order
 to be able to implement this type signature for at least for this type
 constructor so for this type constructor certainly it is easy to implement
 if F is if it has a zip operation then we can implement it like this so
 that is going to be a fundamental assumption not for the traverse operation
 to make sense the type constructor F must be implicative now the type construct
or L on the other hand doesn't we don't know what that is it could be applicativ
e or not maybe we'll find out but for now let's what say L is traversable
 if it has this operation now in Scala we have a very limited version of
 this Traverse which assumes L to be a sequence so it's not based on this
 idea of being traversable as such it's just that one of the properties
 of a sequence is that you can implement this operation and we'll see why
 that is so but for me the example with lists and futures or sequences of
 futures is the easy to remember example that helps me remember the requirements
 for the traversal duration so always think that I have a list of some items
 and the processing makes me a future so L is a list F the future and then
 it is clear that I want this kind of type signature I want to have a single
 future and when that future completes I want to have the entire list of
 process data that's the easy to remember example so not not the other way
 around for example not a list of future they're not interested in having
 a list of futures I want a single future with the final list of the results
 and so that's why this example helps me remember this somewhat complicated
 type signature where I could easily make a mistake they will a to L of
 B today to have fun being LF being instead of X well being it's easy to
 mix them up but so remembering this example that I'm starting with that
 what helps me remember the time signature of triggers so the questions
 that I'm going to answer in this tutorial in this chapter are to find out
 what factors L can have this triggers operation to find out if we can simplify
 with somewhat complicated type signature can we express it perhaps through
 a simpler operation what are the laws that is reasonable to require for
 this operation and finally to look at contractors and pro fungus do they
 have also some kind of analog of this operation in previous tutorials are
 started right away with practical examples of usage in this chapter I will
 first do more theory to understand in more detail and more deeply the propertie
s of this operation that will be easier to follow the usage examples so
 to simplify traverse we notice that traverse is a kind of lifting of sorts
 it's the arguments can be permuted so these are two curried arguments so
 we can take this one was the first argument and then we have la to FLV
 yes the second argument so it's a complicated kind of twisted lifting and
 we have seen several times already that often you can find a simpler natural
 transformation that is computationally equivalent to a lifting so let's
 derive that natural transformation that is equivalent to traverse to derive
 it I asked the question so why can't we have F map to do the work of Traverse
 f map would have this type signature it Traverse sorry this is actually
 yeah so so this is the type signature investment but Traverse needs F L
 be here instead of lfb so see this F needs to be outside and that's what's
 missing so we need to transform lfb with F inside into F L being with em
 outside so that's the transformation that is a natural transformation we
 expect to be equivalent the trailer so what's called a sequence so this
 is maybe not a very good name sequence kind of suggesting that we change
 the or the order of L and F in the functor composition not a very good
 name but that's a traditional name and I don't know how else to call it
 indeed we find that the functions traversing sequence are computationally
 equivalent so this is why well we have defined sequence likeness so then
 Traverse of a function f is computed by first doing F map of F like we
 get here then we get this and then apply this sequence function that I
 abbreviated to seek which performs this lets transposition of the order
 the type diagram looks like this so we start with a type LA and we can
 do Traverse from it directly with this trap function which takes F and
 director gives you from la f OB or you can first do F map so you have a
 function f under L you get instead of la l FB and then you change the order
 so you reorder the functions composition ever be to FM and the results
 must be equal so for any value of this type you go up or horizontal and
 the result must be the same value of this type that's the definition and
 as we have seen before this pattern implies that natural transformation
 is defined as a composition of F map sub sorry and lifting is defined as
 composition of F method natural transformation and then this natural transforma
tion is equal to lift and if you take identity instead of F obviously and
 so then that's a pattern we've seen time and again where the result is
 that traversing sequence are computational global you can derive one from
 the other and back and it gets the same function back so I'm going to spend
 time through again since it's exactly the same proof as we had many times
 just a different type signature and notice also F here is an arbitrary
 placated factor so these functions don't use the structure of f other than
 that it is applicative so that's that's an example we have seen just just
 before we implemented a traverse function for this type constructor by
 applying the zip function of F otherwise we don't you know what F is we
 just use zip from it and so we are generic in the function in the functor
 F as long as it's implicit if we don't look at the structure of F we do
 look at the structure of L so the Traverse function depends on the structure
 of L but it doesn't depend on the structure of F it's generic images future
 that sequence has this type signature and that's an example of a sequence
 natural transformation you note we cannot have the opposite transformation
 I'll show the example for that but well for future analyst you could make
 an opposite transformation for a future of a list and you produce a list
 or individual futures that are going to be all already copies of this future
 mapped to select one copy of the lid and of the element you can do that
 it's kind of useless to transform in the opposite way but what I will show
 on examples is that it's impossible to have this transformation in general
 and arbitrary it's possible for future not for arbitrary yeah so examples
 of traversable function functors this example we have already seen list
 is another example sequence in general and also finite trees various shapes
 there and also traversable an example of an entre versatile factor is there
 either Malad and also the lazy list or infinite product or stream is sometimes
 called lazy string so let's see why that is so let's implement the sequence
 for this type constructor first so I'm going to define this file constructor
 for convenience and the seek function is I'm just going to define directly
 it's going to have this type signature and that's just a zip apply it twice
 and then some reordering Oh nested tuple that results from the zip and
 we know this is associative because we assume that F is applicative now
 I'm using my own typeclass for F which I call the zip for applicative but
 you can also use cats applicative just has a slightly different name for
 things and it doesn't have the zip syntax so I like the use of zip syntax
 so I'm using my own type process here but it's equal to standard implicit
 if that was so the sequence function has this type signature just as we
 have seen in the case or filter balls lowlands and applicatives it's much
 easier to reason about this natural transformation rather than the reason
 about the lifting it's also will be the case of laws or in simpler to formulate
 so that's why I will always always define just a sequence function I will
 not define a traverse function the Traverse is easily defined in terms
 of a sequence - and I'm therefore in this tutorial concentrating entirely
 on the sequence function I'll never implement Traverse directly to save
 time so let's have another example that either as a functor either Z where
 Z is a constant type then the sequence must have this type signature so
 it takes an either of Z FFA and puts F outside so it's pulls the function
 f from the inside of our plan into the outside that's the time signature
 of sequence so how do we implement that all we need to match so if it's
 the left we have a Z to produce F of Z so the only way to do that is to
 use the pure method okay I mean interchange there were there blinds here
 the left z does not have any FFA and so in order to produce an F of something
 we have to use the pure method from F and then we apply that to the left
 of Z and then we get the right type if we have a right of FA then all we
 need to do is to put the right inside the width so we just map that we
 don't change the value of a we just wrap it to wrap it into the right type
 construction so that's the very clearly simple implementation so if we
 actually write this type signature using a shortcut notation then maybe
 it's even easier to understand how the sequence function works so if we
 have a Z then we just put Z inside F using the pure if you cover away then
 we just put a 0 plus a into that by mapping with the right type constructor
 so that we don't change this value hey let's see how to implement the sequence
 method for the Fortran type so here's a simple binary tree it has a value
 of type a and belief and it has a branch of two trees so how the hell does
 sequence work on a tree like we're in the leaf where we just wrap in the
 leaf like we did with this either and if we're in the branch then we apply
 the sequence method which is the same sequence we're defining is a recursive
 function them so we recursively apply the same since and as a sequence
 method to the left and to the right branches of the tree and then we zip
 them together so then zip is the operation in the F function wickety function
 so we can use that zip them together we get an F of a pair two trees and
 then we wrap that fear is a branch under the map so this map is under the
 tree sorry under the F function so f is an arbitrary negative function
 and we're using its methods map and zip here we used its metal period but
 other than that we did not use any knowledge of F so it is in this way
 that we are generic in the factor f we are not using any knowledge about
 the structure of f other than it has that it has a map and zip and puree
 method let us see examples of non traversable functors so here's an example
 it's a reader mode with a parameter in its non polynomial and so it will
 turn now that this is not reversible so let's see why what's takes on applicati
ve function f specifically like option a and let's find all implementations
 of this type signature which is the pipe signature of sequence now all
 implementations turn out to be just one and this implementation always
 returns none so it always returns an empty option ignoring its argument
 so it is not a very interesting implementation and we will see shortly
 that this would not satisfy was overprotective of over a traversable contest
 so this is this satisfies the pipe signature but it does not satisfy the
 walls we haven't yet seen the laws but it is reasonable to say that this
 function completely ignores its argument so it loses information and typical
 walls for a lifting would be identity and Composition laws identity law
 would tell you that some lifting is identity but if it's losing information
 it cannot be identity so it cannot preserve the data that you give it but
 if people lose it will always return empty option and so that's reasonable
 to expect when this note is not a good implementation and so there are
 no good implementations - thank you let's take another example and you'll
 see there's there's one implementation for this so we can actually implement
 this type signature for this duplicative functor this this code is what
 you would expect it's taking this function so what translate entire signature
 let's just e to the pair and this is pair of eternity doing now if you
 have a eat to the pair and you can produce a pair of Italy in d2 a that's
 very easy just duplicate your your function so we do have implementations
 from this book we're supposed to produce an implementation of sequence
 as a generic in the function so we cannot look at the structure from the
 functor F and have a different implementation for every effort want to
 be generic and so because we can we cannot implement it for some F we're
 stuck in this is not going to prevent reversible functor let's take another
 example where we have a pair so the pair of some type and a polynomial
 function and let's take this as the implicated and again we find them there
 is an implementation so that's fine well this is actually traversable what's
 considered the infinite list so the infinite list class needs to be defined
 because we cannot have the cursive type as a type an alien's we have to
 have a class and it's a pair of value of type a underlays evaluated tail
 choosing again an infinite list of time from all values of tightly so let's
 define a sequence method well we can actually define it it's quite easy
 you you take the head of the list you zip it with the recursive implication
 of the same function sequence to the tail from the list which will sequence
 were found commute the order of factories and then you wrap it into the
 infinite list again so that's similar to what our implementation for the
 sequence operation on a tuple except that it's recursive and it turns out
 this is infinite recursion let's check that the even the simplest functor
 have the identity function let's define it like this put some type of class
 instances for identity function ages tribunal was defined let's define
 an example value of an infinite list which is if you find like this it's
 a recursive definition we could do a lazy Val instead of def I believe
 but it's just cleaning doing them since it's a recursive function and you
 see the tail of the list will turn again the same list so it's going to
 be an infinite list of 123 on the whole the way to infinity so if we use
 sequence on this value then we get a stack overflow interaction because
 it's an infinite recursion so it's it's an infinite loop there's no way
 to implement the Traverse of an infinite list because basically what you
 would mean is we need to sequence like this we need to have a list of F
 values so it's an infinite list of an infinite list about four days and
 that should be mapped into an f of infinite list of is now how can we do
 that we need to pull F outside to the outside of the title which means
 that we need to evaluate infinitely many of these f's in order to pull
 off outside mean generically that's what we need to do we need to evaluate
 infinitely many elements of this infinite list in order to put F outside
 it's impossible to just pull F outside magically out of the infinitely
 many elements here and so even when F is just an identity factor s won't
 work it's impossible to pull f outside I mean it would be possible for
 identity factor of course but we have to be generic in the factor f we
 cannot use any methods on F other than zip and map and so we don't know
 what F is f could be something that needs to be evaluated in order to pull
 a out of it and so because of that it forces us to evaluate infinitely
 many elements before we even get a single value of this type and so that
 will never end and so that's impossible so for this reason an infinite
 list is not reversible and finally I mentioned that the opposite type signature
 isn't is unworkable so why let's make an example calculation so let's say
 L is an easier which we know is reversible F is this reader unit which
 we know is applicative so let's find all implementations of this time signature
 and we find they're not there is no implementation of this type signature
 the reason is that this type signature would have to map this function
 into this data but that is impossible you cannot extract Z out of this
 so you could not possibly return the Z because you need an integer so which
 integer are going to give imagine that this integer is a different data
 type you don't you don't have values of it necessarily for integer you
 could put 0 in that integer sure but that would not be reasonable from
 other types so you cannot possibly pull Z out of this because there aren't
 any special values of this type and you can also not get this function
 because you only have this function and this function could sometimes fail
 to return an 8 could sometimes return a Z so for some integers it could
 return is e and you don't know in advance for which integers it will return
 Z and for which it will return in a until you run this function on every
 possible integer you won't know that and so that's impossible to know and
 so you can't split this into a Z and into it you couldn't either split
 it into two functions into Z and into in the same for the same reason you
 in order to split it you'd have to run this function on every possible
 integer and see what the results are so that's unworkable and so that's
 why you don't have that's that's an informal reason why you don't have
 any implementations of this type and a final comment is that there are
 several ways of implementing the sequence usually so let's consider this
 type again we have seen we can implement a sequence by applying zip to
 x and here's another implementation we can arbitrarily select a different
 order so we instead of zipping one two three with zip to one I'm sorry
 this is a mistake two three say 1 and that's valid so the type is right
 and the laws will hold as well we'll see why so that shows you that there's
 more than one way of implementing the Traverse or in the sequence function
 which is equivalent for a given type constructor L different valid ways
 of doing it so let's find out if other polynomial factors are traversable
 now one of the central results here is that all polynomial functions are
 reversible we will show this quite rigorously later so for now let's see
 how we can implement the Traverse or the sequence function for an arbitrary
 polynomial function so we have done it so far for this and we have also
 done it for either which is a simple polynomial factor and the general
 polynomial factor would have this form it's got a polynomial in a with
 some constant coefficients which I here denoted as Z Y Q P so we have seen
 how to implement for a monomial so let's first consider monomial like this
 so one part of this polynomial then we can apply zip to these so first
 we look at lfb so RV has this type so we can apply zip to these we get
 this and then we can lift the Z into the functor F by just this standard
 factor map this function is always possible for any factor f alternatively
 we can do F pure of this Z and then this will become FZ and then we can
 zip it together with all others but the result will be exactly the same
 as using this function because of the law of identity for applicatives
 so the result is going to be this and then that's a sequence method for
 a single monomial and then for each normal you do this and you have a disjuncti
on of different results of type F of a monomial and then we lift it to F
 of the disjunction like we did in the either implementation so we we have
 seen therefore that we can perform the traversal equivalently the sequence
 operation on monomials and we can also perform them on disjunctions and
 therefore we can perform them on arbitrary disjunctions on monomials and
 that's arbitrary polynomial factor also note we could apply zip here in
 different orders wicked first zipless and then Z put Z on the right we
 can change orders in different ways and so traversal order could be application
-specific it could be necessary to adjust it for a certain application you
 can always implement in some order or automatically say but it might not
 be necessarily correct for your application and also we have seen that
 non polynomial factors at least some of them are not to her so so this
 is not reversible because we cannot have a reasonable implementation of
 this that does not lose information and there's this paper that I'm referencing
 here it's a complicated paper there in theoretical but it has a proof that
 only polynomial functions are reversible that that and and also they must
 be finite so infinite lists do not fit the conditions of their theorem
 only finite containers polynomial factors are essentially containers with
 data they can have different shape they can have many items of data or
 few or none it could be a disjunction of different shapes and they also
 can have extra data of some constant type in addition to data of the type
 a but those are the containers that are traversable and no other containers
 aren't reversible sorry you have a lazy infinite stream that's not reversible
 they have to be finite and they have to be polynomial so that is proved
 in this paper in a complicated way so I'm not going to try to understand
 how they did it I believe that this is so because I have examples that
 even the simplest non polynomial factor can't have reasonable implementation
 of sequence so even though all polynomial functions are traversable they
 are usually traversable in several different ways and so it's useful to
 have a typeclass to declare a specific instance of a typeclass expressing
 a specific order of traversal so this order of zipping that we can choose
 here corresponds to ordering of traversal in a sense we'll see that when
 we look at specific examples of traversing but now let's take a look at
 the laws because we have have been talking about the laws so far and we
 need to see more in more detail how they work so I prefer to look at this
 type signature of Traverse and to derive laws using the lifting intuition
 so it's a lifting of sorts and every time we had lifting so far we had
 laws of identity and Composition in other words there was some kind of
 identity here and some kind of composition of these and this has to translate
 into identity here and composition of these I will mention that there is
 this paper which is arguing what laws traversals must have from a different
 perspective not as formally as I have argued just now because my argument
 is completely formal Traverse looks like a lifting therefore it should
 have laws like the laws we had before for other liftings it's purely a
 formal argument saying that the form of this function is similar therefore
 it should have similar laws but this argument doesn't look at what Traverse
 actually does well what it does is that it evaluates some function on each
 element this one produces some effect maybe this F is an applicative factor
 which could be a monad or it could be known more and what it encapsulate
 some kind of effect some kind of computational context or a result other
 than B and all these contexts need to be somehow put together and be outside
 of the elbe so we need to reconstruct our container L inside the larger
 effect described by F so we need to somehow combine all these effects for
 individual values of a into one big effect which will be outside and then
 we have to combine all the values of B after somehow pull them out combine
 them again into the same shape as the container L inside the F so all that
 needs to be done by the traversal function and the authors of that paper
 argued that the traversal first of all should visit each element of the
 container exactly once it it should evaluate each effect exactly once and
 then combine these effects into a larger effect and using this intuition
 they formulate some laws that seem to fit this description in some way
 well they didn't actually derive these laws from these requirements but
 they showed examples where these requirements are violated and they showed
 that these examples also violate the laws so this is a little not very
 convincing to me that these laws are correct and therefore I prefer the
 more formal approach because I have more assurance but if I find some reasonabl
e identity and Composition laws that's a correct set of laws so far in every
 example we have seen with functors with contra factors filterable applicative
 and wounded every single example had a function with type signature like
 this which was life like a lifting in my terminology and in every single
 example there were identity law and composition law and these laws were
 equivalent to all the other set of laws that were derived from intuition
 and these laws also corresponded to some category laws now in this example
 I don't know how to formulate this in terms of a category and everything
 a way that would be simple enough so I'm satisfied that I find a law that
 looks like identity law and the law that looks like a composition law even
 though I'm not satisfied that I can find it easy enough category to reason
 about so that it's useful so I'm not going to talk about the category in
 this chapter I'm not going to describe this as a lifting from one category
 to another because I don't know if that's really very useful and I don't
 know a good formulation of that so let's look for these laws so identity
 law is that we map some special function here that is identity in some
 sense into a function here that plays the role of identity now the type
 signatures are not a to a they are a to f of B so what could be playing
 the role of identity here well the pure method obviously and F has that
 method by an assumption so the identity law is that if we put a pure method
 here than it should be lifted to this which is again a pyramid and except
 it's applied to a different type of parameter now another way of formulating
 identity is to say that if F is the identity function so then there's no
 F you just be then identity function here is all ordinary a to a and that
 should be lifted to identity elite really so f is just identity function
 and then this identity should be lifted to this so that is another way
 of formulating an identity law let's find out now to compose what will
 be the composition if we have two of these functions like f and G then
 we can compose them using F map but the result would be this because the
 F G would be nested now we take F be we map G over it and we get F of G
 of C now if F and G are in clique are applicative then the composition
 F of G is also applicative we know that from the properties of the platitudes
 and so it is again a function of the same type except that it has a different
 factor instead of F so f function G factor and the composition of such
 functions is going to be of this kind which which is kind of complicated
 it changes the functor each time so what should be on the right-hand side
 what should be a composition of these traversals now the composition of
 traversals obviously works in the same way so you have la 2 FL b and then
 FL b 2 f g LC and so that is your final traversal and that should be equal
 to applying the traversal right away with this function as a purgative
 factor so in other words applying traversal to this if that is true then
 traversal of composition is equal to composition of traversals so that's
 with a little twisting where we keep using F map in order to get composition
 and keep pulling all the functors F and G all the implicit is we keep pulling
 them outside with these twists it looks like just a composition law traversal
 of composition of F and G with some twisting is equal to the composition
 of the two traversals with F and with G again with some twisting so these
 are the laws we're going to examine and it will turn out these are exactly
 the same laws as this paper proposes when I first looked at this it looks
 like we have two identity laws are they really independent no they are
 it will see that but that's a question we need to answer also laws for
 sequence are probably going to be simpler because in our experience so
 far always we found that the laws became simpler if we consider the natural
 transformation instead of a lifting so let's find those laws for the sequence
 and finally with the laws in in hand we can try to answer the question
 of which functors satisfy these laws we have found examples where we can
 implement the type signatures but are the law is respected by those examples
 or not so that's the questions that we have after this point so let's look
 at the first item the dual so a traverse of pure needs to be Pierce and
 how fast if it's the first law let's look at the type diagram for this
 so we started from away we map it with pure where we map it with traverse
 of pure and it should be the same value it was type in favilla so that's
 the first one now the second identity law looks like this and it's clearly
 a consequence of the first identity law if we just put F to be the identity
 founder and the first law should hold for every applicative functors so
 we really just need this one law when the second one is a consequence so
 let's forget it so we have the identity law which is this and we have the
 composition law which we can write like this and the short notation so
 for any function of this type and the function G of this type and for any
 applicative factors F and G we have so the composition of F and G is twisted
 in the sense that G must be lifted by factor F so this is our twist on
 the composition other than that composition of two traversals is equal
 to Traverse of composition here will we twist and here we twist let's look
 at the type diagram we start again with LA first with Traverse with function
 f and we get F lb well then we want to traverse with G but G works on B
 so we have to we have to traverse just on this lb and F needs to stay outside
 therefore we use F map of F and we Traverse inside of F using the Traverse
 of G which is giving us this value F G LC or we could directly Traverse
 on the function H with respect to the factor f of G which is a functor
 composition so the factor H could be defined like this as a functor composition
 of F and G and we know it's applicative so we could just directly Traverse
 with respect to H so this can be traversal with respective H of a function
 H of this type this function is defined like that so this is the law that
 we demand now which will hold let's derive the corresponding law for laws
 for its sequence to do that we just Express Traverse like this your sequence
 and substitute that into the laws of chillers so let's look at identity
 law Traverse of pure equals P R so Traverse of pure equals this conduction
 legal pure so that's the law of identity for pure so pure lifted to Bill
 and then sequence should be the same as pure applied to the type parameter
 Helle I should also mention naturality law that's always the case for all
 of our examples so far such as filterable moon and imitative but all these
 natural transformations as well as the liftings they have natural tea laws
 for each type parameter that they have there's one neutrality law which
 expresses the fact that the code implementing that function does not use
 any information about the type it's completely generic in that type and
 so you can map this type to another type before the transformation or after
 the transformation and the results are going to be the same so here's what
 the naturality law looks like for the sequence now sequence has a more
 complicated type signature and its type parameter a is all the way inside
 therefore in order to transform in this a to some B we need to have a double
 F map so let's say there's some function G that transforms a to be in order
 to transform this a or transform that a we need to lift this G twice and
 that's how I would write it down so first we can sequence this LF a to
 FL a and then we can lift G twice in this order or we can first lift G
 twice in this order so that instead of LF a we get LF B and then we sequence
 on that so that should be the same function that's a natural t law and
 the code for sequence will automatically respect that law if it is a code
 that is generic type parameter a will never use any information about the
 type of a so usually naturality laws are satisfied automatically by generic
 code and so it's not important to check them but it's important to check
 the other laws so now let's look at the composition law we need a bit more
 work about it traversal of F followed by the traversal of G lifted so let's
 substitute the definition of traversal and then we get this formula now
 we can decompose a lifting of composition going to factor law so we can
 get like this now naturality law means we can interchange this and we get
 that and finally the right hand side is written like that so again we can
 do that because of the thumb tree law so in other words the composition
 law for traverse says that this is equal to this they have a common prefix
 that we can omit because these are arbitrary functions F and G for which
 this must hold and so it's sufficient that these things are equal so that's
 the law for sequence much simpler and here's the type diagram because the
 type types here are actually complicated so we start with an L of F G C
 C is some type parameter I could use a here but I just can't see now first
 we sequence with with respect to F and then we just pull F out and we get
 F LGC then we sequence with respect to G but we lift it to be operating
 inside of F so that means we interchange this L and this G the result is
 f G LLC alternatively we could sequence with respect to the factor f of
 G this is maybe not a very nice known notation not very consistent but
 this is the composition of functions F and G so it's the page I mentioned
 here I should probably for clarity I should use page instead of F G and
 so if we sequence with respect to F G that means we pull out F G at the
 same time to the outside and we get F G of LC so the result of these two
 computations must be the same having formulated the laws now can look at
 constructions and we can check that the laws hold we can also check whether
 some factors can be traversable when they are polynomial or when they recursive
 or they're not polynomial so we have so far seen some examples but now
 let's be more systematic about it here are the constructions that I found
 for traversable factors and I will go through each of them one by one now
 now before I do that let me explain what is a by traversable and by functor
 so by factor is a type constructor with two type parameters which is a
 functor in both of them so it has a map with respect to each of them separately
 and it also has a map with respect to both of them at once of course because
 you can just you can transform a to some C and B to some D separately or
 at the same time if you wish it doesn't doesn't it so that's a bi functor
 and by factors are by traversable in the following sense they have this
 natural transformation where we have an F wrapping each of the type parameters
 of s and this F can be pulled out by this sequence by sequence natural
 transformation and it should be natural both an A and B separately so that's
 the assumption and so you see this a and B remains and we have pulled F
 out to the outside so if statute transformation exists which is natural
 in both a and B and it has the same laws the laws of identity and the laws
 of composition now the law of identity is this and it needs to be adapted
 obviously to this by seek so that you have pure here and pure here and
 the law of composition obviously needs to be adapted as well because we
 have F G a F G B and so on but other than that it's a direct generalization
 so analogous laws must hold so let me now begin by deriving the laws that
 must hold for these constructions rather deriving the fact that the laws
 hold for these constructions first construction is constant functor and
 identity factor so both of them are traversable till you find that we need
 to define the sequence method and to show that the laws hold for it that's
 very simple so for convenience I'm just going to put a type parameter up
 front the constant factor is a function that doesn't end on its type parameter
 so L of F of a is the same as I've elevated Simon is this constant times
 e and FMLA is f of Z so sequence is this type signature and clearly this
 is f dot P R is just a pure of F functor can't in any other way produce
 a type signature like this but is generic in if we're not allowed to know
 what F is except that it has a pyramid zip and map so let's just define
 that as a pure let's check Louis so the identity law is that F map of pure
 followed by sequence must be equal to F dot P R now I'm putting here this
 underscore ell notation for clarity I could have said for example instead
 of F dot P R I could have said pure underscore F what I mean by this is
 that it's the method that is defined for the type instructor F such this
 method is not generic and F it is defined for each F separately in the
 typeclass instance similarly F map is not generic and L it's defined for
 each L separately so I could I could have written like this as well it's
 not Scala notation necessarily but it will do for now just for clarity
 to remind myself where these methods come from now sequence is defined
 for L so here I could write it like this to remind myself that the sequence
 is defined separately for each ill but it is generic and F so I could write
 it like that so sequence has F as a type parameter but L as type constructor
 or or functor for which it is defined in the Thai class now so let's see
 if we can verify this law F map is identity for the constant factor so
 this is identity and so this is just F here sequence is sorry F map of
 F of F here is identity function f map does not transform anything because
 there is nothing to transform we only have this Z cannot transform so this
 is just at the energy function you can cross it out and then we have the
 law that sequence equals pure at sequence equals pure by definition so
 the law is satisfied let's consider now the composition law which is the
 composition of sequence of F and the lifted sequence of G so now I'm using
 this notation with more sense in here I didn't have to say it's sequence
 Hamilton if I could just say sequence but here it is important now to say
 which for which type parameter is because the factor is a type parameter
 in sequence function so we have the sequence applied with respect to applicativ
e factor f and this with respect to G and F G is the factor which is the
 composition of F and G we just [Music] denote it like that for gravity
 so this is now sequence is defined as pure F map is [Music] defined in
 with respect to F so this is f naught F naught F naught L F map l was identity
 but F map F is not and we actually don't know what it does because it f
 is an arbitrary let's look at your family so you need to keep it symbolic
 so we have f dot P R which is this sequence and then because the Scala
 operation and then responds to my composition symbol and then we have F
 map F of G period because this is that the pure in G and that will be equal
 to FG pure but actually what is the definition of pure for composition
 of functions that's exactly this it's a pure of F followed by lifted pyrimidine
 so it's the definition of what pure use for the function f G and so therefore
 the law holds you now consider the identity function you know the identity
 function is like this or sometimes can it can be denoted by it with a capital
 I so this is identity factor I believe the cat's library does this maybe
 not maybe Scalzi so how do we define a sequence for it well this is just
 an identity function because it doesn't do anything because we we have
 f of a it goes to F of a because it is just wrapping it doesn't do anything
 so this is identity function we could even write this sequence function
 differently like this in order to underscore that factor that's just identity
 function now let's check the laws the identity law which is this now if
 F map is the identity function sequences identity function f map L is just
 this F map L is the identity function of its argument and because of this
 identity function and so this is equal to f dot P so this is f dot pure
 followed by identity and that should be equal to F dot penis clearly so
 composition is that we have a sequence followed by F map of sequence now
 sequence of anything is identity so it's just composing one identity and
 F map of another identity but we know that lifting F map of identity is
 again identity so this is just about composing one identity or another
 that's always going to be identity so that is also identity by definition
 and so this law holds let's move on to the next construction which is the
 product for any traversable factors G and H their product is reversible
 now I'm going to introduce my own typeclass which reversible just for convenien
ce but actually the cat's library has a traverse that class but I just want
 to show that this is easy and I prefer to define seek and they prefer to
 define Traverse in their tag class so that's why I have my own tie plus
 but basically this is very simple that concept has just one method and
 this method is Elif a to FLI traversal defined that method now this red
 is a problem with IntelliJ and install a plug-in cannot resolve the types
 it compares this entire code comparison works also we have a convenience
 method to get the Traverse into instance this drove in the syntax to use
 seek as a as a method rather than user so let me then show how I can define
 an instance of track of travel this traversable type was for this type
 constructor which is a product of l1 and l2 given that both l1 and l2 are
 traversable factors so first time to mend the functor instance well that
 is standard it's just a map this map that just a functor instance for product
 and then i implement the traverse instance using C so what am I supposed
 to do I have this a1 F a times l2 FA and I need to give F of L 1 a times
 Delta a so first I can say please so sorry first I can sequence each of
 these separately because l1 is reversible and all to escape most of my
 assumptions for a sequence separately both of them then I can zip the results
 and I get what I need so that's my idea about how to implement so I just
 say sequence the first one sequence the second one and zip now I could
 also write the code like this but then my IntelliJ doesn't understand where
 these things are coming from but the code actually still compiles if I
 do that so this is just much more your boss telling me where the sequence
 comes from from which factor and in principle I expect a scholar to be
 able to derive this automatically and it can this is much simpler to write
 about intelligent isn't like it so let's check the laws here so there is
 the identity law which is that we can map the pure and apply seek and that's
 the same as the pure so how do we verify this law well we substitute the
 code of F naught which is up here and we apply both sides of this law to
 some arbitrary value of this type and one until two so we do that looking
 at the laws actually we have to start from LA and the law will give me
 this so the value on which I apply both sides of the law must be of type
 le so that's why as eleiza is a pair of L 1 and L 2 and then that's why
 I take some arbitrary pair and i apply the law to it so the left-hand side
 first i apply this and that's going to be that there's a half map this
 is L 1 this is no true and then we apply the seek function to this now
 the code of seek is I'm going to write it like this in a shorter form and
 the result will be that I have this seek zip this so now we need to assume
 obviously that the law already holds for a 1 and L 2 separately and therefore
 for example we have this which is the formulation of the law for L 1 and
 so we can substitute that in here and then we get that now because of the
 identity law of applicative zipping of two peers is a pure of the peer
 so this equals F pure of the peer and that's exactly the same as applying
 F pure which is on the right hand side directly to the pier so we have
 verified the identity law let's verify the composition law this is how
 we could write it I have written out sequence seek of L seek of the hell
 everywhere it's just for clarity so in my notation that means a sequence
 made up defined for the tag constructor L applied with respect to the type
 parameter F so now let's apply again both sides of this law to some suitable
 value let's see what type that value should have which you have the type
 L F G C as the initial point in the time diagram so let's have an arbitrary
 value of type L F G C so sort of C values a here so L F GA naar betray
 value of that is a pair of l1 f g l2 f g and applying the code for seek
 to this we get a 1 FG a sikh with respect to f zip f l2 mg is equal respective
 so that applying just the first step according to the type diagram that
 would lead us in here which is f of LG F of L 1 G 2 G so now we apply F
 naught F of this to that now what is f naught F of CBG know seeing G is
 with respect to L sorry with respect to G over L so it acts on some value
 of this type and it will give this according to the definition but we need
 to lift this function was F naught s the difficulty here is that f is an
 arbitrary function we don't know what ethnic F does we don't have code
 for it we need to keep it symbolic so clearly we need to use a definition
 of zip F G somehow to find out what F naught F will do so the definition
 of zip of F G is this there's some FG x and f gy with zip them in the factor
 F G so so have G X is a type F of G of X G Y is of type F of G the definition
 of the zip for the composition is one of the constructions for applicative
 it's it's a zip in the F factor followed by F map F of zip in the G factor
 is this what we have in our formula not quite because we have not just
 something zip F something after which we we do F method but we have these
 things transformed we seek so let's transform using some function so let's
 use a natural G of zip so that we can transform like this so we transform
 under the factor f and so the result is the same as if we transformed FG
 x and f gy and then zip so that's a natural T you can transform first and
 then zip or you can first zip and then transform that's up to up to us
 so finally if we use this formula we can see that F map f of seek L of
 G is like this it's the F map F of this so this is seek L of genii because
 seek L of G gives us this kind of expression which is similar to this P
 of GX being sequence of this zip G and Q of G Y is sequence of this and
 then we apply this to those things and so the result is that F map of seek
 L applied to that is it's like that it's sick F map sick G and then seek
 F maps engine so that's what we find this really apply natural TMZ so that's
 the left hand side of the composition and the right hand side is that so
 these must be equal now the definition of seek F G is the code of seek
 that is just applied to this type parameter F G instead of that F so the
 same code and it would have been the same code if we could have this equal
 to that now these are six with respect to factor l1 so these are defined
 for l1 and these are defined for how to now we assume that for l1 l2 the
 composition law already holds so that means for example this so this is
 the composition law for a 1 and similarly for L 2 so therefore this is
 the same as this and that is the same as now and so the composition law
 holds for hell the third construction is disjunction so for any traversable
 factors G and H the disjunction is again a traversable factor so we have
 seen an example of implementing this in either and in polynomial factors
 but this is a general construction so let's see how to again we assume
 that factors l1 and l2 reversible and we defined well as the disjunction
 of l1 and l2 a standard factor instance but is Junction so now let's implement
 the founder instance traversable instance for the disjunction so here's
 how it will work we have this so we apply sequence to each of these separately
 we get this disjunction and finally we depending on which one we have we
 lift it into the F of disjunction using just constructors of the disjunction
 that left or right so that's how it works first we do a sequence on each
 of them so if we are on the left and we sequence it again this and then
 we map it with left apply which means that we put a left on top of this
 and left it's just a wrapper in a disjunction so it doesn't change the
 value and the same we do for the right now the redness here is again due
 to limitations of IntelliJ it's unlabeled transferred types directly but
 this code runs it compiles and runs let's check the laws at the entity
 law we do the same thing as before we just substitute the code of the flap
 in here and then we apply to some LA we'll know that both sides of the
 identity law applied to an arbitrary element of this type now since the
 code is symmetric with respect 1 or L 2 it's sufficient to apply this to
 some left of l1e and check the law for that so if we apply it to the left
 and we are in this case we have any left applied to to this which is well
 we are actually in this case and we're looking at F Nobel first so we are
 you want to lift like this now you notice we can't really simplify this
 because these are map and pyramids of factors that we don't know these
 are a one factor and if I look at your factor so we don't really know what
 these methods do we cannot substitute any more code so that's our symbolic
 computation right now we apply sync to this now we're on the left so we
 apply seek to to this which is I'm going to denote that a seek l1 to that
 and [Music] followed by map of left block now nothing more to simplify
 unless we use the fact that l1 already has this law and so this law for
 l1 looks like this therefore we can simplify here substitute that we get
 F P were of l1 a map left apply which by naturally T appear and we have
 pure of left over one a and that's exactly what the right hand side will
 do when applied to left of l1 e so identity law holds let's consider the
 composition law the composition law needs to be applied to a value of this
 type and again it's sufficient to consider the left and applied to that
 so first we apply the seek and that gives us in this now we apply f map
 F to belt and we notice we have F map F which is this one and another if
 map F so we can combine them and the result is that we have this two which
 we apply map with respect to F of this kind of function so we first do
 we left apply to that and then we further apply this function so now this
 is not quite Scala code because I have this map underscore F for convenience
 and clarity so that's just keep in mind I'm not actually using your Scala
 code here but I could adjust that the types will be less clear so now what
 does this do now this c g you know seek g has to act on the left and we
 need to substitute the code of seek when acting on the left it gives us
 this expression my definition of our seek up here so let's substitute into
 this and we get then this expression so now we can use the composition
 law that by assumption already holds forever so then we have this one Perelman
 which we can rewrite like this now this law is not quite giving us the
 expression that we want which is this expression because we have this function
 here but here we have another map so we're not we have another left apply
 to map and also on the right hand side of the law would have another left
 apply so in order to put another map inside the seek we use a net reality
 of seek we add this on the right-hand side which gives us this seek so
 seekers natural so we can apply seek to a transformed argument or we can
 apply transformation to the result of seek and so then if we define what
 lab FG is that is f map of F map and we put that onto the left-hand summit
 so that we have CK one of this map F of this map F both of that you know
 we can combine the map F this one with this one and now we have a single
 map F with a bigger function but that's exactly what we had for the left
 hand side and kill him before and so therefore the right hand side response
 is equal to the left hand side his code so the code is equal and the same
 would be if we replaced a woman so this shows what laws hold for injunction
 now let's consider there is construction for which is a recursive function
 defined as la equals some s of a and la so as s is an arbitrary by functor
 so this could be any type function of two type parameters and this equation
 this is a type equation it defines a type la recursively so examples of
 this are lists and trees different factors s can encode very easily different
 kinds of wastes and trees now this also describes infinite lists and infinite
 data structures and we have seen an example where the infinite data structure
 does not actually work you can implement the function without the recursive
 calls never stopped so that's the problem the laws will appear to hold
 in our proof but actually it will not work in practice so I will comment
 on this when I use the recursive assumption in the proof so let's see how
 it works so I introduced the biofilter as a type parameter up front so
 that I don't worry about it so much it's easier in Scala to do this now
 I cannot just introduce a type like I did here because reclusive type illnesses
 are not allowed in school so I need to introduce your class so once that
 actually makes the code a little clunkier because now and you need a name
 for the data value inside and I need to wrap and unwrap but that's a small
 inconvenience so the class contains a value of type s of a end of the same
 11 so this is a type function that I'm considering as a parameter and now
 I can implement a factor instance for this now this obviously is going
 to be recursive so in order to map this l 8lb i map a to be here and I
 need to map this la to L be recursively by using the same map so I need
 to do this under yes so I need to map at the same time a to b and le to
 l be under the type constructor s so that's by map so I'm mapping the two
 type parameters of s at the same time and then my map is a method that
 takes two functions with two type parameters so it goes a to C and in this
 case we have the by factor with type parameters a and L of a and so it
 takes two functions a to C and elevate to D gives us FCD so this is combining
 map with respect to the first router and map with respect to the second
 parameter in a single call which is completely equivalent to doing first
 the first type parameter with a map and then the second parameter with
 another map but it's just easier to do it with one method probably two
 and this is the recursive call to the same function so this is how we do
 it the functor instance now let's look at the Traverse instance how would
 that work so L of a is the same as recursively defined as s of a and elevate
 so now we need to transform this into this if we want to implement seek
 how do we do that well we can obviously seek here recursively so the second
 argument of s is a recursive instance of the same type and so we can assume
 that for that recursive intense instance we already have the implementation
 so that would be the recursive call to the same function so that would
 be transferring into Fla so now we have so we just do a by map where the
 first one doesn't do anything it's identity and the second function is
 a sequence recursively calling the same and now we do by Traverse or by
 sequence actually by sequence which is as I indicated before it's transforming
 s fafb into F si be pulling out the F at the same time out of both type
 parameters to the outside so we use that and transform s of F a Fla until
 F of s of any LA so this is exactly what we need so in other words seek
 is just a composition of by map and by seek but on that one factor now
 I can use cats library it has by functors by traversable and it has this
 voice sequence so I'm using white functor and white reverse which is canceling
 berry typeclasses just I could have defined them just as easily as the
 trove that class and the redness again is a some problem with types although
 I indicated all types explicitly but still it doesn't like it so therefore
 the Seekers just by map with identity and seek which is a recursive call
 followed by the by sequence call on the by factor so that's exactly what
 we plan to do first we buy map so that we seek under yes with respect to
 the second type parameter and then we do by sequence yes so that works
 and let's check the laws so the identity will need to substitute the code
 now for for clarity I still write f9l here and so on but it is easier now
 to distinguish sequence with respect to L and s because s is a by function
 so it has basic and violent and L has seek so I'm going to write seek L
 I could have done it like this but I'm not going to write it for quality
 for brevity so okay substitute the code of f9 that gives us this code which
 we defined here the lab instance the defunct our instance for help which
 maps using by map under F and the recursive on the second so let's write
 it down so this is a by map of this function and the recursive FF L as
 a second argument of why map so the same function as we're defining here
 is here so now we need to apply secrets the result is this followed by
 by map actually followed by bicycles remind myself what is my definition
 of sequence for you yes just take the S out of the case class which I'm
 not going to write here because it's just wrapping and unwrapping we want
 to pretend that this case class is just a type so first it's apply map
 with identity and seek and then it's a buy seek on the result I'm going
 to ignore this because this is just wrapping right so seek is by map followed
 by by sick this is sick L so we have this expression now we can combine
 the by maps just like we can combine maps because they're by factors it's
 just first we have a map in the first type driver so we combine these two
 which gives us this and then we have a map in the second type planner which
 combines these two and that gives us that so f map L and then seek is the
 same law that we're trying to prove not F not LPR and then seek is f pure
 so it's a recursive invocation of the same law and we're trying to prove
 in the second function of Y map so we can use an inductive assumption that
 we already proved that by recursion and therefore we just substitute into
 this expression we substitute F P R inside of this because that's a look
 so then we get by map of pure pure by seek and the identity law for s means
 that s by map pure pure basic is the same as s is just pure and so that's
 wasting holds for Escalades by traversable function by function and so
 this becomes the right-hand side of the identity law and that's the proof
 of the identity law so now let me mark about using the recursive calls
 and it is that inductive assumptions corresponds to recursive calls in
 code so in mathematics the inductive assumption is that on the previous
 step things were already proved in code it means that we are going to call
 the same function recursively assuming that it will return the correct
 results then our step also returns the correct results but that assumes
 that the recursive call terminates and actually returns the results and
 we have seen an example that on the infinite list it does not return it
 has anything to do and so that's where it is going to break so actually
 the inductive assumption can be used as long as all these functions actually
 terminate their evaluation and return their results and if so then it's
 off it's all fine but so at this level we will not see any problem with
 infinite lists we are using the inductive assumption and everything appears
 to be correct however we have not established that these functions will
 actually return at all and for the infinite list they don't and so for
 some factors defined using this construction using some by factor s some
 factors will have infinite loops and others won't so that is a separate
 thing we need to establish in order to check that they are actually reversible
 this is usually not a problem for factors because this map is going to
 be cold maybe later and this is a lazy call and so there is no infinite
 loop but we have seen we do a bye map and then we do a buy sequence and
 so that call will evaluate everything and that will break for the infinite
 list now all I'm saying is that this proof of laws and the same will apply
 to the proof of the competition law that I'm going to talk about shortly
 this proof is only as good as the fact that all the functions return and
 if you have an infinite loop in one of the implementations then as proof
 oh well great because the inductive assumption cannot be used because the
 use of inductive assumptions is is translated into recursive calls in the
 code and if those goals never terminate them you can't call them so I'm
 not going to present an analysis here as to what possible functors s are
 admissible because I don't know how to do that analysis in general so and
 that's a much more difficult topic of recursive types what are the reclusive
 types for which certain methods would terminate and that's for another
 chapter so from now we will assume that we check separately that all the
 methods will terminate and if that is so then this proof is correct we
 are allowed to use inductive asymmetries let's look at the composition
 law so this is the composition law and the law is an equation both sides
 of which need to be applied to an arbitrary value of this type let's check
 so L F G C so use a instead of C I'll probably check rank it in the slides
 that it is a and not C I'm using a in the code consistency so s of F G
 a L F G so that's lfg so let's apply both sides of this law to some value
 of this type and we get first sequence which is by map of identity and
 sequence followed by by seek and then we do a map of seek which is a function
 that takes this and does a by map and and by seek but now with respect
 to G so I'm just writing it out what the code is for seek and this should
 be equal to by map for the advicing but with respect to FG so that's our
 law let's check that the schools and we certainly assume that it already
 holds for for the s by function which means that this equation holds and
 by seek map is by seek now this is just a law this twisted composition
 of seek can seek is seek so how do we use this in order to prove this now
 clearly to use this we need a value of this type which is not the same
 as what we have here now this is s FG x FG y so is very homogeneous it
 must be the same functors FG and we don't have the same factors here we
 have F G and L F G so this L is outside if L were inside of all of this
 here then we could just say this is why this is eleve is why a is X and
 then we are of this shape so that means we need to permute L over there
 so in order to do this we need to sequence this with respect to F G and
 then L will get inside but we need to use the sequence inside the type
 constructor s which requires a buy map now this is going to be a buy map
 with respect to the second type parameter of S which is the recursive invocatio
n and so that by map and sequence is a recursive call to sequence therefore
 we can use the law of composition for that as if it's already proved and
 we will do that so here's what we do so in this law that we are going to
 use now we're substituting this value s FJ XY which is defined like a by
 map or a sequence with respect to L and respect to F and then G and then
 that's of the right shape with X equal to a and y equal to L of a so that's
 what we wanted and the result is this expression which is a by map followed
 by by seek followed by map now we can certainly use natural reality and
 exchange map sorry no we we here we're having basic F map by CG that's
 what we're using here it's a basic FG that's that's the law we're just
 writing out the law we're substituting s F G X Y into both sides of the
 law services here and this is here so this holds this is an equation that
 holds so now by inductive assumption a composition law for sig L already
 holds when we use it here and so therefore we can rewrite this right-hand
 side like this this is just sick L of F G now this right-hand side is the
 same as the equation that we need to check which I noted as a start and
 just marked labeled that equation by start for convenience so the right-hand
 side of that equation is now the same as this therefore it's also equal
 to that so it remains to show that that the left-hand side is equal to
 the left hand side of star let's write it down so like this yeah it's really
 easier to compare so by map now we have this instead of that and we have
 a by seek and we have a map of by seek instead of this now if we look carefully
 we have a map f of by seek and here we have a map f of something that's
 followed by by 6 so that can be pulled out with a map F and omitted so
 this is a training lab F by sake of G in both of these so as we just a
 minute forget this so now the problem that they are not equal because we
 have a different order of by seek and map so have a by cyghfer by map here
 and here we have a map followed by by seek when we need to interchange
 a map and the natural transformation that's naturality law and it's the
 same way for by factories just by secant by map can be interchanged let's
 write down the naturality law for clarity it looks like this so we have
 a basic follower by map f of by milk of something and then we have a by
 map of map f of that function let other functions we have two functions
 because by map takes two functions both of them need to be mapped and then
 we have bicycling so we have interchange the order by seek and map f so
 if we use this law in this equation then we get that the first line is
 equal to again we can interchange by c combining up and we get by C cadine
 so now we have by map followed by by map followed by by seek by map can
 be combined and then we have this by map fold but by seek and this is exactly
 the left hand side which is this emitted by C kanji sorry this one so this
 concludes the proof of the composition law and therefore we find that this
 construction was valid now the question is which by factors are by traversal
 and the answer is the same all polynomial by factors are by traversable
 now we see without recursion these constructions 1 2 3 our constructions
 that allow us to get any polynomial factor with arbitrary types in it doesn't
 have to be monoid like in applicative can be any any constant type any
 polynomial function these constructions cover all these cases now construction
 to even has two different implementations we can zip in one order or in
 the opposite order it still will work and therefore all polynomial functions
 at reversible now exactly the same constructions worked for by traversable
 constant and a and B are quite reversible in the same way as constant an
 identity function traversable and products and disjunctions are by traversable
 and so-called by traversable polynomial by factors can be used in this
 construction I'm not going to go through proofs for these by functor constructi
ons they're pretty much the same as the proofs I went through except you
 have more type parameters to worry about what implementations are exactly
 the same and so the conclusion is that all polynomial factors including
 recursive polynomial factors as long as the Traverse and seek methods return
 in finite time and they not go into infinite loops as long as that is the
 case all polynomial factors at reversible all polynomial by factors also
 traversable and you can go on you can define a by factor by recursion using
 a try factor in the same way you can say sa B is equal to some T of a be
 s a B or T X Y Z is a try factor and as long as that try factor is tried
 reversible exactly the same proof would show that the by functor is by
 traversable so you can have recursion at any level as long as it's a finite
 level of recursion obviously at some point you would have some n factor
 that is not recursive recursive and or maybe several of them and then as
 long as that's polynomial is going to be 2n traversable and then you go
 back and have your n minus-1 traversable recursive thumpers and so on and
 so it's clear that all polynomial factors with arbitrary recursion so it's
 it's a tree for example whose branches can be themselves lists or you know
 you can have a list of branches or anything like that all of that is traversabl
e so that's a major result of this consideration so now let me consider
 foldable functors now we we know the fold operation in a standard library
 it's a full left turns out that the fold operation is a consequence of
 having a traverse operation and later we'll also see that the scan operation
 the scan left is also a consequence of traverse operation so how do we
 derive the fold from jurors the main idea is that we should take a specific
 applicative factor which is a constant factor fa equals a constant Z or
 is a Z is a monoid type and so the zip operation on this factor is just
 a monoid operation which I will denote like this and we have seen in Chapter
 8 that these are applicative now the type signatures are much simplified
 now in type signature of triggers becomes this and this method is called
 fold map well the does is that it takes a container of type of values of
 type II and takes a function that map's each value to a mono it and then
 it traverses the container and combines all these monoid values into one
 big monoid value and that's for example aggregation and any kind of aggregation
 Sun Oven integer list or some pointer so the general method with an arbitrary
 monoid which is generic in the monoid is called faulkner the type signature
 of seek becomes simple like this so and that is just to concatenate all
 monoid values in the container into one using the monoidal operation so
 this is called M concat now there aren't any more laws because the laws
 are about combining oh the identity law will be automatically satisfied
 and the composition law is trivial because you can't compose these things
 because there is it takes two more nodes compose them you get the second
 one the first one is just just going and so all these laws are trivially
 satisfied there aren't any laws anymore for this foldable operation for
 the fold map there aren't any laws and all traversable functors have these
 operations now nevertheless it's convenient to define the foldable typeclass
 that has these operations like fold map and M concat and fold left because
 you could traverse the containers in different order and that would be
 different implementations even though there are no laws and it's basically
 a consequence of traversable so there aren't any factors that are foldable
 but not reversible so all polynomial factors and only the polynomial functions
 are both foldable and traverses and and so nevertheless it's convenient
 to define this typeclass because you can have different implementations
 of fold for different order of the traverses and finally let me show how
 to define the fold method and that's a trick where you take this as your
 manual type now this is a mono eight where B is an arbitrary fixed type
 and these functions are just concatenated by composition and the identity
 value is the identity function now if you substitute into the following
 up into this substitute B to B you get this type signature it's a curried
 function with one two three arguments so if you just rearrange these arguments
 you see this is exactly the type signature fold left it has your container
 it has initial value it has the update function and it returns the final
 accumulated value so monoid is gone we have a specific one right here the
 arbitrament already that is is gone until we have an arbitrary type B so
 if we put B before this argument and it's not obvious where the money went
 but it is just a consequence of a signature of Traverse where we first
 put them on oil in it and then you specify to this node and so for this
 reason every foldable has a foolproof method for map and M concat and every
 traversable also has them and so now we know which factors are foldable
 and reversible so let's ask our contra functors useful or profanity was
 useful in the same capacity because you could imagine that you want a conscious
 factor that you Traverse with respect to a function or my servers and my
 answer to that is after several analysis is that they're not very useful
 here's why let's take a contra fantasy now let's try to do a seek on it
 so that would be this kind of time signature now if I have a CFA I can
 control map with the pure method the pure F which is a to FA I can come
 up with that to get CFA to see a so I can get down and then I can put that
 into the F using pure F so I get F CA and in fact there is no other way
 of doing this generically now it seems that wall control factors are automatica
lly reversible and I could even say F doesn't have to be a factor it's not
 using map well if I'm just using pure life and so it's it can be arbitrary
 Pro functor as long as it has pure it's actually applicative proof functor
 or even just appointed with a pure so it can be just just like that so
 is that useful well in my view it's not useful because I completely ignore
 all effects of EV I'm using pure of F so whatever F ahead here I'm ignoring
 its effects I'm never going to have any effect full value here either it's
 going to be always a pure so it's not very useful and in the other direction
 you can't do it f seiei to CFA because you can't extract out of F necessary
 now if you have a proof factor see anything things are not workable here's
 why consider this simple example a simplest growth factor just neither
 a functor nor control factor because it has a in both covariant and contravaria
nt positions now we need a sequence function of this type signature but
 that's it's it's impossible we cannot get an F of a to a unless we somehow
 get an a to a first but we can't there's no way to extract a to a out of
 here so I can't get an A you can't get an F of a and so there's no way
 to do this so so the only way to implement this type signature is to return
 pure F of identity here but that ignores its argument and functions that
 ignore its argument will not respect the identity law they will not preserve
 information and finally let's try to try to traverse profile too with respect
 to proof hunters and we find again that the only way to do that is to ignore
 all effects here are two examples so consider this contra factor and this
 contra factor then now if it's applicative it means that s is a mono it
 and so this type the only way to implement is to return an empty value
 of F on the right ignoring all of Fame and the second example is you take
 this contra function and this function and again you can show that the
 only way to implement sequence of this type signature is to always return
 empty option and again that would ignore its argument and so it's most
 likely you're not going to be useful because we ignore all the effects
 will never return anything that's not empty and so on so we we are able
 to implement these type signatures let's see I have I have this test code
 here for a check that we can actually implement only one type signature
 and that it returns an empty option in both of these counter examples so
 take a look at this in more detail if you feel like but I'm of the opinion
 right now that since all of these examples show that I have to ignore all
 effects I have to return a value that ignores all the input data or ignores
 all the effects in the factor or per factor f that's probably not a very
 useful implementation but there isn't any other also note that the laws
 of jurors suppose the notes actually say that effects of f cannot be ignored
 they don't actually say that so you can traverse each element once and
 that's guaranteed but then you can just ignore the effects maybe well for
 some functors that's possible as we have just seen so the conclusion is
 that traversable contractors and pro founders aren't really so great and
 aren't very useful let's look at some examples where we use traversable
 factors the first example is we can convert any traversable factor data
 structure to a list to do that we will actually have a trick and that will
 all define a list as a monoid not as a type constructor is a constant type
 but as a monoid so it will be a constant factor so to express this i define
 the type constructor z which has a type parameter b but it's equal to list
 of c or c is a fixed type parameter up here so it's not depending on B
 so this will be a constant factor which are defined like this so it doesn't
 change anything the type parameter is not used and it's applicative as
 well as a constant for a factor that is a monoid so I define the evocative
 instance using the rajab and this is an eel and a monoid composition or
 concatenation of lists and just for fun I want to define the monoid composition
 in the opposite order [Music] so having defined this and now have Z as
 a applicative factor and I can use chillers which is this function that
 I defined for convenience on the reversible value and so now I Traverse
 F of a which is this L of C probably better cold now this L of C is of
 type unknown type constructor hell so we Traverse it with a function that
 takes a value of type C and returns a list containing a single element
 C the result of traversing is that for each element from the data container
 L will have a list of a single element and then we will concatenate all
 these lists because that's the effect located factor Z and we need to combine
 all these effects for it all values in the container health and the combining
 is done using the monoid composition and so then the result will be a list
 of all elements from the container l so let's see how that works we define
 L like this we have seen the implementation already and now we define a
 value of this type the value is triple 1 2 3 and then we did recall to
 listing it and the result is a list of 3 2 1 because we have defined the
 opposite order here so if we define a straightforward order we would have
 a list of 1 2 3 otherwise we have a list of 3 2 1 so in this way we see
 that any traversable factor is a data container that can be converted to
 lists and the order of list elements depends on the order of traversal
 which is specified by the traversal hibiclens instance the second example
 is to aggregate data from a tree by using a fold so in fact since fold
 is an operation of traverse where the negative factor is a constant factor
 here we have just used fold map essentially we don't need traversable here
 we it's efficient to have foldable we could have defined this function
 by folding with with a list but let's continue using traverse just so that
 we understand these are very much related to each other so here's a definition
 of a simple tree tag it has a leaf of type A and it has a branch with two
 trees now we define the function instance in the usual way and then we
 define the traversal industry which is defined also in the usual way this
 is a recursive construction construction for and so I'm just writing it
 out this follows from the recursive construction if we have a leaf and
 we just put the leaf constructor under F and if we have a branch and we
 run sequence on both branches this is a recursive call to the sequence
 function that we're defining right now and then we zip the results and
 put the result in to pull under the branch here are some example values
 of this type so this is a tree of integers and this is a tree of strings
 and I driven this picture to visualize this tree t2 has a more complicated
 structure T 1 is just 1 2 & 3 it's easy to see what T 2 is not so easy
 to see anymore so let's fold over T 1 so T 1 is 1 2 3 in order to fold
 let's define a 1:08 for integers which will be a multiplication and what's
 the fold map with a function that squares each element so the result of
 fold map will be the product of squares of all and of all the elements
 stored in the tree which will be 1 times 4 times 9 which is 36 the third
 example is to decorate a tree with order labels obtained from a depth-first
 traversal so for instance this tree if we Traverse a depth first then first
 we'll reach a and we'll reach B then C and then D so then the order of
 traversal is 1 2 3 4 and so we expect these labels to be attached so how
 do we attach labels like this way it's not just a map map would we can
 certainly attach constant or a function of each of the label each of the
 element but that's not we won't want to attach a value that depends on
 the traversal so that's the Traverse and since it depends on the traversal
 we need to compute it as we go and so that's I mean we need to maintain
 state as we go as we traverse the tree and maintain in the state can be
 done with the state monad so we use that statement others duplicative function
 and that expresses the effect that we are traversing with so to visualize
 this traversal I could say that we are first so let's Traverse t2 since
 we have it on the screen so we first Traverse t2 by visiting a and we have
 some function that takes a and returns a monad value or a purgative function
 value in general now we done this being and we combine the effects so we
 have four different effects in these four different a purgative functionaries
 we need to combine them using zip and so the result is an F of tuple of
 a B here and then it's going to be this nested tuple so it's f of domestic
 tuple and then we have to recreate the three structure out of that nested
 tuple by remembering where these a B and C and D were in it in the tree
 and we have to reconstruct a tree under F so this and I'm not going to
 write much more detail with basic analysis so it's to be reconstructed
 as the value of this type after after zip and you would just have an F
 of some tuple and you could have converted it to a list first but then
 you completely lose the structure of the tree so the traverse operation
 must somehow keep track of the structure of the continue and you recreate
 it after zipping so it zips the effects so the effects are combined linearly
 in the traversal order using the zip and then after the effects are combined
 effects are mono it always of some kind so they are combined linearly there
 is no tree structure only effects but there is tree structure on the values
 ABCD or whatever values you get after you transform them with the function
 f and so those values have to be arranged so that could be of type B those
 values have to be arranged into the same tree structure as before so now
 we are going to use a state monad as the positive effect and statement
 others applicative and you will use if statement values together what happens
 is that you update the state each state mullet value could update the state
 in some way and so this is a linear sequence of effects that you need to
 combine by updating the state first using this updater than using this
 updater and so on in the linear order of traversal and that's what well
 we will use now we'll have a monadic value make label so we define first
 of all a state monad I'm using the Katz library with integer state so for
 convenience I'll call this s right now just in this test so I'll I define
 a make label value which is a monadic value that updates the state and
 returns also this value that is the previous value before I'm dating I
 could return the next value it doesn't really matter and that's going to
 be melodic value that we are going to produce for each of the elements
 of the tree now we actually need to represent this as an applicative factor
 so let me just quickly convert to my zip typeclass which is my my version
 of applicative of course the cats library already has a positive instance
 for this but it's easier to use my my typeclasses because they're very
 small they don't have a lot of methods and it's easy to see what they do
 so we need to define the wrapped unit which is just a pure of state factor
 and we need to define zip which is defined in a regular way for anyone
 that this is just combined the two effects in this order we could have
 changed the order here so this is this is a freedom but let's just keep
 this order and this function will allow us to produce her with zip tie
 plus instance from a statement well you know what's right a tree traversal
 so a tree traversal we already implemented up here so I just copied this
 code in I don't think I needed to duplicate nice code we can just remove
 this code so how do we use that so we have t2 which was defined before
 that we Traverse using the effect type yes so this is the apocatip factor
 that we have now a wizard instance for we have this was a probe s and the
 result type is going to be a tuple of string int so we're adding an integer
 label to a string type of the tree which which t2 has 32 think and the
 type is tray of string so the function with which which reverse takes a
 label and prefer this make label operation which is a monadic value and
 then we map now this magnetic value returns the integer and then we map
 that integer into a tuple with the previous tree leaf is really called
 leaf action to be more clear so we map a tree leaf to a tuple of leaf and
 label and we get out of the Monad so now this is a value of type s of tree
 of string int so this is a result of traversal and now we need to run it
 so we run the statement out on the initial value one and we extract the
 value out of it so this is that cats library API two is to extract values
 from statement and the result is as expected so it's a labeled with 1v
 we still in soon so in this way we can decorate the tree with labels that
 are computed as we go on in a traversal the next example is templum and
 skin functions scan map and scan left so we have seen that fold can be
 implemented if you have it reversible and scan also follows from properties
 of traversable so scan map is something I made up it's a method analogous
 to fold map where you have a monoid and you map your data to a monoid type
 and then the result is that unlike fold map it's not just one monoid value
 that aggregates everything you don't just accumulate the final value you
 keep all the intermediate accumulated values and put them back into your
 container so this is like the scan function so how does it work we use
 a statement again it's state is the MU node so initially it will be empty
 and then we will accumulate a monoid state so this is how we accumulate
 we get the previous state and we set the new accumulated state and then
 we get again in new states so that we have it on hand and then we Traverse
 with a function that is f which is this given F followed by accumulate
 and so the result is s of Z which is a state that accumulates Z and also
 gives it as a value so after traversing we get a value of type s of L of
 Z's and then we run it on an initially empty value and that's what we return
 extracting out of the state monad after we have run it so here's the test
 let's use a string as monoid so we imported a cat's instance just for standard
 string 108 and let's do a scan map on t2 with no transformation so then
 we're just going to accumulate the string as we go so we get a a b a b
 c a b c d so that's the result of scan map and we can also implement the
 standard scan left function which is very similar except we don't accumulate
 a monoid now we just accumulate a value of some arbitrary type z and we
 do the same thing as we did before very similar code and here's a test
 so we let's accumulate the length of strings in the in the tree so then
 we'll get one two three four because all all strings have length 1 and
 the last example is the traverse a rigid tree or non monadic tree as I
 don't think vegetation well it is a widely used word to describe this kind
 of tree but basically imagine a tree that must have all branches fall so
 it cannot be unbalanced then it must be full it's a binary tree that must
 have one two four eight 16 32 and so on elements and no other number of
 elements can be in the tree that's very rigid in its shape this recursive
 type equation he finds it and you can easily see why so it's either a or
 it's the same T of any times a so then it's either a times a or the same
 tree of a times a times a times a so then it's for A's or eight A's or
 sixteen is consumed so it's it's at this infinite disjunction with 1 a
 or 2 is 4 4 8 or 8 8 and so on so that's that's why this equation works
 not we don't have a construction where I did not write down the construction
 that can generalize this tree this kind of construction could be generalized
 like this where you have a recursive equation with some buy furniture yes
 and the second type 300 - 2 s is not a la as it was previously not just
 LA but it's L of some RA where R is another function so in this case it
 will be a pair but in general it could be some other function and that
 function must be both applicative and reversible and if so then I believe
 if this construction will work as well so this is a more general recursive
 construction let's see the code for this so the definition of the tree
 type is this it has a single element in the branch which is a tree of the
 pair parameter instead so we substitute to the type parameter which is
 kind of non-trivial so we can define the functor instance which is a bit
 of work because now we need to map this branch of type 3 of a a we need
 to map it recursively with a function that map's a a to be me but we don't
 have that function we have a to be so we need to construct a function that
 map's a a to be B out of F and the traversal is again a depth-first traversal
 where the leaf is handled the same way as before but the branch is handled
 differently because we actually have this kind of type and we need to get
 this so we need to do we need to use zip for F in order to pull F out of
 the tuple and so we first zip the FS together like this and this needs
 to be done under the B so it's a b fa fa map of the zip so that's going
 to have B of F of praa and then we sequence that so we get F of of PNA
 and then we wrap it into the branch so that's how traversal works and certainly
 we tested you know this is how we would create this data structure so it's
 always branch branch branch branch and finally leaf with a very large may
 be nested tuple so this is why this tree is so rigid he does not have cannot
 have unbalanced shape so that works we use in mono omoide instance for
 integer and do a fold map with identity to get the sum of all these numbers
 so these examples indicate that we can do a lot of things with Traverse
 but there are there are actually things we cannot do using each others
 because the Traverse separation we remember it is an operation that needs
 to be generic in the effect against which we Traverse in this applicative
 factor so two things that cannot be implemented the traversal which you
 find interesting but this is so or the breadth-first traversal for a tree
 so imagine a tree of this shape and you want to do breadth-first traversal
 so you traverse first at this level you get one and you traverse at this
 level you get to an elite reverse at this level now that can cannot be
 expressed as a traversal with some effect because as I indicated here to
 visualize a traversal we need to imagine that we are computing a large
 linear sequence of effects into one combining a large linear sequence of
 effects into one big effect and now in order to express this you would
 have to have to know for example here that this two must be two and not
 one now this effect cannot come from just recursive traversal you cannot
 just take a usual recursive depth first traversal and run some more nuts
 and clever Monat with it and get this other chamber so now we certainly
 probably can implement it in some other way but I don't see how you can
 simply do a recursive function on a tree that traverses it against an applicati
ve factor and get this effect and especially when you call recursively on
 this subtree you need to know how many nodes will be in some other levels
 in some other subtree so it's not clear how you could possibly get that
 information from any kind of monitor or [Music] applicative function now
 certainly you can implement breadth-first traversal but what I'm saying
 is that you cannot take some special monad and some recursive function
 calls and implement it so easily I hope you can still implement it in some
 way that is not too bad as a traversal certainly the standard way of implementi
ng breadth-first traversal to use a queue or you in queue each node and
 then you in queue it to children and then you DQ and as you dqu in queue
 more so that can be certainly done in a statement that that computation
 but the problem is you need the traversal which recreates the original
 structure so if if all you want is twofold then you can implement fold
 in a breadth-first while using a queue like that but what you need is to
 recreate the original tree structure and that's very cursive structure
 that has a depth-first logic to it and so that's the difficulty and certainly
 you can do it with a lot of extra work it's not just a couple of lines
 of code like it was for depth-first traversal so at this point I don't
 have code for this maybe this can be done in some clever way but I haven't
 found it and the second thing that I don't think you can do is to label
 depth of the tree using a traversal so again it's a similar problem that
 effects so these aren't going to be effects and obviously you need some
 kind of state to hold this one and then update it to two and two three
 but effects are concatenated linearly and so it cannot be that this three
 is the same as this you cannot avoid concatenating this effect with this
 one when you do a traversal because of this linear nature of combining
 effects and you cannot avoid combining effects during traversal and so
 there's no way to skip incrementing the counter when you do choose ourselves
 so I don't think you can easily express this kind of labeling and this
 is trivial to do ad hoc as a function on a tree but what you want is to
 have a generic traversal which is generic in the factor f and just uses
 the zip and combines the effects and that's why traversals are not so flexible
 you cannot avoid incrementing your counter you cannot have logic that says
 oh here I don't increment because they're at the same level can't have
 that logic you must combine the only factors together so I keep talking
 about being generic in the function f so let me talk about it in a more
 rigorous manner so what we're looking for is to be generic in the sense
 that the code for traverse as well as the code for the sequence in it should
 not depend on a specific function f it should only use the methods P R
 and zip or maybe map as well from F and [Music] recall recall how we dealt
 with a similar problem when we discovered founders so a factor is a data
 container that is generic in type of the data that it holds and the map
 function or F map is a function that cannot use specific type information
 about A or B it must manipulate this data blindly with no change you take
 a container you take each element a very replacement may be and put it
 back at the same place but you don't know what types those are and so we
 expressed the law of natural T for various functions by saying that F map
 should come should commute with those functions so you can transform first
 or you can transform later and that's what it means that it's generic in
 the type of data so similarly generic in the function f means that if we
 map a functor F to some other function G then a traverse with respect to
 F will be mapped to the Traverse with respect to G so we need this mapping
 somehow so this cannot be this can be formulated mathematically I don't
 want to spend too much time on this but I just want to mention this is
 an important mathematical development perhaps but this is the first time
 where we have seen this kind of thing and we don't have I don't have good
 notation right now for this natural transformations between applicative
 functors and its need to be considered so here's the mathematical formulation
 we consider - Lickety functors F and G and we consider a natural transformation
 between them such that it Maps period of F into pure of G and it maps zip
 of F into the project and then we demand that it also should map the Traverse
 of F into Traverse of G so if we do that well all we do is we just say
 we have a traverse with respect to F let's apply it and then map F to G
 in the result because the result of Traverse is F of something F of some
 L of a or L of B so we can map that into G of not using the natural transformat
ion or we can first map f to G and then apply Traverse and that should be
 the same and so this is a natural T with respect to the functor as a type
 parameter so it's a higher-order type parameter itself otherwise it's quite
 similar to not two naturality and it's just more complicated because it's
 not just any natural transformation natural transformation by itself has
 laws already and in addition to being a natural transformation it needs
 to preserve the implicative properties of f so that pure is mapped to pure
 zip is mapped to zip and and the laws of course must hold for both implicated
 factors so if you look at this notation which is slightly made shorter
 on purpose by omitting various type parameters it really looks like lifting
 from a function f to G into function of traversing you have to traverse
 G but F and G are not types they're type constructors so and this is not
 a function this is a natural transformation which is more complicated object
 so when we used category theory to describe such liftings we would usually
 say this is a morphism in one category and this is a morphism in another
 category but a morphism as we define it was always between two types now
 we don't have types we have type constructors so we need basically a morphism
 between type constructors so that's more more precisely between implicative
 factors so a morphism between applicative functions that's what we need
 to lift into a morphism of traversable faculties and so that requires a
 more general definition of category than what I have given so far we're
 in them in the definition I've given so far morphisms were just twisted
 function types but now we need morphisms between type constructors or even
 more restricted ones morphisms between applicative functions with extra
 properties so category theory prescribes this in a general definition of
 category can be given which I'm not going to give right now because I don't
 see in the use for it other than to indicate the property of natural T
 as being similar to previous properties I encourage you to look at category
 theory at some point but I will only talk about what I see it as being
 useful and so right now it is useful to think about this as a lifting and
 the wall is of course need to hold such as identity and Composition so
 if we map F to F then we don't change anything that should be lifted into
 identity and composition F to G to H mapped it to composition of those
 mappings and so on so those are the rigorous four forms for the naturality
 war with respect to applicative function I'm not writing it down in detail
 because just as naturality with respect to ordinary type parameter this
 is this morality with respectively funter is going to be satisfied automaticall
y by any code that nearly uses peer and zip and why is that it's because
 when we perform a natural transformation that maps FPR to GD P R and F
 zip to gzip the code doesn't actually change at all the code has f as a
 type parameter and it just uses pure and zip in the code to cause them
 as we have been doing when we implemented the traverse instances for example
 so let's see here is for example we are using zip the zip is from the function
 f but F is a type parameter so if we now apply a natural transformation
 from F to G for some other negative function G this code doesn't change
 at all it still uses the zip and we have the condition that there's natural
 transformation that maps F to G it Maps zip to zip and peer to peer and
 and map to map of course that's the natural T of natural transformation
 so our code won't change and our code therefore is invariant under this
 natural transformation and so it's automatically going to satisfy naturality
 with respect to the type parameter F and it also will automatically satisfy
 not reality with respect to time over a and that's why we never need to
 check these laws explicitly or even spend so much time writing them explicitly
 because they are they are useful sometimes when your reason about code
 and prove some other law was then learned are useful but for coding for
 implementing you always have natural T automatically so this concludes
 chapter 9 and here are some exercises for you to implement let me just
 comment and this exercise so I don't want you to prove laws by hand for
 this factor T it's cumbersome but instead use constructions so we have
 proved general constructions so if you express T as a recursive equation
 using some by factor s and you show that the wife on dress is by traversable
 again using constructions of course then you don't need to and to do the
 proof yourself if the constructions already proved once you have found
 them and similarly for for this construction you don't need to prove anything
 by hand this exercise is a little different but you can try to prove this
 extra construction that I mentioned this one but it's very similar to other
 constructions and so it's not necessarily part of this exercise this concludes
 chapter 9 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
