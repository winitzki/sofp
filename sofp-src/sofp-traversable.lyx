#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset


\end_layout

\begin_layout Chapter
Traversable functors
\begin_inset CommandInset label
LatexCommand label
name "chap:9-Traversable-functors-and"

\end_inset


\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 programming style
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
map
\family default
/
\family typewriter
reduce
\family default
 programming style
\end_layout

\end_inset

 was perhaps the first significant industrial use of functional programming.
 The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 were added later to increase the expressive power of that programming style.
 Previous chapters examined systematically the properties of those methods
 and generalized them to many different type constructors.
 This chapter uses the same approach to study and generalize the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method.
 In this way, we will obtain a complete understanding of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 programming style.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:From-reduce-and-foldleft-to-foldmap"

\end_inset

From 
\family typewriter
reduce
\family default
 and 
\family typewriter
foldLeft
\family default
 to 
\family typewriter
foldMap
\end_layout

\begin_layout Standard
The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](la: Seq[A])(update: (A, A) => A): A
\end_layout

\begin_layout Plain Layout

def foldLeft[A, B](la: Seq[A])(init: B)(update: (B, A) => B): B
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{reduce}:\text{Seq}^{A}\rightarrow(A\times A\rightarrow A)\rightarrow A\quad,\quad\quad\text{foldLeft}:\text{Seq}^{A}\rightarrow B\rightarrow(B\times A\rightarrow B)\rightarrow B\quad.
\]

\end_inset

In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, the accumulated result is of a different type (
\begin_inset Formula $B$
\end_inset

) than the type of sequence elements (
\begin_inset Formula $A$
\end_inset

).
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is a generalized version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
 We can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](la: Seq[A])(update: (A, A) => A): A = reduce.tail.foldLeft(reduce.hea
d)(update)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation goes over each element of a sequence and accumulates the updates,
 returning the final updated value.
 We have seen many examples of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Now we would like to generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to data structures other than sequences.
 Such a generalization must be based on imposing suitable laws, but it is
 not obvious what laws 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 must satisfy (other than naturality laws that will hold automatically for
 any fully parametric code).
 To make progress, we will generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 further to obtain the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method, for which we can motivate non-trivial laws.
 We will achieve this generalization in two steps, first transforming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to a new function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and then to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The way from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 starts by changing the type of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

update: (B, A) => B
\end_layout

\end_inset

 to an equivalent curried form with a flipped order of arguments:
\begin_inset Formula 
\[
\text{upd}:A\rightarrow B\rightarrow B\quad.
\]

\end_inset

So, 
\begin_inset Formula $\text{upd}\,(x^{:A})$
\end_inset

 has type 
\begin_inset Formula $B\rightarrow B$
\end_inset

.
 The key observation is that all functions of type 
\begin_inset Formula $B\rightarrow B$
\end_inset

 form a 
\emph on
monoid
\emph default
 (denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidFunc
\end_layout

\end_inset

 in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
monoid
\end_layout

\end_inset

 For brevity, let us denote that monoid by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MF
\end_layout

\end_inset

.
 The empty element of that monoid is the identity function (
\begin_inset Formula $e_{\text{MF}}\triangleq\text{id}^{:B\rightarrow B}$
\end_inset

), and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

 operation is the function composition (
\begin_inset Formula $f^{:B\rightarrow B}\oplus_{\text{MF}}g^{:B\rightarrow B}\triangleq f\bef g$
\end_inset

).
 With this formulation, the evaluation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 function can be written like this:
\begin_inset Formula 
\begin{align*}
 & \text{foldLeft}\left(\left[x_{1},x_{2},x_{3}\right]\right)\left(b_{0}\right)\left(\text{upd}\right)=b_{0}\triangleright\text{upd}\left(x_{1}\right)\triangleright\text{upd}\left(x_{2}\right)\triangleright\text{upd}\left(x_{3}\right)\\
 & =b_{0}\triangleright\text{upd}\left(x_{1}\right)\bef\text{upd}\left(x_{2}\right)\bef\text{upd}\left(x_{3}\right)=b_{0}\triangleright\big(\text{upd}\left(x_{1}\right)\oplus_{\text{MF}}\text{upd}\left(x_{2}\right)\oplus_{\text{MF}}\text{upd}\left(x_{3}\right)\big)\quad.
\end{align*}

\end_inset

This formulation suggests that we could replace the specific monoid (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MF
\end_layout

\end_inset

) by an arbitrary monoid (
\begin_inset Formula $M$
\end_inset

).
 The new, more general function is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 To obtain that function, we first change the order of the curried arguments
 for convenience:
\begin_inset Formula 
\[
\text{foldMap}\,(\text{upd})\left(xs\right)\left(b_{0}\right)\triangleq\text{foldLeft}\left(xs\right)\left(b_{0}\right)(\text{upd})\quad.
\]

\end_inset

Omitting the argument 
\begin_inset Formula $b_{0}$
\end_inset

, we may visualize the computation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
\text{foldMap}\,(\text{upd})\left(\left[x_{1},x_{2},x_{3}\right]\right)=\text{upd}\left(x_{1}\right)\oplus_{M}\text{upd}\left(x_{2}\right)\oplus_{M}\text{upd}\left(x_{3}\right)\quad.
\]

\end_inset

Now, the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

upd
\end_layout

\end_inset

 is 
\begin_inset Formula $A\rightarrow M$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow B\rightarrow B$
\end_inset

.
 So, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 must be:
\begin_inset Formula 
\[
\text{foldMap}:(A\rightarrow M)\rightarrow\text{Seq}^{A}\rightarrow M\quad.
\]

\end_inset

This type signature assumes that 
\begin_inset Formula $M$
\end_inset

 is a monoid type.
 We can now implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldMap[M: Monoid, A](f: A => M): Seq[A] => M =
\end_layout

\begin_layout Plain Layout

  _.foldLeft(Monoid[M].empty) { (m, a) => m |+| f(a) }
\end_layout

\end_inset

We can also implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 by using the monoid instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FM
\end_layout

\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def monoidFunc[A]: Monoid[A => A] = ...
\end_layout

\begin_layout Plain Layout

def foldLeft[A, B](la: Seq[A])(init: B)(update: (B, A) => B): B =
\end_layout

\begin_layout Plain Layout

  foldMap[B => B, A](identity)(a => b => update(b, a))(init)
\end_layout

\end_inset

We will prove later than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are in fact equivalent.
\end_layout

\begin_layout Standard
The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 suggests further to replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[_]
\end_layout

\end_inset

 by another type constructor, denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

.
 We call 
\series bold
foldable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
foldable functor
\end_layout

\end_inset

 a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

 for which the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 method is defined:
\begin_inset Formula 
\[
\text{foldMap}_{L}:\left(A\rightarrow M\right)\rightarrow L^{A}\rightarrow M\quad,\quad\text{assuming that }M\text{ is a monoid}\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldMap_L[M: Monoid, A](f: A => M): L[A] => M = ???
\end_layout

\end_inset

The function 
\begin_inset Formula $\text{foldMap}_{L}$
\end_inset

 works in the same way for all monoids 
\begin_inset Formula $M$
\end_inset

 (but differently for each 
\begin_inset Formula $L$
\end_inset

).
 
\end_layout

\begin_layout Standard
The second step towards the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method replaces the arbitrary monoid 
\begin_inset Formula $M$
\end_inset

 by an arbitrary applicative functor 
\begin_inset Formula $F^{B}$
\end_inset

 with a type parameter 
\begin_inset Formula $B$
\end_inset

.
 Since this step is not straightforward, we will give an independent motivation
 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method in the next subsection.
\end_layout

\begin_layout Subsection
The 
\family typewriter
traverse
\family default
 operation
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-traverse-operation"

\end_inset


\end_layout

\begin_layout Standard
Consider the task of waiting for several concurrent operations to finish.
 As an example, suppose we have a list of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 and a processing function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Future[B]
\end_layout

\end_inset

.
 We need to apply the processing function to all items from the list in
 parallel and wait until the entire data set is processed.
\end_layout

\begin_layout Standard
The Scala standard library has a special method (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.traverse
\end_layout

\end_inset

) to use in this situation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val data: List[A] = ...
\end_layout

\begin_layout Plain Layout

val processing: A => Future[B] = ...
\end_layout

\begin_layout Plain Layout

implicit val ec: ExecutionContext = ...
\end_layout

\begin_layout Plain Layout

val results: Future[List[B]] = Future.traverse(data)(processing)
\end_layout

\end_inset

Since the processing of each element is asynchronous, the result must be
 also wrapped in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 type constructor.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method will mark that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 value as finished when all processing functions are done.
\end_layout

\begin_layout Standard
If we ignore the implicit argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ExecutionContext
\end_layout

\end_inset

 (which is specific to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 class) and also flip the first two curried arguments, we will arrive at
 the following type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{trav}$
\end_inset


\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\[
\text{trav}:(A\rightarrow\text{Future}^{B})\rightarrow\text{List}^{A}\rightarrow\text{Future}^{\text{List}^{B}}\quad.
\]

\end_inset

Generalizing to other type constructors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, we obtain:
\begin_inset Formula 
\[
\text{trav}_{L}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}\quad.
\]

\end_inset

In this type signature, we have chosen the names 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 specifically to help us avoid errors (e.g., writing 
\begin_inset Formula $L^{F^{B}}$
\end_inset

 instead of 
\begin_inset Formula $F^{L^{B}}$
\end_inset

) by recalling the example with 
\begin_inset Formula $F=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset Formula $L=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It turns out that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method can work in the same way for any 
\emph on
applicative
\emph default
 functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

.
 A functor 
\begin_inset Formula $L^{\bullet}$
\end_inset

 having a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method of this type is called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
traversable functor
\end_layout

\end_inset


\series bold
traversable
\series default
.
\end_layout

\begin_layout Standard
The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are similar except that 
\begin_inset Formula $M$
\end_inset

 is replaced by 
\begin_inset Formula $F^{B}$
\end_inset

 or 
\begin_inset Formula $F^{L^{B}}$
\end_inset

 as appropriate.
 To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 is a special case of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, take a constant functor 
\begin_inset Formula $F^{A}\triangleq M$
\end_inset

, which is applicative if 
\begin_inset Formula $M$
\end_inset

 is a monoid (as shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-applicative-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 With this choice of 
\begin_inset Formula $F^{\bullet}$
\end_inset

, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 reduces to that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Before studying the properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, we will look at some examples of its practical use.
\end_layout

\begin_layout Section
Practical use of folding and traversing operations
\end_layout

\begin_layout Subsection
Implementing 
\family typewriter
traverse
\family default
 for various data types
\end_layout

\begin_layout Standard
To understand how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 works, let us implement it for some data types, including lists and trees.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traverse-for-1+a*a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-for-1+a*a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the type constructor 
\begin_inset Formula $L^{\bullet}$
\end_inset

 defined by:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type L[A] = Option[(A, A)]
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For the given type constructor 
\begin_inset Formula $L^{\bullet}$
\end_inset

, write an equivalent type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]]
\end_layout

\end_inset

Here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 is an unknown applicative functor.
 In the short type notation, this type signature is:
\begin_inset Formula 
\[
\text{trav}_{L}:(A\rightarrow F^{B})\rightarrow(\bbnum 1+A\times A)\rightarrow F^{\bbnum 1+B\times B}\quad.
\]

\end_inset

 Let us implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

, aiming to preserve information.
 We need to compute a value of type 
\begin_inset Formula $F^{\bbnum 1+B\times B}$
\end_inset

.
 Since 
\begin_inset Formula $F$
\end_inset

 is applicative, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 could just always return an empty value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] =
\end_layout

\begin_layout Plain Layout

  F.pure(None)   // Assuming F.pure is defined.
\end_layout

\end_inset

We reject this implementation since it ignores all arguments and loses informati
on.
 Instead, we begin by pattern matching on the argument of type 
\begin_inset Formula $\bbnum 1+A\times A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] = {
\end_layout

\begin_layout Plain Layout

  case None             => F.pure(None)   // We must return this value in
 this case.
\end_layout

\begin_layout Plain Layout

  case Some((a1, a2))   => ???            // Would like a value of type
 F[Some[(B, B)]] here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The only way of getting values of type 
\begin_inset Formula $B$
\end_inset

 is by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to some arguments.
 We can apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

; the result will be two values of type 
\begin_inset Formula $F^{B}$
\end_inset

.
 Since 
\begin_inset Formula $F$
\end_inset

 is applicative, we may use its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method and obtain a single value of type 
\begin_inset Formula $F^{B\times B}$
\end_inset

.
 It remains to use 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and transform that value to the required type 
\begin_inset Formula $F^{\bbnum 1+B\times B}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] = {
\end_layout

\begin_layout Plain Layout

  case None             => F.pure(None)         // Here we must return an
 empty value.
\end_layout

\begin_layout Plain Layout

  case Some((a1, a2))   => F.zip(f(a1), f(a2)).map { case (b1, b2)  => Some((b1,
 b2)) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the code notation, this is written as:
\begin_inset Formula 
\[
\text{trav}_{L}(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{\bbnum 1+B\times B}\\
\hline \bbnum 1 & \_\rightarrow\text{pu}_{F}(\bbnum 1+\bbnum 0^{:B\times B})\\
A\times A & (f\boxtimes f)\bef\text{zip}_{F}\bef(b_{1}^{:B}\times b_{2}^{:B}\rightarrow\bbnum 0^{:\bbnum 1}+b_{1}\times b_{2})^{\uparrow F}
\end{array}\quad.
\]

\end_inset

The code uses 
\begin_inset Formula $F$
\end_inset

's methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

.
 This makes it clear why 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 requires 
\begin_inset Formula $F$
\end_inset

 to be an applicative functor.
 Apart from that requirement, the code works in the same way for all 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traversable-seq"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversable-seq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type constructor.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to implement the following type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B]): List[A] => F[List[B]]
\end_layout

\end_inset

A list may be empty, or may have a head and a tail.
 Similarly to the code in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-for-1+a*a"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we use 
\begin_inset Formula $F$
\end_inset

's methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to compute a suitable value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[Seq[B]]
\end_layout

\end_inset

 in these cases.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B])(la: List[A]):
 F[List[B]] = la match {
\end_layout

\begin_layout Plain Layout

  case Nil            => F.pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => F.zip(f(head), trav(f)(tail)).map { case (headB,
 tailB)  => headB :: tailB }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code iterates over each element of the list (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

) and accumulates the effect expressed by the applicative functor 
\begin_inset Formula $F$
\end_inset

.
 The 
\begin_inset Formula $F$
\end_inset

-effects are merged using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method.
\end_layout

\begin_layout Standard
In the code notation, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 looks like this:
\begin_inset Formula 
\[
\text{trav}_{\text{List}}(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{\bbnum 1+B\times\text{List}^{B}}\\
\hline \bbnum 1 & \_\rightarrow\text{pu}_{F}(\bbnum 1+\bbnum 0^{:B\times\text{List}^{B}})\\
A\times\text{List}^{A} & \big(f\boxtimes\overline{\text{trav}}_{\text{List}}(f)\big)\bef\text{zip}_{F}\bef(h^{:B}\times t^{:\text{List}^{B}}\rightarrow\bbnum 0^{:\bbnum 1}+h\times t)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traverse-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for the binary tree (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Binary-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will use the following binary tree data type denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait T2[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](a: A)                 extends T2[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](l: T2[A], r: T2[A]) extends T2[A]
\end_layout

\end_inset

We implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 similarly to the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Binary-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B])(t: T2[A]): F[T2[B]]
 = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)          => f(a).map(b => Leaf(b))            // Reproduce
 the Leaf structure under F.
\end_layout

\begin_layout Plain Layout

  case Branch(t1, t2)   =>
\end_layout

\begin_layout Plain Layout

    val (r1, r2) = (trav(f)(t1), trav(f)(t2))    // Traverse the two branches
 and obtain two results.
\end_layout

\begin_layout Plain Layout

    (r1 zip r2).map { case (b1, b2)  => Branch(b1, b2) }   // Reproduce the
 Branch structure under F.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the code notation, this function looks like this:
\begin_inset Formula 
\[
\text{trav}\,(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{B+\text{T2}^{B}\times\text{T2}^{B}}\\
\hline A & f\bef(b^{:B}\rightarrow b+\bbnum 0^{:\text{T2}^{B}\times\text{T2}^{B}})^{\uparrow F}\\
\text{T2}^{A}\times\text{T2}^{A} & \big(\overline{\text{trav}}\,(f)\boxtimes\overline{\text{trav}}\,(f)\big)\bef\text{zip}_{F}\bef(l^{:\text{T2}^{B}}\times r^{:\text{T2}^{B}}\rightarrow\bbnum 0^{:B}+l\times r)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The code first traverses the two sub-branches (using recursive calls to
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

) and then combines the resulting values.
 So, this implementation represents the depth-first, left-to-right traversal
 of the tree.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traversal-perfect-shaped-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversal-perfect-shaped-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for the perfect-shaped tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Perfect-shaped-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We begin writing code as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by pattern matching:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B])(t: PTree[A]):
 F[PTree[B]] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)     => f(a).map(b => Leaf(b))           // Reproduce the Leaf
 structure under F.
\end_layout

\begin_layout Plain Layout

  case Branch(t)   => ???  // Here t has type PTree[(A, A)].
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In line 3, we have a pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[(A, A)]
\end_layout

\end_inset

, but we need to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[Branch[B]]
\end_layout

\end_inset

 in that scope.
 Since a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 contains a recursive instance of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree
\end_layout

\end_inset

, it seems we need to use a recursive call of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 here.
 However, we cannot apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav(f)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 because the types do not match.
 We will be able to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 if instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => F[B]
\end_layout

\end_inset

 we had a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A) => F[(B, B)]
\end_layout

\end_inset

.
 We can create such a function out of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case (a1, a2) => f(a1) zip f(a2) }
\end_layout

\end_inset

 So, we write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  case Branch(t)   => trav { case (a1, a2) => f(a1) zip f(a2) }(t); ???
 } // Have F[PTree[(B, B)]].
\end_layout

\end_inset

We can now use 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method to restore the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 structure under 
\begin_inset Formula $F$
\end_inset

.
 The complete code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Functor : Applicative](f: A => F[B])(t: PTree[A]):
 F[PTree[B]] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)     => f(a).map(b => Leaf(b))           // Reproduce the Leaf
 structure under F.
\end_layout

\begin_layout Plain Layout

  case Branch(t)   => (trav[(A, A), (B, B), F] { case (a1, a2) => f(a1)
 zip f(a2) }(t)
\end_layout

\begin_layout Plain Layout

                      ).map(x => Branch(x))          // Reproduce the Branch
 structure under F.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here we assumed that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 is defined on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 as an extension method.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
These examples show how to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for a data structure of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 Each value of type 
\begin_inset Formula $A$
\end_inset

 contained in the data structure should be processed using the given function
 
\begin_inset Formula $f:A\rightarrow F^{B}$
\end_inset

.
 All of the resulting 
\begin_inset Formula $F$
\end_inset

-effects need to be collected and merged (using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

) into a single 
\begin_inset Formula $F$
\end_inset

-effect that wraps a value of type 
\begin_inset Formula $L^{B}$
\end_inset

.
 That value should reproduce the shape of the data structure that was present
 in the input value of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
In all examples above, we merge all 
\begin_inset Formula $F$
\end_inset

-effects together, making sure that each 
\begin_inset Formula $F$
\end_inset

-effect is collected exactly once.
 It would be strange if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation were to repeat some 
\begin_inset Formula $F$
\end_inset

-effects, as the following code shows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def badtrav[A, B, F[_]: Functor : Applicative](f: A => F[B])(la: List[A]):
 F[List[B]] = la match {
\end_layout

\begin_layout Plain Layout

  case Nil            => F.pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => F.zip(f(head), F.zip(f(head), badtrav(f)(tail)))
  // Use the F-effect twice.
\end_layout

\begin_layout Plain Layout

                          .map { case (headB, (_, tailB))  => headB :: tailB
 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Although this implementation fits the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, it contradicts the intuition of traversing the sequence only once.
 When 
\begin_inset Formula $F=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

, the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

badtrav(f)(xs)
\end_layout

\end_inset

 will start 
\emph on
two
\emph default
 parallel computations for each element of the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and ignore one of the results.
 When 
\begin_inset Formula $F$
\end_inset

's effect describes parsing (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Parsing-with-applicative-and-monadic-parsers"
plural "false"
caps "false"
noprefix "false"

\end_inset

) or other computations that maintain an internal state, invoking such an
 
\begin_inset Formula $F$
\end_inset

-effect twice will likely lead to incorrect results.
 Below we will see that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 prohibit implementations that either repeat some of the 
\begin_inset Formula $F$
\end_inset

-effects or ignore some of the values.
\end_layout

\begin_layout Subsection
Aggregating tree-like data by folding.
 Breadth-first traversal
\begin_inset CommandInset label
LatexCommand label
name "subsec:Aggregating-tree-like-data-bfs"

\end_inset


\end_layout

\begin_layout Standard
Although 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 (and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

) are special cases of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, it is often easier to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 directly.
 Let us look at some examples of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 that implements different kinds of tree traversals.
\end_layout

\begin_layout Standard
One implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 corresponds to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldMap[A, M: Monoid](f: A => M)(t: T2[A]): M = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)          => f(a)
\end_layout

\begin_layout Plain Layout

  case Branch(t1, t2)   => foldMap(f)(t1) |+| foldMap(f)(t2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A special case of a monoid is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

; its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine
\end_layout

\end_inset

 operation is the concatenation of lists.
 If we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 with the monoid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M = List[A]
\end_layout

\end_inset

 and the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => List[A]
\end_layout

\end_inset

 that creates a single-element list, we obtain an interesting result: a
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 that converts a tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList[A]: T2[A] => List[A] = foldMap[A, List[A]](List(_)) // Need a
 Monoid instance for List[A].
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the same way, we may implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList: L[A] => List[A]
\end_layout

\end_inset

 for any foldable functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 captures the requirement that a foldable functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 must have a well-defined way of iterating over the data items stored inside
 it.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 is foldable if there is a known way of extracting its data items in the
 form of a list.
 We may then use standard aggregation operations on lists (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, and so on).
 Below, we will prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 So, a foldable functor supports applying any aggregation operation to the
 functor's data.
 
\end_layout

\begin_layout Standard
An aggregation's results may depend on the order of data traversal.
 It is important that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 can be implemented in different ways depending on the order in which it
 writes the data from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 to a list.
 Some data structures have a 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

 traversal order that is easiest to implement, but this is by no means the
 only possible traversal order.
 Let us see some examples of implementing different traversal orders for
 lists and trees.
\end_layout

\begin_layout Standard
The above code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 for the binary tree implements a depth-first traversal of the tree.
 We can see that by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 to an example tree:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "76col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t2: T2[Int] = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toList(t2)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(8, 3, 5, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent

\size footnotesize
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList(
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

)
\end_layout

\end_inset


\size small

\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Formula $=\left[8,3,5,4\right]$
\end_inset


\end_layout

\begin_layout Standard
Let us now implement another version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 that performs the 
\emph on
breadth-first
\emph default
 traversal of a binary tree.
 The idea is to prepare a list of all leaf values at level 
\begin_inset Formula $0$
\end_inset

 in the tree, then a list of all values at level 
\begin_inset Formula $1$
\end_inset

, and so on.
 At each level, values must be collected left to right.
 The result must be a list of lists.
 For instance, the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 has no values at level 
\begin_inset Formula $0$
\end_inset

, value 
\begin_inset Formula $8$
\end_inset

 at level 
\begin_inset Formula $1$
\end_inset

, value 
\begin_inset Formula $4$
\end_inset

 at level 
\begin_inset Formula $2$
\end_inset

, and values 
\begin_inset Formula $3$
\end_inset

 and 
\begin_inset Formula $5$
\end_inset

 at level 
\begin_inset Formula $3$
\end_inset

.
 So, we will implement a function (called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

) that computes a list of lists of the form 
\begin_inset Formula $\left[\left[\right],\left[8\right],\left[4\right],\left[3,5\right]\right]$
\end_inset

 for this tree, enumerating all leaf values level by level.
 Then we can 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 that list and obtain the list 
\begin_inset Formula $\left[8,4,3,5\right]$
\end_inset

, which is the breadth-first traversal order of the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Begin writing code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 by pattern matching on the tree structure:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toListBFS[A]: T2[A] => List[A] = toList2 andThen (_.flatten)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def toList2[A]: T2[A] => List[List[A]] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => List(List(a))    // Only one value at level 0.
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => ???         // Have toList2(l) and toList2(r).
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

After using recursive calls of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 on the left and right sub-trees (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

), we need somehow to combine the resulting lists.
 In the example of the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

, applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 to the sub-trees will return the lists 
\begin_inset Formula $\left[\left[8\right]\right]$
\end_inset

 and 
\begin_inset Formula $\left[\left[\right],\left[4\right],\left[3,5\right]\right]$
\end_inset

.
 We need to concatenate the corresponding nested lists and obtain 
\begin_inset Formula $\left[\left[\right],\left[8\right],\left[4\right],\left[3,5\right]\right]$
\end_inset

.
 (An initial empty list needs to be added because the sub-trees begin one
 level deeper.) The standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 operation will not work correctly since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 will truncate the longer list.
 However, here we need to keep the longer list's elements.
 So, let us implement a special helper function for merging the nested lists
 in this way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def listMerge[A](l: List[List[A]], r: List[List[A]]): List[List[A]] = (l,
 r) match {
\end_layout

\begin_layout Plain Layout

  case (Nil, r)               => r        // Keep the elements from the
 longer list.
\end_layout

\begin_layout Plain Layout

  case (l, Nil)               => l
\end_layout

\begin_layout Plain Layout

  case (lh :: lt, rh :: rt)   => (lh ++ rh) :: listMerge(lt, rt)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can complete the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toListBFS
\end_layout

\end_inset

, and run some tests:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList2[A]: T2[A] => List[List[A]] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => List(List(a)) // Only one value at level 0.
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => listMerge(Nil :: toList2(l), Nil :: toList2(r))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toList2(t2)
\end_layout

\begin_layout Plain Layout

res1: List[List[Int]] = List(List(), List(8), List(4), List(3, 5))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toListBFS(t2)
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(8, 4, 3, 5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For lists and other sequences, the easiest traversal orders are either direct
 or reverse.
 A direct traversal is implemented by the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, while a reverse-order traversal is done simply by applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

 method, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

la.reverse.foldLeft(...)(...)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method may be implemented with different traversal orders.
 For comparison, we show the code for the direct-ordered and reverse-ordered
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 traversals:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// This code assumes that F has typeclass instances for Applicative and
 Functor.
\end_layout

\begin_layout Plain Layout

def travList[A, B](f: A => F[B])(la: List[A]): F[List[B]] = la match {
\end_layout

\begin_layout Plain Layout

  case Nil            => Applicative[F].pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => f(head).map2(travList(f)(tail)) { (x, y) => x +:
 y }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def travRevList[A, B](f: A => F[B])(la: List[A]): F[List[B]] = la.reverse
 match {
\end_layout

\begin_layout Plain Layout

  case Nil            => Applicative[F].pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => f(head).map2(travRevList(f)(tail)) { (x, y) => y
 :+ x }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

First, we reverse the given list, so that 
\begin_inset Formula $F$
\end_inset

's effects are merged in the reverse order.
 Second, we recreate the original list structure wrapped under 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Standard
Implementing a breadth-first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for a tree is more difficult.
 It is not sufficient to convert the tree to a list in the breadth-first
 order and collect 
\begin_inset Formula $F$
\end_inset

's effects.
 We also need to restore the original tree structure wrapped under the applicati
ve functor 
\begin_inset Formula $F$
\end_inset

.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Decorating-a-tree-breadth-first-traversal"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show an example implementation of a breadth-first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Decorating a tree.
 I.
 Depth-first traversal
\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method for a given tree-like data structure may be used to perform various
 operations on trees, as long as those operations are described by the effect
 of some applicative functor 
\begin_inset Formula $F$
\end_inset

.
 
\end_layout

\begin_layout Standard
An example of a tree operation is 
\begin_inset Quotes eld
\end_inset

decorating
\begin_inset Quotes erd
\end_inset

, i.e., adding labels of some sort to each leaf.
 Since tree-like data types are functors that have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method, a simple decorating operation replaces each leaf with a function
 of the data at that leaf.
 For instance, we may add the value 
\begin_inset Formula $20$
\end_inset

 to each leaf:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t2 = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t2.map(x => x + 20)  // Assuming a Functor instance for T2[_].
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Leaf(28), Branch(Branch(Leaf(23), Leaf(25)), Leaf(24)))
\end_layout

\end_inset

This transforms the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 into 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 28 [ [ 23 25 ] 24 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

.
 However, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method works separately with each leaf and cannot use any information from
 previously computed values.
 We cannot use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to, e.g., implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 function for trees: to count the leaves and to label each leaf with its
 index value, transforming the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 into 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ (8,0) [ [ (3,1) (5,2) ] (4,3) ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 with added indices (
\begin_inset Formula $0$
\end_inset

, 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, 
\begin_inset Formula $3$
\end_inset

).
 For such tasks, we need the additional functionality of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation.
\end_layout

\begin_layout Standard
Labeling the leaves of a tree with their traversal index requires us to
 update some internal state (the number of leaves seen so far) while traversing
 the tree.
 Updating an internal state is the effect of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 Since all monads can also implement the applicative methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

), we may use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad as the applicative functor 
\begin_inset Formula $F$
\end_inset

 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
In this section, we will implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 for a depth-first tree traversal; let us call that function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDF
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDF
\end_layout

\end_inset

 will have the form:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class St[A](run: Int => (A, Int))    // A State monad with internal
 state of type Int.
\end_layout

\begin_layout Plain Layout

                         // Assume that we have defined Applicative and
 Functor instances for St.
\end_layout

\begin_layout Plain Layout

def computeIndex[A]: A => St[(A, Int)] = ???                 // Define the
 
\begin_inset Quotes eld
\end_inset

decoration
\begin_inset Quotes erd
\end_inset

 function.
\end_layout

\begin_layout Plain Layout

def zipWithIndexDF[A](tree: T2[A]): T2[(A, Int)] = {
\end_layout

\begin_layout Plain Layout

  val afterTraverse: St[T2[(A, Int)]] = trav[A, (A, Int), St](computeIndex)(tree
)
\end_layout

\begin_layout Plain Layout

  afterTraverse.run(0)._1                        // Run the State monad and
 get the result value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This will be a depth-first traversal if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 is the function shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It remains to define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

computeIndex
\end_layout

\end_inset

 describing the 
\begin_inset Quotes eld
\end_inset

decoration logic
\begin_inset Quotes erd
\end_inset

.
 Begin writing the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

computeIndex
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def computeIndex[A]: A => St[(A, Int)] = a => St { i => ???: ((A, Int),
 Int) }
\end_layout

\end_inset

Given a leaf value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 and a previous internal state 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i: Int
\end_layout

\end_inset

, we must compute the 
\begin_inset Quotes eld
\end_inset

decorated
\begin_inset Quotes erd
\end_inset

 leaf value of type 
\begin_inset Formula $A\times\text{Int}$
\end_inset

 as well as the new internal state.
 Since our goal is to label the leaves by the current leaf count, we use
 the internal state to keep the number of leaves seen so far.
 So, we just need to increment the internal state after copying it to a
 leaf:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def computeIndex[A]: A => St[(A, Int)] = a => St { i => ((a, i), i + 1)
 }
\end_layout

\end_inset

This completes the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDFS
\end_layout

\end_inset

, which we can now test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> zipWithIndexDF(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Leaf((8,0)), Branch(Branch(Leaf((3,1)), Leaf((5,2)
)), Leaf((4,3))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Decorating a tree.
 II.
 Breadth-first traversal
\begin_inset CommandInset label
LatexCommand label
name "subsec:Decorating-a-tree-breadth-first-traversal"

\end_inset


\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Aggregating-tree-like-data-bfs"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we have implemented a breadth-first folding for the tree data structure
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

.
 What additional code does a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 need? Folding over 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 merely needs to arrange the leaf values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in the breadth-first order, but a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function must return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[T2[B]]
\end_layout

\end_inset

.
 This requires to sequence the effects of an arbitrary applicative functor
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 in the breadth-first order, while gathering the values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 into a tree structure (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[B]
\end_layout

\end_inset

) wrapped under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toListBFS
\end_layout

\end_inset

 shown in the previous section is not sufficient for that purpose, because
 the tree structure cannot be reproduced if we only have a list of leaf
 values.
 Even the nested list computed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 is not sufficient.
 We need additional information about each leaf's position in the tree.
\end_layout

\begin_layout Standard
So, let us begin by adding the required position information to the nested
 list of leaf values.
 For each leaf, we need to store the path from the root of the tree.
 We can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type constructor and its subtypes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 for marking that path.
 For example, the position information for the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2 =
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 could be represented by the following nested list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(
\end_layout

\begin_layout Plain Layout

  List(),                                                // No leaves at
 level 0.
\end_layout

\begin_layout Plain Layout

  List( Left(8) ),                                       // One leaf at
 level 1.
\end_layout

\begin_layout Plain Layout

  List( Right(Right(4)) ),                               // One leaf at
 level 2.
\end_layout

\begin_layout Plain Layout

  List( Right(Left(Left(3))), Right(Left(Right(5))) ),   // Two leaves at
 level 3.
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

This data structure makes it easy to iterate over the leaf values in the
 breadth-first order.
 At the same time, it keeps enough information for restoring the original
 tree since each leaf value comes with the full path from the root of the
 tree.
\end_layout

\begin_layout Standard
An immediate problem with this data structure is a type mismatch in the
 outer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

: its elements are not of the same type because each subsequent sub-list
 contains data wrapped under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 more deeply.
 To make the types match, we need to implement a special list-like data
 structure whose first element has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

, the second element has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Either[A, A]]
\end_layout

\end_inset

, the third element has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Either[Either[A, A], Either[A, A]]]
\end_layout

\end_inset

, and so on.
 (A similar data type was shown in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-EvenList-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.) Let us call this data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

 (
\begin_inset Quotes eld
\end_inset

tree descriptor
\begin_inset Quotes erd
\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait TD[A]
\end_layout

\begin_layout Plain Layout

final case class Last[A](a: List[A]) extends TD[A]
\end_layout

\begin_layout Plain Layout

final case class More[A](a: List[A], tail: TD[Either[A, A]]) extends TD[A]
  
\end_layout

\end_inset

The tree descriptor for the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 shown above will then look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val td2: TD[Int] = More(List(), More(                          // No leaves
 at level 0.
\end_layout

\begin_layout Plain Layout

    List( Left(8) ), More(                                     // The leaf
 at level 1.
\end_layout

\begin_layout Plain Layout

      List( Right(Right(4)) ), Last(                           // The leaf
 at level 2.
\end_layout

\begin_layout Plain Layout

        List( Right(Left(Left(3))), Right(Left(Right(5))) ),   // Two leaves
 at level 3.
\end_layout

\begin_layout Plain Layout

))))
\end_layout

\end_inset

Now the types match, while a wrong number of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 wrappers will be a type error.
\end_layout

\begin_layout Standard
This representation of the tree descriptor is certainly not efficient in
 terms of memory consumption and processing speed.
 An 
\begin_inset Quotes eld
\end_inset

industry-strength
\begin_inset Quotes erd
\end_inset

 breadth-first tree traversal may use quite different data structures while
 implementing the same logic.
 For instance, one could use a bit vector 
\begin_inset Formula $\left[1,0,1\right]$
\end_inset

 instead of the wrapper 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(Left(Right()))
\end_layout

\end_inset

, avoiding the allocation of many objects in memory.
 However, our present goal is not to achieve high efficiency but to obtain
 correct code.
\end_layout

\begin_layout Standard
The next step is to write functions transforming between trees 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 and descriptors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t2ToTD[A]: T2[A] => TD[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = ???
\end_layout

\end_inset

Begin implementing the first function by pattern matching:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def t2ToTD[A]: T2[A] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => Last(List(a))                      // A leaf at
 level 0.
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => ( t2ToTD(l),  t2ToTD(r) ); ???     // How to combine
 the subtrees?
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It seems reasonable that we need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 recursively to the subtrees 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 in line 
\begin_inset Formula $3$
\end_inset

, obtaining the tree descriptors of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 for those subtrees.
 We still have to combine these tree descriptors in the correct way.
 Inspired by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

listMerge
\end_layout

\end_inset

 function from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Aggregating-tree-like-data-bfs"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we write the descriptor-merging code that concatenates the lists separately
 at each depth level:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def tdMerge[A](l: TD[A], r: TD[A]): TD[A] = (l, r) match {
\end_layout

\begin_layout Plain Layout

  case (Last(la), Last(lb))                 => Last(la ++ lb)
\end_layout

\begin_layout Plain Layout

  case (Last(la), More(lb, tail))           => More(la ++ lb, tail)
\end_layout

\begin_layout Plain Layout

  case (More(la, tail), Last(lb))           => More(la ++ lb, tail)
\end_layout

\begin_layout Plain Layout

  case (More(la, tailA), More(lb, tailB))   => More(la ++ lb, tdMerge(tailA,
 tailB))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

However, writing just 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdMerge(t2ToTD(l), t2ToTD(r))
\end_layout

\end_inset

 would not be correct in line 
\begin_inset Formula $3$
\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

.
 We need somehow to store the information that the subtrees 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 are located one level deeper at the left and at the right respectively.
 To see how that information needs to be stored, let us look at the tree
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 whose left and right subtrees are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l = 
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8  ]
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r =
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[  [ 3 5 ] 4  ]
\end_layout

\end_inset


\end_layout

\end_inset

.
 The descriptors of these subtrees are computed by recursive calls of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

, which (if implemented correctly) should yield the following:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

t2ToTD(l) == Last(List(8))                   // One leaf at level 0.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

t2ToTD(r) == More(List(), More(              // No leaves at level 0.
\end_layout

\begin_layout Plain Layout

  List( Right(4) ), Last(                    // One leaf at level 1.
\end_layout

\begin_layout Plain Layout

    List( Left(Left(3)), Left(Right(5)) )    // Two leaves at level 2.
\end_layout

\begin_layout Plain Layout

)))
\end_layout

\end_inset

The correct merging of these tree descriptors requires wrapping all data
 in the subtree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 in an additional 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

 layer and all data in the subtree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 in an additional 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right()
\end_layout

\end_inset

 layer.
 Let us implement two helper functions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRight
\end_layout

\end_inset

) for this transformation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def addLeft[A]: TD[A] => TD[Either[A, A]] = {
\end_layout

\begin_layout Plain Layout

  case Last(a)         => Last(a.map(Left(_)))
\end_layout

\begin_layout Plain Layout

  case More(a, tail)   => More(a.map(Left(_)), addLeft[Either[A, A]](tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def addRight[A]: TD[A] => TD[Either[A, A]] = {
\end_layout

\begin_layout Plain Layout

  case Last(a)         => Last(a.map(Right(_)))
\end_layout

\begin_layout Plain Layout

  case More(a, tail)   => More(a.map(Right(_)), addRight[Either[A, A]](tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

 We expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRight
\end_layout

\end_inset

 will transform the left and right subtree descriptors as follows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

addLeft(t2ToTD(l)) == Last(List(Left(8)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

addRight(t2ToTD(r)) == More( List(), More(
\end_layout

\begin_layout Plain Layout

  List( Right(Right(4)) ), Last(
\end_layout

\begin_layout Plain Layout

    List( Right(Left(Left(3))), Right(Left(Right(5))) )
\end_layout

\begin_layout Plain Layout

)))
\end_layout

\end_inset

It remains to mark the subtrees as being one layer deeper.
 We do this by inserting an empty list at the beginning of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

 structure.
 The types will then require that the subsequent lists must have one more
 layer of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 wrappers, which they will have after using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRight
\end_layout

\end_inset

.
 So, the correct merging of the two subtree descriptors is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

More(List(), tdMerge( addLeft(t2ToTD(l)), addRight(t2ToTD(r)) ))
\end_layout

\end_inset

The complete code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 becomes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t2ToTD[A]: T2[A] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => Last(List(a))
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => More(List(), tdMerge( addLeft(t2ToTD(l)), addRight(t2To
TD(r)) ))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can test this code on an example tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t2 = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t2ToTD(t2)
\end_layout

\begin_layout Plain Layout

res0: TD[Int] = More(List(), More(List(Left(8)), More(List(Right(Right(4))),
 Last(List(Right(Left(Left(3))), Right(Left(Right(5))))))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To implement the inverse function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

), it is important to keep in mind that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 will only create a certain subset of possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

.
 Looking at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

, we can see, for instance, that the first list is always empty when the
 tree has a branch; if the first list is not empty then that list will always
 contain only one element (the single leaf of the tree).
 We will never create values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 where the first list has more than one element, or where the first list
 is nonempty and there are also nonempty subsequent lists.
 Such values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 do not correspond to any valid trees.
 So, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 will be a 
\emph on
partial
\emph default
 function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A] => T2[A]
\end_layout

\end_inset

 that will assume valid tree descriptors, that is, values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 that were obtained by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTd
\end_layout

\end_inset

 to some trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

.
 The composition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD andThen tdToT2
\end_layout

\end_inset

 should be the identity function.
\end_layout

\begin_layout Standard
Begin writing the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 by pattern matching:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(List(a))   => Leaf(a)    // Tree has a single leaf at level
 0.
\end_layout

\begin_layout Plain Layout

  case _               => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Valid tree descriptors can only have a non-empty first list if the tree
 has a single leaf at level 
\begin_inset Formula $0$
\end_inset

.
 So, we may ignore all other cases and continue writing the code:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(List(a))        => Leaf(a)    // Tree has a single leaf at level
 0.
\end_layout

\begin_layout Plain Layout

  case More(List(a), _)     => Leaf(a)    // Tree has a single leaf at level
 0.
         
\end_layout

\begin_layout Plain Layout

  case More(List(), tail)   => ???        // Tree has two branches.
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In line 
\begin_inset Formula $4$
\end_inset

, we need to restore two branches of the tree from the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[Either[A, A]]
\end_layout

\end_inset

.
 How can we do that? The left branch contains all the leaf data from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

 where the outermost wrapper is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

.
 We can select just that subset of leaf data and remove the outermost 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

 wrapper via the following code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeLeft[A]: List[Either[A, A]] => List[A] = _.collect { case Left(x)
 => x }
\end_layout

\begin_layout Plain Layout

def filterLeft[A]: TD[Either[A, A]] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(la)         => Last(removeLeft(la))
\end_layout

\begin_layout Plain Layout

  case More(la, tail)   => More(removeLeft(la), filterLeft(tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

For example, applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterLeft
\end_layout

\end_inset

 to the descriptor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD(t2).tail
\end_layout

\end_inset

, we will get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

filterLeft(t2ToTD(t2).tail) == More(List(8), More(List(), Last(List())))
\end_layout

\end_inset

This tree descriptor corresponds to the left subtree of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In a similar way, we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterRight
\end_layout

\end_inset

 that extracts the descriptor data for the right subtree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeRight[A]: List[Either[A, A]] => List[A] = _.collect { case Right(x)
 => x }
\end_layout

\begin_layout Plain Layout

def filterRight[A]: TD[Either[A, A]] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(la)         => Last(removeRight(la))
\end_layout

\begin_layout Plain Layout

  case More(la, tail)   => More(removeRight(la), filterRight(tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> filterRight(t2ToTD(t2).tail)
\end_layout

\begin_layout Plain Layout

res1: TD[Int] = More(List(), More(List(Right(4)), Last(List(Left(Left(3)),
 Left(Right(5))))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we are ready to complete the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

.
 We use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterRight
\end_layout

\end_inset

 to obtain the descriptors for the left and the right subtrees.
 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 recursively to those descriptors will restore the two subtrees:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(List(a))        => Leaf(a)    // Tree has a single leaf at level
 0.
\end_layout

\begin_layout Plain Layout

  case More(List(a), _)     => Leaf(a)    // Tree has a single leaf at level
 0.
         
\end_layout

\begin_layout Plain Layout

  case More(List(), tail)   => Branch(tdToT2(filterLeft(tail)), tdToT2(filterRig
ht(tail)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> tdToT2(t2ToTD(t2)) == t2
\end_layout

\begin_layout Plain Layout

res2: Boolean = true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[_]
\end_layout

\end_inset

, which makes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[_]
\end_layout

\end_inset

 into a traversable functor.
 We will call its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travTD
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 for clarity.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 is essentially a decorated list of lists, we will need 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 (Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversable-seq"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which we here denote by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travList
\end_layout

\end_inset

.
 We will also need a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function for the functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def travEither[A, B, F[_]: Functor](f: A => F[B])(e: Either[A, A]): F[Either[B,
 B]] = e match {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => f(a).map(Left(_))
\end_layout

\begin_layout Plain Layout

  case Right(a)   => f(a).map(Right(_))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travList
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travEither
\end_layout

\end_inset

, we can now implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travTD
\end_layout

\end_inset

 as follows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def travTD[A, B, F[_]: Applicative : Functor](f: A => F[B])(td: TD[A]):
 F[TD[B]] = td match {
\end_layout

\begin_layout Plain Layout

  case Last(a)         => travList(f)(a).map(Last(_))
\end_layout

\begin_layout Plain Layout

  case More(a, tail)   =>
\end_layout

\begin_layout Plain Layout

    val headFB: F[List[B]] = travList(f)(a)
\end_layout

\begin_layout Plain Layout

    val tailFB: F[TD[Either[B, B]]] = travTD { x: Either[A, A] => travEither(f)(
x) }(tail)
\end_layout

\begin_layout Plain Layout

    (headFB zip tailFB).map { case (headB, tailB) => More(headB, tailB) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The final step is to convert 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

.
 We first compute the tree descriptor of a given tree and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travTD
\end_layout

\end_inset

 to perform a traversal.
 The result is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[TD[B]]
\end_layout

\end_inset

, which we convert into a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[T2[B]]
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 lifted to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def travBF[A, B, F[_]: Applicative : Functor](f: A => F[B])(tree: T2[A]):
 F[T2[B]] =
\end_layout

\begin_layout Plain Layout

  travTD(f)(t2ToTD(tree)).map(tdToT2) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This completes our implementation of a breadth-first traversal for binary
 trees.
 To test the code, we run the example of decorating a tree with the breadth-firs
t traversal index:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithIndexBF[A](tree: T2[A]): T2[(A, Int)] = {
\end_layout

\begin_layout Plain Layout

  val afterTraverse: St[T2[(A, Int)]] = travBF[A, (A, Int), St](computeIndex)(tr
ee)
\end_layout

\begin_layout Plain Layout

  afterTraverse.run(0)._1                        // Run the State monad and
 get the result value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithIndexBF(t2)
\end_layout

\begin_layout Plain Layout

res3: T2[(Int, Int)] = Branch(Leaf((8,0)), Branch(Branch(Leaf((3,2)), Leaf((5,3)
)), Leaf((4,1))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only difference between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDF
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexBF
\end_layout

\end_inset

 is the choice of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travBF
\end_layout

\end_inset

).
 The 
\begin_inset Quotes eld
\end_inset

decoration logic
\begin_inset Quotes erd
\end_inset

 is described by the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

computeIndex
\end_layout

\end_inset

 and does not depend on the traversal order.
 As a result, we gain flexibility: a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 with an arbitrary traversal order may be used with an arbitrary 
\begin_inset Quotes eld
\end_inset

decoration
\begin_inset Quotes erd
\end_inset

 logic.
 
\end_layout

\begin_layout Subsection
The 
\family typewriter
Traversable
\family default
 typeclass.
 Implementing 
\family typewriter
scanLeft
\family default
 via 
\family typewriter
traverse
\end_layout

\begin_layout Standard
We define a 
\begin_inset Quotes eld
\end_inset

traversable functor
\begin_inset Quotes erd
\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

) typeclass as having a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation, which is convenient to provide as an extension method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Traversable[L[_]] {
\end_layout

\begin_layout Plain Layout

  def trav[A, B, F[_]: Applicative: Functor](f: A => F[B])(la: L[A]): F[L[B]]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class TraversableOps[L[_]: Traversable, A](la: L[A]) {
\end_layout

\begin_layout Plain Layout

  def traverse[B, F[_]: Applicative : Functor](f: A => F[B]): F[L[B]] =
\end_layout

\begin_layout Plain Layout

    implicitly[Traversable[L]].trav(f)(la)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have mentioned in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-traverse-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation can be defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation transforms an initial sequence into a result value by updating
 some internal state.
 Another function similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

; the difference is that in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

, the result value is the 
\emph on
sequence
\emph default
 of all intermediate state values rather than just the last state value.
 Let us see how the functionality of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 can be expressed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad that handles the state updates.
 This will allow us to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 automatically for every traversable functor.
\end_layout

\begin_layout Standard
Assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

 is a traversable functor whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 function is available:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative: Functor](f: A => F[B])(la: L[A]): F[L[B]]
 = ...
\end_layout

\end_inset

We would like to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 with the following type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def scanLeft[A, Z](la: L[A])(init: Z)(f: (A, Z) => Z): L[Z] = ???
\end_layout

\end_inset

The standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 method for lists produces a list with an extra initial element, which is
 always equal to the initial value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

.
 This initial element is not essential and may be omitted from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

.
 In fact, we 
\emph on
need
\emph default
 to omit that initial element when we generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 to data types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

 other than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

, since those data types will not necessarily support adding one more data
 item.
\end_layout

\begin_layout Standard
In order to update the state of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 and also store it as the result of the traversal, we will use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad and compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[Z, Z]
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 with a suitable function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

accum
\end_layout

\end_inset

 that creates the required value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[Z, Z]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class State[Z, A](run: Z => (A, Z))
\end_layout

\begin_layout Plain Layout

    // Assume that the State monad has Applicative and Functor instances
 in scope.
\end_layout

\begin_layout Plain Layout

def accum[A, Z](a: A, f: (A, Z) => Z): State[Z, Z] = State { z =>
\end_layout

\begin_layout Plain Layout

  val newZ = f(a, z)  // Update the internal state using `f`.
\end_layout

\begin_layout Plain Layout

  (newZ, newZ)        // Store the internal state, and also return it as
 a result value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class TraversableScanOps[L[_] : Traversable, A](la: L[A]) {
\end_layout

\begin_layout Plain Layout

  def scanLeft[Z](init: Z)(f: (A, Z) => Z): L[Z] = la.traverse(a => accum(a,
 f)).run(init)._1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In this way, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 is made available for a wide class of data types (traversable functors).
\end_layout

\begin_layout Standard
To test this code, we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 via depth-first traverse for a tree of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithIndexDFS[A]: T2[A] => T2[(A, Int)] = 
\end_layout

\begin_layout Plain Layout

  _.scanLeft[(A, Int)]((null.asInstanceOf[A], -1)) { case (a, (_, i)) => (a,
 i + 1) }
\end_layout

\begin_layout Plain Layout

val t2 = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithIndexDFS(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Leaf((8,0)), Branch(Branch(Leaf((3,1)), Leaf((5,2)
)), Leaf((4,3))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tasks 
\emph on
not
\emph default
 implementable
\begin_inset CommandInset label
LatexCommand label
name "subsec:Tasks-not-implementable-via-traverse"

\end_inset

 via 
\family typewriter
traverse
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function is powerful since it can use an arbitrary applicative functor
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

.
 However, some computations are still not expressible via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 because they require information that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 cannot have.
 We will now look at two examples of this.
\end_layout

\begin_layout Standard
The first example is the depth labeling of a tree: each leaf gets a value
 equal to its depth.
 For instance, a depth-labeled tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 becomes 
\size tiny

\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ (8,1) [ [ (3,3) (5,3) ] (4,2) ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\size default
.
 This cannot be implemented via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 because it cannot detect nodes that have the same depth in the tree.
 To see this in more detail, recall that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 always collects and merges all the effects of a given functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

.
 If the effect of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 describes incrementing a counter (as in our examples involving the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad), the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 will increment that counter at 
\emph on
each
\emph default
 leaf.
 We may traverse the tree so that leaves at the same depth are traversed
 next to each other (as in the breadth-first traversal).
 But the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 cannot skip the incrementing when a leaf is at the same depth: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 does not receive any information about the position of values in the tree.
 So, we cannot label certain nodes with the same depth value but other nodes
 with a different depth value.
\end_layout

\begin_layout Standard
Depth labeling can be implemented as a special operation such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 for the tree type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithDepth[A](initial: Int = 0): T2[A] => T2[(A, Int)] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => Leaf((a, initial))
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => Branch(zipWithDepth(initial + 1)(l), zipWithDepth(initi
al + 1)(r))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

val t2: T2[Int] = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithDepth()(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Leaf((8,1)), Branch(Branch(Leaf((3,3)), Leaf((5,3)
)), Leaf((4,2))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
More generally, traversals cannot perform computations that depend on the
 
\emph on
position
\emph default
 of data in the tree (e.g., whether the data is in the left or in the right
 branch and at what depth).
 An example of such a computation is 
\begin_inset Quotes eld
\end_inset

pretty-printing
\begin_inset Quotes erd
\end_inset

 that converts trees into a text form.
 In the \SpecialChar LaTeX
 format used in this book, the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 is represented by the text 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ]
\end_layout

\end_inset

.
 We may write the following code for converting trees to this format:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def printLaTeX[A](t: T2[A])(toString: A => String): String = {
\end_layout

\begin_layout Plain Layout

  def printLaTeXSubtree: T2[A] => String = {
\end_layout

\begin_layout Plain Layout

    case Leaf(a)        => toString(a)
\end_layout

\begin_layout Plain Layout

    case Branch(l, r)   => "[ " + printLaTeXSubtree(l) + " " + printLaTeXSubtree
(r) + " ]"
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  "
\backslash

\backslash
Tree" + printLaTeXSubtree(t)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printLaTeX(t2)(_.toString)
\end_layout

\begin_layout Plain Layout

res1: String = 
\backslash
Tree[ [ 8 [ 3 5 ] ] 4 ]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using recursion schemes.
 I.
 Folding operations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Recursion-schemes.-folding"

\end_inset


\end_layout

\begin_layout Standard
The previous section showed two examples of folding and traversing operations
 that cannot be expressed through the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 methods and are instead implemented via custom recursive code.
 If we needed to implement the same operations for trees of different shapes
 or for other recursive data types, we would need to write new custom code
 for each new data type.
 That code will contain a certain common pattern: it will use recursive
 calls at the points where the recursive data type refers to itself.
 It turns out that we can implement this common pattern separately from
 the custom code, reducing the effort required for implementing the folding
 and traversing operations for different recursive data types.
\end_layout

\begin_layout Standard
To begin, write the recursive definition of the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
\text{T2}^{A}\triangleq A+\text{T2}^{A}\times\text{T2}^{A}\quad.
\]

\end_inset

This type refers recursively to itself in two places.
 To express that, define a bifunctor 
\begin_inset Formula $S^{A,R}$
\end_inset

:
\begin_inset Formula 
\[
S^{A,R}\triangleq A+R\times R\quad,
\]

\end_inset

and use it to rewrite the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

 as a recursive type equation: 
\begin_inset Formula $\text{T2}^{A}\triangleq S^{A,\text{T2}^{A}}$
\end_inset

.
 The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (R, R)]
\end_layout

\begin_layout Plain Layout

final case class T2[A](run: S[A, T2[A]])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bifunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
bifunctor
\end_layout

\end_inset

 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 is called the 
\series bold
recursion scheme
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
recursion scheme
\end_layout

\end_inset

 of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

.
 The recursion scheme describes the places where the recursive type refers
 to itself in its definition.
 All the recursive uses correspond to occurrences of the type parameter
 
\begin_inset Formula $R$
\end_inset

 in 
\begin_inset Formula $S^{A,R}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The ordinary folding operation, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, takes a function 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow Z$
\end_inset

 as a parameter:
\begin_inset Formula 
\[
\text{foldMap}_{L}(f^{:A\rightarrow Z}):L^{A}\rightarrow Z\quad,
\]

\end_inset

The function 
\begin_inset Formula $f$
\end_inset

 will be applied to all values of type 
\begin_inset Formula $A$
\end_inset

 stored inside 
\begin_inset Formula $L^{A}$
\end_inset

.
 As we have seen in the previous section, the function 
\begin_inset Formula $f^{:A\rightarrow Z}$
\end_inset

 cannot receive any information about the location of values of type 
\begin_inset Formula $A$
\end_inset

 inside 
\begin_inset Formula $L^{A}$
\end_inset

.
 In order to access that information and make the folding operation 
\begin_inset Quotes eld
\end_inset

location-aware
\begin_inset Quotes erd
\end_inset

, we need to change the type signature of 
\begin_inset Formula $f$
\end_inset

.
 To figure out the new type signature, let us look at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pls
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) from the previous section:
\begin_inset Formula 
\[
\text{pls}\triangleq\,\begin{array}{|c||c|}
 & \text{String}\\
\hline A & \text{toString}\\
\text{T2}^{A}\times\text{T2}^{A} & (\overline{\text{pls}}\boxtimes\overline{\text{pls}})\bef(l\times r\rightarrow\text{"[ "}+l+\text{" "}+r+\text{" ]"})
\end{array}\quad.
\]

\end_inset

We can rewrite this code using the bifunctor 
\begin_inset Formula $S^{A,R}\triangleq A+R\times R$
\end_inset

.
 In this example, the result type 
\begin_inset Formula $Z$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 By calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 recursively on the left and the right subtrees, we obtain two values of
 type 
\begin_inset Formula $Z$
\end_inset

.
 We can separate the recursive calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 from the custom string processing and express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 as the following function composition:
\begin_inset Formula 
\[
\text{pls}\triangleq\,\begin{array}{|c||cc|}
 & A & Z\times Z\\
\hline A & \text{id} & \bbnum 0\\
\text{T2}^{A}\times\text{T2}^{A} & \bbnum 0 & \overline{\text{pls}}\boxtimes\overline{\text{pls}}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & Z\\
\hline A & \text{toString}\\
Z\times Z & l\times r\rightarrow\text{"[ "}+l+\text{" "}+r+\text{" ]"}
\end{array}\quad.
\]

\end_inset

The intermediate result is a data structure of type 
\begin_inset Formula $A+Z\times Z$
\end_inset

, to which we need to apply some string manipulations.
 We note that the type 
\begin_inset Formula $A+Z\times Z$
\end_inset

 is the same as 
\begin_inset Formula $S^{A,Z}$
\end_inset

, while the first matrix in the code above is the lifting 
\begin_inset Formula $\overline{\text{pls}}^{\uparrow S^{A,\bullet}}$
\end_inset

 with respect to the type parameter 
\begin_inset Formula $R$
\end_inset

 of 
\begin_inset Formula $S^{A,R}$
\end_inset

.
 So, we may express the custom string manipulations specific to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 via a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLaTeX
\end_layout

\end_inset

 of type 
\begin_inset Formula $S^{A,Z}\rightarrow Z$
\end_inset

:
\begin_inset Formula 
\[
\text{toLaTeX}:S^{A,Z}\rightarrow Z\quad,\quad\quad\text{toLaTeX}\triangleq\,\begin{array}{|c||c|}
 & Z\\
\hline A & \text{toString}\\
Z\times Z & l\times r\rightarrow\text{"[ "}+l+\text{" "}+r+\text{" ]"}
\end{array}\quad.
\]

\end_inset

Using this function, the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 can be rewritten as:
\begin_inset Formula 
\[
\text{pls}\triangleq\overline{\text{pls}}^{\uparrow S^{A,\bullet}}\bef\text{toLaTeX}\quad.
\]

\end_inset

All custom 
\begin_inset Quotes eld
\end_inset

location-aware
\begin_inset Quotes erd
\end_inset

 logic is now encapsulated in the (non-recursive!) function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLaTeX
\end_layout

\end_inset

.
 So, we can now generalize the calculation by defining a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 function (denoted by 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

):
\begin_inset Formula 
\begin{equation}
\text{fold}_{S}:(S^{A,Z}\rightarrow Z)\rightarrow L^{A}\rightarrow Z\quad,\quad\quad\text{fold}_{S}(f)\triangleq\overline{\text{fold}_{S}(f)}^{\uparrow S^{A,\bullet}}\bef f\quad.\label{eq:fold-via-recursion-scheme-1}
\end{equation}

\end_inset

We then obtain 
\begin_inset Formula $\text{pls}=\text{fold}_{S}(\text{toLaTeX})$
\end_inset

.
 The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmapR[A, R, T](f: R => T): S[A, R] => S[A, T] = _.map { case (r1, r2)
 => (f(r1), f(r2)) }
\end_layout

\begin_layout Plain Layout

def foldS[A, Z](f: S[A, Z] => Z)(tree: T2[A]): Z = f(fmapR(foldS(f))(tree.run))
\end_layout

\begin_layout Plain Layout

def toLaTeX[A]: S[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case Left(a)         => a.toString
\end_layout

\begin_layout Plain Layout

  case Right((l, r))   => s"[ $l $r ]"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def printLaTeX[A](tree: T2[A]): String = "
\backslash

\backslash
Tree" + foldS[A, String](toLaTeX)(tree)
\end_layout

\begin_layout Plain Layout

val t2: T2[Int] = T2(Right((T2(Right((T2(Left(8)), T2(Right((T2(Left(3)),
 T2(Left(5)))))))), T2(Left(4)))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printLaTeX(t2)
\end_layout

\begin_layout Plain Layout

res0: String = 
\backslash
Tree[ [ 8 [ 3 5 ] ] 4 ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important that the function 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 may be implemented in the same way for all recursion schemes 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and for all result types 
\begin_inset Formula $Z$
\end_inset

 (which are no longer required to be monoids!).
 Each recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 defines a certain recursive type constructor 
\begin_inset Formula $L^{\bullet}$
\end_inset

.
 In previous chapters, we have seen examples where different recursion schemes
 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 were used to define lists, trees, and other recursive data types.
 So, the same code of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 will work for all those data types, as long as the recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and the corresponding lifting function (
\begin_inset Formula $^{\uparrow S^{A,\bullet}}$
\end_inset

) are available.
\end_layout

\begin_layout Standard
To illustrate the general applicability of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 to different data types, let us implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeX
\end_layout

\end_inset

 function for ordinary lists, for non-empty lists, and for rose trees (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rose-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type and the corresponding recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 may be defined by:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}\quad,\quad\quad S^{A,R}\triangleq\bbnum 1+A\times R\quad,\quad\quad\text{List}^{A}\triangleq S^{A,\text{List}^{A}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
A non-empty list type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

) and the corresponding recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 may be defined by:
\begin_inset Formula 
\[
\text{NEL}^{A}\triangleq A+A\times\text{NEL}^{A}\quad,\quad\quad S^{A,R}\triangleq A+A\times R\quad,\quad\quad\text{NEL}^{A}\triangleq S^{A,\text{NEL}^{A}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
A rose tree (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN
\end_layout

\end_inset

) and the corresponding recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 may be defined by:
\begin_inset Formula 
\[
\text{TreeN}^{A}\triangleq A+\text{NEL}^{\text{TreeN}^{A}}\quad,\quad\quad S^{A,R}\triangleq A+\text{NEL}^{R}\quad,\quad\quad\text{TreeN}^{A}\triangleq S^{A,\text{TreeN}^{A}}\quad.
\]

\end_inset

For rose trees, the recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 is itself a recursively defined type because it uses the non-empty list
 (NEL).
 This is not a problem: 
\begin_inset Formula $S^{A,R}$
\end_inset

 is still polynomial, which guarantees that any value of type 
\begin_inset Formula $S^{A,R}$
\end_inset

 contains a finite number of elements of types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 So, any value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 will contain a finite number of values of type 
\begin_inset Formula $A$
\end_inset

, assuring that the folding operation will terminate.
\end_layout

\begin_layout Standard
To avoid repetitive code, let us define all three data types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN
\end_layout

\end_inset

) at once through a universal recursive class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

 that takes the recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 as a type parameter:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S1[A, R] = Option[(A, R)]             // For List.
\end_layout

\begin_layout Plain Layout

type S2[A, R] = Either[A, (A, R)]          // For NEL.
\end_layout

\begin_layout Plain Layout

type S3[A, R] = Either[A, NEL[R]]          // For TreeN.
\end_layout

\begin_layout Plain Layout

final case class Fix[S[_, _], A](unfix: S[A, Fix[S, A]])
\end_layout

\end_inset

Using the universal class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

, we may write the equivalent definitions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 
\begin_inset Formula $\cong$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S1, A]
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL[A]
\end_layout

\end_inset

 
\begin_inset Formula $\cong$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S2, A]
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 
\begin_inset Formula $\cong$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S3, A]
\end_layout

\end_inset

.
 Some example values of these types are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x1 = Fix[S1, Int](Some((1, Fix[S1, Int](Some((2, Fix[S1, Int](Some((3,
 Fix[S1, Int](None))))))))))  // Equivalent to List(1, 2, 3) 
\end_layout

\begin_layout Plain Layout

val x2 = Fix[S2, Int](Right((1, Fix[S2, Int](Right((2, Fix[S2, Int](Left(3))))))
))  // NEL(1, 2, 3)
\end_layout

\begin_layout Plain Layout

val x3 = Fix[S3, Int](Right(NEL(Fix[S3, Int](Right(NEL(Fix[S3, Int](Left(8)),
 Fix[S3, Int](Right(NEL(Fix[S3, Int](Left(3)), Fix[S3, Int](Left(5)))))))),
 Fix[S3, Int](Left(4)))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is less convenient (and less efficient) to define data structures via
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

.
 We show these definitions only because they help understand how one can
 generalize 
\begin_inset Quotes eld
\end_inset

location-aware
\begin_inset Quotes erd
\end_inset

 folding operations to arbitrary recursive data types.
 (For clarity, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S3
\end_layout

\end_inset

 uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

 rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S2, A]
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard
To make the code of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 general, we add a functor typeclass constraint to 
\begin_inset Formula $S^{A,\bullet}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fold[A, Z, S[_,_]](f: S[A, Z] => Z)(t: Fix[S, A])(implicit fs: Functor[S[A,
 *]]): Z =
\end_layout

\begin_layout Plain Layout

  f(t.unfix.map(fold(f)))
\end_layout

\end_inset

Below we will assume that the appropriate functor instances are defined
 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S3
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It remains to implement functions with type signatures 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S[A, String] => String
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toLaTeX1[A]: S1[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case None                 => 
\begin_inset Quotes eld
\end_inset

Nil
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case Some((head, tail))   => head.toString + 
\begin_inset Quotes eld
\end_inset

, 
\begin_inset Quotes eld
\end_inset

 + tail
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def toLaTeX2[A]: S2[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case Left(a)               => a.toString
\end_layout

\begin_layout Plain Layout

  case Right((head, tail))   => head.toString + 
\begin_inset Quotes eld
\end_inset

, 
\begin_inset Quotes eld
\end_inset

 + tail
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def toLaTeX3[A]: S3[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case Left(a)      => a.toString
\end_layout

\begin_layout Plain Layout

  case Right(nel)   => 
\begin_inset Quotes eld
\end_inset

[ 
\begin_inset Quotes eld
\end_inset

 + nel.mkString(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes erd
\end_inset

) + 
\begin_inset Quotes eld
\end_inset

 ]
\begin_inset Quotes erd
\end_inset

 // Assume mkString() is defined for NEL.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now use 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 to convert some data structures to a \SpecialChar LaTeX
 form:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def listToLaTeX[A](t: Fix[S1, A]): String = 
\begin_inset Quotes eld
\end_inset

[ 
\begin_inset Quotes eld
\end_inset

 + fold[A, String, S1](toLaTeX1)(t) + 
\begin_inset Quotes eld
\end_inset

 ]
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

def nelToLaTeX[A](t: Fix[S2, A]): String = 
\begin_inset Quotes eld
\end_inset

[ 
\begin_inset Quotes eld
\end_inset

 + fold[A, String, S2](toLaTeX2)(t) + 
\begin_inset Quotes eld
\end_inset

 ]
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

def treeNToLaTeX[A](t: Fix[S3, A]): String = 
\begin_inset Quotes eld
\end_inset


\backslash

\backslash
Tree
\begin_inset Quotes eld
\end_inset

 + fold[A, String, S3](toLaTeX3)(t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> listToLaTeX(x1)
\end_layout

\begin_layout Plain Layout

res1: String = [ 1, 2, 3, Nil ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> nelToLaTeX(x2)
\end_layout

\begin_layout Plain Layout

res2: String = [ 1, 2, 3 ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> treeNToLaTeX(x3)
\end_layout

\begin_layout Plain Layout

res3: String = 
\backslash
Tree[ [ 8 [ 3 5 ] ] 4 ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The definition of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 calls itself recursively under the lifting (
\begin_inset Formula $\overline{\text{fold}_{S}(f)}^{\uparrow S^{A,\bullet}}$
\end_inset

).
 Is it guaranteed that this recursion terminates? The only way it can terminate
 is when the lifting 
\begin_inset Formula $f^{\uparrow S^{A,\bullet}}$
\end_inset

 does not 
\emph on
always
\emph default
 call the function 
\begin_inset Formula $f$
\end_inset

.
 This will happen if 
\begin_inset Formula $S^{A,R}$
\end_inset

 is a disjunctive type with some parts that do not depend on 
\begin_inset Formula $R$
\end_inset

.
 This is indeed the case for lists (
\begin_inset Formula $S^{A,R}\triangleq\bbnum 1+A\times R$
\end_inset

 or 
\begin_inset Formula $S^{A,R}\triangleq A+A\times R$
\end_inset

) and trees (
\begin_inset Formula $S^{A,R}\triangleq A+R\times R$
\end_inset

).
 Applying 
\begin_inset Formula $f^{\uparrow S^{A,\bullet}}$
\end_inset

 to values of 
\begin_inset Formula $R$
\end_inset

-independent types will be an identify function, not actually involving
 any calls of 
\begin_inset Formula $f$
\end_inset

.
 This will be the base case of recursion.
\end_layout

\begin_layout Standard
It remains to assure that the recursion reaches the base case with every
 value of type 
\begin_inset Formula $L^{A}$
\end_inset

; that is, no values of type 
\begin_inset Formula $L^{A}$
\end_inset

 cause an infinite loop in 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

.
 A simple example where 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 enters an infinite loop with the recursion scheme 
\begin_inset Formula $S^{A,R}\triangleq A+(\bbnum 1\rightarrow R)$
\end_inset

.
 Note that 
\begin_inset Formula $S^{A,R}$
\end_inset

 is non-polynomial due to the function type 
\begin_inset Formula $\bbnum 1\rightarrow R$
\end_inset

, which delays 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Due to having the function type as part of 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

, it is no longer polynomial.
\end_layout

\end_inset

the evaluation of the value of type 
\begin_inset Formula $R$
\end_inset

.
 This allows us to implement a well-defined, finite value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: L[A]
\end_layout

\end_inset

 which refers to itself under the delayed evaluation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, Unit => R]
\end_layout

\begin_layout Plain Layout

final case class Looping[A](run: S[A, Looping[A]])
\end_layout

\begin_layout Plain Layout

lazy val x: Looping[Int] = Looping(Right(_ => looping))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.run.right.get(())                      // No stack overflows.
\end_layout

\begin_layout Plain Layout

val res0: Looping[Int] = Looping(Right($Lambda$1123/1058984040@753aca85))
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.run.right.get(()).run.right.get(())    // This is again the same value:
\end_layout

\begin_layout Plain Layout

val res1: Looping[Int] = Looping(Right($Lambda$1123/1058984040@753aca85))
\end_layout

\end_inset

Trying to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold(f)(x)
\end_layout

\end_inset

 with any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 will result in an infinite loop.
\end_layout

\begin_layout Standard
It seems that we need to restrict recursion schemes 
\begin_inset Formula $S^{A,R}$
\end_inset

 to 
\emph on
polynomial
\emph default
 bifunctors.
 Such 
\begin_inset Formula $S^{A,R}$
\end_inset

 will define recursive polynomial functors 
\begin_inset Formula $L^{A}$
\end_inset

 that support no delayed evaluation of stored values of type 
\begin_inset Formula $A$
\end_inset

.
 So, any value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset Formula $L^{A}$
\end_inset

 will have to contain a finite number of values of type 
\begin_inset Formula $A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold(f)(x)
\end_layout

\end_inset

 is guaranteed to terminate for any terminating function 
\begin_inset Formula $f:S^{A,Z}\rightarrow Z$
\end_inset

.
\end_layout

\begin_layout Standard
Rather than working with the general 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 function and redefine all recursive types via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

, it is more convenient to implement and use specialized versions of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 for already defined recursive types.
 The general implementation of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-via-recursion-scheme-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be translated mechanically (e.g., using macros or code generators) into
 code specialized for a given data type and recursion scheme.
\end_layout

\begin_layout Standard
For instance, while the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S3[A, *]]
\end_layout

\end_inset

 shown above, it is easier to work with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

.
 The specialized version of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 has the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldTreeN[A, Z](f: S3[A, Z] => Z): TreeN[A] => Z = ???
\end_layout

\end_inset

The general definition of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-via-recursion-scheme-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows us how to write the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldTreeN
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldTreeN[A, Z](f: Either[A, NEL[Z]] => Z): TreeN[A] => Z = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)      => f(Left(a))
\end_layout

\begin_layout Plain Layout

  case Branch(ts)   => f(Right(ts.map(foldTreeN(f))))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Then we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeX
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def printLaTeX[A](tree: TreeN[A]): String = "
\backslash

\backslash
Tree" + foldTreeN[A, String](toLaTeX3)(tree)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another simple example of an aggregation operation that cannot be expressed
 as a traversal is the task of determining the maximum branching number
 of a given rose tree.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldTreeN
\end_layout

\end_inset

 allows us to implement that computation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxBranching[A]: TreeN[A] => Int = foldTreeN[A, Int] {
\end_layout

\begin_layout Plain Layout

  case Left(_)      => 0
\end_layout

\begin_layout Plain Layout

  case Right(nel)   => math.max(nel.max, nel.length)    // NEL must have `max`
 and `length` methods.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxBranching(x3)
\end_layout

\begin_layout Plain Layout

res2: Int = 2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using recursion schemes.
 II.
 Unfolding operations
\end_layout

\begin_layout Standard
A folding operation converts a collection to a single value.
 The opposite operation is 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

: converting a single value into a collection.
 By reversing the direction of certain function arrows in the type signature
 of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

, we can define a general 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

 method that uses an arbitrary recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 and an arbitrary function of type 
\begin_inset Formula $Z\rightarrow S^{A,Z}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{unfold}_{S}:(Z\rightarrow S^{A,Z})\rightarrow Z\rightarrow L^{A}\quad,\quad\text{unfold}_{S}(f)\triangleq f\bef\overline{\text{unfold}_{S}(f)}^{\uparrow S^{A,\bullet}}\quad\quad.\label{eq:unfold-via-recursion-scheme}
\end{equation}

\end_inset

Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ch2Converting-a-single"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed an unfolding operation for sequences: starting from an initial value,
 a function is applied repeatedly to compute further elements of the sequence.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 operation generalizes that computation to an arbitrary recursive type 
\begin_inset Formula $L^{A}$
\end_inset

 whose recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 is given.
 
\end_layout

\begin_layout Standard
To get more intuition, we look at some examples using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 with lists and binary trees.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-unfold-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 of consecutive powers of 
\begin_inset Formula $2$
\end_inset

 up to a given value 
\begin_inset Formula $n$
\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type Z = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def unfoldList[A, Z](f: Z => S[A, Z])(init: Z): List[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def powersOf2UpTo(n: Long): List[Long] = unfoldList(???)(???)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> powersOf2UpTo(1000)
\end_layout

\begin_layout Plain Layout

res0: List[Long] = List(1, 2, 4, 8, 16, 32, 64, 128, 256, 512)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The recursion scheme for a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $S^{A,R}\triangleq\bbnum 1+A\times R$
\end_inset

.
 Let us specialize the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:unfold-via-recursion-scheme"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Option[(A, R)]
\end_layout

\begin_layout Plain Layout

def unfoldList[A, Z](f: Z => S[A, Z])(init: Z): List[A] = f(init) match
 {
\end_layout

\begin_layout Plain Layout

  case None           => Nil
\end_layout

\begin_layout Plain Layout

  case Some((a, z))   => a :: unfoldList(f)(z)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now need to determine a suitable type 
\begin_inset Formula $Z$
\end_inset

 and a suitable function 
\begin_inset Formula $f:Z\rightarrow\bbnum 1+A\times Z$
\end_inset

 that we can 
\begin_inset Quotes eld
\end_inset

unfold
\begin_inset Quotes erd
\end_inset

 into the required sequence.
 If we are in the middle of unfolding, we need to produce the remaining
 portion of the list, say, 
\begin_inset Formula $\left[128,256,512\right]$
\end_inset

, given only a current value of type 
\begin_inset Formula $Z$
\end_inset

.
 We can do that if we keep track of the current initial power of 
\begin_inset Formula $2$
\end_inset

.
 So, let us choose 
\begin_inset Formula $Z\triangleq$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

 to represent that value; the type 
\begin_inset Formula $A$
\end_inset

 will be also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
How can we implement the function 
\begin_inset Formula $f$
\end_inset

? It should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $1+\bbnum 0$
\end_inset

) when the list is finished.
 When we are in the middle of generating the list, the call 
\begin_inset Formula $f(z)$
\end_inset

 should return 
\begin_inset Formula $\bbnum 0+a\times z^{\prime}$
\end_inset

 with some values 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $z^{\prime}$
\end_inset

.
 The value 
\begin_inset Formula $a$
\end_inset

 must be the new element of the list.
 The value 
\begin_inset Formula $z^{\prime}$
\end_inset

 will be passed to the next call of 
\begin_inset Formula $f$
\end_inset

.
 Since the next element must be twice the previous one, we must have 
\begin_inset Formula $a=z$
\end_inset

 and 
\begin_inset Formula $z^{\prime}=2*z$
\end_inset

.
 So, the code of 
\begin_inset Formula $f$
\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(n: Long): Long => Option[(Long, Long)] = { z => if (z >= n) None else
 Some((z, z * 2)) }
\end_layout

\end_inset

The code of 
\begin_inset Formula $f$
\end_inset

 is 
\emph on
not
\emph default
 recursive; the value 
\begin_inset Formula $n$
\end_inset

 is stored inside the nameless function returned by 
\begin_inset Formula $f(n)$
\end_inset

.
 We can now complete the solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def powersOf2UpTo(n: Long): List[Long] = unfoldList(f(n))(1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-unfold-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 for the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Use it to create 
\begin_inset Quotes eld
\end_inset

full
\begin_inset Quotes erd
\end_inset

 binary trees of given depth, e.g., 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ 0 1 ] [ 2 3 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 (depth 
\begin_inset Formula $2$
\end_inset

) and 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ [ 0 1 ] [ 2 3 ] ] [ [ 4 5 ] [ 6 7 ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 (depth 
\begin_inset Formula $3$
\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We adapt the general code in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:unfold-via-recursion-scheme"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to obtain the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (R, R)]
\end_layout

\begin_layout Plain Layout

def unfoldT2[A, Z](f: Z => S[A, Z])(init: Z): T2[A] = f(init) match {
\end_layout

\begin_layout Plain Layout

  case Left(a)           => Leaf(a)
\end_layout

\begin_layout Plain Layout

  case Right((z1, z2))   => Branch(unfoldT2(f)(z1), unfoldT2(f)(z2))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We plan to implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fullBinaryTree
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fullBinaryTree(n: Int): T2[Int] = {
\end_layout

\begin_layout Plain Layout

  type Z = ???
\end_layout

\begin_layout Plain Layout

  val init: Z = ???
\end_layout

\begin_layout Plain Layout

  val f: Z => Either[Int, (Z, Z)] = ???
\end_layout

\begin_layout Plain Layout

  unfoldT2[Int, Z](f)(init)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The next step is to choose a suitable type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 such that the unfolding procedure can generate trees of the required shape.
 To figure out what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 must be, we need to consider an intermediate step that generates a subtree
 of this tree at some point in the middle of 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

.
 For the tree of depth 
\begin_inset Formula $3$
\end_inset

 as shown above, an example of a subtree in the middle is 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 4 5 ]
\end_layout

\end_inset


\end_layout

\end_inset

.
 This subtree must be computed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2(f)(z)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
 The information needed for this computation is the initial value (
\begin_inset Formula $4$
\end_inset

) and the total number (
\begin_inset Formula $2$
\end_inset

) of the subtree's leaves.
 So, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 needs to contain two integers: the value of the first leaf and the size
 of the remaining subtree (which will always be a power of 
\begin_inset Formula $2$
\end_inset

).
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

type Z = (Int, Int)        // (k, m) where k is the first leaf$
\backslash
color{dkgreen}
\backslash
texttt{'}$s value and m is the subtree size.
\end_layout

\begin_layout Plain Layout

val init: Z = (0, 1 << n)  // The size of the tree is 2 to the power n.
\end_layout

\end_inset

The initial value for the entire tree shown above will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(0, 8)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Next, we figure out the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is applied to a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k, m)
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

, it should generate the corresponding subtree.
 If the subtree size 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 is 
\begin_inset Formula $1$
\end_inset

, the return value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(k)
\end_layout

\end_inset

.
 Otherwise, the return value should give two new values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 corresponding to the two next subtrees at one level deeper.
 These two subtrees have sizes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m / 2
\end_layout

\end_inset

 and initial values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k + m / 2
\end_layout

\end_inset

.
 So, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Z => Either[Int, (Z, Z)] = {
\end_layout

\begin_layout Plain Layout

  case (k, m) if m == 1   => Left(k)
\end_layout

\begin_layout Plain Layout

  case (k, m)             => Right(((k, m / 2), (k + m / 2, m / 2)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This completes the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fullBinaryTree
\end_layout

\end_inset

.
 To test the resulting code, compute a full tree
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "74col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fullBinaryTree(2)
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Branch(Leaf(0), Leaf(1)), Branch(Leaf(2), Leaf(3)))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
of depth 
\begin_inset Formula $2$
\end_inset

:
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ 0 1 ] [ 2 3 ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-unfold-tree-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-tree-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(n)
\end_layout

\end_inset

 that generates binary trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[Int]
\end_layout

\end_inset

 where the leaves have descending numbers from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, but all odd numbers are on the left and even numbers on the right.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(3)
\end_layout

\end_inset

 should generate the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 3 [ [ 1 0 ] 2 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(4)
\end_layout

\end_inset

 should give 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ 3 [ [ 1 0 ] 2 ] ] 4 ]
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We plan to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def evenOdd(n: Int): T2[Int] = {
\end_layout

\begin_layout Plain Layout

  type Z = ???
\end_layout

\begin_layout Plain Layout

  val init: Z = ???
\end_layout

\begin_layout Plain Layout

  val f: Z => Either[Int, (Z, Z)] = ???
\end_layout

\begin_layout Plain Layout

  unfoldT2[Int, Z](f)(init)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The examples with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(3)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(4)
\end_layout

\end_inset

 suggest that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(n)
\end_layout

\end_inset

 is a tree containing a leaf with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 and a subtree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(n - 1)
\end_layout

\end_inset

.
 Can we use the integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 as the initial value for unfolding? 
\end_layout

\begin_layout Standard
To figure this out, consider an intermediate stage of the unfolding process
 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 will apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to some intermediate value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z) == Left(k)
\end_layout

\end_inset

, we will get a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

.
 The other possibility is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z) == Right((z1, z2))
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

 are some values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
 This will generate a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 with two subtrees.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 will then apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

 in order to create the left and the right subtrees.
 The difference between those subtrees must come entirely from the difference
 between the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
In our case, we need to make either the left or the right subtree a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 depending on whether the initial leaf value is odd or even.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 cannot know that a call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z1)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z2)
\end_layout

\end_inset

 is used to generate a left or a right subtree, or that sometimes a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 must be made.
 This information can only come from the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

.
 So, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 must contain a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 flag indicating whether it is necessary to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 at the current place.
 For clarity, let us define the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 as a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Z(startAt: Int, makeLeaf: Boolean)
\end_layout

\begin_layout Plain Layout

val init = Z(startAt = n, makeLeaf = false)
\end_layout

\end_inset

When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeLeaf == true
\end_layout

\end_inset

, we should create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 should return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

.
 Otherwise, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 should return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((z1, z2))
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

 should set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeLeaf
\end_layout

\end_inset

 appropriately depending on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startAt
\end_layout

\end_inset

 being odd or even.
 Looking at the examples, we find that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 should also return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

 when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startAt == 0
\end_layout

\end_inset

.
 So, the complete code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Z => Either[Int, (Z, Z)] = {
\end_layout

\begin_layout Plain Layout

  case Z(n, false) if n > 0 && n % 2 == 0  => Right((Z(n - 1, false), Z(n,
 true)))
\end_layout

\begin_layout Plain Layout

  case Z(n, false) if n > 0 && n % 2 == 1  => Right((Z(n, true), Z(n - 1,
 false)))
\end_layout

\begin_layout Plain Layout

  case Z(n, _)                             => Left(n) // Make a leaf when
 n == 0 or makeLeaf == true.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd
\end_layout

\end_inset

 is now complete.
 To test:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "74col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> evenOdd(3)
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Leaf(3), Branch(Branch(Leaf(1), Leaf(0)), Leaf(2)))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 3 [ [ 1 0 ] 2 ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Is the recursion guaranteed to stop while evaluating 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

? During evaluation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold(f)(z)
\end_layout

\end_inset

 will recursively call 
\begin_inset Formula $f$
\end_inset

 whenever the value 
\begin_inset Formula $f(z)$
\end_inset

 of type 
\begin_inset Formula $S^{A,Z}$
\end_inset

 contains additional values of type 
\begin_inset Formula $Z$
\end_inset

.
 In the examples just shown, we used 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold(f)
\end_layout

\end_inset

 with a function 
\begin_inset Formula $f$
\end_inset

 that was specially designed to stop the recursion at the required places.
 For instance, if 
\begin_inset Formula $S^{A,Z}\triangleq A+Z\times Z$
\end_inset

, the function 
\begin_inset Formula $f$
\end_inset

 can return a value of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 to stop the unfolding.
\end_layout

\begin_layout Standard
However, the type signature 
\begin_inset Formula $f:Z\rightarrow S^{A,Z}$
\end_inset

 does not guarantee that 
\begin_inset Formula $f(z)$
\end_inset

 will return values that stop the unfolding at the right place.
 It is the programmer's responsibility to choose functions 
\begin_inset Formula $f$
\end_inset

 that do not cause infinite loops during unfolding.
 If 
\begin_inset Formula $S^{A,Z}\triangleq A+Z\times Z$
\end_inset

 and 
\begin_inset Formula $f(z)$
\end_inset

 always returns values of type 
\begin_inset Formula $\bbnum 0+Z\times Z$
\end_inset

 (for example, 
\begin_inset Formula $f(z)\triangleq\bbnum 0+z\times z$
\end_inset

), the unfolding operation will enter an infinite loop trying to construct
 a tree of infinite size.
 
\end_layout

\begin_layout Standard
Data structures in a computer's memory cannot have infinite size.
 To ensure that unfolding always terminates, we could use a data structure
 that delays the evaluation of some of its parts.
 Such data structures can imitate infinite lists or trees where further
 data items are evaluated on demand.
\end_layout

\begin_layout Standard
As an example, consider the recursion scheme 
\begin_inset Formula $S^{A,R}\triangleq A+(\bbnum 1\rightarrow R\times R)$
\end_inset

.
 The corresponding data type 
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset

 is a binary tree with a delayed evaluation of branches (but eager evaluation
 of leaves).
 This data structure supports unfolding with 
\emph on
any
\emph default
 function 
\begin_inset Formula $f:Z\rightarrow S^{A,Z}$
\end_inset

 because the recursive evaluation of 
\begin_inset Formula $f$
\end_inset

 at the branches is always delayed.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 can generate a value of type 
\begin_inset Formula $L^{A}$
\end_inset

 whose tree structure has the form 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 1 [ 2  [3 ...
 ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 with unbounded size:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, Unit => (R, R)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sealed trait UT[A]                // A tree with unevaluated branches.
\end_layout

\begin_layout Plain Layout

final case class ULeaf[A](a: A)                          extends UT[A]
\end_layout

\begin_layout Plain Layout

final case class UBranch[A](run: Unit => (UT[A], UT[A])) extends UT[A]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def unfoldUT[A, Z](f: Z => S[A, Z])(init: Z): UT[A] = f(init) match {
\end_layout

\begin_layout Plain Layout

  case Left(a)       => ULeaf(a)
\end_layout

\begin_layout Plain Layout

  case Right(func)   => UBranch { _ =>     // It is important to delay the
 evaluation of func(()).
\end_layout

\begin_layout Plain Layout

    val (z1, z2) = func(())
\end_layout

\begin_layout Plain Layout

    (unfoldUT(f)(z1), unfoldUT(f)(z2))     // Unfolding of further branches
 is also delayed.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val tree1toInf = unfoldUT[Int, (Int, Boolean)] { case (z, makeLeaf) =>
\end_layout

\begin_layout Plain Layout

  if (makeLeaf) Left(z) else Right(_ => ((z + 1, true), (z + 1, false)))
\end_layout

\begin_layout Plain Layout

}((0, false))
\end_layout

\end_inset

The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tree1toInf
\end_layout

\end_inset

 is finite but contains a potentially unbounded number of leaves computed
 on demand.
 To visualize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tree1toInf
\end_layout

\end_inset

, w write a function that converts 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

UT[A]
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 by stopping at a given maximum depth.
 The unevaluated parts of the tree will be marked with a value called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

default
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toT2[A](maxDepth: Int, default: A): UT[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case ULeaf(a)        => Leaf(a)e
\end_layout

\begin_layout Plain Layout

  case UBranch(func)   => if (maxDepth == 0) Leaf(default) else {
\end_layout

\begin_layout Plain Layout

    val (z1, z2) = func(())
\end_layout

\begin_layout Plain Layout

    Branch(toT2(maxDepth - 1, default)(z1), toT2(maxDepth - 1, default)(z2))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test this code, let us truncate the infinite structure 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tree1toInf
\end_layout

\end_inset

 at depth 
\begin_inset Formula $4$
\end_inset

.
 The result is a finite tree of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[Int]
\end_layout

\end_inset

, where the unevaluated part of the tree is shown as 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "65col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> toT2(maxDepth = 3, default = -1)(tree1toInf)
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Leaf(1), Branch(Leaf(2), Branch(Leaf(3), Branch(Leaf(4),
 Leaf(-1)))))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 1 [ 2  [3 [ 4 -1 ] ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using recursion schemes.
 III.
 Traversing operations
\end_layout

\begin_layout Standard
Folding with a recursion scheme (
\begin_inset Formula $\text{fold}_{S}$
\end_inset

) allows us to implement operations such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that cannot be expressed via ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 functions.
 Another operation not expressible via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

, which we implemented in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tasks-not-implementable-via-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

 through custom code.
 We will now implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 via a more general traversal operation (
\begin_inset Formula $\text{trav}_{S}$
\end_inset

) parameterized by an arbitrary recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and an arbitrary functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

.
\end_layout

\begin_layout Standard
To figure out the type signature of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

, consider the relationship between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, the ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\text{trav}_{L}$
\end_inset

), and 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{foldMap}_{L}(f^{:A\rightarrow Z}):L^{A}\rightarrow Z\quad,\quad\quad\text{trav}_{L}(f^{:A\rightarrow F^{B}}):L^{A}\rightarrow F^{L^{B}}\quad,\\
 & \text{fold}_{S}(f^{:S^{A,Z}\rightarrow Z}):L^{A}\rightarrow Z\quad,\quad\quad\text{trav}_{S}(f^{:???}):L^{A}\rightarrow F^{L^{B}}\quad.
\end{align*}

\end_inset

We recover 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 by setting the applicative functor 
\begin_inset Formula $F$
\end_inset

 as 
\begin_inset Formula $F^{B}\triangleq Z$
\end_inset

.
 So, we expect to obtain the type signature of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 from the type signature of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 if we replace 
\begin_inset Formula $Z$
\end_inset

 by 
\begin_inset Formula $F^{L^{B}}$
\end_inset

.
 The first argument 
\begin_inset Formula $f$
\end_inset

 of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 will then have the type 
\begin_inset Formula $S^{A,F^{L^{B}}}\rightarrow F^{L^{B}}$
\end_inset

:
\begin_inset Formula 
\[
\text{trav}_{S}:(S^{A,F^{L^{B}}}\rightarrow F^{L^{B}})\rightarrow L^{A}\rightarrow F^{L^{B}}\quad.
\]

\end_inset

To implement this method, begin with the type equivalence 
\begin_inset Formula $L^{A}\cong S^{A,L^{A}}$
\end_inset

.
 We can apply 
\begin_inset Formula $\text{trav}_{S}(f)$
\end_inset

 recursively to the values of type 
\begin_inset Formula $L^{A}$
\end_inset

 stored inside 
\begin_inset Formula $S^{A,L^{A}}$
\end_inset

 and obtain a value of type 
\begin_inset Formula $S^{A,F^{L^{B}}}$
\end_inset

:
\begin_inset Formula 
\[
\big(s^{:S^{A,L^{A}}}\triangleright\,\overline{\text{trav}_{S}(f)}^{\uparrow S^{A,\bullet}}\big):S^{A,F^{L^{B}}}\quad.
\]

\end_inset

It remains to apply 
\begin_inset Formula $f$
\end_inset

 to the last obtained value.
 This completes the code of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

: 
\begin_inset Formula 
\[
\text{trav}_{S}\big(f^{:S^{A,F^{L^{B}}}\rightarrow F^{L^{B}}}\big)\triangleq\overline{\text{trav}_{S}(f)}^{\uparrow S^{A,\bullet}}\bef f\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The method 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 works in the same way for all recursion schemes 
\begin_inset Formula $S$
\end_inset

 and for all type constructors 
\begin_inset Formula $F$
\end_inset

.
 This makes 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 powerful but hard to use because we need to work always with data structures
 defined via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

 type constructor.
 It is easier to use a specialized version of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 for the data structure at hand, similarly to what we did in the previous
 sections for folding and unfolding.
 
\end_layout

\begin_layout Standard
To illustrate this, let us implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 via a traversal with a binary tree recursion scheme.
 As in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we will use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad as the functor 
\begin_inset Formula $F$
\end_inset

 when running the traversal:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class St[A](run: Int => (A, Int))  { // A State monad with internal
 state of type Int.
\end_layout

\begin_layout Plain Layout

  import io.chymyst.ch.implement                // Implement the monad methods
 automatically.
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => St[B]): St[B] = implement
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): St[B] = implement
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def incrementAndGet: St[Int] = St(s => (s + 1, s + 1))  // Increment the
 current state value.
\end_layout

\begin_layout Plain Layout

def get: St[Int] = St(s => (s, s))             // Fetch the current state
 value.
\end_layout

\begin_layout Plain Layout

def set(s: Int): St[Unit] = St(_ => ((), s))   // Set the state, ignore
 previous state value.
\end_layout

\end_inset

Next, define the recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 and a specialized version of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 for trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (R, R)]          // Recursion scheme for T2[A].
\end_layout

\begin_layout Plain Layout

def travT2[A, B, F[_]](f: S[A, F[T2[B]]] => F[T2[B]]): T2[A] => F[T2[B]]
 = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => f(Left(a))
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => f(Right((travT2(f)(l), travT2(f)(r))))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It remains to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travT2
\end_layout

\end_inset

 to a suitable function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 The value of the internal state will represent the current depth of the
 tree element.
 We need to increment the depth whenever we find a branch and then traverse
 the two subtrees starting from the same depth value.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithDepth[A](tree: T2[A]): T2[(A, Int)] = travS[A, (A, Int), St]
 {
\end_layout

\begin_layout Plain Layout

  case Left(a) => for { s <- get } yield Leaf((a, s))   // Put the current
 depth into the Leaf value.
\end_layout

\begin_layout Plain Layout

  case Right((l, r))   => for {
\end_layout

\begin_layout Plain Layout

    s <- incrementAndGet   // Read the current depth after incrementing
 it.
\end_layout

\begin_layout Plain Layout

    x <- l                 // Traverse the left branch starting from depth
 `s`.
\end_layout

\begin_layout Plain Layout

    _ <- set(s)            // Set the same initial depth `s` for traversing
 the right branch.
       
\end_layout

\begin_layout Plain Layout

    y <- r                 // Traverse the right branch.
\end_layout

\begin_layout Plain Layout

  } yield Branch(x, y)
\end_layout

\begin_layout Plain Layout

}(tree).run(0)._1
\end_layout

\end_inset

To test this code, apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 to a sample tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 used earlier in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Decorating-a-tree-breadth-first-traversal"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tasks-not-implementable-via-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "70col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> zipWithDepth(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Branch(Leaf((8,2)), Branch(Leaf((3,3)), Leaf((5,3)
))), Leaf((4,1)))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ (8,2) [ (3,3) (5,3) ] ] (4,1) ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Note that we used the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set(s)
\end_layout

\end_inset

 with a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 obtained from a previous monadic computation.
 So, the code involves 
\begin_inset Formula $\text{trav}_{S}(f)$
\end_inset

 with a function 
\begin_inset Formula $f:S^{A,F^{L^{B}}\rightarrow F^{L^{B}}}$
\end_inset

 whose 
\begin_inset Formula $F$
\end_inset

-effect is 
\emph on
not
\emph default
 equivalent to an applicative functor's effect.
 We can see that the recursion scheme-based traversal (
\begin_inset Formula $\text{trav}_{S}$
\end_inset

) is more powerful than the plain traversal, 
\begin_inset Formula $\text{trav}_{L}(f^{:A\rightarrow F^{B}})$
\end_inset

, that only uses the applicative functor's methods of 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-7-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-7-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the following type constructors:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $F^{A}\triangleq\text{Int}+A+A\times A\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $F^{A}\triangleq(\text{String}+A)\times(\bbnum 1+A\times A)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A+A\times A\times F^{A}$
\end_inset

 (defined recursively).
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $F^{A}\triangleq(\bbnum 1+F^{A})\times(\bbnum 1+A\times F^{A})$
\end_inset

 (defined recursively).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the binary tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

), implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance for right-to-left depth-first traversal order.
 Use that to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

, and test that the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ 8 [ 3 5 ] ] 4 ] 
\end_layout

\end_inset


\end_layout

\end_inset

 is decorated with index as 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ (8,3) [ (3,2) (5,1) ] ] (4,0) ] 
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance for the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T3
\end_layout

\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-I-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the specialized version of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 for the binary tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to compute the maximum depth of a tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxDepth[A](tree: T2[A]): Int = foldT2(???)(???)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxDepth(Branch(Leaf(0), Branch(Branch(Leaf(0), Leaf(0)), Leaf(0))))
\end_layout

\begin_layout Plain Layout

res0: Int = 3
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T3[A]
\end_layout

\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-I-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, define a recursion scheme and implement a specialized version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT3
\end_layout

\end_inset

.
 Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT3
\end_layout

\end_inset

, write a function that generates ternary trees of the form 
\size tiny

\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[.3  0  [.2 0   1   0  ]   0  ] 
\end_layout

\end_inset


\end_layout

\end_inset


\size default
 starting from the given integer 
\begin_inset Formula $n$
\end_inset

 at the root.
\end_layout

\begin_layout Section
Laws and structure
\end_layout

\begin_layout Standard
To study the laws of the operations of folding and traversing, it helps
 to choose simpler but equivalent versions of these operations.
 We have seen four methods that implement folding operations: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

.
 With suitable naturality laws, these methods are equivalent.
\end_layout

\begin_layout Subsection
Equivalence of 
\family typewriter
foldLeft
\family default
, 
\family typewriter
foldMap
\family default
, 
\family typewriter
reduce
\family default
, and 
\family typewriter
toList
\family default
.
 Monoid morphisms
\end_layout

\begin_layout Standard
Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method assumes a non-empty sequence and will fail otherwise:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](la: Seq[A])(red: (A, A) => A): A
\end_layout

\end_inset

For the purposes of this section, we will modify 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 to supply a default value for empty sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduceE[A](la: Seq[A])(default: A)(red: (A, A) => A): A =
\end_layout

\begin_layout Plain Layout

if (la.isEmpty) default else reduce(la)(red)
\end_layout

\end_inset

Having a default value of type 
\begin_inset Formula $A$
\end_inset

 and a binary operation of type 
\begin_inset Formula $A\times A\rightarrow A$
\end_inset

 suggest that 
\begin_inset Formula $A$
\end_inset

 may be a monoid (assuming that the monoid laws hold, see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we rewrite the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass constraint:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduceE[A: Monoid](la: Seq[A]): A
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this change, let us compare the type signatures of the four methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, B](la: L[A])(init: B)(update: (B, A) => B): B
\end_layout

\begin_layout Plain Layout

def foldMap[M: Monoid, A](f: A => M): L[A] => M
\end_layout

\begin_layout Plain Layout

def reduceE[M: Monoid]: L[M] => M
\end_layout

\begin_layout Plain Layout

def toList[A]: L[A] => List[A]
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{foldLeft}_{L}:L^{A}\rightarrow B\rightarrow(B\times A\rightarrow B)\rightarrow B\quad,\quad\quad\text{foldMap}_{L}:(A\rightarrow M)\rightarrow L^{A}\rightarrow M\quad,\\
 & \text{reduceE}_{L}:L^{M}\rightarrow M\quad,\quad\quad\text{toList}_{L}:L^{A}\rightarrow\text{List}^{A}\quad.
\end{align*}

\end_inset

While 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 has the simplest type signature, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is used most often.
 We will now show that these four functions are equivalent, assuming certain
 naturality laws.
\end_layout

\begin_layout Standard
The formulation of naturality laws is different for functions whose type
 parameters have typeclass constraints.
 For example, consider 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 whose type parameter 
\begin_inset Formula $M$
\end_inset

 is constrained to be a monoid.
 The naturality law for functions 
\begin_inset Formula $\phi$
\end_inset

 with type signature 
\begin_inset Formula $\forall M.\,L^{M}\rightarrow M$
\end_inset

 (but without the typeclass constraint) is:
\begin_inset Formula 
\[
\text{for all }f^{:M\rightarrow N}\quad:\quad\quad\phi^{:L^{M}\rightarrow M}\bef f=f^{\uparrow L}\bef\phi^{:L^{N}\rightarrow N}\quad.
\]

\end_inset

Does this law hold with 
\begin_inset Formula $\phi=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

? Since we would need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 with type parameters 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, those types have to be monoids for the law to make sense.
 It turns out that the law must be used only with functions 
\begin_inset Formula $f$
\end_inset

 that satisfy certain conditions with respect to the monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 
\end_layout

\begin_layout Standard
To see why, let us set 
\begin_inset Formula $L=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 It is reasonable to assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 method should satisfy the naturality law, as long as we formulate that
 law correctly.
 We now apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 to an empty list and to a list with two elements of type 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Formula 
\[
\text{reduceE}\left(\left[\right]\right)=e_{M}\quad,\quad\quad\text{reduceE}\left(\left[x,y\right]\right)=x\oplus_{M}y\quad.
\]

\end_inset

Similar values are found when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 is used with the monoid 
\begin_inset Formula $N$
\end_inset

.
 Then we have:
\begin_inset Formula 
\begin{align*}
 & \left[\right]\triangleright\text{reduceE}\triangleright f=f(e_{M})\quad,\quad\quad\left[\right]\triangleright f^{\uparrow L}\triangleright\text{reduceE}=\left[\right]\triangleright\text{reduceE}=e_{N}\quad,\\
 & \left[x,y\right]\triangleright\text{reduceE}\triangleright f=(x\oplus_{M}y)\triangleright f=f(x\oplus_{M}y)\quad,\\
 & \left[x,y\right]\triangleright f^{\uparrow L}\triangleright\text{reduceE}=\left[f(x),f(y)\right]\triangleright\text{reduceE}=f(x)\oplus_{N}f(y)\quad.
\end{align*}

\end_inset

It follows that the law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 only if the function 
\begin_inset Formula $f$
\end_inset

 has the properties: 
\begin_inset Formula 
\[
f(e_{M})=e_{N}\quad,\quad\quad f(x\oplus_{M}y)=f(x)\oplus_{N}f(y)\quad.
\]

\end_inset

These properties mean that 
\begin_inset Formula $f:M\rightarrow N$
\end_inset

 is compatible with the structure of the monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, in the sense that 
\begin_inset Formula $f$
\end_inset

 maps the empty value 
\begin_inset Formula $e_{M}$
\end_inset

 to the empty value 
\begin_inset Formula $e_{N}$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

's binary operation to 
\begin_inset Formula $N$
\end_inset

's.
 Functions with these properties are called 
\begin_inset Quotes eld
\end_inset

monoid morphisms
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-monoid-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-monoid-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any two monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, a function 
\begin_inset Formula $\phi:M\rightarrow N$
\end_inset

 is a 
\series bold
monoid morphism
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monoid morphism|textit
\end_layout

\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 satisfies the following laws:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \phi(e_{M})=e_{N}\quad,\\
\text{composition law}:\quad & \phi(x^{:M}\oplus_{M}y^{:M})=\phi(x)\oplus_{N}\phi(y)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
monoidal naturality law
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monoidal naturality law
\end_layout

\end_inset

of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 is then formulated as:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement i
overhang 0in
width "20col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -205baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{2.8pc}L^{M}\ar[r]\sp(0.5){\ \text{reduceE}\ }\ar[d]\sp(0.45){\,f^{\uparrow L}} & M\ar[d]\sp(0.45){\,f}\\
L^{N}\ar[r]\sp(0.5){~\text{reduceE}\ } & N
}
\]

\end_inset


\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -40baselineskip%
\end_inset


\begin_inset Formula 
\begin{equation}
\text{reduceE}\bef f^{:M\rightarrow N}=f^{\uparrow L}\bef\text{reduceE}\quad,\label{eq:monoidal-naturality-law-of-reduceE}
\end{equation}

\end_inset

where the types 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 must be monoids and 
\begin_inset Formula $f:M\rightarrow N$
\end_inset

 is an arbitrary monoid morphism between 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 
\end_layout

\begin_layout Standard
The monoidal naturality law expresses a programmer's expectation that the
 code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE[M]
\end_layout

\end_inset

 should work in the same way for every monoid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 should be fully parametric and may use the monoid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

's methods but may not inspect the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

 via run-time reflection or make any decisions based on that.
 
\end_layout

\begin_layout Standard
With these definitions, we can now give a precise formulation of the following
 equivalences:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-foldleft-foldmap-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-foldleft-foldmap-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are equivalent as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 satisfies the naturality law with respect to its type parameter 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are equivalent as long as the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-transformation-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shown below holds and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 satisfies the monoidal naturality law with respect to its type parameter
 
\begin_inset Formula $M$
\end_inset

.
 
\end_layout

\begin_layout Standard
We will show in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:relational-property-for-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:Proofs-of-naturality-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-transformation-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is a consequence of parametricity.
 So, the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-transformation-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will hold automatically as long as the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is fully parametric.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The equivalence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 if we assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 satisfies the naturality law with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 To get that equivalence, we need to set 
\begin_inset Formula $F^{A}\triangleq L^{A}$
\end_inset

, 
\begin_inset Formula $G^{B}\triangleq M$
\end_inset

, and 
\begin_inset Formula $H^{B}\triangleq M$
\end_inset

 in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 A similar equivalence holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 if we reformulate its type signature in a form more similar to that of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 We change the order of curried arguments in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and also replace the updater function of type 
\begin_inset Formula $B\times A\rightarrow B$
\end_inset

 by an equivalent curried function of type 
\begin_inset Formula $A\rightarrow B\rightarrow B$
\end_inset

 (similarly to what was done in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:From-reduce-and-foldleft-to-foldmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The result is a function we denote by 
\begin_inset Formula $\text{fldl}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{fldl}_{L}^{B}:(A\rightarrow B\rightarrow B)\rightarrow L^{A}\rightarrow B\rightarrow B\quad,\quad\quad\text{fldl}_{L}(u^{:A\rightarrow B\rightarrow B})(p^{:L^{A}})(z^{:B})\triangleq\text{foldLeft}_{L}(p)(z)(\tilde{u})\quad,\\
 & \text{where we defined}\quad\tilde{u}^{:B\times A\rightarrow B}\triangleq b^{:B}\times a^{:A}\rightarrow u\left(a\right)(b)\quad.
\end{align*}

\end_inset

Setting 
\begin_inset Formula $F^{A}\triangleq L^{A}$
\end_inset

, 
\begin_inset Formula $G^{A}\triangleq B\rightarrow B$
\end_inset

, and 
\begin_inset Formula $H^{A}\triangleq B\rightarrow B$
\end_inset

 in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we obtain an equivalence between 
\begin_inset Formula $\text{fldl}_{L}$
\end_inset

 and a function with type signature 
\begin_inset Formula $L^{B\rightarrow B}\rightarrow B\rightarrow B$
\end_inset

 that we will temporarily denote by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 (
\begin_inset Quotes eld
\end_inset

fold with function
\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\[
\text{foldFn}:L^{B\rightarrow B}\rightarrow B\rightarrow B\quad,\quad\quad\text{foldFn}\,(p^{:L^{B\rightarrow B}})\triangleq\text{fldl}_{L}(\text{id}^{:(B\rightarrow B)\rightarrow B\rightarrow B})(p)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We will now prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are equivalent.
 The type signatures of these functions are similar except 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 uses the type 
\begin_inset Formula $B\rightarrow B$
\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 uses an arbitrary monoid 
\begin_inset Formula $M$
\end_inset

 (having an empty value 
\begin_inset Formula $e_{M}$
\end_inset

 and a binary operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

).
 The type of functions 
\begin_inset Formula $B\rightarrow B$
\end_inset

 is itself a monoid that we here denote by 
\begin_inset Formula $\text{MF}^{B}\triangleq B\rightarrow B$
\end_inset

.
 The empty value of that monoid is the identity function (
\begin_inset Formula $e_{_{\text{MF}^{B}}}=\text{id}^{:B\rightarrow B}$
\end_inset

), and the binary operation 
\begin_inset Formula $\ensuremath{\oplus}_{_{\text{MF}^{B}}}$
\end_inset

 is the (forward) function composition: 
\begin_inset Formula 
\[
p^{:B\rightarrow B}\oplus_{_{\text{MF}^{B}}}q^{:B\rightarrow B}\triangleq p\bef q\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To relate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

, we need to map an arbitrary monoid 
\begin_inset Formula $M$
\end_inset

 to the monoid 
\begin_inset Formula $\text{MF}^{M}$
\end_inset

:
\begin_inset Formula 
\[
\text{inMF}:M\rightarrow\text{MF}^{M}\quad,\quad\quad\text{inMF}\left(m\right)\triangleq n^{:M}\rightarrow n\oplus_{M}m\quad.
\]

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is just the monoid 
\begin_inset Formula $M$
\end_inset

's binary operation in a flipped and curried form:
\begin_inset Formula 
\[
\text{inMF}:M\rightarrow M\rightarrow M\quad,\quad\quad\text{inMF}\triangleq m\rightarrow n\rightarrow n\oplus_{M}m\quad.
\]

\end_inset

In particular, for any value 
\begin_inset Formula $m^{:M}$
\end_inset

 we have, due to the monoid 
\begin_inset Formula $M$
\end_inset

's identity law: 
\begin_inset Formula 
\begin{equation}
\text{inMF}\,(m)(e_{M})=e_{M}\oplus m=m\quad.\label{eq:identity-law-of-inMF}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is a monoid morphism because the two laws of Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-monoid-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 hold:
\begin_inset Formula 
\begin{align*}
 & \text{inMF}\,(e_{M})=n^{:M}\rightarrow n\oplus_{M}e_{M}=n^{:M}\rightarrow n=\text{id}=e_{_{\text{MF}^{M}}}\quad,\\
 & \text{inMF}\,(x\oplus_{M}y)=n^{:M}\rightarrow n\oplus_{M}x\oplus_{M}y\quad,\\
 & \text{inMF}\left(x\right)\oplus_{_{\text{MF}^{M}}}\text{inMF}\left(y\right)=\text{inMF}\left(x\right)\bef\text{inMF}\left(y\right)=(n\rightarrow n\oplus_{M}x)\bef(n\rightarrow n\oplus_{M}y)\\
 & \quad=n\rightarrow n\oplus_{M}x\oplus_{M}y=\text{inMF}\,(x\oplus_{M}y)\quad.
\end{align*}

\end_inset

Because of this, we may use 
\begin_inset Formula $f\triangleq\text{inMF}$
\end_inset

 in the monoidal naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 with monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N\triangleq\text{MF}^{M}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{reduceE}\bef\text{inMF}=\text{inMF}^{\uparrow L}\bef\text{reduceE}\quad.\label{eq:monoidal-naturality-law-of-reduceE-applied-to-inMF}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Now we can express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 through each other:
\begin_inset Formula 
\begin{align}
 & \text{foldFn}^{B}=\text{reduceE}^{\text{MF}^{B}}\quad\quad\text{where}\quad\quad\text{MF}^{B}\triangleq B\rightarrow B\quad,\label{eq:foldFn-via-reduceE}\\
 & \text{reduceE}\,(p^{:L^{M}})=\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})\quad.\label{eq:reduceE-via-foldFn}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
It remains to demonstrate the isomorphism between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 in both directions.
\end_layout

\begin_layout Standard

\series bold
1)
\series default
 For a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 with the type signature shown above, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{foldFn}^{\prime}(p^{:L^{B\rightarrow B}})=\text{reduceE}\,(p)=\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})\quad.
\end{align*}

\end_inset

Here the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is used with the type signature corresponding to the monoid 
\begin_inset Formula $M\triangleq B\rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{inMF}:\left(B\rightarrow B\right)\rightarrow\text{MF}^{B\rightarrow B}\cong\left(B\rightarrow B\right)\rightarrow\left(B\rightarrow B\right)\rightarrow B\rightarrow B\quad,\\
 & \text{inMF}\triangleq g^{:B\rightarrow B}\rightarrow h^{:B\rightarrow B}\rightarrow h\bef g\quad,\quad\quad e_{\text{MF}}\triangleq\text{id}^{:B\rightarrow B}.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We find that 
\begin_inset Formula $\text{foldFn}^{\prime}(p)=\text{foldFn}\,(p)$
\end_inset

 if we assume that the following law holds:
\begin_inset Formula 
\begin{equation}
\text{foldFn}^{B}(p^{:L^{B\rightarrow B}})=\text{foldFn}^{B\rightarrow B}(p\triangleright\text{inMF}^{\uparrow L})(\text{id}^{:B\rightarrow B})\quad.\label{eq:foldFn-transformation-law}
\end{equation}

\end_inset

This special law is a consequence of parametricity (as shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:relational-property-for-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
2)
\series default
 For a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 with the type signature shown above, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{reduceE}\left(p\right):\quad & \text{reduceE}^{\prime}(p^{:L^{M}})=\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})=\text{reduceE}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})\\
\text{rewrite using }\triangleright\text{-notation}:\quad & =e_{M}\triangleright\big(p\triangleright\gunderline{\text{inMF}^{\uparrow L}\bef\text{reduceE}}\big)\\
\text{use Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE-applied-to-inMF})}:\quad & =e_{M}\triangleright\big(p\triangleright\text{reduceE}\bef\text{inMF}\big)=\gunderline{\text{inMF}}\,(p\triangleright\text{reduceE})\gunderline{(e_{M})}\\
\text{use Eq.~(\ref{eq:identity-law-of-inMF})}:\quad & =p\triangleright\text{reduceE}=\text{reduceE}\,(p)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It remains to prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 defined via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will always satisfy the transformation law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-transformation-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{foldFn}\left(p\right):\quad & \text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{\text{MF}})=\text{reduceE}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{\text{MF}})\\
 & =e_{\text{MF}}\triangleright(p\triangleright\gunderline{\text{inMF}^{\uparrow L}\bef\text{reduceE}})\\
\text{use Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE-applied-to-inMF})}:\quad & =e_{\text{MF}}\triangleright\big(p\triangleright\text{reduceE}\bef\text{inMF}\big)=\gunderline{\text{inMF}}\,(p\triangleright\text{reduceE})\gunderline{(e_{\text{MF}})}\\
\text{use Eq.~(\ref{eq:identity-law-of-inMF})}:\quad & =p\triangleright\text{reduceE}=\text{reduceE}\,(p)=\text{foldFn}\,(p)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-reduceE-toList-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-reduceE-toList-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 are equivalent and are expressed as:
\begin_inset Formula 
\begin{align*}
 & \text{toList}:L^{A}\rightarrow\text{List}^{A}\quad,\quad\quad\text{toList}=\text{pu}_{\text{List}}^{\uparrow L}\bef\text{reduceE}^{\text{List}^{A}}\quad,\\
 & \text{reduceE}:L^{M}\rightarrow M\quad,\quad\quad\text{reduceE}=\text{toList}\bef\text{reduceList}\quad,
\end{align*}

\end_inset

if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 obeys the monoidal naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Here, 
\begin_inset Formula $\text{reduceE}^{\text{List}^{A}}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 applied to the monoidal type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

, with the list concatenation as the monoidal operation.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList[M]
\end_layout

\end_inset

 is defined for monoids 
\begin_inset Formula $M$
\end_inset

 by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduceList[M: Monoid]: List[M] => M = {
\end_layout

\begin_layout Plain Layout

  case Nil            => Monoid[M].empty
\end_layout

\begin_layout Plain Layout

  case head :: tail   => head |+| reduceList(tail)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{reduceList}:\text{List}^{M}\rightarrow M\quad,\quad\quad\text{reduceList}\triangleq\,\begin{array}{|c||c|}
 & M\\
\hline \bbnum 1 & e_{M}\\
M\times\text{List}^{M} & h^{:M}\times t^{:\text{List}^{M}}\rightarrow h\oplus_{M}\overline{\text{reduceList}}\left(t\right)
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
The difficulty with the laws of 
\family typewriter
foldMap
\family default
 and 
\family typewriter
reduce
\end_layout

\begin_layout Standard
The equivalence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 was ensured by assuming full parametricity, which entails various naturality
 laws.
 However, these laws do not fully describe the programmer's expectations
 about the behavior of folding operations.
 
\end_layout

\begin_layout Standard
To see why, let us consider 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $L^{A}\rightarrow\text{List}^{A}$
\end_inset

.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 is fully parametric, it will satisfy the naturality law:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow L}\bef\text{toList }=\text{toList}\bef f^{\uparrow\text{List}}\quad.
\]

\end_inset

This law describes the property that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList[A]
\end_layout

\end_inset

 works in the same way for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Certainly, programmers expect this property to hold.
 But the main intent of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 is to extract values of type 
\begin_inset Formula $A$
\end_inset

 out of 
\begin_inset Formula $L^{A}$
\end_inset

 and store them in a list.
 Naturality laws do not express this intent.
\end_layout

\begin_layout Standard
More precisely, programmers expect that for any 
\begin_inset Quotes eld
\end_inset

container
\begin_inset Quotes erd
\end_inset

 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList(p)
\end_layout

\end_inset

 should be a list of 
\emph on
all
\emph default
 values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 stored in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 As an example of unexpected behavior, imagine implementing the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 by a function that always returns an empty list.
 For 
\begin_inset Quotes eld
\end_inset

containers
\begin_inset Quotes erd
\end_inset

 that store some values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, this implementation would be unacceptable since it loses information (the
 code always ignores the argument and returns a fixed value).
\end_layout

\begin_layout Standard
In addition to the naturality law, we would like to impose a law that holds
 only when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 has extracted 
\emph on
every
\emph default
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 stored in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 Unfortunately, it seems to be impossible to express this property in the
 form of an equation satisfied by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

.
 Usually, the loss of information is prevented by imposing identity laws.
 But there seems to be no suitable formulation of an identity law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

.
 A way to formulate an identity law would be to require that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList(p)
\end_layout

\end_inset

 should extract some known values contained in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 But 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 works on values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

, with an unknown functor 
\begin_inset Formula $L$
\end_inset

.
 So, we cannot in general inject values into 
\begin_inset Formula $L$
\end_inset

 in some 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 way that would be guaranteed not to lose information.
\end_layout

\begin_layout Standard
Another approach to formulating laws is to look at the type signature and
 formulate a law similarly to other type signatures of that form.
 This approach works best with type signatures in the form of a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

, where a function of one type is transformed into a function of another
 type.
 We have summarized the methods of several standard typeclasses as 
\begin_inset Quotes eld
\end_inset

liftings
\begin_inset Quotes erd
\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-pattern-of-functorial-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The laws of a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 are the functor laws (identity and composition).
 Could we apply this approach to the folding operation? The type signature
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 function is:
\begin_inset Formula 
\[
\text{foldMap}:\left(A\rightarrow M\right)\rightarrow L^{A}\rightarrow M\quad.
\]

\end_inset

This resembles a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 from functions of type 
\begin_inset Formula $A\rightarrow M$
\end_inset

 to functions of type 
\begin_inset Formula $L^{A}\rightarrow M$
\end_inset

.
 However, we will not be able to impose the functor laws on these liftings.
 For instance, the functor composition law involves applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 to a composition of arguments.
 But the type signature 
\begin_inset Formula $A\rightarrow M$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

 is a fixed type) does not support composition, as we cannot compose 
\begin_inset Formula $A\rightarrow M$
\end_inset

 with 
\begin_inset Formula $B\rightarrow M$
\end_inset

.
\end_layout

\begin_layout Standard
So, the 
\begin_inset Quotes eld
\end_inset

formal
\begin_inset Quotes erd
\end_inset

 approach also fails to yield a suitable law for folding operations.
 However, we will see below that lifting-like laws may be imposed on the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation, whose type signature is a generalization of that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 We will show that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 forbid information-losing implementations.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 can be derived from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, we may take the position that the only acceptable implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are those derived from a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Subsection
Equivalence of 
\family typewriter
traverse
\family default
 and 
\family typewriter
sequence
\end_layout

\begin_layout Subsection
Laws of 
\family typewriter
traverse
\family default
 and 
\family typewriter
sequence
\end_layout

\begin_layout Subsection
Constructions of traversable functors
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All traversable functors are foldable because foldLeft can be implemented
 via traverse.
 Although the opposite is not true (traverse cannot be implemented via foldLeft)
, it turns out that all foldable functors are also traversable.
 However, this is not automatic (we cannot implement traverse via foldLeft).
 Foldable functors are traversable because all polynomial functors (including
 recursively defined polynomial functors) are foldable and no other functors
 are.
 ***
\end_layout

\begin_layout Standard
foldMap works in the same way for all monoids: monoidal naturality
\end_layout

\begin_layout Standard
traverse works in the same way for all applicative functors: applicative
 naturality
\end_layout

\begin_layout Section
Slides 
\end_layout

\begin_layout Standard
Which functors 
\begin_inset Formula $L$
\end_inset

 can have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation?
\end_layout

\begin_layout Standard
Can we express traverse through a simpler operation?
\end_layout

\begin_layout Standard
What are the required laws for traverse?
\end_layout

\begin_layout Standard
What about contrafunctors or profunctors?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Deriving the sequence operation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

The type signature of traverse is a complicated 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 is often equivalent to a simpler natural transformation
\end_layout

\begin_layout Standard
To derive it, ask: what is missing from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 to do the job of traverse?
\begin_inset Formula 
\[
\text{fmap}_{L}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow L^{F^{B}}
\]

\end_inset


\end_layout

\begin_layout Standard
We need 
\begin_inset Formula $F^{L^{B}}$
\end_inset

, but the traverse operation gives us 
\begin_inset Formula $L^{F^{B}}$
\end_inset

 instead
\end_layout

\begin_layout Standard
What's missing is a natural transformation sequence 
\begin_inset Formula $:L^{F^{B}}\rightarrow F^{L^{B}}$
\end_inset

 
\end_layout

\begin_layout Standard
The functions traverse and sequence are computationally equivalent:
\begin_inset Formula 
\[
\text{trav}(f^{:A\rightarrow F^{B}})=f^{\uparrow L}\bef\text{seq}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & L^{F^{B}}\ar[rd]\sp(0.45){\text{seq}}\\
L^{A}\ar[ru]\sp(0.45){\big(f^{:A\rightarrow F^{B}}\big)^{\uparrow L}}\ar[rr]\sb(0.45){\text{trav}\,f^{\underline{A\rightarrow F^{B}}}} &  & F^{L^{B}}
}
\]

\end_inset

Here 
\begin_inset Formula $F$
\end_inset

 is an arbitrary applicative functor
\end_layout

\begin_layout Standard
Keep in mind the example Future.sequence 
\begin_inset Formula $:\text{List}^{\text{Future}^{X}}\rightarrow\text{Future}^{\text{List}^{X}}$
\end_inset


\end_layout

\begin_layout Standard
Examples: 
\begin_inset Formula $L^{A}\triangleq A\times A\times A$
\end_inset

; 
\begin_inset Formula $L^{A}=\text{List}^{A}$
\end_inset

; finite trees 
\end_layout

\begin_layout Standard
Non-traversable: 
\begin_inset Formula $L^{A}\triangleq R\rightarrow A$
\end_inset

; lazy list (
\begin_inset Quotes eld
\end_inset

infinite product
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Note: We cannot have the opposite transformation 
\begin_inset Formula $F^{L^{B}}\rightarrow L^{F^{B}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Polynomial functors are traversable
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset

Generalize from the example 
\begin_inset Formula $L^{A}\triangleq A\times A\times A$
\end_inset

 to other polynomials
\end_layout

\begin_layout Standard
Polynomial functors have the form 
\begin_inset Formula 
\[
L^{A}\triangleq Z\times A\times...\times A+Y\times A\times...\times A+...+Q\times A+P
\]

\end_inset


\end_layout

\begin_layout Standard
To implement 
\begin_inset Formula $\text{seq}:L^{F^{B}}\rightarrow F^{L^{B}}$
\end_inset

, consider monomial 
\begin_inset Formula $L^{A}\triangleq Z\times A\times...\times A$
\end_inset


\end_layout

\begin_layout Standard
We have 
\begin_inset Formula $L^{F^{B}}=Z\times F^{B}\times...\times F^{B}$
\end_inset

; apply zip and get 
\begin_inset Formula $Z\times F^{B\times...\times B}$
\end_inset

 
\end_layout

\begin_layout Standard
Lift 
\begin_inset Formula $Z$
\end_inset

 into the functor 
\begin_inset Formula $F$
\end_inset

 using 
\begin_inset Formula $Z\rightarrow F^{A}\rightarrow F^{Z\times A}$
\end_inset

 (or with 
\begin_inset Formula $F.\text{pure}$
\end_inset

)
\end_layout

\begin_layout Standard
The result is 
\begin_inset Formula $F^{Z\times B\times...\times B}\triangleq F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
For a polynomial 
\begin_inset Formula $L^{A}$
\end_inset

, do this to each monomial, then lift to 
\begin_inset Formula $F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
Note that we could apply zip in various different orders
\end_layout

\begin_layout Standard
The traversal order is arbitrary, may be application-specific
\end_layout

\begin_layout Standard
Non-polynomial functors are not traversable (see 
\begin_inset CommandInset href
LatexCommand href
name "Bird et al., 2013"
target "http://www.cs.ox.ac.uk/jeremy.gibbons/publications/uitbaf.pdf"
literal "false"

\end_inset

)
\end_layout

\begin_layout Standard
Example: 
\begin_inset Formula $L^{A}\triangleq E\rightarrow A$
\end_inset

; 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

; can't have 
\begin_inset Formula $\text{seq}:L^{F^{B}}\rightarrow F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
All polynomial functors are traversable, and usually in several ways
\end_layout

\begin_layout Standard
It is still useful to have a typeclass for traversable functors because
 traversal order can vary
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Motivation for the laws of traverse 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset

The 
\begin_inset CommandInset href
LatexCommand href
name "law of traversals paper"
target "https://arxiv.org/pdf/1202.2919.pdf"
literal "false"

\end_inset

 by M.
\begin_inset space ~
\end_inset

Jaskelioff
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mauro Jaskelioff
\end_layout

\end_inset

 (2012) argues that traverse should 
\begin_inset Quotes eld
\end_inset

visit each element
\begin_inset Quotes erd
\end_inset

 of the container 
\begin_inset Formula $L^{A}$
\end_inset

 exactly once, and evaluate each corresponding 
\begin_inset Quotes eld
\end_inset

effect
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $F^{B}$
\end_inset

 exactly once; then they formulate the laws
\end_layout

\begin_layout Standard
To derive the laws, use the 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 intuition for traverse,
\begin_inset Formula 
\[
\text{trav}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}
\]

\end_inset


\end_layout

\begin_layout Standard
Look for 
\begin_inset Quotes eld
\end_inset

identity
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

composition
\begin_inset Quotes erd
\end_inset

 laws:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Identity
\begin_inset Quotes erd
\end_inset

 as pure 
\begin_inset Formula $:A\rightarrow F^{A}$
\end_inset

 must be lifted to pure 
\begin_inset Formula $:L^{A}\rightarrow F^{L^{A}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Identity
\begin_inset Quotes erd
\end_inset

 as 
\begin_inset Formula $\text{id}^{\underline{A\rightarrow A}}$
\end_inset

 with 
\begin_inset Formula $F^{A}\triangleq A$
\end_inset

 (identity functor) lifted to 
\begin_inset Formula $\text{id}^{\underline{L^{A}\rightarrow L^{A}}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Compose
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $f:A\rightarrow F^{B}$
\end_inset

 and 
\begin_inset Formula $g:B\rightarrow G^{C}$
\end_inset

 to get 
\begin_inset Formula $h:A\rightarrow F^{G^{C}}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

 are applicative; a traversal with 
\begin_inset Formula $h$
\end_inset

 maps 
\begin_inset Formula $L^{A}$
\end_inset

 to 
\begin_inset Formula $F^{G^{L^{C}}}$
\end_inset

 and must be equal to the composition of traversals with 
\begin_inset Formula $f$
\end_inset

 and then with 
\begin_inset Formula $g^{F\uparrow}$
\end_inset


\end_layout

\begin_layout Standard
Questions:
\end_layout

\begin_layout Standard
Are the laws for the sequence operation simpler?
\end_layout

\begin_layout Standard
Are all these laws independent?
\end_layout

\begin_layout Standard
What functors 
\begin_inset Formula $L$
\end_inset

 satisfy these laws for all applicative functors 
\begin_inset Formula $F$
\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Formulation of the laws for traverse 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Identity law: For any applicative functor 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula 
\[
\text{trav}\left(\text{pure}\right)=\text{pure}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc}\ L^{A}\ar[rr]\sp(0.45){\text{pure}^{\underline{L^{A}\rightarrow F^{L^{A}}}}}\ar[rr]\sb(0.45){\text{trav}\,(\text{pure}^{\underline{A\rightarrow F^{A}}})} &  & F^{L^{A}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Second identity law: 
\begin_inset Formula $\text{trav}^{\text{Id}}(\text{id}^{A})=\text{id}^{L^{A}}$
\end_inset

 is a consequence with 
\begin_inset Formula $F=\text{Id}$
\end_inset


\end_layout

\begin_layout Standard
So, we need only one identity law
\end_layout

\begin_layout Standard
Composition law: For any 
\begin_inset Formula $f^{\underline{A\rightarrow F^{B}}}$
\end_inset

 and 
\begin_inset Formula $g^{\underline{B\rightarrow G^{C}}}$
\end_inset

, & applicative 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

,
\begin_inset Formula 
\[
\text{trav}\,f\bef\left(\text{trav}\,g\right)^{F\uparrow}=\text{trav}\,\big(f\bef g^{F\uparrow}\big)
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{L^{B}}\ar[rd]\sp(0.55){\ \ \ \ \text{fmap}_{F}\big(\text{trav}^{G}\,g\big)^{\underline{L^{B}\rightarrow G^{L^{C}}}}}\\
L^{A}\ar[ru]\sp(0.45){\text{trav}^{F}\,f^{\underline{A\rightarrow F^{B}}}}\ar[rr]\sb(0.45){\text{trav}^{F^{G}}\,h^{\underline{A\rightarrow F^{G^{C}}}}} &  & F^{G^{L^{C}}}
}
\]

\end_inset

where 
\begin_inset Formula $h^{\underline{A\rightarrow F^{G^{C}}}}\triangleq f\bef g^{F\uparrow}$
\end_inset

.
 (Note: 
\begin_inset Formula $H^{A}\triangleq F^{G^{A}}$
\end_inset

 is applicative!)
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Derivation of the laws for sequence 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset

Express 
\begin_inset Formula $\text{trav}\,f=f^{L\uparrow}\bef\text{seq}$
\end_inset

 and substitute into the laws for 
\begin_inset Formula $\text{trav}$
\end_inset

:
\end_layout

\begin_layout Standard
Identity law: 
\begin_inset Formula $\text{trav}\left(\text{pure}\right)=\text{pure}^{L\uparrow}\bef\text{seq}=\text{pure}$
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & L^{F^{A}}\ar[rd]\sp(0.45){\text{seq}}\\
L^{A}\ar[rr]\sb(0.45){\text{pure}^{L^{A}}}\ar[ru]\sp(0.45){\text{fmap}_{L}\,\text{pure}^{A}} &  & F^{L^{A}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
Naturality law: 
\begin_inset Formula $\text{seq}\bef g^{F\uparrow L\uparrow}=g^{L\uparrow F\uparrow}\bef\text{seq}$
\end_inset

 with 
\begin_inset Formula $g^{\underline{A\rightarrow B}}$
\end_inset

, mapping 
\begin_inset Formula $L^{F^{A}}\rightarrow F^{L^{B}}$
\end_inset


\end_layout

\begin_layout Standard
Composition law: 
\begin_inset Formula 
\begin{align*}
\text{trav}\,f\bef\left(\text{trav}\,g\right)^{F\uparrow} & =f^{L\uparrow}\bef\text{seq}\bef\left(g^{L\uparrow}\bef seq\right)^{F\uparrow}\\
 & =f^{L\uparrow}\bef\text{seq}\bef g^{L\uparrow F\uparrow}\bef\text{seq}^{F\uparrow}=f^{L\uparrow}\bef g^{F\uparrow L\uparrow}\bef\text{seq}\bef\text{seq}^{F\uparrow}\\
\text{trav}\,\big(f\bef g^{F\uparrow}\big) & =\big(f\bef g^{F\uparrow}\big)^{L\uparrow}\bef\text{seq}=f^{L\uparrow}\bef g^{F\uparrow L\uparrow}\bef\text{seq}
\end{align*}

\end_inset

Now omit the common prefix 
\begin_inset Formula $f^{...}\bef g^{...}$
\end_inset

 (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-simplify-law-omit-lifted-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and obtain: 
\begin_inset Formula $\text{seq}\bef\text{seq}^{F\uparrow}=\text{seq}$
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{3pc} & F^{L^{G^{A}}}\ar[rd]\sp(0.6){\ (\text{seq}^{G})^{F\uparrow}}\\
L^{F^{G^{A}}}\ar[ru]\sp(0.45){\text{seq}^{F}}\ar[rr]\sb(0.45){\text{seq}^{F\circ G}} &  & F^{G^{L^{A}}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Constructions of traversable and bitraversable functors
\end_layout

\begin_layout Standard
Constructions of traversable functors:
\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq Z$
\end_inset

 (constant functor) and 
\begin_inset Formula $L^{A}\triangleq A$
\end_inset

 (identity functor)
\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq G^{A}\times H^{A}$
\end_inset

 for any traversable 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq G^{A}+H^{A}$
\end_inset

 for any traversable 
\begin_inset Formula $G^{A}$
\end_inset

 and 
\begin_inset Formula $H^{A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset

 (recursive) for a bitraversable bifunctor 
\begin_inset Formula $S^{A,B}$
\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L^{A}$
\end_inset

 is infinite, laws will appear to hold but seq will not terminate
\end_layout

\begin_layout Standard
A bifunctor 
\begin_inset Formula $S^{A,B}$
\end_inset

 is bitraversable if bisequence exists such that
\begin_inset Formula 
\[
\text{biseq}:S^{F^{A},F^{B}}\rightarrow F^{S^{A,B}}
\]

\end_inset

 for any applicative functor 
\begin_inset Formula $F$
\end_inset

; the analogous laws must hold
\end_layout

\begin_layout Standard
Constructions of bitraversable bifunctors:
\end_layout

\begin_layout Standard
\begin_inset Formula $S^{A,B}\triangleq Z$
\end_inset

, 
\begin_inset Formula $S^{A,B}\triangleq A$
\end_inset

, and 
\begin_inset Formula $S^{A,B}=B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S^{A,B}\triangleq G^{A,B}\times H^{A,B}$
\end_inset

 for any bitraversable 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S^{A,B}\triangleq G^{A,B}+H^{A,B}$
\end_inset

 for any bitraversable 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Standard
All polynomial bifunctors are bitraversable
\end_layout

\begin_layout Standard
All polynomial functors, including recursive functors, are traversable
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Traversable contrafunctors and profunctors are not useful
\end_layout

\begin_layout Standard
Traversing profunctors with respect to functors 
\begin_inset Formula $F$
\end_inset

: effects of 
\begin_inset Formula $F$
\end_inset

 are ignored
\end_layout

\begin_layout Standard
All contrafunctors 
\begin_inset Formula $C^{A}$
\end_inset

 are traversable w.r.t.
\begin_inset space ~
\end_inset

applicative profunctors 
\begin_inset Formula $F^{A}$
\end_inset

,
\begin_inset Formula 
\[
\text{seq}:C^{F^{A}}\rightarrow F^{C^{A}}\triangleq\text{pure}^{C\downarrow}\bef\text{pure}
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{C^{F^{A}}\ar[r]\sp(0.5){\text{cmap}_{C}\text{pure}_{F}^{A}}\xyScaleY{0.2pc}\xyScaleX{3pc} & C^{A}\ar[r]\sp(0.5){\text{pure}_{F}^{C^{A}}} & F^{C^{A}}}
\]

\end_inset


\end_layout

\begin_layout Standard
But not profunctors that are neither functors not contrafunctors
\end_layout

\begin_layout Standard
Counterexample: 
\begin_inset Formula $P^{A}\triangleq A\rightarrow A$
\end_inset

; need 
\begin_inset Formula $\text{seq}:\left(F^{A}\rightarrow F^{A}\right)\rightarrow F^{A\rightarrow A}$
\end_inset

; we can't get an 
\begin_inset Formula $A\rightarrow A$
\end_inset

, so the only implementation is to return 
\begin_inset Formula $\text{pure}_{F}\left(\text{id}\right)$
\end_inset

, which ignores its argument and so will fail the identity law 
\end_layout

\begin_layout Standard
Traversing profunctors 
\begin_inset Formula $L$
\end_inset

 with respect to profunctors 
\begin_inset Formula $F$
\end_inset

: effects are ignored
\end_layout

\begin_layout Standard
Counterexample 1: contrafunctor 
\begin_inset Formula $L^{A}\triangleq A\rightarrow R$
\end_inset

 and contrafunctor 
\begin_inset Formula $F^{A}\triangleq A\rightarrow S$
\end_inset

, a seq of type 
\begin_inset Formula $L^{F^{A}}\rightarrow F^{L^{A}}$
\end_inset

 must return ***
\end_layout

\begin_layout Standard
Counterexample 2: contrafunctor 
\begin_inset Formula $F^{A}\triangleq\left(R\rightarrow A\right)\rightarrow S$
\end_inset

 and functor 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A$
\end_inset

; seq must return 
\begin_inset Formula $1+\bbnum 0$
\end_inset


\end_layout

\begin_layout Standard
So, the result is trivial and probably not useful
\end_layout

\begin_layout Standard
Laws of traversables allow ignoring the effects of 
\begin_inset Formula $F$
\end_inset

 ! Not sure how to specify that the effects cannot be ignored.
 Does the applicative naturality in 
\begin_inset Formula $F$
\end_inset

 help?
\end_layout

\begin_layout Paragraph
Naturality with respect to applicative functor as parameter
\end_layout

\begin_layout Standard
The traverse method must be 
\begin_inset Quotes eld
\end_inset

generic in the functor 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\text{trav}^{F,A,B}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}
\]

\end_inset

Which means: The code of traverse can only use pure and zip from 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Standard
A functor 
\begin_inset Formula $F^{A}$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

generic in 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

: have 
\begin_inset Formula $\text{fmap}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Generic in 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 means mapping 
\begin_inset Formula $\left(F\rightarrow G\right)\rightarrow\text{trav}^{F}\rightarrow\text{trav}^{G}$
\end_inset

 in some way
\end_layout

\begin_layout Standard
Mathematical formulation:
\end_layout

\begin_layout Standard
For any natural transformation 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

 between applicative functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 such that 
\begin_inset Formula $F.\text{pure}$
\end_inset

 and 
\begin_inset Formula $F.\text{zip}$
\end_inset

 are mapped into 
\begin_inset Formula $G.\text{pure}$
\end_inset

 and 
\begin_inset Formula $G.\text{zip}$
\end_inset

, the result of transforming 
\begin_inset Formula $\text{trav}^{F}$
\end_inset

 is 
\begin_inset Formula $\text{trav}^{G}$
\end_inset


\end_layout

\begin_layout Standard
Such a natural transformation is a morphism of applicative functors
\end_layout

\begin_layout Standard
Category theory can describe 
\begin_inset Formula $\left(F\rightarrow G\right)\rightarrow\text{trav}^{F}\rightarrow\text{trav}^{G}$
\end_inset

 as a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Use a more general definition of category than what we had so far (morphisms
 between type constructors)
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that any traversable functor 
\begin_inset Formula $L$
\end_inset

 admits a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{consume}_{L}:(L^{A}\rightarrow B)\rightarrow L^{F^{A}}\rightarrow F^{B}\quad,
\]

\end_inset

defined for any applicative functor 
\begin_inset Formula $F$
\end_inset

.
 Assuming a suitable naturality law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

, show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 are equivalent.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
First, we express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 and back.
\begin_inset Formula 
\begin{align}
 & \text{consume}_{L}(f^{:L^{A}\rightarrow B})(p^{:L^{F^{A}}})=p\triangleright\text{seq}_{L}\triangleright f^{\uparrow F}\quad,\quad\text{or equivalently}:\quad\text{consume}_{L}(f)=\text{seq}_{L}\bef f^{\uparrow F}\quad,\label{eq:consume-via-seq}\\
 & \text{seq}_{L}=\text{consume}_{L}(\text{id}^{:L^{A}\rightarrow L^{A}})\quad.\label{eq:seq-via-consume}
\end{align}

\end_inset

The pattern is similar to that in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and to the equivalence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
We need to derive the equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 in both directions.
 To figure out the necessary naturality law, we begin with the direction
 that restores 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 is the more complicated function (having two type parameters).
\end_layout

\begin_layout Plain Layout

\series bold
(a)
\series default
 Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:seq-via-consume"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:consume-via-seq"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then we need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 equals 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

.
 For an arbitrary 
\begin_inset Formula $f^{:L^{A}\rightarrow B}$
\end_inset

, we write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{consume}_{L}(f):\quad & \text{consume}_{L}^{\prime}(f)=\text{seq}_{L}\bef f^{\uparrow F}=\text{consume}_{L}(\text{id})\bef f^{\uparrow F}=???
\end{align*}

\end_inset

If we know nothing about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

, we cannot conclude that 
\begin_inset Formula $\text{consume}_{L}(f)\overset{?}{=}\text{consume}_{L}(\text{id})\bef f^{\uparrow F}$
\end_inset

 because the function 
\begin_inset Formula $f$
\end_inset

 is arbitrary and the value 
\begin_inset Formula $\text{consume}_{L}(f)$
\end_inset

 does not need to be related in any way to 
\begin_inset Formula $\text{consume}_{L}(\text{id})$
\end_inset

.
 It appears that we need a naturality law involving a lifted function applied
 after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{consume}_{L}(f^{:L^{A}\rightarrow B})\bef(g^{:B\rightarrow C})^{\uparrow F}=\text{consume}_{L}(f\bef g)\quad.\label{eq:consume-naturality-law}
\end{equation}

\end_inset

If this law holds, we can derive the required equation:
\begin_inset Formula 
\[
\text{consume}_{L}^{\prime}(f)=\text{consume}_{L}(\text{id})\bef f^{\uparrow F}=\text{consume}_{L}(\text{id}\bef f)=\text{consume}_{L}(f)\quad.
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
(b)
\series default
 Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

, we first define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:consume-via-seq"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:seq-via-consume"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We then show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 equals 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{seq}_{L}^{\prime}=\text{consume}_{L}(\text{id})=\text{seq}_{L}\bef\gunderline{\text{id}^{\uparrow F}}=\text{seq}\quad.
\]

\end_inset


\end_layout

\begin_layout Plain Layout
If a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

, the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:consume-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will hold automatically:
\begin_inset Formula 
\[
\text{consume}_{L}(f)\bef g^{\uparrow F}=\text{seq}_{L}\bef\gunderline{f^{\uparrow F}\bef g^{\uparrow F}}=\text{seq}_{L}\bef(f\bef g)^{\uparrow F}=\text{consume}_{L}\left(f\bef g\right)\quad.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a lawful traversable functor 
\begin_inset Formula $L$
\end_inset

, show that 
\begin_inset Formula $\text{seq}_{L}^{:L^{F^{A}}\rightarrow F^{L^{A}}}=\text{id}$
\end_inset

 if we choose 
\begin_inset Formula $F^{A}\triangleq A$
\end_inset

 (the identity functor).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the identity law is 
\emph on
not
\emph default
 satisfied by the implementation of 
\begin_inset Formula $\text{seq}:L^{F^{A}}\rightarrow F^{L^{A}}$
\end_inset

 for 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

seq
\end_layout

\end_inset

 always returns an empty option (
\begin_inset Formula $1+\bbnum 0$
\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 in Scala).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $K^{A}\triangleq G^{H^{A}}$
\end_inset

 is traversable if 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are traversable.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that all the bitraversable laws hold for the bifunctor 
\begin_inset Formula $S^{A,B}\triangleq A\times B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the tree-like type defined as 
\begin_inset Formula $T^{A}\triangleq\bbnum 1+A\times T^{A}\times T^{A}$
\end_inset

, define a traversable instance.
 Verify that the laws hold, using a suitable bifunctor 
\begin_inset Formula $S^{X,Y}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Is the recursive type constructor 
\begin_inset Formula $L^{A}\triangleq A+L^{\text{List}^{A}}$
\end_inset

 traversable? Explain via examples what sort of data container it is.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that for any two monoid morphisms 
\begin_inset Formula $\phi:M\rightarrow N$
\end_inset

 and 
\begin_inset Formula $\psi:N\rightarrow P$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

, and 
\begin_inset Formula $P$
\end_inset

 are monoids), the composition 
\begin_inset Formula $\phi\bef\psi:M\rightarrow P$
\end_inset

 is again a monoid morphism.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monad 
\begin_inset Formula $M$
\end_inset

 and a monoid morphism 
\begin_inset Formula $\phi^{:R\rightarrow S}$
\end_inset

 between some monoid types 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, prove that 
\begin_inset Formula $\phi^{\uparrow M}:M^{R}\rightarrow M^{S}$
\end_inset

 is also a monoid morphism.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
The empty elements of the monoids 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 (by definition) are 
\begin_inset Formula $\text{pu}_{M}(e_{R})$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{M}(e_{S})$
\end_inset

 respectively.
 The binary operations of 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are
\begin_inset Formula 
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{M^{S}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:S}\rightarrow q\triangleright(v^{:S}\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

To verify the properties of a monoid morphism, begin with the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }e_{M^{S}}:\quad & \gunderline{e_{M^{R}}}\triangleright\phi^{\uparrow M}=e_{R}\triangleright\gunderline{\text{pu}_{M}\triangleright\phi^{\uparrow M}}=\gunderline{e_{R}\triangleright\phi}\triangleright\text{pu}_{M}=e_{S}\triangleright\text{pu}_{M}=e_{M^{S}}\quad.
\end{align*}

\end_inset

Now check the composition law: for any 
\begin_inset Formula $p^{:M^{R}}$
\end_inset

 and 
\begin_inset Formula $q^{:M^{R}}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}:\quad & (p\triangleright\phi^{\uparrow M})\underset{M^{S}}{\oplus}(q\triangleright\phi^{\uparrow M})\\
 & =(p\triangleright\gunderline{\phi^{\uparrow M})\triangleright\text{flm}_{M}}\big(u\rightarrow q\triangleright\phi^{\uparrow M}\triangleright(v\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\\
\text{naturality of }\text{flm}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(\gunderline{\phi\bef(}v\rightarrow\phi(u)\oplus_{S}v))^{\uparrow M}\big)\\
\text{compute composition}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\gunderline{\phi(u)\oplus_{S}\phi(v)}))^{\uparrow M}\big)\\
\text{composition law of }\phi:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\phi(u\oplus_{R}v))^{\uparrow M}\big)\\
\text{move }\phi^{\uparrow M}\text{ outside}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi^{\uparrow M}\big)\\
\text{naturality of }\text{flm}_{M}:\quad & =\gunderline{p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)}\bef\phi^{\uparrow M}\\
 & =(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monoid type 
\begin_inset Formula $R$
\end_inset

 and a monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between some monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, prove that 
\begin_inset Formula $\phi:M^{R}\rightarrow N^{R}$
\end_inset

 is a monoid morphism between 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
The empty elements of the monoids 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 (by definition) are 
\begin_inset Formula $\text{pu}_{M}(e_{R})$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{N}(e_{R})$
\end_inset

 respectively.
 The binary operations of 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are
\begin_inset Formula 
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{N^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{N}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow N}\big)\quad.
\end{align*}

\end_inset

To verify the properties of a monoid morphism, begin with the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }e_{N^{R}}:\quad & \gunderline{e_{M^{R}}}\triangleright\phi=\gunderline{e_{R}\triangleright\text{pu}_{M}}\triangleright\phi=e_{R}\triangleright\text{pu}_{N}=e_{N^{R}}\quad.
\end{align*}

\end_inset

Now check the composition law: for any 
\begin_inset Formula $p^{:M^{R}}$
\end_inset

 and 
\begin_inset Formula $q^{:M^{R}}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi:\quad & (p\triangleright\phi)\underset{N^{R}}{\oplus}(q\triangleright\phi)=(p\triangleright\phi)\triangleright\text{flm}_{N}\big(u\rightarrow q\triangleright\gunderline{\phi\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow N}}\big)\\
\text{naturality of }\phi:\quad & =p\triangleright\gunderline{\phi\bef\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi\big)^{\uparrow N}}\bef\text{ftn}_{N}\\
\text{naturality of }\phi:\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)^{\uparrow M}\bef\gunderline{\phi\bef\phi^{\uparrow N}\bef\text{ftn}_{N}}\\
\text{composition law of }\phi:\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\gunderline{\big)^{\uparrow M}\bef\text{ftn}_{M}}\bef\phi\\
\text{definition of }\text{ftn}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\bef\phi=(p\underset{M^{R}}{\oplus}q)\triangleright\phi\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given an applicative functor 
\begin_inset Formula $M$
\end_inset

 and a monoid morphism 
\begin_inset Formula $\phi^{:R\rightarrow S}$
\end_inset

 between some monoid types 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, prove that 
\begin_inset Formula $\phi^{\uparrow M}:M^{R}\rightarrow M^{S}$
\end_inset

 is also a monoid morphism.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monoid type 
\begin_inset Formula $R$
\end_inset

 and an applicative morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between some applicative functors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, prove that 
\begin_inset Formula $\phi:M^{R}\rightarrow N^{R}$
\end_inset

 is a monoid morphism between 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
Discussion and further developments
\end_layout

\begin_layout Subsection
Traversals for nested recursive types
\end_layout

\begin_layout Subsection
Traversable contrafunctors and profunctors
\end_layout

\begin_layout Subsection
Recursion schemes for nested recursive types
\end_layout

\begin_layout Paragraph
Perfect-shaped binary tree
\end_layout

\begin_layout Standard
The type is defined by:
\end_layout

\begin_layout Standard
\begin_inset Formula $T^{A}\triangleq A+T^{A\times A}$
\end_inset


\end_layout

\begin_layout Standard
The corresponding construction is 
\begin_inset Formula $L^{A}\triangleq S^{A,L^{R^{A}}}$
\end_inset

 where 
\begin_inset Formula $R$
\end_inset

 is applicative and traversable and 
\begin_inset Formula $S$
\end_inset

 is bitraversable
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this is chapter 9 of the functional programming tutorial traversable functors
 to motivate the interrupted introduction of these factors into practice
 I always remember the example that you have a list of some data items and
 you want to process it by using a function like this where you have a future
 as a as a result of this function and the usual way of doing this in Scala
 is to use a function called future dot sequence and I have seen this I
 have shown this in a previous tutorial and the idea is that you want to
 process each element of this list with this function and you have to wait
 until the entire list is done so we have many separate computations for
 each element of the list encapsulated by the future for each one of them
 you want to wait until the entire list is done and basically this is the
 type signature that you want in order to implement this computation you
 have a list of a you have a function from a to future B and you want to
 get a list of B as a result and you can get it in the future so you have
 a future of lists of it as a result and that is the type signature that
 the function future that sequence will allow you to have with some work
 but in order to understand what this kind of computation does we want to
 generalize from the future to an arbitrary type constructor F and we want
 to understand what properties these type constructors must answer so the
 list we have L and instead the future we have F and the type signature
 of the function is like this so this function is called Traverse I believe
 there's also a future of traders with a type signature like this that works
 on sequences we want to generalize to some type constructors F and L and
 that's what we will be able to do once we understand the properties of
 this operation so this operation can be implemented for instance if L is
 this type constructor then what can we do in order to implement this operation
 well clearly we have an LA and we can apply map F so f is this function
 we can apply map F and the result will be this now in other words we have
 not what we want probably wanders F lb Inc which would be this so how can
 we get F of a triple from a triple of F's or clearly we need an operation
 that's similar to zip zip would be FB times F be going to F of B times
 B now we need to apply zip twice and then we get from here to here so once
 we have the zip we will be able to implement this traverse operation that's
 the conclusion so far so it seems that F needs to be a quick ative in order
 to be able to implement this type signature for at least for this type
 constructor so for this type constructor certainly it is easy to implement
 if F is if it has a zip operation then we can implement it like this so
 that is going to be a fundamental assumption not for the traverse operation
 to make sense the type constructor F must be implicative now the type construct
or L on the other hand doesn't we don't know what that is it could be applicativ
e or not maybe we'll find out but for now let's what say L is traversable
 if it has this operation now in Scala we have a very limited version of
 this Traverse which assumes L to be a sequence so it's not based on this
 idea of being traversable as such it's just that one of the properties
 of a sequence is that you can implement this operation and we'll see why
 that is so but for me the example with lists and futures or sequences of
 futures is the easy to remember example that helps me remember the requirements
 for the traversal duration so always think that I have a list of some items
 and the processing makes me a future so L is a list F the future and then
 it is clear that I want this kind of type signature I want to have a single
 future and when that future completes I want to have the entire list of
 process data that's the easy to remember example so not not the other way
 around for example not a list of future they're not interested in having
 a list of futures I want a single future with the final list of the results
 and so that's why this example helps me remember this somewhat complicated
 type signature where I could easily make a mistake they will a to L of
 B today to have fun being LF being instead of X well being it's easy to
 mix them up but so remembering this example that I'm starting with that
 what helps me remember the time signature of triggers so the questions
 that I'm going to answer in this tutorial in this chapter are to find out
 what factors L can have this triggers operation to find out if we can simplify
 with somewhat complicated type signature can we express it perhaps through
 a simpler operation what are the laws that is reasonable to require for
 this operation and finally to look at contractors and pro fungus do they
 have also some kind of analog of this operation in previous tutorials are
 started right away with practical examples of usage in this chapter I will
 first do more theory to understand in more detail and more deeply the propertie
s of this operation that will be easier to follow the usage examples so
 to simplify traverse we notice that traverse is a kind of lifting of sorts
 it's the arguments can be permuted so these are two curried arguments so
 we can take this one was the first argument and then we have la to FLV
 yes the second argument so it's a complicated kind of twisted lifting and
 we have seen several times already that often you can find a simpler natural
 transformation that is computationally equivalent to a lifting so let's
 derive that natural transformation that is equivalent to traverse to derive
 it I asked the question so why can't we have F map to do the work of Traverse
 f map would have this type signature it Traverse sorry this is actually
 yeah so so this is the type signature investment but Traverse needs F L
 be here instead of lfb so see this F needs to be outside and that's what's
 missing so we need to transform lfb with F inside into F L being with em
 outside so that's the transformation that is a natural transformation we
 expect to be equivalent the trailer so what's called a sequence so this
 is maybe not a very good name sequence kind of suggesting that we change
 the or the order of L and F in the functor composition not a very good
 name but that's a traditional name and I don't know how else to call it
 indeed we find that the functions traversing sequence are computationally
 equivalent so this is why well we have defined sequence likeness so then
 Traverse of a function f is computed by first doing F map of F like we
 get here then we get this and then apply this sequence function that I
 abbreviated to seek which performs this lets transposition of the order
 the type diagram looks like this so we start with a type LA and we can
 do Traverse from it directly with this trap function which takes F and
 director gives you from la f OB or you can first do F map so you have a
 function f under L you get instead of la l FB and then you change the order
 so you reorder the functions composition ever be to FM and the results
 must be equal so for any value of this type you go up or horizontal and
 the result must be the same value of this type that's the definition and
 as we have seen before this pattern implies that natural transformation
 is defined as a composition of F map sub sorry and lifting is defined as
 composition of F method natural transformation and then this natural transforma
tion is equal to lift and if you take identity instead of F obviously and
 so then that's a pattern we've seen time and again where the result is
 that traversing sequence are computational global you can derive one from
 the other and back and it gets the same function back so I'm going to spend
 time through again since it's exactly the same proof as we had many times
 just a different type signature and notice also F here is an arbitrary
 placated factor so these functions don't use the structure of f other than
 that it is applicative so that's that's an example we have seen just just
 before we implemented a traverse function for this type constructor by
 applying the zip function of F otherwise we don't you know what F is we
 just use zip from it and so we are generic in the function in the functor
 F as long as it's implicit if we don't look at the structure of F we do
 look at the structure of L so the Traverse function depends on the structure
 of L but it doesn't depend on the structure of F it's generic images future
 that sequence has this type signature and that's an example of a sequence
 natural transformation you note we cannot have the opposite transformation
 I'll show the example for that but well for future analyst you could make
 an opposite transformation for a future of a list and you produce a list
 or individual futures that are going to be all already copies of this future
 mapped to select one copy of the lid and of the element you can do that
 it's kind of useless to transform in the opposite way but what I will show
 on examples is that it's impossible to have this transformation in general
 and arbitrary it's possible for future not for arbitrary yeah so examples
 of traversable function functors this example we have already seen list
 is another example sequence in general and also finite trees various shapes
 there and also traversable an example of an entre versatile factor is there
 either Malad and also the lazy list or infinite product or stream is sometimes
 called lazy string so let's see why that is so let's implement the sequence
 for this type constructor first so I'm going to define this file constructor
 for convenience and the seek function is I'm just going to define directly
 it's going to have this type signature and that's just a zip apply it twice
 and then some reordering Oh nested tuple that results from the zip and
 we know this is associative because we assume that F is applicative now
 I'm using my own typeclass for F which I call the zip for applicative but
 you can also use cats applicative just has a slightly different name for
 things and it doesn't have the zip syntax so I like the use of zip syntax
 so I'm using my own type process here but it's equal to standard implicit
 if that was so the sequence function has this type signature just as we
 have seen in the case or filter balls lowlands and applicatives it's much
 easier to reason about this natural transformation rather than the reason
 about the lifting it's also will be the case of laws or in simpler to formulate
 so that's why I will always always define just a sequence function I will
 not define a traverse function the Traverse is easily defined in terms
 of a sequence - and I'm therefore in this tutorial concentrating entirely
 on the sequence function I'll never implement Traverse directly to save
 time so let's have another example that either as a functor either Z where
 Z is a constant type then the sequence must have this type signature so
 it takes an either of Z FFA and puts F outside so it's pulls the function
 f from the inside of our plan into the outside that's the time signature
 of sequence so how do we implement that all we need to match so if it's
 the left we have a Z to produce F of Z so the only way to do that is to
 use the pure method okay I mean interchange there were there blinds here
 the left z does not have any FFA and so in order to produce an F of something
 we have to use the pure method from F and then we apply that to the left
 of Z and then we get the right type if we have a right of FA then all we
 need to do is to put the right inside the width so we just map that we
 don't change the value of a we just wrap it to wrap it into the right type
 construction so that's the very clearly simple implementation so if we
 actually write this type signature using a shortcut notation then maybe
 it's even easier to understand how the sequence function works so if we
 have a Z then we just put Z inside F using the pure if you cover away then
 we just put a 0 plus a into that by mapping with the right type constructor
 so that we don't change this value hey let's see how to implement the sequence
 method for the Fortran type so here's a simple binary tree it has a value
 of type a and belief and it has a branch of two trees so how the hell does
 sequence work on a tree like we're in the leaf where we just wrap in the
 leaf like we did with this either and if we're in the branch then we apply
 the sequence method which is the same sequence we're defining is a recursive
 function them so we recursively apply the same since and as a sequence
 method to the left and to the right branches of the tree and then we zip
 them together so then zip is the operation in the F function wickety function
 so we can use that zip them together we get an F of a pair two trees and
 then we wrap that fear is a branch under the map so this map is under the
 tree sorry under the F function so f is an arbitrary negative function
 and we're using its methods map and zip here we used its metal period but
 other than that we did not use any knowledge of F so it is in this way
 that we are generic in the factor f we are not using any knowledge about
 the structure of f other than it has that it has a map and zip and puree
 method let us see examples of non traversable functors so here's an example
 it's a reader mode with a parameter in its non polynomial and so it will
 turn now that this is not reversible so let's see why what's takes on applicati
ve function f specifically like option a and let's find all implementations
 of this type signature which is the pipe signature of sequence now all
 implementations turn out to be just one and this implementation always
 returns none so it always returns an empty option ignoring its argument
 so it is not a very interesting implementation and we will see shortly
 that this would not satisfy was overprotective of over a traversable contest
 so this is this satisfies the pipe signature but it does not satisfy the
 walls we haven't yet seen the laws but it is reasonable to say that this
 function completely ignores its argument so it loses information and typical
 walls for a lifting would be identity and Composition laws identity law
 would tell you that some lifting is identity but if it's losing information
 it cannot be identity so it cannot preserve the data that you give it but
 if people lose it will always return empty option and so that's reasonable
 to expect when this note is not a good implementation and so there are
 no good implementations - thank you let's take another example and you'll
 see there's there's one implementation for this so we can actually implement
 this type signature for this duplicative functor this this code is what
 you would expect it's taking this function so what translate entire signature
 let's just e to the pair and this is pair of eternity doing now if you
 have a eat to the pair and you can produce a pair of Italy in d2 a that's
 very easy just duplicate your your function so we do have implementations
 from this book we're supposed to produce an implementation of sequence
 as a generic in the function so we cannot look at the structure from the
 functor F and have a different implementation for every effort want to
 be generic and so because we can we cannot implement it for some F we're
 stuck in this is not going to prevent reversible functor let's take another
 example where we have a pair so the pair of some type and a polynomial
 function and let's take this as the implicated and again we find them there
 is an implementation so that's fine well this is actually traversable what's
 considered the infinite list so the infinite list class needs to be defined
 because we cannot have the cursive type as a type an alien's we have to
 have a class and it's a pair of value of type a underlays evaluated tail
 choosing again an infinite list of time from all values of tightly so let's
 define a sequence method well we can actually define it it's quite easy
 you you take the head of the list you zip it with the recursive implication
 of the same function sequence to the tail from the list which will sequence
 were found commute the order of factories and then you wrap it into the
 infinite list again so that's similar to what our implementation for the
 sequence operation on a tuple except that it's recursive and it turns out
 this is infinite recursion let's check that the even the simplest functor
 have the identity function let's define it like this put some type of class
 instances for identity function ages tribunal was defined let's define
 an example value of an infinite list which is if you find like this it's
 a recursive definition we could do a lazy Val instead of def I believe
 but it's just cleaning doing them since it's a recursive function and you
 see the tail of the list will turn again the same list so it's going to
 be an infinite list of 123 on the whole the way to infinity so if we use
 sequence on this value then we get a stack overflow interaction because
 it's an infinite recursion so it's it's an infinite loop there's no way
 to implement the Traverse of an infinite list because basically what you
 would mean is we need to sequence like this we need to have a list of F
 values so it's an infinite list of an infinite list about four days and
 that should be mapped into an f of infinite list of is now how can we do
 that we need to pull F outside to the outside of the title which means
 that we need to evaluate infinitely many of these f's in order to pull
 off outside mean generically that's what we need to do we need to evaluate
 infinitely many elements of this infinite list in order to put F outside
 it's impossible to just pull F outside magically out of the infinitely
 many elements here and so even when F is just an identity factor s won't
 work it's impossible to pull f outside I mean it would be possible for
 identity factor of course but we have to be generic in the factor f we
 cannot use any methods on F other than zip and map and so we don't know
 what F is f could be something that needs to be evaluated in order to pull
 a out of it and so because of that it forces us to evaluate infinitely
 many elements before we even get a single value of this type and so that
 will never end and so that's impossible so for this reason an infinite
 list is not reversible and finally I mentioned that the opposite type signature
 isn't is unworkable so why let's make an example calculation so let's say
 L is an easier which we know is reversible F is this reader unit which
 we know is applicative so let's find all implementations of this time signature
 and we find they're not there is no implementation of this type signature
 the reason is that this type signature would have to map this function
 into this data but that is impossible you cannot extract Z out of this
 so you could not possibly return the Z because you need an integer so which
 integer are going to give imagine that this integer is a different data
 type you don't you don't have values of it necessarily for integer you
 could put 0 in that integer sure but that would not be reasonable from
 other types so you cannot possibly pull Z out of this because there aren't
 any special values of this type and you can also not get this function
 because you only have this function and this function could sometimes fail
 to return an 8 could sometimes return a Z so for some integers it could
 return is e and you don't know in advance for which integers it will return
 Z and for which it will return in a until you run this function on every
 possible integer you won't know that and so that's impossible to know and
 so you can't split this into a Z and into it you couldn't either split
 it into two functions into Z and into in the same for the same reason you
 in order to split it you'd have to run this function on every possible
 integer and see what the results are so that's unworkable and so that's
 why you don't have that's that's an informal reason why you don't have
 any implementations of this type and a final comment is that there are
 several ways of implementing the sequence usually so let's consider this
 type again we have seen we can implement a sequence by applying zip to
 x and here's another implementation we can arbitrarily select a different
 order so we instead of zipping one two three with zip to one I'm sorry
 this is a mistake two three say 1 and that's valid so the type is right
 and the laws will hold as well we'll see why so that shows you that there's
 more than one way of implementing the Traverse or in the sequence function
 which is equivalent for a given type constructor L different valid ways
 of doing it so let's find out if other polynomial factors are traversable
 now one of the central results here is that all polynomial functions are
 reversible we will show this quite rigorously later so for now let's see
 how we can implement the Traverse or the sequence function for an arbitrary
 polynomial function so we have done it so far for this and we have also
 done it for either which is a simple polynomial factor and the general
 polynomial factor would have this form it's got a polynomial in a with
 some constant coefficients which I here denoted as Z Y Q P so we have seen
 how to implement for a monomial so let's first consider monomial like this
 so one part of this polynomial then we can apply zip to these so first
 we look at lfb so RV has this type so we can apply zip to these we get
 this and then we can lift the Z into the functor F by just this standard
 factor map this function is always possible for any factor f alternatively
 we can do F pure of this Z and then this will become FZ and then we can
 zip it together with all others but the result will be exactly the same
 as using this function because of the law of identity for applicatives
 so the result is going to be this and then that's a sequence method for
 a single monomial and then for each normal you do this and you have a disjuncti
on of different results of type F of a monomial and then we lift it to F
 of the disjunction like we did in the either implementation so we we have
 seen therefore that we can perform the traversal equivalently the sequence
 operation on monomials and we can also perform them on disjunctions and
 therefore we can perform them on arbitrary disjunctions on monomials and
 that's arbitrary polynomial factor also note we could apply zip here in
 different orders wicked first zipless and then Z put Z on the right we
 can change orders in different ways and so traversal order could be application
-specific it could be necessary to adjust it for a certain application you
 can always implement in some order or automatically say but it might not
 be necessarily correct for your application and also we have seen that
 non polynomial factors at least some of them are not to her so so this
 is not reversible because we cannot have a reasonable implementation of
 this that does not lose information and there's this paper that I'm referencing
 here it's a complicated paper there in theoretical but it has a proof that
 only polynomial functions are reversible that that and and also they must
 be finite so infinite lists do not fit the conditions of their theorem
 only finite containers polynomial factors are essentially containers with
 data they can have different shape they can have many items of data or
 few or none it could be a disjunction of different shapes and they also
 can have extra data of some constant type in addition to data of the type
 a but those are the containers that are traversable and no other containers
 aren't reversible sorry you have a lazy infinite stream that's not reversible
 they have to be finite and they have to be polynomial so that is proved
 in this paper in a complicated way so I'm not going to try to understand
 how they did it I believe that this is so because I have examples that
 even the simplest non polynomial factor can't have reasonable implementation
 of sequence so even though all polynomial functions are traversable they
 are usually traversable in several different ways and so it's useful to
 have a typeclass to declare a specific instance of a typeclass expressing
 a specific order of traversal so this order of zipping that we can choose
 here corresponds to ordering of traversal in a sense we'll see that when
 we look at specific examples of traversing but now let's take a look at
 the laws because we have have been talking about the laws so far and we
 need to see more in more detail how they work so I prefer to look at this
 type signature of Traverse and to derive laws using the lifting intuition
 so it's a lifting of sorts and every time we had lifting so far we had
 laws of identity and Composition in other words there was some kind of
 identity here and some kind of composition of these and this has to translate
 into identity here and composition of these I will mention that there is
 this paper which is arguing what laws traversals must have from a different
 perspective not as formally as I have argued just now because my argument
 is completely formal Traverse looks like a lifting therefore it should
 have laws like the laws we had before for other liftings it's purely a
 formal argument saying that the form of this function is similar therefore
 it should have similar laws but this argument doesn't look at what Traverse
 actually does well what it does is that it evaluates some function on each
 element this one produces some effect maybe this F is an applicative factor
 which could be a monad or it could be known more and what it encapsulate
 some kind of effect some kind of computational context or a result other
 than B and all these contexts need to be somehow put together and be outside
 of the elbe so we need to reconstruct our container L inside the larger
 effect described by F so we need to somehow combine all these effects for
 individual values of a into one big effect which will be outside and then
 we have to combine all the values of B after somehow pull them out combine
 them again into the same shape as the container L inside the F so all that
 needs to be done by the traversal function and the authors of that paper
 argued that the traversal first of all should visit each element of the
 container exactly once it it should evaluate each effect exactly once and
 then combine these effects into a larger effect and using this intuition
 they formulate some laws that seem to fit this description in some way
 well they didn't actually derive these laws from these requirements but
 they showed examples where these requirements are violated and they showed
 that these examples also violate the laws so this is a little not very
 convincing to me that these laws are correct and therefore I prefer the
 more formal approach because I have more assurance but if I find some reasonabl
e identity and Composition laws that's a correct set of laws so far in every
 example we have seen with functors with contra factors filterable applicative
 and wounded every single example had a function with type signature like
 this which was life like a lifting in my terminology and in every single
 example there were identity law and composition law and these laws were
 equivalent to all the other set of laws that were derived from intuition
 and these laws also corresponded to some category laws now in this example
 I don't know how to formulate this in terms of a category and everything
 a way that would be simple enough so I'm satisfied that I find a law that
 looks like identity law and the law that looks like a composition law even
 though I'm not satisfied that I can find it easy enough category to reason
 about so that it's useful so I'm not going to talk about the category in
 this chapter I'm not going to describe this as a lifting from one category
 to another because I don't know if that's really very useful and I don't
 know a good formulation of that so let's look for these laws so identity
 law is that we map some special function here that is identity in some
 sense into a function here that plays the role of identity now the type
 signatures are not a to a they are a to f of B so what could be playing
 the role of identity here well the pure method obviously and F has that
 method by an assumption so the identity law is that if we put a pure method
 here than it should be lifted to this which is again a pyramid and except
 it's applied to a different type of parameter now another way of formulating
 identity is to say that if F is the identity function so then there's no
 F you just be then identity function here is all ordinary a to a and that
 should be lifted to identity elite really so f is just identity function
 and then this identity should be lifted to this so that is another way
 of formulating an identity law let's find out now to compose what will
 be the composition if we have two of these functions like f and G then
 we can compose them using F map but the result would be this because the
 F G would be nested now we take F be we map G over it and we get F of G
 of C now if F and G are in clique are applicative then the composition
 F of G is also applicative we know that from the properties of the platitudes
 and so it is again a function of the same type except that it has a different
 factor instead of F so f function G factor and the composition of such
 functions is going to be of this kind which which is kind of complicated
 it changes the functor each time so what should be on the right-hand side
 what should be a composition of these traversals now the composition of
 traversals obviously works in the same way so you have la 2 FL b and then
 FL b 2 f g LC and so that is your final traversal and that should be equal
 to applying the traversal right away with this function as a purgative
 factor so in other words applying traversal to this if that is true then
 traversal of composition is equal to composition of traversals so that's
 with a little twisting where we keep using F map in order to get composition
 and keep pulling all the functors F and G all the implicit is we keep pulling
 them outside with these twists it looks like just a composition law traversal
 of composition of F and G with some twisting is equal to the composition
 of the two traversals with F and with G again with some twisting so these
 are the laws we're going to examine and it will turn out these are exactly
 the same laws as this paper proposes when I first looked at this it looks
 like we have two identity laws are they really independent no they are
 it will see that but that's a question we need to answer also laws for
 sequence are probably going to be simpler because in our experience so
 far always we found that the laws became simpler if we consider the natural
 transformation instead of a lifting so let's find those laws for the sequence
 and finally with the laws in in hand we can try to answer the question
 of which functors satisfy these laws we have found examples where we can
 implement the type signatures but are the law is respected by those examples
 or not so that's the questions that we have after this point so let's look
 at the first item the dual so a traverse of pure needs to be Pierce and
 how fast if it's the first law let's look at the type diagram for this
 so we started from away we map it with pure where we map it with traverse
 of pure and it should be the same value it was type in favilla so that's
 the first one now the second identity law looks like this and it's clearly
 a consequence of the first identity law if we just put F to be the identity
 founder and the first law should hold for every applicative functors so
 we really just need this one law when the second one is a consequence so
 let's forget it so we have the identity law which is this and we have the
 composition law which we can write like this and the short notation so
 for any function of this type and the function G of this type and for any
 applicative factors F and G we have so the composition of F and G is twisted
 in the sense that G must be lifted by factor F so this is our twist on
 the composition other than that composition of two traversals is equal
 to Traverse of composition here will we twist and here we twist let's look
 at the type diagram we start again with LA first with Traverse with function
 f and we get F lb well then we want to traverse with G but G works on B
 so we have to we have to traverse just on this lb and F needs to stay outside
 therefore we use F map of F and we Traverse inside of F using the Traverse
 of G which is giving us this value F G LC or we could directly Traverse
 on the function H with respect to the factor f of G which is a functor
 composition so the factor H could be defined like this as a functor composition
 of F and G and we know it's applicative so we could just directly Traverse
 with respect to H so this can be traversal with respective H of a function
 H of this type this function is defined like that so this is the law that
 we demand now which will hold let's derive the corresponding law for laws
 for its sequence to do that we just Express Traverse like this your sequence
 and substitute that into the laws of chillers so let's look at identity
 law Traverse of pure equals P R so Traverse of pure equals this conduction
 legal pure so that's the law of identity for pure so pure lifted to Bill
 and then sequence should be the same as pure applied to the type parameter
 Helle I should also mention naturality law that's always the case for all
 of our examples so far such as filterable moon and imitative but all these
 natural transformations as well as the liftings they have natural tea laws
 for each type parameter that they have there's one neutrality law which
 expresses the fact that the code implementing that function does not use
 any information about the type it's completely generic in that type and
 so you can map this type to another type before the transformation or after
 the transformation and the results are going to be the same so here's what
 the naturality law looks like for the sequence now sequence has a more
 complicated type signature and its type parameter a is all the way inside
 therefore in order to transform in this a to some B we need to have a double
 F map so let's say there's some function G that transforms a to be in order
 to transform this a or transform that a we need to lift this G twice and
 that's how I would write it down so first we can sequence this LF a to
 FL a and then we can lift G twice in this order or we can first lift G
 twice in this order so that instead of LF a we get LF B and then we sequence
 on that so that should be the same function that's a natural t law and
 the code for sequence will automatically respect that law if it is a code
 that is generic type parameter a will never use any information about the
 type of a so usually naturality laws are satisfied automatically by generic
 code and so it's not important to check them but it's important to check
 the other laws so now let's look at the composition law we need a bit more
 work about it traversal of F followed by the traversal of G lifted so let's
 substitute the definition of traversal and then we get this formula now
 we can decompose a lifting of composition going to factor law so we can
 get like this now naturality law means we can interchange this and we get
 that and finally the right hand side is written like that so again we can
 do that because of the thumb tree law so in other words the composition
 law for traverse says that this is equal to this they have a common prefix
 that we can omit because these are arbitrary functions F and G for which
 this must hold and so it's sufficient that these things are equal so that's
 the law for sequence much simpler and here's the type diagram because the
 type types here are actually complicated so we start with an L of F G C
 C is some type parameter I could use a here but I just can't see now first
 we sequence with with respect to F and then we just pull F out and we get
 F LGC then we sequence with respect to G but we lift it to be operating
 inside of F so that means we interchange this L and this G the result is
 f G LLC alternatively we could sequence with respect to the factor f of
 G this is maybe not a very nice known notation not very consistent but
 this is the composition of functions F and G so it's the page I mentioned
 here I should probably for clarity I should use page instead of F G and
 so if we sequence with respect to F G that means we pull out F G at the
 same time to the outside and we get F G of LC so the result of these two
 computations must be the same having formulated the laws now can look at
 constructions and we can check that the laws hold we can also check whether
 some factors can be traversable when they are polynomial or when they recursive
 or they're not polynomial so we have so far seen some examples but now
 let's be more systematic about it here are the constructions that I found
 for traversable factors and I will go through each of them one by one now
 now before I do that let me explain what is a by traversable and by functor
 so by factor is a type constructor with two type parameters which is a
 functor in both of them so it has a map with respect to each of them separately
 and it also has a map with respect to both of them at once of course because
 you can just you can transform a to some C and B to some D separately or
 at the same time if you wish it doesn't doesn't it so that's a bi functor
 and by factors are by traversable in the following sense they have this
 natural transformation where we have an F wrapping each of the type parameters
 of s and this F can be pulled out by this sequence by sequence natural
 transformation and it should be natural both an A and B separately so that's
 the assumption and so you see this a and B remains and we have pulled F
 out to the outside so if statute transformation exists which is natural
 in both a and B and it has the same laws the laws of identity and the laws
 of composition now the law of identity is this and it needs to be adapted
 obviously to this by seek so that you have pure here and pure here and
 the law of composition obviously needs to be adapted as well because we
 have F G a F G B and so on but other than that it's a direct generalization
 so analogous laws must hold so let me now begin by deriving the laws that
 must hold for these constructions rather deriving the fact that the laws
 hold for these constructions first construction is constant functor and
 identity factor so both of them are traversable till you find that we need
 to define the sequence method and to show that the laws hold for it that's
 very simple so for convenience I'm just going to put a type parameter up
 front the constant factor is a function that doesn't end on its type parameter
 so L of F of a is the same as I've elevated Simon is this constant times
 e and FMLA is f of Z so sequence is this type signature and clearly this
 is f dot P R is just a pure of F functor can't in any other way produce
 a type signature like this but is generic in if we're not allowed to know
 what F is except that it has a pyramid zip and map so let's just define
 that as a pure let's check Louis so the identity law is that F map of pure
 followed by sequence must be equal to F dot P R now I'm putting here this
 underscore ell notation for clarity I could have said for example instead
 of F dot P R I could have said pure underscore F what I mean by this is
 that it's the method that is defined for the type instructor F such this
 method is not generic and F it is defined for each F separately in the
 typeclass instance similarly F map is not generic and L it's defined for
 each L separately so I could I could have written like this as well it's
 not Scala notation necessarily but it will do for now just for clarity
 to remind myself where these methods come from now sequence is defined
 for L so here I could write it like this to remind myself that the sequence
 is defined separately for each ill but it is generic and F so I could write
 it like that so sequence has F as a type parameter but L as type constructor
 or or functor for which it is defined in the Thai class now so let's see
 if we can verify this law F map is identity for the constant factor so
 this is identity and so this is just F here sequence is sorry F map of
 F of F here is identity function f map does not transform anything because
 there is nothing to transform we only have this Z cannot transform so this
 is just at the energy function you can cross it out and then we have the
 law that sequence equals pure at sequence equals pure by definition so
 the law is satisfied let's consider now the composition law which is the
 composition of sequence of F and the lifted sequence of G so now I'm using
 this notation with more sense in here I didn't have to say it's sequence
 Hamilton if I could just say sequence but here it is important now to say
 which for which type parameter is because the factor is a type parameter
 in sequence function so we have the sequence applied with respect to applicativ
e factor f and this with respect to G and F G is the factor which is the
 composition of F and G we just [Music] denote it like that for gravity
 so this is now sequence is defined as pure F map is [Music] defined in
 with respect to F so this is f naught F naught F naught L F map l was identity
 but F map F is not and we actually don't know what it does because it f
 is an arbitrary let's look at your family so you need to keep it symbolic
 so we have f dot P R which is this sequence and then because the Scala
 operation and then responds to my composition symbol and then we have F
 map F of G period because this is that the pure in G and that will be equal
 to FG pure but actually what is the definition of pure for composition
 of functions that's exactly this it's a pure of F followed by lifted pyrimidine
 so it's the definition of what pure use for the function f G and so therefore
 the law holds you now consider the identity function you know the identity
 function is like this or sometimes can it can be denoted by it with a capital
 I so this is identity factor I believe the cat's library does this maybe
 not maybe Scalzi so how do we define a sequence for it well this is just
 an identity function because it doesn't do anything because we we have
 f of a it goes to F of a because it is just wrapping it doesn't do anything
 so this is identity function we could even write this sequence function
 differently like this in order to underscore that factor that's just identity
 function now let's check the laws the identity law which is this now if
 F map is the identity function sequences identity function f map L is just
 this F map L is the identity function of its argument and because of this
 identity function and so this is equal to f dot P so this is f dot pure
 followed by identity and that should be equal to F dot penis clearly so
 composition is that we have a sequence followed by F map of sequence now
 sequence of anything is identity so it's just composing one identity and
 F map of another identity but we know that lifting F map of identity is
 again identity so this is just about composing one identity or another
 that's always going to be identity so that is also identity by definition
 and so this law holds let's move on to the next construction which is the
 product for any traversable factors G and H their product is reversible
 now I'm going to introduce my own typeclass which reversible just for convenien
ce but actually the cat's library has a traverse that class but I just want
 to show that this is easy and I prefer to define seek and they prefer to
 define Traverse in their tag class so that's why I have my own tie plus
 but basically this is very simple that concept has just one method and
 this method is Elif a to FLI traversal defined that method now this red
 is a problem with IntelliJ and install a plug-in cannot resolve the types
 it compares this entire code comparison works also we have a convenience
 method to get the Traverse into instance this drove in the syntax to use
 seek as a as a method rather than user so let me then show how I can define
 an instance of track of travel this traversable type was for this type
 constructor which is a product of l1 and l2 given that both l1 and l2 are
 traversable factors so first time to mend the functor instance well that
 is standard it's just a map this map that just a functor instance for product
 and then i implement the traverse instance using C so what am I supposed
 to do I have this a1 F a times l2 FA and I need to give F of L 1 a times
 Delta a so first I can say please so sorry first I can sequence each of
 these separately because l1 is reversible and all to escape most of my
 assumptions for a sequence separately both of them then I can zip the results
 and I get what I need so that's my idea about how to implement so I just
 say sequence the first one sequence the second one and zip now I could
 also write the code like this but then my IntelliJ doesn't understand where
 these things are coming from but the code actually still compiles if I
 do that so this is just much more your boss telling me where the sequence
 comes from from which factor and in principle I expect a scholar to be
 able to derive this automatically and it can this is much simpler to write
 about intelligent isn't like it so let's check the laws here so there is
 the identity law which is that we can map the pure and apply seek and that's
 the same as the pure so how do we verify this law well we substitute the
 code of F naught which is up here and we apply both sides of this law to
 some arbitrary value of this type and one until two so we do that looking
 at the laws actually we have to start from LA and the law will give me
 this so the value on which I apply both sides of the law must be of type
 le so that's why as eleiza is a pair of L 1 and L 2 and then that's why
 I take some arbitrary pair and i apply the law to it so the left-hand side
 first i apply this and that's going to be that there's a half map this
 is L 1 this is no true and then we apply the seek function to this now
 the code of seek is I'm going to write it like this in a shorter form and
 the result will be that I have this seek zip this so now we need to assume
 obviously that the law already holds for a 1 and L 2 separately and therefore
 for example we have this which is the formulation of the law for L 1 and
 so we can substitute that in here and then we get that now because of the
 identity law of applicative zipping of two peers is a pure of the peer
 so this equals F pure of the peer and that's exactly the same as applying
 F pure which is on the right hand side directly to the pier so we have
 verified the identity law let's verify the composition law this is how
 we could write it I have written out sequence seek of L seek of the hell
 everywhere it's just for clarity so in my notation that means a sequence
 made up defined for the tag constructor L applied with respect to the type
 parameter F so now let's apply again both sides of this law to some suitable
 value let's see what type that value should have which you have the type
 L F G C as the initial point in the time diagram so let's have an arbitrary
 value of type L F G C so sort of C values a here so L F GA naar betray
 value of that is a pair of l1 f g l2 f g and applying the code for seek
 to this we get a 1 FG a sikh with respect to f zip f l2 mg is equal respective
 so that applying just the first step according to the type diagram that
 would lead us in here which is f of LG F of L 1 G 2 G so now we apply F
 naught F of this to that now what is f naught F of CBG know seeing G is
 with respect to L sorry with respect to G over L so it acts on some value
 of this type and it will give this according to the definition but we need
 to lift this function was F naught s the difficulty here is that f is an
 arbitrary function we don't know what ethnic F does we don't have code
 for it we need to keep it symbolic so clearly we need to use a definition
 of zip F G somehow to find out what F naught F will do so the definition
 of zip of F G is this there's some FG x and f gy with zip them in the factor
 F G so so have G X is a type F of G of X G Y is of type F of G the definition
 of the zip for the composition is one of the constructions for applicative
 it's it's a zip in the F factor followed by F map F of zip in the G factor
 is this what we have in our formula not quite because we have not just
 something zip F something after which we we do F method but we have these
 things transformed we seek so let's transform using some function so let's
 use a natural G of zip so that we can transform like this so we transform
 under the factor f and so the result is the same as if we transformed FG
 x and f gy and then zip so that's a natural T you can transform first and
 then zip or you can first zip and then transform that's up to up to us
 so finally if we use this formula we can see that F map f of seek L of
 G is like this it's the F map F of this so this is seek L of genii because
 seek L of G gives us this kind of expression which is similar to this P
 of GX being sequence of this zip G and Q of G Y is sequence of this and
 then we apply this to those things and so the result is that F map of seek
 L applied to that is it's like that it's sick F map sick G and then seek
 F maps engine so that's what we find this really apply natural TMZ so that's
 the left hand side of the composition and the right hand side is that so
 these must be equal now the definition of seek F G is the code of seek
 that is just applied to this type parameter F G instead of that F so the
 same code and it would have been the same code if we could have this equal
 to that now these are six with respect to factor l1 so these are defined
 for l1 and these are defined for how to now we assume that for l1 l2 the
 composition law already holds so that means for example this so this is
 the composition law for a 1 and similarly for L 2 so therefore this is
 the same as this and that is the same as now and so the composition law
 holds for hell the third construction is disjunction so for any traversable
 factors G and H the disjunction is again a traversable factor so we have
 seen an example of implementing this in either and in polynomial factors
 but this is a general construction so let's see how to again we assume
 that factors l1 and l2 reversible and we defined well as the disjunction
 of l1 and l2 a standard factor instance but is Junction so now let's implement
 the founder instance traversable instance for the disjunction so here's
 how it will work we have this so we apply sequence to each of these separately
 we get this disjunction and finally we depending on which one we have we
 lift it into the F of disjunction using just constructors of the disjunction
 that left or right so that's how it works first we do a sequence on each
 of them so if we are on the left and we sequence it again this and then
 we map it with left apply which means that we put a left on top of this
 and left it's just a wrapper in a disjunction so it doesn't change the
 value and the same we do for the right now the redness here is again due
 to limitations of IntelliJ it's unlabeled transferred types directly but
 this code runs it compiles and runs let's check the laws at the entity
 law we do the same thing as before we just substitute the code of the flap
 in here and then we apply to some LA we'll know that both sides of the
 identity law applied to an arbitrary element of this type now since the
 code is symmetric with respect 1 or L 2 it's sufficient to apply this to
 some left of l1e and check the law for that so if we apply it to the left
 and we are in this case we have any left applied to to this which is well
 we are actually in this case and we're looking at F Nobel first so we are
 you want to lift like this now you notice we can't really simplify this
 because these are map and pyramids of factors that we don't know these
 are a one factor and if I look at your factor so we don't really know what
 these methods do we cannot substitute any more code so that's our symbolic
 computation right now we apply sync to this now we're on the left so we
 apply seek to to this which is I'm going to denote that a seek l1 to that
 and [Music] followed by map of left block now nothing more to simplify
 unless we use the fact that l1 already has this law and so this law for
 l1 looks like this therefore we can simplify here substitute that we get
 F P were of l1 a map left apply which by naturally T appear and we have
 pure of left over one a and that's exactly what the right hand side will
 do when applied to left of l1 e so identity law holds let's consider the
 composition law the composition law needs to be applied to a value of this
 type and again it's sufficient to consider the left and applied to that
 so first we apply the seek and that gives us in this now we apply f map
 F to belt and we notice we have F map F which is this one and another if
 map F so we can combine them and the result is that we have this two which
 we apply map with respect to F of this kind of function so we first do
 we left apply to that and then we further apply this function so now this
 is not quite Scala code because I have this map underscore F for convenience
 and clarity so that's just keep in mind I'm not actually using your Scala
 code here but I could adjust that the types will be less clear so now what
 does this do now this c g you know seek g has to act on the left and we
 need to substitute the code of seek when acting on the left it gives us
 this expression my definition of our seek up here so let's substitute into
 this and we get then this expression so now we can use the composition
 law that by assumption already holds forever so then we have this one Perelman
 which we can rewrite like this now this law is not quite giving us the
 expression that we want which is this expression because we have this function
 here but here we have another map so we're not we have another left apply
 to map and also on the right hand side of the law would have another left
 apply so in order to put another map inside the seek we use a net reality
 of seek we add this on the right-hand side which gives us this seek so
 seekers natural so we can apply seek to a transformed argument or we can
 apply transformation to the result of seek and so then if we define what
 lab FG is that is f map of F map and we put that onto the left-hand summit
 so that we have CK one of this map F of this map F both of that you know
 we can combine the map F this one with this one and now we have a single
 map F with a bigger function but that's exactly what we had for the left
 hand side and kill him before and so therefore the right hand side response
 is equal to the left hand side his code so the code is equal and the same
 would be if we replaced a woman so this shows what laws hold for injunction
 now let's consider there is construction for which is a recursive function
 defined as la equals some s of a and la so as s is an arbitrary by functor
 so this could be any type function of two type parameters and this equation
 this is a type equation it defines a type la recursively so examples of
 this are lists and trees different factors s can encode very easily different
 kinds of wastes and trees now this also describes infinite lists and infinite
 data structures and we have seen an example where the infinite data structure
 does not actually work you can implement the function without the recursive
 calls never stopped so that's the problem the laws will appear to hold
 in our proof but actually it will not work in practice so I will comment
 on this when I use the recursive assumption in the proof so let's see how
 it works so I introduced the biofilter as a type parameter up front so
 that I don't worry about it so much it's easier in Scala to do this now
 I cannot just introduce a type like I did here because reclusive type illnesses
 are not allowed in school so I need to introduce your class so once that
 actually makes the code a little clunkier because now and you need a name
 for the data value inside and I need to wrap and unwrap but that's a small
 inconvenience so the class contains a value of type s of a end of the same
 11 so this is a type function that I'm considering as a parameter and now
 I can implement a factor instance for this now this obviously is going
 to be recursive so in order to map this l 8lb i map a to be here and I
 need to map this la to L be recursively by using the same map so I need
 to do this under yes so I need to map at the same time a to b and le to
 l be under the type constructor s so that's by map so I'm mapping the two
 type parameters of s at the same time and then my map is a method that
 takes two functions with two type parameters so it goes a to C and in this
 case we have the by factor with type parameters a and L of a and so it
 takes two functions a to C and elevate to D gives us FCD so this is combining
 map with respect to the first router and map with respect to the second
 parameter in a single call which is completely equivalent to doing first
 the first type parameter with a map and then the second parameter with
 another map but it's just easier to do it with one method probably two
 and this is the recursive call to the same function so this is how we do
 it the functor instance now let's look at the Traverse instance how would
 that work so L of a is the same as recursively defined as s of a and elevate
 so now we need to transform this into this if we want to implement seek
 how do we do that well we can obviously seek here recursively so the second
 argument of s is a recursive instance of the same type and so we can assume
 that for that recursive intense instance we already have the implementation
 so that would be the recursive call to the same function so that would
 be transferring into Fla so now we have so we just do a by map where the
 first one doesn't do anything it's identity and the second function is
 a sequence recursively calling the same and now we do by Traverse or by
 sequence actually by sequence which is as I indicated before it's transforming
 s fafb into F si be pulling out the F at the same time out of both type
 parameters to the outside so we use that and transform s of F a Fla until
 F of s of any LA so this is exactly what we need so in other words seek
 is just a composition of by map and by seek but on that one factor now
 I can use cats library it has by functors by traversable and it has this
 voice sequence so I'm using white functor and white reverse which is canceling
 berry typeclasses just I could have defined them just as easily as the
 trove that class and the redness again is a some problem with types although
 I indicated all types explicitly but still it doesn't like it so therefore
 the Seekers just by map with identity and seek which is a recursive call
 followed by the by sequence call on the by factor so that's exactly what
 we plan to do first we buy map so that we seek under yes with respect to
 the second type parameter and then we do by sequence yes so that works
 and let's check the laws so the identity will need to substitute the code
 now for for clarity I still write f9l here and so on but it is easier now
 to distinguish sequence with respect to L and s because s is a by function
 so it has basic and violent and L has seek so I'm going to write seek L
 I could have done it like this but I'm not going to write it for quality
 for brevity so okay substitute the code of f9 that gives us this code which
 we defined here the lab instance the defunct our instance for help which
 maps using by map under F and the recursive on the second so let's write
 it down so this is a by map of this function and the recursive FF L as
 a second argument of why map so the same function as we're defining here
 is here so now we need to apply secrets the result is this followed by
 by map actually followed by bicycles remind myself what is my definition
 of sequence for you yes just take the S out of the case class which I'm
 not going to write here because it's just wrapping and unwrapping we want
 to pretend that this case class is just a type so first it's apply map
 with identity and seek and then it's a buy seek on the result I'm going
 to ignore this because this is just wrapping right so seek is by map followed
 by by sick this is sick L so we have this expression now we can combine
 the by maps just like we can combine maps because they're by factors it's
 just first we have a map in the first type driver so we combine these two
 which gives us this and then we have a map in the second type planner which
 combines these two and that gives us that so f map L and then seek is the
 same law that we're trying to prove not F not LPR and then seek is f pure
 so it's a recursive invocation of the same law and we're trying to prove
 in the second function of Y map so we can use an inductive assumption that
 we already proved that by recursion and therefore we just substitute into
 this expression we substitute F P R inside of this because that's a look
 so then we get by map of pure pure by seek and the identity law for s means
 that s by map pure pure basic is the same as s is just pure and so that's
 wasting holds for Escalades by traversable function by function and so
 this becomes the right-hand side of the identity law and that's the proof
 of the identity law so now let me mark about using the recursive calls
 and it is that inductive assumptions corresponds to recursive calls in
 code so in mathematics the inductive assumption is that on the previous
 step things were already proved in code it means that we are going to call
 the same function recursively assuming that it will return the correct
 results then our step also returns the correct results but that assumes
 that the recursive call terminates and actually returns the results and
 we have seen an example that on the infinite list it does not return it
 has anything to do and so that's where it is going to break so actually
 the inductive assumption can be used as long as all these functions actually
 terminate their evaluation and return their results and if so then it's
 off it's all fine but so at this level we will not see any problem with
 infinite lists we are using the inductive assumption and everything appears
 to be correct however we have not established that these functions will
 actually return at all and for the infinite list they don't and so for
 some factors defined using this construction using some by factor s some
 factors will have infinite loops and others won't so that is a separate
 thing we need to establish in order to check that they are actually reversible
 this is usually not a problem for factors because this map is going to
 be cold maybe later and this is a lazy call and so there is no infinite
 loop but we have seen we do a bye map and then we do a buy sequence and
 so that call will evaluate everything and that will break for the infinite
 list now all I'm saying is that this proof of laws and the same will apply
 to the proof of the competition law that I'm going to talk about shortly
 this proof is only as good as the fact that all the functions return and
 if you have an infinite loop in one of the implementations then as proof
 oh well great because the inductive assumption cannot be used because the
 use of inductive assumptions is is translated into recursive calls in the
 code and if those goals never terminate them you can't call them so I'm
 not going to present an analysis here as to what possible functors s are
 admissible because I don't know how to do that analysis in general so and
 that's a much more difficult topic of recursive types what are the reclusive
 types for which certain methods would terminate and that's for another
 chapter so from now we will assume that we check separately that all the
 methods will terminate and if that is so then this proof is correct we
 are allowed to use inductive asymmetries let's look at the composition
 law so this is the composition law and the law is an equation both sides
 of which need to be applied to an arbitrary value of this type let's check
 so L F G C so use a instead of C I'll probably check rank it in the slides
 that it is a and not C I'm using a in the code consistency so s of F G
 a L F G so that's lfg so let's apply both sides of this law to some value
 of this type and we get first sequence which is by map of identity and
 sequence followed by by seek and then we do a map of seek which is a function
 that takes this and does a by map and and by seek but now with respect
 to G so I'm just writing it out what the code is for seek and this should
 be equal to by map for the advicing but with respect to FG so that's our
 law let's check that the schools and we certainly assume that it already
 holds for for the s by function which means that this equation holds and
 by seek map is by seek now this is just a law this twisted composition
 of seek can seek is seek so how do we use this in order to prove this now
 clearly to use this we need a value of this type which is not the same
 as what we have here now this is s FG x FG y so is very homogeneous it
 must be the same functors FG and we don't have the same factors here we
 have F G and L F G so this L is outside if L were inside of all of this
 here then we could just say this is why this is eleve is why a is X and
 then we are of this shape so that means we need to permute L over there
 so in order to do this we need to sequence this with respect to F G and
 then L will get inside but we need to use the sequence inside the type
 constructor s which requires a buy map now this is going to be a buy map
 with respect to the second type parameter of S which is the recursive invocatio
n and so that by map and sequence is a recursive call to sequence therefore
 we can use the law of composition for that as if it's already proved and
 we will do that so here's what we do so in this law that we are going to
 use now we're substituting this value s FJ XY which is defined like a by
 map or a sequence with respect to L and respect to F and then G and then
 that's of the right shape with X equal to a and y equal to L of a so that's
 what we wanted and the result is this expression which is a by map followed
 by by seek followed by map now we can certainly use natural reality and
 exchange map sorry no we we here we're having basic F map by CG that's
 what we're using here it's a basic FG that's that's the law we're just
 writing out the law we're substituting s F G X Y into both sides of the
 law services here and this is here so this holds this is an equation that
 holds so now by inductive assumption a composition law for sig L already
 holds when we use it here and so therefore we can rewrite this right-hand
 side like this this is just sick L of F G now this right-hand side is the
 same as the equation that we need to check which I noted as a start and
 just marked labeled that equation by start for convenience so the right-hand
 side of that equation is now the same as this therefore it's also equal
 to that so it remains to show that that the left-hand side is equal to
 the left hand side of star let's write it down so like this yeah it's really
 easier to compare so by map now we have this instead of that and we have
 a by seek and we have a map of by seek instead of this now if we look carefully
 we have a map f of by seek and here we have a map f of something that's
 followed by by 6 so that can be pulled out with a map F and omitted so
 this is a training lab F by sake of G in both of these so as we just a
 minute forget this so now the problem that they are not equal because we
 have a different order of by seek and map so have a by cyghfer by map here
 and here we have a map followed by by seek when we need to interchange
 a map and the natural transformation that's naturality law and it's the
 same way for by factories just by secant by map can be interchanged let's
 write down the naturality law for clarity it looks like this so we have
 a basic follower by map f of by milk of something and then we have a by
 map of map f of that function let other functions we have two functions
 because by map takes two functions both of them need to be mapped and then
 we have bicycling so we have interchange the order by seek and map f so
 if we use this law in this equation then we get that the first line is
 equal to again we can interchange by c combining up and we get by C cadine
 so now we have by map followed by by map followed by by seek by map can
 be combined and then we have this by map fold but by seek and this is exactly
 the left hand side which is this emitted by C kanji sorry this one so this
 concludes the proof of the composition law and therefore we find that this
 construction was valid now the question is which by factors are by traversal
 and the answer is the same all polynomial by factors are by traversable
 now we see without recursion these constructions 1 2 3 our constructions
 that allow us to get any polynomial factor with arbitrary types in it doesn't
 have to be monoid like in applicative can be any any constant type any
 polynomial function these constructions cover all these cases now construction
 to even has two different implementations we can zip in one order or in
 the opposite order it still will work and therefore all polynomial functions
 at reversible now exactly the same constructions worked for by traversable
 constant and a and B are quite reversible in the same way as constant an
 identity function traversable and products and disjunctions are by traversable
 and so-called by traversable polynomial by factors can be used in this
 construction I'm not going to go through proofs for these by functor constructi
ons they're pretty much the same as the proofs I went through except you
 have more type parameters to worry about what implementations are exactly
 the same and so the conclusion is that all polynomial factors including
 recursive polynomial factors as long as the Traverse and seek methods return
 in finite time and they not go into infinite loops as long as that is the
 case all polynomial factors at reversible all polynomial by factors also
 traversable and you can go on you can define a by factor by recursion using
 a try factor in the same way you can say sa B is equal to some T of a be
 s a B or T X Y Z is a try factor and as long as that try factor is tried
 reversible exactly the same proof would show that the by functor is by
 traversable so you can have recursion at any level as long as it's a finite
 level of recursion obviously at some point you would have some n factor
 that is not recursive recursive and or maybe several of them and then as
 long as that's polynomial is going to be 2n traversable and then you go
 back and have your n minus-1 traversable recursive thumpers and so on and
 so it's clear that all polynomial factors with arbitrary recursion so it's
 it's a tree for example whose branches can be themselves lists or you know
 you can have a list of branches or anything like that all of that is traversabl
e so that's a major result of this consideration so now let me consider
 foldable functors now we we know the fold operation in a standard library
 it's a full left turns out that the fold operation is a consequence of
 having a traverse operation and later we'll also see that the scan operation
 the scan left is also a consequence of traverse operation so how do we
 derive the fold from jurors the main idea is that we should take a specific
 applicative factor which is a constant factor fa equals a constant Z or
 is a Z is a monoid type and so the zip operation on this factor is just
 a monoid operation which I will denote like this and we have seen in Chapter
 8 that these are applicative now the type signatures are much simplified
 now in type signature of triggers becomes this and this method is called
 fold map well the does is that it takes a container of type of values of
 type II and takes a function that map's each value to a mono it and then
 it traverses the container and combines all these monoid values into one
 big monoid value and that's for example aggregation and any kind of aggregation
 Sun Oven integer list or some pointer so the general method with an arbitrary
 monoid which is generic in the monoid is called faulkner the type signature
 of seek becomes simple like this so and that is just to concatenate all
 monoid values in the container into one using the monoidal operation so
 this is called M concat now there aren't any more laws because the laws
 are about combining oh the identity law will be automatically satisfied
 and the composition law is trivial because you can't compose these things
 because there is it takes two more nodes compose them you get the second
 one the first one is just just going and so all these laws are trivially
 satisfied there aren't any laws anymore for this foldable operation for
 the fold map there aren't any laws and all traversable functors have these
 operations now nevertheless it's convenient to define the foldable typeclass
 that has these operations like fold map and M concat and fold left because
 you could traverse the containers in different order and that would be
 different implementations even though there are no laws and it's basically
 a consequence of traversable so there aren't any factors that are foldable
 but not reversible so all polynomial factors and only the polynomial functions
 are both foldable and traverses and and so nevertheless it's convenient
 to define this typeclass because you can have different implementations
 of fold for different order of the traverses and finally let me show how
 to define the fold method and that's a trick where you take this as your
 manual type now this is a mono eight where B is an arbitrary fixed type
 and these functions are just concatenated by composition and the identity
 value is the identity function now if you substitute into the following
 up into this substitute B to B you get this type signature it's a curried
 function with one two three arguments so if you just rearrange these arguments
 you see this is exactly the type signature fold left it has your container
 it has initial value it has the update function and it returns the final
 accumulated value so monoid is gone we have a specific one right here the
 arbitrament already that is is gone until we have an arbitrary type B so
 if we put B before this argument and it's not obvious where the money went
 but it is just a consequence of a signature of Traverse where we first
 put them on oil in it and then you specify to this node and so for this
 reason every foldable has a foolproof method for map and M concat and every
 traversable also has them and so now we know which factors are foldable
 and reversible so let's ask our contra functors useful or profanity was
 useful in the same capacity because you could imagine that you want a conscious
 factor that you Traverse with respect to a function or my servers and my
 answer to that is after several analysis is that they're not very useful
 here's why let's take a contra fantasy now let's try to do a seek on it
 so that would be this kind of time signature now if I have a CFA I can
 control map with the pure method the pure F which is a to FA I can come
 up with that to get CFA to see a so I can get down and then I can put that
 into the F using pure F so I get F CA and in fact there is no other way
 of doing this generically now it seems that wall control factors are automatica
lly reversible and I could even say F doesn't have to be a factor it's not
 using map well if I'm just using pure life and so it's it can be arbitrary
 Pro functor as long as it has pure it's actually applicative proof functor
 or even just appointed with a pure so it can be just just like that so
 is that useful well in my view it's not useful because I completely ignore
 all effects of EV I'm using pure of F so whatever F ahead here I'm ignoring
 its effects I'm never going to have any effect full value here either it's
 going to be always a pure so it's not very useful and in the other direction
 you can't do it f seiei to CFA because you can't extract out of F necessary
 now if you have a proof factor see anything things are not workable here's
 why consider this simple example a simplest growth factor just neither
 a functor nor control factor because it has a in both covariant and contravaria
nt positions now we need a sequence function of this type signature but
 that's it's it's impossible we cannot get an F of a to a unless we somehow
 get an a to a first but we can't there's no way to extract a to a out of
 here so I can't get an A you can't get an F of a and so there's no way
 to do this so so the only way to implement this type signature is to return
 pure F of identity here but that ignores its argument and functions that
 ignore its argument will not respect the identity law they will not preserve
 information and finally let's try to try to traverse profile too with respect
 to proof hunters and we find again that the only way to do that is to ignore
 all effects here are two examples so consider this contra factor and this
 contra factor then now if it's applicative it means that s is a mono it
 and so this type the only way to implement is to return an empty value
 of F on the right ignoring all of Fame and the second example is you take
 this contra function and this function and again you can show that the
 only way to implement sequence of this type signature is to always return
 empty option and again that would ignore its argument and so it's most
 likely you're not going to be useful because we ignore all the effects
 will never return anything that's not empty and so on so we we are able
 to implement these type signatures let's see I have I have this test code
 here for a check that we can actually implement only one type signature
 and that it returns an empty option in both of these counter examples so
 take a look at this in more detail if you feel like but I'm of the opinion
 right now that since all of these examples show that I have to ignore all
 effects I have to return a value that ignores all the input data or ignores
 all the effects in the factor or per factor f that's probably not a very
 useful implementation but there isn't any other also note that the laws
 of jurors suppose the notes actually say that effects of f cannot be ignored
 they don't actually say that so you can traverse each element once and
 that's guaranteed but then you can just ignore the effects maybe well for
 some functors that's possible as we have just seen so the conclusion is
 that traversable contractors and pro founders aren't really so great and
 aren't very useful let's look at some examples where we use traversable
 factors the first example is we can convert any traversable factor data
 structure to a list to do that we will actually have a trick and that will
 all define a list as a monoid not as a type constructor is a constant type
 but as a monoid so it will be a constant factor so to express this i define
 the type constructor z which has a type parameter b but it's equal to list
 of c or c is a fixed type parameter up here so it's not depending on B
 so this will be a constant factor which are defined like this so it doesn't
 change anything the type parameter is not used and it's applicative as
 well as a constant for a factor that is a monoid so I define the evocative
 instance using the rajab and this is an eel and a monoid composition or
 concatenation of lists and just for fun I want to define the monoid composition
 in the opposite order [Music] so having defined this and now have Z as
 a applicative factor and I can use chillers which is this function that
 I defined for convenience on the reversible value and so now I Traverse
 F of a which is this L of C probably better cold now this L of C is of
 type unknown type constructor hell so we Traverse it with a function that
 takes a value of type C and returns a list containing a single element
 C the result of traversing is that for each element from the data container
 L will have a list of a single element and then we will concatenate all
 these lists because that's the effect located factor Z and we need to combine
 all these effects for it all values in the container health and the combining
 is done using the monoid composition and so then the result will be a list
 of all elements from the container l so let's see how that works we define
 L like this we have seen the implementation already and now we define a
 value of this type the value is triple 1 2 3 and then we did recall to
 listing it and the result is a list of 3 2 1 because we have defined the
 opposite order here so if we define a straightforward order we would have
 a list of 1 2 3 otherwise we have a list of 3 2 1 so in this way we see
 that any traversable factor is a data container that can be converted to
 lists and the order of list elements depends on the order of traversal
 which is specified by the traversal hibiclens instance the second example
 is to aggregate data from a tree by using a fold so in fact since fold
 is an operation of traverse where the negative factor is a constant factor
 here we have just used fold map essentially we don't need traversable here
 we it's efficient to have foldable we could have defined this function
 by folding with with a list but let's continue using traverse just so that
 we understand these are very much related to each other so here's a definition
 of a simple tree tag it has a leaf of type A and it has a branch with two
 trees now we define the function instance in the usual way and then we
 define the traversal industry which is defined also in the usual way this
 is a recursive construction construction for and so I'm just writing it
 out this follows from the recursive construction if we have a leaf and
 we just put the leaf constructor under F and if we have a branch and we
 run sequence on both branches this is a recursive call to the sequence
 function that we're defining right now and then we zip the results and
 put the result in to pull under the branch here are some example values
 of this type so this is a tree of integers and this is a tree of strings
 and I driven this picture to visualize this tree t2 has a more complicated
 structure T 1 is just 1 2 & 3 it's easy to see what T 2 is not so easy
 to see anymore so let's fold over T 1 so T 1 is 1 2 3 in order to fold
 let's define a 1:08 for integers which will be a multiplication and what's
 the fold map with a function that squares each element so the result of
 fold map will be the product of squares of all and of all the elements
 stored in the tree which will be 1 times 4 times 9 which is 36 the third
 example is to decorate a tree with order labels obtained from a depth-first
 traversal so for instance this tree if we Traverse a depth first then first
 we'll reach a and we'll reach B then C and then D so then the order of
 traversal is 1 2 3 4 and so we expect these labels to be attached so how
 do we attach labels like this way it's not just a map map would we can
 certainly attach constant or a function of each of the label each of the
 element but that's not we won't want to attach a value that depends on
 the traversal so that's the Traverse and since it depends on the traversal
 we need to compute it as we go and so that's I mean we need to maintain
 state as we go as we traverse the tree and maintain in the state can be
 done with the state monad so we use that statement others duplicative function
 and that expresses the effect that we are traversing with so to visualize
 this traversal I could say that we are first so let's Traverse t2 since
 we have it on the screen so we first Traverse t2 by visiting a and we have
 some function that takes a and returns a monad value or a purgative function
 value in general now we done this being and we combine the effects so we
 have four different effects in these four different a purgative functionaries
 we need to combine them using zip and so the result is an F of tuple of
 a B here and then it's going to be this nested tuple so it's f of domestic
 tuple and then we have to recreate the three structure out of that nested
 tuple by remembering where these a B and C and D were in it in the tree
 and we have to reconstruct a tree under F so this and I'm not going to
 write much more detail with basic analysis so it's to be reconstructed
 as the value of this type after after zip and you would just have an F
 of some tuple and you could have converted it to a list first but then
 you completely lose the structure of the tree so the traverse operation
 must somehow keep track of the structure of the continue and you recreate
 it after zipping so it zips the effects so the effects are combined linearly
 in the traversal order using the zip and then after the effects are combined
 effects are mono it always of some kind so they are combined linearly there
 is no tree structure only effects but there is tree structure on the values
 ABCD or whatever values you get after you transform them with the function
 f and so those values have to be arranged so that could be of type B those
 values have to be arranged into the same tree structure as before so now
 we are going to use a state monad as the positive effect and statement
 others applicative and you will use if statement values together what happens
 is that you update the state each state mullet value could update the state
 in some way and so this is a linear sequence of effects that you need to
 combine by updating the state first using this updater than using this
 updater and so on in the linear order of traversal and that's what well
 we will use now we'll have a monadic value make label so we define first
 of all a state monad I'm using the Katz library with integer state so for
 convenience I'll call this s right now just in this test so I'll I define
 a make label value which is a monadic value that updates the state and
 returns also this value that is the previous value before I'm dating I
 could return the next value it doesn't really matter and that's going to
 be melodic value that we are going to produce for each of the elements
 of the tree now we actually need to represent this as an applicative factor
 so let me just quickly convert to my zip typeclass which is my my version
 of applicative of course the cats library already has a positive instance
 for this but it's easier to use my my typeclasses because they're very
 small they don't have a lot of methods and it's easy to see what they do
 so we need to define the wrapped unit which is just a pure of state factor
 and we need to define zip which is defined in a regular way for anyone
 that this is just combined the two effects in this order we could have
 changed the order here so this is this is a freedom but let's just keep
 this order and this function will allow us to produce her with zip tie
 plus instance from a statement well you know what's right a tree traversal
 so a tree traversal we already implemented up here so I just copied this
 code in I don't think I needed to duplicate nice code we can just remove
 this code so how do we use that so we have t2 which was defined before
 that we Traverse using the effect type yes so this is the apocatip factor
 that we have now a wizard instance for we have this was a probe s and the
 result type is going to be a tuple of string int so we're adding an integer
 label to a string type of the tree which which t2 has 32 think and the
 type is tray of string so the function with which which reverse takes a
 label and prefer this make label operation which is a monadic value and
 then we map now this magnetic value returns the integer and then we map
 that integer into a tuple with the previous tree leaf is really called
 leaf action to be more clear so we map a tree leaf to a tuple of leaf and
 label and we get out of the Monad so now this is a value of type s of tree
 of string int so this is a result of traversal and now we need to run it
 so we run the statement out on the initial value one and we extract the
 value out of it so this is that cats library API two is to extract values
 from statement and the result is as expected so it's a labeled with 1v
 we still in soon so in this way we can decorate the tree with labels that
 are computed as we go on in a traversal the next example is templum and
 skin functions scan map and scan left so we have seen that fold can be
 implemented if you have it reversible and scan also follows from properties
 of traversable so scan map is something I made up it's a method analogous
 to fold map where you have a monoid and you map your data to a monoid type
 and then the result is that unlike fold map it's not just one monoid value
 that aggregates everything you don't just accumulate the final value you
 keep all the intermediate accumulated values and put them back into your
 container so this is like the scan function so how does it work we use
 a statement again it's state is the MU node so initially it will be empty
 and then we will accumulate a monoid state so this is how we accumulate
 we get the previous state and we set the new accumulated state and then
 we get again in new states so that we have it on hand and then we Traverse
 with a function that is f which is this given F followed by accumulate
 and so the result is s of Z which is a state that accumulates Z and also
 gives it as a value so after traversing we get a value of type s of L of
 Z's and then we run it on an initially empty value and that's what we return
 extracting out of the state monad after we have run it so here's the test
 let's use a string as monoid so we imported a cat's instance just for standard
 string 108 and let's do a scan map on t2 with no transformation so then
 we're just going to accumulate the string as we go so we get a a b a b
 c a b c d so that's the result of scan map and we can also implement the
 standard scan left function which is very similar except we don't accumulate
 a monoid now we just accumulate a value of some arbitrary type z and we
 do the same thing as we did before very similar code and here's a test
 so we let's accumulate the length of strings in the in the tree so then
 we'll get one two three four because all all strings have length 1 and
 the last example is the traverse a rigid tree or non monadic tree as I
 don't think vegetation well it is a widely used word to describe this kind
 of tree but basically imagine a tree that must have all branches fall so
 it cannot be unbalanced then it must be full it's a binary tree that must
 have one two four eight 16 32 and so on elements and no other number of
 elements can be in the tree that's very rigid in its shape this recursive
 type equation he finds it and you can easily see why so it's either a or
 it's the same T of any times a so then it's either a times a or the same
 tree of a times a times a times a so then it's for A's or eight A's or
 sixteen is consumed so it's it's at this infinite disjunction with 1 a
 or 2 is 4 4 8 or 8 8 and so on so that's that's why this equation works
 not we don't have a construction where I did not write down the construction
 that can generalize this tree this kind of construction could be generalized
 like this where you have a recursive equation with some buy furniture yes
 and the second type 300 - 2 s is not a la as it was previously not just
 LA but it's L of some RA where R is another function so in this case it
 will be a pair but in general it could be some other function and that
 function must be both applicative and reversible and if so then I believe
 if this construction will work as well so this is a more general recursive
 construction let's see the code for this so the definition of the tree
 type is this it has a single element in the branch which is a tree of the
 pair parameter instead so we substitute to the type parameter which is
 kind of non-trivial so we can define the functor instance which is a bit
 of work because now we need to map this branch of type 3 of a a we need
 to map it recursively with a function that map's a a to be me but we don't
 have that function we have a to be so we need to construct a function that
 map's a a to be B out of F and the traversal is again a depth-first traversal
 where the leaf is handled the same way as before but the branch is handled
 differently because we actually have this kind of type and we need to get
 this so we need to do we need to use zip for F in order to pull F out of
 the tuple and so we first zip the FS together like this and this needs
 to be done under the B so it's a b fa fa map of the zip so that's going
 to have B of F of praa and then we sequence that so we get F of of PNA
 and then we wrap it into the branch so that's how traversal works and certainly
 we tested you know this is how we would create this data structure so it's
 always branch branch branch branch and finally leaf with a very large may
 be nested tuple so this is why this tree is so rigid he does not have cannot
 have unbalanced shape so that works we use in mono omoide instance for
 integer and do a fold map with identity to get the sum of all these numbers
 so these examples indicate that we can do a lot of things with Traverse
 but there are there are actually things we cannot do using each others
 because the Traverse separation we remember it is an operation that needs
 to be generic in the effect against which we Traverse in this applicative
 factor so two things that cannot be implemented the traversal which you
 find interesting but this is so or the breadth-first traversal for a tree
 so imagine a tree of this shape and you want to do breadth-first traversal
 so you traverse first at this level you get one and you traverse at this
 level you get to an elite reverse at this level now that can cannot be
 expressed as a traversal with some effect because as I indicated here to
 visualize a traversal we need to imagine that we are computing a large
 linear sequence of effects into one combining a large linear sequence of
 effects into one big effect and now in order to express this you would
 have to have to know for example here that this two must be two and not
 one now this effect cannot come from just recursive traversal you cannot
 just take a usual recursive depth first traversal and run some more nuts
 and clever Monat with it and get this other chamber so now we certainly
 probably can implement it in some other way but I don't see how you can
 simply do a recursive function on a tree that traverses it against an applicati
ve factor and get this effect and especially when you call recursively on
 this subtree you need to know how many nodes will be in some other levels
 in some other subtree so it's not clear how you could possibly get that
 information from any kind of monitor or [Music] applicative function now
 certainly you can implement breadth-first traversal but what I'm saying
 is that you cannot take some special monad and some recursive function
 calls and implement it so easily I hope you can still implement it in some
 way that is not too bad as a traversal certainly the standard way of implementi
ng breadth-first traversal to use a queue or you in queue each node and
 then you in queue it to children and then you DQ and as you dqu in queue
 more so that can be certainly done in a statement that that computation
 but the problem is you need the traversal which recreates the original
 structure so if if all you want is twofold then you can implement fold
 in a breadth-first while using a queue like that but what you need is to
 recreate the original tree structure and that's very cursive structure
 that has a depth-first logic to it and so that's the difficulty and certainly
 you can do it with a lot of extra work it's not just a couple of lines
 of code like it was for depth-first traversal so at this point I don't
 have code for this maybe this can be done in some clever way but I haven't
 found it and the second thing that I don't think you can do is to label
 depth of the tree using a traversal so again it's a similar problem that
 effects so these aren't going to be effects and obviously you need some
 kind of state to hold this one and then update it to two and two three
 but effects are concatenated linearly and so it cannot be that this three
 is the same as this you cannot avoid concatenating this effect with this
 one when you do a traversal because of this linear nature of combining
 effects and you cannot avoid combining effects during traversal and so
 there's no way to skip incrementing the counter when you do choose ourselves
 so I don't think you can easily express this kind of labeling and this
 is trivial to do ad hoc as a function on a tree but what you want is to
 have a generic traversal which is generic in the factor f and just uses
 the zip and combines the effects and that's why traversals are not so flexible
 you cannot avoid incrementing your counter you cannot have logic that says
 oh here I don't increment because they're at the same level can't have
 that logic you must combine the only factors together so I keep talking
 about being generic in the function f so let me talk about it in a more
 rigorous manner so what we're looking for is to be generic in the sense
 that the code for traverse as well as the code for the sequence in it should
 not depend on a specific function f it should only use the methods P R
 and zip or maybe map as well from F and [Music] recall recall how we dealt
 with a similar problem when we discovered founders so a factor is a data
 container that is generic in type of the data that it holds and the map
 function or F map is a function that cannot use specific type information
 about A or B it must manipulate this data blindly with no change you take
 a container you take each element a very replacement may be and put it
 back at the same place but you don't know what types those are and so we
 expressed the law of natural T for various functions by saying that F map
 should come should commute with those functions so you can transform first
 or you can transform later and that's what it means that it's generic in
 the type of data so similarly generic in the function f means that if we
 map a functor F to some other function G then a traverse with respect to
 F will be mapped to the Traverse with respect to G so we need this mapping
 somehow so this cannot be this can be formulated mathematically I don't
 want to spend too much time on this but I just want to mention this is
 an important mathematical development perhaps but this is the first time
 where we have seen this kind of thing and we don't have I don't have good
 notation right now for this natural transformations between applicative
 functors and its need to be considered so here's the mathematical formulation
 we consider - Lickety functors F and G and we consider a natural transformation
 between them such that it Maps period of F into pure of G and it maps zip
 of F into the project and then we demand that it also should map the Traverse
 of F into Traverse of G so if we do that well all we do is we just say
 we have a traverse with respect to F let's apply it and then map F to G
 in the result because the result of Traverse is F of something F of some
 L of a or L of B so we can map that into G of not using the natural transformat
ion or we can first map f to G and then apply Traverse and that should be
 the same and so this is a natural T with respect to the functor as a type
 parameter so it's a higher-order type parameter itself otherwise it's quite
 similar to not two naturality and it's just more complicated because it's
 not just any natural transformation natural transformation by itself has
 laws already and in addition to being a natural transformation it needs
 to preserve the implicative properties of f so that pure is mapped to pure
 zip is mapped to zip and and the laws of course must hold for both implicated
 factors so if you look at this notation which is slightly made shorter
 on purpose by omitting various type parameters it really looks like lifting
 from a function f to G into function of traversing you have to traverse
 G but F and G are not types they're type constructors so and this is not
 a function this is a natural transformation which is more complicated object
 so when we used category theory to describe such liftings we would usually
 say this is a morphism in one category and this is a morphism in another
 category but a morphism as we define it was always between two types now
 we don't have types we have type constructors so we need basically a morphism
 between type constructors so that's more more precisely between implicative
 factors so a morphism between applicative functions that's what we need
 to lift into a morphism of traversable faculties and so that requires a
 more general definition of category than what I have given so far we're
 in them in the definition I've given so far morphisms were just twisted
 function types but now we need morphisms between type constructors or even
 more restricted ones morphisms between applicative functions with extra
 properties so category theory prescribes this in a general definition of
 category can be given which I'm not going to give right now because I don't
 see in the use for it other than to indicate the property of natural T
 as being similar to previous properties I encourage you to look at category
 theory at some point but I will only talk about what I see it as being
 useful and so right now it is useful to think about this as a lifting and
 the wall is of course need to hold such as identity and Composition so
 if we map F to F then we don't change anything that should be lifted into
 identity and composition F to G to H mapped it to composition of those
 mappings and so on so those are the rigorous four forms for the naturality
 war with respect to applicative function I'm not writing it down in detail
 because just as naturality with respect to ordinary type parameter this
 is this morality with respectively funter is going to be satisfied automaticall
y by any code that nearly uses peer and zip and why is that it's because
 when we perform a natural transformation that maps FPR to GD P R and F
 zip to gzip the code doesn't actually change at all the code has f as a
 type parameter and it just uses pure and zip in the code to cause them
 as we have been doing when we implemented the traverse instances for example
 so let's see here is for example we are using zip the zip is from the function
 f but F is a type parameter so if we now apply a natural transformation
 from F to G for some other negative function G this code doesn't change
 at all it still uses the zip and we have the condition that there's natural
 transformation that maps F to G it Maps zip to zip and peer to peer and
 and map to map of course that's the natural T of natural transformation
 so our code won't change and our code therefore is invariant under this
 natural transformation and so it's automatically going to satisfy naturality
 with respect to the type parameter F and it also will automatically satisfy
 not reality with respect to time over a and that's why we never need to
 check these laws explicitly or even spend so much time writing them explicitly
 because they are they are useful sometimes when your reason about code
 and prove some other law was then learned are useful but for coding for
 implementing you always have natural T automatically so this concludes
 chapter 9 and here are some exercises for you to implement let me just
 comment and this exercise so I don't want you to prove laws by hand for
 this factor T it's cumbersome but instead use constructions so we have
 proved general constructions so if you express T as a recursive equation
 using some by factor s and you show that the wife on dress is by traversable
 again using constructions of course then you don't need to and to do the
 proof yourself if the constructions already proved once you have found
 them and similarly for for this construction you don't need to prove anything
 by hand this exercise is a little different but you can try to prove this
 extra construction that I mentioned this one but it's very similar to other
 constructions and so it's not necessarily part of this exercise this concludes
 chapter 9 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
