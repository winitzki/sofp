#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset


\end_layout

\begin_layout Chapter
Traversable functors
\begin_inset CommandInset label
LatexCommand label
name "chap:9-Traversable-functors-and"

\end_inset


\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 style
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout

\family typewriter
map
\family default
/
\family typewriter
reduce
\family default
 programming style
\end_layout

\end_inset

 is a major industrial use case of functional programming.
 Previous chapters examined systematically the properties of functions used
 in that style (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

) and generalized them to many different type constructors.
 This chapter adopts the same approach to study and generalize the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method.
 In this way, we will obtain a complete understanding of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 programming style.
\end_layout

\begin_layout Subsection
From 
\family typewriter
reduce
\family default
 and 
\family typewriter
foldLeft
\family default
 to 
\family typewriter
foldMap
\family default
 and 
\family typewriter
traverse
\family default

\begin_inset CommandInset label
LatexCommand label
name "subsec:From-reduce-and-foldleft-to-foldmap"

\end_inset


\end_layout

\begin_layout Standard
The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](xs: Seq[A])(update: (A, A) => A): A
\end_layout

\begin_layout Plain Layout

def foldLeft[A, B](xs: Seq[A])(b0: B)(update: (B, A) => B): B
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{reduce}:\text{Seq}^{A}\rightarrow(A\times A\rightarrow A)\rightarrow A\quad,\quad\quad\text{foldLeft}:\text{Seq}^{A}\rightarrow B\rightarrow(B\times A\rightarrow B)\rightarrow B\quad.
\]

\end_inset

In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, the accumulated result is of a different type (
\begin_inset Formula $B$
\end_inset

) than the type of sequence elements (
\begin_inset Formula $A$
\end_inset

).
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is a more general version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
 We can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](xs: Seq[A])(update: (A, A) => A): A = xs.tail.foldLeft(xs.head)(updat
e)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation goes over each element of a sequence and accumulates the updates,
 returning the final updated value.
 We have seen many examples of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Now we would like to generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to data structures other than sequences.
 Such a generalization must be based on imposing suitable laws, but it is
 not obvious what laws 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 must satisfy (other than naturality laws that will hold automatically for
 any fully parametric code).
 To make progress, we will generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 further to obtain a new function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, for which we can motivate non-trivial laws.
 This generalization goes in two steps, first transforming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and then to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The way from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
foldMap
\family default
 function
\end_layout

\end_inset

starts by changing the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

update: (B, A) => B
\end_layout

\end_inset

 to an equivalent curried form with a flipped order of arguments:
\begin_inset Formula 
\[
\text{upd}:A\rightarrow B\rightarrow B\quad.
\]

\end_inset

So, 
\begin_inset Formula $\text{upd}\,(x^{:A})$
\end_inset

 has type 
\begin_inset Formula $B\rightarrow B$
\end_inset

.
 The key observation is that the set of all functions of type 
\begin_inset Formula $B\rightarrow B$
\end_inset

 is a monoid (denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidFunc
\end_layout

\end_inset

 in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
monoid
\end_layout

\end_inset

 For brevity, we will here denote that monoid by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MF
\end_layout

\end_inset

.
 The empty element of that monoid is the identity function (
\begin_inset Formula $e_{\text{MF}}\triangleq\text{id}^{:B\rightarrow B}$
\end_inset

), and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

 operation is the function composition (
\begin_inset Formula $f^{:B\rightarrow B}\oplus_{\text{MF}}g^{:B\rightarrow B}\triangleq f\bef g$
\end_inset

).
 Now the evaluation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation can be visualized like this:
\begin_inset Formula 
\begin{align*}
 & \text{foldLeft}\left(\left[x_{1},x_{2},x_{3}\right]\right)\left(b_{0}\right)\left(\text{upd}\right)=b_{0}\triangleright\text{upd}\left(x_{1}\right)\triangleright\text{upd}\left(x_{2}\right)\triangleright\text{upd}\left(x_{3}\right)\\
 & =b_{0}\triangleright\text{upd}\left(x_{1}\right)\bef\text{upd}\left(x_{2}\right)\bef\text{upd}\left(x_{3}\right)=b_{0}\triangleright\big(\text{upd}\left(x_{1}\right)\oplus_{\text{MF}}\text{upd}\left(x_{2}\right)\oplus_{\text{MF}}\text{upd}\left(x_{3}\right)\big)\quad.
\end{align*}

\end_inset

This formulation suggests that we could replace the specific monoid (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MF
\end_layout

\end_inset

) used in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 by an arbitrary monoid (
\begin_inset Formula $M$
\end_inset

).
 The new, more general function is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 To obtain that function, we first change the order of the curried arguments
 for convenience:
\begin_inset Formula 
\[
\text{foldMap}\,(\text{upd})(\text{xs})\left(b_{0}\right)\triangleq\text{foldLeft}\,(\text{xs})\left(b_{0}\right)(\text{upd})\quad.
\]

\end_inset

Omitting the argument 
\begin_inset Formula $b_{0}$
\end_inset

, we may visualize the computation performed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
\text{foldMap}\,(\text{upd})\left(\left[x_{1},x_{2},x_{3}\right]\right)=\text{upd}\left(x_{1}\right)\oplus_{M}\text{upd}\left(x_{2}\right)\oplus_{M}\text{upd}\left(x_{3}\right)\quad.
\]

\end_inset

The type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

upd
\end_layout

\end_inset

 is now 
\begin_inset Formula $A\rightarrow M$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow B\rightarrow B$
\end_inset

.
 So, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 must be:
\begin_inset Formula 
\[
\text{foldMap}:(A\rightarrow M)\rightarrow\text{Seq}^{A}\rightarrow M\quad.
\]

\end_inset

This type signature assumes that 
\begin_inset Formula $M$
\end_inset

 is a monoid type.
 We can now implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldMap[M: Monoid, A](f: A => M): Seq[A] => M =
\end_layout

\begin_layout Plain Layout

  _.foldLeft(Monoid[M].empty) { (m, a) => m |+| f(a) }
\end_layout

\end_inset

We can also implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 by using the monoid instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MF
\end_layout

\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def monoidFunc[A]: Monoid[A => A] = ...
\end_layout

\begin_layout Plain Layout

def foldLeft[A, B](xs: Seq[A])(b0: B)(update: (B, A) => B): B =
\end_layout

\begin_layout Plain Layout

  foldMap[B => B, A](a => b => update(b, a))(xs)(b0)
\end_layout

\end_inset

We will prove later that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are in fact equivalent.
\end_layout

\begin_layout Standard
The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 suggests that we could replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[_]
\end_layout

\end_inset

 by an arbitrary type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

.
 We call 
\series bold
foldable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
foldable functor
\end_layout

\end_inset

 a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

 for which the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 method is defined:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldMap_L[M: Monoid, A](f: A => M): L[A] => M
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{foldMap}_{L}:\left(A\rightarrow M\right)\rightarrow L^{A}\rightarrow M\quad,\quad\text{assuming that }M\text{ is a monoid}\quad.
\]

\end_inset

The function 
\begin_inset Formula $\text{foldMap}_{L}$
\end_inset

 works in the same way for all monoids 
\begin_inset Formula $M$
\end_inset

 (but differently for each 
\begin_inset Formula $L$
\end_inset

).
 
\end_layout

\begin_layout Standard
The final step towards the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method is to replace an arbitrary monoid 
\begin_inset Formula $M$
\end_inset

 by an arbitrary 
\emph on
applicative
\emph default
 functor 
\begin_inset Formula $F^{B}$
\end_inset

 with a new type parameter 
\begin_inset Formula $B$
\end_inset

.
 This step is not straightforward: values of applicative functor types are
 not monoids (we do not necessarily have an operation of type 
\begin_inset Formula $F^{B}\times F^{B}\rightarrow F^{B}$
\end_inset

).
 So, we will give an independent motivation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method in the next subsection.
\end_layout

\begin_layout Subsection
The 
\family typewriter
traverse
\family default
 operation
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-traverse-operation"

\end_inset


\end_layout

\begin_layout Standard
Consider the task of waiting for several concurrent operations to finish.
 As an example, suppose we have a list of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 and a processing function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Future[B]
\end_layout

\end_inset

.
 We need to apply the processing function in parallel to all items from
 the list and wait until the entire data set is processed.
\end_layout

\begin_layout Standard
The Scala standard library has a special method (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.traverse
\end_layout

\end_inset

) to use in this situation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val data: List[A] = ???
\end_layout

\begin_layout Plain Layout

val processing: A => Future[B] = ???
\end_layout

\begin_layout Plain Layout

implicit val ec: ExecutionContext = ???
\end_layout

\begin_layout Plain Layout

val results: Future[List[B]] = Future.traverse(data)(processing)
\end_layout

\end_inset

Since the processing of each element is asynchronous, the result is wrapped
 in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 type constructor.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method will mark that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 value as finished when all processing is done.
\end_layout

\begin_layout Standard
If we ignore the implicit argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ExecutionContext
\end_layout

\end_inset

 (which is specific to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 class) and also flip the first two curried arguments, we will arrive at
 the following type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{traverse}:(A\rightarrow\text{Future}^{B})\rightarrow\text{List}^{A}\rightarrow\text{Future}^{\text{List}^{B}}\quad.
\]

\end_inset

Generalizing to other type constructors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, we obtain:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def traverse[A, B, F[_]: Applicative: Functor](f: A => F[B]): L[A] => F[L[B]]
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{trav}_{L}^{F,A}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}\quad.
\]

\end_inset

In this type signature, we have chosen the parameter names 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 specifically to help us avoid errors (e.g., writing 
\begin_inset Formula $L^{F^{B}}$
\end_inset

 instead of 
\begin_inset Formula $F^{L^{B}}$
\end_inset

) by recalling the example with 
\begin_inset Formula $F=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset Formula $L=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It turns out that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method can work in the same way for any 
\emph on
applicative
\emph default
 functor 
\begin_inset Formula $F$
\end_inset

.
 A functor 
\begin_inset Formula $L$
\end_inset

 having a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method of this type is called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
traversable functor
\end_layout

\end_inset


\series bold
traversable
\series default
.
\end_layout

\begin_layout Standard
The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are similar except that 
\begin_inset Formula $M$
\end_inset

 is replaced by 
\begin_inset Formula $F^{B}$
\end_inset

 or 
\begin_inset Formula $F^{L^{B}}$
\end_inset

 as needed.
 To see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 is a special case of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, take a constant functor 
\begin_inset Formula $F^{A}\triangleq M$
\end_inset

, which is applicative if 
\begin_inset Formula $M$
\end_inset

 is a monoid (as shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-applicative-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 With this choice of 
\begin_inset Formula $F$
\end_inset

, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 reduces to that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Before studying the properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, we will look at some examples of its practical use.
\end_layout

\begin_layout Section
Practical use of folding and traversing operations
\end_layout

\begin_layout Subsection
Implementing 
\family typewriter
traverse
\family default
 for various data types
\end_layout

\begin_layout Standard
To understand how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 works, let us implement it for some data types, including lists and trees.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traverse-for-1+a*a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-for-1+a*a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the type constructor 
\begin_inset Formula $L$
\end_inset

 defined by:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type L[A] = Option[(A, A)]
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For the given type constructor 
\begin_inset Formula $L$
\end_inset

, write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]]
\end_layout

\end_inset

In the short type notation, this type signature is:
\begin_inset Formula 
\[
\text{trav}_{L}:(A\rightarrow F^{B})\rightarrow(\bbnum 1+A\times A)\rightarrow F^{\bbnum 1+B\times B}\quad.
\]

\end_inset

 Let us implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

, aiming to preserve information.
 We need to compute a value of type 
\begin_inset Formula $F^{\bbnum 1+B\times B}$
\end_inset

.
 Begin by pattern matching on the argument of type 
\begin_inset Formula $\bbnum 1+A\times A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] = {
\end_layout

\begin_layout Plain Layout

  case None             => Applicative[F].pure(None)  // No other choice
 here.
\end_layout

\begin_layout Plain Layout

  case Some((a1, a2))   => ???                        // Need a value of
 type F[Some[(B, B)]] here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The only way of getting values of type 
\begin_inset Formula $B$
\end_inset

 is by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

.
 We will then get two values of type 
\begin_inset Formula $F^{B}$
\end_inset

.
 We may merge them into a single value of type 
\begin_inset Formula $F^{B\times B}$
\end_inset

 via 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method.
 It remains to use 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 in order to transform 
\begin_inset Formula $F^{B\times B}$
\end_inset

 to the required type 
\begin_inset Formula $F^{\bbnum 1+B\times B}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B]): Option[(A, A)]
 => F[Option[(B, B)]] = {
\end_layout

\begin_layout Plain Layout

  case None             => Applicative[F].pure(None)          // No other
 choice here.
\end_layout

\begin_layout Plain Layout

  case Some((a1, a2))   => Applicative[F].zip(f(a1), f(a2)).map { case (b1,
 b2)  => Some((b1, b2)) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the code notation, this is written as:
\begin_inset Formula 
\[
\text{trav}_{L}(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{\bbnum 1+B\times B}\\
\hline \bbnum 1 & \_\rightarrow\text{pu}_{F}(1+\bbnum 0^{:B\times B})\\
A\times A & (f\boxtimes f)\bef\text{zip}_{F}\bef(b_{1}^{:B}\times b_{2}^{:B}\rightarrow\bbnum 0^{:\bbnum 1}+b_{1}\times b_{2})^{\uparrow F}
\end{array}\quad.
\]

\end_inset

The code must use 
\begin_inset Formula $F$
\end_inset

's methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

.
 This makes it clear why 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 requires 
\begin_inset Formula $F$
\end_inset

 to be an applicative functor.
 Apart from that requirement, the code works in the same way for all 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traversable-seq"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversable-seq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type constructor.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to implement the following type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B]): List[A] => F[List[B]]
\end_layout

\end_inset

A list may be empty, or may have a head and a tail.
 Similarly to the code in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-for-1+a*a"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we use 
\begin_inset Formula $F$
\end_inset

's methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to compute a suitable value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[Seq[B]]
\end_layout

\end_inset

 in these cases.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B])(la: List[A]):
 F[List[B]] = la match {
\end_layout

\begin_layout Plain Layout

  case Nil            => Applicative[F].pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => (f(head) zip trav(f)(tail)).map { case (headB, tailB)
  => headB :: tailB }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each element of the list and accumulates the resulting 
\begin_inset Formula $F$
\end_inset

-effects of type 
\begin_inset Formula $F^{B}$
\end_inset

.
 The 
\begin_inset Formula $F$
\end_inset

-effects are merged using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 function (implemented as an extension method).
\end_layout

\begin_layout Standard
In the code notation, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 looks like this:
\begin_inset Formula 
\[
\text{trav}_{\text{List}}(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{\bbnum 1+B\times\text{List}^{B}}\\
\hline \bbnum 1 & \_\rightarrow\text{pu}_{F}(1+\bbnum 0^{:B\times\text{List}^{B}})\\
A\times\text{List}^{A} & \big(f\boxtimes\overline{\text{trav}}_{\text{List}}(f)\big)\bef\text{zip}_{F}\bef(h^{:B}\times t^{:\text{List}^{B}}\rightarrow\bbnum 0^{:\bbnum 1}+h\times t)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traverse-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for a binary tree.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will use the following binary tree data type denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait T2[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](a: A)                 extends T2[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](l: T2[A], r: T2[A]) extends T2[A]
\end_layout

\end_inset

We implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 similarly to the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Binary-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B])(t: T2[A]): F[T2[B]]
 = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)          => f(a).map(b => Leaf(b))            // Reproduce
 the Leaf structure under F.
\end_layout

\begin_layout Plain Layout

  case Branch(t1, t2)   =>
\end_layout

\begin_layout Plain Layout

    val (r1, r2) = (trav(f)(t1), trav(f)(t2))    // Traverse the two branches
 and obtain two results.
\end_layout

\begin_layout Plain Layout

    (r1 zip r2).map { case (b1, b2)  => Branch(b1, b2) }   // Reproduce the
 Branch structure under F.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the code notation, this function looks like this:
\begin_inset Formula 
\[
\text{trav}\,(f^{:A\rightarrow F^{B}})\triangleq\,\begin{array}{|c||c|}
 & F^{B+\text{T2}^{B}\times\text{T2}^{B}}\\
\hline A & f\bef(b^{:B}\rightarrow b+\bbnum 0^{:\text{T2}^{B}\times\text{T2}^{B}})^{\uparrow F}\\
\text{T2}^{A}\times\text{T2}^{A} & \big(\overline{\text{trav}}\,(f)\boxtimes\overline{\text{trav}}\,(f)\big)\bef\text{zip}_{F}\bef(l^{:\text{T2}^{B}}\times r^{:\text{T2}^{B}}\rightarrow\bbnum 0^{:B}+l\times r)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The code first traverses the two sub-branches (using recursive calls to
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

) and then combines the resulting values.
 So, this implementation represents a depth-first, left-to-right traversal
 of the tree.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-traversal-perfect-shaped-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversal-perfect-shaped-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for a perfect-shaped tree (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree
\end_layout

\end_inset

, Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Perfect-shaped-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We begin writing code as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by pattern matching:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B])(t: PTree[A]):
 F[PTree[B]] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)     => f(a).map(b => Leaf(b))           // Reproduce the Leaf
 structure under F.
\end_layout

\begin_layout Plain Layout

  case Branch(t)   => ???  // Here t has type PTree[(A, A)].
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In line 3, we have a pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[(A, A)]
\end_layout

\end_inset

, but we need to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[Branch[B]]
\end_layout

\end_inset

 in that scope.
 Since a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 contains a recursive instance of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree
\end_layout

\end_inset

, it seems we need to use a recursive call of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 here.
 However, we cannot apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav(f)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 because the types do not match.
 We will be able to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 if instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => F[B]
\end_layout

\end_inset

 we had a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A) => F[(B, B)]
\end_layout

\end_inset

.
 We can create such a function out of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case (a1, a2) => f(a1) zip f(a2) }
\end_layout

\end_inset

 So, we write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  case Branch(t)   => trav { case (a1, a2) => f(a1) zip f(a2) }(t); ???
 } // Have F[PTree[(B, B)]].
\end_layout

\end_inset

We can now use 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method to restore the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 structure under 
\begin_inset Formula $F$
\end_inset

.
 The complete code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative : Functor](f: A => F[B])(t: PTree[A]):
 F[PTree[B]] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)     => f(a).map(b => Leaf(b))           // Reproduce the Leaf
 structure under F.
\end_layout

\begin_layout Plain Layout

  case Branch(t)   => (trav[(A, A), (B, B), F] { case (a1, a2) => f(a1)
 zip f(a2) }(t)
\end_layout

\begin_layout Plain Layout

                      ).map(x => Branch(x))          // Reproduce the Branch
 structure under F.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here we assumed that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 function is defined on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 as an extension method.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
These examples show how to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation for a container-like data structure 
\begin_inset Formula $L^{A}$
\end_inset

 that stores some values of type 
\begin_inset Formula $A$
\end_inset

.
 Each stored value of type 
\begin_inset Formula $A$
\end_inset

 is processed using the given function 
\begin_inset Formula $f:A\rightarrow F^{B}$
\end_inset

.
 All of the resulting 
\begin_inset Formula $F$
\end_inset

-effects need to be collected and merged (using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

) into a single 
\begin_inset Formula $F$
\end_inset

-effect that wraps a value of type 
\begin_inset Formula $L^{B}$
\end_inset

.
 The wrapped value should reproduce the shape of the data structure that
 was present in the input value of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
In all examples above, we merged all 
\begin_inset Formula $F$
\end_inset

-effects together by collecting each 
\begin_inset Formula $F$
\end_inset

-effect exactly once.
 It would be strange if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation repeated some 
\begin_inset Formula $F$
\end_inset

-effects, as in the following code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def badtrav[A, B, F[_]: Applicative : Functor](f: A => F[B])(la: List[A]):
 F[List[B]] = la match {
\end_layout

\begin_layout Plain Layout

  case Nil            => Applicative[F].pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => (f(head) zip f(head) zip badtrav(f)(tail))    
 // Use the F-effect twice.
\end_layout

\begin_layout Plain Layout

                           .map { case (headB, (_, tailB))  => headB :: tailB
 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Although this implementation fits the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, it contradicts the intuition of traversing the sequence only once.
 When 
\begin_inset Formula $F=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

, the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

badtrav(f)(xs)
\end_layout

\end_inset

 will start 
\emph on
two
\emph default
 parallel computations for each element of the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and ignore one of the results.
 When 
\begin_inset Formula $F$
\end_inset

's effect describes parsing (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Parsing-with-applicative-and-monadic-parsers"
plural "false"
caps "false"
noprefix "false"

\end_inset

) or other computations that maintain an internal state, invoking such an
 
\begin_inset Formula $F$
\end_inset

-effect twice will likely lead to incorrect results.
 Below we will see that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 prohibit implementations that either repeat some of the 
\begin_inset Formula $F$
\end_inset

-effects or ignore some of the values.
\end_layout

\begin_layout Subsection
Aggregating tree-like data by folding.
 Breadth-first traversal
\begin_inset CommandInset label
LatexCommand label
name "subsec:Aggregating-tree-like-data-bfs"

\end_inset


\end_layout

\begin_layout Standard
Although 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 (and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

) are special cases of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, it is often easier to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 directly.
 Let us look at some examples of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 that implements different kinds of tree traversals.
\end_layout

\begin_layout Standard
One implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 corresponds to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldMap[A, M: Monoid](f: A => M)(t: T2[A]): M = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)          => f(a)
\end_layout

\begin_layout Plain Layout

  case Branch(t1, t2)   => foldMap(f)(t1) |+| foldMap(f)(t2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A special case of a monoid is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

; its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine
\end_layout

\end_inset

 operation is the concatenation of lists.
 If we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 with the monoid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M = List[A]
\end_layout

\end_inset

 and the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => List[A]
\end_layout

\end_inset

 that creates a single-element list, we obtain a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 that converts a tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList[A]: T2[A] => List[A] = foldMap[A, List[A]](List(_)) // Need a
 Monoid instance for List[A].
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the same way, we may implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList: L[A] => List[A]
\end_layout

\end_inset

 for any foldable functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 captures the requirement that a foldable functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 must have a well-defined way of iterating over the data items stored inside
 it.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 is foldable if there is a known way of extracting its data items in the
 form of a list.
 We may then use standard aggregation operations on lists (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, and so on).
 Below, we will prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 So, a foldable functor allows us to apply any aggregation operation to
 the data stored in the functor.
 
\end_layout

\begin_layout Standard
An aggregation's results may depend on the order of data traversal.
 It is important that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 can be implemented in different ways by choosing a specific order in which
 the data from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 is copied to a list.
 Some data structures have a 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

 traversal order that is easiest to implement.
 Let us see some examples of implementing different traversal orders for
 lists and trees.
\end_layout

\begin_layout Standard
The above code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 for the binary tree implements a depth-first traversal of the tree.
 We can see that by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 to an example tree (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "76col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t2: T2[Int] = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toList(t2)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(8, 3, 5, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent

\size footnotesize
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList(
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

)
\end_layout

\end_inset


\size small

\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Formula $=\left[8,3,5,4\right]$
\end_inset


\end_layout

\begin_layout Standard
Let us now implement another version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

, called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

, that performs the 
\emph on
breadth-first
\emph default
 traversal of a binary tree.
 The idea is to prepare a list of all leaf values at level 
\begin_inset Formula $0$
\end_inset

 in the tree, then a list of all values at level 
\begin_inset Formula $1$
\end_inset

, and so on.
 At each level, values must be collected left to right.
 The result will be a list of lists.
 For example, the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 shown above has no values at level 
\begin_inset Formula $0$
\end_inset

, value 
\begin_inset Formula $8$
\end_inset

 at level 
\begin_inset Formula $1$
\end_inset

, value 
\begin_inset Formula $4$
\end_inset

 at level 
\begin_inset Formula $2$
\end_inset

, and values 
\begin_inset Formula $3$
\end_inset

 and 
\begin_inset Formula $5$
\end_inset

 at level 
\begin_inset Formula $3$
\end_inset

.
 So, applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 to the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 will give the nested list 
\begin_inset Formula $\left[\left[\right],\left[8\right],\left[4\right],\left[3,5\right]\right]$
\end_inset

.
 Then we can 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 that list and obtain the list 
\begin_inset Formula $\left[8,4,3,5\right]$
\end_inset

, which is the breadth-first traversal order of the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Begin writing code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 by pattern matching on the tree structure:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toListBFS[A]: T2[A] => List[A] = toList2 andThen (_.flatten)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def toList2[A]: T2[A] => List[List[A]] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => List(List(a))    // Only one value at level 0.
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => ???         // Have toList2(l) and toList2(r).
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

After using recursive calls of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 on the left and right sub-trees (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

), we need somehow to combine the resulting lists.
 For the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

, applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 to the sub-trees will return the lists 
\begin_inset Formula $\left[\left[8\right]\right]$
\end_inset

 and 
\begin_inset Formula $\left[\left[\right],\left[4\right],\left[3,5\right]\right]$
\end_inset

.
 We need to concatenate the corresponding nested lists and obtain 
\begin_inset Formula $\left[\left[\right],\left[8\right],\left[4\right],\left[3,5\right]\right]$
\end_inset

.
 (An initial empty list needs to be added because the sub-trees begin one
 level deeper.) The standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 operation would not work correctly here: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 would truncate the longer list.
 Instead, we need to keep the longer list's elements.
 So, let us implement a special helper function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

listMerge
\end_layout

\end_inset

) for merging the nested lists in this way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def listMerge[A](l: List[List[A]], r: List[List[A]]): List[List[A]] = (l,
 r) match {
\end_layout

\begin_layout Plain Layout

  case (Nil, r)               => r        // Keep the elements from the
 longer list.
\end_layout

\begin_layout Plain Layout

  case (l, Nil)               => l
\end_layout

\begin_layout Plain Layout

  case (lh :: lt, rh :: rt)   => (lh ++ rh) :: listMerge(lt, rt)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can complete the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 and run some tests:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList2[A]: T2[A] => List[List[A]] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => List(List(a)) // Only one value at level 0.
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => listMerge(Nil :: toList2(l), Nil :: toList2(r))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toList2(t2)
\end_layout

\begin_layout Plain Layout

res1: List[List[Int]] = List(List(), List(8), List(4), List(3, 5))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toListBFS(t2)
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(8, 4, 3, 5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For lists and other sequences, the easiest traversal orders are either direct
 or reverse.
 A direct traversal is implemented by the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, while a reverse-order traversal is done simply by applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

 method, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

la.reverse.foldLeft(...)(...)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method may be implemented with different traversal orders.
 For comparison, we show the code for the direct-ordered and reverse-ordered
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 traversals:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// This code assumes that F has typeclass instances for Applicative and
 Functor.
\end_layout

\begin_layout Plain Layout

def travList[A, B](f: A => F[B])(la: List[A]): F[List[B]] = la match {
\end_layout

\begin_layout Plain Layout

  case Nil            => Applicative[F].pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => f(head).map2(travList(f)(tail)) { (x, y) => x +:
 y }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def travRevList[A, B](f: A => F[B])(la: List[A]): F[List[B]] = la.reverse
 match {
\end_layout

\begin_layout Plain Layout

  case Nil            => Applicative[F].pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail   => f(head).map2(travRevList(f)(tail)) { (h, t) => t
 :+ h }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travRevList
\end_layout

\end_inset

 first reverses the given list, so that 
\begin_inset Formula $F$
\end_inset

's effects are merged in the reverse order.
 Then it swaps 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

, which restores the original list structure wrapped under 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Standard
Implementing a breadth-first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for a tree is more difficult.
 It is not sufficient to convert the tree to a list in the breadth-first
 order and collect 
\begin_inset Formula $F$
\end_inset

's effects.
 We also need to restore the original tree structure wrapped under the functor
 
\begin_inset Formula $F$
\end_inset

.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Decorating-a-tree-breadth-first-traversal"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show an example of implementing a breadth-first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for binary trees.
\end_layout

\begin_layout Subsection
Decorating a tree.
 I.
 Depth-first traversal
\begin_inset CommandInset label
LatexCommand label
name "subsec:Decorating-a-tree1"

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method for a given tree-like data structure may be used to perform various
 operations on trees, as long as those operations are described by the effect
 of some applicative functor 
\begin_inset Formula $F$
\end_inset

.
 
\end_layout

\begin_layout Standard
An example of a tree operation is 
\begin_inset Quotes eld
\end_inset

decorating
\begin_inset Quotes erd
\end_inset

, i.e., adding labels of some sort to each leaf.
 Since tree-like data types are functors that have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method, a simple decorating operation replaces each leaf with a function
 of the data at that leaf.
 For instance, we may add the value 
\begin_inset Formula $20$
\end_inset

 to each leaf:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t2 = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t2.map(x => x + 20)  // Assuming a Functor instance for T2[_].
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Leaf(28), Branch(Branch(Leaf(23), Leaf(25)), Leaf(24)))
\end_layout

\end_inset

This transforms the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 into 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 28 [ [ 23 25 ] 24 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

.
 However, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method works separately with each leaf and cannot use any previously computed
 values.
 E.g., we cannot use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 function for trees, transforming the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 into 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ (8,0) [ [ (3,1) (5,2) ] (4,3) ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 with added indices (
\begin_inset Formula $0$
\end_inset

, 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, 
\begin_inset Formula $3$
\end_inset

).
 For such tasks, we need the additional functionality of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation.
\end_layout

\begin_layout Standard
Labeling the leaves of a tree with their traversal index requires us to
 update an internal state (the number of leaves seen so far) while traversing
 the tree.
 Recall that updating an internal state is the effect of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 Since all monads can also implement the applicative methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

), we may use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad as the applicative functor 
\begin_inset Formula $F$
\end_inset

 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
In this section, we will implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 for a 
\emph on
depth-first
\emph default
 tree traversal.
 Let us call that function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDF
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDF
\end_layout

\end_inset

 will have the form:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class St[A](run: Int => (A, Int))    // A State monad with internal
 state of type Int.
\end_layout

\begin_layout Plain Layout

                         // Assume that we have defined Applicative and
 Functor instances for St.
\end_layout

\begin_layout Plain Layout

def computeIndex[A]: A => St[(A, Int)] = ???                 // Define the
 
\begin_inset Quotes eld
\end_inset

decoration
\begin_inset Quotes erd
\end_inset

 function.
\end_layout

\begin_layout Plain Layout

def zipWithIndexDF[A](tree: T2[A]): T2[(A, Int)] = {
\end_layout

\begin_layout Plain Layout

  val afterTraverse: St[T2[(A, Int)]] = trav[A, (A, Int), St](computeIndex)(tree
)
\end_layout

\begin_layout Plain Layout

  afterTraverse.run(0)._1                        // Run the State monad and
 get the result value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This will be a depth-first traversal if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 is the function shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traverse-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It remains to define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

computeIndex
\end_layout

\end_inset

 describing the 
\begin_inset Quotes eld
\end_inset

decoration logic
\begin_inset Quotes erd
\end_inset

.
 Begin writing the code as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def computeIndex[A]: A => St[(A, Int)] = a => St { i => ???: ((A, Int),
 Int) }
\end_layout

\end_inset

Given a leaf value (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

) and a previous internal state (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i: Int
\end_layout

\end_inset

), we must compute the 
\begin_inset Quotes eld
\end_inset

decorated
\begin_inset Quotes erd
\end_inset

 leaf value of type 
\begin_inset Formula $A\times\text{Int}$
\end_inset

 as well as the new internal state.
 Since our goal is to label the leaves by the current leaf count, we use
 the internal state to store the number of leaves seen so far.
 So, we just need to increment the internal state after copying it to a
 leaf:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def computeIndex[A]: A => St[(A, Int)] = a => St { i => ((a, i), i + 1)
 }
\end_layout

\end_inset

This completes the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDFS
\end_layout

\end_inset

, which we can now test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> zipWithIndexDF(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Leaf((8,0)), Branch(Branch(Leaf((3,1)), Leaf((5,2)
)), Leaf((4,3))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Decorating a tree.
 II.
 Breadth-first traversal
\begin_inset CommandInset label
LatexCommand label
name "subsec:Decorating-a-tree-breadth-first-traversal"

\end_inset


\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Aggregating-tree-like-data-bfs"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we have implemented a breadth-first folding for the tree data structure
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

.
 What additional code does  
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 need? Folding over 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 merely needs to enumerate the values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in the breadth-first order, but a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function must return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[T2[B]]
\end_layout

\end_inset

.
 This requires us to 
\emph on
merge the effects
\emph default
 of an arbitrary applicative functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 in the breadth-first order, while gathering the values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 into a tree structure (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[B]
\end_layout

\end_inset

) wrapped under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toListBFS
\end_layout

\end_inset

 shown in the previous section is not sufficient for that purpose, because
 the tree structure cannot be reproduced if we only have a list of leaf
 values.
 Even the nested list computed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList2
\end_layout

\end_inset

 is not sufficient.
 We need additional information about each leaf's position in the tree.
\end_layout

\begin_layout Standard
So, let us begin by adding the required position information to the nested
 list of leaf values.
 For each leaf, we need to store the path from the root of the tree.
 We can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type constructor and its subtypes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 for marking that path.
 For example, the position information for the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2 =
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 could be represented by the following nested list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(
\end_layout

\begin_layout Plain Layout

  List(),                                                // No leaves at
 level 0.
\end_layout

\begin_layout Plain Layout

  List( Left(8) ),                                       // One leaf at
 level 1.
\end_layout

\begin_layout Plain Layout

  List( Right(Right(4)) ),                               // One leaf at
 level 2.
\end_layout

\begin_layout Plain Layout

  List( Right(Left(Left(3))), Right(Left(Right(5))) ),   // Two leaves at
 level 3.
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

This data structure makes it easy to iterate over the leaf values in the
 breadth-first order.
 At the same time, it keeps enough information for restoring the original
 tree since each leaf value comes with the full path from the root of the
 tree.
\end_layout

\begin_layout Standard
An immediate problem with this data structure is a type mismatch in the
 outer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

: its elements are not of the same type because each subsequent sub-list
 contains data wrapped under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 more deeply.
 To make the types match, we need to implement a special list-like data
 structure whose first element has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

, the second element has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Either[A, A]]
\end_layout

\end_inset

, the third element has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Either[Either[A, A], Either[A, A]]]
\end_layout

\end_inset

, and so on.
 (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-EvenList-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows a similar data type.) Let us call this data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

 (
\begin_inset Quotes eld
\end_inset

tree descriptor
\begin_inset Quotes erd
\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait TD[A]
\end_layout

\begin_layout Plain Layout

final case class Last[A](a: List[A]) extends TD[A]
\end_layout

\begin_layout Plain Layout

final case class More[A](a: List[A], tail: TD[Either[A, A]]) extends TD[A]
  
\end_layout

\end_inset

The tree descriptor for the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 shown above will then look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val td2: TD[Int] = More(List(), More(                          // No leaves
 at level 0.
\end_layout

\begin_layout Plain Layout

    List( Left(8) ), More(                                     // The leaf
 at level 1.
\end_layout

\begin_layout Plain Layout

      List( Right(Right(4)) ), Last(                           // The leaf
 at level 2.
\end_layout

\begin_layout Plain Layout

        List( Right(Left(Left(3))), Right(Left(Right(5))) ),   // Two leaves
 at level 3.
\end_layout

\begin_layout Plain Layout

))))
\end_layout

\end_inset

Now the types match, while a wrong number of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 wrappers will be a type error.
\end_layout

\begin_layout Standard
This representation of the tree descriptor is certainly not efficient in
 terms of memory consumption and processing speed.
 An 
\begin_inset Quotes eld
\end_inset

industry-strength
\begin_inset Quotes erd
\end_inset

 breadth-first tree traversal will use quite different data structures while
 implementing the same logic.
 For instance, one could use a bit vector 
\begin_inset Formula $\left[1,0,1\right]$
\end_inset

 instead of the wrapper 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(Left(Right()))
\end_layout

\end_inset

, avoiding the allocation of many objects in memory.
 However, our present goal is not to achieve high efficiency but to obtain
 correct code quickly.
\end_layout

\begin_layout Standard
The next step is to write functions transforming between trees 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 and descriptors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t2ToTD[A]: T2[A] => TD[A] = ???
\end_layout

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = ???
\end_layout

\end_inset

Begin implementing the first function by pattern matching:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def t2ToTD[A]: T2[A] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => Last(List(a))                      // A leaf at
 level 0.
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => ( t2ToTD(l),  t2ToTD(r) ); ???     // How to combine
 the subtrees?
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It seems reasonable that we need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 recursively to the subtrees 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 in line 
\begin_inset Formula $3$
\end_inset

, obtaining the tree descriptors of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 for those subtrees.
 We still have to merge these tree descriptors in the correct way.
 Inspired by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

listMerge
\end_layout

\end_inset

 function from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Aggregating-tree-like-data-bfs"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we implement the descriptor-merging code by concatenating the lists separately
 at each depth level:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def tdMerge[A](l: TD[A], r: TD[A]): TD[A] = (l, r) match {
\end_layout

\begin_layout Plain Layout

  case (Last(la), Last(lb))                 => Last(la ++ lb)
\end_layout

\begin_layout Plain Layout

  case (Last(la), More(lb, tail))           => More(la ++ lb, tail)
\end_layout

\begin_layout Plain Layout

  case (More(la, tail), Last(lb))           => More(la ++ lb, tail)
\end_layout

\begin_layout Plain Layout

  case (More(la, tailA), More(lb, tailB))   => More(la ++ lb, tdMerge(tailA,
 tailB))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

However, writing just 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdMerge(t2ToTD(l), t2ToTD(r))
\end_layout

\end_inset

 would not be correct in line 
\begin_inset Formula $3$
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

.
 We need somehow to store the information that the subtrees 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 are located one level deeper at the left and at the right respectively.
 To see how that information needs to be stored, let us look at the tree
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 whose left and right subtrees are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l = 
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 8  ]
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r =
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[  [ 3 5 ] 4  ]
\end_layout

\end_inset


\end_layout

\end_inset

.
 The descriptors of these subtrees are computed by recursive calls of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

, which (if implemented correctly) should yield the following:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

t2ToTD(l) == Last(List(8))                   // One leaf at level 0.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

t2ToTD(r) == More(List(), More(              // No leaves at level 0.
\end_layout

\begin_layout Plain Layout

  List( Right(4) ), Last(                    // One leaf at level 1.
\end_layout

\begin_layout Plain Layout

    List( Left(Left(3)), Left(Right(5)) )    // Two leaves at level 2.
\end_layout

\begin_layout Plain Layout

)))
\end_layout

\end_inset

The correct merging of these tree descriptors requires wrapping all data
 in the subtree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

l
\end_layout

\end_inset

 in an additional 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

 layer and all data in the subtree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 in an additional 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right()
\end_layout

\end_inset

 layer.
 Let us implement two helper functions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRight
\end_layout

\end_inset

) for that transformation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def addLeft[A]: TD[A] => TD[Either[A, A]] = {
\end_layout

\begin_layout Plain Layout

  case Last(a)         => Last(a.map(Left(_)))
\end_layout

\begin_layout Plain Layout

  case More(a, tail)   => More(a.map(Left(_)), addLeft[Either[A, A]](tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def addRight[A]: TD[A] => TD[Either[A, A]] = {
\end_layout

\begin_layout Plain Layout

  case Last(a)         => Last(a.map(Right(_)))
\end_layout

\begin_layout Plain Layout

  case More(a, tail)   => More(a.map(Right(_)), addRight[Either[A, A]](tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

 We expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRight
\end_layout

\end_inset

 will transform the left and right subtree descriptors like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

addLeft(t2ToTD(l)) == Last(List(Left(8)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

addRight(t2ToTD(r)) == More( List(), More(
\end_layout

\begin_layout Plain Layout

  List( Right(Right(4)) ), Last(
\end_layout

\begin_layout Plain Layout

    List( Right(Left(Left(3))), Right(Left(Right(5))) )
\end_layout

\begin_layout Plain Layout

)))
\end_layout

\end_inset

It remains to mark the subtrees as being one layer deeper.
 We do this by inserting an empty list at the beginning of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

 structure.
 The types will then require that the subsequent lists must have one more
 layer of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 wrappers, which they will indeed have after applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRight
\end_layout

\end_inset

.
 So, the correct merging of the two subtree descriptors is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

More(List(), tdMerge( addLeft(t2ToTD(l)), addRight(t2ToTD(r)) ))
\end_layout

\end_inset

The complete code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 becomes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t2ToTD[A]: T2[A] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => Last(List(a))
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => More(List(), tdMerge( addLeft(t2ToTD(l)), addRight(t2To
TD(r)) ))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can test this code on an example tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t2 = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t2ToTD(t2)
\end_layout

\begin_layout Plain Layout

res0: TD[Int] = More(List(), More(List(Left(8)), More(List(Right(Right(4))),
 Last(List(Right(Left(Left(3))), Right(Left(Right(5))))))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To implement the inverse function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

), we need to keep in mind that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 will only create a certain subset of possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

.
 Looking at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

, we can see, for instance, that the first list is always empty when the
 tree has a branch.
 The first list is either empty or contains only one element (the single
 leaf of the tree).
 We will never create values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 where the first list has more than one element, or where the first list
 is nonempty and there are also nonempty subsequent lists.
 Such values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 do not correspond to any trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

.
 So, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 can be a 
\emph on
partial
\emph default
 function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A] => T2[A]
\end_layout

\end_inset

 that only works with valid tree descriptors, that is, values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 that were obtained by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTd
\end_layout

\end_inset

 to some trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

.
 The composition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD andThen tdToT2
\end_layout

\end_inset

 should be the identity function.
\end_layout

\begin_layout Standard
Begin writing the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 by pattern matching:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(List(a))   => Leaf(a)    // Tree has a single leaf at level
 0.
\end_layout

\begin_layout Plain Layout

  case _               => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Valid tree descriptors can only have a non-empty first list if the tree
 has a single leaf at level 
\begin_inset Formula $0$
\end_inset

.
 So, we may ignore all other cases and continue with patterns that assume
 an empty first list:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(List(a))        => Leaf(a)    // Tree has a single leaf at level
 0.
\end_layout

\begin_layout Plain Layout

  case More(List(a), _)     => Leaf(a)    // Tree has a single leaf at level
 0.
         
\end_layout

\begin_layout Plain Layout

  case More(List(), tail)   => ???        // Tree has two branches.
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In line 
\begin_inset Formula $4$
\end_inset

, we need to restore two branches of the tree from the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[Either[A, A]]
\end_layout

\end_inset

.
 How can we do that? The left branch contains all the leaf data from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

 where the outermost wrapper is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

.
 We can select just that subset of leaf data and remove the outermost 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

 wrapper by implementing the helper functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

removeLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterLeft
\end_layout

\end_inset

 as shown here:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeLeft[A]: List[Either[A, A]] => List[A] = _.collect { case Left(x)
 => x }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def filterLeft[A]: TD[Either[A, A]] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(la)         => Last(removeLeft(la))
\end_layout

\begin_layout Plain Layout

  case More(la, tail)   => More(removeLeft(la), filterLeft(tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

For example, if we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterLeft
\end_layout

\end_inset

 to the descriptor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD(t2).tail
\end_layout

\end_inset

 then we will get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

filterLeft(t2ToTD(t2).tail) == More(List(8), More(List(), Last(List())))
\end_layout

\end_inset

This tree descriptor corresponds to the left subtree of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In a similar way, we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterRight
\end_layout

\end_inset

 that extracts the descriptor data for the right subtree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeRight[A]: List[Either[A, A]] => List[A] = _.collect { case Right(x)
 => x }
\end_layout

\begin_layout Plain Layout

def filterRight[A]: TD[Either[A, A]] => TD[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(la)         => Last(removeRight(la))
\end_layout

\begin_layout Plain Layout

  case More(la, tail)   => More(removeRight(la), filterRight(tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> filterRight(t2ToTD(t2).tail)
\end_layout

\begin_layout Plain Layout

res1: TD[Int] = More(List(), More(List(Right(4)), Last(List(Left(Left(3)),
 Left(Right(5))))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we are ready to complete the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

.
 We use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterRight
\end_layout

\end_inset

 to obtain the descriptors for the left and the right subtrees.
 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 recursively to those descriptors will restore the two subtrees:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def tdToT2[A]: TD[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(List(a))        => Leaf(a)
\end_layout

\begin_layout Plain Layout

  case More(List(a), _)     => Leaf(a)
\end_layout

\begin_layout Plain Layout

  case More(List(), tail)   => Branch(tdToT2(filterLeft(tail)), tdToT2(filterRig
ht(tail)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> tdToT2(t2ToTD(t2)) == t2
\end_layout

\begin_layout Plain Layout

res2: Boolean = true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[_]
\end_layout

\end_inset

, which makes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[_]
\end_layout

\end_inset

 into a traversable functor.
 We will call its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travTD
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 for clarity.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD[A]
\end_layout

\end_inset

 is essentially a decorated list of lists, we will need 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 (Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversable-seq"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which we here denote by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travList
\end_layout

\end_inset

.
 We will also need a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function for the functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def travEither[A, B, F[_]: Functor](f: A => F[B])(e: Either[A, A]): F[Either[B,
 B]] = e match {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => f(a).map(Left(_))
\end_layout

\begin_layout Plain Layout

  case Right(a)   => f(a).map(Right(_))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travList
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travEither
\end_layout

\end_inset

, we can now implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travTD
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def travTD[A, B, F[_]: Applicative : Functor](f: A => F[B])(td: TD[A]):
 F[TD[B]] = td match {
\end_layout

\begin_layout Plain Layout

  case Last(a)         => travList(f)(a).map(Last(_))
\end_layout

\begin_layout Plain Layout

  case More(a, tail)   =>
\end_layout

\begin_layout Plain Layout

    val headFB: F[List[B]] = travList(f)(a)
\end_layout

\begin_layout Plain Layout

    val tailFB: F[TD[Either[B, B]]] = travTD { x: Either[A, A] => travEither(f)(
x) }(tail)
\end_layout

\begin_layout Plain Layout

    (headFB zip tailFB).map { case (headB, tailB) => More(headB, tailB) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The final step is to convert 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2ToTD
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

.
 We first compute the tree descriptor of a given tree and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travTD
\end_layout

\end_inset

 to perform a traversal.
 The result is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[TD[B]]
\end_layout

\end_inset

, which we convert into a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[T2[B]]
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tdToT2
\end_layout

\end_inset

 lifted to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def travBF[A, B, F[_]: Applicative : Functor](f: A => F[B])(tree: T2[A]):
 F[T2[B]] =
\end_layout

\begin_layout Plain Layout

  travTD(f)(t2ToTD(tree)).map(tdToT2) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This completes our implementation of a breadth-first traversal for binary
 trees.
 To test the code, we run the example of decorating a tree with the breadth-firs
t traversal index:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithIndexBF[A](tree: T2[A]): T2[(A, Int)] = {
\end_layout

\begin_layout Plain Layout

  val afterTraverse: St[T2[(A, Int)]] = travBF[A, (A, Int), St](computeIndex)(tr
ee)
\end_layout

\begin_layout Plain Layout

  afterTraverse.run(0)._1                        // Run the State monad and
 get the result value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithIndexBF(t2)
\end_layout

\begin_layout Plain Layout

res3: T2[(Int, Int)] = Branch(Leaf((8,0)), Branch(Branch(Leaf((3,2)), Leaf((5,3)
)), Leaf((4,1))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only difference between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexDF
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndexBF
\end_layout

\end_inset

 is the choice of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travBF
\end_layout

\end_inset

).
 The 
\begin_inset Quotes eld
\end_inset

decoration logic
\begin_inset Quotes erd
\end_inset

 is described by the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

computeIndex
\end_layout

\end_inset

 and does not depend on the traversal order.
 As a result, we gain flexibility: an arbitrary traversal order may be used
 with an arbitrary 
\begin_inset Quotes eld
\end_inset

decoration logic
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsection
The 
\family typewriter
Traversable
\family default
 typeclass.
 Implementing 
\family typewriter
scanLeft
\end_layout

\begin_layout Standard
We define a 
\begin_inset Quotes eld
\end_inset

traversable functor
\begin_inset Quotes erd
\end_inset

 typeclass (called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

) by specifying a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation, which is convenient to provide as an extension method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Traversable[L[_]] {
\end_layout

\begin_layout Plain Layout

  def trav[A, B, F[_]: Applicative: Functor](f: A => F[B])(la: L[A]): F[L[B]]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class TraversableOps[L[_], A](la: L[A])(implicit tr: Traversable[L])
 {
\end_layout

\begin_layout Plain Layout

  def traverse[B, F[_]: Applicative : Functor](f: A => F[B]): F[L[B]] =
 tr.trav(f)(la)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have mentioned in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-traverse-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation can be defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation transforms an initial sequence into a result value by updating
 some internal state.
 Another function similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

; the difference is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

's result value is the 
\emph on
sequence
\emph default
 of all intermediate state values rather than just the last state value.
 Let us see how the functionality of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 can be expressed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad that handles the state updates.
 This will allow us to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 automatically for every traversable functor.
\end_layout

\begin_layout Standard
Assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

 is a traversable functor whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav
\end_layout

\end_inset

 function is available:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav[A, B, F[_]: Applicative: Functor](f: A => F[B])(la: L[A]): F[L[B]]
 = ...
\end_layout

\end_inset

We would like to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 with the following type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def scanLeft[A, Z](la: L[A])(init: Z)(f: (A, Z) => Z): L[Z] = ???
\end_layout

\end_inset

The standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 method for lists produces a list with an extra initial element, which is
 always equal to the initial value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

.
 This initial element is not essential and may be omitted from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

.
 In fact, we 
\emph on
need
\emph default
 to omit that initial element when we generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 to data types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

 other than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

, since those data types will not necessarily support adding one more data
 item.
\end_layout

\begin_layout Standard
In order to update the state of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 and also store the state's value as the result of the traversal, we will
 use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad and compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[Z, Z]
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 with a suitable function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

accum
\end_layout

\end_inset

 that creates the required value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[Z, Z]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class State[Z, A](run: Z => (A, Z)) // Assume Applicative and Functor
 instances for State[Z, *].
\end_layout

\begin_layout Plain Layout

def accum[A, Z](a: A, f: (A, Z) => Z): State[Z, Z] = State { z =>
\end_layout

\begin_layout Plain Layout

  val newZ = f(a, z)  // Update the internal state using `f`.
\end_layout

\begin_layout Plain Layout

  (newZ, newZ)        // Store the internal state, and also return it as
 a result value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class TraversableScanOps[L[_] : Traversable, A](la: L[A]) {
\end_layout

\begin_layout Plain Layout

  def scanLeft[Z](init: Z)(f: (A, Z) => Z): L[Z] = la.traverse(a => accum(a,
 f)).run(init)._1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In this way, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 is made available for all traversable functors.
\end_layout

\begin_layout Standard
To test this code, we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 via depth-first traverse for a tree of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithIndexDFS[A]: T2[A] => T2[(A, Int)] = 
\end_layout

\begin_layout Plain Layout

  _.scanLeft[(A, Int)]((null.asInstanceOf[A], -1)) { case (a, (_, i)) => (a,
 i + 1) }
\end_layout

\begin_layout Plain Layout

val t2 = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithIndexDFS(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Leaf((8,0)), Branch(Branch(Leaf((3,1)), Leaf((5,2)
)), Leaf((4,3))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tasks that cannot be performed via 
\family typewriter
traverse
\family default

\begin_inset CommandInset label
LatexCommand label
name "subsec:Tasks-not-implementable-via-traverse"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function is powerful since it can use an arbitrary applicative functor
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

.
 However, some computations are still not expressible via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 because they require information that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 cannot have.
 We will now look at two examples of this.
\end_layout

\begin_layout Standard
The first example is the depth labeling of a tree: each leaf gets a value
 equal to its depth.
 For instance, the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 becomes 
\size tiny

\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ (8,1) [ [ (3,3) (5,3) ] (4,2) ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\size default
 after depth labeling.
 This cannot be implemented via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 because it cannot detect nodes that have the same depth in the tree.
 To see this in more detail, recall that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 always collects and merges all the effects of a given functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

.
 If the effect of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 describes incrementing a counter (as in our examples involving the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad), the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 will increment that counter at 
\emph on
each
\emph default
 leaf.
 We may traverse the tree so that leaves at the same depth are traversed
 next to each other (as in the breadth-first traversal).
 But the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 cannot skip the incrementing when a leaf is at the same depth: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 does not receive any information about the position of values in the tree.
 So, we cannot label certain nodes with the same depth value but other nodes
 with a different depth value.
\end_layout

\begin_layout Standard
Depth labeling can be implemented as a special operation such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 for the tree type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithDepth[A](initial: Int = 0): T2[A] => T2[(A, Int)] = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => Leaf((a, initial))
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => Branch(zipWithDepth(initial + 1)(l), zipWithDepth(initi
al + 1)(r))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

val t2: T2[Int] = Branch(Leaf(8), Branch(Branch(Leaf(3), Leaf(5)), Leaf(4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithDepth()(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Leaf((8,1)), Branch(Branch(Leaf((3,3)), Leaf((5,3)
)), Leaf((4,2))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
More generally, traversals cannot perform computations that depend on the
 
\emph on
position
\emph default
 of data in the tree (e.g., whether the data is in a left or in a right branch
 and at what depth).
 An example of such a computation is 
\begin_inset Quotes eld
\end_inset

pretty-printing
\begin_inset Quotes erd
\end_inset

 that converts trees into a text form.
 In the \SpecialChar LaTeX
 format used to typeset this book, the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 is represented by the text string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset


\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ]
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 We may write the following code for converting trees to this format:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def printLaTeX[A](t: T2[A])(toString: A => String): String = {
\end_layout

\begin_layout Plain Layout

  def printLaTeXSubtree: T2[A] => String = {
\end_layout

\begin_layout Plain Layout

    case Leaf(a)        => toString(a)
\end_layout

\begin_layout Plain Layout

    case Branch(l, r)   => "[ " + printLaTeXSubtree(l) + " " + printLaTeXSubtree
(r) + " ]"
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  "
\backslash

\backslash
Tree" + printLaTeXSubtree(t)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printLaTeX(t2)(_.toString)
\end_layout

\begin_layout Plain Layout

res1: String = 
\backslash
Tree[ 8 [ [ 3 5 ] 4 ] ]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Recursion schemes.
 I.
 Folding operations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Recursion-schemes.-folding"

\end_inset


\end_layout

\begin_layout Standard
The previous section showed two examples of folding and traversing operations
 that cannot be expressed through the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 methods and are instead implemented via custom recursive code.
 If we needed to implement the same operations for trees of different shapes
 or for other recursive data types, we would need to write new custom code
 for each new data type.
 That code will contain a certain common pattern: it will use recursive
 calls at the points where the recursive data type refers to itself.
 It turns out that we can separate this common pattern from the custom code,
 reducing the effort required for implementing the folding and traversing
 operations for different recursive data types.
\end_layout

\begin_layout Standard
To begin, write the recursive definition of the tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
\text{T2}^{A}\triangleq A+\text{T2}^{A}\times\text{T2}^{A}\quad.
\]

\end_inset

This type refers recursively to itself in two places.
 To express that, define a bifunctor 
\begin_inset Formula $S^{A,R}$
\end_inset

:
\begin_inset Formula 
\[
S^{A,R}\triangleq A+R\times R\quad.
\]

\end_inset

We can now rewrite the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

 as a recursive type equation: 
\begin_inset Formula $\text{T2}^{A}\triangleq S^{A,\text{T2}^{A}}$
\end_inset

.
 The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (R, R)]
\end_layout

\begin_layout Plain Layout

final case class T2[A](run: S[A, T2[A]])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bifunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
bifunctor
\end_layout

\end_inset

 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 is called the 
\series bold
recursion scheme
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
recursion scheme
\end_layout

\end_inset

 of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2
\end_layout

\end_inset

.
 The recursion scheme describes the places where the recursive type refers
 to itself in its definition.
 All the recursive uses correspond to occurrences of the type parameter
 
\begin_inset Formula $R$
\end_inset

 in 
\begin_inset Formula $S^{A,R}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The folding operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 takes a function 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow Z$
\end_inset

 as a parameter:
\begin_inset Formula 
\[
\text{foldMap}_{L}(f^{:A\rightarrow Z}):L^{A}\rightarrow Z\quad.
\]

\end_inset

The function 
\begin_inset Formula $f$
\end_inset

 will be applied to all values of type 
\begin_inset Formula $A$
\end_inset

 stored inside 
\begin_inset Formula $L^{A}$
\end_inset

.
 As we have seen in the previous section, the function 
\begin_inset Formula $f^{:A\rightarrow Z}$
\end_inset

 cannot receive any information about the location of values of type 
\begin_inset Formula $A$
\end_inset

 inside 
\begin_inset Formula $L^{A}$
\end_inset

.
 In order to access that information and make the folding operation 
\begin_inset Quotes eld
\end_inset

location-aware
\begin_inset Quotes erd
\end_inset

, we need to change the type signature of 
\begin_inset Formula $f$
\end_inset

.
 To figure out the new type signature, let us look at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pls
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) from the previous section:
\begin_inset Formula 
\[
\text{pls}\triangleq\,\begin{array}{|c||c|}
 & \text{String}\\
\hline A & \text{toString}\\
\text{T2}^{A}\times\text{T2}^{A} & (\overline{\text{pls}}\boxtimes\overline{\text{pls}})\bef(l\times r\rightarrow\text{"[ "}+l+\text{" "}+r+\text{" ]"})
\end{array}\quad.
\]

\end_inset

We can rewrite this code using the bifunctor 
\begin_inset Formula $S^{A,R}\triangleq A+R\times R$
\end_inset

.
 In this example, the result type 
\begin_inset Formula $Z$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 By calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 recursively on the left and the right subtrees, we obtain two values of
 type 
\begin_inset Formula $Z$
\end_inset

.
 We can separate the recursive calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 from the custom string processing and express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 as the following function composition:
\begin_inset Formula 
\[
\text{pls}\triangleq\,\begin{array}{|c||cc|}
 & A & Z\times Z\\
\hline A & \text{id} & \bbnum 0\\
\text{T2}^{A}\times\text{T2}^{A} & \bbnum 0 & \overline{\text{pls}}\boxtimes\overline{\text{pls}}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & Z\\
\hline A & \text{toString}\\
Z\times Z & l\times r\rightarrow\text{"[ "}+l+\text{" "}+r+\text{" ]"}
\end{array}\quad.
\]

\end_inset

The intermediate result is a data structure of type 
\begin_inset Formula $A+Z\times Z$
\end_inset

, to which we need to apply some string manipulations.
 We note that the type 
\begin_inset Formula $A+Z\times Z$
\end_inset

 is the same as 
\begin_inset Formula $S^{A,Z}$
\end_inset

, while the first matrix in the code above is the lifting 
\begin_inset Formula $\overline{\text{pls}}^{\uparrow S^{A,\bullet}}\,$
\end_inset

with respect to the type parameter 
\begin_inset Formula $R$
\end_inset

 of 
\begin_inset Formula $S^{A,R}$
\end_inset

.
 So, we may express the custom string manipulations specific to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 via a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLaTeX
\end_layout

\end_inset

 of type 
\begin_inset Formula $S^{A,Z}\rightarrow Z$
\end_inset

:
\begin_inset Formula 
\[
\text{toLaTeX}:S^{A,Z}\rightarrow Z\quad,\quad\quad\text{toLaTeX}\triangleq\,\begin{array}{|c||c|}
 & Z\\
\hline A & \text{toString}\\
Z\times Z & l\times r\rightarrow\text{"[ "}+l+\text{" "}+r+\text{" ]"}
\end{array}\quad.
\]

\end_inset

Using this function, the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 can be rewritten as:
\begin_inset Formula 
\[
\text{pls}\triangleq\overline{\text{pls}}^{\uparrow S^{A,\bullet}}\bef\text{toLaTeX}\quad.
\]

\end_inset

All custom 
\begin_inset Quotes eld
\end_inset

location-aware
\begin_inset Quotes erd
\end_inset

 logic is now encapsulated in the (non-recursive!) function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLaTeX
\end_layout

\end_inset

.
 So, we can now generalize the calculation by defining a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 function (denoted by 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

):
\begin_inset Formula 
\begin{equation}
\text{fold}_{S}:(S^{A,Z}\rightarrow Z)\rightarrow L^{A}\rightarrow Z\quad,\quad\quad\text{fold}_{S}(f)\triangleq\overline{\text{fold}_{S}(f)}^{\uparrow S^{A,\bullet}}\bef f\quad.\label{eq:fold-via-recursion-scheme-1}
\end{equation}

\end_inset

We then obtain 
\begin_inset Formula $\text{pls}=\text{fold}_{S}(\text{toLaTeX})$
\end_inset

.
 The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmapR[A, R, T](f: R => T): S[A, R] => S[A, T] = _.map { case (r1, r2)
 => (f(r1), f(r2)) }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def foldS[A, Z](f: S[A, Z] => Z)(tree: T2[A]): Z = f(fmapR(foldS(f))(tree.run))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def toLaTeX[A]: S[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case Left(a)         => a.toString
\end_layout

\begin_layout Plain Layout

  case Right((l, r))   => s"[ $l $r ]"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def printLaTeX[A](tree: T2[A]): String = "
\backslash

\backslash
Tree" + foldS[A, String](toLaTeX)(tree)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val t2: T2[Int] = T2(Right((T2(Left(8)), T2(Right((T2(Right((T2(Left(3)),
 T2(Left(5))))), T2(Left(4))))))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printLaTeX(t2)
\end_layout

\begin_layout Plain Layout

res0: String = 
\backslash
Tree[ [ 8 [ 3 5 ] ] 4 ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important that the function 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 is parametric in the recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and the result type 
\begin_inset Formula $Z$
\end_inset

 (which is not required to be a monoid).
 Different recursion schemes 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 may be used to define lists, trees, and other recursive data types.
 The same code of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 will work for all those data types, as long as we have the recursion scheme
 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and the corresponding lifting function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmapR
\end_layout

\end_inset

 in the Scala code shown above, or 
\begin_inset Formula $^{\uparrow S^{A,\bullet}}$
\end_inset

 in the code notation).
\end_layout

\begin_layout Standard
To illustrate the general applicability of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 to different data types, let us implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeX
\end_layout

\end_inset

 function for ordinary lists, for non-empty lists, and for rose trees (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rose-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type and the corresponding recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 may be defined by:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}\quad,\quad\quad S^{A,R}\triangleq\bbnum 1+A\times R\quad,\quad\quad\text{List}^{A}\triangleq S^{A,\text{List}^{A}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
A non-empty list type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

) and the corresponding recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 may be defined by:
\begin_inset Formula 
\[
\text{NEL}^{A}\triangleq A+A\times\text{NEL}^{A}\quad,\quad\quad S^{A,R}\triangleq A+A\times R\quad,\quad\quad\text{NEL}^{A}\triangleq S^{A,\text{NEL}^{A}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
A rose tree (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN
\end_layout

\end_inset

) and the corresponding recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 may be defined by:
\begin_inset Formula 
\[
\text{TreeN}^{A}\triangleq A+\text{NEL}^{\text{TreeN}^{A}}\quad,\quad\quad S^{A,R}\triangleq A+\text{NEL}^{R}\quad,\quad\quad\text{TreeN}^{A}\triangleq S^{A,\text{TreeN}^{A}}\quad.
\]

\end_inset

For rose trees, the recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 is itself a recursively defined type because it uses the non-empty list
 (NEL).
 This is not a problem: 
\begin_inset Formula $S^{A,R}$
\end_inset

 is still polynomial, which guarantees that any value of type 
\begin_inset Formula $S^{A,R}$
\end_inset

 contains a finite number of elements of types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 So, any value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 will contain a finite number of values of type 
\begin_inset Formula $A$
\end_inset

, assuring that the folding operation will terminate.
\end_layout

\begin_layout Standard
To avoid repetitive code, let us define all three data types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN
\end_layout

\end_inset

) at once through a universal recursive class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

 that takes the recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 as a type parameter:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S1[A, R] = Option[(A, R)]             // For List.
\end_layout

\begin_layout Plain Layout

type S2[A, R] = Either[A, (A, R)]          // For NEL.
\end_layout

\begin_layout Plain Layout

type S3[A, R] = Either[A, NEL[R]]          // For TreeN.
\end_layout

\begin_layout Plain Layout

final case class Fix[S[_, _], A](unfix: S[A, Fix[S, A]])
\end_layout

\end_inset

Using the class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

, we may write the equivalent definitions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 
\begin_inset Formula $\cong$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S1, A]
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL[A]
\end_layout

\end_inset

 
\begin_inset Formula $\cong$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S2, A]
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 
\begin_inset Formula $\cong$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S3, A]
\end_layout

\end_inset

.
 Some example values of these types are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x1 = Fix[S1, Int](Some((1, Fix[S1, Int](Some((2, Fix[S1, Int](Some((3,
 Fix[S1, Int](None))))))))))  // Equivalent to List(1, 2, 3) .
\end_layout

\begin_layout Plain Layout

val x2 = Fix[S2, Int](Right((1, Fix[S2, Int](Right((2, Fix[S2, Int](Left(3))))))
))  // NEL(1, 2, 3) .
\end_layout

\begin_layout Plain Layout

val x3 = Fix[S3, Int](Right(NEL(Fix[S3, Int](Right(NEL(Fix[S3, Int](Left(10)),
 Fix[S3, Int](Right(NEL(Fix[S3, Int](Left(20)), Fix[S3, Int](Left(30)))))))),
 Fix[S3, Int](Left(40)))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In practice, defining data structures via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

 is both inconvenient and inefficient.
 We show these definitions only to clarify how one can generalize 
\begin_inset Quotes eld
\end_inset

location-aware
\begin_inset Quotes erd
\end_inset

 folding operations to arbitrary recursive data types.
 (For simplicity, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S3
\end_layout

\end_inset

 uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

 rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S2, A]
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard
To make the code of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 general, we add a functor typeclass constraint to 
\begin_inset Formula $S^{A,\bullet}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fold[A, Z, S[_,_]](f: S[A, Z] => Z)(t: Fix[S, A])(implicit fs: Functor[S[A,
 *]]): Z =
\end_layout

\begin_layout Plain Layout

  f(t.unfix.map(fold(f)))
\end_layout

\end_inset

Below we will assume that the appropriate functor instances are defined
 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S3
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It remains to implement functions with type signatures 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S[A, String] => String
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toLaTeX1[A]: S1[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case None                 => 
\begin_inset Quotes eld
\end_inset

Nil
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case Some((head, tail))   => head.toString + 
\begin_inset Quotes eld
\end_inset

, 
\begin_inset Quotes eld
\end_inset

 + tail
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def toLaTeX2[A]: S2[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case Left(a)               => a.toString
\end_layout

\begin_layout Plain Layout

  case Right((head, tail))   => head.toString + 
\begin_inset Quotes eld
\end_inset

, 
\begin_inset Quotes eld
\end_inset

 + tail
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def toLaTeX3[A]: S3[A, String] => String = {
\end_layout

\begin_layout Plain Layout

  case Left(a)      => a.toString
\end_layout

\begin_layout Plain Layout

  case Right(nel)   => 
\begin_inset Quotes eld
\end_inset

[ 
\begin_inset Quotes eld
\end_inset

 + nel.mkString(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes erd
\end_inset

) + 
\begin_inset Quotes eld
\end_inset

 ]
\begin_inset Quotes erd
\end_inset

 // Assume mkString() is defined for NEL.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now use 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 to convert some data structures to a \SpecialChar LaTeX
 form:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def listToLaTeX[A](t: Fix[S1, A]): String = 
\begin_inset Quotes eld
\end_inset

[ 
\begin_inset Quotes eld
\end_inset

 + fold[A, String, S1](toLaTeX1)(t) + 
\begin_inset Quotes eld
\end_inset

 ]
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

def nelToLaTeX[A](t: Fix[S2, A]): String = 
\begin_inset Quotes eld
\end_inset

[ 
\begin_inset Quotes eld
\end_inset

 + fold[A, String, S2](toLaTeX2)(t) + 
\begin_inset Quotes eld
\end_inset

 ]
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

def treeNToLaTeX[A](t: Fix[S3, A]): String = 
\begin_inset Quotes eld
\end_inset


\backslash

\backslash
Tree
\begin_inset Quotes eld
\end_inset

 + fold[A, String, S3](toLaTeX3)(t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> listToLaTeX(x1)
\end_layout

\begin_layout Plain Layout

res1: String = [ 1, 2, 3, Nil ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> nelToLaTeX(x2)
\end_layout

\begin_layout Plain Layout

res2: String = [ 1, 2, 3 ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> treeNToLaTeX(x3)
\end_layout

\begin_layout Plain Layout

res3: String = 
\backslash
Tree[ [ 10 [ 20 30 ] ] 40 ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The definition of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 calls itself recursively under the lifting (
\begin_inset Formula $\overline{\text{fold}_{S}(f)}^{\uparrow S^{A,\bullet}}$
\end_inset

).
 Is it guaranteed that this recursion terminates? The only way it can terminate
 is when the lifting 
\begin_inset Formula $f^{\uparrow S^{A,\bullet}}$
\end_inset

 does not 
\emph on
always
\emph default
 call the function 
\begin_inset Formula $f$
\end_inset

.
 This will happen if 
\begin_inset Formula $S^{A,R}$
\end_inset

 is a disjunctive type with some parts that do not depend on 
\begin_inset Formula $R$
\end_inset

.
 This is indeed the case for lists (
\begin_inset Formula $S^{A,R}\triangleq\bbnum 1+A\times R$
\end_inset

 or 
\begin_inset Formula $S^{A,R}\triangleq A+A\times R$
\end_inset

) and trees (
\begin_inset Formula $S^{A,R}\triangleq A+R\times R$
\end_inset

).
 Applying 
\begin_inset Formula $f^{\uparrow S^{A,\bullet}}$
\end_inset

 to values of 
\begin_inset Formula $R$
\end_inset

-independent types will be an identity function; it will not actually call
 
\begin_inset Formula $f$
\end_inset

.
 This will be the base case of the recursion.
\end_layout

\begin_layout Standard
It remains to assure that the recursion reaches the base case with every
 value of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 That is, no values of type 
\begin_inset Formula $L^{A}$
\end_inset

 should cause an infinite loop in 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

.
 A simple example where 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 enters an infinite loop is the recursion scheme 
\begin_inset Formula $S^{A,R}\triangleq A+(\bbnum 1\rightarrow R)$
\end_inset

.
 Note that 
\begin_inset Formula $S^{A,R}$
\end_inset

 is non-polynomial due to the function type 
\begin_inset Formula $\bbnum 1\rightarrow R$
\end_inset

, which delays the evaluation of a value of type 
\begin_inset Formula $R$
\end_inset

.
 This allows us to implement a well-defined, finite value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: L[A]
\end_layout

\end_inset

 which refers to itself under the delayed evaluation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, Unit => R]
\end_layout

\begin_layout Plain Layout

final case class Looping[A](run: S[A, Looping[A]])
\end_layout

\begin_layout Plain Layout

lazy val x: Looping[Int] = Looping(Right(_ => x))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.run.right.get(())                      // No stack overflows.
\end_layout

\begin_layout Plain Layout

val res0: Looping[Int] = Looping(Right($Lambda$1123/1058984040@753aca85))
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.run.right.get(()).run.right.get(())    // This is again the same value:
\end_layout

\begin_layout Plain Layout

val res1: Looping[Int] = Looping(Right($Lambda$1123/1058984040@753aca85))
\end_layout

\end_inset

Trying to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold(f)(x)
\end_layout

\end_inset

 with any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 will result in an infinite loop.
\end_layout

\begin_layout Standard
It seems that we need to restrict recursion schemes 
\begin_inset Formula $S^{A,R}$
\end_inset

 to 
\emph on
polynomial
\emph default
 bifunctors.
 Such 
\begin_inset Formula $S^{A,R}$
\end_inset

 will define recursive polynomial functors 
\begin_inset Formula $L^{A}$
\end_inset

 that support no delayed evaluation of stored values of type 
\begin_inset Formula $A$
\end_inset

.
 So, any value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset Formula $L^{A}$
\end_inset

 will have to contain a finite number of values of type 
\begin_inset Formula $A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold(f)(x)
\end_layout

\end_inset

 is guaranteed to terminate for any terminating function 
\begin_inset Formula $f:S^{A,Z}\rightarrow Z$
\end_inset

.
\end_layout

\begin_layout Standard
Rather than working with the general 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 function and redefine all recursive types via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

, it is more convenient to implement and use specialized versions of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 for already defined recursive types.
 The general implementation of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-via-recursion-scheme-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be translated mechanically (e.g., using macros or code generators) into
 code specialized for a given data type and recursion scheme.
\end_layout

\begin_layout Standard
For instance, while the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix[S3[A, *]]
\end_layout

\end_inset

 shown above, it is easier to work with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

.
 The specialized version of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 has the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldTreeN[A, Z](f: S3[A, Z] => Z): TreeN[A] => Z = ???
\end_layout

\end_inset

The general definition of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fold-via-recursion-scheme-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows us how to write the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldTreeN
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldTreeN[A, Z](f: Either[A, NEL[Z]] => Z): TreeN[A] => Z = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)      => f(Left(a))
\end_layout

\begin_layout Plain Layout

  case Branch(ts)   => f(Right(ts.map(foldTreeN(f))))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Then we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeX
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def printLaTeX[A](tree: TreeN[A]): String = "
\backslash

\backslash
Tree" + foldTreeN[A, String](toLaTeX3)(tree)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another simple example of an aggregation operation that cannot be expressed
 as a traversal is the task of determining the maximum branching number
 of a given rose tree.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldTreeN
\end_layout

\end_inset

 now allows us to implement that computation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxBranching[A]: TreeN[A] => Int = foldTreeN[A, Int] {
\end_layout

\begin_layout Plain Layout

  case Left(_)      => 0
\end_layout

\begin_layout Plain Layout

  case Right(nel)   => math.max(nel.max, nel.length)    // NEL must have `max`
 and `length` methods.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxBranching(x3)
\end_layout

\begin_layout Plain Layout

res2: Int = 2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Recursion schemes.
 II.
 Unfolding operations
\end_layout

\begin_layout Standard
A folding operation converts a collection to a single value.
 The opposite operation is 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

: converting a single value into a collection.
 By reversing the direction of certain function arrows in the type signature
 of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

, we can define a general 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

 method that uses an arbitrary recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 and an arbitrary function of type 
\begin_inset Formula $Z\rightarrow S^{A,Z}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{unfold}_{S}:(Z\rightarrow S^{A,Z})\rightarrow Z\rightarrow L^{A}\quad,\quad\text{unfold}_{S}(f)\triangleq f\bef\overline{\text{unfold}_{S}(f)}^{\uparrow S^{A,\bullet}}\quad.\label{eq:unfold-via-recursion-scheme}
\end{equation}

\end_inset

Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ch2Converting-a-single"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed an unfolding operation for sequences: starting from an initial value,
 a function is applied repeatedly to compute further elements of the sequence.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 operation generalizes that computation to an arbitrary recursive type 
\begin_inset Formula $L^{A}$
\end_inset

 whose recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 is given.
 
\end_layout

\begin_layout Standard
To get more intuition, we look at some examples using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 with lists and binary trees.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-unfold-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 of consecutive powers of 
\begin_inset Formula $2$
\end_inset

 up to a given value 
\begin_inset Formula $n$
\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = ???
\end_layout

\begin_layout Plain Layout

type Z = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def unfoldList[A, Z](f: Z => S[A, Z])(init: Z): List[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def powersOf2UpTo(n: Long): List[Long] = unfoldList(???)(???)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> powersOf2UpTo(1000)
\end_layout

\begin_layout Plain Layout

res0: List[Long] = List(1, 2, 4, 8, 16, 32, 64, 128, 256, 512)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The recursion scheme for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $S^{A,R}\triangleq\bbnum 1+A\times R$
\end_inset

.
 Let us specialize the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:unfold-via-recursion-scheme"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Option[(A, R)]
\end_layout

\begin_layout Plain Layout

def unfoldList[A, Z](f: Z => S[A, Z])(init: Z): List[A] = f(init) match
 {
\end_layout

\begin_layout Plain Layout

  case None           => Nil
\end_layout

\begin_layout Plain Layout

  case Some((a, z))   => a :: unfoldList(f)(z)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now need to determine a suitable type 
\begin_inset Formula $Z$
\end_inset

 and a suitable function 
\begin_inset Formula $f:Z\rightarrow\bbnum 1+A\times Z$
\end_inset

 so that the unfolding would produce the required sequence.
 If we are in the middle of unfolding, we need to produce the remaining
 portion of the list, say, 
\begin_inset Formula $\left[128,256,512\right]$
\end_inset

, given only a current value of type 
\begin_inset Formula $Z$
\end_inset

.
 We can do that if the current value of type 
\begin_inset Formula $Z$
\end_inset

 is 
\begin_inset Formula $128$
\end_inset

 (the smallest remaining power of 
\begin_inset Formula $2$
\end_inset

).
 So, let us choose 
\begin_inset Formula $Z\triangleq$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

 to represent the smallest remaining power of 
\begin_inset Formula $2$
\end_inset

.
 The type 
\begin_inset Formula $A$
\end_inset

 will be also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
How can we implement the function 
\begin_inset Formula $f$
\end_inset

? It should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $1+\bbnum 0$
\end_inset

) when the list is finished.
 When we are in the middle of generating the list, the call 
\begin_inset Formula $f(z)$
\end_inset

 should return 
\begin_inset Formula $\bbnum 0+a\times z^{\prime}$
\end_inset

 with some values 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $z^{\prime}$
\end_inset

.
 The value 
\begin_inset Formula $a$
\end_inset

 must be the new element of the list.
 The value 
\begin_inset Formula $z^{\prime}$
\end_inset

 will be passed to the next call of 
\begin_inset Formula $f$
\end_inset

.
 Since the next element must be twice the previous one, we must have 
\begin_inset Formula $a=z$
\end_inset

 and 
\begin_inset Formula $z^{\prime}=2*z$
\end_inset

.
 So, the code of 
\begin_inset Formula $f$
\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(n: Long): Long => Option[(Long, Long)] = { z => if (z >= n) None else
 Some((z, z * 2)) }
\end_layout

\end_inset

Note that the code of 
\begin_inset Formula $f$
\end_inset

 is 
\emph on
not
\emph default
 recursive, and the value 
\begin_inset Formula $n$
\end_inset

 is captured inside the nameless function returned by 
\begin_inset Formula $f(n)$
\end_inset

.
 We can now complete the solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def powersOf2UpTo(n: Long): List[Long] = unfoldList(f(n))(1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-unfold-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 for the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Use it to create 
\begin_inset Quotes eld
\end_inset

full
\begin_inset Quotes erd
\end_inset

 binary trees of given depth, e.g., 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ 0 1 ] [ 2 3 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 (depth 
\begin_inset Formula $2$
\end_inset

) and 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ [ 0 1 ] [ 2 3 ] ] [ [ 4 5 ] [ 6 7 ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 (depth 
\begin_inset Formula $3$
\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We adapt the general code in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:unfold-via-recursion-scheme"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to obtain the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (R, R)]
\end_layout

\begin_layout Plain Layout

def unfoldT2[A, Z](f: Z => S[A, Z])(init: Z): T2[A] = f(init) match {
\end_layout

\begin_layout Plain Layout

  case Left(a)           => Leaf(a)
\end_layout

\begin_layout Plain Layout

  case Right((z1, z2))   => Branch(unfoldT2(f)(z1), unfoldT2(f)(z2))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We plan to implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fullBinaryTree
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fullBinaryTree(n: Int): T2[Int] = {
\end_layout

\begin_layout Plain Layout

  type Z = ???
\end_layout

\begin_layout Plain Layout

  val init: Z = ???
\end_layout

\begin_layout Plain Layout

  val f: Z => Either[Int, (Z, Z)] = ???
\end_layout

\begin_layout Plain Layout

  unfoldT2[Int, Z](f)(init)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The next step is to choose a suitable type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 such that the unfolding procedure can generate trees of the required shape.
 To figure out what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 must be, we need to consider an intermediate step that generates a subtree
 at some point in the middle of 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

.
 For the tree of depth 
\begin_inset Formula $3$
\end_inset

 as shown above, an example of a subtree in the middle is 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 4 5 ]
\end_layout

\end_inset


\end_layout

\end_inset

.
 This subtree must be computed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2(f)(z)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
 The information needed for this computation is the initial value (
\begin_inset Formula $4$
\end_inset

) and the total number (
\begin_inset Formula $2$
\end_inset

) of the subtree's leaves.
 So, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 needs to contain two integers: the value of the first leaf and the size
 of the remaining subtree (which will always be a power of 
\begin_inset Formula $2$
\end_inset

).
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

type Z = (Int, Int)        // (k, m) where k is the first leaf$
\backslash
color{dkgreen}
\backslash
texttt{'}$s value and m is the subtree size.
\end_layout

\begin_layout Plain Layout

val init: Z = (0, 1 << n)  // The size of the entire tree is 2 to the power
 n.
\end_layout

\end_inset

The initial value for the entire tree shown above will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(0, 8)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Next, we figure out the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is applied to a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k, m)
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

, it should generate the corresponding subtree.
 If the subtree size 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 is 
\begin_inset Formula $1$
\end_inset

, the return value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(k)
\end_layout

\end_inset

.
 Otherwise, the return value should give two new values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 corresponding to the two subtrees one level deeper.
 Those two subtrees have sizes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m / 2
\end_layout

\end_inset

 and initial values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m / 2 + k
\end_layout

\end_inset

.
 So, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Z => Either[Int, (Z, Z)] = {
\end_layout

\begin_layout Plain Layout

  case (k, m) if m == 1   => Left(k)
\end_layout

\begin_layout Plain Layout

  case (k, m)             => Right(((k, m / 2), (m / 2 + k, m / 2)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This completes the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fullBinaryTree
\end_layout

\end_inset

.
 To test the resulting code, compute a full tree of depth 
\begin_inset Formula $2$
\end_inset

:
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ 0 1 ] [ 2 3 ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fullBinaryTree(2)
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Branch(Leaf(0), Leaf(1)), Branch(Leaf(2), Leaf(3)))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-unfold-tree-evenodd"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-tree-evenodd"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(n)
\end_layout

\end_inset

 that generates binary trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[Int]
\end_layout

\end_inset

 where the leaves have descending numbers from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, but all odd numbers are on the left and all even numbers on the right.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(3)
\end_layout

\end_inset

 should generate the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 3 [ [ 1 0 ] 2 ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 , while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(4)
\end_layout

\end_inset

 should give the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ 3 [ [ 1 0 ] 2 ] ] 4 ]
\end_layout

\end_inset


\end_layout

\end_inset

 .
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We plan to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def evenOdd(n: Int): T2[Int] = {
\end_layout

\begin_layout Plain Layout

  type Z = ???
\end_layout

\begin_layout Plain Layout

  val init: Z = ???
\end_layout

\begin_layout Plain Layout

  val f: Z => Either[Int, (Z, Z)] = ???
\end_layout

\begin_layout Plain Layout

  unfoldT2[Int, Z](f)(init)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The examples with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(3)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(4)
\end_layout

\end_inset

 suggest that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(n)
\end_layout

\end_inset

 is a tree containing a leaf with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 and a subtree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd(n - 1)
\end_layout

\end_inset

.
 Can we use the integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 as the initial value for unfolding? 
\end_layout

\begin_layout Standard
To figure this out, consider an intermediate stage of the unfolding process
 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 will apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z) == Left(k)
\end_layout

\end_inset

, we will get a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

.
 The other possibility is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z) == Right((z1, z2))
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

 are some values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

.
 This will generate a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 with two subtrees.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT2
\end_layout

\end_inset

 will then apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

 in order to create the left and the right subtrees.
 The difference between those subtrees must come entirely from the difference
 between the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
In our case, we need to make a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 either at the left or at the right depending on whether the initial leaf
 value is odd or even.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 must know whether 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z)
\end_layout

\end_inset

 should return a subtree or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

.
 This information can only come from the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

.
 So, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 must contain a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 flag saying whether we need a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 at the current place.
 For clarity, let us define the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

 as a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Z(startAt: Int, makeLeaf: Boolean)
\end_layout

\begin_layout Plain Layout

val init = Z(startAt = n, makeLeaf = false)
\end_layout

\end_inset

When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeLeaf
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, we must create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 should return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

.
 Otherwise 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 should return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((z1, z2))
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z2
\end_layout

\end_inset

 should set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

makeLeaf
\end_layout

\end_inset

 depending on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startAt
\end_layout

\end_inset

 being odd or even.
 Looking at the examples, we find that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 must also return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left()
\end_layout

\end_inset

 when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

startAt == 0
\end_layout

\end_inset

.
 So, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Z => Either[Int, (Z, Z)] = {
\end_layout

\begin_layout Plain Layout

  case Z(n, false) if n > 0 && n % 2 == 0  => Right((Z(n - 1, false), Z(n,
 true)))
\end_layout

\begin_layout Plain Layout

  case Z(n, false) if n > 0 && n % 2 == 1  => Right((Z(n, true), Z(n - 1,
 false)))
\end_layout

\begin_layout Plain Layout

  case Z(n, _)                             => Left(n) // Make a leaf when
 n == 0 or makeLeaf == true.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

evenOdd
\end_layout

\end_inset

 is now complete.
 To test:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "74col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> evenOdd(3)
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Leaf(3), Branch(Branch(Leaf(1), Leaf(0)), Leaf(2)))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 3 [ [ 1 0 ] 2 ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The kind of reasoning shown in Examples
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-unfold-tree-evenodd"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is called 
\series bold
co-induction
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
co-induction
\end_layout

\end_inset

.
 It is related to mathematical induction but is significantly different
 from the reasoning required to write the code for a folding operation (which
 is directly modeled on induction).
 In co-induction, the base cases are not at the beginning of the computation
 but 
\begin_inset Quotes eld
\end_inset

in the future
\begin_inset Quotes erd
\end_inset

.
 Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold(f)(z)
\end_layout

\end_inset

 will call itself whenever the value 
\begin_inset Formula $f(z)$
\end_inset

 of type 
\begin_inset Formula $S^{A,Z}$
\end_inset

 contains additional values of type 
\begin_inset Formula $Z$
\end_inset

.
 The programmer must carefully choose a suitable type 
\begin_inset Formula $Z$
\end_inset

 and a suitable function 
\begin_inset Formula $f$
\end_inset

 such that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold(f)(z)
\end_layout

\end_inset

 stops the recursion at the required places.
 For instance, if 
\begin_inset Formula $S^{A,Z}\triangleq A+Z\times Z$
\end_inset

, the function 
\begin_inset Formula $f$
\end_inset

 must sometimes return a value of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 to stop the unfolding.
\end_layout

\begin_layout Standard
Is the recursion guaranteed to stop while evaluating 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

? The type signature 
\begin_inset Formula $f:Z\rightarrow S^{A,Z}$
\end_inset

 itself does not guarantee that 
\begin_inset Formula $f(z)$
\end_inset

 returns values that will stop the unfolding at the right places.
 If 
\begin_inset Formula $S^{A,Z}\triangleq A+Z\times Z$
\end_inset

 and 
\begin_inset Formula $f(z)$
\end_inset

 always returns values of type 
\begin_inset Formula $\bbnum 0+Z\times Z$
\end_inset

 (for example, 
\begin_inset Formula $f(z)\triangleq\bbnum 0+z\times z$
\end_inset

), the unfolding operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold(f)
\end_layout

\end_inset

 will enter an infinite loop trying to constructing a tree of infinite size.
 This will, of course, fail since data structures in a computer cannot have
 infinite size.
\end_layout

\begin_layout Standard
Unfolding will always terminate if we use a data type that 
\emph on
delays
\emph default
 the evaluation of its recursively defined parts.
 Those parts will be computed only on demand.
 To obtain further data, the code needs to call certain functions.
 Data types of this kind are sometimes called 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

,
\begin_inset Index idx
status open

\begin_layout Plain Layout
infinite data types
\end_layout

\end_inset

 which is misleading since no infinite amount of data is involved.
 A function may be called many times and produce any number of result values,
 but it does not mean that a function stores an infinite amount of data.
\end_layout

\begin_layout Standard
As an example, consider the recursion scheme 
\begin_inset Formula $S^{A,R}\triangleq A+(\bbnum 1\rightarrow R\times R)$
\end_inset

.
 The corresponding data type 
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset

 is a binary tree whose branches are evaluated on demand (but leaves are
 evaluated eagerly).
 This data structure supports unfolding with 
\emph on
any
\emph default
 function 
\begin_inset Formula $f:Z\rightarrow S^{A,Z}$
\end_inset

 because the recursive evaluation of 
\begin_inset Formula $f$
\end_inset

 at the branches is always delayed.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 can generate a value of type 
\begin_inset Formula $L^{A}$
\end_inset

 whose tree structure has the form 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 1 [ 2  [3 ...
 ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset

 with unbounded size:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, Unit => (R, R)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sealed trait UT[A]      // A tree with on-call evaluation of branches and
 eager evaluation of leaves.
\end_layout

\begin_layout Plain Layout

case class ULeaf[A](a: A)                          extends UT[A]
\end_layout

\begin_layout Plain Layout

case class UBranch[A](run: Unit => (UT[A], UT[A])) extends UT[A] // Call
 run(()) to get the branches.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def unfoldUT[A, Z](f: Z => S[A, Z])(init: Z): UT[A] = f(init) match {
\end_layout

\begin_layout Plain Layout

  case Left(a)       => ULeaf(a)
\end_layout

\begin_layout Plain Layout

  case Right(func)   => UBranch { _ =>     // It is important to delay the
 evaluation of func(()).
\end_layout

\begin_layout Plain Layout

    val (z1, z2) = func(())                // Force the evaluation of branches
 at this level.
\end_layout

\begin_layout Plain Layout

    (unfoldUT(f)(z1), unfoldUT(f)(z2))     // `unfold` will delay the evaluation
 of further branches.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val tree1toInf = unfoldUT[Int, (Int, Boolean)] { case (z, makeLeaf) =>
\end_layout

\begin_layout Plain Layout

  if (makeLeaf) Left(z) else Right(_ => ((z + 1, true), (z + 1, false)))
\end_layout

\begin_layout Plain Layout

}((0, false))
\end_layout

\end_inset

The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tree1toInf
\end_layout

\end_inset

 is finite but can compute a tree of unbounded depth.
 To visualize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tree1toInf
\end_layout

\end_inset

, we write a function that converts 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

UT[A]
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 by stopping at a given maximum depth.
 The unevaluated parts of the tree will be marked with a value called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

default
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toT2[A](maxDepth: Int, default: A): UT[A] => T2[A] = {
\end_layout

\begin_layout Plain Layout

  case ULeaf(a)        => Leaf(a)e
\end_layout

\begin_layout Plain Layout

  case UBranch(func)   => if (maxDepth == 0) Leaf(default) else {
\end_layout

\begin_layout Plain Layout

    val (z1, z2) = func(())
\end_layout

\begin_layout Plain Layout

    Branch(toT2(maxDepth - 1, default)(z1), toT2(maxDepth - 1, default)(z2))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test this code, let us truncate the infinite structure 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tree1toInf
\end_layout

\end_inset

 at depth 
\begin_inset Formula $4$
\end_inset

.
 The result is a finite tree of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[Int]
\end_layout

\end_inset

, where the unevaluated part of the tree is shown as 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "65col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> toT2(maxDepth = 3, default = -1)(tree1toInf)
\end_layout

\begin_layout Plain Layout

res0: T2[Int] = Branch(Leaf(1), Branch(Leaf(2), Branch(Leaf(3), Branch(Leaf(4),
 Leaf(-1)))))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ 1 [ 2  [3 [ 4 -1 ] ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Recursion schemes.
 III.
 Traversing operations
\end_layout

\begin_layout Standard
Folding with a recursion scheme (
\begin_inset Formula $\text{fold}_{S}$
\end_inset

) allows us to implement operations such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printLaTeXSubtree
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that cannot be expressed via ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 functions.
 Another operation not expressible via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

, which we implemented in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tasks-not-implementable-via-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

 through custom code.
 We will now implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 via a more general traversal operation (
\begin_inset Formula $\text{trav}_{S}$
\end_inset

) parameterized by an arbitrary recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and an arbitrary functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 (not necessarily applicative).
\end_layout

\begin_layout Standard
To figure out the type signature of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

, consider the relationship between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

, and the ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\text{trav}_{L}$
\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{foldMap}_{L}(f^{:A\rightarrow Z}):L^{A}\rightarrow Z\quad,\quad\quad\text{trav}_{L}(f^{:A\rightarrow F^{B}}):L^{A}\rightarrow F^{L^{B}}\quad,\\
 & \text{fold}_{S}(f^{:S^{A,Z}\rightarrow Z}):L^{A}\rightarrow Z\quad,\quad\quad\text{trav}_{S}(f^{:???}):L^{A}\rightarrow F^{L^{B}}\quad.
\end{align*}

\end_inset

We recover 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 by setting the applicative functor 
\begin_inset Formula $F$
\end_inset

 as 
\begin_inset Formula $F^{B}\triangleq Z$
\end_inset

.
 So, we expect to obtain the type signature of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 from the type signature of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 if we replace 
\begin_inset Formula $Z$
\end_inset

 by 
\begin_inset Formula $F^{L^{B}}$
\end_inset

.
 The first argument 
\begin_inset Formula $f$
\end_inset

 of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 will then have the type 
\begin_inset Formula $S^{A,F^{L^{B}}}\rightarrow F^{L^{B}}$
\end_inset

:
\begin_inset Formula 
\[
\text{trav}_{S}:(S^{A,F^{L^{B}}}\rightarrow F^{L^{B}})\rightarrow L^{A}\rightarrow F^{L^{B}}\quad.
\]

\end_inset

To implement this method, begin with the type equivalence 
\begin_inset Formula $L^{A}\cong S^{A,L^{A}}$
\end_inset

.
 We can apply 
\begin_inset Formula $\text{trav}_{S}(f)$
\end_inset

 recursively to the values of type 
\begin_inset Formula $L^{A}$
\end_inset

 stored inside 
\begin_inset Formula $S^{A,L^{A}}$
\end_inset

 and obtain a value of type 
\begin_inset Formula $S^{A,F^{L^{B}}}$
\end_inset

:
\begin_inset Formula 
\[
\big(s^{:S^{A,L^{A}}}\triangleright\,\overline{\text{trav}_{S}(f)}^{\uparrow S^{A,\bullet}}\big):S^{A,F^{L^{B}}}\quad.
\]

\end_inset

It remains to apply 
\begin_inset Formula $f$
\end_inset

 to the last obtained value.
 This completes the code of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

: 
\begin_inset Formula 
\[
\text{trav}_{S}\big(f^{:S^{A,F^{L^{B}}}\rightarrow F^{L^{B}}}\big)\triangleq\overline{\text{trav}_{S}(f)}^{\uparrow S^{A,\bullet}}\bef f\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The method 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 works in the same way for all recursion schemes 
\begin_inset Formula $S$
\end_inset

 and for all type constructors 
\begin_inset Formula $F$
\end_inset

.
 This makes 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 powerful but hard to use because we need to work with data structures defined
 via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fix
\end_layout

\end_inset

 type constructor.
 It is easier to use a specialized version of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 for the data structure at hand, similarly to what we did in the previous
 sections for folding and unfolding.
 
\end_layout

\begin_layout Standard
To illustrate this, let us implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 via 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 with a binary tree recursion scheme.
 We will use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad as the functor 
\begin_inset Formula $F$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class St[A](run: Int => (A, Int))  { // A State monad with internal
 state of type Int.
\end_layout

\begin_layout Plain Layout

  import io.chymyst.ch.implement                // Implement the monad methods
 automatically.
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => St[B]): St[B] = implement
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): St[B] = implement
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def incrementAndGet: St[Int] = St(s => (s + 1, s + 1))  // Increment the
 current state value.
\end_layout

\begin_layout Plain Layout

def get: St[Int] = St(s => (s, s))             // Fetch the current state
 value.
\end_layout

\begin_layout Plain Layout

def set(s: Int): St[Unit] = St(_ => ((), s))   // Set the state, ignore
 previous state value.
\end_layout

\end_inset

Next, define the recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 and a specialized version of 
\begin_inset Formula $\text{trav}_{S}$
\end_inset

 for trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (R, R)]          // Recursion scheme for T2[A].
\end_layout

\begin_layout Plain Layout

def travT2[A, B, F[_]](f: S[A, F[T2[B]]] => F[T2[B]]): T2[A] => F[T2[B]]
 = {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)        => f(Left(a))
\end_layout

\begin_layout Plain Layout

  case Branch(l, r)   => f(Right((travT2(f)(l), travT2(f)(r))))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It remains to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

travT2
\end_layout

\end_inset

 to a suitable function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 The value of the internal state will represent the current depth of the
 tree element.
 We need to increment the depth whenever we find a branch and then traverse
 the two subtrees starting from the same depth value.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithDepth[A](tree: T2[A]): T2[(A, Int)] = travS[A, (A, Int), St]
 {
\end_layout

\begin_layout Plain Layout

  case Left(a) => for { s <- get } yield Leaf((a, s))   // Put the current
 depth into the Leaf value.
\end_layout

\begin_layout Plain Layout

  case Right((l, r))   => for {
\end_layout

\begin_layout Plain Layout

    s <- incrementAndGet   // Read the current depth after incrementing
 it.
\end_layout

\begin_layout Plain Layout

    x <- l                 // Traverse the left branch starting from depth
 `s`.
\end_layout

\begin_layout Plain Layout

    _ <- set(s)            // Set the same initial depth `s` for traversing
 the right branch.
       
\end_layout

\begin_layout Plain Layout

    y <- r                 // Traverse the right branch.
\end_layout

\begin_layout Plain Layout

  } yield Branch(x, y)
\end_layout

\begin_layout Plain Layout

}(tree).run(0)._1
\end_layout

\end_inset

To test the code, apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

 to a sample tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 used earlier in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Decorating-a-tree-breadth-first-traversal"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tasks-not-implementable-via-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "70col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> zipWithDepth(t2)
\end_layout

\begin_layout Plain Layout

res0: T2[(Int, Int)] = Branch(Leaf((8, 1)), Branch(Branch(Leaf((3, 3)),
 Leaf((5, 3))), Leaf((4, 2))))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ (8,1) [ [ (3,3) (5,3) ] (4,2) ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Here we need to use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set(s)
\end_layout

\end_inset

 with a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 obtained from a previous monadic computation.
 So, the code involves 
\begin_inset Formula $\text{trav}_{S}(f)$
\end_inset

 with a function 
\begin_inset Formula $f:S^{A,F^{L^{B}}}\rightarrow F^{L^{B}}$
\end_inset

 whose 
\begin_inset Formula $F$
\end_inset

-effect is 
\emph on
not
\emph default
 equivalent to an applicative functor's effect (which cannot depend on a
 previously computed value).
 We can see that the recursion scheme-based traversal (
\begin_inset Formula $\text{trav}_{S}$
\end_inset

) is more powerful than the plain traversal, 
\begin_inset Formula $\text{trav}_{L}(f^{:A\rightarrow F^{B}})$
\end_inset

, that may only use 
\begin_inset Formula $F$
\end_inset

's applicative functor methods.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-7-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-7-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the following type constructors:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $F^{A}\triangleq\text{Int}+A+A\times A\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $F^{A}\triangleq(\text{String}+A)\times(\bbnum 1+A\times A)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $F^{A}\triangleq A+A\times F^{A}$
\end_inset

 (a recursive definition equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

, the non-empty list).
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A+A\times A\times F^{A}$
\end_inset

 (a recursive definition).
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $F^{A}\triangleq(\bbnum 1+F^{A})\times(\bbnum 1+A\times F^{A})$
\end_inset

 (a recursive definition).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the binary tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

), implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance for 
\emph on
right-to-left
\emph default
 depth-first traversal order.
 Use that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

.
 Verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 transforms the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ 8 [ 3 5 ] ] 4 ] 
\end_layout

\end_inset


\end_layout

\end_inset

 into 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ (8,3) [ (3,2) (5,1) ] ] (4,0) ] 
\end_layout

\end_inset


\end_layout

\end_inset

 .
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance for the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T3
\end_layout

\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-I-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-8-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-8-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Decorating-a-tree-breadth-first-traversal"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TD
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method to re-implement the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

addRight
\end_layout

\end_inset

 from that section.
 Show that the new implementations are equivalent to the old ones.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the specialized version of 
\begin_inset Formula $\text{fold}_{S}$
\end_inset

 for the binary tree 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T2[A]
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursion-schemes.-folding"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to compute the maximum depth of a tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxDepth[A](tree: T2[A]): Int = foldT2(???)(???)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxDepth(Branch(Leaf(0), Branch(Branch(Leaf(0), Leaf(0)), Leaf(0))))
\end_layout

\begin_layout Plain Layout

res0: Int = 3
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T3[A]
\end_layout

\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-I-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, define a recursion scheme and implement a specialized version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT3
\end_layout

\end_inset

.
 Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfoldT3
\end_layout

\end_inset

, write a function that generates ternary trees of the form 
\size tiny

\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[.3  0  [.2 0   1   0  ]   0  ] 
\end_layout

\end_inset


\end_layout

\end_inset


\size default
 starting from the given integer 
\begin_inset Formula $n$
\end_inset

 at the root.
\end_layout

\begin_layout Section
Laws and structure
\end_layout

\begin_layout Standard
To study the laws of the folding and traversing operations, it helps to
 choose simpler but equivalent versions of these operations.
 We have seen four methods that implement folding operations: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

.
 With suitable naturality laws, these methods are equivalent.
\end_layout

\begin_layout Subsection
Equivalence of 
\family typewriter
reduce
\family default
, 
\family typewriter
foldLeft
\family default
, 
\family typewriter
foldMap
\family default
, and 
\family typewriter
toList
\family default
.
 Monoid morphisms
\begin_inset CommandInset label
LatexCommand label
name "subsec:Equivalence-of-foldLeft,foldMap,reduce,and-toList"

\end_inset


\end_layout

\begin_layout Standard
Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method assumes a non-empty sequence and will fail otherwise:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A](la: Seq[A])(red: (A, A) => A): A
\end_layout

\end_inset

For the purposes of this section, we will modify 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 to supply a default value for empty sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduceE[A](la: Seq[A])(default: A)(red: (A, A) => A): A =
\end_layout

\begin_layout Plain Layout

if (la.isEmpty) default else reduce(la)(red)
\end_layout

\end_inset

Having a default value of type 
\begin_inset Formula $A$
\end_inset

 and a binary operation of type 
\begin_inset Formula $A\times A\rightarrow A$
\end_inset

 suggest that 
\begin_inset Formula $A$
\end_inset

 may be a monoid (assuming that the monoid laws hold, see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we simplify the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass constraint:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduceE[M: Monoid](la: Seq[M]): M
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this change, let us compare the type signatures of the four methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, B](la: L[A])(init: B)(update: (B, A) => B): B
\end_layout

\begin_layout Plain Layout

def foldMap[M: Monoid, A](f: A => M): L[A] => M
\end_layout

\begin_layout Plain Layout

def reduceE[M: Monoid]: L[M] => M
\end_layout

\begin_layout Plain Layout

def toList[A]: L[A] => List[A]
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{foldLeft}_{L}:L^{A}\rightarrow B\rightarrow(B\times A\rightarrow B)\rightarrow B\quad,\quad\quad\text{foldMap}_{L}:(A\rightarrow M)\rightarrow L^{A}\rightarrow M\quad,\\
 & \text{reduceE}_{L}:L^{M}\rightarrow M\quad,\quad\quad\text{toList}_{L}:L^{A}\rightarrow\text{List}^{A}\quad.
\end{align*}

\end_inset

We will now show that these four functions are equivalent, assuming certain
 naturality laws.
\end_layout

\begin_layout Standard
The formulation of naturality laws is different for functions whose type
 parameters have typeclass constraints.
 For example, consider 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 whose type parameter 
\begin_inset Formula $M$
\end_inset

 is constrained to be a monoid.
 The naturality law for functions 
\begin_inset Formula $\phi$
\end_inset

 with type signature 
\begin_inset Formula $\forall M.\,L^{M}\rightarrow M$
\end_inset

 (but without the typeclass constraint) is:
\begin_inset Formula 
\[
\text{for all }f^{:M\rightarrow N}\quad:\quad\quad\phi^{:L^{M}\rightarrow M}\bef f=f^{\uparrow L}\bef\phi^{:L^{N}\rightarrow N}\quad.
\]

\end_inset

Does this law hold with 
\begin_inset Formula $\phi=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

? Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 would be used with type parameters 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, those types have to be monoids for the law to make sense.
 Also, it turns out that the law must be used only with functions 
\begin_inset Formula $f$
\end_inset

 that satisfy certain conditions with respect to the monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 
\end_layout

\begin_layout Standard
To see why, let us set 
\begin_inset Formula $L=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 We expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 method will satisfy the naturality law as long as we formulate that law
 correctly.
 We now apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 to an empty list and to a list with two elements of type 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Formula 
\[
\text{reduceE}\left(\left[\right]\right)=e_{M}\quad,\quad\quad\text{reduceE}\left(\left[x,y\right]\right)=x\oplus_{M}y\quad.
\]

\end_inset

Similar values are found when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 is used with the monoid 
\begin_inset Formula $N$
\end_inset

.
 Then we have:
\begin_inset Formula 
\begin{align*}
 & \left[\right]\triangleright\text{reduceE}\triangleright f=f(e_{M})\quad,\quad\quad\left[\right]\triangleright f^{\uparrow L}\triangleright\text{reduceE}=\left[\right]\triangleright\text{reduceE}=e_{N}\quad,\\
 & \left[x,y\right]\triangleright\text{reduceE}\triangleright f=(x\oplus_{M}y)\triangleright f=f(x\oplus_{M}y)\quad,\\
 & \left[x,y\right]\triangleright f^{\uparrow L}\triangleright\text{reduceE}=\left[f(x),f(y)\right]\triangleright\text{reduceE}=f(x)\oplus_{N}f(y)\quad.
\end{align*}

\end_inset

It follows that the law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 only if the function 
\begin_inset Formula $f$
\end_inset

 has the properties: 
\begin_inset Formula 
\[
f(e_{M})=e_{N}\quad,\quad\quad f(x\oplus_{M}y)=f(x)\oplus_{N}f(y)\quad.
\]

\end_inset

These properties mean that 
\begin_inset Formula $f:M\rightarrow N$
\end_inset

 preserves the operations of the monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, in the sense that 
\begin_inset Formula $f$
\end_inset

 maps the empty value 
\begin_inset Formula $e_{M}$
\end_inset

 to the empty value 
\begin_inset Formula $e_{N}$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

's binary operation to 
\begin_inset Formula $N$
\end_inset

's.
 Functions with these properties are called 
\begin_inset Quotes eld
\end_inset

monoid morphisms
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-monoid-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-monoid-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any two monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, a function 
\begin_inset Formula $f:M\rightarrow N$
\end_inset

 is a 
\series bold
monoid morphism
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monoid morphism|textit
\end_layout

\end_inset

 if 
\begin_inset Formula $f$
\end_inset

 satisfies the following laws:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & f(e_{M})=e_{N}\quad,\\
\text{composition law}:\quad & f(x^{:M}\oplus_{M}y^{:M})=f(x)\oplus_{N}f(y)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
monoidal naturality law
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monoidal naturality law
\end_layout

\end_inset

of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 is then formulated as:
\begin_inset Formula 
\begin{equation}
\text{reduceE}^{M}\bef f^{:M\rightarrow N}=f^{\uparrow L}\bef\text{reduceE}^{N}\quad.\label{eq:monoidal-naturality-law-of-reduceE}
\end{equation}

\end_inset


\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{3.5pc}L^{M}\ar[r]\sp(0.5){\ \text{reduceE}^{M}}\ar[d]\sp(0.45){\,f^{\uparrow L}} & M\ar[d]\sp(0.45){\,f}\\
L^{N}\ar[r]\sp(0.5){~\text{reduceE}^{N}} & N
}
\]

\end_inset


\end_layout

\end_inset

Here the types 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 are arbitrary monoids and 
\begin_inset Formula $f:M\rightarrow N$
\end_inset

 is an arbitrary monoid morphism between 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 
\end_layout

\begin_layout Standard
The monoidal naturality law expresses a programmer's expectation that the
 code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE[M]
\end_layout

\end_inset

 should work in the same way for every monoid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 should be fully parametric and may use the monoid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

's methods but may not, e.g., inspect the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

 via run-time reflection and make any decisions based on that.
 
\end_layout

\begin_layout Standard
With these definitions, we can now give a precise formulation of the following
 equivalences:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-foldleft-foldmap-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-foldleft-foldmap-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are equivalent as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 satisfies the naturality law with respect to its type parameter 
\begin_inset Formula $A$
\end_inset

.
 In addition, Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show that the monoidal naturality laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are equivalent.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is equivalent to a new method we call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 (
\begin_inset Quotes eld
\end_inset

fold with function
\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\[
\text{foldFn}:L^{B\rightarrow B}\rightarrow B\rightarrow B\quad,
\]

\end_inset

as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 satisfies the naturality law with respect to its type parameter 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are equivalent as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 obeys the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shown below and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 satisfies the monoidal naturality law.
 
\end_layout

\begin_layout Standard
We will show in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:relational-property-for-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below that the special laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) follow from parametricity.
 So, these laws will hold automatically when the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 is fully parametric.
 However, formulating these special laws allows us to prove the equivalence
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 without assuming parametricity.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The equivalence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 if we assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 satisfies the naturality law with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 To prove that equivalence, we just need to set 
\begin_inset Formula $F^{A}\triangleq L^{A}$
\end_inset

, 
\begin_inset Formula $G^{B}\triangleq M$
\end_inset

, and 
\begin_inset Formula $K^{B}\triangleq M$
\end_inset

 in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We first reformulate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

's type signature in a form more similar to that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 We change the order of curried arguments in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and also replace the updater function of type 
\begin_inset Formula $B\times A\rightarrow B$
\end_inset

 by an equivalent curried function of type 
\begin_inset Formula $A\rightarrow B\rightarrow B$
\end_inset

 (similarly to what was done in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:From-reduce-and-foldleft-to-foldmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The result is a function we denote by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fldl
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{fldl}:(A\rightarrow B\rightarrow B)\rightarrow L^{A}\rightarrow B\rightarrow B\quad,\quad\quad\text{fldl}\,(u^{:A\rightarrow B\rightarrow B})(p^{:L^{A}})(z^{:B})\triangleq\text{foldLeft}\,(p)(z)(\tilde{u})\quad,\\
 & \text{where we defined}:\quad\tilde{u}^{:B\times A\rightarrow B}\triangleq b^{:B}\times a^{:A}\rightarrow u\left(a\right)(b)\quad.
\end{align*}

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fldl
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 since we only replaced some types with equivalent ones.
 Setting 
\begin_inset Formula $F^{A}\triangleq L^{A}$
\end_inset

, 
\begin_inset Formula $G^{A}\triangleq B\rightarrow B$
\end_inset

, and 
\begin_inset Formula $K^{A}\triangleq B\rightarrow B$
\end_inset

 in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we obtain an equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fldl
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{foldFn}:L^{B\rightarrow B}\rightarrow B\rightarrow B\quad,\quad\quad\text{foldFn}\,(p^{:L^{B\rightarrow B}})\triangleq\text{fldl}\,(\text{id}^{:(B\rightarrow B)\rightarrow B\rightarrow B})(p)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are similar except that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 uses the type 
\begin_inset Formula $B\rightarrow B$
\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 uses an arbitrary monoid 
\begin_inset Formula $M$
\end_inset

 (having an empty value 
\begin_inset Formula $e_{M}$
\end_inset

 and a binary operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

).
 The type of functions 
\begin_inset Formula $B\rightarrow B$
\end_inset

 is itself a monoid that we here denote by 
\begin_inset Formula $\text{MF}^{B}\triangleq B\rightarrow B$
\end_inset

.
 The empty value of that monoid is the identity function (
\begin_inset Formula $e_{_{\text{MF}^{B}}}=\text{id}^{:B\rightarrow B}$
\end_inset

), and the binary operation (
\begin_inset Formula $\ensuremath{\oplus}_{_{\text{MF}^{B}}}$
\end_inset

) is the 
\emph on
forward
\emph default
 function composition: 
\begin_inset Formula 
\[
p^{:B\rightarrow B}\oplus_{_{\text{MF}^{B}}}q^{:B\rightarrow B}\triangleq p\bef q\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To relate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

, we need to map an arbitrary monoid 
\begin_inset Formula $M$
\end_inset

 to the monoid 
\begin_inset Formula $\text{MF}^{M}$
\end_inset

:
\begin_inset Formula 
\[
\text{inMF}:M\rightarrow\text{MF}^{M}\quad,\quad\quad\text{inMF}\left(m\right)\triangleq n^{:M}\rightarrow n\oplus_{M}m\quad.
\]

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is just the monoid 
\begin_inset Formula $M$
\end_inset

's binary operation (
\begin_inset Formula $\oplus_{M}$
\end_inset

) in a flipped and curried form:
\begin_inset Formula 
\[
\text{inMF}:M\rightarrow M\rightarrow M\quad,\quad\quad\text{inMF}\triangleq m\rightarrow n\rightarrow n\oplus_{M}m\quad.
\]

\end_inset

In particular, for any value 
\begin_inset Formula $m^{:M}$
\end_inset

 we have, due to the monoid 
\begin_inset Formula $M$
\end_inset

's identity law: 
\begin_inset Formula 
\begin{equation}
\text{inMF}\,(m)(e_{M})=e_{M}\oplus m=m\quad.\label{eq:identity-law-of-inMF}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is a monoid morphism because the two laws of Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-monoid-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 hold:
\begin_inset Formula 
\begin{align*}
 & \text{inMF}\,(e_{M})=n^{:M}\rightarrow n\oplus_{M}e_{M}=n^{:M}\rightarrow n=\text{id}^{:M\rightarrow M}=e_{_{\text{MF}^{M}}}\quad,\\
 & \text{inMF}\,(x\oplus_{M}y)=n^{:M}\rightarrow n\oplus_{M}x\oplus_{M}y\quad,\\
 & \text{inMF}\left(x\right)\oplus_{_{\text{MF}^{M}}}\text{inMF}\left(y\right)=\text{inMF}\left(x\right)\bef\text{inMF}\left(y\right)=(n\rightarrow n\oplus_{M}x)\bef(n\rightarrow n\oplus_{M}y)\\
 & \quad=n\rightarrow n\oplus_{M}x\oplus_{M}y=\text{inMF}\,(x\oplus_{M}y)\quad.
\end{align*}

\end_inset

So, we may use 
\begin_inset Formula $f\triangleq\text{inMF}$
\end_inset

 in the monoidal naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N\triangleq\text{MF}^{M}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{reduceE}\bef\text{inMF}=\text{inMF}^{\uparrow L}\bef\text{reduceE}\quad.\label{eq:monoidal-naturality-law-of-reduceE-inMF}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Now we can express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 through each other:
\begin_inset Formula 
\begin{align}
 & \text{foldFn}^{B}=\text{reduceE}^{\text{MF}^{B}}\quad\quad\text{where}\quad\quad\text{MF}^{B}\triangleq B\rightarrow B\quad,\label{eq:foldFn-via-reduceE}\\
 & \text{reduceE}\,(p^{:L^{M}})=\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})\quad.\label{eq:reduceE-via-foldFn}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
It remains to demonstrate an isomorphism between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 in both directions.
\end_layout

\begin_layout Standard

\series bold
1)
\series default
 For a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 with the type signature shown above, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{foldFn}^{\prime}(p^{:L^{B\rightarrow B}})=\text{reduceE}\,(p)=\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})\quad.
\end{align*}

\end_inset

Here the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is used with the type signature corresponding to the monoid 
\begin_inset Formula $M\triangleq B\rightarrow B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{inMF}:\left(B\rightarrow B\right)\rightarrow\text{MF}^{B\rightarrow B}\cong\left(B\rightarrow B\right)\rightarrow\left(B\rightarrow B\right)\rightarrow B\rightarrow B\quad,\\
 & \text{inMF}\triangleq g^{:B\rightarrow B}\rightarrow h^{:B\rightarrow B}\rightarrow h\bef g\quad,\quad\quad e_{\text{MF}}\triangleq\text{id}^{:B\rightarrow B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We find that 
\begin_inset Formula $\text{foldFn}^{\prime}(p)=\text{foldFn}\,(p)$
\end_inset

 if the following equation holds:
\begin_inset Formula 
\begin{equation}
\text{foldFn}^{B}(p^{:L^{B\rightarrow B}})=\text{foldFn}^{B\rightarrow B}(p\triangleright\text{inMF}^{\uparrow L})(\text{id}^{:B\rightarrow B})\quad.\label{eq:foldFn-first-special-law}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It remains to prove that the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will hold when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 is defined via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & p^{:L^{M}}\triangleright\text{reduceE}^{M}\bef f^{:M\rightarrow N}=\big(\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})\big)\triangleright f\quad,\\
\text{right-hand side}:\quad & p^{:L^{M}}\triangleright f^{\uparrow L}\bef\text{reduceE}^{N}=\text{foldFn}\,(p\triangleright f^{\uparrow L}\triangleright\text{inMF}^{\uparrow L})(e_{N})\quad.
\end{align*}

\end_inset

The two sides are equal if the following law holds for any 
\begin_inset Formula $p^{:L^{M}}$
\end_inset

 and any monoid morphism 
\begin_inset Formula $f^{:M\rightarrow N}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
e_{M}\triangleright\big(p\triangleright\text{inMF}^{\uparrow L}\triangleright\text{foldFn}\big)\triangleright f=e_{N}\triangleright\big(p\triangleright f^{\uparrow L}\triangleright\text{inMF}^{\uparrow L}\triangleright\text{foldFn}\big)\quad.\label{eq:foldFn-second-special-law}
\end{equation}

\end_inset

Since both laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are assumed to hold, we have demonstrated the equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 in one direction.
\end_layout

\begin_layout Standard

\series bold
2)
\series default
 For a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 with the type signature shown above, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{reduceE}\left(p\right):\quad & \text{reduceE}^{\prime}(p^{:L^{M}})=\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})=\text{reduceE}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{M})\\
\text{rewrite using }\triangleright\text{-notation}:\quad & =e_{M}\triangleright\big(p\triangleright\gunderline{\text{inMF}^{\uparrow L}\bef\text{reduceE}}\big)\\
\text{use Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE-inMF})}:\quad & =e_{M}\triangleright\big(p\triangleright\text{reduceE}\bef\text{inMF}\big)=\gunderline{\text{inMF}}\,(p\triangleright\text{reduceE})\gunderline{(e_{M})}\\
\text{use Eq.~(\ref{eq:identity-law-of-inMF})}:\quad & =p\triangleright\text{reduceE}=\text{reduceE}\,(p)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It remains to prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 defined via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will always satisfy the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To verify that the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{foldFn}^{B}(p):\quad & \text{foldFn}^{B\rightarrow B}(p^{:L^{B\rightarrow B}}\triangleright\text{inMF}^{\uparrow L})(e_{\text{MF}})=\text{reduceE}\,(p\triangleright\text{inMF}^{\uparrow L})(e_{\text{MF}})\\
 & =e_{\text{MF}}\triangleright(p\triangleright\gunderline{\text{inMF}^{\uparrow L}\bef\text{reduceE}})\\
\text{use Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE-inMF})}:\quad & =e_{\text{MF}}\triangleright\big(p\triangleright\text{reduceE}\bef\text{inMF}\big)=\gunderline{\text{inMF}}\,(p\triangleright\text{reduceE})\gunderline{(e_{\text{MF}})}\\
\text{use Eq.~(\ref{eq:identity-law-of-inMF})}:\quad & =p\triangleright\text{reduceE}=\text{reduceE}^{B\rightarrow B}(p)=\text{foldFn}^{B}(p)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), write the two sides separately and substitute Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & e_{M}\triangleright\big(p\triangleright\gunderline{\text{inMF}^{\uparrow L}\triangleright\text{foldFn}}\big)\triangleright f=e_{M}\triangleright(p\triangleright\gunderline{\text{inMF}^{\uparrow L}\bef\text{reduceE}}\big)\triangleright f\\
\text{use Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE-inMF})}:\quad & \quad=e_{M}\triangleright\big(p\triangleright\text{reduceE}\bef\text{inMF}\big)\triangleright f=\big(\gunderline{\text{inMF}}\,(p\triangleright\text{reduceE})\gunderline{(e_{M})}\big)\triangleright f\\
\text{use Eq.~(\ref{eq:identity-law-of-inMF})}:\quad & \quad=p\triangleright\text{reduceE}\triangleright f\quad,\\
\text{right-hand side}:\quad & e_{N}\triangleright\big(p\triangleright\gunderline{f^{\uparrow L}\triangleright\text{inMF}^{\uparrow L}\triangleright\text{foldFn}}\big)=e_{N}\triangleright\big(p\triangleright f^{\uparrow L}\bef\gunderline{\text{inMF}^{\uparrow L}\bef\text{reduceE}}\big)\\
\text{use Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE-inMF})}:\quad & \quad=e_{N}\triangleright\big(p\triangleright\gunderline{f^{\uparrow L}\bef\text{reduceE}}\bef\text{inMF}\big)\\
\text{use Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE})}:\quad & \quad=e_{N}\triangleright\big(p\triangleright\text{reduceE}\bef f\bef\text{inMF}\big)=\gunderline{\text{inMF}}\,\big(p\triangleright\text{reduceE}\bef f\big)\gunderline{(e_{N})}\\
\text{use Eq.~(\ref{eq:identity-law-of-inMF})}:\quad & \quad=p\triangleright\text{reduceE}\triangleright f\quad.
\end{align*}

\end_inset

The two sides are now equal.
\end_layout

\begin_layout Standard
This proves that the equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 holds also in the other direction.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Let us comment on the special laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The next statement will show that those laws follow from parametricity.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn(p)
\end_layout

\end_inset

 uses any functions of type 
\begin_inset Formula $B\rightarrow B$
\end_inset

 contained in 
\begin_inset Formula $p:L^{B\rightarrow B}$
\end_inset

 in a fully parametric manner, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 cannot inspect the type 
\begin_inset Formula $B$
\end_inset

 or the code of the functions of type 
\begin_inset Formula $B\rightarrow B$
\end_inset

.
 The only way of using those functions is to compose them with each other
 in some order, obtaining again a function of type 
\begin_inset Formula $B\rightarrow B$
\end_inset

.
 The laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) express this property in different ways by writing the function composition
 explicitly as part of the code of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:relational-property-for-foldFn"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:relational-property-for-foldFn"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Denote for brevity 
\begin_inset Formula $E^{A}\triangleq A\rightarrow A$
\end_inset

.
 Let 
\begin_inset Formula $L$
\end_inset

 be any 
\emph on
polynomial
\emph default
 functor.
 (This restriction is acceptable because, as we will see below, only polynomial
 functors are traversable.)
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Any fully parametric function 
\begin_inset Formula $\phi:\forall A.\,L^{E^{A}}\rightarrow E^{A}$
\end_inset

 satisfies the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-first-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
 & \phi\,(p^{:L^{E^{A}}})=\phi\,(p\triangleright\text{inF}^{\uparrow L})(\text{id}^{:A\rightarrow A})\quad,\label{eq:first-special-law-of-phi}\\
\text{where we defined}:\quad & \quad\text{inF}:E^{A}\rightarrow E^{A}\rightarrow E^{A}\quad,\quad\quad\text{inF}\triangleq h^{:A\rightarrow A}\rightarrow k^{:A\rightarrow A}\rightarrow k\bef h\quad.\nonumber 
\end{align}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Any fully parametric function 
\begin_inset Formula $\text{foldFn}:\forall A.\,L^{E^{A}}\rightarrow E^{A}$
\end_inset

 satisfies Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-strong-dinaturality-proof-of-foldFn-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:Proofs-of-naturality-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows that 
\begin_inset Formula $\phi$
\end_inset

 satisfies the strong dinaturality law.
 The law says that 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Begin by formulating the relational naturality law of 
\begin_inset Formula $\phi$
\end_inset

: for all 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
\text{if }(x^{:L^{A\rightarrow A}},y^{:L^{B\rightarrow B}})\in r^{\updownarrow(L\circ E)}\text{ then }(\phi(x),\phi(y))\in r^{\updownarrow E}\quad.
\]

\end_inset

In order to use this law to derive Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:first-special-law-of-phi"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to choose a specific relation 
\begin_inset Formula $r$
\end_inset

 and specific types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 Note that the value 
\begin_inset Formula $p\triangleright\text{inMF}^{\uparrow L}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:first-special-law-of-phi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) has type 
\begin_inset Formula $L^{E^{A}\rightarrow E^{A}}$
\end_inset

.
 So, the only hope of using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-law-of-g"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is by choosing the type 
\begin_inset Formula $B$
\end_inset

 as 
\begin_inset Formula $B\triangleq E^{A}=A\rightarrow A$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
It remains to choose a suitable relation 
\begin_inset Formula $r$
\end_inset

 between the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B\triangleq A\rightarrow A$
\end_inset

.
 In Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-law-of-g"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the relation 
\begin_inset Formula $r$
\end_inset

 is being lifted to the functor 
\begin_inset Formula $L\circ E$
\end_inset

, which is equivalent to the lifting 
\begin_inset Formula $(r^{\updownarrow E})^{\updownarrow L}$
\end_inset

.
 Since 
\begin_inset Formula $L$
\end_inset

 is an unknown functor, we do not have a general formula for lifting an
 arbitrary relation 
\begin_inset Formula $r$
\end_inset

 to 
\begin_inset Formula $L\circ E$
\end_inset

.
 However, we do have a formula for lifting a relation 
\begin_inset Formula $r^{:A\leftrightarrow B}$
\end_inset

 that comes from a function (either of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or of type 
\begin_inset Formula $B\rightarrow A$
\end_inset

).
 For instance, given a function 
\begin_inset Formula $f:B\rightarrow A$
\end_inset

, we define 
\begin_inset Formula $r\triangleq\text{rev}\left<f\right>$
\end_inset

.
 First we lift 
\begin_inset Formula $\left<f\right>^{\updownarrow E}$
\end_inset

 as:
\begin_inset Formula 
\[
(g^{:B\rightarrow B},h^{:A\rightarrow A})\in\left<f\right>^{\updownarrow E}\text{ means }g\bef f=f\bef h\quad.
\]

\end_inset

This is a relation of pullback form:
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow E}=\text{pull}\,\big(g^{:B\rightarrow B}\rightarrow g\bef f,\quad h^{:A\rightarrow A}\rightarrow f\bef h\big)\quad.
\]

\end_inset

A pullback relation can then be lifted to a functor 
\begin_inset Formula $L$
\end_inset

 as shown in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pullback-as-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
\left<f\right>^{\updownarrow E\updownarrow L}=\text{pull}\,\big((g^{:B\rightarrow B}\rightarrow g\bef f)^{\uparrow L},\quad(h^{:A\rightarrow A}\rightarrow f\bef h)^{\uparrow L}\big)\quad.
\]

\end_inset

We can now rewrite Eq.
\begin_inset space ~
\end_inset

 in the form of a chain of pullback relations: 
\end_layout

\end_inset

for any 
\begin_inset Formula $f^{:B\rightarrow A}$
\end_inset

, 
\begin_inset Formula $x^{:L^{A\rightarrow A}}$
\end_inset

, and 
\begin_inset Formula $y^{:L^{B\rightarrow B}}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{if }x\triangleright(h^{:A\rightarrow A}\rightarrow f\bef h)^{\uparrow L}=y\triangleright(g^{:B\rightarrow B}\rightarrow g\bef f)^{\uparrow L}\quad\text{then}\quad f\bef\phi(x)=\phi(y)\bef f\quad.\label{eq:strong-dinaturality-law-of-phi-with-f}
\end{equation}

\end_inset

We need to choose 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, and 
\begin_inset Formula $f$
\end_inset

 appropriately in order to be able to derive Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:first-special-law-of-phi"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 After some guessing and trying, one finds that a good choice is 
\begin_inset Formula $B\triangleq A\rightarrow A$
\end_inset

 and 
\begin_inset Formula $f^{:B\rightarrow A}$
\end_inset

 defined by:
\begin_inset Formula 
\begin{equation}
f:(A\rightarrow A)\rightarrow A\quad,\quad\quad f\triangleq k^{:A\rightarrow A}\rightarrow k(a_{0})\quad\text{with a fixed }a_{0}:A\quad.\label{eq:f-for-relational-law-of-foldFn-derivation1}
\end{equation}

\end_inset

Each value 
\begin_inset Formula $a_{0}$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

 gives us a function 
\begin_inset Formula $f_{a_{0}}:(A\rightarrow A)\rightarrow A$
\end_inset

 for which the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds.
 
\end_layout

\begin_layout Standard
We will now show that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:first-special-law-of-phi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) follows from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with this choice of 
\begin_inset Formula $f$
\end_inset

.
 The value 
\begin_inset Formula $a_{0}$
\end_inset

 will be held fixed throughout most of this proof, so we will write just
 
\begin_inset Formula $f$
\end_inset

 instead of 
\begin_inset Formula $f_{a_{0}}$
\end_inset

.
\end_layout

\begin_layout Standard
In order to use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with this choice of 
\begin_inset Formula $f$
\end_inset

, we need to find suitable values 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
 Note that the conclusion of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) relates 
\begin_inset Formula $\phi(x)$
\end_inset

 with 
\begin_inset Formula $\phi(y)$
\end_inset

, while Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:first-special-law-of-phi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) requires us to relate 
\begin_inset Formula $\phi(p)$
\end_inset

 with 
\begin_inset Formula $\phi(p\triangleright\text{inF}^{\uparrow L})$
\end_inset

.
 So, we must choose 
\begin_inset Formula $x=p$
\end_inset

 and 
\begin_inset Formula $y=p\triangleright\text{inF}^{\uparrow L}$
\end_inset

.
 This choice would work with Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) only if its precondition is satisfied with these 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 and with 
\begin_inset Formula $f$
\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-for-relational-law-of-foldFn-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & p\triangleright(h^{:A\rightarrow A}\rightarrow f\bef h)^{\uparrow L}\overset{?}{=}y\triangleright(g^{:B\rightarrow B}\rightarrow g\bef f)^{\uparrow L}=p\triangleright\text{inF}^{\uparrow L}\triangleright(g^{:B\rightarrow B}\rightarrow g\bef f)^{\uparrow L}\\
 & \quad=p\triangleright\big(\text{inF}\bef(g^{:B\rightarrow B}\rightarrow g\bef f)\big)^{\uparrow L}\quad.
\end{align*}

\end_inset

We will show that this equation holds for any 
\begin_inset Formula $p:L^{A\rightarrow A}$
\end_inset

 if we show that:
\begin_inset Formula 
\[
h^{:A\rightarrow A}\rightarrow f\bef h\overset{?}{=}\text{inF}\bef(g^{:B\rightarrow B}\rightarrow g\bef f)\quad.
\]

\end_inset

We simplify separately each side of this equation and find that they are
 equal:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & h^{:A\rightarrow A}\rightarrow f\bef h=h\rightarrow(k\rightarrow\gunderline{k(a_{0}))\bef h}=h\rightarrow k\rightarrow h(k(a_{0}))\quad,\\
\text{right-hand side}:\quad & \gunderline{\text{inF}}\bef(g^{:B\rightarrow B}\rightarrow g\bef\gunderline f)=(h\rightarrow k\rightarrow k\bef h)\bef(g\rightarrow g\bef(k\rightarrow k(a_{0}))\\
\text{compute composition}:\quad & \quad=h\rightarrow(k\rightarrow k\bef h)\bef(k\rightarrow k(a_{0}))=h\rightarrow k\rightarrow\gunderline{(k\bef h)(a_{0})}\\
 & \quad=h\rightarrow k\rightarrow h(k(a_{0})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Since the precondition of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is satisfied, its conclusion holds too:
\begin_inset Formula 
\begin{align*}
 & f\bef\phi(x)\overset{!}{=}\phi(y)\bef f\quad,\\
\text{equivalently}:\quad & (k^{:A\rightarrow A}\rightarrow k(a_{0}))\bef\phi(p)\overset{!}{=}\phi(p\triangleright\text{inF}^{\uparrow L})\bef(k^{:A\rightarrow A}\rightarrow k(a_{0}))\quad,\\
\text{equivalently}:\quad & k^{:A\rightarrow A}\rightarrow\phi(p)(k(a_{0}))\overset{!}{=}k^{:A\rightarrow A}\rightarrow\phi(p\triangleright\text{inF}^{\uparrow L})(k)(a_{0})\quad.
\end{align*}

\end_inset

The last equation can be applied to any function 
\begin_inset Formula $k$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
\phi(p)(k(a_{0}))\overset{!}{=}\phi(p\triangleright\text{inF}^{\uparrow L})(k)(a_{0})\quad.
\]

\end_inset

In Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:first-special-law-of-phi"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the function 
\begin_inset Formula $\phi(p\triangleright\text{inF}^{\uparrow L})$
\end_inset

 is applied to the identity function of type 
\begin_inset Formula $A\rightarrow A$
\end_inset

.
 So, we set 
\begin_inset Formula $k\triangleq\text{id}$
\end_inset

 in the line above:
\begin_inset Formula 
\[
\phi(p)(a_{0})\overset{!}{=}\phi(p\triangleright\text{inF}^{\uparrow L})(\text{id})(a_{0})\quad.
\]

\end_inset

Since this holds for any 
\begin_inset Formula $a_{0}$
\end_inset

, we get 
\begin_inset Formula $\phi(p)\overset{!}{=}\phi(p\triangleright\text{inF}^{\uparrow L})(\text{id})$
\end_inset

, which proves Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:first-special-law-of-phi"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We already showed in part 
\series bold
(a)
\series default
 that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldFn
\end_layout

\end_inset

 
\begin_inset Formula $=\phi$
\end_inset

 satisfies Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We will now show that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) follows if we apply Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $x$
\end_inset

, and 
\begin_inset Formula $y$
\end_inset

 chosen as:
\begin_inset Formula 
\[
A\triangleq N\quad,\quad\quad B\triangleq M\quad,\quad\quad x^{:L^{N\rightarrow N}}\triangleq p\triangleright f^{\uparrow L}\triangleright\text{inMF}^{\uparrow L}\quad,\quad\quad y^{:L^{M\rightarrow M}}\triangleq p\triangleright\text{inMF}^{\uparrow L}\quad.
\]

\end_inset

Before we can use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to verify that its precondition is satisfied:
\begin_inset Formula 
\[
x\triangleright(h\rightarrow f\bef h)^{\uparrow L}=p\triangleright\big(f\bef\text{inMF}\bef(h\rightarrow f\bef h)\big)^{\uparrow L}\overset{?}{=}y\triangleright(g\rightarrow g\bef f)^{\uparrow L}=p\triangleright\big(\text{inMF}\bef(g\rightarrow g\bef f)\big)^{\uparrow L}\quad.
\]

\end_inset

To show that this equation holds, we compare separately the lifted functions
 that are applied to 
\begin_inset Formula $p$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f\bef\text{inMF}\bef(h\rightarrow f\bef h)=\big(m^{:M}\rightarrow n^{:N}\rightarrow n\oplus_{N}f(m)\big)\bef(h\rightarrow f\bef h)=m^{:M}\rightarrow l^{:M}\rightarrow f(l)\oplus_{N}f(m)\quad,\\
 & \text{inMF}\bef(g\rightarrow g\bef f)=(m^{:M}\rightarrow l^{:M}\rightarrow l\oplus_{M}m)\bef(g\rightarrow g\bef f)=m^{:M}\rightarrow l^{:M}\rightarrow f(l\oplus_{M}m)\quad.
\end{align*}

\end_inset

The two functions are equal because of the composition law of the monoid
 morphism 
\begin_inset Formula $f$
\end_inset

.
 So, the precondition of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law-of-phi-with-f"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds, and we may use its conclusion:
\begin_inset Formula 
\[
f\bef\text{foldFn}\,(x)\overset{!}{=}\text{foldFn}(y)\bef f\quad\text{or equivalently:}\quad\text{foldFn}\,(p\triangleright\text{inMF}^{\uparrow L})\bef f=f\bef\text{foldFn}(p\triangleright f^{\uparrow L}\bef\text{inMF}^{\uparrow L}).
\]

\end_inset

This gives the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:foldFn-second-special-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) if we use 
\begin_inset Formula $f$
\end_inset

's monoid morphism identity law: 
\begin_inset Formula $e_{M}\triangleright f=e_{N}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-reduceE-toList-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-reduceE-toList-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 are equivalent if expressed through each other as:
\begin_inset Formula 
\begin{align}
 & \text{toList}:L^{A}\rightarrow\text{List}^{A}\quad,\quad\quad\text{toList}=\text{pu}_{\text{List}}^{\uparrow L}\bef\text{reduceE}^{\text{List}^{A}}\quad,\label{eq:toList-via-reduceE}\\
 & \text{reduceE}:L^{M}\rightarrow M\quad,\quad\quad\text{reduceE}=\text{toList}\bef\text{reduceList}\quad,\label{eq:reduceE-via-toList}
\end{align}

\end_inset

assuming the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 and the monoidal naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

.
 Here the function 
\begin_inset Formula $\text{reduceE}^{\text{List}^{A}}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 applied to the monoidal type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 whose binary operation is the list concatenation.
 The monoidally natural function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList[M]
\end_layout

\end_inset

 is defined for monoids 
\begin_inset Formula $M$
\end_inset

 by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduceList[M: Monoid]: List[M] => M = {
\end_layout

\begin_layout Plain Layout

  case Nil            => Monoid[M].empty
\end_layout

\begin_layout Plain Layout

  case head :: tail   => head |+| reduceList(tail)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{reduceList}^{M}:\text{List}^{M}\rightarrow M\quad,\quad\quad\text{reduceList}\triangleq\,\begin{array}{|c||c|}
 & M\\
\hline \bbnum 1 & \_\rightarrow e_{M}\\
M\times\text{List}^{M} & h^{:M}\times t^{:\text{List}^{M}}\rightarrow h\oplus_{M}\overline{\text{reduceList}}\left(t\right)
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We begin by showing that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList
\end_layout

\end_inset

 obeys the monoidal naturality law:
\begin_inset Formula 
\[
f^{\uparrow\text{List}}\bef\text{reduceList}=\text{reduceList}\bef f\quad.
\]

\end_inset

This law assumes that 
\begin_inset Formula $f^{:M\rightarrow N}$
\end_inset

 is a monoid morphism between two monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 
\end_layout

\begin_layout Standard
Simplify the left-hand side of the law:
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow\text{List}}\bef\text{reduceList}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & N\times\text{List}^{N}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
M\times\text{List}^{M} & \bbnum 0 & f\boxtimes f^{\uparrow\text{List}}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & N\\
\hline \bbnum 1 & \_\rightarrow e_{N}\\
N\times\text{List}^{N} & h\times t\rightarrow h\oplus_{N}(t\triangleright\overline{\text{reduceList}})
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & N\\
\hline \bbnum 1 & \_\rightarrow e_{N}\\
M\times\text{List}^{M} & h\times t\rightarrow f(h)\oplus_{N}(t\triangleright f^{\uparrow\text{List}}\bef\overline{\text{reduceList}})
\end{array}\quad.
\end{align*}

\end_inset

We can use the inductive assumption that recursive calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList
\end_layout

\end_inset

 already obey the monoidal naturality law.
 So, we can simplify:
\begin_inset Formula 
\[
t\triangleright f^{\uparrow\text{List}}\bef\overline{\text{reduceList}}=t\triangleright\overline{\text{reduceList}}\bef f=f(\overline{\text{reduceList}}\left(t\right))\quad.
\]

\end_inset

The bottom-row expression in the last matrix is then rewritten to:
\begin_inset Formula 
\begin{align*}
 & f(h)\oplus_{N}(t\triangleright f^{\uparrow\text{List}}\bef\overline{\text{reduceList}})=f(h)\oplus_{N}f(\overline{\text{reduceList}}\left(t\right))\\
\text{monad morphism law}:\quad & =f\big(h\oplus_{M}\overline{\text{reduceList}}\left(t\right)\big)\quad.
\end{align*}

\end_inset

Using the monad morphism identity law (
\begin_inset Formula $f(e_{M})=e_{N}$
\end_inset

), we find:
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow\text{List}}\bef\text{reduceList}=\,\begin{array}{|c||c|}
 & N\\
\hline \bbnum 1 & \_\rightarrow f(e_{M})\\
M\times\text{List}^{M} & h\times t\rightarrow f\big(h\oplus_{M}\overline{\text{reduceList}}\left(t\right)\big)
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & N\\
\hline \bbnum 1 & \_\rightarrow e_{M}\\
M\times\text{List}^{M} & h\times t\rightarrow h\oplus_{M}\overline{\text{reduceList}}\left(t\right)
\end{array}\bef f=\text{reduceList}\bef f\quad.
\end{align*}

\end_inset

 This is equal to the right-hand side of the law.
\end_layout

\begin_layout Standard
We are now ready to show the isomorphism between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 in both directions:
\end_layout

\begin_layout Standard

\series bold
(1)
\series default
 Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 that satisfies Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

), define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:toList-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-toList"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

, we write:
\begin_inset Formula 
\begin{align*}
 & \text{reduceE}^{\prime}=\text{toList}\bef\text{reduceList}=\gunderline{\text{pu}_{\text{List}}^{\uparrow L}\bef\text{reduceE}^{\text{List}^{M}}}\bef\text{reduceList}\\
\text{Eq.~(\ref{eq:monoidal-naturality-law-of-reduceE}) with }N\triangleq\text{List}^{A}:\quad & =\text{reduceE}^{M}\bef\text{pu}_{\text{List}}\bef\text{reduceList}\quad.
\end{align*}

\end_inset

It remains to show that the composition 
\begin_inset Formula $\text{pu}_{\text{List}}\bef\text{reduceList}$
\end_inset

 is equal to the identity function:
\begin_inset Formula 
\[
\text{pu}_{\text{List}}\bef\text{reduceList}=\text{id}^{:M\rightarrow M}\quad.
\]

\end_inset

We use the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList[M]
\end_layout

\end_inset

 and simplify the matrix composition:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{\text{List}}\bef\text{reduceList}=(m^{:M}\rightarrow\bbnum 0+m\times\left[\right])\bef\text{reduceList}\\
 & =\,\begin{array}{|c||cc|}
 & \bbnum 1 & M\times\text{List}^{M}\\
\hline M & \bbnum 0 & m\rightarrow m\times\left[\right]
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M\\
\hline \bbnum 1 & \_\rightarrow e_{M}\\
M\times\text{List}^{M} & h\times t\rightarrow h\oplus_{M}\overline{\text{reduceList}}\left(t\right)
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & M\\
\hline M & m\rightarrow m\oplus_{M}\gunderline{\overline{\text{reduceList}}\left(\left[\right]\right)}
\end{array}\,=m\rightarrow\gunderline{m\oplus e_{M}}=m\rightarrow m=\text{id}\quad.
\end{align*}

\end_inset

In the last line, we used the fact that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList[M]
\end_layout

\end_inset

 applied to an empty list gives 
\begin_inset Formula $e_{M}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(2)
\series default
 Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

, define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-toList"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then define a new function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:toList-via-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

, we write:
\begin_inset Formula 
\begin{align*}
 & \text{toList}^{\prime}=\text{pu}_{\text{List}}^{\uparrow L}\bef\text{reduceE}^{\text{List}^{A}}=\gunderline{\text{pu}_{\text{List}}^{\uparrow L}\bef\text{toList}}\bef\text{reduceList}^{\text{List}^{A}}\\
\text{naturality of }\text{toList}:\quad & =\text{toList}\bef\text{pu}_{\text{List}}^{\uparrow\text{List}}\bef\text{reduceList}^{\text{List}^{A}}\quad.
\end{align*}

\end_inset

It remains to show that the composition 
\begin_inset Formula $\text{pu}_{\text{List}}^{\uparrow\text{List}}\bef\text{reduceList}$
\end_inset

 is equal to the identity function:
\begin_inset Formula 
\begin{equation}
\text{pu}_{\text{List}}^{\uparrow\text{List}}\bef\text{reduceList}=\text{id}^{:\text{List}^{M}\rightarrow\text{List}^{M}}\quad.\label{eq:identity-for-reduceList-and-pure}
\end{equation}

\end_inset

We use the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList[M]
\end_layout

\end_inset

 and set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

 to the monoid type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{\text{List}}^{\uparrow\text{List}}\bef\text{reduceList}^{\text{List}^{A}}\\
 & =\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{List}^{M}\times\text{List}^{\text{List}^{M}}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
M\times\text{List}^{M} & \bbnum 0 & h\times t\rightarrow\text{pu}_{\text{List}}(h)\times(t\triangleright\text{pu}_{\text{List}}^{\uparrow\text{List}})
\end{array}\,\bef\,\begin{array}{|c||c|}
 & \text{List}^{M}\\
\hline \bbnum 1 & \_\rightarrow1+\bbnum 0\\
\text{List}^{M}\times\text{List}^{\text{List}^{M}} & h\times t\rightarrow h\pplus\overline{\text{reduceList}}\left(t\right)
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & \text{List}^{M}\\
\hline \bbnum 1 & \_\rightarrow1+\bbnum 0\\
M\times\text{List}^{M} & h\times t\rightarrow\text{pu}_{\text{List}}(h)\pplus(t\triangleright\text{pu}_{\text{List}}^{\uparrow\text{List}}\triangleright\overline{\text{reduceList}})
\end{array}\quad.
\end{align*}

\end_inset

By the inductive assumption, a recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceList
\end_layout

\end_inset

 already satisfies Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-for-reduceList-and-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
t\triangleright\gunderline{\text{pu}_{\text{List}}^{\uparrow\text{List}}\triangleright\overline{\text{reduceList}}}=t\triangleright\text{id}=t\quad.
\]

\end_inset

We can now simplify the code and obtain the identity function:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{\text{List}}^{\uparrow\text{List}}\bef\text{reduceList}^{\text{List}^{A}}=\,\begin{array}{|c||c|}
 & \text{List}^{M}\\
\hline \bbnum 1 & \_\rightarrow1+\bbnum 0\\
M\times\text{List}^{M} & h^{:M}\times t^{:\text{List}^{M}}\rightarrow\text{pu}_{\text{List}}(h)\pplus t
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & \text{List}^{M}\\
\hline \bbnum 1 & \_\rightarrow1+\bbnum 0\\
M\times\text{List}^{M} & h^{:M}\times t^{:\text{List}^{M}}\rightarrow\bbnum 0+h\times t
\end{array}\,=\,\begin{array}{|c||cc|}
 & \bbnum 1 & M\times\text{List}^{M}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
M\times\text{List}^{M} & \bbnum 0 & h^{:M}\times t^{:\text{List}^{M}}\rightarrow h\times t
\end{array}\\
 & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It remains to prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 will satisfy the monoidal naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

) when defined via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:reduceE-via-toList"
plural "false"
caps "false"
noprefix "false"

\end_inset

) through any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 function.
 For any monoid morphism 
\begin_inset Formula $f:M\rightarrow N$
\end_inset

 between arbitrary monoids 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, we write the two sides of the monoidal naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monoidal-naturality-law-of-reduceE"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{reduceE}\bef f=\text{toList}\bef\gunderline{\text{reduceList}\bef f}\\
\text{monoidal naturality of }\text{reduceList}:\quad & \quad=\gunderline{\text{toList}\bef f^{\uparrow\text{List}}}\bef\text{reduceList}\\
\text{naturality of }\text{toList}:\quad & \quad=f^{\uparrow L}\bef\text{toList}\bef\text{reduceList}\quad,\\
\text{right-hand side}:\quad & f^{\uparrow L}\bef\text{reduceE}=f^{\uparrow L}\bef\text{toList}\bef\text{reduceList}\quad.
\end{align*}

\end_inset

The two sides are now equal.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsection
The missing laws of 
\family typewriter
foldMap
\family default
 and 
\family typewriter
reduce
\end_layout

\begin_layout Standard
The equivalence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 is ensured by assuming various naturality laws.
 However, those naturality laws do not fully describe the programmer's expectati
ons about the behavior of folding operations.
 
\end_layout

\begin_layout Standard
To see why, let us consider 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $L^{A}\rightarrow\text{List}^{A}$
\end_inset

.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 is fully parametric, it will satisfy the naturality law:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow L}\bef\text{toList }=\text{toList}\bef f^{\uparrow\text{List}}\quad.
\]

\end_inset

This law describes the property that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList[A]
\end_layout

\end_inset

 works in the same way for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Certainly, programmers expect this property to hold.
 But the main intent of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 is to extract values of type 
\begin_inset Formula $A$
\end_inset

 out of 
\begin_inset Formula $L^{A}$
\end_inset

 and store them in a list.
 Naturality laws do not express this intent.
\end_layout

\begin_layout Standard
More precisely, programmers expect that for any 
\begin_inset Quotes eld
\end_inset

container
\begin_inset Quotes erd
\end_inset

 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList(p)
\end_layout

\end_inset

 should be a list of 
\emph on
all
\emph default
 values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 stored in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 As an example of unexpected behavior, imagine implementing the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 by a function that always returns an empty list.
 For 
\begin_inset Quotes eld
\end_inset

containers
\begin_inset Quotes erd
\end_inset

 that store some values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, this implementation (although it is fully parametric) would be unacceptable
 since it loses information: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList(x)
\end_layout

\end_inset

 always ignores its argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To prohibit such implementations, we would like to impose a law that holds
 only when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 extracts every value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 stored in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 Unfortunately, it seems to be impossible to express this property in the
 form of an equation satisfied by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

.
 Often, a loss of information is prevented by imposing an identity law.
 Can we formulate an identity law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

? Such a law could state that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList(p)
\end_layout

\end_inset

 should extract some known values contained in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 If 
\begin_inset Formula $L$
\end_inset

 were a pointed functor
\begin_inset Index idx
status open

\begin_layout Plain Layout
pointed functor
\end_layout

\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-functors-motivation-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we could use its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method to inject a known value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 into the container 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 and then require 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 to extract the same value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 But the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 does not require the functor 
\begin_inset Formula $L$
\end_inset

 to be pointed.
 So, in general we cannot inject values into 
\begin_inset Formula $L^{A}$
\end_inset

 in a way that is guaranteed to preserve information.
 This prevents us from formulating an identity law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Another approach to finding laws is to look for type signatures in the form
 of a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 that transforms a function of one type into a function of another type.
 We have summarized the methods of several standard typeclasses as 
\begin_inset Quotes eld
\end_inset

liftings
\begin_inset Quotes erd
\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-pattern-of-functorial-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The laws of a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 are the functor laws (identity and composition).
 Could we apply this approach to the folding operations? The type signature
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 function is:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
foldMap
\family default
 function
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{foldMap}:\left(A\rightarrow M\right)\rightarrow L^{A}\rightarrow M\quad.
\]

\end_inset

This resembles a 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 from functions of type 
\begin_inset Formula $A\rightarrow M$
\end_inset

 to functions of type 
\begin_inset Formula $L^{A}\rightarrow M$
\end_inset

.
 However, it is not possible to impose the functor laws on those liftings.
 For instance, the functor composition law involves applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 to a composition of arguments.
 But the type signature 
\begin_inset Formula $A\rightarrow M$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

 is a fixed type) does not support composition since we cannot compose 
\begin_inset Formula $A\rightarrow M$
\end_inset

 with 
\begin_inset Formula $B\rightarrow M$
\end_inset

.
\end_layout

\begin_layout Standard
So, the 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 approach also fails to yield a suitable law for folding operations.
 However, we will see below that lifting-like laws may be imposed on the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation, whose type signature is a generalization of that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

.
 We will show that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 forbid information-losing implementations.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 can be derived from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, we may take the position that the only acceptable implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 are those derived from a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Subsection
All polynomial functors are foldable
\end_layout

\begin_layout Standard
It turns out that the lack of available laws does not prevent us from finding
 correct implementations of folding operations.
 The reason is that folding operations are available only for polynomial
 functors, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 (note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 is a 
\emph on
recursively
\emph default
 
\emph on
defined
\emph default
 polynomial functor
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functor!recursive
\end_layout

\end_inset

).
 Those functors represent data structures that store a finite number of
 values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 It is clear what it means to extract 
\begin_inset Quotes eld
\end_inset

all values of type 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 from such data structures.
 To show that all polynomial functors are foldable, we will define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 inductively via structural analysis of functor types.
 The definition will ensure that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 correctly extracts the values stored by a given data structure.
\end_layout

\begin_layout Standard
Let us first show that non-polynomial functors are 
\emph on
not
\emph default
 foldable.
 An example of a non-polynomial functor is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad:
\begin_inset Formula 
\[
\text{Reader}^{R,A}\triangleq R\rightarrow A\quad,
\]

\end_inset

where 
\begin_inset Formula $R$
\end_inset

 is a fixed but arbitrarily chosen type.
 A value 
\begin_inset Formula $p$
\end_inset

 of type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 can be viewed as a container that stores one value of type 
\begin_inset Formula $A$
\end_inset

 for each value of type 
\begin_inset Formula $R$
\end_inset

.
 We can extract all values of type 
\begin_inset Formula $A$
\end_inset

 from 
\begin_inset Formula $p$
\end_inset

 only if we can enumerate all possible values of type 
\begin_inset Formula $R$
\end_inset

.
 In general, it is not practical to enumerate all values of a given type
 (as an example, consider the type 
\begin_inset Formula $R\triangleq\text{String}\rightarrow\text{String}$
\end_inset

).
 So, we will not be able to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 type.
 The only exceptions are types 
\begin_inset Formula $R$
\end_inset

 that have a known finite set of distinct values, such as 
\begin_inset Formula $R=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

.
 However, in those cases the type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 is equivalent to a polynomial functor:
\begin_inset Formula 
\[
\text{Reader}^{\text{Boolean},A}=\bbnum 2\rightarrow A\cong A\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We are now ready to show that all polynomial functors are foldable.
 It is convenient to use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 operation to define the 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
foldable functor
\end_layout

\end_inset

foldable functor
\begin_inset Quotes erd
\end_inset

 typeclass:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Foldable[L[_]] {
\end_layout

\begin_layout Plain Layout

  def toList[A]: L[A] => List[A]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Other folding operations (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

) can be derived from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Equivalence-of-foldLeft,foldMap,reduce,and-toList"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Polynomial functors are built via the five standard type constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-notation-and-standard-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 without the function types).
 Defining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 for these constructions will provide an implementation of folding operations
 for all polynomial functors.
\end_layout

\begin_layout Paragraph
Fixed type
\end_layout

\begin_layout Standard
Constant functors 
\begin_inset Formula $L^{A}\triangleq Z$
\end_inset

, where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type, are viewed as containers that are always empty and cannot
 store any values of type 
\begin_inset Formula $A$
\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 for 
\begin_inset Formula $L$
\end_inset

 always returns an empty list.
\end_layout

\begin_layout Paragraph
Type parameter
\end_layout

\begin_layout Standard
The identity functor 
\begin_inset Formula $L^{A}\triangleq A$
\end_inset

 is viewed as a container holding a single value of type 
\begin_inset Formula $A$
\end_inset

.
 So, we simply define 
\begin_inset Formula $\text{toList}\triangleq\text{id}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are foldable functors that support 
\begin_inset Formula $\text{toList}_{K}$
\end_inset

 and 
\begin_inset Formula $\text{toList}_{L}$
\end_inset

, we define the product 
\begin_inset Formula $M^{A}\triangleq K^{A}\times L^{A}$
\end_inset

 and the corresponding function 
\begin_inset Formula $\text{toList}_{M}$
\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList_M[A]: ((K[A], L[A])) => List[A] = { case (p, q) => toList_K(p)
 ++ toList_L(q) }
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{toList}_{M}:K^{A}\times L^{A}\rightarrow\text{List}^{A}\quad,\quad\quad\text{toList}_{M}\triangleq p^{:K^{A}}\times q^{:L^{A}}\rightarrow\text{toList}_{K}(p)\,\pplus\,\text{toList}_{L}(q)\quad.
\]

\end_inset

This implementation contains an arbitrary choice: the values stored in 
\begin_inset Formula $p$
\end_inset

 are listed before the values stored in 
\begin_inset Formula $q$
\end_inset

.
 We could equally well write 
\begin_inset Formula $\text{toList}_{L}(q)\,\pplus\,\text{toList}_{K}(p)$
\end_inset

 in the function body.
 This arbitrary choice corresponds to the arbitrariness of the order in
 which a folding operation may traverse the values stored in a container.
 Different instances of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Foldable
\end_layout

\end_inset

 typeclass may define different traversal orders, as we have seen in the
 code examples earlier in this chapter.
\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are foldable functors, we define the co-product 
\begin_inset Formula $M^{A}\triangleq K^{A}+L^{A}$
\end_inset

 and the corresponding function 
\begin_inset Formula $\text{toList}_{M}:K^{A}+L^{A}\rightarrow\text{List}^{A}$
\end_inset

 as:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "60col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList_M[A]: Either[K[A], L[A]] => List[A] = {
\end_layout

\begin_layout Plain Layout

  case Left(p)    => toList_K(p)
\end_layout

\begin_layout Plain Layout

  case Right(q)   => toList_L(q)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{toList}_{M}\triangleq\,\begin{array}{|c||c|}
 & \text{List}^{A}\\
\hline K^{A} & \text{toList}_{K}\\
L^{A} & \text{toList}_{L}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
We need to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 for a functor 
\begin_inset Formula $L$
\end_inset

 defined recursively by 
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset

, where the recursion scheme 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 is a bifunctor that is itself foldable.
 A bifunctor 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 is 
\series bold
foldable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
foldable bifunctor
\end_layout

\end_inset

 if there is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 function with this type signature:
\begin_inset Formula 
\[
\text{toList}_{S}:S^{A,A}\rightarrow\text{List}^{A}\quad.
\]

\end_inset

We define 
\begin_inset Formula $\text{toList}_{L}$
\end_inset

 using 
\begin_inset Formula $\text{toList}_{S}$
\end_inset

 and the bifunctor 
\begin_inset Formula $S$
\end_inset

's liftings (denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapS1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapS2
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList_L[A]: S[A, L[A]] => List[A] = _.mapS2(toList_L).mapS1(List(_)).toList.fla
tten
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{toList}_{L}:S^{A,L^{A}}\rightarrow\text{List}^{A}\quad,\quad\quad\text{toList}_{L}\triangleq\overline{\text{toList}_{L}}^{\uparrow S^{A,\bullet}}\bef\text{pu}_{\text{List}}^{\uparrow S^{\bullet,\text{List}^{A}}}\bef\text{toList}_{S}\bef\text{ftn}_{\text{List}}\quad.
\]

\end_inset

This code first converts values of type 
\begin_inset Formula $S^{A,L^{A}}$
\end_inset

 into type 
\begin_inset Formula $S^{A,\text{List}^{A}}$
\end_inset

 by lifting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 recursively to the second type parameter of 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

.
 We then convert 
\begin_inset Formula $S^{A,\text{List}^{A}}$
\end_inset

 into 
\begin_inset Formula $S^{\text{List}^{A},\text{List}^{A}}$
\end_inset

 by creating one-element lists via 
\begin_inset Formula $\text{pu}_{\text{List}}$
\end_inset

.
 After that, all values of type 
\begin_inset Formula $A$
\end_inset

 are extracted from 
\begin_inset Formula $S^{\text{List}^{A},\text{List}^{A}}$
\end_inset

 using 
\begin_inset Formula $\text{toList}_{S}$
\end_inset

, which returns a nested 
\begin_inset Formula $\text{List}^{\text{List}^{A}}$
\end_inset

.
 The final 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 operation reduces that to a 
\begin_inset Formula $\text{List}^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
This implements 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 for the five type constructions that build up polynomial functors.
 In each case, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 extracts all stored values of type 
\begin_inset Formula $A$
\end_inset

.
 One could write a code generator to provide a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Foldable
\end_layout

\end_inset

 instance for any polynomial functor automatically.
 When writing code by hand, it is more convenient to implement folding operation
s directly, as we did at the beginning of this chapter.
\end_layout

\begin_layout Subsection
Equivalence of 
\family typewriter
traverse
\family default
 and 
\family typewriter
sequence
\end_layout

\begin_layout Standard
The standard Scala library contains the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.sequence
\end_layout

\end_inset

 in addition to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.traverse
\end_layout

\end_inset

.
 The main use of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.sequence
\end_layout

\end_inset

 is for transforming a sequence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 values that may run in parallel.
 The result is a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 value that waits until all parallel computations are finished.
 Omitting some details, we may write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.sequence
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sequence[A, L[X] <: TraversableOnce[X]]: L[Future[A]] => Future[L[A]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future.sequence
\end_layout

\end_inset

 is limited to sequence-like data types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A] = List[A]
\end_layout

\end_inset

.
 To generalize the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 operation to other data types, we replace a sequence-like type by an arbitrary
 traversable functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

.
 We also replace the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 type constructor by an arbitrary applicative functor (since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation accepts one).
 It turns out that a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 can then be defined via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation and vice versa:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sequence[A, L[_]: Traversable, F[_]: Applicative : Functor]: L[F[A]]
 => F[L[A]] = _.traverse(id)
\end_layout

\begin_layout Plain Layout

def traverse[A, B, L[_]: Traversable, F[_]: Applicative : Functor](la: L[A])(f:
 A => F[B]): F[L[B]] = sequence(la.map(f))
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}:L^{F^{A}}\rightarrow F^{L^{A}}\quad,\quad\quad\text{seq}_{L}\triangleq\text{trav}_{L}(\text{id})\quad,\\
 & \text{trav}_{L}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}\quad,\quad\quad\text{trav}_{L}(f)\triangleq f^{\uparrow L}\bef\text{seq}_{L}\quad.
\end{align*}

\end_inset

An inverse transformation (
\begin_inset Formula $F^{L^{A}}\rightarrow L^{F^{A}}$
\end_inset

) is not always possible, as shown in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The example with 
\begin_inset Formula $F=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset Formula $L=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 may help remember the correct type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 holds under the assumption that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 obeys a naturality law with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 This follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 where we need to define 
\begin_inset Formula $\text{tr}\triangleq\text{seq}_{L}$
\end_inset

, 
\begin_inset Formula $\text{ftr}\triangleq\text{trav}_{L}$
\end_inset

, 
\begin_inset Formula $F\triangleq L$
\end_inset

, 
\begin_inset Formula $G\triangleq F$
\end_inset

, and 
\begin_inset Formula $K\triangleq F\circ L$
\end_inset

.
 
\end_layout

\begin_layout Standard
Because of this equivalence, we may define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 typeclass via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 instead of via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 It is easier to study the properties and laws of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 operation because it has a simpler type signature.
 It is also easier to verify the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

.
 So, we will use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 when proving the type constructions for traversable functors.
\end_layout

\begin_layout Subsection
Laws of 
\family typewriter
traverse
\end_layout

\begin_layout Standard
Given a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: L[A]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 is a traversable functor, programmers expect that the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.traverse(f)
\end_layout

\end_inset

 should evaluate the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => F[B]
\end_layout

\end_inset

 on each value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 stored within the container 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 The resulting applicative 
\begin_inset Formula $F$
\end_inset

-effects should be merged into a single value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[L[B]]
\end_layout

\end_inset

.
 At the same time, the structure of the initial value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: L[A]
\end_layout

\end_inset

 must be preserved as much as possible in the resulting values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[B]
\end_layout

\end_inset

 wrapped under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

.
 Also, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function should work in the same way for all applicative functors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 How can we express these expectations as laws?
\begin_inset Foot
status open

\begin_layout Plain Layout
Those laws were given by M.
\begin_inset space ~
\end_inset

Jaskelioff
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mauro Jaskelioff
\end_layout

\end_inset

 and O.
\begin_inset space ~
\end_inset

Rypacek in the paper 
\begin_inset Quotes eld
\end_inset

An investigation of the laws of traversals
\begin_inset Quotes erd
\end_inset

, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/abs/1202.2919"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A naturality law formalizes the requirement that a function with a type
 parameter should work in the same way regardless of the type chosen for
 that type parameter.
 There is one naturality law per type parameter.
 So, we impose the naturality laws with respect to type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The form of the naturality laws follows from the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{trav}_{L}^{F,A,B}:(A\rightarrow F^{B})\rightarrow L^{A}\rightarrow F^{L^{B}}\quad.
\]

\end_inset

If we fix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and let 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 vary, the type signature is of the form 
\begin_inset Formula $J^{A}\rightarrow K^{A}$
\end_inset

, which is a natural transformation between two contrafunctors.
 If we fix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and let 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 vary, this type signature has the form 
\begin_inset Formula $G^{A}\rightarrow H^{A}$
\end_inset

, which is a natural transformation between two functors.
 So, we can formulate the two 
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
traverse
\end_layout

\end_inset

naturality laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 according to the recipes of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Naturality-laws-and-natural-transformations"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For any 
\begin_inset Formula $f^{:X\rightarrow A}$
\end_inset

, 
\begin_inset Formula $g^{:A\rightarrow F^{B}}$
\end_inset

, and 
\begin_inset Formula $h^{:B\rightarrow C}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{trav}_{L}^{F,X,B}(f\bef g)=f^{\uparrow L}\bef\text{trav}_{L}^{F,A,B}(g)\quad,\quad\quad\text{trav}_{L}^{F,A,C}(g\bef h^{\uparrow F})=\text{trav}_{L}^{F,A,B}(g)\bef h^{\uparrow L\uparrow F}\quad.\label{eq:naturality-laws-of-traverse}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{5.0pc}L^{X}\ar[rd]\sp(0.6){~~\text{trav}_{L}^{F,X,B}(f\bef g)}\ar[d]\sp(0.45){f^{\uparrow L}} &  & L^{A}\ar[rd]\sb(0.35){\text{trav}_{L}^{F,A,C}(g\bef h)~~}\ar[r]\sp(0.5){\text{trav}_{L}^{F,A,B}(g)} & F^{L^{B}}\ar[d]\sp(0.45){h^{\uparrow L\uparrow F}}\\
L^{A}\ar[r]\sb(0.5){\text{trav}_{L}^{F,A,B}(g)} & F^{L^{B}} &  & F^{L^{C}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
We also need a naturality law with respect to the parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

, which is a type constructor required to be an applicative functor.
 This law expresses the requirement that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 may not inspect the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 directly and make decisions based on that type.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 may only use 
\begin_inset Formula $F$
\end_inset

's applicative methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wu
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

).
 To formulate this requirement as an 
\series bold
applicative naturality law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative naturality law!of 
\family typewriter
traverse
\end_layout

\end_inset

, we write an equation similar to the second naturality law, except that
 the arbitrary function 
\begin_inset Formula $f$
\end_inset

 will now map the applicative functor 
\begin_inset Formula $F$
\end_inset

 to another 
\emph on
arbitrary
\emph default
 applicative functor 
\begin_inset Formula $G$
\end_inset

:
\begin_inset Formula $\xymatrix{\xyScaleY{1.7pc}\xyScaleX{5.0pc}L^{A}\ar[rd]\sb(0.4){\text{trav}_{L}^{G,A,B}(g\bef f)~~}\ar[r]\sp(0.5){\text{trav}_{L}^{F,A,B}(g)} & F^{L^{B}}\ar[d]\sp(0.45){f}\\
 & G^{L^{B}}
}
$
\end_inset


\begin_inset Formula 
\begin{equation}
\text{trav}_{L}^{G,A,B}(g^{:A\rightarrow F^{B}}\bef f^{:F^{B}\rightarrow G^{B}})=\text{trav}_{L}^{F,A,B}(g)\bef f^{:F^{L^{B}}\rightarrow G^{L^{B}}}\quad.\label{eq:traverse-applicative-naturality-law}
\end{equation}

\end_inset

Here 
\begin_inset Formula $f$
\end_inset

 is a natural transformation with type signature 
\begin_inset Formula $f:\forall X.\,F^{X}\rightarrow G^{X}$
\end_inset

.
 So, we are allowed to apply the same code of 
\begin_inset Formula $f$
\end_inset

 to different types: 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $F^{B}\rightarrow G^{B}$
\end_inset

 in the left-hand side of the law and 
\begin_inset Formula $F^{L^{B}}\rightarrow G^{L^{B}}$
\end_inset

 in the right-hand side.
\end_layout

\begin_layout Standard
Another requirement for the function 
\begin_inset Formula $f$
\end_inset

 is that 
\begin_inset Formula $f$
\end_inset

 must map 
\begin_inset Formula $F$
\end_inset

's applicative methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wu
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

) to the corresponding methods of 
\begin_inset Formula $G$
\end_inset

.
 Otherwise, the code of 
\begin_inset Formula $\text{trav}_{L}^{F,A,B}$
\end_inset

 that uses those methods of 
\begin_inset Formula $F$
\end_inset

 will not be mapped via 
\begin_inset Formula $f$
\end_inset

 to the same code of 
\begin_inset Formula $\text{trav}_{L}^{G,A,B}$
\end_inset

 that uses 
\begin_inset Formula $G$
\end_inset

's applicative methods.
 
\end_layout

\begin_layout Standard
Natural transformations 
\begin_inset Formula $f:F^{X}\rightarrow G^{X}$
\end_inset

 that preserve the applicative methods of 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative morphism
\end_layout

\end_inset


\series bold
applicative morphisms
\series default
 (compare to monoid morphisms defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Equivalence-of-foldLeft,foldMap,reduce,and-toList"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and monad morphisms defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monads-in-category-theory-monad-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The laws of applicative morphisms are:
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of applicative morphisms
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of applicative morphisms
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
\text{identity law of applicative morphism }f:\quad & f^{:F^{\bbnum 1}\rightarrow G^{\bbnum 1}}(\text{wu}_{F})=\text{wu}_{G}\quad,\label{eq:identity-law-of-applicative-morphism}\\
\text{composition law of applicative morphism }f:\quad & \text{zip}_{G}\big(f(p^{:F^{A}})\times f(q^{:F^{B}})\big)=f(\text{zip}_{F}(p\times q))\quad.\label{eq:composition-law-of-applicative-morphism}
\end{align}

\end_inset

The applicative naturality law is required to hold only when 
\begin_inset Formula $f$
\end_inset

 is an applicative morphism.
\end_layout

\begin_layout Standard
Here are some examples of applicative morphisms and applicative naturality.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-some-applicative-morphisms"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-some-applicative-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider applicative functors 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

 and 
\begin_inset Formula $L^{A}\triangleq A\times A$
\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that the standard function 
\begin_inset Formula $\Delta:\text{Id}^{A}\rightarrow L^{A}$
\end_inset

 is an applicative morphism.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the standard function 
\begin_inset Formula $\pi_{1}:L^{A}\rightarrow\text{Id}^{A}$
\end_inset

 is an applicative morphism.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to check that these functions obey the laws of applicative morphisms.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 To verify the identity law, write:
\begin_inset Formula 
\[
\Delta(\text{wu}_{\text{Id}})=\Delta(1)=1\times1=\text{wu}_{P}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law, begin with its left-hand side:
\begin_inset Formula 
\begin{align*}
 & \text{zip}_{L}\big(\Delta(p^{:A})\times\Delta(q^{:A})\big)=\text{zip}_{L}\big((p\times p)\times(q\times q)\big)\\
\text{definition of }\text{zip}_{L}:\quad & =(p\times q)\times(p\times q)=\Delta(p\times q)=\Delta(\text{zip}_{\text{Id}}(p\times q))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 To verify the identity law, write:
\begin_inset Formula 
\[
\pi_{1}(\text{wu}_{L})=\pi_{1}(1\times1)=1=\text{wu}_{\text{Id}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law, begin with its right-hand side:
\begin_inset Formula 
\begin{align*}
 & \pi_{1}\big(\text{zip}_{L}((p_{1}^{:A}\times p_{2}^{:A})\times(q_{1}^{:B}\times q_{2}^{:B}))\big)=\pi_{1}\big((p_{1}\times q_{1})\times(p_{2}\times q_{2})\big)=p_{1}\times q_{1}\\
 & =\text{zip}_{\text{Id}}(p_{1}\times q_{1})=\text{zip}_{\text{Id}}(\pi_{1}(p_{1}\times p_{2})\times\pi_{1}(q_{1}\times q_{2}))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-naturality-law-of-traverse"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-naturality-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for 
\begin_inset Formula $L^{A}\triangleq A\times A$
\end_inset

 using an applicative morphism between applicative functors 
\begin_inset Formula $G^{A}\triangleq\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq\bbnum 1+A\times A$
\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method for 
\begin_inset Formula $L^{A}\triangleq A\times A$
\end_inset

 is defined by:
\begin_inset Formula 
\[
\text{trav}_{L}(f^{:A\rightarrow F^{B}})\triangleq p^{:A}\times q^{:A}\rightarrow\text{zip}_{F}(f(p)\times f(q))=(f\boxtimes f)\bef\text{zip}_{F}\quad.
\]

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 methods of the applicative functors 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 are:
\begin_inset Formula 
\[
\text{zip}_{G}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times B\\
\hline \bbnum 1\times\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
A\times\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
\bbnum 1\times B & \_\rightarrow1 & \bbnum 0\\
A\times B & \bbnum 0 & \text{id}
\end{array}\quad,\quad\quad\text{zip}_{H}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & (A\times B)\times(A\times B)\\
\hline \bbnum 1\times\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
(A\times A)\times\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
\bbnum 1\times(B\times B) & \_\rightarrow1 & \bbnum 0\\
(A\times A)\times(B\times B) & \bbnum 0 & \text{zip}_{L}
\end{array}\quad.
\]

\end_inset

The function 
\begin_inset Formula $\text{zip}_{L}$
\end_inset

 was shown in the solution to Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-some-applicative-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a).
 
\end_layout

\begin_layout Standard
The applicative morphism 
\begin_inset Formula $g:G^{A}\rightarrow H^{A}$
\end_inset

 is implemented as:
\begin_inset Formula 
\[
g:\bbnum 1+A\rightarrow\bbnum 1+A\times A\quad,\quad\quad g\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \Delta
\end{array}\quad.
\]

\end_inset

The fully parametric implementations of 
\begin_inset Formula $\text{trav}_{L}$
\end_inset

, 
\begin_inset Formula $\text{zip}_{G}$
\end_inset

, 
\begin_inset Formula $\text{zip}_{H}$
\end_inset

, and 
\begin_inset Formula $g$
\end_inset

 are forced by their type signatures.
 The values 
\begin_inset Formula $\text{wu}_{G}$
\end_inset

 and 
\begin_inset Formula $\text{wu}_{H}$
\end_inset

 need to be chosen as 
\begin_inset Formula $\text{wu}_{G}\triangleq\bbnum 0^{:\bbnum 1}+1$
\end_inset

 and 
\begin_inset Formula $\text{wu}_{H}\triangleq\bbnum 0^{:\bbnum 1}+1\times1$
\end_inset

 in order to obey the identity laws of applicative morphisms.
\end_layout

\begin_layout Standard
Next, we verify that 
\begin_inset Formula $g$
\end_inset

 is an applicative morphism.
 To check the identity law of 
\begin_inset Formula $g$
\end_inset

:
\begin_inset Formula 
\[
\text{wu}_{G}\triangleright g=\,\begin{array}{|cc|}
\bbnum 0 & 1\end{array}\,\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \Delta
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & (1\triangleright\Delta)\end{array}\,=\bbnum 0+1\times1=\text{wu}_{H}\quad.
\]

\end_inset

To check the composition law of 
\begin_inset Formula $g$
\end_inset

, first rewrite that law in the point-free style:
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of applicative morphisms!in the point-free style
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
point-free style
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
(g\boxtimes g)\bef\text{zip}_{H}=\text{zip}_{G}\bef g\quad.\label{eq:composition-law-applicative-morphism-point-free}
\end{equation}

\end_inset

The pair product (
\begin_inset Formula $g\boxtimes g$
\end_inset

) can be written in matrix form like this:
\begin_inset Formula 
\[
g\boxtimes g=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \Delta
\end{array}\,\boxtimes\,\begin{array}{|c||cc|}
 & \bbnum 1 & B\times B\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
B & \bbnum 0 & \Delta
\end{array}\,=\,\begin{array}{|c||cccc|}
 & \bbnum 1 & A\times A\times\bbnum 1 & \bbnum 1\times B\times B & A\times A\times B\times B\\
\hline \bbnum 1\times\bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0 & \bbnum 0\\
A\times\bbnum 1 & \bbnum 0 & \Delta\boxtimes\text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 1\times B & \bbnum 0 & \bbnum 0 & \text{id}\boxtimes\Delta & \bbnum 0\\
A\times B & \bbnum 0 & \bbnum 0 & \bbnum 0 & \Delta\boxtimes\Delta
\end{array}\quad.
\]

\end_inset

The two sides of the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-applicative-morphism-point-free"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are then simplified to:
\begin_inset Formula 
\begin{align*}
 & (g\boxtimes g)\bef\text{zip}_{H}=\,\begin{array}{||cccc|}
\text{id} & \bbnum 0 & \bbnum 0 & \bbnum 0\\
\bbnum 0 & \Delta\boxtimes\text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 0 & \bbnum 0 & \text{id}\boxtimes\Delta & \bbnum 0\\
\bbnum 0 & \bbnum 0 & \bbnum 0 & \Delta\boxtimes\Delta
\end{array}\,\bef\,\begin{array}{||cc|}
\_\rightarrow1 & \bbnum 0\\
\_\rightarrow1 & \bbnum 0\\
\_\rightarrow1 & \bbnum 0\\
\bbnum 0 & \text{zip}_{L}
\end{array}\,=\,\begin{array}{||cc|}
\_\rightarrow1 & \bbnum 0\\
\_\rightarrow1 & \bbnum 0\\
\_\rightarrow1 & \bbnum 0\\
\bbnum 0 & (\Delta\boxtimes\Delta)\bef\text{zip}_{L}
\end{array}\quad,\\
 & \text{zip}_{G}\bef g=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times B\\
\hline \bbnum 1\times\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
A\times\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
\bbnum 1\times B & \_\rightarrow1 & \bbnum 0\\
A\times B & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & (A\times B)\times(A\times B)\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times B & \bbnum 0 & \Delta
\end{array}\,=\,\begin{array}{||cc|}
\_\rightarrow1 & \bbnum 0\\
\_\rightarrow1 & \bbnum 0\\
\_\rightarrow1 & \bbnum 0\\
\bbnum 0 & \Delta
\end{array}\quad.
\end{align*}

\end_inset

The remaining difference is:
\begin_inset Formula 
\[
(\Delta\boxtimes\Delta)\bef\text{zip}_{L}\overset{?}{=}\Delta\quad.
\]

\end_inset

This equation can be verified by applying both sides to some 
\begin_inset Formula $a^{:A}\times b^{:B}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (a\times b)\triangleright(\Delta\boxtimes\Delta)\bef\text{zip}_{L}=\big((a\times a)\times(b\times b)\big)\triangleright\text{zip}_{L}=(a\times b)\times(a\times b)\quad,\\
 & (a\times b)\triangleright\Delta=(a\times b)\times(a\times b)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We are now ready to check that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method of 
\begin_inset Formula $L$
\end_inset

 satisfies the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), where we swap 
\begin_inset Formula $f$
\end_inset

 with 
\begin_inset Formula $g$
\end_inset

 and use applicative functors 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $H$
\end_inset

 instead of 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

.
 Write the two sides of the law:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{trav}_{L}^{H,A,B}(f^{:A\rightarrow G^{B}}\bef g^{:G^{B}\rightarrow H^{B}})=\big((f\bef g)\boxtimes(f\bef g)\big)\bef\text{zip}_{H}\quad,\\
\text{right-hand side}:\quad & \text{trav}_{L}^{G,A,B}(f^{:A\rightarrow G^{B}})\bef g^{:G^{L^{B}}\rightarrow H^{L^{B}}}=(f\boxtimes f)\bef\gunderline{\text{zip}_{G}\bef g}\\
\text{composition law~(\ref{eq:composition-law-applicative-morphism-point-free})}:\quad & \quad=\gunderline{(f\boxtimes f)\bef(g\boxtimes g)}\bef\text{zip}_{H}\\
\text{composition law~(\ref{eq:pair-product-composition-law})}:\quad & \quad=\gunderline{\big((f\bef g)\boxtimes(f\bef g)\big)}\bef\text{zip}_{H}\quad.
\end{align*}

\end_inset

The two sides of the law are now equal.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
In this derivation, we were able to pass from 
\begin_inset Formula $\text{zip}_{G}$
\end_inset

 to 
\begin_inset Formula $\text{zip}_{H}$
\end_inset

 only because 
\begin_inset Formula $g$
\end_inset

, being an applicative morphism, maps 
\begin_inset Formula $G$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 operation into 
\begin_inset Formula $H$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 operation according to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-applicative-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-pure-is-applicative-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-pure-is-applicative-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any applicative functor 
\begin_inset Formula $F$
\end_inset

, show that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method (
\begin_inset Formula $\text{pu}_{F}:A\rightarrow F^{A}$
\end_inset

) is an applicative morphism between the identity functor (
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

) and 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The identity functor's applicative methods are identity functions:
\begin_inset Formula 
\[
\text{wu}_{\text{Id}}=1\quad,\quad\quad\text{pu}_{\text{Id}}(x)=x\quad,\quad\quad\text{zip}_{\text{Id}}(p\times q)=p\times q\quad.
\]

\end_inset

We need to show that 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 obeys the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-applicative-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-applicative-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To verify the identity law:
\begin_inset Formula 
\[
\text{pu}_{F}(\text{wu}_{\text{Id}})\overset{?}{=}\text{wu}_{F}=\text{pu}_{F}(1)=\text{pu}_{F}(\text{wu}_{\text{Id}})\quad.
\]

\end_inset

To verify the composition law:
\begin_inset Formula 
\begin{align*}
 & \text{zip}_{F}\big(\text{pu}_{F}(p^{:A})\times\text{pu}_{F}(q^{:B})\big)\overset{?}{=}\text{pu}_{F}(\text{zip}_{\text{Id}}(p\times q))=\text{pu}_{F}(p\times q)\\
\text{use Exercise~\ref{subsec:Exercise-zip-pure-pure}}:\quad & =\text{zip}_{F}(\text{pu}_{F}(p)\times\text{pu}_{F}(q))\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We have analyzed the expectation that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 should work in the same way for all types and applicative functors.
 Another reasonable expectation is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.traverse(f)
\end_layout

\end_inset

 should visit 
\emph on
every
\emph default
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 stored inside 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 (where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 has type 
\begin_inset Formula $L^{A}$
\end_inset

).
 To formulate that expectation as a law, consider for simplicity a function
 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow F^{A}$
\end_inset

.
 Then the final result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.traverse(f)
\end_layout

\end_inset

 has type 
\begin_inset Formula $F^{L^{A}}$
\end_inset

, which can be visualized as some values of type 
\begin_inset Formula $L^{A}$
\end_inset

 wrapped under an 
\begin_inset Formula $F$
\end_inset

-effect.
 We expect those values to be similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 in their structure.
\end_layout

\begin_layout Standard
To formulate this condition in a simple way, we may choose functions 
\begin_inset Formula $f$
\end_inset

 that always return an 
\emph on
empty
\emph default
 
\begin_inset Formula $F$
\end_inset

-effect (that is, a result of applying 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method to some value).
 So, we choose 
\begin_inset Formula $f\triangleq\text{pu}_{F}$
\end_inset

.
 We expect that traversing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 with this function 
\begin_inset Formula $f$
\end_inset

 should reproduce the same value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 wrapped in an empty 
\begin_inset Formula $F$
\end_inset

-effect.
 So, we write the law as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.traverse(pure) == pure(p)
\end_layout

\end_inset

, or in the point-free style:
\begin_inset Formula 
\begin{equation}
\text{trav}_{L}^{F,A,A}(\text{pu}_{F})=\text{pu}_{F}\quad.\label{eq:traverse-identity-law-with-pure}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Alternatively, we may choose 
\begin_inset Formula $F^{A}\triangleq\text{Id}^{A}=A$
\end_inset

 (the identity functor), 
\begin_inset Formula $A=B$
\end_inset

, and 
\begin_inset Formula $f^{:A\rightarrow F^{B}}=\text{id}^{:A\rightarrow A}$
\end_inset

.
 Then the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.traverse(f)
\end_layout

\end_inset

 will have type 
\begin_inset Formula $F^{L^{A}}=L^{A}$
\end_inset

 and is expected to equal the initial value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, as the transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is an identity function.
 We obtain the 
\series bold
identity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
traverse
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{trav}_{L}^{\text{Id},A,A}(\text{id}^{:A\rightarrow A})=\text{id}^{:L^{A}\rightarrow L^{A}}\quad.\label{eq:traverse-identity-law}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We can show that this law is equivalent to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law-with-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-identity-law-traverse-simplified"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-identity-law-traverse-simplified"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 obeys Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law-with-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then it also obeys Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 obeys Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then it also obeys Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law-with-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We may set 
\begin_inset Formula $F\triangleq\text{Id}$
\end_inset

 in the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law-with-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then we get Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) since 
\begin_inset Formula $\text{pu}_{\text{Id}}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-pure-is-applicative-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 is an applicative morphism between 
\begin_inset Formula $\text{Id}$
\end_inset

 and 
\begin_inset Formula $F$
\end_inset

.
 So, we may set 
\begin_inset Formula $F\triangleq\text{Id}$
\end_inset

, 
\begin_inset Formula $G\triangleq F$
\end_inset

, 
\begin_inset Formula $f\triangleq\text{pu}_{F}$
\end_inset

, and 
\begin_inset Formula $g\triangleq\text{\text{id}}$
\end_inset

 in the applicative naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We then obtain:
\begin_inset Formula 
\begin{align*}
\text{applicative naturality law~(\ref{eq:traverse-applicative-naturality-law})}:\quad & \text{trav}_{L}(\text{id}\bef f)\overset{!}{=}\gunderline{\text{trav}_{L}(\text{id})}\bef f\\
\text{identity law~(\ref{eq:traverse-identity-law})}:\quad & =\text{id}\bef f=f=\text{pu}_{F}\quad.
\end{align*}

\end_inset

At the same time, we have: 
\begin_inset Formula $\text{trav}_{L}(\text{id}\bef f)=\text{trav}_{L}(f)=\text{trav}_{L}(\text{pu}_{F})$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law-with-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Apart from visiting every stored value exactly once, we expect that all
 
\begin_inset Formula $F$
\end_inset

-effects returned by 
\begin_inset Formula $f$
\end_inset

 are collected by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 exactly once.
 To see an example where that expectation fails, consider a simple traversable
 functor 
\begin_inset Formula $L^{A}=A\times A$
\end_inset

 and write the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def trav2[A, B, F[_]: WuZip : Functor](f: A => F[B])(la: (A, A)): F[(B,
 B)] = {
\end_layout

\begin_layout Plain Layout

  val (f1, f2) = (f(la._1), f(la._2))
\end_layout

\begin_layout Plain Layout

  (f1 zip f1 zip f2).map { case ((x, y), z) => (y, z) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code applies the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to both values in the given pair.
 The result is a pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f1, f2)
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(F[B], F[B])
\end_layout

\end_inset

.
 The code copies the first 
\begin_inset Formula $F$
\end_inset

-effect twice and uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 to combine the three 
\begin_inset Formula $F$
\end_inset

-effects together.
 The first of the wrapped values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is discarded.
\end_layout

\begin_layout Standard
We expect that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav2
\end_layout

\end_inset

 should violate some law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 It turns out that a suitable law is found by composing two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operations.
 Consider two different applicative functors (
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

), two functions 
\begin_inset Formula $f:A\rightarrow F^{B}$
\end_inset

 and 
\begin_inset Formula $g:B\rightarrow G^{C}$
\end_inset

, and compute the following composition:
\begin_inset Formula 
\[
p\triangleright\text{trav}_{L}^{F,A,B}(f)\triangleright\big(\text{trav}_{L}^{G,B,C}(g)\big)^{\uparrow F}:F^{G^{L^{C}}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
The second 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation needs to be lifted to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 for the types to match.
 The result (of type 
\begin_inset Formula $F^{G^{L^{C}}}$
\end_inset

) looks like a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation with respect to the functor 
\begin_inset Formula $F\circ G$
\end_inset

.
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-applicative-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the functor 
\begin_inset Formula $F\circ G$
\end_inset

 is applicative.
 So, we may apply a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation using that functor and obtain:
\begin_inset Formula 
\[
p\triangleright\text{trav}_{L}^{F\circ G,A,C}(f\bef g^{\uparrow F}):F^{G^{L^{C}}}\quad.
\]

\end_inset


\begin_inset Formula $\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3.4pc}L^{A}\ar[dr]\sb(0.35){\text{trav}_{L}^{F\circ G,A,C}(f\bef g^{\uparrow F})~~}\ar[r]\sp(0.5){\text{trav}_{L}^{F,A,B}(f)} & F^{L^{B}}\ar[d]\sp(0.4){\big(\text{trav}_{L}^{G,B,C}(g)\big)^{\uparrow F}}\\
 & F^{G^{L^{C}}}
}
$
\end_inset

The 
\series bold
composition law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of 
\family typewriter
traverse
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 says that the two results should be equal:
\begin_inset Formula 
\begin{equation}
\text{trav}_{L}^{F,A,B}(f)\bef\big(\text{trav}_{L}^{G,B,C}(g)\big)^{\uparrow F}=\text{trav}_{L}^{F\circ G,A,C}(f\bef g^{\uparrow F})\quad.\label{eq:composition-law-of-traverse}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
So far, we have not given a motivation for the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) from a programmer's perspective.
 We just wrote that law by analogy with composition laws of other 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

-like functions.
 It is not obvious that the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) indeed prevents 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 from evaluating some effects more than once.
 To get a heuristic explanation, assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 evaluates some effect twice.
 The left-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will evaluate some 
\begin_inset Formula $F$
\end_inset

-effect twice and then evaluate some 
\begin_inset Formula $G$
\end_inset

-effect twice, wrapped under the twice evaluated 
\begin_inset Formula $F$
\end_inset

-effect.
 The right-hand side will evaluate an 
\begin_inset Formula $(F\circ G)$
\end_inset

-effect twice.
 To illustrate the difference between the resulting effects, we may write
 heuristically 
\begin_inset Formula $(F\times F)\circ(G\times G)$
\end_inset

 and 
\begin_inset Formula $(F\circ G)\times(F\circ G)$
\end_inset

.
 In general, these results will not be the same when 
\begin_inset Formula $F$
\end_inset

-effects and 
\begin_inset Formula $G$
\end_inset

-effects do not commute.
\end_layout

\begin_layout Standard
To make this heuristic explanation more rigorous, let us show an example
 where the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is violated by the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trav2
\end_layout

\end_inset

 shown above.
 We need to choose sufficiently complicated applicative functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 whose effects do not commute.
 A suitable choice is to set both 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
\begin_inset Foot
status open

\begin_layout Plain Layout
The paper 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/abs/1202.2919"
literal "false"

\end_inset


\family default
 shows another example using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad.
\end_layout

\end_inset

 For simplicity, we set all type parameters to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and choose the functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 that add their arguments to the internal state.
 The complete code (using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Zippable
\end_layout

\end_inset

 typeclass defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Zippable-and-Applicative-typeclass"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Full-code-implementing-traverse-law-counterexample"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "frame=single,fillcolor={\color{black}},framesep={0.2mm},framexleftmargin=2mm,framexrightmargin=2mm,framextopmargin=2mm,framexbottommargin=2mm"
inline false
status open

\begin_layout Plain Layout

import io.chymyst.ch.implement // Automatic implementation of some methods.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type L[A] = (A, A) // A very simple but nontrivial traversable functor.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit val functorL: Functor[L] = new Functor[L] {
\end_layout

\begin_layout Plain Layout

  override def map[A, B](fa: (A, A))(f: A => B): (B, B) = implement
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def trav2[A, B, F[_] : Zippable : Functor](f: A => F[B])(la: L[A]): F[L[B]]
 = la.map(f) match {
\end_layout

\begin_layout Plain Layout

  case (f1, f2) => f1 zip f1 zip f2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

final case class S[A](run: Int => (A, Int)) // State monad with internal
 state of type Int.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit val FunctorS: Functor[S] = new Functor[S] {
\end_layout

\begin_layout Plain Layout

  override def map[A, B](fa: S[A])(f: A => B): S[B] = implement
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit val ZippableS: Zippable[S] = new Zippable[S] {
\end_layout

\begin_layout Plain Layout

  override def zip[A, B](fa: S[A], fb: S[B]): S[(A, B)] = S { i  =>
\end_layout

\begin_layout Plain Layout

    val (a, j) = fa.run(i)
\end_layout

\begin_layout Plain Layout

    val (b, k) = fb.run(j)
\end_layout

\begin_layout Plain Layout

    ((a, b), k)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Define F[A] as the composition S[S[A]] and implement WuZip and Functor
 instances.
\end_layout

\begin_layout Plain Layout

final case class F[A](run: S[S[A]]) {
\end_layout

\begin_layout Plain Layout

  // A runner method to help with testing.
\end_layout

\begin_layout Plain Layout

  def eval(i: Int, j: Int): (A, Int, Int) = {
\end_layout

\begin_layout Plain Layout

    val (sa, k) = run.run(i)
\end_layout

\begin_layout Plain Layout

    val (a, l) = sa.run(j)
\end_layout

\begin_layout Plain Layout

    (a, k, l)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit val FunctorF: Functor[F] = new Functor[F] {
\end_layout

\begin_layout Plain Layout

  override def map[A, B](fa: F[A])(f: A => B): F[B] = implement
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit val ZippableF: Zippable[F] = new Zippable[F] {
\end_layout

\begin_layout Plain Layout

  override def zip[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
\end_layout

\begin_layout Plain Layout

    F((fa.run zip fb.run).map { case (sa, sb) => sa zip sb })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val f: Int => S[Int] = i => S(j => (i + j, i + j))
\end_layout

\begin_layout Plain Layout

val g: Int => S[Int] = f
\end_layout

\begin_layout Plain Layout

val ff: Int => F[Int] = i => F(f(i).map(g))
\end_layout

\begin_layout Plain Layout

val l: L[Int] = (1, 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val result1: F[L[Int]] = trav2[Int, Int, F](f1f2)(l)
\end_layout

\begin_layout Plain Layout

val result2: F[L[Int]] = {
\end_layout

\begin_layout Plain Layout

  val x: S[(Int, Int)] = trav2[Int, Int, S](f1)(l)
\end_layout

\begin_layout Plain Layout

  val y: S[S[(Int, Int)]] = x.map(trav2[Int, Int, S](f2))
\end_layout

\begin_layout Plain Layout

  F(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Show that result1 is not equal to result2:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> result1.eval(0, 0)
\end_layout

\begin_layout Plain Layout

res0: ((Int, Int), Int, Int) = ((3, 5), 2, 5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> result2.eval(0,0)
\end_layout

\begin_layout Plain Layout

res1: ((Int, Int), Int, Int) = ((4, 6), 2, 6) 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A counterexample violating the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:Full-code-implementing-traverse-law-counterexample"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have shown that 
\emph on
some
\emph default
 incorrect implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 are excluded by the composition law.
 But it remains unknown whether the mentioned laws guarantee that any lawful
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function collects each 
\begin_inset Formula $F$
\end_inset

-effect exactly once.
 Perhaps another law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 is required (see Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-traverse-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).***Mention the paper about the rewinding law.
\end_layout

\begin_layout Subsection
Laws of 
\family typewriter
sequence
\end_layout

\begin_layout Standard
We now derive the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 that correspond to the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 found previously.
 
\end_layout

\begin_layout Standard
Begin with the naturality laws.
 Since the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 (
\begin_inset Formula $L^{F^{A}}\rightarrow F^{L^{A}}$
\end_inset

) has only one type parameter, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 has only one naturality law
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
sequence
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $\xymatrix{\xyScaleY{1.5pc}\xyScaleX{2.0pc}L^{F^{A}}\ar[d]\sb(0.45){\text{seq}_{L}^{F,A}}\ar[r]\sb(0.5){f^{\uparrow F\uparrow L}} & L^{F^{B}}\ar[d]\sp(0.45){\text{seq}_{L}^{F,B}}\\
F^{L^{A}}\ar[r]\sp(0.5){f^{\uparrow L\uparrow F}} & F^{L^{B}}
}
$
\end_inset


\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B})^{\uparrow F\uparrow L}\bef\text{seq}_{L}^{F,B}=\text{seq}_{L}^{F,A}\bef f^{\uparrow L\uparrow F}\quad.\label{eq:sequence-naturality-law}
\end{equation}

\end_inset

It will be shown in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that this naturality law is equivalent to the two naturality laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Turning now to the applicative naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, we derive the corresponding applicative naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

.
 Express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 and substitute into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{trav}_{L}^{G,A,B}(g\bef f^{B})=(g\bef f^{B})^{\uparrow L}\bef\text{seq}_{L}^{G,B}=g^{\uparrow L}\bef f^{\uparrow L}\bef\text{seq}_{L}\quad,\\
\text{right-hand side}:\quad & \text{trav}_{L}^{F,A,B}(g)\bef f^{L^{B}}=g^{\uparrow L}\bef\text{seq}_{L}^{F,B}\bef f^{L^{B}}\quad.
\end{align*}

\end_inset

The function 
\begin_inset Formula $g^{\uparrow L}$
\end_inset

 can be omitted from both sides (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-simplify-law-omit-lifted-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a similar property).
\end_layout

\begin_layout Standard
\begin_inset Formula $\xymatrix{\xyScaleY{1.5pc}\xyScaleX{2.0pc}L^{F^{A}}\ar[d]\sb(0.45){\text{seq}_{L}^{F,A}}\ar[r]\sb(0.5){(f^{A})^{\uparrow L}} & L^{G^{A}}\ar[d]\sp(0.45){\text{seq}_{L}^{G,A}}\\
F^{L^{A}}\ar[r]\sp(0.5){f^{L^{A}}} & G^{L^{A}}
}
$
\end_inset

Renaming 
\begin_inset Formula $B$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

, we rewrite the applicative naturality law
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative naturality law!of 
\family typewriter
sequence
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
(f^{A})^{\uparrow L}\bef\text{seq}_{L}^{G,A}=\text{seq}_{L}^{F,A}\bef f^{L^{A}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
Here we have written the full type parameters in 
\begin_inset Formula $f^{X}$
\end_inset

 and 
\begin_inset Formula $\text{seq}_{L}^{F,A}$
\end_inset

 for clarity.
\end_layout

\begin_layout Standard
Turning now to the identity law, we again express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 and substitute into the simpler formulation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of the identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{id}\overset{!}{=}\text{trav}_{L}^{\text{Id},A,A}(\text{id})=\text{id}^{\uparrow L}\bef\text{seq}_{L}^{\text{Id},A}\overset{!}{=}\text{seq}_{L}^{\text{Id},A}\quad.
\]

\end_inset

So, the 
\series bold
identity law
\series default
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset


\begin_inset Index true 1 ""
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
sequence
\end_layout

\end_inset

 is:
\begin_inset Formula 
\begin{equation}
\text{seq}_{L}^{\text{Id},A}=\text{id}\quad.\label{eq:identity-law-of-sequence}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 leads to the following composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{trav}_{L}^{F,A,B}(f^{:A\rightarrow F^{B}})\bef\big(\text{trav}_{L}^{G,B,C}(g^{:B\rightarrow G^{C}})\big)^{\uparrow F}=f^{\uparrow L}\bef\text{seq}_{L}^{F,B}\bef\big(g^{\uparrow L}\bef\text{seq}_{L}^{G,C}\big)^{\uparrow F}\\
 & \quad=f^{\uparrow L}\bef\gunderline{\text{seq}_{L}^{F,B}\bef g^{\uparrow L\uparrow F}}\bef(\text{seq}_{L}^{G,C})^{\uparrow F}\\
\text{naturality law~(\ref{eq:sequence-naturality-law})}:\quad & \quad=f^{\uparrow L}\bef g^{\uparrow F\uparrow L}\bef\text{seq}_{L}^{F,G^{C}}\bef(\text{seq}_{L}^{G,C})^{\uparrow F}\quad,\\
\text{right-hand side}:\quad & \text{trav}_{L}^{F\circ G,A,C}(f\bef g^{\uparrow F})=(f\bef g^{\uparrow F})^{\uparrow L}\bef\text{seq}_{L}^{F\circ G,C}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\xymatrix{\xyScaleY{1.4pc}\xyScaleX{3.0pc}L^{F^{G^{A}}}\ar[r]\sp(0.55){\text{seq}_{L}^{F,G^{A}}}\ar[rd]\sb(0.4){\text{seq}_{L}^{F\circ G,A}} & F^{L^{G^{A}}}\ar[d]\sp(0.4){(\text{seq}_{L}^{G,A})^{\uparrow F}}\\
 & F^{G^{L^{A}}}
}
$
\end_inset

Omitting the common function 
\begin_inset Formula $(f\bef g^{\uparrow F})^{\uparrow L}$
\end_inset

 and renaming 
\begin_inset Formula $C$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

, we obtain the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of 
\family typewriter
sequence
\end_layout

\end_inset


\series bold
composition law
\series default
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}=\text{seq}_{L}^{F\circ G,A}\quad.\label{eq:composition-law-of-sequence}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 has simpler laws and a simpler type signature than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, we will use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 for verifying the laws of traversable functors.
 
\end_layout

\begin_layout Subsection
All polynomial functors are traversable
\begin_inset CommandInset label
LatexCommand label
name "subsec:All-polynomial-functors-are-traversable"

\end_inset


\end_layout

\begin_layout Standard
To show that all polynomial functors are traversable, we implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 operation for the five type constructions that build up polynomial functors.
 We will verify the laws in every case.
\end_layout

\begin_layout Paragraph
Fixed type
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L^{A}\triangleq Z$
\end_inset

 where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 via 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}:L^{F^{A}}\rightarrow F^{L^{A}}\cong Z\rightarrow F^{Z}\quad,\quad\quad\text{seq}_{L}^{F,A}\triangleq\text{pu}_{F}^{:Z\rightarrow F^{Z}}\quad.
\]

\end_inset

The identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds since 
\begin_inset Formula $\text{seq}_{L}^{\text{Id},A}=\text{pu}_{\text{Id}}=\text{id}$
\end_inset

.
 To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}=\text{pu}_{F}\bef(\text{pu}_{G})^{\uparrow F}\\
\text{naturality law of }\text{pu}_{F}:\quad & \quad=\text{pu}_{G}\bef\text{pu}_{F}\quad,\\
\text{right-hand side}:\quad & \text{seq}_{L}^{F\circ G,A}=\text{pu}_{F\circ G}\\
\text{definition of }\text{pu}_{F\circ G}:\quad & \quad=\text{pu}_{G}\bef\text{pu}_{F}\quad.
\end{align*}

\end_inset

The two sides of the law are now equal.
\end_layout

\begin_layout Paragraph
Type parameter
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L^{A}\triangleq A$
\end_inset

 (the identity functor), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 is defined as the identity function.
 Identity functions always satisfy identity and composition laws.
\end_layout

\begin_layout Standard
The functor composition 
\begin_inset Formula $L^{A}\triangleq M^{N^{A}}$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 are some traversable functors) is another case where the type parameter
 is used to define 
\begin_inset Formula $L$
\end_inset

.
 We assume that 
\begin_inset Formula $\text{seq}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq}_{N}$
\end_inset

 are already available and satisfy the laws, and define 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
\text{seq}_{L}:M^{N^{F^{A}}}\rightarrow F^{M^{N^{A}}}\quad,\quad\quad\text{seq}_{L}\triangleq(\text{seq}_{N}^{F,A})^{\uparrow M}\bef\text{seq}_{M}^{F,N^{A}}\quad.\label{eq:def-sequence-for-functor-composition}
\end{equation}

\end_inset

The laws of 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 will be proved in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $L^{A}\triangleq M^{A}\times N^{A}$
\end_inset

, with some traversable functors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 We assume that 
\begin_inset Formula $\text{seq}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq}_{N}$
\end_inset

 are already available and satisfy the laws, and define 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}:M^{F^{A}}\times N^{F^{A}}\rightarrow F^{M^{A}\times N^{A}}\quad,\quad\quad\text{seq}_{L}^{F,A}\triangleq m^{:M^{F^{A}}}\times n^{:N^{F^{A}}}\rightarrow\text{zip}_{F}\big((m\triangleright\text{seq}_{M}^{F,A})\times(n\triangleright\text{seq}_{N}^{F,A})\big)\quad.
\]

\end_inset

In the point-free style, we can write the same code in a shorter formula:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}\triangleq(\text{seq}_{M}^{F,A}\boxtimes\text{seq}_{N}^{F,A})\bef\text{zip}_{F}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), use the fact that 
\begin_inset Formula $\text{zip}_{\text{Id}}=\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}^{\text{Id},A}=(\gunderline{\text{seq}_{M}^{\text{Id},A}}\boxtimes\gunderline{\text{seq}_{N}^{\text{Id},A}})\bef\text{zip}_{\text{Id}}\\
\text{identity laws of }\text{seq}_{M}\text{ and }\text{seq}_{N}:\quad & =(\text{id}\boxtimes\text{id})\bef\text{id}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), begin with its left-hand side:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}=(\text{seq}_{M}^{F,G^{A}}\boxtimes\text{seq}_{N}^{F,G^{A}})\bef\gunderline{\text{zip}_{F}\bef(\text{seq}_{M}^{G,A}\boxtimes\text{seq}_{N}^{G,A})^{\uparrow F}}\bef\text{zip}_{G}^{\uparrow F}\\
\text{naturality law of }\text{zip}_{F}:\quad & =\gunderline{(\text{seq}_{M}^{F,G^{A}}\boxtimes\text{seq}_{N}^{F,G^{A}})\bef\big((\text{seq}_{M}^{G,A})^{\uparrow F}\boxtimes(\text{seq}_{N}^{G,A})^{\uparrow F}\big)}\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\\
\text{composition law~(\ref{eq:pair-product-composition-law})}:\quad & =\big((\text{seq}_{M}^{F,G^{A}}\bef(\text{seq}_{M}^{G,A})^{\uparrow F})\boxtimes(\text{seq}_{N}^{F,G^{A}}\bef(\text{seq}_{N}^{G,A})^{\uparrow F})\big)\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\quad.
\end{align*}

\end_inset

By assumption, 
\begin_inset Formula $\text{seq}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq}_{N}$
\end_inset

 satisfy their composition laws.
 So, we may rewrite the last line as:
\begin_inset Formula 
\[
\big(\text{seq}_{M}^{F\circ G,A}\boxtimes\text{seq}_{N}^{F\circ G,A}\big)\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\quad.
\]

\end_inset

We can now transform the right-hand side of the law to the same expression:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & \text{seq}_{L}^{F\circ G,A}=\big(\text{seq}_{M}^{F\circ G,A}\boxtimes\text{seq}_{N}^{F\circ G,A}\big)\bef\text{zip}_{F\circ G}\\
\text{definition of }\text{zip}_{F\circ G}:\quad & =\big(\text{seq}_{M}^{F\circ G,A}\boxtimes\text{seq}_{N}^{F\circ G,A}\big)\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The given implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 will first collect the 
\begin_inset Formula $F$
\end_inset

-effects stored in 
\begin_inset Formula $M^{F^{A}}$
\end_inset

 and then the 
\begin_inset Formula $F$
\end_inset

-effects stored in 
\begin_inset Formula $N^{F^{A}}$
\end_inset

.
 An alternative implementation could first iterate over the data in 
\begin_inset Formula $N$
\end_inset

 and then in 
\begin_inset Formula $M$
\end_inset

.
 That implementation still obeys the laws (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a proof in case 
\begin_inset Formula $M=N=\text{Id}$
\end_inset

).
\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $L^{A}\triangleq M^{A}+N^{A}$
\end_inset

, with some traversable functors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 We assume that 
\begin_inset Formula $\text{seq}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq}_{N}$
\end_inset

 are already available and satisfy the laws, and define 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{seq}_{L}:M^{F^{A}}+N^{F^{A}}\rightarrow F^{M^{A}+N^{A}}\quad,\quad\quad\text{seq}_{L}\triangleq\,\begin{array}{|c||c|}
 & F^{M^{A}+N^{A}}\\
\hline M^{F^{A}} & \text{seq}_{M}^{F,A}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow F}\\
N^{F^{A}} & \text{seq}_{N}^{F,A}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
*** do we need this? 
\end_layout

\begin_layout Plain Layout
It helps to rewrite 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 as a composition of two matrices, separating the functions lifted to 
\begin_inset Formula $F$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}\triangleq\,\begin{array}{|c||cc|}
 & F^{M^{A}} & F^{N^{A}}\\
\hline M^{F^{A}} & \text{seq}_{M}^{F,A} & \bbnum 0\\
N^{F^{A}} & \bbnum 0 & \text{seq}_{N}^{F,A}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & F^{M^{A}+N^{A}}\\
\hline F^{M^{A}} & (m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow F}\\
F^{N^{A}} & (n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow F}
\end{array}\\
 & =\,\begin{array}{|c||cc|}
 & F^{M^{A}} & F^{N^{A}}\\
\hline M^{F^{A}} & \text{seq}_{M}^{F,A} & \bbnum 0\\
N^{F^{A}} & \bbnum 0 & \text{seq}_{N}^{F,A}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & F^{M^{A}+N^{A}}\\
\hline F^{M^{A}} & (m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow F}\\
F^{N^{A}} & (n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset

To verify the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}^{\text{Id},A}=\,\begin{array}{|c||c|}
 & M^{A}+N^{A}\\
\hline M^{\text{Id}^{A}} & \text{seq}_{M}^{\text{Id},A}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow\text{Id}}\\
N^{\text{Id}^{A}} & \text{seq}_{N}^{\text{Id},A}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow\text{Id}}
\end{array}\\
\text{identity laws of }\text{seq}_{M}\text{ and }\text{seq}_{N}:\quad & =\,\begin{array}{|c||c|}
 & M^{A}+N^{A}\\
\hline M^{A} & m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}}\\
N^{A} & n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n
\end{array}\,=\,\begin{array}{|c||cc|}
 & M^{A} & N^{A}\\
\hline M^{A} & m\rightarrow m & \bbnum 0\\
N^{A} & \bbnum 0 & n\rightarrow n
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}=\,\begin{array}{||c|}
\text{seq}_{M}^{F,G^{A}}\bef(m^{:M^{G^{A}}}\rightarrow m+\bbnum 0^{:N^{G^{A}}})^{\uparrow F}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}\\
\text{seq}_{N}^{F,G^{A}}\bef(n^{:N^{G^{A}}}\rightarrow\bbnum 0^{:M^{G^{A}}}+n)^{\uparrow F}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}
\end{array}\quad,\\
\text{right-hand side}:\quad & \text{seq}_{L}^{F\circ G,A}=\,\begin{array}{||c|}
\text{seq}_{M}^{F\circ G,A}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow G\uparrow F}\\
\text{seq}_{N}^{F\circ G,A}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow G\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
The
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 left-hand side contains some function compositions lifted to 
\begin_inset Formula $F$
\end_inset

.
 Write them separately:
\begin_inset Formula 
\begin{align*}
 & (m^{:M^{G^{A}}}\rightarrow m+\bbnum 0^{:N^{G^{A}}})\bef\text{seq}_{L}^{G,A}=\,\begin{array}{|c||cc|}
 & M^{G^{A}} & N^{G^{A}}\\
\hline M^{G^{A}} & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||c|}
 & G^{M^{A}+N^{A}}\\
\hline M^{G^{A}} & \text{seq}_{M}^{G,A}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow G}\\
N^{G^{A}} & \text{seq}_{N}^{G,A}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow G}
\end{array}\\
 & \quad=\text{seq}_{M}^{G,A}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow G}\quad,\\
 & (n^{:N^{G^{A}}}\rightarrow\bbnum 0^{:M^{G^{A}}}+n)\bef\text{seq}_{L}^{G,A}=\,\begin{array}{|c||cc|}
 & M^{G^{A}} & N^{G^{A}}\\
\hline N^{G^{A}} & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & G^{M^{A}+N^{A}}\\
\hline M^{G^{A}} & \text{seq}_{M}^{G,A}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow G}\\
N^{G^{A}} & \text{seq}_{N}^{G,A}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow G}
\end{array}\\
 & \quad=\text{seq}_{N}^{G,A}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow G}\quad.
\end{align*}

\end_inset

Then simplify the left-hand side using the composition laws of 
\begin_inset Formula $\text{seq}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq}_{N}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}=\,\begin{array}{||c|}
\gunderline{\text{seq}_{M}^{F,G^{A}}\bef(\text{seq}_{M}^{G,A})^{\uparrow F}}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow G\uparrow F}\\
\gunderline{\text{seq}_{N}^{F,G^{A}}\bef(\text{seq}_{N}^{G,A})^{\uparrow F}}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow G\uparrow F}
\end{array}\\
 & =\,\begin{array}{||c|}
\text{seq}_{M}^{F\circ G,A}\bef(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{A}})^{\uparrow G\uparrow F}\\
\text{seq}_{N}^{F\circ G,A}\bef(n^{:N^{A}}\rightarrow\bbnum 0^{:M^{A}}+n)^{\uparrow G\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset

The two sides are now equal.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset

, with a recursion scheme given by a bifunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
bifunctor
\end_layout

\end_inset

 
\begin_inset Formula $S^{A,R}$
\end_inset

.
 In order to obtain the traversable property of 
\begin_inset Formula $L$
\end_inset

, we will need to assume that 
\begin_inset Formula $S$
\end_inset

 is traversable with respect to both its type parameters in a special way,
 which we call 
\begin_inset Quotes eld
\end_inset

bitraversable
\begin_inset Quotes erd
\end_inset

.
 It is not enough if 
\begin_inset Formula $S^{A,R}$
\end_inset

 is traversable with respect to each type parameter separately.
\end_layout

\begin_layout Standard
A bifunctor 
\begin_inset Formula $S^{A,B}$
\end_inset

 is called 
\series bold
bitraversable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
bitraversable bifunctor
\end_layout

\end_inset

 if it has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bisequence
\end_layout

\end_inset

 method (denoted by 
\begin_inset Formula $\text{seq2}_{S}$
\end_inset

):
\begin_inset Formula 
\[
\text{seq2}_{S}^{F,A,B}:S^{F^{A},F^{B}}\rightarrow F^{S^{A,B}}\quad,
\]

\end_inset

which is parameterized by an arbitrary applicative functor 
\begin_inset Formula $F$
\end_inset

 and is natural in 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

, and 
\begin_inset Formula $B$
\end_inset

.
 The traversable laws of identity
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
bisequence
\end_layout

\end_inset

 and composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of 
\family typewriter
bisequence
\end_layout

\end_inset

 must also hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bisequence
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align}
\text{identity law of }\text{seq2}_{S}:\quad & \text{seq2}_{S}^{\text{Id},A,B}=\text{id}^{:S^{A,B}\rightarrow S^{A,B}}\quad,\label{eq:identity-law-of-bisequence}\\
\text{composition law of }\text{seq2}_{S}:\quad & \text{seq2}_{S}^{F,G^{A},G^{B}}\bef\big(\text{seq2}_{S}^{G,A,B}\big)^{\uparrow F}=\text{seq2}_{S}^{F\circ G,A,B}\quad.\label{eq:composition-law-of-bisequence}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:All-polynomial-bifunctors-are-bitraversable"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show that all polynomial bifunctors are bitraversable.
 So, we are free to use any recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

 as long as 
\begin_inset Formula $S$
\end_inset

 is a polynomial bifunctor.
 For now, we assume that a lawful 
\begin_inset Formula $\text{seq2}_{S}$
\end_inset

 is available and define 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}:S^{F^{A},L^{F^{A}}}\rightarrow F^{S^{A,L^{A}}}\quad,\quad\quad\text{seq}_{L}^{F,A}\triangleq\big(\overline{\text{seq}}_{L}^{F,A}\big)^{\uparrow S^{F^{A},\bullet}}\bef\text{seq2}_{S}^{F,A,L^{A}}\quad.
\]

\end_inset

This definition uses a recursive call to 
\begin_inset Formula $\overline{\text{seq}}_{L}^{F,A}$
\end_inset

 lifted with respect to the type parameter 
\begin_inset Formula $R$
\end_inset

 of 
\begin_inset Formula $S^{A,R}$
\end_inset

.
 The inductive assumption is that the recursively called 
\begin_inset Formula $\overline{\text{seq}}_{L}^{F,A}$
\end_inset

 already obeys the laws we are proving.
\end_layout

\begin_layout Standard
To verify the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we use the assumed law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{seq}_{L}^{\text{Id},A}=\big(\overline{\text{seq}}_{L}^{\text{Id},A}\big)^{\uparrow S^{\text{Id}^{A},\bullet}}\bef\text{seq2}_{S}^{\text{Id},A,L^{A}}=\text{id}^{\uparrow S^{A,\bullet}}\bef\text{id}=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), write its two sides separately:
\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}=\big(\overline{\text{seq}}_{L}^{F,G^{A}}\big)^{\uparrow S^{F^{G^{A}},\bullet}}\bef\text{seq2}_{S}^{F,G^{A},L^{G^{A}}}\bef\big(\overline{\text{seq}}_{L}^{G,A}\big)^{\uparrow S^{G^{A},\bullet}\uparrow F}\bef\big(\text{seq2}_{S}^{G,A,L^{A}}\big)^{\uparrow F}\quad,\\
 & \text{seq}_{L}^{F\circ G,A}=\big(\overline{\text{seq}}_{L}^{F\circ G,A}\big)^{\uparrow S^{F^{G^{A}},\bullet}}\bef\text{seq2}_{S}^{F\circ G,A,L^{A}}\quad.
\end{align*}

\end_inset

We use the naturality law of 
\begin_inset Formula $\text{seq2}_{S}^{F,A,B}$
\end_inset

 with respect to the parameter 
\begin_inset Formula $B$
\end_inset

:
\begin_inset Formula 
\[
\text{seq2}_{S}^{F,A,B}\bef(f^{:B\rightarrow C})^{\uparrow S^{A,\bullet}\uparrow F}=f^{\uparrow F\uparrow S^{F^{A},\bullet}}\bef\text{seq2}_{S}^{F,A,C}\quad.
\]

\end_inset

Then the left-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes:
\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}\\
 & =\gunderline{\big(\overline{\text{seq}}_{L}^{F,G^{A}}\big)^{\uparrow S^{F^{G^{A}},\bullet}}\bef\big(\overline{\text{seq}}_{L}^{G,A}\big)^{\uparrow F\uparrow S^{F^{G^{A}},\bullet}}}\bef\text{seq2}_{S}^{F,G^{A},G^{L^{A}}}\bef\big(\text{seq2}_{S}^{G,A,L^{A}}\big)^{\uparrow F}\\
\text{composition law~(\ref{eq:composition-law-of-sequence})}:\quad & =(\text{seq}_{L}^{F\circ G,A})^{\uparrow S^{F^{G^{A}},\bullet}}\bef\gunderline{\text{seq2}_{S}^{F,G^{A},G^{L^{A}}}\bef\big(\text{seq2}_{S}^{G,A,L^{A}}\big)^{\uparrow F}}\\
\text{composition law~(\ref{eq:composition-law-of-bisequence})}:\quad & =(\text{seq}_{L}^{F\circ G,A})^{\uparrow S^{F^{G^{A}},\bullet}}\bef\gunderline{\text{seq2}_{S}^{F\circ G,A,L^{A}}}\quad.
\end{align*}

\end_inset

The two sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are now equal.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
These constructions allow us to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance automatically for any polynomial functor.
 The corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function will iterate in a naturally defined order over all values stored
 in the functor.
 To visualize the way 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 works, write a polynomial functor 
\begin_inset Formula $L$
\end_inset

 as:
\begin_inset Formula 
\[
L^{A}=Z_{0}+Z_{1}\times A+Z_{2}\times A\times A+...\quad,
\]

\end_inset

where 
\begin_inset Formula $Z_{0}$
\end_inset

, 
\begin_inset Formula $Z_{1}$
\end_inset

, ..., are fixed types.
 Any polynomial functor may be equivalently rewritten in this way, perhaps
 with an infinite number of parts in the disjunction.
 Each part of the disjunction is written as 
\begin_inset Formula $Z_{k}\times A\times...\times A$
\end_inset

 and contains a finite number 
\begin_inset Formula $k$
\end_inset

 of values of type 
\begin_inset Formula $A$
\end_inset

 and a value of a fixed type 
\begin_inset Formula $Z_{k}$
\end_inset

.
 The computation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse(f)
\end_layout

\end_inset

, where 
\begin_inset Formula $f$
\end_inset

 is a function of type 
\begin_inset Formula $A\rightarrow F^{B}$
\end_inset

, iterates over the 
\begin_inset Formula $k$
\end_inset

 values of type 
\begin_inset Formula $A$
\end_inset

 and merges the 
\begin_inset Formula $F$
\end_inset

-effects in the natural order using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 operation.
 This creates a value of type 
\begin_inset Formula $F^{B\times...\times B}$
\end_inset

.
 The constant value of type 
\begin_inset Formula $Z_{k}$
\end_inset

 is then lifted into 
\begin_inset Formula $F$
\end_inset

 to get the final value of type 
\begin_inset Formula $F^{Z_{k}\times B\times B\times...\times B}$
\end_inset

.
\end_layout

\begin_layout Standard
If the traversal order needs to be chosen differently, we will need to provide
 a custom implementation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance.
\end_layout

\begin_layout Standard
Functors that are not equivalent to polynomial functors are not traversable.
\begin_inset Foot
status open

\begin_layout Plain Layout
To prove that any traversable functor 
\emph on
must
\emph default
 be polynomial, one needs advanced methods beyond the scope of this book.
 See the paper by R.
\begin_inset space ~
\end_inset

Bird
\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bird
\end_layout

\end_inset

 et al.: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "http://www.cs.ox.ac.uk/jeremy.gibbons/publications/uitbaf.pdf"
target "http://www.cs.ox.ac.uk/jeremy.gibbons/publications/uitbaf.pdf"
literal "false"

\end_inset


\family default
 and the paper by M.
\begin_inset space ~
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Mauro Jaskelioff
\end_layout

\end_inset

Jaskelioff and R.
\begin_inset space ~
\end_inset

O'Connor: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/abs/1402.1699"
literal "false"

\end_inset


\end_layout

\end_inset

 As an example, consider the functors 
\begin_inset Formula $L^{A}\triangleq E\rightarrow A$
\end_inset

 and 
\begin_inset Formula $F^{A}\triangleq Z+A$
\end_inset

, where the types 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 are arbitrary but fixed.
 Then the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 
\begin_inset Formula $:L^{F^{B}}\rightarrow F^{L^{B}}$
\end_inset

 becomes 
\begin_inset Formula $(E\rightarrow Z+A)\rightarrow Z+(E\rightarrow A)$
\end_inset

, which is impossible to implement via a fully parametric function.
\end_layout

\begin_layout Subsection
All polynomial bifunctors are bitraversable
\begin_inset CommandInset label
LatexCommand label
name "subsec:All-polynomial-bifunctors-are-bitraversable"

\end_inset


\end_layout

\begin_layout Standard
Bitraversable bifunctors are used in the recursive-type construction for
 traversable functors.
 The properties of bitraversable bifunctors are similar to the properties
 of traversable functors.
 We will now prove that all polynomial bifunctors are bitraversable.
 The proof verifies that each of the five type constructions of polynomial
 bifunctors will produce a bitraversable bifunctor satisfying the laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Fixed type
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $S^{A,B}\triangleq Z$
\end_inset

 where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bisequence
\end_layout

\end_inset

 via 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method:
\begin_inset Formula 
\[
\text{seq2}_{S}^{F,A,B}:S^{F^{A},F^{B}}\rightarrow F^{S^{A,B}}\cong Z\rightarrow F^{Z}\quad,\quad\quad\text{seq2}_{S}^{F,A,B}\triangleq\text{pu}_{F}^{:Z\rightarrow F^{Z}}\quad.
\]

\end_inset

The identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds since 
\begin_inset Formula $\text{seq2}_{S}^{\text{Id},A,B}=\text{pu}_{\text{Id}}=\text{id}$
\end_inset

.
 To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{seq2}_{S}^{F,G^{A},G^{B}}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}=\text{pu}_{F}\bef(\text{pu}_{G})^{\uparrow F}\\
\text{naturality law of }\text{pu}_{F}:\quad & \quad=\text{pu}_{G}\bef\text{pu}_{F}\quad,\\
\text{right-hand side}:\quad & \text{seq2}_{S}^{F\circ G,A,B}=\text{pu}_{F\circ G}\\
\text{definition of }\text{pu}_{F\circ G}:\quad & \quad=\text{pu}_{G}\bef\text{pu}_{F}\quad.
\end{align*}

\end_inset

The two sides of the law are now equal.
\end_layout

\begin_layout Paragraph
Type parameter
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $S^{A,B}\triangleq A$
\end_inset

 or 
\begin_inset Formula $S^{A,B}\triangleq B$
\end_inset

, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bisequence
\end_layout

\end_inset

 as the identity function:
\begin_inset Formula 
\begin{align*}
\text{if }S^{A,B}\triangleq A:\quad & \text{seq2}_{S}^{F,A,B}\triangleq\text{id}^{:F^{A}\rightarrow F^{A}}\quad,\\
\text{if }S^{A,B}\triangleq B:\quad & \text{seq2}_{S}^{F,A,B}\triangleq\text{id}^{:F^{B}\rightarrow F^{B}}\quad.
\end{align*}

\end_inset

Identity functions always satisfy identity and composition laws.
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $S^{A,B}\triangleq M^{A,B}\times N^{A,B}$
\end_inset

, with some bitraversable bifunctors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 We assume that 
\begin_inset Formula $\text{seq2}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq2}_{N}$
\end_inset

 are already available and satisfy the laws, and define 
\begin_inset Formula $\text{seq2}_{S}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{seq2}_{S}^{F,A,B}:M^{F^{A},F^{B}}\times N^{F^{A},F^{B}}\rightarrow F^{M^{A,B}\times N^{A,B}}\quad,\quad\quad\text{seq2}_{S}^{F,A,B}\triangleq(\text{seq2}_{M}^{F,A,B}\boxtimes\text{seq2}_{N}^{F,A,B})\bef\text{zip}_{F}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), use the fact that 
\begin_inset Formula $\text{zip}_{\text{Id}}=\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{seq2}_{S}^{\text{Id},A,B}=(\gunderline{\text{seq2}_{M}^{\text{Id},A,B}}\boxtimes\gunderline{\text{seq2}_{N}^{\text{Id},A,B}})\bef\text{zip}_{\text{Id}}\\
\text{identity laws of }\text{seq2}_{M}\text{ and }\text{seq2}_{N}:\quad & =(\text{id}\boxtimes\text{id})=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), begin with its left-hand side:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{seq2}_{S}^{F,G^{A},G^{B}}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}\\
 & =(\text{seq2}_{M}^{F,G^{A},G^{B}}\boxtimes\text{seq2}_{N}^{F,G^{A},G^{B}})\bef\gunderline{\text{zip}_{F}\bef(\text{seq2}_{M}^{G,A,B}\boxtimes\text{seq2}_{N}^{G,A,B})^{\uparrow F}}\bef\text{zip}_{G}^{\uparrow F}\\
\text{naturality of }\text{zip}_{F}:\quad & =\gunderline{(\text{seq2}_{M}^{F,G^{A},G^{B}}\boxtimes\text{seq2}_{N}^{F,G^{A},G^{B}})\bef\big((\text{seq2}_{M}^{G,A,B})^{\uparrow F}\boxtimes(\text{seq2}_{N}^{G,A,B})^{\uparrow F}\big)}\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\\
\text{the law~(\ref{eq:pair-product-composition-law})}:\quad & =\big((\text{seq2}_{M}^{F,G^{A},G^{B}}\bef(\text{seq2}_{M}^{G,A,B})^{\uparrow F})\boxtimes(\text{seq2}_{N}^{F,G^{A},G^{B}}\bef(\text{seq2}_{N}^{G,A,B})^{\uparrow F})\big)\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\quad.
\end{align*}

\end_inset

By assumption, 
\begin_inset Formula $\text{seq2}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq2}_{N}$
\end_inset

 satisfy their composition laws.
 So, we may rewrite the last line as:
\begin_inset Formula 
\[
\text{seq2}_{S}^{F,G^{A},G^{B}}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}=\big(\text{seq2}_{M}^{F\circ G,A,B}\boxtimes\text{seq2}_{N}^{F\circ G,A,B}\big)\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\quad.
\]

\end_inset

We can now transform the right-hand side of the law to the same expression:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & \text{seq2}_{S}^{F\circ G,A,B}=\big(\text{seq2}_{M}^{F\circ G,A,B}\boxtimes\text{seq2}_{N}^{F\circ G,A,B}\big)\bef\text{zip}_{F\circ G}\\
\text{definition of }\text{zip}_{F\circ G}:\quad & =\big(\text{seq2}_{M}^{F\circ G,A,B}\boxtimes\text{seq2}_{N}^{F\circ G,A,B}\big)\bef\text{zip}_{F}\bef\text{zip}_{G}^{\uparrow F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $S^{A,B}\triangleq M^{A,B}+N^{A,B}$
\end_inset

, with some bitraversable bifunctors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 We assume that 
\begin_inset Formula $\text{seq2}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq2}_{N}$
\end_inset

 are already available and satisfy the laws, and define 
\begin_inset Formula $\text{seq2}_{S}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{seq2}_{S}:M^{F^{A},F^{B}}+N^{F^{A},F^{B}}\rightarrow F^{M^{A,B}+N^{A,B}}\quad,\quad\text{seq2}_{S}\triangleq\,\begin{array}{|c||c|}
 & F^{M^{A,B}+N^{A,B}}\\
\hline M^{F^{A},F^{B}} & \text{seq2}_{M}^{F,A,B}\bef(m^{:M^{A,B}}\rightarrow m+\bbnum 0)^{\uparrow F}\\
N^{F^{A},F^{B}} & \text{seq2}_{N}^{F,A,B}\bef(n^{:N^{A,B}}\rightarrow\bbnum 0+n)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{seq2}_{S}^{\text{Id},A}=\,\begin{array}{|c||c|}
 & M^{A,B}+N^{A,B}\\
\hline M^{\text{Id}^{A},\text{Id}^{B}} & \text{seq2}_{M}^{\text{Id},A,B}\bef(m\rightarrow m+\bbnum 0)^{\uparrow\text{Id}}\\
N^{\text{Id}^{A}} & \text{seq2}_{N}^{\text{Id},A,B}\bef(n\rightarrow\bbnum 0+n)^{\uparrow\text{Id}}
\end{array}\\
\text{identity laws of }\text{seq2}_{M}\text{ and }\text{seq2}_{N}:\quad & =\,\begin{array}{|c||c|}
 & M^{A,B}+N^{A,B}\\
\hline M^{A,B} & m\rightarrow m+\bbnum 0\\
N^{A,B} & n\rightarrow\bbnum 0+n
\end{array}\,=\,\begin{array}{|c||cc|}
 & M^{A,B} & N^{A,B}\\
\hline M^{A,B} & m\rightarrow m & \bbnum 0\\
N^{A,B} & \bbnum 0 & n\rightarrow n
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{seq2}_{S}^{F,G^{A},G^{B}}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}=\,\begin{array}{||c|}
\text{seq2}_{M}^{F,G^{A},G^{B}}\bef(m\rightarrow m+\bbnum 0)^{\uparrow F}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}\\
\text{seq2}_{N}^{F,G^{A},G^{B}}\bef(n\rightarrow\bbnum 0+n)^{\uparrow F}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}
\end{array}\quad,\\
\text{right-hand side}:\quad & \text{seq2}_{S}^{F\circ G,A,B}=\,\begin{array}{||c|}
\text{seq2}_{M}^{F\circ G,A,B}\bef(m\rightarrow m+\bbnum 0)^{\uparrow G\uparrow F}\\
\text{seq2}_{N}^{F\circ G,A,B}\bef(n\rightarrow\bbnum 0+n)^{\uparrow G\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
The
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 left-hand side contains some function compositions lifted to 
\begin_inset Formula $F$
\end_inset

.
 Write them separately:
\begin_inset Formula 
\begin{align*}
 & (m\rightarrow m+\bbnum 0)\bef\text{seq2}_{S}^{G,A,B}=\,\begin{array}{|c||cc|}
 & M^{G^{A},G^{B}} & N^{G^{A},G^{B}}\\
\hline M^{G^{A},G^{B}} & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||c|}
 & G^{M^{A,B}+N^{A,B}}\\
\hline M^{G^{A},G^{B}} & \text{seq2}_{M}^{G,A,B}\bef(m\rightarrow m+\bbnum 0)^{\uparrow G}\\
N^{G^{A},G^{B}} & \text{seq2}_{N}^{G,A,B}\bef(n\rightarrow\bbnum 0+n)^{\uparrow G}
\end{array}\\
 & \quad=\text{seq2}_{M}^{G,A,B}\bef(m^{:M^{A,B}}\rightarrow m+\bbnum 0^{:N^{A,B}})^{\uparrow G}\quad,\\
 & (n\rightarrow\bbnum 0+n)\bef\text{seq2}_{S}^{G,A,B}=\,\begin{array}{|c||cc|}
 & M^{G^{A},G^{B}} & N^{G^{A},G^{B}}\\
\hline N^{G^{A},G^{B}} & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & G^{M^{A,B}+N^{A,B}}\\
\hline M^{G^{A},G^{B}} & \text{seq2}_{M}^{G,A,B}\bef(m\rightarrow m+\bbnum 0)^{\uparrow G}\\
N^{G^{A},G^{B}} & \text{seq2}_{N}^{G,A,B}\bef(n\rightarrow\bbnum 0+n)^{\uparrow G}
\end{array}\\
 & \quad=\text{seq2}_{N}^{G,A,B}\bef(n^{:N^{A,B}}\rightarrow\bbnum 0^{:M^{A,B}}+n)^{\uparrow G}\quad.
\end{align*}

\end_inset

We then simplify the left-hand side using the composition laws of 
\begin_inset Formula $\text{seq2}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{seq2}_{N}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{seq2}_{S}^{F,G^{A},G^{B}}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}=\,\begin{array}{||c|}
\gunderline{\text{seq2}_{M}^{F,G^{A},G^{B}}\bef(\text{seq2}_{M}^{G,A,B})^{\uparrow F}}\bef(m\rightarrow m+\bbnum 0)^{\uparrow G\uparrow F}\\
\gunderline{\text{seq2}_{N}^{F,G^{A},G^{B}}\bef(\text{seq2}_{N}^{G,A,B})^{\uparrow F}}\bef(n\rightarrow\bbnum 0+n)^{\uparrow G\uparrow F}
\end{array}\\
 & =\,\begin{array}{||c|}
\text{seq2}_{M}^{F\circ G,A,B}\bef(m\rightarrow m+\bbnum 0)^{\uparrow G\uparrow F}\\
\text{seq2}_{N}^{F\circ G,A,B}\bef(n\rightarrow\bbnum 0+n)^{\uparrow G\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset

The two sides are now equal.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $S^{A,B}\triangleq T^{A,B,S^{A,B}}$
\end_inset

, with a recursion scheme given by a 
\series bold
3-functor
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
3@3-functor
\end_layout

\end_inset


\begin_inset Formula $T^{A,B,R}$
\end_inset

 (a type constructor covariant in each of its three type parameters).
 To show that 
\begin_inset Formula $S$
\end_inset

 is bitraversable, we need to assume that 
\begin_inset Formula $T$
\end_inset

 is traversable with respect to all its type parameters at once, which we
 call 
\begin_inset Quotes eld
\end_inset

3-traversable
\begin_inset Quotes erd
\end_inset

.
 We say that a 3-functor 
\begin_inset Formula $T^{A,B,R}$
\end_inset

 is 
\series bold
3-traversable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
3@3-traversable 3-functor
\end_layout

\end_inset

 if it has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence3
\end_layout

\end_inset

 method:
\begin_inset Formula 
\[
\text{seq3}_{T}^{F,A,B,C}:T^{F^{A},F^{B},F^{C}}\rightarrow F^{T^{A,B,C}}\quad,
\]

\end_inset

which is parameterized by an arbitrary applicative functor 
\begin_inset Formula $F$
\end_inset

 and is natural in 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, and 
\begin_inset Formula $C$
\end_inset

.
 The traversable laws of identity
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
sequence3
\end_layout

\end_inset

 and composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of 
\family typewriter
sequence3
\end_layout

\end_inset

 must also hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence3
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align}
\text{identity law of }\text{seq3}_{T}:\quad & \text{seq3}_{T}^{\text{Id},A,B,C}=\text{id}^{:T^{A,B,C}\rightarrow T^{A,B,C}}\quad,\label{eq:identity-law-of-trisequence}\\
\text{composition law of }\text{seq3}_{T}:\quad & \text{seq3}_{T}^{F,G^{A},G^{B},G^{C}}\bef\big(\text{seq3}_{T}^{G,A,B,C}\big)^{\uparrow F}=\text{seq3}_{T}^{F\circ G,A,B,C}\quad.\label{eq:composition-law-of-trisequence}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
To prove that all polynomial 3-functors are 3-traversable, we would need
 to repeat the proofs in this section with more type parameters.
 The recursive type construction for 3-traversable 3-functors will require
 a 4-traversable 4-functor as a recursion scheme.
 To prove that all polynomial 4-functors are 4-traversable, we will need
 to use 5-traversable 5-functors, and so on.
 Note that the proofs in this section differ from the proofs in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:All-polynomial-functors-are-traversable"
plural "false"
caps "false"
noprefix "false"

\end_inset

 only in having more type parameters in the functions.
 So, the proofs for 3-traversable 3-functors, 4-traversable 4-functors,
 etc., will remain essentially the same as the proofs for bitraversable bifunctor
s except for having more type parameters in each function.
 For this reason, we omit those proofs.
 The conclusion will be that all polynomial 
\begin_inset Formula $n$
\end_inset

-functors are 
\begin_inset Formula $n$
\end_inset

-traversable for 
\begin_inset Formula $n=1,2,3,...$
\end_inset


\end_layout

\begin_layout Standard
Assume that a lawful 
\begin_inset Formula $\text{seq3}_{T}$
\end_inset

 is available and define 
\begin_inset Formula $\text{seq2}_{S}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{seq2}_{S}^{F,A,B}:T^{F^{A},F^{B},S^{F^{A},F^{B}}}\rightarrow F^{T^{A,B,S^{A,B}}}\quad,\quad\quad\text{seq2}_{S}^{F,A,B}\triangleq\big(\overline{\text{seq2}}_{S}^{F,A,B}\big)^{\uparrow T^{F^{A},F^{B},\bullet}}\bef\text{seq3}_{T}^{F,A,B,S^{A,B}}\quad.
\]

\end_inset

The inductive assumption is that the recursively called 
\begin_inset Formula $\overline{\text{seq2}}_{S}$
\end_inset

 already obeys the laws we are proving.
\end_layout

\begin_layout Standard
To verify the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we use the assumed law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-trisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{seq2}_{S}^{\text{Id},A,B}=\big(\overline{\text{seq2}}_{S}^{\text{Id},A,B}\big)^{\uparrow T^{\text{Id}^{A},\text{Id}^{B},\bullet}}\bef\text{seq3}_{T}^{\text{Id},A,B,S^{A,B}}=\text{id}^{\uparrow T^{A,B,\bullet}}\bef\text{id}=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{seq2}_{S}^{F,G^{A},G^{B}}\bef(\text{seq2}_{S}^{G,A,B})^{\uparrow F}\\
 & \quad=\big(\overline{\text{seq2}}_{S}^{F,G^{A},G^{B}}\big)^{\uparrow T^{F^{G^{A}},F^{G^{B}},\bullet}}\bef\text{seq3}_{T}^{F,G^{A},G^{B},S^{G^{A},G^{B}}}\bef\big(\overline{\text{seq2}}_{S}^{G,A,B}\big)^{\uparrow T^{G^{A},G^{B},\bullet}\uparrow F}\bef\big(\text{seq3}_{T}^{G,A,B,S^{A,B}}\big)^{\uparrow F}\quad,\\
 & \text{seq2}_{S}^{F\circ G,A,B}=\big(\overline{\text{seq2}}_{S}^{F\circ G,A,B}\big)^{\uparrow T^{F^{G^{A}},F^{G^{B}},\bullet}}\bef\text{seq3}_{T}^{F\circ G,A,B,S^{A,B}}\quad.
\end{align*}

\end_inset

We use the naturality law of 
\begin_inset Formula $\text{seq3}_{T}^{F,A,B,C}$
\end_inset

 with respect to the parameter 
\begin_inset Formula $C$
\end_inset

:
\begin_inset Formula 
\[
\text{seq3}_{T}^{F,A,B,C}\bef(f^{:C\rightarrow D})^{\uparrow T^{A,B,\bullet}\uparrow F}=f^{\uparrow F\uparrow T^{F^{A},F^{B},\bullet}}\bef\text{seq3}_{T}^{F,A,B,D}\quad.
\]

\end_inset

Then the left-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes:
\begin_inset Formula 
\begin{align*}
\text{seq2}_{S}^{F,G^{A},G^{B}}\bef & (\text{seq2}_{S}^{G,A,B})^{\uparrow F}\\
 & =\gunderline{\big(\overline{\text{seq2}}_{S}^{F,G^{A},G^{B}}\big)^{\uparrow T^{F^{G^{A}},F^{G^{B}},\bullet}}\bef\big(\overline{\text{seq2}}_{S}^{G,A,B}\big)^{\uparrow F\uparrow T^{F^{G^{A}},F^{G^{B}},\bullet}}}\bef\text{seq3}_{T}^{F,G^{A},G^{B},G^{S^{A,B}}}\bef\big(\text{seq3}_{T}^{G,A,B,S^{A,B}}\big)^{\uparrow F}\\
\text{Eq.~(\ref{eq:identity-law-of-bisequence})}:\quad & =(\text{seq2}_{S}^{F\circ G,A,B})^{\uparrow T^{F^{G^{A}},F^{G^{B}},\bullet}}\bef\gunderline{\text{seq3}_{T}^{F,G^{A},G^{B},G^{S^{A,B}}}\bef\big(\text{seq3}_{T}^{G,A,B,S^{A,B}}\big)^{\uparrow F}}\\
\text{Eq.~(\ref{eq:composition-law-of-trisequence})}:\quad & =(\text{seq2}_{S}^{F\circ G,A,B})^{\uparrow T^{F^{G^{A}},F^{G^{B}},\bullet}}\bef\gunderline{\text{seq3}_{T}^{F\circ G,A,B,S^{A,B}}}\quad.
\end{align*}

\end_inset

The two sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-bisequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are now equal.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that any traversable functor 
\begin_inset Formula $L$
\end_inset

 admits a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{consume}_{L}:(L^{A}\rightarrow B)\rightarrow L^{F^{A}}\rightarrow F^{B}\quad,
\]

\end_inset

defined for any applicative functor 
\begin_inset Formula $F$
\end_inset

.
 Assuming a suitable naturality law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

, show that the types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

consume
\end_layout

\end_inset

 are equivalent.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-3-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-3-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the following implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for the functor 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def badtrav[A, B, F[_]: Applicative : Functor](f: A => F[B]): Option[(A,
 A)] => F[Option[(B, B)]] =
\end_layout

\begin_layout Plain Layout

  Applicative[F].pure(None)
\end_layout

\end_inset

Show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

badtrav
\end_layout

\end_inset

 does 
\emph on
not
\emph default
 satisfy the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the laws are 
\emph on
not
\emph default
 satisfied by the implementation of 
\begin_inset Formula $\text{seq}:L^{F^{A}}\rightarrow F^{L^{A}}$
\end_inset

 for 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

seq
\end_layout

\end_inset

 always returns an empty option (
\begin_inset Formula $1+\bbnum 0$
\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 in Scala).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $L^{A}\triangleq A\times A$
\end_inset

, consider 
\begin_inset Formula $\text{seq}_{L}^{F,A}$
\end_inset

 which collects the 
\begin_inset Formula $F$
\end_inset

-effects in the opposite order:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def seq[F[_]: Applicative : Functor, A]: ((F[A], F[A])) => F[(A, A)] = {
\end_layout

\begin_layout Plain Layout

  case (fa1, fa2) => (fa2 zip fa1).map(_.swap) // Use `swap` to restore the
 order of wrapped values.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the point-free style, this code is written as:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}:F^{A}\times F^{A}\rightarrow F^{A\times A}\quad,\quad\quad\text{seq}_{L}^{F,A}\triangleq\text{swap}\bef\text{zip}_{F}\bef\text{swap}^{\uparrow F}\quad.
\]

\end_inset

Prove that this implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 satisfies its laws.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find an example of an applicative functor 
\begin_inset Formula $F$
\end_inset

 and a traversable functor 
\begin_inset Formula $L$
\end_inset

 such that one 
\emph on
cannot
\emph default
 implement a natural transformation with type signature 
\begin_inset Formula $F^{L^{A}}\rightarrow L^{F^{A}}$
\end_inset

 (the inverse to the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-laws-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:sequence-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 is equivalent to the two naturality laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-laws-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-laws-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-tr-equivalent-to-ftr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tr
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ftr
\end_layout

\end_inset

 are equivalent if a naturality law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ftr
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 Under the same assumption, show that the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ftr
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset Formula $B$
\end_inset

 is equivalent to the naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tr
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-laws-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-foldleft-foldmap-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) shows that functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

 are equivalent.
 Show that the monoidal naturality law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 if it holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduceE
\end_layout

\end_inset

, and vice versa.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove that 
\begin_inset Formula $L^{A}\triangleq M^{N^{A}}$
\end_inset

 is a lawful traversable if 
\begin_inset Formula $M^{\bullet}$
\end_inset

 and 
\begin_inset Formula $N^{\bullet}$
\end_inset

 are traversable functors.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove directly that all the bitraversable laws hold for the bifunctor 
\begin_inset Formula $S^{A,B}\triangleq A\times B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the tree-like type defined as 
\begin_inset Formula $T^{A}\triangleq\bbnum 1+A\times T^{A}\times T^{A}$
\end_inset

, define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance.
 Verify that the laws hold by using a suitable recursion scheme 
\begin_inset Formula $S^{A,R}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Is the recursive type constructor 
\begin_inset Formula $L^{A}\triangleq A+L^{\text{List}^{A}}$
\end_inset

 traversable? Explain via examples what sort of data container it is.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove that for any two monoid morphisms 
\begin_inset Formula $\phi:M\rightarrow N$
\end_inset

 and 
\begin_inset Formula $\psi:N\rightarrow P$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

, and 
\begin_inset Formula $P$
\end_inset

 are monoids), the composition 
\begin_inset Formula $\phi\bef\psi:M\rightarrow P$
\end_inset

 is again a lawful monoid morphism.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-laws-2-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-laws-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any applicative functor 
\begin_inset Formula $F$
\end_inset

, Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-pure-is-applicative-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\text{pu}_{F}:A\rightarrow F^{A}$
\end_inset

 is an applicative morphism between 
\begin_inset Formula $\text{Id}$
\end_inset

 and 
\begin_inset Formula $F$
\end_inset

.
 Prove that 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 is the 
\emph on
only
\emph default
 such morphism.
 (In terms of category theory, the identity functor is an initial object
 in the category of applicative functors
\begin_inset Index idx
status open

\begin_layout Plain Layout
category of applicative functors!initial object
\end_layout

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\emph on
monad
\emph default
 
\begin_inset Formula $M^{\bullet}$
\end_inset

 and a monoid morphism 
\begin_inset Formula $\phi:R\rightarrow S$
\end_inset

 between some monoid types 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, prove that 
\begin_inset Formula $\phi^{\uparrow M}:M^{R}\rightarrow M^{S}$
\end_inset

 is also a monoid morphism.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monoid type 
\begin_inset Formula $R$
\end_inset

 and a 
\emph on
monad
\emph default
 morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between some monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, prove that 
\begin_inset Formula $\phi:M^{R}\rightarrow N^{R}$
\end_inset

 is a monoid morphism between 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-1-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Each monad has at the same time an applicative functor instance.
 Given a monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between two monads, show that 
\begin_inset Formula $\phi$
\end_inset

 is also an applicative morphism between applicative functors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the converse does not hold: if 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 is an applicative morphism between two monads then 
\begin_inset Formula $\phi$
\end_inset

 is 
\emph on
not
\emph default
 necessarily a monad morphism.
 One example is where 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monads ***???
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given an applicative functor 
\begin_inset Formula $M$
\end_inset

 and a monoid morphism 
\begin_inset Formula $\phi:R\rightarrow S$
\end_inset

 between some monoid types 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, prove that 
\begin_inset Formula $\phi^{\uparrow M}:M^{R}\rightarrow M^{S}$
\end_inset

 is also a monoid morphism.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $M^{S}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monoid type 
\begin_inset Formula $R$
\end_inset

 and an applicative morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between some applicative functors 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, prove that 
\begin_inset Formula $\phi:M^{R}\rightarrow N^{R}$
\end_inset

 is a monoid morphism between 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

.
 (The types 
\begin_inset Formula $M^{R}$
\end_inset

 and 
\begin_inset Formula $N^{R}$
\end_inset

 are monoids due to Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-applicative-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-traversables-10-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monoid 
\begin_inset Formula $M$
\end_inset

, define the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outMF
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{inMF}:M\rightarrow M\rightarrow M\quad,\quad\quad\text{inMF}\,(x^{:M})\triangleq y^{:M}\rightarrow x\oplus y\quad,\\
 & \text{outMF}:(M\rightarrow M)\rightarrow M\quad,\quad\quad\text{outMF}\,(p^{:M\rightarrow M})\triangleq p(e_{M})\quad.
\end{align*}

\end_inset

This definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is similar to that used in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-foldleft-foldmap-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c).
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inMF
\end_layout

\end_inset

 is a monoid morphism between 
\begin_inset Formula $M$
\end_inset

 and the monoid 
\begin_inset Formula $\text{MF}^{M}$
\end_inset

 consisting of all functions of type 
\begin_inset Formula $M\rightarrow M$
\end_inset

.
 Define the empty element and the binary operation of 
\begin_inset Formula $\text{MF}^{M}$
\end_inset

 appropriately.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Prove that 
\begin_inset Formula $\text{inMF}\bef\text{outMF}=\text{id}$
\end_inset

 but 
\begin_inset Formula $\text{outMF}\bef\text{inMF}\neq\text{id}$
\end_inset

.
 (Give an example of a monoid 
\begin_inset Formula $M$
\end_inset

 where the second equation does not hold.)
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outMF
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 a monoid morphism between 
\begin_inset Formula $\text{MF}^{M}$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Section
Discussion and further developments
\end_layout

\begin_layout Subsection
Laws of 
\family typewriter
traverse
\family default
 and properties of 
\family typewriter
zipWithIndex
\family default

\begin_inset CommandInset label
LatexCommand label
name "subsec:Laws-of-traverse-and-zipWithIndex"

\end_inset


\end_layout

\begin_layout Standard
Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Decorating-a-tree1"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Decorating-a-tree-breadth-first-traversal"
plural "false"
caps "false"
noprefix "false"

\end_inset

 defined the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 for different orders of tree traversal.
 In a similar way, we may define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\text{zwi}_{L}$
\end_inset

 for brevity) for any traversable functor 
\begin_inset Formula $L$
\end_inset

.
 In this section, we will prove some intuitively reasonable properties of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 by assuming only that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 hold.
 This will serve as an additional evidence that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 correspond to a programmer's intuitions about code.
\end_layout

\begin_layout Standard
To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 for 
\begin_inset Formula $L$
\end_inset

, we use 
\begin_inset Formula $L$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method (
\begin_inset Formula $\text{trav}_{L}^{F,A,B}$
\end_inset

) and chose the applicative functor 
\begin_inset Formula $F$
\end_inset

 as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad with internal state of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

:
\begin_inset Formula 
\[
F^{A}\triangleq\text{State}^{\text{Int},A}\triangleq\text{Int}\rightarrow A\times\text{Int}\quad.
\]

\end_inset

The internal state represents a current value of the index.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 to a function of type 
\begin_inset Formula $A\rightarrow\text{State}^{S,A\times\text{Int}}$
\end_inset

 that increments the index:
\begin_inset Formula 
\begin{equation}
\text{zwi}_{L}^{A}:L^{A}\rightarrow L^{A\times\text{Int}}\quad,\quad\text{zwi}_{L}^{A}\triangleq\text{trav}_{L}^{F,A,A\times\text{Int}}(a^{:A}\rightarrow s^{:\text{Int}}\rightarrow(a\times s)\times(s+1))\bef\text{run}_{\text{State}}(0^{:\text{Int}})\quad,\label{eq:definition-of-zwi}
\end{equation}

\end_inset

Here 
\begin_inset Formula $\text{run}_{\text{State}}(0^{:\text{Int}})$
\end_inset

 is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's runner defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-runState"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and applied to the zero integer value 
\begin_inset Formula $0^{:\text{Int}}$
\end_inset

:
\begin_inset Formula 
\[
\text{run}_{\text{State}}:S\rightarrow\text{State}^{S,A}\rightarrow A\quad,\quad\quad\text{run}_{\text{State}}(s_{0})\triangleq k^{:S\rightarrow A\times S}\rightarrow s_{0}\triangleright k\triangleright\pi_{1}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
What are a programmer's intuitive expectations about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 when applied to arbitrary traversable functors 
\begin_inset Formula $L$
\end_inset

? First, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 applied to a value 
\begin_inset Formula $p:L^{A}$
\end_inset

 should produce a value of type 
\begin_inset Formula $L^{A\times\text{Int}}$
\end_inset

 that preserves the structure of 
\begin_inset Formula $p$
\end_inset

 and just adds indices at places where some data of type 
\begin_inset Formula $A$
\end_inset

 is stored within 
\begin_inset Formula $p$
\end_inset

.
 Second, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 should produce a 
\emph on
different
\emph default
 index for every value of type 
\begin_inset Formula $A$
\end_inset

 stored within 
\begin_inset Formula $p$
\end_inset

.
 Let us now formulate those intuitions as equations that rigorously express
 the expected properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The first property is that the value 
\begin_inset Formula $p:L^{A}$
\end_inset

 must be restored if we remove the index values:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

p.zipWithIndex.map(_._1) == p
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Formula 
\[
p\triangleright\text{zwi}_{L}\triangleright\pi_{1}^{\uparrow L}=p\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The second property means that each index can be mapped to a distinct value
 of type 
\begin_inset Formula $A$
\end_inset

 stored within 
\begin_inset Formula $p$
\end_inset

.
 Begin by computing a value 
\begin_inset Formula $q\triangleq p\triangleright\text{zwi}_{L}\triangleright\pi_{2}^{\uparrow L}$
\end_inset

 of type 
\begin_inset Formula $L^{\text{Int}}$
\end_inset

.
 Then 
\begin_inset Formula $q$
\end_inset

 has the same structure as 
\begin_inset Formula $p$
\end_inset

 but carries integer index values instead of values of type 
\begin_inset Formula $A$
\end_inset

.
 We expect that the original data (
\begin_inset Formula $p$
\end_inset

) can be restored if we replace the index values in 
\begin_inset Formula $q$
\end_inset

 by the corresponding values of type 
\begin_inset Formula $A$
\end_inset

.
 In other words, there should exist a function 
\begin_inset Formula $f:\text{Int}\rightarrow A$
\end_inset

 such that 
\begin_inset Formula $p$
\end_inset

 can be restored from 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 as 
\begin_inset Formula $p=q\triangleright f^{\uparrow L}$
\end_inset

.
 This also means that there should be an injective map from the type 
\begin_inset Formula $L^{A}$
\end_inset

 to the type 
\begin_inset Formula $(\text{Int}\rightarrow A)\times L^{\text{Int}}$
\end_inset

.
\end_layout

\begin_layout Standard
We will now prove the first property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

, assuming only that 
\begin_inset Formula $L$
\end_inset

 is a lawful traversable functor.
 In that proof, we will need a special subtype of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-constant-value-state-monad"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-constant-value-state-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
We define a 
\begin_inset Quotes eld
\end_inset

constant-function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad
\begin_inset Quotes erd
\end_inset

, denoted by 
\begin_inset Formula $\text{CFState}^{S,A}$
\end_inset

, like this: Write the type of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad equivalently as 
\begin_inset Formula $\text{State}^{S,A}\triangleq S\rightarrow A\times S\cong(S\rightarrow A)\times(S\rightarrow S)$
\end_inset

 and consider values of that type, 
\begin_inset Formula $p^{:S\rightarrow A}\times q^{:S\rightarrow S}$
\end_inset

, such that 
\begin_inset Formula $p^{:S\rightarrow A}$
\end_inset

 is a
\emph on
 constant
\emph default
 function (independent of its argument).
 In other words, the wrapped value of type 
\begin_inset Formula $A$
\end_inset

 is independent of the state value of type 
\begin_inset Formula $S$
\end_inset

.
 This defines a subset of all possible values of type 
\begin_inset Formula $\text{State}^{S,A}$
\end_inset

.
 We call that subset 
\begin_inset Formula $\text{CFState}^{S,A}$
\end_inset

 and write: 
\begin_inset Formula 
\[
\text{CFState}^{S,A}\triangleq(\_^{:S}\rightarrow A)\times(S\rightarrow S)\quad.
\]

\end_inset

This is a subtype of 
\begin_inset Formula $\text{State}^{S,A}$
\end_inset

 because there is a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

 of type 
\begin_inset Formula $\text{CFState}^{S,A}\rightarrow\text{State}^{S,A}$
\end_inset

 that is an identity function that merely reassigns types:
\begin_inset Formula 
\[
\text{fromCF}:(\_^{:S}\rightarrow A)\times(S\rightarrow S)\rightarrow(S\rightarrow A)\times(S\rightarrow S)\quad,\quad\quad\text{fromCF}\triangleq p^{:\_\rightarrow A}\times q^{:S\rightarrow S}\rightarrow p^{:S\rightarrow A}\times q^{:S\rightarrow S}\quad.
\]

\end_inset

Assuming that 
\begin_inset Formula $S$
\end_inset

 is not a void type, we then have the following properties:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The type 
\begin_inset Formula $\text{CFState}^{S,A}$
\end_inset

 is a monad with the same implementation code as 
\begin_inset Formula $\text{State}^{S,A}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

 is an injective monad morphism and applicative morphism.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CFState
\end_layout

\end_inset

 has a runner, 
\begin_inset Formula $\text{run}_{\text{CFState}}:\text{CFState}^{S,A}\rightarrow A$
\end_inset

, defined by:
\begin_inset Formula 
\[
\text{run}_{\text{CFState}}\triangleq\text{fromCF}\bef\text{run}_{\text{State}}(s_{0})\quad,
\]

\end_inset

where 
\begin_inset Formula $s_{0}^{:S}$
\end_inset

 is a fixed value.
 The function 
\begin_inset Formula $\text{run}_{\text{CFState}}$
\end_inset

 is the same for all choices of 
\begin_inset Formula $s_{0}$
\end_inset

 and is both a monad morphism and an applicative morphism.
 (Note that 
\begin_inset Formula $\text{run}_{\text{State}}(s_{0})$
\end_inset

 is neither a monad morphism nor an applicative morphism of type 
\begin_inset Formula $\text{State}^{S,A}\rightarrow A$
\end_inset

.) 
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 The monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CFState
\end_layout

\end_inset

 is equivalent to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad.
 There exists a one-to-one (bijective) monad morphism 
\begin_inset Formula $\text{CFState}^{S,A}\rightarrow\text{Writer}^{W,A}$
\end_inset

 where 
\begin_inset Formula $\text{Writer}^{W,A}\triangleq A\times W$
\end_inset

 and the type 
\begin_inset Formula $W\triangleq S\rightarrow S$
\end_inset

 is a function composition monoid (denoted by 
\begin_inset Formula $\text{MF}^{S}$
\end_inset

 in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-foldleft-foldmap-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Rewrite the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's methods 
\begin_inset Formula $\text{pu}_{\text{State}}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{\text{State}}$
\end_inset

 using the equivalent type signature 
\begin_inset Formula $\text{State}^{S,A}\cong(S\rightarrow A)\times(S\rightarrow S)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{\text{State}}:A\rightarrow(S\rightarrow A)\times(S\rightarrow S)\quad,\quad\quad\text{pu}_{\text{State}}=a^{:A}\rightarrow(\_^{:S}\rightarrow a)\times\text{id}^{:S\rightarrow S}\quad,\\
 & \text{ftn}_{\text{State}}:(S\rightarrow(S\rightarrow A)\times(S\rightarrow S))\times(S\rightarrow S)\rightarrow(S\rightarrow A)\times(S\rightarrow S)\quad,\\
 & \text{ftn}_{\text{State}}=p^{:S\rightarrow(S\rightarrow A)\times(S\rightarrow S)}\times q^{:S\rightarrow S}\rightarrow(s^{:S}\rightarrow s\triangleright q\triangleright(s\triangleright p\triangleright\pi_{1}))\times(s^{:S}\rightarrow s\triangleright q\triangleright(s\triangleright p\triangleright\pi_{2}))\quad.
\end{align*}

\end_inset

The code of 
\begin_inset Formula $\text{pu}_{\text{State}}$
\end_inset

 is already of type 
\begin_inset Formula $A\rightarrow\text{CFState}^{S,A}$
\end_inset

 because 
\begin_inset Formula $\text{pu}_{\text{State}}(a)$
\end_inset

 returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad containing a constant function (
\begin_inset Formula $\_^{:S}\rightarrow A$
\end_inset

).
 It remains to check that 
\begin_inset Formula $\text{ftn}_{\text{State}}$
\end_inset

 returns values of the subtype 
\begin_inset Formula $\text{CFState}^{S,A}$
\end_inset

 when applied to a value of type 
\begin_inset Formula $\text{CFState}^{S,\text{CFState}^{S,A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{\text{State}}(p^{:\_^{:S}\rightarrow(\_^{:S}\rightarrow A)\times(S\rightarrow S)}\times q^{:S\rightarrow S})\\
 & =(s^{:S}\rightarrow s\triangleright q\triangleright(\gunderline{s\triangleright p}\triangleright\pi_{1}))\times(s^{:S}\rightarrow...)\\
\text{denote }p_{0}\triangleq s\triangleright p:\quad & =(s^{:S}\rightarrow\gunderline{s\triangleright q\triangleright\,}(p_{0}\triangleright\pi_{1}))\times(s^{:S}\rightarrow...)\\
\text{denote }a_{0}\triangleq s\triangleright q\triangleright(p_{0}\triangleright\pi_{1}):\quad & =(s^{:S}\rightarrow a_{0})\times(s^{:S}\rightarrow...)=(\_^{:S}\rightarrow a_{0})\times(s^{:S}\rightarrow...)\quad.
\end{align*}

\end_inset

Here the constants 
\begin_inset Formula $p_{0}:(\_^{:S}\rightarrow A)\times(S\rightarrow S)$
\end_inset

 and 
\begin_inset Formula $a_{0}:A$
\end_inset

 exist due to the assumption that both 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $p_{0}\triangleright\pi_{1}$
\end_inset

 are constant functions.
 It follows that the code of 
\begin_inset Formula $\text{pu}_{\text{State}}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{\text{State}}$
\end_inset

 can be reused as 
\begin_inset Formula $\text{pu}_{\text{CFState}}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{\text{CFState}}$
\end_inset

 when restricted to the type 
\begin_inset Formula $\text{CFState}^{S,A}$
\end_inset

.
 The monad laws hold for 
\begin_inset Formula $\text{CFState}^{S,A}$
\end_inset

 because those laws hold for the code of 
\begin_inset Formula $\text{pu}_{\text{State}}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{\text{State}}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The code of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

 is an identity function that only reassigns types.
 This indicates that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CFState
\end_layout

\end_inset

 is a subtype of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 (in the sense of subtyping explained in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Covariance,-contravariance,-and-subtyping"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The code of 
\begin_inset Formula $\text{pu}_{\text{CFState}}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{\text{CFState}}$
\end_inset

 is the same as the code of 
\begin_inset Formula $\text{pu}_{\text{State}}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{\text{State}}$
\end_inset

 respectively.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

 automatically satisfies the laws of the monad morphism of type 
\begin_inset Formula $\text{CFState}^{S,A}\rightarrow\text{State}^{S,A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

 is then also an applicative morphism (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
To prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

 is injective, we will show that it has a left inverse (denoted 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toCF
\end_layout

\end_inset

):
\begin_inset Formula 
\[
\text{toCF}:\text{State}^{S,A}\rightarrow\text{CFState}^{S,A}\quad,\quad\quad\text{toCF}\triangleq p^{:S\rightarrow A}\times q^{:S\rightarrow S}\rightarrow(\_^{:S}\rightarrow p(s_{0}))\times q\quad.
\]

\end_inset

Here 
\begin_inset Formula $s_{0}$
\end_inset

 is an arbitrary value of type 
\begin_inset Formula $S$
\end_inset

.
 That value exists because 
\begin_inset Formula $S$
\end_inset

 is not a void type.
\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset Formula $\text{fromCF}\bef\text{toCF}=\text{id}$
\end_inset

.
 For any constant function 
\begin_inset Formula $p\triangleq\_^{:S}\rightarrow a_{0}$
\end_inset

 we will have 
\begin_inset Formula $p(s_{0})=a_{0}$
\end_inset

 and so we can write:
\begin_inset Formula 
\[
\text{fromCF}\bef\text{toCF}=p^{:\_^{:S}\rightarrow A}\times q^{:S\rightarrow S}\rightarrow(\_^{:S}\rightarrow p(s_{0}))\times q=p\times q\rightarrow(\_\rightarrow a_{0})\times q=p\times q\rightarrow p\times q=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The code ***
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 A value of type 
\begin_inset Formula $\text{CFState}^{S,A}=(\_^{:S}\rightarrow A)\times(S\rightarrow S)$
\end_inset

 is a pair of a constant function and a value of type 
\begin_inset Formula $W$
\end_inset

.
 When 
\begin_inset Formula $S$
\end_inset

 is not void, the type of constant functions 
\begin_inset Formula $(\_^{:S}\rightarrow A)$
\end_inset

 is equivalent to the type 
\begin_inset Formula $A$
\end_inset

: we can substitute an arbitrary value 
\begin_inset Formula $s_{0}:S$
\end_inset

 into a constant function and obtain the corresponding value of type 
\begin_inset Formula $A$
\end_inset

.
 So, we have the type equivalence 
\begin_inset Formula $\text{CFState}^{S,A}\cong A\times(S\rightarrow S)\triangleq A\times W$
\end_inset

.
 The isomorphism is given by a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inCF
\end_layout

\end_inset

 defined by:
\begin_inset Formula 
\[
\text{inCF}:\text{Writer}^{W,A}\rightarrow\text{CFState}^{S,A}\quad,\quad\quad\text{inCF}\triangleq a^{:A}\times w^{:S\rightarrow S}\rightarrow(\_^{:S}\rightarrow a)\times w\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inCF
\end_layout

\end_inset

 is a monad morphism.
 To verify the identity law:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{\text{Writer}}\bef\text{inCF}=(a^{:A}\rightarrow a\times\text{id})\bef(a\times w\rightarrow(\_\rightarrow a)\times w)\\
 & =a\rightarrow(\_\rightarrow a)\times\text{id}=\text{pu}_{\text{State}}=\text{pu}_{\text{CFState}}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We are now ready to prove the first property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-properties-of-zipWithIndex"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-properties-of-zipWithIndex"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any lawful traversable functor 
\begin_inset Formula $L$
\end_inset

, define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 (denoted for brevity by 
\begin_inset Formula $\text{zwi}_{L}$
\end_inset

) via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-zwi"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 satisfies the equation: 
\begin_inset Formula $\text{zwi}_{L}\bef\pi_{1}^{\uparrow L}=\text{id}^{:L^{A}\rightarrow L^{A}}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 There exists a 
\begin_inset Quotes eld
\end_inset

tabulating
\begin_inset Quotes erd
\end_inset

 function (denoted by 
\begin_inset Formula $\text{tab}_{L}^{A}$
\end_inset

):
\begin_inset Formula 
\[
\text{tab}_{L}^{A}:L^{A\times\text{Int}}\rightarrow(\text{Int}\rightarrow A)\times L^{\text{Int}}\quad,
\]

\end_inset

such that 
\begin_inset Formula $\text{zwi}_{L}\bef\text{tab}_{L}\bef(f^{:\text{Int}\rightarrow A}\times q^{:L^{\text{Int}}}\rightarrow q\triangleright f^{\uparrow L})=\text{id}^{:L^{A}\rightarrow L^{A}}$
\end_inset

.
 So, the function 
\begin_inset Formula $\text{zwi}_{L}\bef\text{tab}_{L}$
\end_inset

 is an injective map of type 
\begin_inset Formula $L^{A}\rightarrow(\text{Int}\rightarrow A)\times L^{\text{Int}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
To make the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-zwi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) easier to work with, we denote:
\begin_inset Formula 
\begin{align*}
 & F^{A}\triangleq\text{State}^{\text{Int},A}=(\text{Int}\rightarrow A)\times(\text{Int}\rightarrow\text{Int})\quad,\\
 & g:A\rightarrow\text{State}^{\text{Int},A\times\text{Int}}\quad,\quad\quad g\triangleq a^{:A}\rightarrow(s^{:\text{Int}}\rightarrow a\times s)\times(s^{:\text{Int}}\rightarrow s+1)\quad,\\
 & r:\forall B.\,\text{State}^{\text{Int},B}\rightarrow B\quad,\quad\quad r\triangleq p^{:\text{Int}\rightarrow B}\times q^{:\text{Int}\rightarrow\text{Int}}\rightarrow p(0^{:\text{Int}})\quad.
\end{align*}

\end_inset

and get 
\begin_inset Formula $\text{zwi}_{L}=\text{trav}_{L}^{F,A,A\times\text{Int}}(g)\bef r$
\end_inset

.
 Then we write:
\begin_inset Formula 
\begin{align*}
 & \text{zwi}_{L}\bef\pi_{1}^{\uparrow L}=\text{trav}_{L}^{F,A,A\times\text{Int}}(g)\bef\gunderline{r\bef\pi_{1}^{\uparrow L}}\\
\text{naturality of }r:\quad & =\gunderline{\text{trav}_{L}^{F,A,A\times\text{Int}}(g)\bef\pi_{1}^{\uparrow L\uparrow\text{State}}}\bef r\\
\text{naturality of }\text{trav}_{L}:\quad & =\text{trav}_{L}^{F,A,A}(g\bef\pi_{1}^{\uparrow\text{State}})\bef r\quad.
\end{align*}

\end_inset

To compute 
\begin_inset Formula $g\bef\pi_{1}^{\uparrow\text{State}}$
\end_inset

, we first express the lifting to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow\text{State}^{S,\bullet}}(p^{:S\rightarrow A}\times q^{:S\rightarrow S})=(p\bef f)\times q\quad.
\]

\end_inset

Then we get:
\begin_inset Formula 
\begin{align*}
 & g\bef\pi_{1}^{\uparrow\text{State}}:A\rightarrow\text{State}^{\text{Int},A}\quad,\\
 & g\bef\pi_{1}^{\uparrow\text{State}}=a^{:A}\rightarrow(s^{:\text{Int}}\rightarrow\pi_{1}(a\times s))\times(s^{:\text{Int}}\rightarrow s+1)\\
 & =a\rightarrow(s^{:\text{Int}}\rightarrow a)\times(s^{:\text{Int}}\rightarrow s+1)=a\rightarrow(\_^{:\text{Int}}\rightarrow a)\times(s^{:\text{Int}}\rightarrow s+1)\quad.
\end{align*}

\end_inset

Now we note that the sub-expression (
\begin_inset Formula $\_^{:\text{Int}}\rightarrow a$
\end_inset

) is a constant function.
 So, 
\begin_inset Formula $g\bef\pi_{1}^{\uparrow\text{State}}$
\end_inset

 can be expressed as a function 
\begin_inset Formula $h$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow\text{CFState}^{\text{Int},A}$
\end_inset

 followed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & h:A\rightarrow\text{CFState}^{\text{Int},A}=A\rightarrow(\_^{:\text{Int}}\rightarrow A)\times(\text{Int}\rightarrow\text{Int})\quad,\\
 & h\triangleq a\rightarrow(\_^{:\text{Int}}\rightarrow a)\times(s^{:\text{Int}}\rightarrow s+1)\quad,\quad\quad g\bef\pi_{1}^{\uparrow\text{State}}=h\bef\text{fromCF}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In this way, we have found that:
\begin_inset Formula 
\[
\text{zwi}_{L}\bef\pi_{1}^{\uparrow L}=\text{trav}_{L}^{\text{State}^{\text{Int},\bullet},A,A}(h\bef\text{fromCF})\bef r\quad.
\]

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

 is an applicative morphism, we can use the applicative naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $B\triangleq A$
\end_inset

, 
\begin_inset Formula $F^{A}\triangleq\text{CFState}^{\text{Int},A}$
\end_inset

, 
\begin_inset Formula $G^{A}\triangleq\text{State}^{\text{Int},A}$
\end_inset

, 
\begin_inset Formula $f^{:F^{B}\rightarrow G^{B}}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromCF
\end_layout

\end_inset

, and 
\begin_inset Formula $g^{:A\rightarrow F^{B}}=h$
\end_inset

:
\begin_inset Formula 
\[
\text{trav}_{L}^{G,A,B}(g\bef f)=\text{trav}_{L}^{F,A,B}(g)\bef f\quad\quad\text{or equivalently:}\quad\quad\text{trav}_{L}(h\bef\text{fromCF})=\text{trav}_{L}(h)\bef\text{fromCF}\quad.
\]

\end_inset

Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-constant-value-state-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c) gives the formula 
\begin_inset Formula $\text{run}_{\text{CFState}}=\text{fromCF}\bef r$
\end_inset

, so we write:
\begin_inset Formula 
\[
\text{zwi}_{L}\bef\pi_{1}^{\uparrow L}=\text{trav}_{L}(h)\bef\gunderline{\text{fromCF}\bef r}=\text{trav}_{L}(h)\bef\text{run}_{\text{CFState}}\quad.
\]

\end_inset

As 
\begin_inset Formula $\text{run}_{\text{CFState}}$
\end_inset

 is an applicative morphism, we may again use the applicative naturality
 law:
\begin_inset Formula 
\[
\text{zwi}_{L}\bef\pi_{1}^{\uparrow L}=\text{trav}_{L}(h)\bef\text{run}_{\text{CFState}}=\text{trav}_{L}(h\bef\text{run}_{\text{CFState}})\quad.
\]

\end_inset

Now we recall the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and compute:
\begin_inset Formula 
\begin{align*}
 & h\bef\text{run}_{\text{CFState}}=a\rightarrow(\_^{:\text{Int}}\rightarrow a)\times(s^{:\text{Int}}\rightarrow s+1)\bef\text{run}_{\text{CFState}}=a\rightarrow a=\text{id}^{:A\rightarrow A}\quad,\\
 & \text{zwi}_{L}\bef\pi_{1}^{\uparrow L}=\text{trav}_{L}(h\bef\text{run}_{\text{CFState}})=\text{trav}_{L}(\text{id})=\text{id}\quad.
\end{align*}

\end_inset

 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The second property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 does 
\emph on
not
\emph default
 seem to be provable using the laws of traverse; see Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-traverse-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b).
 However, it appears to be natural to expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 assigns different indices to each value of type 
\begin_inset Formula $A$
\end_inset

 stored inside a data structure of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 Perhaps another law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 is needed? 
\end_layout

\begin_layout Subsection
Traversable contrafunctors and profunctors are not useful
\end_layout

\begin_layout Standard
In Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we found some uses for applicative contrafunctors and profunctors.
 We will now briefly investigate whether contrafunctors or profunctors may
 be traversable.
 To answer that question, we will try implementing a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 function for contrafunctors and profunctors.
\end_layout

\begin_layout Standard
Suppose that 
\begin_inset Formula $L^{A}$
\end_inset

 is a contrafunctor.
 A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 function (denoted by 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

) with the type signature:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}:L^{F^{A}}\rightarrow F^{L^{A}}\quad,
\]

\end_inset

is required for 
\begin_inset Formula $L$
\end_inset

 to be traversable.
 That function must obey the applicative naturality law, which ensures that
 
\begin_inset Formula $\text{seq}_{L}^{F,A}$
\end_inset

 works in the same way for any applicative functor 
\begin_inset Formula $F$
\end_inset

.
 We note that 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 is covariant in 
\begin_inset Formula $F$
\end_inset

 because 
\begin_inset Formula $L^{\bullet}$
\end_inset

 is contravariant.
 Since 
\begin_inset Formula $\text{pu}_{F}:\text{Id}^{A}\rightarrow F^{A}$
\end_inset

 is an applicative morphism (Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-pure-is-applicative-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we may use this morphism to write the applicative naturality law:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}=\text{pu}_{F}^{\downarrow L}\bef\text{seq}_{L}^{\text{Id},A}\bef\text{pu}_{F}\quad.
\]

\end_inset

The identity law gives 
\begin_inset Formula $\text{seq}_{L}^{\text{Id},A}=\text{id}$
\end_inset

.
 So, the code of 
\begin_inset Formula $\text{seq}_{L}^{F,A}$
\end_inset

 must be this:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}=\text{pu}_{F}^{\downarrow L}\bef\text{pu}_{F}\quad.
\]

\end_inset

No other implementation of 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 would obey the applicative naturality law and the identity law.
\end_layout

\begin_layout Standard
We can verify that the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for this 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}=\text{pu}_{F}^{\downarrow L}\bef\gunderline{\text{pu}_{F}\bef(\text{pu}_{G}^{\downarrow L}\bef\text{pu}_{G})^{\uparrow F}}\\
\text{naturality law of }\text{pu}_{F}:\quad & \quad=\gunderline{\text{pu}_{F}^{\downarrow L}\bef\text{pu}_{G}^{\downarrow L}}\bef\text{pu}_{G}\bef\text{pu}_{F}=(\text{pu}_{G}\bef\text{pu}_{F})^{\downarrow L}\bef\text{pu}_{G}\bef\text{pu}_{F}\quad,\\
\text{right-hand side}:\quad & \text{seq}_{L}^{F\circ G,A}=\text{pu}_{F\circ G}^{\downarrow L}\bef\text{pu}_{F\circ G}=(\text{pu}_{G}\bef\text{pu}_{F})^{\downarrow L}\bef\text{pu}_{G}\bef\text{pu}_{F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
So, every contrafunctor has a unique 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 method that obeys the laws of traversables.
 However, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 ignores all 
\begin_inset Formula $F$
\end_inset

-effects in its arguments and always produces values with empty 
\begin_inset Formula $F$
\end_inset

-effects.
 For example, if 
\begin_inset Formula $L^{A}\triangleq A\rightarrow Z$
\end_inset

 (where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type) then:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}:(F^{A}\rightarrow Z)\rightarrow F^{A\rightarrow Z}\quad,\quad\quad\text{seq}_{L}^{F,A}(f^{:F^{A}\rightarrow Z})=\text{pu}_{F}(a^{:A}\rightarrow f(\text{pu}_{F}(a)))\quad.
\]

\end_inset

The function 
\begin_inset Formula $f$
\end_inset

 will be never applied to nontrivial 
\begin_inset Formula $F$
\end_inset

-effects.
 So, the function 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 will never obtain any information that 
\begin_inset Formula $f$
\end_inset

 would return when applied to nontrivial 
\begin_inset Formula $F$
\end_inset

-effects.
 
\end_layout

\begin_layout Standard
We see that contrafunctors are traversable in a way that is not practically
 useful.
\end_layout

\begin_layout Standard
Turning now to the case where 
\begin_inset Formula $L$
\end_inset

 is a profunctor, consider a simple example:
\begin_inset Formula 
\[
L^{A}\triangleq A\rightarrow A\quad,\quad\quad\text{seq}_{L}:(F^{A}\rightarrow F^{A})\rightarrow F^{A\rightarrow A}\quad.
\]

\end_inset

Since the applicative functor 
\begin_inset Formula $F$
\end_inset

 is unknown and the type signature of 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 does not provide any arguments of type 
\begin_inset Formula $F^{X}$
\end_inset

, we cannot produce values of type 
\begin_inset Formula $F$
\end_inset

 other than via 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

.
 So, the only implementation of 
\begin_inset Formula $\text{seq}_{L}$
\end_inset

 is:
\begin_inset Formula 
\[
\text{seq}_{L}\triangleq p^{:F^{A}\rightarrow F^{A}}\rightarrow\text{pu}_{F}(\text{id}^{:A\rightarrow A})\quad.
\]

\end_inset

This function is not useful because it ignores its argument 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Subsection
Traversals for nested recursive types
\end_layout

\begin_layout Standard
In most of this book, recursive type constructors are defined via equations
 of the form 
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset

, where 
\begin_inset Formula $S$
\end_inset

 is a recursion scheme.
 We have seen one example of a recursive type constructor (a perfect-shaped
 tree, Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Perfect-shaped-trees"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-traversal-perfect-shaped-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that cannot be defined in this way.
 The reason is that the recursive type equation for a perfect-shaped binary
 tree
\begin_inset Index idx
status open

\begin_layout Plain Layout
perfect-shaped tree
\end_layout

\end_inset

 
\begin_inset Formula $\text{PT}^{A}$
\end_inset

 is:
\begin_inset Formula 
\begin{equation}
\text{PT}^{A}\triangleq A+\text{PT}^{A\times A}\quad.\label{eq:perfect-shaped-binary-tree-type-equation}
\end{equation}

\end_inset

This type equation is not of the form 
\begin_inset Formula $\text{PT}^{A}\triangleq S^{A,\text{PT}^{A}}$
\end_inset

 because the recursive use of 
\begin_inset Formula $\text{PT}^{\bullet}$
\end_inset

 contains a nontrivial type expression (
\begin_inset Formula $A\times A$
\end_inset

) instead of just 
\begin_inset Formula $A$
\end_inset

.
 To express the type equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:perfect-shaped-binary-tree-type-equation"
plural "false"
caps "false"
noprefix "false"

\end_inset

) via a recursion scheme, we may introduce an additional functor 
\begin_inset Formula $P$
\end_inset

 and write:
\begin_inset Formula 
\[
\text{PT}^{A}\triangleq S^{A,\text{PT}^{P^{A}}}\quad,\quad\quad P^{A}\triangleq A\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Nested recursive types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nested recursive types
\end_layout

\end_inset

 are defined using type equations of this more general form, for example:
\begin_inset Formula 
\begin{equation}
T^{A}\triangleq S^{A,T^{P^{A}}}\quad,\quad\text{or}\quad\quad T^{A,B}\triangleq S^{A,B,T^{P^{A},Q^{B}}}\quad,\quad\quad\text{etc.}\label{eq:nested-recursive-type-equations}
\end{equation}

\end_inset

The nested functors 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 replace the type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 of 
\begin_inset Formula $T^{A,B}$
\end_inset

 by different type expressions.
 
\end_layout

\begin_layout Standard
One could write a nested recursive type of an even more general form than
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:nested-recursive-type-equations"
plural "false"
caps "false"
noprefix "false"

\end_inset

), e.g., 
\begin_inset Formula $T^{A}\triangleq S^{A,T^{T^{A}}}$
\end_inset

, where the nested type expressions may use the type 
\begin_inset Formula $T$
\end_inset

 itself more than once.
 We will not consider such type equations in this book, as it is not clear
 how much use they have in practice.
\end_layout

\begin_layout Standard
Let us see how one can implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instance for type constructors of the form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:nested-recursive-type-equations"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-nested-recursive-type-traversable"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-nested-recursive-type-traversable"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a bitraversable bifunctor 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and a traversable functor 
\begin_inset Formula $P^{\bullet}$
\end_inset

, define a nested recursive type constructor 
\begin_inset Formula $L^{\bullet}$
\end_inset

 by:
\begin_inset Formula 
\[
L^{A}\triangleq S^{A,L^{P^{A}}}\quad.
\]

\end_inset

Then 
\begin_inset Formula $L$
\end_inset

 is a lawful traversable functor with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 function defined as:
\begin_inset Formula 
\[
\text{seq}_{L}^{F,A}:S^{F^{A},L^{P^{F^{A}}}}\rightarrow F^{S^{A,L^{P^{A}}}}\quad,\quad\quad\text{seq}_{L}^{F,A}\triangleq\big(\text{seq}_{P}^{F,A}\big)^{\uparrow L\uparrow S^{F^{A},\bullet}}\bef\big(\overline{\text{seq}}_{L}^{F,P^{A}}\big)^{\uparrow S^{F^{A},\bullet}}\bef\text{seq2}_{S}^{F,A,L^{P^{A}}}\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{6pc}S^{F^{A},L^{P^{F^{A}}}}\ar[r]\sp(0.5){\big(\text{seq}_{P}^{F,A}\big)^{\uparrow L\uparrow S^{F^{A},\bullet}}} & S^{F^{A},L^{F^{P^{A}}}}\ar[r]\sp(0.5){\big(\overline{\text{seq}}_{L}^{F,P^{A}}\big)^{\uparrow S^{F^{A},\bullet}}} & S^{F^{A},F^{L^{P^{A}}}}\ar[r]\sp(0.5){\text{seq2}_{S}^{F,A,L^{P^{A}}}} & F^{S^{A,L^{P^{A}}}}}
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We assume that the methods 
\begin_inset Formula $\text{seq}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{seq2}_{S}$
\end_inset

, as well as the recursively called 
\begin_inset Formula $\overline{\text{seq}}_{L}$
\end_inset

, already satisfy the laws.
 To verify the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{seq}_{L}^{\text{Id},A}=\big(\text{seq}_{P}^{\text{Id},A}\big)^{\uparrow L\uparrow S^{F^{A},\bullet}}\bef\big(\overline{\text{seq}}_{L}^{\text{Id},P^{A}}\big)^{\uparrow S^{F^{A},\bullet}}\bef\text{seq2}_{S}^{\text{Id},A,L^{P^{A}}}=\text{id}^{\uparrow L\uparrow S}\bef\text{id}^{\uparrow S}\bef\text{id}=\text{id}\quad.
\]

\end_inset

To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-sequence"
plural "false"
caps "false"
noprefix "false"

\end_inset

), write its two sides, omitting some type parameters for brevity:
\begin_inset Formula 
\begin{align*}
 & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}\\
 & \quad=\big(\text{seq}_{P}^{F,G^{A}}\big)^{\uparrow L\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{F,P^{G^{A}}}\big)^{\uparrow S}\bef\text{seq2}_{S}^{F,G^{A},L^{P^{G^{A}}}}\bef\big((\text{seq}_{P}^{G,A})^{\uparrow L\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{G,P^{A}}\big)^{\uparrow S}\bef\text{seq2}_{S}^{G,A,L^{P^{A}}}\big)^{\uparrow F}\quad,\\
 & \text{seq}_{L}^{F\circ G,A}=\big(\text{seq}_{P}^{F\circ G,A}\big)^{\uparrow L\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{F\circ G,P^{A}}\big)^{\uparrow S}\bef\text{seq2}_{S}^{F\circ G,A,L^{P^{A}}}\\
 & \quad=\big(\text{seq}_{P}^{F,G^{A}}\bef(\text{seq}_{P}^{G,A})^{\uparrow F}\big)^{\uparrow L\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{F,G^{P^{A}}}\bef(\overline{\text{seq}}_{L}^{G,P^{A}})^{\uparrow F}\big)^{\uparrow S}\bef\text{seq2}_{S}^{F,G^{A},G^{L^{P^{A}}}}\bef\big(\text{seq2}_{S}^{G,A,L^{P^{A}}}\big)^{\uparrow F}\quad.
\end{align*}

\end_inset

To get the last line, we used the assumed composition laws of 
\begin_inset Formula $\text{seq}_{P}$
\end_inset

, 
\begin_inset Formula $\overline{\text{seq}}_{L}$
\end_inset

, and 
\begin_inset Formula $\text{seq2}_{S}$
\end_inset

.
 
\end_layout

\begin_layout Standard
It is now clear that the two sides of the law differ only in the order of
 function compositions.
 The remaining difference is:
\begin_inset Formula 
\begin{align*}
 & \big(\overline{\text{seq}}_{L}^{F,P^{G^{A}}}\big)^{\uparrow S}\bef\text{seq2}_{S}^{F,G^{A},L^{P^{G^{A}}}}\bef\big((\text{seq}_{P}^{G,A})^{\uparrow L}\bef\overline{\text{seq}}_{L}^{G,P^{A}}\big)^{\uparrow S\uparrow F}\\
 & \overset{?}{=}(\text{seq}_{P}^{G,A})^{\uparrow F\uparrow L\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{F,G^{P^{A}}}\big)^{\uparrow S}\bef(\overline{\text{seq}}_{L}^{G,P^{A}})^{\uparrow F\uparrow S}\bef\text{seq2}_{S}^{F,G^{A},G^{L^{P^{A}}}}\quad.
\end{align*}

\end_inset

We will show that the two sides are equal if we rewrite the left-hand side
 so that the various 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 methods are composed in the same order as in the right-hand side.
 This can be done using naturality laws, which allow us to change the order
 of composition of lifted functions:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \big(\overline{\text{seq}}_{L}^{F,P^{G^{A}}}\big)^{\uparrow S}\bef\gunderline{\text{seq2}_{S}^{F,G^{A},L^{P^{G^{A}}}}\bef\big((\text{seq}_{P}^{G,A})^{\uparrow L}\bef\overline{\text{seq}}_{L}^{G,P^{A}}\big)^{\uparrow S\uparrow F}}\\
\text{naturality law of }\text{seq2}_{S}:\quad & =\gunderline{\big(\overline{\text{seq}}_{L}^{F,P^{G^{A}}}\big)^{\uparrow S}\bef\big((\text{seq}_{P}^{G,A})^{\uparrow L}\bef\overline{\text{seq}}_{L}^{G,P^{A}}\big)^{\uparrow F\uparrow S}}\bef\text{seq2}_{S}^{F,G^{A},G^{L^{P^{A}}}}\\
\text{composition under }^{\uparrow S}:\quad & =\big(\gunderline{\overline{\text{seq}}_{L}^{F,P^{G^{A}}}\bef(\text{seq}_{P}^{G,A})^{\uparrow L\uparrow F}}\big)^{\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{G,P^{A}}\big)^{\uparrow F\uparrow S}\bef\text{seq2}_{S}^{F,G^{A},G^{L^{P^{A}}}}\quad.\\
\text{naturality law of }\overline{\text{seq}}_{L}:\quad & =\big(\overline{\text{seq}}_{L}^{F,P^{G^{A}}}\bef(\text{seq}_{P}^{G,A})^{\uparrow L\uparrow F}\big)^{\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{G,P^{A}}\big)^{\uparrow F\uparrow S}\bef\text{seq2}_{S}^{F,G^{A},G^{L^{P^{A}}}}
\end{align*}

\end_inset

It remains to show that: 
\begin_inset Formula 
\[
\big(\overline{\text{seq}}_{L}^{F,P^{G^{A}}}\bef(\text{seq}_{P}^{G,A})^{\uparrow L\uparrow F}\big)^{\uparrow S}\overset{?}{=}(\text{seq}_{P}^{G,A})^{\uparrow F\uparrow L\uparrow S}\bef\big(\overline{\text{seq}}_{L}^{F,G^{P^{A}}}\big)^{\uparrow S}\quad.
\]

\end_inset

But this is just the naturality law of 
\begin_inset Formula $\overline{\text{seq}}_{L}$
\end_inset

 under the lifting 
\begin_inset Formula $(\dots)^{\uparrow S}$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
As an advanced example of a nested traversable functor, we will derive a
 type for square-shaped matrices
\begin_inset Foot
status open

\begin_layout Plain Layout
This and other advanced examples of nested recursive types are explained
 in the paper 
\begin_inset Quotes eld
\end_inset

Manufacturing datatypes
\begin_inset Quotes erd
\end_inset

 (1999) by R.
\begin_inset space ~
\end_inset

Hinze
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ralf Hinze
\end_layout

\end_inset

, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.cs.ox.ac.uk/ralf.hinze/publications/WAAAPL99a.ps.gz"
literal "false"

\end_inset


\end_layout

\end_inset

 with elements of type 
\begin_inset Formula $A$
\end_inset

.
 For motivation, recall how Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-matrix-products"
plural "false"
caps "false"
noprefix "false"

\end_inset

 encoded square matrices via nested lists of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

.
 However, a value of that type is not guaranteed to represent a matrix of
 a consistent shape.
 We would like to define a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq[A]
\end_layout

\end_inset

 whose values always contain 
\begin_inset Formula $n$
\end_inset

 nested lists of length 
\begin_inset Formula $n$
\end_inset

 (for 
\begin_inset Formula $n=1,2,...$
\end_inset

).
 We need to disallow inconsistent nested lists such as 
\begin_inset Formula $\left[\left[1,2\right],\left[\right],\left[3\right]\right]$
\end_inset

 that do not correspond to a square matrix.
\end_layout

\begin_layout Standard
Begin by considering an example of a 
\begin_inset Formula $2\times2$
\end_inset

 matrix.
 The type of such matrices is not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

 but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List2[List2[A]]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List2[A]
\end_layout

\end_inset

 is a list of 
\emph on
exactly
\emph default
 
\begin_inset Formula $2$
\end_inset

 elements of type 
\begin_inset Formula $A$
\end_inset

.
 We can rewrite the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List2[A]
\end_layout

\end_inset

 equivalently as a pair 
\begin_inset Formula $A\times A$
\end_inset

 and also as a function 
\begin_inset Formula $\bbnum 2\rightarrow A$
\end_inset

 (where 
\begin_inset Formula $\bbnum 2$
\end_inset

 is the type containing exactly 
\begin_inset Formula $2$
\end_inset

 distinct values).
 This technique allows us to formulate the types of lists of exactly 
\begin_inset Formula $3$
\end_inset

, 
\begin_inset Formula $4$
\end_inset

, etc.,
\begin_inset space ~
\end_inset

elements as 
\begin_inset Formula $\text{List}_{3}^{A}\triangleq\bbnum 3\rightarrow A$
\end_inset

, 
\begin_inset Formula $\text{List}_{4}^{A}\triangleq\bbnum 4\rightarrow A$
\end_inset

, and so on.
 The type of an 
\begin_inset Formula $n\times n$
\end_inset

 matrix is then written symbolically as 
\begin_inset Formula $\bbnum n\rightarrow\bbnum n\rightarrow A$
\end_inset

 (where 
\begin_inset Formula $\bbnum n=\bbnum 1$
\end_inset

, 
\begin_inset Formula $\bbnum 2$
\end_inset

, etc.) or equivalently as 
\begin_inset Formula $\bbnum n\times\bbnum n\rightarrow A$
\end_inset

.
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq[A]
\end_layout

\end_inset

 is equivalent to an infinite disjunction of types representing square matrices
 of every size (
\begin_inset Formula $1\times1$
\end_inset

, 
\begin_inset Formula $2\times2$
\end_inset

, and so on).
 To define an infinite disjunctive type in a program of finite size, we
 need to use recursion at type level.
 In a mathematical sense, this recursion will be induction on the size of
 the matrix.
 So, let us introduce the size of the matrix as an extra 
\emph on
type parameter
\emph default
 
\begin_inset Formula $N$
\end_inset

.
 It will be convenient to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SqSize[N, A]
\end_layout

\end_inset

 as the type of matrices of size 
\emph on
at least
\emph default
 
\begin_inset Formula $N$
\end_inset

.
 We intend 
\begin_inset Formula $N$
\end_inset

 to be equivalent to one of the types 
\begin_inset Formula $\bbnum 1$
\end_inset

, 
\begin_inset Formula $\bbnum 2$
\end_inset

, etc.
 
\end_layout

\begin_layout Standard
The base case (
\begin_inset Formula $N=\bbnum 1$
\end_inset

) and the inductive step (from 
\begin_inset Formula $N$
\end_inset

 to 
\begin_inset Formula $\bbnum 1+N$
\end_inset

) are written as:
\begin_inset Formula 
\[
\text{Sq}^{A}\triangleq\text{SqSize}^{\bbnum 1,A}\quad,\quad\quad\text{SqSize}^{N,A}\triangleq\left(N\times N\rightarrow A\right)+\text{SqSize}^{\bbnum 1+N,A}\quad.
\]

\end_inset

To implement this in Scala, we first define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SqSize[N, A]
\end_layout

\end_inset

 as a disjunctive type and then define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait SqSize[N, A]
\end_layout

\begin_layout Plain Layout

final case class Matrix[N, A](byIndex: ((N, N)) => A) extends SqSize[N,
 A]
\end_layout

\begin_layout Plain Layout

final case class Next[N, A](next: SqSize[Option[N], A])  extends SqSize[N,
 A]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type Sq[A] = SqSize[Unit, A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As an example, the 
\begin_inset Formula $2\times2$
\end_inset

 matrix 
\begin_inset Formula $\,\begin{array}{|cc|}
11 & 12\\
21 & 22
\end{array}\,$
\end_inset

 is represented by a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq[Int]
\end_layout

\end_inset

 as:
\begin_inset VSpace 20baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val matrix2x2: Sq[Int] = Next(Matrix {
\end_layout

\begin_layout Plain Layout

  case (None, None)         => 11
\end_layout

\begin_layout Plain Layout

  case (None, Some(_))      => 12
\end_layout

\begin_layout Plain Layout

  case (Some(_), None)      => 21
\end_layout

\begin_layout Plain Layout

  case (Some(_), Some(_))   => 22
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Formula $3\times3$
\end_inset

 matrix will have the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Next(Next(Matrix { ...
 }))
\end_layout

\end_inset

.
 An 
\begin_inset Formula $n\times n$
\end_inset

 matrix has 
\begin_inset Formula $\left(n-1\right)$
\end_inset

 nested 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Next
\end_layout

\end_inset

 constructors in front of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Matrix
\end_layout

\end_inset

 constructor.
 The size of a matrix is encoded by its type in this way.
\end_layout

\begin_layout Standard
We now implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq
\end_layout

\end_inset

 is defined by induction using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SqSize[N, A]
\end_layout

\end_inset

, we must first implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SqSize
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sequence[A, N, F[_]: Applicative: Functor]: SqSize[N, F[A]] => F[SqSize[N,
 A]] = {
\end_layout

\begin_layout Plain Layout

  case Matrix(byIndex)   => ???    // Base case.
\end_layout

\begin_layout Plain Layout

  case Next(next)        => ???    // Inductive step.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the base case, we have a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

byIndex
\end_layout

\end_inset

 of type 
\begin_inset Formula $N\times N\rightarrow F^{A}$
\end_inset

 that can return 
\begin_inset Formula $n\times n$
\end_inset

 different values of type 
\begin_inset Formula $F^{A}$
\end_inset

.
 We need to combine all those values together by using 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method.
 The result will be a value of type 
\begin_inset Formula $F^{A\times A\times...\times A}$
\end_inset

, which we will then need to convert to the type 
\begin_inset Formula $F^{N\times N\rightarrow A}$
\end_inset

.
 The only way of performing these computations is by enumerating all possible
 values of type 
\begin_inset Formula $N$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "frame=single,fillcolor={\color{black}},framesep={0.2mm},framexleftmargin=2mm,framexrightmargin=2mm,framextopmargin=2mm,framexbottommargin=2mm"
inline false
status open

\begin_layout Plain Layout

type Finite[N] = List[N] // A list of all possible values of type N.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object Finite { def apply[N: Finite]: Finite[N] = implicitly[Finite[N]]
 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sealed abstract class SqSize[N: Finite, A]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

final case class Matrix[N: Finite, A](byIndex: ((N, N)) => A) extends SqSize[N,
 A]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

final case class Next[N: Finite, A](next: SqSize[Option[N], A]) extends
 SqSize[N, A]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type Sq[A] = SqSize[Unit, A]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit val finiteUnit: Finite[Unit] = List(())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit def finiteOptionN[N: Finite]: Finite[Option[N]] = None +: Finite[N].map(
Some(_))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Access the matrix element at zero-based index (i, j).
\end_layout

\begin_layout Plain Layout

def access[N: Finite, A](s: SqSize[N, A], i: Int, j: Int): A = s match {
\end_layout

\begin_layout Plain Layout

  case Matrix(byIndex) => byIndex((Finite[N].apply(i), Finite[N].apply(j)))
\end_layout

\begin_layout Plain Layout

  case Next(next) => access[Option[N], A](next, i, j)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def size[N: Finite, A](s: SqSize[N, A]): Int = s match {      
\end_layout

\begin_layout Plain Layout

  case Matrix(_) => Finite[N].length
\end_layout

\begin_layout Plain Layout

  case Next(next) => size[Option[N], A](next)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def toSeqSeq[N: Finite, A](s: SqSize[N, A]): Seq[Seq[A]] = {
\end_layout

\begin_layout Plain Layout

  val length = size(s)
\end_layout

\begin_layout Plain Layout

  (0 until length).map(i => (0 until length).map(j => access(s, i, j)))
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Test: visualize the matrix defined previously by converting it to nested
 lists.
\end_layout

\begin_layout Plain Layout

scala> toSeqSeq(matrix2x2)
\end_layout

\begin_layout Plain Layout

res1: List[List[Int]] = List(List(11, 12), List(21, 22))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def sequenceList[F[_]: Applicative : Functor, A](l: List[F[A]]): F[List[A]]
 = l match {
\end_layout

\begin_layout Plain Layout

  case Nil          => Applicative[F].pure(Nil)
\end_layout

\begin_layout Plain Layout

  case head :: tail => (head zip sequenceList(tail)).map { case (x, y) =>
 x +: y }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def sequence[N: Finite, F[_]: Applicative : Functor, A](sq: SqSize[N, F[A]]):
 F[SqSize[N, A]] =
\end_layout

\begin_layout Plain Layout

  sq match {
\end_layout

\begin_layout Plain Layout

    case Matrix(byIndex)   =>
\end_layout

\begin_layout Plain Layout

      val allValuesF: List[F[((N, N), A)]] = for {
\end_layout

\begin_layout Plain Layout

        i <- Finite[N]
\end_layout

\begin_layout Plain Layout

        j <- Finite[N]
\end_layout

\begin_layout Plain Layout

      } yield byIndex((i, j)).map(a => ((i, j), a))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      val fList: F[List[((N, N), A)]] = sequenceList(allValuesF)
\end_layout

\begin_layout Plain Layout

      fList.map { values =>
\end_layout

\begin_layout Plain Layout

        val valuesMap: ((N, N)) => A = values.toMap.apply
\end_layout

\begin_layout Plain Layout

        Matrix[N, A](valuesMap)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    case Next(next)        => sequence[Option[N], F, A](next).map(Next(_))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 for square matrices.
\begin_inset CommandInset label
LatexCommand label
name "fig:Full-code-implementing-traverse-for-square-matrix"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq
\end_layout

\end_inset

 sets the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SqSize[N, A]
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N = Unit
\end_layout

\end_inset

.
 This forces the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

 in all of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Next()
\end_layout

\end_inset

 constructors to be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 wrapped in a number of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 constructors.
 All values of a type of this form can be enumerated explicitly.
 However, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SqSize[N, A]
\end_layout

\end_inset

 does not ensure that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

 will be a type with a known finite number of values.
 This problem prevents us from implementing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 method for our current definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A solution is to add a typeclass constraint (with a typeclass called 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Finite
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) on the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

.
 A suitable typeclass instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Finite[N]
\end_layout

\end_inset

 contains a list of all values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Finite[N] = List[N] // A list of all possible values of type N.
\end_layout

\end_inset

We can implement functions that create typeclass instances automatically
 for all the types we will actually use instead of the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

, namely, the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Unit]
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[Unit]]
\end_layout

\end_inset

 and so on.
 Suitable typeclass instances are defined inductively:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val finiteUnit: Finite[Unit] = List(())
\end_layout

\begin_layout Plain Layout

implicit def finiteOptionN[N: Finite]: Finite[Option[N]] = None +: Finite[N].map(
Some(_))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using these definitions, we can now extract all values of type 
\begin_inset Formula $A$
\end_inset

 from a value of type 
\begin_inset Formula $N\times N\rightarrow A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def access[N: Finite, A](s: SqSize[N, A], i: Int, j: Int): A = s match {
\end_layout

\begin_layout Plain Layout

  case Matrix(byIndex) => byIndex((Finite[N].apply(i), Finite[N].apply(j)))
\end_layout

\begin_layout Plain Layout

  case Next(next) => access[Option[N], A](next, i, j)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Let us test this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> access(matrix2x2, 0, 1)
\end_layout

\begin_layout Plain Layout

res0: Int = 12
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Full-code-implementing-traverse-for-square-matrix"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the complete code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq
\end_layout

\end_inset

.
 For testing (Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Full-code-implementing-traverse-for-square-matrix-tests"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we define a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

matrix2x2List
\end_layout

\end_inset

 that represents a square matrix of lists:
\begin_inset Formula 
\[
\text{matrix2x2List}:\text{Sq}^{\text{List}^{\text{Int}}}\quad,\quad\quad\text{matrix2x2List}\triangleq\left|\begin{array}{cc}
\left[0,10,100\right] & \left[1,11,101\right]\\
\left[2,12,102\right] & \left[3,13,103\right]
\end{array}\right|\quad.
\]

\end_inset

 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 to that value, we obtain a list of 
\begin_inset Formula $3$
\end_inset

 square matrices:
\begin_inset Formula 
\[
\text{seq}_{\text{Sq}}\,(\text{matrix2x2List})=\big[\left|\begin{array}{cc}
0 & 1\\
2 & 3
\end{array}\right|,\left|\begin{array}{cc}
10 & 11\\
12 & 13
\end{array}\right|,\left|\begin{array}{cc}
100 & 101\\
102 & 103
\end{array}\right|\big]\quad.
\]

\end_inset

This represents a kind of transposition operation for tensors of dimension
 
\begin_inset Formula $2\times2\times3$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "frame=single,fillcolor={\color{black}},framesep={0.2mm},framexleftmargin=2mm,framexrightmargin=2mm,framextopmargin=2mm,framexbottommargin=2mm"
inline false
status open

\begin_layout Plain Layout

// Test: use List as an Applicative Functor.
\end_layout

\begin_layout Plain Layout

implicit val applicativeList: Applicative[List] = new Applicative[List]
 {
\end_layout

\begin_layout Plain Layout

  override def pure[A](a: A): List[A] = List(a)
\end_layout

\begin_layout Plain Layout

  override def zip[A, B](fa: List[A], fb: List[B]): List[(A, B)] = fa zip
 fb     }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit val functorList: Functor[List] = new Functor[List] {
\end_layout

\begin_layout Plain Layout

  override def map[A, B](fa: List[A])(f: A => B): List[B] = fa map f
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Test value of type Sq[List[Int]]:
\end_layout

\begin_layout Plain Layout

val matrix2x2List: Sq[List[Int]] = Next(Matrix {
\end_layout

\begin_layout Plain Layout

  case (None, None)         => List(0, 10, 100)
\end_layout

\begin_layout Plain Layout

  case (None, Some(_))      => List(1, 11, 101)
\end_layout

\begin_layout Plain Layout

  case (Some(_), None)      => List(2, 12, 102)
\end_layout

\begin_layout Plain Layout

  case (Some(_), Some(_))   => List(3, 13, 103)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Apply `sequence` to the test value.
 The result has type List[Sq[Int]].
\end_layout

\begin_layout Plain Layout

val list2x2Matrix: List[Sq[Int]] = sequence(matrix2x2List)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Visualize the result by converting it to nested lists.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toSeqSeq(list2x2Matrix)
\end_layout

\begin_layout Plain Layout

res1: List[List[List[Int]]] = List(List(List(0, 1), List(2, 3)), List(List(10,
 11), List(12, 13)), List(List(100, 101), List(102, 103))) 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tests for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 method implemented in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Full-code-implementing-traverse-for-square-matrix"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:Full-code-implementing-traverse-for-square-matrix-tests"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sq[A]
\end_layout

\end_inset

 assures (at compile time) that all matrices have consistent shapes.
 However, it is hard to use because of complicated type parameters and deeply
 nested type constructors.
 To achieve good performance, square matrices and other tensor-like quantities
 are usually represented by flat arrays with an interface that recalculates
 the indices.
 When the dimensions of the matrices are known at compile time, one could
 use macros or other metaprogramming features to assure that all matrix
 operations are consistent, without resorting to complicated type constructors.
 Alternatively, one can use dependent types to constrain matrix dimensions
 at compile time.
\begin_inset Foot
status open

\begin_layout Plain Layout
See, for example, the 
\family typewriter
NDScala
\family default
 library for Scala 3: 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/SciScala/NDScala"
literal "false"

\end_inset


\end_layout

\end_inset

 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this is chapter 9 of the functional programming tutorial traversable functors
 to motivate the interrupted introduction of these factors into practice
 I always remember the example that you have a list of some data items and
 you want to process it by using a function like this where you have a future
 as a as a result of this function and the usual way of doing this in Scala
 is to use a function called future dot sequence and I have seen this I
 have shown this in a previous tutorial and the idea is that you want to
 process each element of this list with this function and you have to wait
 until the entire list is done so we have many separate computations for
 each element of the list encapsulated by the future for each one of them
 you want to wait until the entire list is done and basically this is the
 type signature that you want in order to implement this computation you
 have a list of a you have a function from a to future B and you want to
 get a list of B as a result and you can get it in the future so you have
 a future of lists of it as a result and that is the type signature that
 the function future that sequence will allow you to have with some work
 but in order to understand what this kind of computation does we want to
 generalize from the future to an arbitrary type constructor F and we want
 to understand what properties these type constructors must answer so the
 list we have L and instead the future we have F and the type signature
 of the function is like this so this function is called Traverse I believe
 there's also a future of traders with a type signature like this that works
 on sequences we want to generalize to some type constructors F and L and
 that's what we will be able to do once we understand the properties of
 this operation so this operation can be implemented for instance if L is
 this type constructor then what can we do in order to implement this operation
 well clearly we have an LA and we can apply map F so f is this function
 we can apply map F and the result will be this now in other words we have
 not what we want probably wanders F lb Inc which would be this so how can
 we get F of a triple from a triple of F's or clearly we need an operation
 that's similar to zip zip would be FB times F be going to F of B times
 B now we need to apply zip twice and then we get from here to here so once
 we have the zip we will be able to implement this traverse operation that's
 the conclusion so far so it seems that F needs to be a quick ative in order
 to be able to implement this type signature for at least for this type
 constructor so for this type constructor certainly it is easy to implement
 if F is if it has a zip operation then we can implement it like this so
 that is going to be a fundamental assumption not for the traverse operation
 to make sense the type constructor F must be implicative now the type construct
or L on the other hand doesn't we don't know what that is it could be applicativ
e or not maybe we'll find out but for now let's what say L is traversable
 if it has this operation now in Scala we have a very limited version of
 this Traverse which assumes L to be a sequence so it's not based on this
 idea of being traversable as such it's just that one of the properties
 of a sequence is that you can implement this operation and we'll see why
 that is so but for me the example with lists and futures or sequences of
 futures is the easy to remember example that helps me remember the requirements
 for the traversal duration so always think that I have a list of some items
 and the processing makes me a future so L is a list F the future and then
 it is clear that I want this kind of type signature I want to have a single
 future and when that future completes I want to have the entire list of
 process data that's the easy to remember example so not not the other way
 around for example not a list of future they're not interested in having
 a list of futures I want a single future with the final list of the results
 and so that's why this example helps me remember this somewhat complicated
 type signature where I could easily make a mistake they will a to L of
 B today to have fun being LF being instead of X well being it's easy to
 mix them up but so remembering this example that I'm starting with that
 what helps me remember the time signature of triggers so the questions
 that I'm going to answer in this tutorial in this chapter are to find out
 what factors L can have this triggers operation to find out if we can simplify
 with somewhat complicated type signature can we express it perhaps through
 a simpler operation what are the laws that is reasonable to require for
 this operation and finally to look at contractors and pro fungus do they
 have also some kind of analog of this operation in previous tutorials are
 started right away with practical examples of usage in this chapter I will
 first do more theory to understand in more detail and more deeply the propertie
s of this operation that will be easier to follow the usage examples so
 to simplify traverse we notice that traverse is a kind of lifting of sorts
 it's the arguments can be permuted so these are two curried arguments so
 we can take this one was the first argument and then we have la to FLV
 yes the second argument so it's a complicated kind of twisted lifting and
 we have seen several times already that often you can find a simpler natural
 transformation that is computationally equivalent to a lifting so let's
 derive that natural transformation that is equivalent to traverse to derive
 it I asked the question so why can't we have F map to do the work of Traverse
 f map would have this type signature it Traverse sorry this is actually
 yeah so so this is the type signature investment but Traverse needs F L
 be here instead of lfb so see this F needs to be outside and that's what's
 missing so we need to transform lfb with F inside into F L being with em
 outside so that's the transformation that is a natural transformation we
 expect to be equivalent the trailer so what's called a sequence so this
 is maybe not a very good name sequence kind of suggesting that we change
 the or the order of L and F in the functor composition not a very good
 name but that's a traditional name and I don't know how else to call it
 indeed we find that the functions traversing sequence are computationally
 equivalent so this is why well we have defined sequence likeness so then
 Traverse of a function f is computed by first doing F map of F like we
 get here then we get this and then apply this sequence function that I
 abbreviated to seek which performs this lets transposition of the order
 the type diagram looks like this so we start with a type LA and we can
 do Traverse from it directly with this trap function which takes F and
 director gives you from la f OB or you can first do F map so you have a
 function f under L you get instead of la l FB and then you change the order
 so you reorder the functions composition ever be to FM and the results
 must be equal so for any value of this type you go up or horizontal and
 the result must be the same value of this type that's the definition and
 as we have seen before this pattern implies that natural transformation
 is defined as a composition of F map sub sorry and lifting is defined as
 composition of F method natural transformation and then this natural transforma
tion is equal to lift and if you take identity instead of F obviously and
 so then that's a pattern we've seen time and again where the result is
 that traversing sequence are computational global you can derive one from
 the other and back and it gets the same function back so I'm going to spend
 time through again since it's exactly the same proof as we had many times
 just a different type signature and notice also F here is an arbitrary
 placated factor so these functions don't use the structure of f other than
 that it is applicative so that's that's an example we have seen just just
 before we implemented a traverse function for this type constructor by
 applying the zip function of F otherwise we don't you know what F is we
 just use zip from it and so we are generic in the function in the functor
 F as long as it's implicit if we don't look at the structure of F we do
 look at the structure of L so the Traverse function depends on the structure
 of L but it doesn't depend on the structure of F it's generic images future
 that sequence has this type signature and that's an example of a sequence
 natural transformation you note we cannot have the opposite transformation
 I'll show the example for that but well for future analyst you could make
 an opposite transformation for a future of a list and you produce a list
 or individual futures that are going to be all already copies of this future
 mapped to select one copy of the lid and of the element you can do that
 it's kind of useless to transform in the opposite way but what I will show
 on examples is that it's impossible to have this transformation in general
 and arbitrary it's possible for future not for arbitrary yeah so examples
 of traversable function functors this example we have already seen list
 is another example sequence in general and also finite trees various shapes
 there and also traversable an example of an entre versatile factor is there
 either Malad and also the lazy list or infinite product or stream is sometimes
 called lazy string so let's see why that is so let's implement the sequence
 for this type constructor first so I'm going to define this file constructor
 for convenience and the seek function is I'm just going to define directly
 it's going to have this type signature and that's just a zip apply it twice
 and then some reordering Oh nested tuple that results from the zip and
 we know this is associative because we assume that F is applicative now
 I'm using my own typeclass for F which I call the zip for applicative but
 you can also use cats applicative just has a slightly different name for
 things and it doesn't have the zip syntax so I like the use of zip syntax
 so I'm using my own type process here but it's equal to standard implicit
 if that was so the sequence function has this type signature just as we
 have seen in the case or filter balls lowlands and applicatives it's much
 easier to reason about this natural transformation rather than the reason
 about the lifting it's also will be the case of laws or in simpler to formulate
 so that's why I will always always define just a sequence function I will
 not define a traverse function the Traverse is easily defined in terms
 of a sequence - and I'm therefore in this tutorial concentrating entirely
 on the sequence function I'll never implement Traverse directly to save
 time so let's have another example that either as a functor either Z where
 Z is a constant type then the sequence must have this type signature so
 it takes an either of Z FFA and puts F outside so it's pulls the function
 f from the inside of our plan into the outside that's the time signature
 of sequence so how do we implement that all we need to match so if it's
 the left we have a Z to produce F of Z so the only way to do that is to
 use the pure method okay I mean interchange there were there blinds here
 the left z does not have any FFA and so in order to produce an F of something
 we have to use the pure method from F and then we apply that to the left
 of Z and then we get the right type if we have a right of FA then all we
 need to do is to put the right inside the width so we just map that we
 don't change the value of a we just wrap it to wrap it into the right type
 construction so that's the very clearly simple implementation so if we
 actually write this type signature using a shortcut notation then maybe
 it's even easier to understand how the sequence function works so if we
 have a Z then we just put Z inside F using the pure if you cover away then
 we just put a 0 plus a into that by mapping with the right type constructor
 so that we don't change this value hey let's see how to implement the sequence
 method for the Fortran type so here's a simple binary tree it has a value
 of type a and belief and it has a branch of two trees so how the hell does
 sequence work on a tree like we're in the leaf where we just wrap in the
 leaf like we did with this either and if we're in the branch then we apply
 the sequence method which is the same sequence we're defining is a recursive
 function them so we recursively apply the same since and as a sequence
 method to the left and to the right branches of the tree and then we zip
 them together so then zip is the operation in the F function wickety function
 so we can use that zip them together we get an F of a pair two trees and
 then we wrap that fear is a branch under the map so this map is under the
 tree sorry under the F function so f is an arbitrary negative function
 and we're using its methods map and zip here we used its metal period but
 other than that we did not use any knowledge of F so it is in this way
 that we are generic in the factor f we are not using any knowledge about
 the structure of f other than it has that it has a map and zip and puree
 method let us see examples of non traversable functors so here's an example
 it's a reader mode with a parameter in its non polynomial and so it will
 turn now that this is not reversible so let's see why what's takes on applicati
ve function f specifically like option a and let's find all implementations
 of this type signature which is the pipe signature of sequence now all
 implementations turn out to be just one and this implementation always
 returns none so it always returns an empty option ignoring its argument
 so it is not a very interesting implementation and we will see shortly
 that this would not satisfy was overprotective of over a traversable contest
 so this is this satisfies the pipe signature but it does not satisfy the
 walls we haven't yet seen the laws but it is reasonable to say that this
 function completely ignores its argument so it loses information and typical
 walls for a lifting would be identity and Composition laws identity law
 would tell you that some lifting is identity but if it's losing information
 it cannot be identity so it cannot preserve the data that you give it but
 if people lose it will always return empty option and so that's reasonable
 to expect when this note is not a good implementation and so there are
 no good implementations - thank you let's take another example and you'll
 see there's there's one implementation for this so we can actually implement
 this type signature for this duplicative functor this this code is what
 you would expect it's taking this function so what translate entire signature
 let's just e to the pair and this is pair of eternity doing now if you
 have a eat to the pair and you can produce a pair of Italy in d2 a that's
 very easy just duplicate your your function so we do have implementations
 from this book we're supposed to produce an implementation of sequence
 as a generic in the function so we cannot look at the structure from the
 functor F and have a different implementation for every effort want to
 be generic and so because we can we cannot implement it for some F we're
 stuck in this is not going to prevent reversible functor let's take another
 example where we have a pair so the pair of some type and a polynomial
 function and let's take this as the implicated and again we find them there
 is an implementation so that's fine well this is actually traversable what's
 considered the infinite list so the infinite list class needs to be defined
 because we cannot have the cursive type as a type an alien's we have to
 have a class and it's a pair of value of type a underlays evaluated tail
 choosing again an infinite list of time from all values of tightly so let's
 define a sequence method well we can actually define it it's quite easy
 you you take the head of the list you zip it with the recursive implication
 of the same function sequence to the tail from the list which will sequence
 were found commute the order of factories and then you wrap it into the
 infinite list again so that's similar to what our implementation for the
 sequence operation on a tuple except that it's recursive and it turns out
 this is infinite recursion let's check that the even the simplest functor
 have the identity function let's define it like this put some type of class
 instances for identity function ages tribunal was defined let's define
 an example value of an infinite list which is if you find like this it's
 a recursive definition we could do a lazy Val instead of def I believe
 but it's just cleaning doing them since it's a recursive function and you
 see the tail of the list will turn again the same list so it's going to
 be an infinite list of 123 on the whole the way to infinity so if we use
 sequence on this value then we get a stack overflow interaction because
 it's an infinite recursion so it's it's an infinite loop there's no way
 to implement the Traverse of an infinite list because basically what you
 would mean is we need to sequence like this we need to have a list of F
 values so it's an infinite list of an infinite list about four days and
 that should be mapped into an f of infinite list of is now how can we do
 that we need to pull F outside to the outside of the title which means
 that we need to evaluate infinitely many of these f's in order to pull
 off outside mean generically that's what we need to do we need to evaluate
 infinitely many elements of this infinite list in order to put F outside
 it's impossible to just pull F outside magically out of the infinitely
 many elements here and so even when F is just an identity factor s won't
 work it's impossible to pull f outside I mean it would be possible for
 identity factor of course but we have to be generic in the factor f we
 cannot use any methods on F other than zip and map and so we don't know
 what F is f could be something that needs to be evaluated in order to pull
 a out of it and so because of that it forces us to evaluate infinitely
 many elements before we even get a single value of this type and so that
 will never end and so that's impossible so for this reason an infinite
 list is not reversible and finally I mentioned that the opposite type signature
 isn't is unworkable so why let's make an example calculation so let's say
 L is an easier which we know is reversible F is this reader unit which
 we know is applicative so let's find all implementations of this time signature
 and we find they're not there is no implementation of this type signature
 the reason is that this type signature would have to map this function
 into this data but that is impossible you cannot extract Z out of this
 so you could not possibly return the Z because you need an integer so which
 integer are going to give imagine that this integer is a different data
 type you don't you don't have values of it necessarily for integer you
 could put 0 in that integer sure but that would not be reasonable from
 other types so you cannot possibly pull Z out of this because there aren't
 any special values of this type and you can also not get this function
 because you only have this function and this function could sometimes fail
 to return an 8 could sometimes return a Z so for some integers it could
 return is e and you don't know in advance for which integers it will return
 Z and for which it will return in a until you run this function on every
 possible integer you won't know that and so that's impossible to know and
 so you can't split this into a Z and into it you couldn't either split
 it into two functions into Z and into in the same for the same reason you
 in order to split it you'd have to run this function on every possible
 integer and see what the results are so that's unworkable and so that's
 why you don't have that's that's an informal reason why you don't have
 any implementations of this type and a final comment is that there are
 several ways of implementing the sequence usually so let's consider this
 type again we have seen we can implement a sequence by applying zip to
 x and here's another implementation we can arbitrarily select a different
 order so we instead of zipping one two three with zip to one I'm sorry
 this is a mistake two three say 1 and that's valid so the type is right
 and the laws will hold as well we'll see why so that shows you that there's
 more than one way of implementing the Traverse or in the sequence function
 which is equivalent for a given type constructor L different valid ways
 of doing it so let's find out if other polynomial factors are traversable
 now one of the central results here is that all polynomial functions are
 reversible we will show this quite rigorously later so for now let's see
 how we can implement the Traverse or the sequence function for an arbitrary
 polynomial function so we have done it so far for this and we have also
 done it for either which is a simple polynomial factor and the general
 polynomial factor would have this form it's got a polynomial in a with
 some constant coefficients which I here denoted as Z Y Q P so we have seen
 how to implement for a monomial so let's first consider monomial like this
 so one part of this polynomial then we can apply zip to these so first
 we look at lfb so RV has this type so we can apply zip to these we get
 this and then we can lift the Z into the functor F by just this standard
 factor map this function is always possible for any factor f alternatively
 we can do F pure of this Z and then this will become FZ and then we can
 zip it together with all others but the result will be exactly the same
 as using this function because of the law of identity for applicatives
 so the result is going to be this and then that's a sequence method for
 a single monomial and then for each normal you do this and you have a disjuncti
on of different results of type F of a monomial and then we lift it to F
 of the disjunction like we did in the either implementation so we we have
 seen therefore that we can perform the traversal equivalently the sequence
 operation on monomials and we can also perform them on disjunctions and
 therefore we can perform them on arbitrary disjunctions on monomials and
 that's arbitrary polynomial factor also note we could apply zip here in
 different orders wicked first zipless and then Z put Z on the right we
 can change orders in different ways and so traversal order could be application
-specific it could be necessary to adjust it for a certain application you
 can always implement in some order or automatically say but it might not
 be necessarily correct for your application and also we have seen that
 non polynomial factors at least some of them are not to her so so this
 is not reversible because we cannot have a reasonable implementation of
 this that does not lose information and there's this paper that I'm referencing
 here it's a complicated paper there in theoretical but it has a proof that
 only polynomial functions are reversible that that and and also they must
 be finite so infinite lists do not fit the conditions of their theorem
 only finite containers polynomial factors are essentially containers with
 data they can have different shape they can have many items of data or
 few or none it could be a disjunction of different shapes and they also
 can have extra data of some constant type in addition to data of the type
 a but those are the containers that are traversable and no other containers
 aren't reversible sorry you have a lazy infinite stream that's not reversible
 they have to be finite and they have to be polynomial so that is proved
 in this paper in a complicated way so I'm not going to try to understand
 how they did it I believe that this is so because I have examples that
 even the simplest non polynomial factor can't have reasonable implementation
 of sequence so even though all polynomial functions are traversable they
 are usually traversable in several different ways and so it's useful to
 have a typeclass to declare a specific instance of a typeclass expressing
 a specific order of traversal so this order of zipping that we can choose
 here corresponds to ordering of traversal in a sense we'll see that when
 we look at specific examples of traversing but now let's take a look at
 the laws because we have have been talking about the laws so far and we
 need to see more in more detail how they work so I prefer to look at this
 type signature of Traverse and to derive laws using the lifting intuition
 so it's a lifting of sorts and every time we had lifting so far we had
 laws of identity and Composition in other words there was some kind of
 identity here and some kind of composition of these and this has to translate
 into identity here and composition of these I will mention that there is
 this paper which is arguing what laws traversals must have from a different
 perspective not as formally as I have argued just now because my argument
 is completely formal Traverse looks like a lifting therefore it should
 have laws like the laws we had before for other liftings it's purely a
 formal argument saying that the form of this function is similar therefore
 it should have similar laws but this argument doesn't look at what Traverse
 actually does well what it does is that it evaluates some function on each
 element this one produces some effect maybe this F is an applicative factor
 which could be a monad or it could be known more and what it encapsulate
 some kind of effect some kind of computational context or a result other
 than B and all these contexts need to be somehow put together and be outside
 of the elbe so we need to reconstruct our container L inside the larger
 effect described by F so we need to somehow combine all these effects for
 individual values of a into one big effect which will be outside and then
 we have to combine all the values of B after somehow pull them out combine
 them again into the same shape as the container L inside the F so all that
 needs to be done by the traversal function and the authors of that paper
 argued that the traversal first of all should visit each element of the
 container exactly once it it should evaluate each effect exactly once and
 then combine these effects into a larger effect and using this intuition
 they formulate some laws that seem to fit this description in some way
 well they didn't actually derive these laws from these requirements but
 they showed examples where these requirements are violated and they showed
 that these examples also violate the laws so this is a little not very
 convincing to me that these laws are correct and therefore I prefer the
 more formal approach because I have more assurance but if I find some reasonabl
e identity and Composition laws that's a correct set of laws so far in every
 example we have seen with functors with contra factors filterable applicative
 and wounded every single example had a function with type signature like
 this which was life like a lifting in my terminology and in every single
 example there were identity law and composition law and these laws were
 equivalent to all the other set of laws that were derived from intuition
 and these laws also corresponded to some category laws now in this example
 I don't know how to formulate this in terms of a category and everything
 a way that would be simple enough so I'm satisfied that I find a law that
 looks like identity law and the law that looks like a composition law even
 though I'm not satisfied that I can find it easy enough category to reason
 about so that it's useful so I'm not going to talk about the category in
 this chapter I'm not going to describe this as a lifting from one category
 to another because I don't know if that's really very useful and I don't
 know a good formulation of that so let's look for these laws so identity
 law is that we map some special function here that is identity in some
 sense into a function here that plays the role of identity now the type
 signatures are not a to a they are a to f of B so what could be playing
 the role of identity here well the pure method obviously and F has that
 method by an assumption so the identity law is that if we put a pure method
 here than it should be lifted to this which is again a pyramid and except
 it's applied to a different type of parameter now another way of formulating
 identity is to say that if F is the identity function so then there's no
 F you just be then identity function here is all ordinary a to a and that
 should be lifted to identity elite really so f is just identity function
 and then this identity should be lifted to this so that is another way
 of formulating an identity law let's find out now to compose what will
 be the composition if we have two of these functions like f and G then
 we can compose them using F map but the result would be this because the
 F G would be nested now we take F be we map G over it and we get F of G
 of C now if F and G are in clique are applicative then the composition
 F of G is also applicative we know that from the properties of the platitudes
 and so it is again a function of the same type except that it has a different
 factor instead of F so f function G factor and the composition of such
 functions is going to be of this kind which which is kind of complicated
 it changes the functor each time so what should be on the right-hand side
 what should be a composition of these traversals now the composition of
 traversals obviously works in the same way so you have la 2 FL b and then
 FL b 2 f g LC and so that is your final traversal and that should be equal
 to applying the traversal right away with this function as a purgative
 factor so in other words applying traversal to this if that is true then
 traversal of composition is equal to composition of traversals so that's
 with a little twisting where we keep using F map in order to get composition
 and keep pulling all the functors F and G all the implicit is we keep pulling
 them outside with these twists it looks like just a composition law traversal
 of composition of F and G with some twisting is equal to the composition
 of the two traversals with F and with G again with some twisting so these
 are the laws we're going to examine and it will turn out these are exactly
 the same laws as this paper proposes when I first looked at this it looks
 like we have two identity laws are they really independent no they are
 it will see that but that's a question we need to answer also laws for
 sequence are probably going to be simpler because in our experience so
 far always we found that the laws became simpler if we consider the natural
 transformation instead of a lifting so let's find those laws for the sequence
 and finally with the laws in in hand we can try to answer the question
 of which functors satisfy these laws we have found examples where we can
 implement the type signatures but are the law is respected by those examples
 or not so that's the questions that we have after this point so let's look
 at the first item the dual so a traverse of pure needs to be Pierce and
 how fast if it's the first law let's look at the type diagram for this
 so we started from away we map it with pure where we map it with traverse
 of pure and it should be the same value it was type in favilla so that's
 the first one now the second identity law looks like this and it's clearly
 a consequence of the first identity law if we just put F to be the identity
 founder and the first law should hold for every applicative functors so
 we really just need this one law when the second one is a consequence so
 let's forget it so we have the identity law which is this and we have the
 composition law which we can write like this and the short notation so
 for any function of this type and the function G of this type and for any
 applicative factors F and G we have so the composition of F and G is twisted
 in the sense that G must be lifted by factor F so this is our twist on
 the composition other than that composition of two traversals is equal
 to Traverse of composition here will we twist and here we twist let's look
 at the type diagram we start again with LA first with Traverse with function
 f and we get F lb well then we want to traverse with G but G works on B
 so we have to we have to traverse just on this lb and F needs to stay outside
 therefore we use F map of F and we Traverse inside of F using the Traverse
 of G which is giving us this value F G LC or we could directly Traverse
 on the function H with respect to the factor f of G which is a functor
 composition so the factor H could be defined like this as a functor composition
 of F and G and we know it's applicative so we could just directly Traverse
 with respect to H so this can be traversal with respective H of a function
 H of this type this function is defined like that so this is the law that
 we demand now which will hold let's derive the corresponding law for laws
 for its sequence to do that we just Express Traverse like this your sequence
 and substitute that into the laws of chillers so let's look at identity
 law Traverse of pure equals P R so Traverse of pure equals this conduction
 legal pure so that's the law of identity for pure so pure lifted to Bill
 and then sequence should be the same as pure applied to the type parameter
 Helle I should also mention naturality law that's always the case for all
 of our examples so far such as filterable moon and imitative but all these
 natural transformations as well as the liftings they have natural tea laws
 for each type parameter that they have there's one neutrality law which
 expresses the fact that the code implementing that function does not use
 any information about the type it's completely generic in that type and
 so you can map this type to another type before the transformation or after
 the transformation and the results are going to be the same so here's what
 the naturality law looks like for the sequence now sequence has a more
 complicated type signature and its type parameter a is all the way inside
 therefore in order to transform in this a to some B we need to have a double
 F map so let's say there's some function G that transforms a to be in order
 to transform this a or transform that a we need to lift this G twice and
 that's how I would write it down so first we can sequence this LF a to
 FL a and then we can lift G twice in this order or we can first lift G
 twice in this order so that instead of LF a we get LF B and then we sequence
 on that so that should be the same function that's a natural t law and
 the code for sequence will automatically respect that law if it is a code
 that is generic type parameter a will never use any information about the
 type of a so usually naturality laws are satisfied automatically by generic
 code and so it's not important to check them but it's important to check
 the other laws so now let's look at the composition law we need a bit more
 work about it traversal of F followed by the traversal of G lifted so let's
 substitute the definition of traversal and then we get this formula now
 we can decompose a lifting of composition going to factor law so we can
 get like this now naturality law means we can interchange this and we get
 that and finally the right hand side is written like that so again we can
 do that because of the thumb tree law so in other words the composition
 law for traverse says that this is equal to this they have a common prefix
 that we can omit because these are arbitrary functions F and G for which
 this must hold and so it's sufficient that these things are equal so that's
 the law for sequence much simpler and here's the type diagram because the
 type types here are actually complicated so we start with an L of F G C
 C is some type parameter I could use a here but I just can't see now first
 we sequence with with respect to F and then we just pull F out and we get
 F LGC then we sequence with respect to G but we lift it to be operating
 inside of F so that means we interchange this L and this G the result is
 f G LLC alternatively we could sequence with respect to the factor f of
 G this is maybe not a very nice known notation not very consistent but
 this is the composition of functions F and G so it's the page I mentioned
 here I should probably for clarity I should use page instead of F G and
 so if we sequence with respect to F G that means we pull out F G at the
 same time to the outside and we get F G of LC so the result of these two
 computations must be the same having formulated the laws now can look at
 constructions and we can check that the laws hold we can also check whether
 some factors can be traversable when they are polynomial or when they recursive
 or they're not polynomial so we have so far seen some examples but now
 let's be more systematic about it here are the constructions that I found
 for traversable factors and I will go through each of them one by one now
 now before I do that let me explain what is a by traversable and by functor
 so by factor is a type constructor with two type parameters which is a
 functor in both of them so it has a map with respect to each of them separately
 and it also has a map with respect to both of them at once of course because
 you can just you can transform a to some C and B to some D separately or
 at the same time if you wish it doesn't doesn't it so that's a bi functor
 and by factors are by traversable in the following sense they have this
 natural transformation where we have an F wrapping each of the type parameters
 of s and this F can be pulled out by this sequence by sequence natural
 transformation and it should be natural both an A and B separately so that's
 the assumption and so you see this a and B remains and we have pulled F
 out to the outside so if statute transformation exists which is natural
 in both a and B and it has the same laws the laws of identity and the laws
 of composition now the law of identity is this and it needs to be adapted
 obviously to this by seek so that you have pure here and pure here and
 the law of composition obviously needs to be adapted as well because we
 have F G a F G B and so on but other than that it's a direct generalization
 so analogous laws must hold so let me now begin by deriving the laws that
 must hold for these constructions rather deriving the fact that the laws
 hold for these constructions first construction is constant functor and
 identity factor so both of them are traversable till you find that we need
 to define the sequence method and to show that the laws hold for it that's
 very simple so for convenience I'm just going to put a type parameter up
 front the constant factor is a function that doesn't end on its type parameter
 so L of F of a is the same as I've elevated Simon is this constant times
 e and FMLA is f of Z so sequence is this type signature and clearly this
 is f dot P R is just a pure of F functor can't in any other way produce
 a type signature like this but is generic in if we're not allowed to know
 what F is except that it has a pyramid zip and map so let's just define
 that as a pure let's check Louis so the identity law is that F map of pure
 followed by sequence must be equal to F dot P R now I'm putting here this
 underscore ell notation for clarity I could have said for example instead
 of F dot P R I could have said pure underscore F what I mean by this is
 that it's the method that is defined for the type instructor F such this
 method is not generic and F it is defined for each F separately in the
 typeclass instance similarly F map is not generic and L it's defined for
 each L separately so I could I could have written like this as well it's
 not Scala notation necessarily but it will do for now just for clarity
 to remind myself where these methods come from now sequence is defined
 for L so here I could write it like this to remind myself that the sequence
 is defined separately for each ill but it is generic and F so I could write
 it like that so sequence has F as a type parameter but L as type constructor
 or or functor for which it is defined in the Thai class now so let's see
 if we can verify this law F map is identity for the constant factor so
 this is identity and so this is just F here sequence is sorry F map of
 F of F here is identity function f map does not transform anything because
 there is nothing to transform we only have this Z cannot transform so this
 is just at the energy function you can cross it out and then we have the
 law that sequence equals pure at sequence equals pure by definition so
 the law is satisfied let's consider now the composition law which is the
 composition of sequence of F and the lifted sequence of G so now I'm using
 this notation with more sense in here I didn't have to say it's sequence
 Hamilton if I could just say sequence but here it is important now to say
 which for which type parameter is because the factor is a type parameter
 in sequence function so we have the sequence applied with respect to applicativ
e factor f and this with respect to G and F G is the factor which is the
 composition of F and G we just [Music] denote it like that for gravity
 so this is now sequence is defined as pure F map is [Music] defined in
 with respect to F so this is f naught F naught F naught L F map l was identity
 but F map F is not and we actually don't know what it does because it f
 is an arbitrary let's look at your family so you need to keep it symbolic
 so we have f dot P R which is this sequence and then because the Scala
 operation and then responds to my composition symbol and then we have F
 map F of G period because this is that the pure in G and that will be equal
 to FG pure but actually what is the definition of pure for composition
 of functions that's exactly this it's a pure of F followed by lifted pyrimidine
 so it's the definition of what pure use for the function f G and so therefore
 the law holds you now consider the identity function you know the identity
 function is like this or sometimes can it can be denoted by it with a capital
 I so this is identity factor I believe the cat's library does this maybe
 not maybe Scalzi so how do we define a sequence for it well this is just
 an identity function because it doesn't do anything because we we have
 f of a it goes to F of a because it is just wrapping it doesn't do anything
 so this is identity function we could even write this sequence function
 differently like this in order to underscore that factor that's just identity
 function now let's check the laws the identity law which is this now if
 F map is the identity function sequences identity function f map L is just
 this F map L is the identity function of its argument and because of this
 identity function and so this is equal to f dot P so this is f dot pure
 followed by identity and that should be equal to F dot penis clearly so
 composition is that we have a sequence followed by F map of sequence now
 sequence of anything is identity so it's just composing one identity and
 F map of another identity but we know that lifting F map of identity is
 again identity so this is just about composing one identity or another
 that's always going to be identity so that is also identity by definition
 and so this law holds let's move on to the next construction which is the
 product for any traversable factors G and H their product is reversible
 now I'm going to introduce my own typeclass which reversible just for convenien
ce but actually the cat's library has a traverse that class but I just want
 to show that this is easy and I prefer to define seek and they prefer to
 define Traverse in their tag class so that's why I have my own tie plus
 but basically this is very simple that concept has just one method and
 this method is Elif a to FLI traversal defined that method now this red
 is a problem with IntelliJ and install a plug-in cannot resolve the types
 it compares this entire code comparison works also we have a convenience
 method to get the Traverse into instance this drove in the syntax to use
 seek as a as a method rather than user so let me then show how I can define
 an instance of track of travel this traversable type was for this type
 constructor which is a product of l1 and l2 given that both l1 and l2 are
 traversable factors so first time to mend the functor instance well that
 is standard it's just a map this map that just a functor instance for product
 and then i implement the traverse instance using C so what am I supposed
 to do I have this a1 F a times l2 FA and I need to give F of L 1 a times
 Delta a so first I can say please so sorry first I can sequence each of
 these separately because l1 is reversible and all to escape most of my
 assumptions for a sequence separately both of them then I can zip the results
 and I get what I need so that's my idea about how to implement so I just
 say sequence the first one sequence the second one and zip now I could
 also write the code like this but then my IntelliJ doesn't understand where
 these things are coming from but the code actually still compiles if I
 do that so this is just much more your boss telling me where the sequence
 comes from from which factor and in principle I expect a scholar to be
 able to derive this automatically and it can this is much simpler to write
 about intelligent isn't like it so let's check the laws here so there is
 the identity law which is that we can map the pure and apply seek and that's
 the same as the pure so how do we verify this law well we substitute the
 code of F naught which is up here and we apply both sides of this law to
 some arbitrary value of this type and one until two so we do that looking
 at the laws actually we have to start from LA and the law will give me
 this so the value on which I apply both sides of the law must be of type
 le so that's why as eleiza is a pair of L 1 and L 2 and then that's why
 I take some arbitrary pair and i apply the law to it so the left-hand side
 first i apply this and that's going to be that there's a half map this
 is L 1 this is no true and then we apply the seek function to this now
 the code of seek is I'm going to write it like this in a shorter form and
 the result will be that I have this seek zip this so now we need to assume
 obviously that the law already holds for a 1 and L 2 separately and therefore
 for example we have this which is the formulation of the law for L 1 and
 so we can substitute that in here and then we get that now because of the
 identity law of applicative zipping of two peers is a pure of the peer
 so this equals F pure of the peer and that's exactly the same as applying
 F pure which is on the right hand side directly to the pier so we have
 verified the identity law let's verify the composition law this is how
 we could write it I have written out sequence seek of L seek of the hell
 everywhere it's just for clarity so in my notation that means a sequence
 made up defined for the tag constructor L applied with respect to the type
 parameter F so now let's apply again both sides of this law to some suitable
 value let's see what type that value should have which you have the type
 L F G C as the initial point in the time diagram so let's have an arbitrary
 value of type L F G C so sort of C values a here so L F GA naar betray
 value of that is a pair of l1 f g l2 f g and applying the code for seek
 to this we get a 1 FG a sikh with respect to f zip f l2 mg is equal respective
 so that applying just the first step according to the type diagram that
 would lead us in here which is f of LG F of L 1 G 2 G so now we apply F
 naught F of this to that now what is f naught F of CBG know seeing G is
 with respect to L sorry with respect to G over L so it acts on some value
 of this type and it will give this according to the definition but we need
 to lift this function was F naught s the difficulty here is that f is an
 arbitrary function we don't know what ethnic F does we don't have code
 for it we need to keep it symbolic so clearly we need to use a definition
 of zip F G somehow to find out what F naught F will do so the definition
 of zip of F G is this there's some FG x and f gy with zip them in the factor
 F G so so have G X is a type F of G of X G Y is of type F of G the definition
 of the zip for the composition is one of the constructions for applicative
 it's it's a zip in the F factor followed by F map F of zip in the G factor
 is this what we have in our formula not quite because we have not just
 something zip F something after which we we do F method but we have these
 things transformed we seek so let's transform using some function so let's
 use a natural G of zip so that we can transform like this so we transform
 under the factor f and so the result is the same as if we transformed FG
 x and f gy and then zip so that's a natural T you can transform first and
 then zip or you can first zip and then transform that's up to up to us
 so finally if we use this formula we can see that F map f of seek L of
 G is like this it's the F map F of this so this is seek L of genii because
 seek L of G gives us this kind of expression which is similar to this P
 of GX being sequence of this zip G and Q of G Y is sequence of this and
 then we apply this to those things and so the result is that F map of seek
 L applied to that is it's like that it's sick F map sick G and then seek
 F maps engine so that's what we find this really apply natural TMZ so that's
 the left hand side of the composition and the right hand side is that so
 these must be equal now the definition of seek F G is the code of seek
 that is just applied to this type parameter F G instead of that F so the
 same code and it would have been the same code if we could have this equal
 to that now these are six with respect to factor l1 so these are defined
 for l1 and these are defined for how to now we assume that for l1 l2 the
 composition law already holds so that means for example this so this is
 the composition law for a 1 and similarly for L 2 so therefore this is
 the same as this and that is the same as now and so the composition law
 holds for hell the third construction is disjunction so for any traversable
 factors G and H the disjunction is again a traversable factor so we have
 seen an example of implementing this in either and in polynomial factors
 but this is a general construction so let's see how to again we assume
 that factors l1 and l2 reversible and we defined well as the disjunction
 of l1 and l2 a standard factor instance but is Junction so now let's implement
 the founder instance traversable instance for the disjunction so here's
 how it will work we have this so we apply sequence to each of these separately
 we get this disjunction and finally we depending on which one we have we
 lift it into the F of disjunction using just constructors of the disjunction
 that left or right so that's how it works first we do a sequence on each
 of them so if we are on the left and we sequence it again this and then
 we map it with left apply which means that we put a left on top of this
 and left it's just a wrapper in a disjunction so it doesn't change the
 value and the same we do for the right now the redness here is again due
 to limitations of IntelliJ it's unlabeled transferred types directly but
 this code runs it compiles and runs let's check the laws at the entity
 law we do the same thing as before we just substitute the code of the flap
 in here and then we apply to some LA we'll know that both sides of the
 identity law applied to an arbitrary element of this type now since the
 code is symmetric with respect 1 or L 2 it's sufficient to apply this to
 some left of l1e and check the law for that so if we apply it to the left
 and we are in this case we have any left applied to to this which is well
 we are actually in this case and we're looking at F Nobel first so we are
 you want to lift like this now you notice we can't really simplify this
 because these are map and pyramids of factors that we don't know these
 are a one factor and if I look at your factor so we don't really know what
 these methods do we cannot substitute any more code so that's our symbolic
 computation right now we apply sync to this now we're on the left so we
 apply seek to to this which is I'm going to denote that a seek l1 to that
 and [Music] followed by map of left block now nothing more to simplify
 unless we use the fact that l1 already has this law and so this law for
 l1 looks like this therefore we can simplify here substitute that we get
 F P were of l1 a map left apply which by naturally T appear and we have
 pure of left over one a and that's exactly what the right hand side will
 do when applied to left of l1 e so identity law holds let's consider the
 composition law the composition law needs to be applied to a value of this
 type and again it's sufficient to consider the left and applied to that
 so first we apply the seek and that gives us in this now we apply f map
 F to belt and we notice we have F map F which is this one and another if
 map F so we can combine them and the result is that we have this two which
 we apply map with respect to F of this kind of function so we first do
 we left apply to that and then we further apply this function so now this
 is not quite Scala code because I have this map underscore F for convenience
 and clarity so that's just keep in mind I'm not actually using your Scala
 code here but I could adjust that the types will be less clear so now what
 does this do now this c g you know seek g has to act on the left and we
 need to substitute the code of seek when acting on the left it gives us
 this expression my definition of our seek up here so let's substitute into
 this and we get then this expression so now we can use the composition
 law that by assumption already holds forever so then we have this one Perelman
 which we can rewrite like this now this law is not quite giving us the
 expression that we want which is this expression because we have this function
 here but here we have another map so we're not we have another left apply
 to map and also on the right hand side of the law would have another left
 apply so in order to put another map inside the seek we use a net reality
 of seek we add this on the right-hand side which gives us this seek so
 seekers natural so we can apply seek to a transformed argument or we can
 apply transformation to the result of seek and so then if we define what
 lab FG is that is f map of F map and we put that onto the left-hand summit
 so that we have CK one of this map F of this map F both of that you know
 we can combine the map F this one with this one and now we have a single
 map F with a bigger function but that's exactly what we had for the left
 hand side and kill him before and so therefore the right hand side response
 is equal to the left hand side his code so the code is equal and the same
 would be if we replaced a woman so this shows what laws hold for injunction
 now let's consider there is construction for which is a recursive function
 defined as la equals some s of a and la so as s is an arbitrary by functor
 so this could be any type function of two type parameters and this equation
 this is a type equation it defines a type la recursively so examples of
 this are lists and trees different factors s can encode very easily different
 kinds of wastes and trees now this also describes infinite lists and infinite
 data structures and we have seen an example where the infinite data structure
 does not actually work you can implement the function without the recursive
 calls never stopped so that's the problem the laws will appear to hold
 in our proof but actually it will not work in practice so I will comment
 on this when I use the recursive assumption in the proof so let's see how
 it works so I introduced the biofilter as a type parameter up front so
 that I don't worry about it so much it's easier in Scala to do this now
 I cannot just introduce a type like I did here because reclusive type illnesses
 are not allowed in school so I need to introduce your class so once that
 actually makes the code a little clunkier because now and you need a name
 for the data value inside and I need to wrap and unwrap but that's a small
 inconvenience so the class contains a value of type s of a end of the same
 11 so this is a type function that I'm considering as a parameter and now
 I can implement a factor instance for this now this obviously is going
 to be recursive so in order to map this l 8lb i map a to be here and I
 need to map this la to L be recursively by using the same map so I need
 to do this under yes so I need to map at the same time a to b and le to
 l be under the type constructor s so that's by map so I'm mapping the two
 type parameters of s at the same time and then my map is a method that
 takes two functions with two type parameters so it goes a to C and in this
 case we have the by factor with type parameters a and L of a and so it
 takes two functions a to C and elevate to D gives us FCD so this is combining
 map with respect to the first router and map with respect to the second
 parameter in a single call which is completely equivalent to doing first
 the first type parameter with a map and then the second parameter with
 another map but it's just easier to do it with one method probably two
 and this is the recursive call to the same function so this is how we do
 it the functor instance now let's look at the Traverse instance how would
 that work so L of a is the same as recursively defined as s of a and elevate
 so now we need to transform this into this if we want to implement seek
 how do we do that well we can obviously seek here recursively so the second
 argument of s is a recursive instance of the same type and so we can assume
 that for that recursive intense instance we already have the implementation
 so that would be the recursive call to the same function so that would
 be transferring into Fla so now we have so we just do a by map where the
 first one doesn't do anything it's identity and the second function is
 a sequence recursively calling the same and now we do by Traverse or by
 sequence actually by sequence which is as I indicated before it's transforming
 s fafb into F si be pulling out the F at the same time out of both type
 parameters to the outside so we use that and transform s of F a Fla until
 F of s of any LA so this is exactly what we need so in other words seek
 is just a composition of by map and by seek but on that one factor now
 I can use cats library it has by functors by traversable and it has this
 voice sequence so I'm using white functor and white reverse which is canceling
 berry typeclasses just I could have defined them just as easily as the
 trove that class and the redness again is a some problem with types although
 I indicated all types explicitly but still it doesn't like it so therefore
 the Seekers just by map with identity and seek which is a recursive call
 followed by the by sequence call on the by factor so that's exactly what
 we plan to do first we buy map so that we seek under yes with respect to
 the second type parameter and then we do by sequence yes so that works
 and let's check the laws so the identity will need to substitute the code
 now for for clarity I still write f9l here and so on but it is easier now
 to distinguish sequence with respect to L and s because s is a by function
 so it has basic and violent and L has seek so I'm going to write seek L
 I could have done it like this but I'm not going to write it for quality
 for brevity so okay substitute the code of f9 that gives us this code which
 we defined here the lab instance the defunct our instance for help which
 maps using by map under F and the recursive on the second so let's write
 it down so this is a by map of this function and the recursive FF L as
 a second argument of why map so the same function as we're defining here
 is here so now we need to apply secrets the result is this followed by
 by map actually followed by bicycles remind myself what is my definition
 of sequence for you yes just take the S out of the case class which I'm
 not going to write here because it's just wrapping and unwrapping we want
 to pretend that this case class is just a type so first it's apply map
 with identity and seek and then it's a buy seek on the result I'm going
 to ignore this because this is just wrapping right so seek is by map followed
 by by sick this is sick L so we have this expression now we can combine
 the by maps just like we can combine maps because they're by factors it's
 just first we have a map in the first type driver so we combine these two
 which gives us this and then we have a map in the second type planner which
 combines these two and that gives us that so f map L and then seek is the
 same law that we're trying to prove not F not LPR and then seek is f pure
 so it's a recursive invocation of the same law and we're trying to prove
 in the second function of Y map so we can use an inductive assumption that
 we already proved that by recursion and therefore we just substitute into
 this expression we substitute F P R inside of this because that's a look
 so then we get by map of pure pure by seek and the identity law for s means
 that s by map pure pure basic is the same as s is just pure and so that's
 wasting holds for Escalades by traversable function by function and so
 this becomes the right-hand side of the identity law and that's the proof
 of the identity law so now let me mark about using the recursive calls
 and it is that inductive assumptions corresponds to recursive calls in
 code so in mathematics the inductive assumption is that on the previous
 step things were already proved in code it means that we are going to call
 the same function recursively assuming that it will return the correct
 results then our step also returns the correct results but that assumes
 that the recursive call terminates and actually returns the results and
 we have seen an example that on the infinite list it does not return it
 has anything to do and so that's where it is going to break so actually
 the inductive assumption can be used as long as all these functions actually
 terminate their evaluation and return their results and if so then it's
 off it's all fine but so at this level we will not see any problem with
 infinite lists we are using the inductive assumption and everything appears
 to be correct however we have not established that these functions will
 actually return at all and for the infinite list they don't and so for
 some factors defined using this construction using some by factor s some
 factors will have infinite loops and others won't so that is a separate
 thing we need to establish in order to check that they are actually reversible
 this is usually not a problem for factors because this map is going to
 be cold maybe later and this is a lazy call and so there is no infinite
 loop but we have seen we do a bye map and then we do a buy sequence and
 so that call will evaluate everything and that will break for the infinite
 list now all I'm saying is that this proof of laws and the same will apply
 to the proof of the competition law that I'm going to talk about shortly
 this proof is only as good as the fact that all the functions return and
 if you have an infinite loop in one of the implementations then as proof
 oh well great because the inductive assumption cannot be used because the
 use of inductive assumptions is is translated into recursive calls in the
 code and if those goals never terminate them you can't call them so I'm
 not going to present an analysis here as to what possible functors s are
 admissible because I don't know how to do that analysis in general so and
 that's a much more difficult topic of recursive types what are the reclusive
 types for which certain methods would terminate and that's for another
 chapter so from now we will assume that we check separately that all the
 methods will terminate and if that is so then this proof is correct we
 are allowed to use inductive asymmetries let's look at the composition
 law so this is the composition law and the law is an equation both sides
 of which need to be applied to an arbitrary value of this type let's check
 so L F G C so use a instead of C I'll probably check rank it in the slides
 that it is a and not C I'm using a in the code consistency so s of F G
 a L F G so that's lfg so let's apply both sides of this law to some value
 of this type and we get first sequence which is by map of identity and
 sequence followed by by seek and then we do a map of seek which is a function
 that takes this and does a by map and and by seek but now with respect
 to G so I'm just writing it out what the code is for seek and this should
 be equal to by map for the advicing but with respect to FG so that's our
 law let's check that the schools and we certainly assume that it already
 holds for for the s by function which means that this equation holds and
 by seek map is by seek now this is just a law this twisted composition
 of seek can seek is seek so how do we use this in order to prove this now
 clearly to use this we need a value of this type which is not the same
 as what we have here now this is s FG x FG y so is very homogeneous it
 must be the same functors FG and we don't have the same factors here we
 have F G and L F G so this L is outside if L were inside of all of this
 here then we could just say this is why this is eleve is why a is X and
 then we are of this shape so that means we need to permute L over there
 so in order to do this we need to sequence this with respect to F G and
 then L will get inside but we need to use the sequence inside the type
 constructor s which requires a buy map now this is going to be a buy map
 with respect to the second type parameter of S which is the recursive invocatio
n and so that by map and sequence is a recursive call to sequence therefore
 we can use the law of composition for that as if it's already proved and
 we will do that so here's what we do so in this law that we are going to
 use now we're substituting this value s FJ XY which is defined like a by
 map or a sequence with respect to L and respect to F and then G and then
 that's of the right shape with X equal to a and y equal to L of a so that's
 what we wanted and the result is this expression which is a by map followed
 by by seek followed by map now we can certainly use natural reality and
 exchange map sorry no we we here we're having basic F map by CG that's
 what we're using here it's a basic FG that's that's the law we're just
 writing out the law we're substituting s F G X Y into both sides of the
 law services here and this is here so this holds this is an equation that
 holds so now by inductive assumption a composition law for sig L already
 holds when we use it here and so therefore we can rewrite this right-hand
 side like this this is just sick L of F G now this right-hand side is the
 same as the equation that we need to check which I noted as a start and
 just marked labeled that equation by start for convenience so the right-hand
 side of that equation is now the same as this therefore it's also equal
 to that so it remains to show that that the left-hand side is equal to
 the left hand side of star let's write it down so like this yeah it's really
 easier to compare so by map now we have this instead of that and we have
 a by seek and we have a map of by seek instead of this now if we look carefully
 we have a map f of by seek and here we have a map f of something that's
 followed by by 6 so that can be pulled out with a map F and omitted so
 this is a training lab F by sake of G in both of these so as we just a
 minute forget this so now the problem that they are not equal because we
 have a different order of by seek and map so have a by cyghfer by map here
 and here we have a map followed by by seek when we need to interchange
 a map and the natural transformation that's naturality law and it's the
 same way for by factories just by secant by map can be interchanged let's
 write down the naturality law for clarity it looks like this so we have
 a basic follower by map f of by milk of something and then we have a by
 map of map f of that function let other functions we have two functions
 because by map takes two functions both of them need to be mapped and then
 we have bicycling so we have interchange the order by seek and map f so
 if we use this law in this equation then we get that the first line is
 equal to again we can interchange by c combining up and we get by C cadine
 so now we have by map followed by by map followed by by seek by map can
 be combined and then we have this by map fold but by seek and this is exactly
 the left hand side which is this emitted by C kanji sorry this one so this
 concludes the proof of the composition law and therefore we find that this
 construction was valid now the question is which by factors are by traversal
 and the answer is the same all polynomial by factors are by traversable
 now we see without recursion these constructions 1 2 3 our constructions
 that allow us to get any polynomial factor with arbitrary types in it doesn't
 have to be monoid like in applicative can be any any constant type any
 polynomial function these constructions cover all these cases now construction
 to even has two different implementations we can zip in one order or in
 the opposite order it still will work and therefore all polynomial functions
 at reversible now exactly the same constructions worked for by traversable
 constant and a and B are quite reversible in the same way as constant an
 identity function traversable and products and disjunctions are by traversable
 and so-called by traversable polynomial by factors can be used in this
 construction I'm not going to go through proofs for these by functor constructi
ons they're pretty much the same as the proofs I went through except you
 have more type parameters to worry about what implementations are exactly
 the same and so the conclusion is that all polynomial factors including
 recursive polynomial factors as long as the Traverse and seek methods return
 in finite time and they not go into infinite loops as long as that is the
 case all polynomial factors at reversible all polynomial by factors also
 traversable and you can go on you can define a by factor by recursion using
 a try factor in the same way you can say sa B is equal to some T of a be
 s a B or T X Y Z is a try factor and as long as that try factor is tried
 reversible exactly the same proof would show that the by functor is by
 traversable so you can have recursion at any level as long as it's a finite
 level of recursion obviously at some point you would have some n factor
 that is not recursive recursive and or maybe several of them and then as
 long as that's polynomial is going to be 2n traversable and then you go
 back and have your n minus-1 traversable recursive thumpers and so on and
 so it's clear that all polynomial factors with arbitrary recursion so it's
 it's a tree for example whose branches can be themselves lists or you know
 you can have a list of branches or anything like that all of that is traversabl
e so that's a major result of this consideration so now let me consider
 foldable functors now we we know the fold operation in a standard library
 it's a full left turns out that the fold operation is a consequence of
 having a traverse operation and later we'll also see that the scan operation
 the scan left is also a consequence of traverse operation so how do we
 derive the fold from jurors the main idea is that we should take a specific
 applicative factor which is a constant factor fa equals a constant Z or
 is a Z is a monoid type and so the zip operation on this factor is just
 a monoid operation which I will denote like this and we have seen in Chapter
 8 that these are applicative now the type signatures are much simplified
 now in type signature of triggers becomes this and this method is called
 fold map well the does is that it takes a container of type of values of
 type II and takes a function that map's each value to a mono it and then
 it traverses the container and combines all these monoid values into one
 big monoid value and that's for example aggregation and any kind of aggregation
 Sun Oven integer list or some pointer so the general method with an arbitrary
 monoid which is generic in the monoid is called faulkner the type signature
 of seek becomes simple like this so and that is just to concatenate all
 monoid values in the container into one using the monoidal operation so
 this is called M concat now there aren't any more laws because the laws
 are about combining oh the identity law will be automatically satisfied
 and the composition law is trivial because you can't compose these things
 because there is it takes two more nodes compose them you get the second
 one the first one is just just going and so all these laws are trivially
 satisfied there aren't any laws anymore for this foldable operation for
 the fold map there aren't any laws and all traversable functors have these
 operations now nevertheless it's convenient to define the foldable typeclass
 that has these operations like fold map and M concat and fold left because
 you could traverse the containers in different order and that would be
 different implementations even though there are no laws and it's basically
 a consequence of traversable so there aren't any factors that are foldable
 but not reversible so all polynomial factors and only the polynomial functions
 are both foldable and traverses and and so nevertheless it's convenient
 to define this typeclass because you can have different implementations
 of fold for different order of the traverses and finally let me show how
 to define the fold method and that's a trick where you take this as your
 manual type now this is a mono eight where B is an arbitrary fixed type
 and these functions are just concatenated by composition and the identity
 value is the identity function now if you substitute into the following
 up into this substitute B to B you get this type signature it's a curried
 function with one two three arguments so if you just rearrange these arguments
 you see this is exactly the type signature fold left it has your container
 it has initial value it has the update function and it returns the final
 accumulated value so monoid is gone we have a specific one right here the
 arbitrament already that is is gone until we have an arbitrary type B so
 if we put B before this argument and it's not obvious where the money went
 but it is just a consequence of a signature of Traverse where we first
 put them on oil in it and then you specify to this node and so for this
 reason every foldable has a foolproof method for map and M concat and every
 traversable also has them and so now we know which factors are foldable
 and reversible so let's ask our contra functors useful or profanity was
 useful in the same capacity because you could imagine that you want a conscious
 factor that you Traverse with respect to a function or my servers and my
 answer to that is after several analysis is that they're not very useful
 here's why let's take a contra fantasy now let's try to do a seek on it
 so that would be this kind of time signature now if I have a CFA I can
 control map with the pure method the pure F which is a to FA I can come
 up with that to get CFA to see a so I can get down and then I can put that
 into the F using pure F so I get F CA and in fact there is no other way
 of doing this generically now it seems that wall control factors are automatica
lly reversible and I could even say F doesn't have to be a factor it's not
 using map well if I'm just using pure life and so it's it can be arbitrary
 Pro functor as long as it has pure it's actually applicative proof functor
 or even just appointed with a pure so it can be just just like that so
 is that useful well in my view it's not useful because I completely ignore
 all effects of EV I'm using pure of F so whatever F ahead here I'm ignoring
 its effects I'm never going to have any effect full value here either it's
 going to be always a pure so it's not very useful and in the other direction
 you can't do it f seiei to CFA because you can't extract out of F necessary
 now if you have a proof factor see anything things are not workable here's
 why consider this simple example a simplest growth factor just neither
 a functor nor control factor because it has a in both covariant and contravaria
nt positions now we need a sequence function of this type signature but
 that's it's it's impossible we cannot get an F of a to a unless we somehow
 get an a to a first but we can't there's no way to extract a to a out of
 here so I can't get an A you can't get an F of a and so there's no way
 to do this so so the only way to implement this type signature is to return
 pure F of identity here but that ignores its argument and functions that
 ignore its argument will not respect the identity law they will not preserve
 information and finally let's try to try to traverse profile too with respect
 to proof hunters and we find again that the only way to do that is to ignore
 all effects here are two examples so consider this contra factor and this
 contra factor then now if it's applicative it means that s is a mono it
 and so this type the only way to implement is to return an empty value
 of F on the right ignoring all of Fame and the second example is you take
 this contra function and this function and again you can show that the
 only way to implement sequence of this type signature is to always return
 empty option and again that would ignore its argument and so it's most
 likely you're not going to be useful because we ignore all the effects
 will never return anything that's not empty and so on so we we are able
 to implement these type signatures let's see I have I have this test code
 here for a check that we can actually implement only one type signature
 and that it returns an empty option in both of these counter examples so
 take a look at this in more detail if you feel like but I'm of the opinion
 right now that since all of these examples show that I have to ignore all
 effects I have to return a value that ignores all the input data or ignores
 all the effects in the factor or per factor f that's probably not a very
 useful implementation but there isn't any other also note that the laws
 of jurors suppose the notes actually say that effects of f cannot be ignored
 they don't actually say that so you can traverse each element once and
 that's guaranteed but then you can just ignore the effects maybe well for
 some functors that's possible as we have just seen so the conclusion is
 that traversable contractors and pro founders aren't really so great and
 aren't very useful let's look at some examples where we use traversable
 factors the first example is we can convert any traversable factor data
 structure to a list to do that we will actually have a trick and that will
 all define a list as a monoid not as a type constructor is a constant type
 but as a monoid so it will be a constant factor so to express this i define
 the type constructor z which has a type parameter b but it's equal to list
 of c or c is a fixed type parameter up here so it's not depending on B
 so this will be a constant factor which are defined like this so it doesn't
 change anything the type parameter is not used and it's applicative as
 well as a constant for a factor that is a monoid so I define the evocative
 instance using the rajab and this is an eel and a monoid composition or
 concatenation of lists and just for fun I want to define the monoid composition
 in the opposite order [Music] so having defined this and now have Z as
 a applicative factor and I can use chillers which is this function that
 I defined for convenience on the reversible value and so now I Traverse
 F of a which is this L of C probably better cold now this L of C is of
 type unknown type constructor hell so we Traverse it with a function that
 takes a value of type C and returns a list containing a single element
 C the result of traversing is that for each element from the data container
 L will have a list of a single element and then we will concatenate all
 these lists because that's the effect located factor Z and we need to combine
 all these effects for it all values in the container health and the combining
 is done using the monoid composition and so then the result will be a list
 of all elements from the container l so let's see how that works we define
 L like this we have seen the implementation already and now we define a
 value of this type the value is triple 1 2 3 and then we did recall to
 listing it and the result is a list of 3 2 1 because we have defined the
 opposite order here so if we define a straightforward order we would have
 a list of 1 2 3 otherwise we have a list of 3 2 1 so in this way we see
 that any traversable factor is a data container that can be converted to
 lists and the order of list elements depends on the order of traversal
 which is specified by the traversal hibiclens instance the second example
 is to aggregate data from a tree by using a fold so in fact since fold
 is an operation of traverse where the negative factor is a constant factor
 here we have just used fold map essentially we don't need traversable here
 we it's efficient to have foldable we could have defined this function
 by folding with with a list but let's continue using traverse just so that
 we understand these are very much related to each other so here's a definition
 of a simple tree tag it has a leaf of type A and it has a branch with two
 trees now we define the function instance in the usual way and then we
 define the traversal industry which is defined also in the usual way this
 is a recursive construction construction for and so I'm just writing it
 out this follows from the recursive construction if we have a leaf and
 we just put the leaf constructor under F and if we have a branch and we
 run sequence on both branches this is a recursive call to the sequence
 function that we're defining right now and then we zip the results and
 put the result in to pull under the branch here are some example values
 of this type so this is a tree of integers and this is a tree of strings
 and I driven this picture to visualize this tree t2 has a more complicated
 structure T 1 is just 1 2 & 3 it's easy to see what T 2 is not so easy
 to see anymore so let's fold over T 1 so T 1 is 1 2 3 in order to fold
 let's define a 1:08 for integers which will be a multiplication and what's
 the fold map with a function that squares each element so the result of
 fold map will be the product of squares of all and of all the elements
 stored in the tree which will be 1 times 4 times 9 which is 36 the third
 example is to decorate a tree with order labels obtained from a depth-first
 traversal so for instance this tree if we Traverse a depth first then first
 we'll reach a and we'll reach B then C and then D so then the order of
 traversal is 1 2 3 4 and so we expect these labels to be attached so how
 do we attach labels like this way it's not just a map map would we can
 certainly attach constant or a function of each of the label each of the
 element but that's not we won't want to attach a value that depends on
 the traversal so that's the Traverse and since it depends on the traversal
 we need to compute it as we go and so that's I mean we need to maintain
 state as we go as we traverse the tree and maintain in the state can be
 done with the state monad so we use that statement others duplicative function
 and that expresses the effect that we are traversing with so to visualize
 this traversal I could say that we are first so let's Traverse t2 since
 we have it on the screen so we first Traverse t2 by visiting a and we have
 some function that takes a and returns a monad value or a purgative function
 value in general now we done this being and we combine the effects so we
 have four different effects in these four different a purgative functionaries
 we need to combine them using zip and so the result is an F of tuple of
 a B here and then it's going to be this nested tuple so it's f of domestic
 tuple and then we have to recreate the three structure out of that nested
 tuple by remembering where these a B and C and D were in it in the tree
 and we have to reconstruct a tree under F so this and I'm not going to
 write much more detail with basic analysis so it's to be reconstructed
 as the value of this type after after zip and you would just have an F
 of some tuple and you could have converted it to a list first but then
 you completely lose the structure of the tree so the traverse operation
 must somehow keep track of the structure of the continue and you recreate
 it after zipping so it zips the effects so the effects are combined linearly
 in the traversal order using the zip and then after the effects are combined
 effects are mono it always of some kind so they are combined linearly there
 is no tree structure only effects but there is tree structure on the values
 ABCD or whatever values you get after you transform them with the function
 f and so those values have to be arranged so that could be of type B those
 values have to be arranged into the same tree structure as before so now
 we are going to use a state monad as the positive effect and statement
 others applicative and you will use if statement values together what happens
 is that you update the state each state mullet value could update the state
 in some way and so this is a linear sequence of effects that you need to
 combine by updating the state first using this updater than using this
 updater and so on in the linear order of traversal and that's what well
 we will use now we'll have a monadic value make label so we define first
 of all a state monad I'm using the Katz library with integer state so for
 convenience I'll call this s right now just in this test so I'll I define
 a make label value which is a monadic value that updates the state and
 returns also this value that is the previous value before I'm dating I
 could return the next value it doesn't really matter and that's going to
 be melodic value that we are going to produce for each of the elements
 of the tree now we actually need to represent this as an applicative factor
 so let me just quickly convert to my zip typeclass which is my my version
 of applicative of course the cats library already has a positive instance
 for this but it's easier to use my my typeclasses because they're very
 small they don't have a lot of methods and it's easy to see what they do
 so we need to define the wrapped unit which is just a pure of state factor
 and we need to define zip which is defined in a regular way for anyone
 that this is just combined the two effects in this order we could have
 changed the order here so this is this is a freedom but let's just keep
 this order and this function will allow us to produce her with zip tie
 plus instance from a statement well you know what's right a tree traversal
 so a tree traversal we already implemented up here so I just copied this
 code in I don't think I needed to duplicate nice code we can just remove
 this code so how do we use that so we have t2 which was defined before
 that we Traverse using the effect type yes so this is the apocatip factor
 that we have now a wizard instance for we have this was a probe s and the
 result type is going to be a tuple of string int so we're adding an integer
 label to a string type of the tree which which t2 has 32 think and the
 type is tray of string so the function with which which reverse takes a
 label and prefer this make label operation which is a monadic value and
 then we map now this magnetic value returns the integer and then we map
 that integer into a tuple with the previous tree leaf is really called
 leaf action to be more clear so we map a tree leaf to a tuple of leaf and
 label and we get out of the Monad so now this is a value of type s of tree
 of string int so this is a result of traversal and now we need to run it
 so we run the statement out on the initial value one and we extract the
 value out of it so this is that cats library API two is to extract values
 from statement and the result is as expected so it's a labeled with 1v
 we still in soon so in this way we can decorate the tree with labels that
 are computed as we go on in a traversal the next example is templum and
 skin functions scan map and scan left so we have seen that fold can be
 implemented if you have it reversible and scan also follows from properties
 of traversable so scan map is something I made up it's a method analogous
 to fold map where you have a monoid and you map your data to a monoid type
 and then the result is that unlike fold map it's not just one monoid value
 that aggregates everything you don't just accumulate the final value you
 keep all the intermediate accumulated values and put them back into your
 container so this is like the scan function so how does it work we use
 a statement again it's state is the MU node so initially it will be empty
 and then we will accumulate a monoid state so this is how we accumulate
 we get the previous state and we set the new accumulated state and then
 we get again in new states so that we have it on hand and then we Traverse
 with a function that is f which is this given F followed by accumulate
 and so the result is s of Z which is a state that accumulates Z and also
 gives it as a value so after traversing we get a value of type s of L of
 Z's and then we run it on an initially empty value and that's what we return
 extracting out of the state monad after we have run it so here's the test
 let's use a string as monoid so we imported a cat's instance just for standard
 string 108 and let's do a scan map on t2 with no transformation so then
 we're just going to accumulate the string as we go so we get a a b a b
 c a b c d so that's the result of scan map and we can also implement the
 standard scan left function which is very similar except we don't accumulate
 a monoid now we just accumulate a value of some arbitrary type z and we
 do the same thing as we did before very similar code and here's a test
 so we let's accumulate the length of strings in the in the tree so then
 we'll get one two three four because all all strings have length 1 and
 the last example is the traverse a rigid tree or non monadic tree as I
 don't think vegetation well it is a widely used word to describe this kind
 of tree but basically imagine a tree that must have all branches fall so
 it cannot be unbalanced then it must be full it's a binary tree that must
 have one two four eight 16 32 and so on elements and no other number of
 elements can be in the tree that's very rigid in its shape this recursive
 type equation he finds it and you can easily see why so it's either a or
 it's the same T of any times a so then it's either a times a or the same
 tree of a times a times a times a so then it's for A's or eight A's or
 sixteen is consumed so it's it's at this infinite disjunction with 1 a
 or 2 is 4 4 8 or 8 8 and so on so that's that's why this equation works
 not we don't have a construction where I did not write down the construction
 that can generalize this tree this kind of construction could be generalized
 like this where you have a recursive equation with some buy furniture yes
 and the second type 300 - 2 s is not a la as it was previously not just
 LA but it's L of some RA where R is another function so in this case it
 will be a pair but in general it could be some other function and that
 function must be both applicative and reversible and if so then I believe
 if this construction will work as well so this is a more general recursive
 construction let's see the code for this so the definition of the tree
 type is this it has a single element in the branch which is a tree of the
 pair parameter instead so we substitute to the type parameter which is
 kind of non-trivial so we can define the functor instance which is a bit
 of work because now we need to map this branch of type 3 of a a we need
 to map it recursively with a function that map's a a to be me but we don't
 have that function we have a to be so we need to construct a function that
 map's a a to be B out of F and the traversal is again a depth-first traversal
 where the leaf is handled the same way as before but the branch is handled
 differently because we actually have this kind of type and we need to get
 this so we need to do we need to use zip for F in order to pull F out of
 the tuple and so we first zip the FS together like this and this needs
 to be done under the B so it's a b fa fa map of the zip so that's going
 to have B of F of praa and then we sequence that so we get F of of PNA
 and then we wrap it into the branch so that's how traversal works and certainly
 we tested you know this is how we would create this data structure so it's
 always branch branch branch branch and finally leaf with a very large may
 be nested tuple so this is why this tree is so rigid he does not have cannot
 have unbalanced shape so that works we use in mono omoide instance for
 integer and do a fold map with identity to get the sum of all these numbers
 so these examples indicate that we can do a lot of things with Traverse
 but there are there are actually things we cannot do using each others
 because the Traverse separation we remember it is an operation that needs
 to be generic in the effect against which we Traverse in this applicative
 factor so two things that cannot be implemented the traversal which you
 find interesting but this is so or the breadth-first traversal for a tree
 so imagine a tree of this shape and you want to do breadth-first traversal
 so you traverse first at this level you get one and you traverse at this
 level you get to an elite reverse at this level now that can cannot be
 expressed as a traversal with some effect because as I indicated here to
 visualize a traversal we need to imagine that we are computing a large
 linear sequence of effects into one combining a large linear sequence of
 effects into one big effect and now in order to express this you would
 have to have to know for example here that this two must be two and not
 one now this effect cannot come from just recursive traversal you cannot
 just take a usual recursive depth first traversal and run some more nuts
 and clever Monat with it and get this other chamber so now we certainly
 probably can implement it in some other way but I don't see how you can
 simply do a recursive function on a tree that traverses it against an applicati
ve factor and get this effect and especially when you call recursively on
 this subtree you need to know how many nodes will be in some other levels
 in some other subtree so it's not clear how you could possibly get that
 information from any kind of monitor or [Music] applicative function now
 certainly you can implement breadth-first traversal but what I'm saying
 is that you cannot take some special monad and some recursive function
 calls and implement it so easily I hope you can still implement it in some
 way that is not too bad as a traversal certainly the standard way of implementi
ng breadth-first traversal to use a queue or you in queue each node and
 then you in queue it to children and then you DQ and as you dqu in queue
 more so that can be certainly done in a statement that that computation
 but the problem is you need the traversal which recreates the original
 structure so if if all you want is twofold then you can implement fold
 in a breadth-first while using a queue like that but what you need is to
 recreate the original tree structure and that's very cursive structure
 that has a depth-first logic to it and so that's the difficulty and certainly
 you can do it with a lot of extra work it's not just a couple of lines
 of code like it was for depth-first traversal so at this point I don't
 have code for this maybe this can be done in some clever way but I haven't
 found it and the second thing that I don't think you can do is to label
 depth of the tree using a traversal so again it's a similar problem that
 effects so these aren't going to be effects and obviously you need some
 kind of state to hold this one and then update it to two and two three
 but effects are concatenated linearly and so it cannot be that this three
 is the same as this you cannot avoid concatenating this effect with this
 one when you do a traversal because of this linear nature of combining
 effects and you cannot avoid combining effects during traversal and so
 there's no way to skip incrementing the counter when you do choose ourselves
 so I don't think you can easily express this kind of labeling and this
 is trivial to do ad hoc as a function on a tree but what you want is to
 have a generic traversal which is generic in the factor f and just uses
 the zip and combines the effects and that's why traversals are not so flexible
 you cannot avoid incrementing your counter you cannot have logic that says
 oh here I don't increment because they're at the same level can't have
 that logic you must combine the only factors together so I keep talking
 about being generic in the function f so let me talk about it in a more
 rigorous manner so what we're looking for is to be generic in the sense
 that the code for traverse as well as the code for the sequence in it should
 not depend on a specific function f it should only use the methods P R
 and zip or maybe map as well from F and [Music] recall recall how we dealt
 with a similar problem when we discovered founders so a factor is a data
 container that is generic in type of the data that it holds and the map
 function or F map is a function that cannot use specific type information
 about A or B it must manipulate this data blindly with no change you take
 a container you take each element a very replacement may be and put it
 back at the same place but you don't know what types those are and so we
 expressed the law of natural T for various functions by saying that F map
 should come should commute with those functions so you can transform first
 or you can transform later and that's what it means that it's generic in
 the type of data so similarly generic in the function f means that if we
 map a functor F to some other function G then a traverse with respect to
 F will be mapped to the Traverse with respect to G so we need this mapping
 somehow so this cannot be this can be formulated mathematically I don't
 want to spend too much time on this but I just want to mention this is
 an important mathematical development perhaps but this is the first time
 where we have seen this kind of thing and we don't have I don't have good
 notation right now for this natural transformations between applicative
 functors and its need to be considered so here's the mathematical formulation
 we consider - Lickety functors F and G and we consider a natural transformation
 between them such that it Maps period of F into pure of G and it maps zip
 of F into the project and then we demand that it also should map the Traverse
 of F into Traverse of G so if we do that well all we do is we just say
 we have a traverse with respect to F let's apply it and then map F to G
 in the result because the result of Traverse is F of something F of some
 L of a or L of B so we can map that into G of not using the natural transformat
ion or we can first map f to G and then apply Traverse and that should be
 the same and so this is a natural T with respect to the functor as a type
 parameter so it's a higher-order type parameter itself otherwise it's quite
 similar to not two naturality and it's just more complicated because it's
 not just any natural transformation natural transformation by itself has
 laws already and in addition to being a natural transformation it needs
 to preserve the implicative properties of f so that pure is mapped to pure
 zip is mapped to zip and and the laws of course must hold for both implicated
 factors so if you look at this notation which is slightly made shorter
 on purpose by omitting various type parameters it really looks like lifting
 from a function f to G into function of traversing you have to traverse
 G but F and G are not types they're type constructors so and this is not
 a function this is a natural transformation which is more complicated object
 so when we used category theory to describe such liftings we would usually
 say this is a morphism in one category and this is a morphism in another
 category but a morphism as we define it was always between two types now
 we don't have types we have type constructors so we need basically a morphism
 between type constructors so that's more more precisely between implicative
 factors so a morphism between applicative functions that's what we need
 to lift into a morphism of traversable faculties and so that requires a
 more general definition of category than what I have given so far we're
 in them in the definition I've given so far morphisms were just twisted
 function types but now we need morphisms between type constructors or even
 more restricted ones morphisms between applicative functions with extra
 properties so category theory prescribes this in a general definition of
 category can be given which I'm not going to give right now because I don't
 see in the use for it other than to indicate the property of natural T
 as being similar to previous properties I encourage you to look at category
 theory at some point but I will only talk about what I see it as being
 useful and so right now it is useful to think about this as a lifting and
 the wall is of course need to hold such as identity and Composition so
 if we map F to F then we don't change anything that should be lifted into
 identity and composition F to G to H mapped it to composition of those
 mappings and so on so those are the rigorous four forms for the naturality
 war with respect to applicative function I'm not writing it down in detail
 because just as naturality with respect to ordinary type parameter this
 is this morality with respectively funter is going to be satisfied automaticall
y by any code that nearly uses peer and zip and why is that it's because
 when we perform a natural transformation that maps FPR to GD P R and F
 zip to gzip the code doesn't actually change at all the code has f as a
 type parameter and it just uses pure and zip in the code to cause them
 as we have been doing when we implemented the traverse instances for example
 so let's see here is for example we are using zip the zip is from the function
 f but F is a type parameter so if we now apply a natural transformation
 from F to G for some other negative function G this code doesn't change
 at all it still uses the zip and we have the condition that there's natural
 transformation that maps F to G it Maps zip to zip and peer to peer and
 and map to map of course that's the natural T of natural transformation
 so our code won't change and our code therefore is invariant under this
 natural transformation and so it's automatically going to satisfy naturality
 with respect to the type parameter F and it also will automatically satisfy
 not reality with respect to time over a and that's why we never need to
 check these laws explicitly or even spend so much time writing them explicitly
 because they are they are useful sometimes when your reason about code
 and prove some other law was then learned are useful but for coding for
 implementing you always have natural T automatically so this concludes
 chapter 9 and here are some exercises for you to implement let me just
 comment and this exercise so I don't want you to prove laws by hand for
 this factor T it's cumbersome but instead use constructions so we have
 proved general constructions so if you express T as a recursive equation
 using some by factor s and you show that the wife on dress is by traversable
 again using constructions of course then you don't need to and to do the
 proof yourself if the constructions already proved once you have found
 them and similarly for for this construction you don't need to prove anything
 by hand this exercise is a little different but you can try to prove this
 extra construction that I mentioned this one but it's very similar to other
 constructions and so it's not necessarily part of this exercise this concludes
 chapter 9 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
