%% LyX 2.3.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Natural transformations]{Properties of natural transformations}
\subtitle{With code examples in Scala}
\author{Sergei Winitzki}
\date{2020-05-30}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

\makeatother

\usepackage{listings}
\lstset{language=Scala,
morekeywords={{scala}},
otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},
keywordstyle={\color{scalakeyword}},
morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},
keywordstyle={[2]{\color{scalatype}}},
frame=tb,
aboveskip={1.5mm},
belowskip={0.5mm},
showstringspaces=false,
columns=fullflexible,
keepspaces=true,
basicstyle={\smaller\ttfamily},
extendedchars=true,
numbers=none,
numberstyle={\tiny\color{gray}},
commentstyle={\color{dkgreen}},
stringstyle={\color{mauve}},
frame=single,
framerule={0.0mm},
breaklines=true,
breakatwhitespace=true,
tabsize=3,
framexleftmargin={0.5mm},
framexrightmargin={0.5mm},
xleftmargin={1.5mm},
xrightmargin={1.5mm},
framextopmargin={0.5mm},
framexbottommargin={0.5mm},
fillcolor={\color{aqua}},
rulecolor={\color{aqua}},
rulesepcolor={\color{aqua}},
backgroundcolor={\color{aqua}},
mathescape=false,
extendedchars=true}
\renewcommand{\lstlistingname}{Listing}

\begin{document}
\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%
\frame{\titlepage}
\begin{frame}{Refactoring code by permuting the order of operations}
\begin{itemize}
\item \vspace{-0.15cm}Expected properties of refactored code: \\
~
\end{itemize}
First extract user information, then convert stream to list; or first
convert to list, then extract user information:

\texttt{\textcolor{blue}{\footnotesize{}db.getRows.toList.map(getUserInfo)}}
gives the same result as\\
\texttt{\textcolor{blue}{\footnotesize{}db.getRows.map(getUserInfo).toList}}~\\
\texttt{\textcolor{blue}{\footnotesize{}~}}{\footnotesize\par}

First extract user information, then exclude invalid rows; or first
exclude invalid rows, then extract user information:

\texttt{\textcolor{blue}{\footnotesize{}db.getRows.map(getUserInfo).filter(isValid)}}
gives the same result as \\
\texttt{\textcolor{blue}{\footnotesize{}db.getRows.filter(getUserInfo
andThen isValid).map(getUserInfo)}}~\\
\texttt{\textcolor{blue}{\footnotesize{}~}}{\footnotesize\par}
\begin{itemize}
\item These refactorings are guaranteed to be correct...
\begin{itemize}
\item ... because \texttt{\textcolor{blue}{\footnotesize{}\_.toList}} is
a natural transformation \texttt{\textcolor{blue}{\footnotesize{}Stream{[}A{]}
=> List{[}A{]}}} 
\item and \texttt{\textcolor{blue}{\footnotesize{}\_.filter}} is also a
natural transformation in disguise
\end{itemize}
\item Natural transformations satisfy the ``naturality properties''
\end{itemize}
\end{frame}

\begin{frame}{Refactored code: equations}

Introduce short syntax to write those properties as equations:
\begin{center}
\begin{tabular}{|c|c|}
\hline 
\texttt{\textcolor{blue}{\small{}def toList{[}A{]}: Stream{[}A{]}
=> List{[}A{]}}} & {\small{}$\text{toList}^{A}:\text{Str}^{A}\rightarrow\text{List}^{A}$}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\small{}val f: A => B}} & {\small{}$f^{:A\rightarrow B}$}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\small{}\_.map(f)}}{\small{} with type }\texttt{\textcolor{blue}{\small{}List{[}A{]}
=> List{[}B{]}}} & {\small{}$f^{\uparrow\text{List}}$}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\small{}\_.toList.map(f)}} & {\small{}$\text{toList}\bef f^{\uparrow\text{List}}$}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\small{}f andThen g}} & {\small{}$f\bef g$}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\small{}\_.map(f).map(g) == \_.map(f andThen
g)}} & {\small{}$f^{\uparrow\text{List}}\bef g^{\uparrow\text{List}}=(f\bef g)^{\uparrow\text{List}}$}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

The ``short syntax'' is equivalent to Scala code
\end{frame}

\begin{frame}{Refactored code: equations}

\vspace{-0.2cm}Rewrite the previous examples as equations and type
diagrams:

\vspace{0.2cm}\lstinline!def toList[A]: Stream[A] => List[A]! written
as {\small{}$\text{toList}^{A}:\text{Str}^{A}\rightarrow\text{List}^{A}$}{\small\par}

\vspace{-0.3cm}%
\begin{minipage}[c][1\totalheight][t]{0.26\columnwidth}%
\[
\xymatrix{\text{Str}^{A}\ar[r]\sp(0.55){\text{toList}^{A}}\ar[d]\sp(0.4){f^{\uparrow\text{Str}}} & \text{List}^{A}\ar[d]\sp(0.4){f^{\uparrow\text{List}}}\\
\xyScaleY{1.6pc}\xyScaleX{4.0pc}\text{Str}^{B}\ar[r]\sp(0.55){\text{toList}^{B}} & \text{List}^{B}
}
\]
%
\end{minipage}\hfill{}%
\begin{minipage}[c][1\totalheight][t]{0.68\columnwidth}%
\begin{center}
~\\
~\\
\lstinline!_.toList.map(f) == _.map(f).toList!{\small{}
\[
\text{toList}^{A}\bef f^{\uparrow\text{List}}=f^{\uparrow\text{Str}}\bef\text{toList}^{B}
\]
}
\par\end{center}%
\end{minipage}

\vspace{0.2cm}\lstinline!def filt[A]: (A => Boolean) => Stream[A] => Stream[A]!

\vspace{-0.3cm}%
\begin{minipage}[c][1\totalheight][t]{0.26\columnwidth}%
\[
\xymatrix{\text{Str}^{A}\ar[r]\sp(0.55){\text{filt}^{A}(f\bef p)}\ar[d]\sp(0.4){f^{\uparrow\text{Str}}} & \text{Str}^{A}\ar[d]\sp(0.4){f^{\uparrow\text{Str}}}\\
\xyScaleY{1.6pc}\xyScaleX{3.5pc}\text{Str}^{B}\ar[r]\sp(0.55){\text{filt}^{B}(p)} & \text{Str}^{B}
}
\]
%
\end{minipage}\hfill{}%
\begin{minipage}[c][1\totalheight][t]{0.72\columnwidth}%
\begin{center}
{\small{}
\begin{align*}
 & \text{filt}^{A}:(A\rightarrow\bbnum 2)\rightarrow\text{Str}^{A}\rightarrow\text{Str}^{A}\\
 & f^{\uparrow\text{Str}}\bef\text{filt}^{B}(p)=\text{filt}^{A}(f\bef p)\bef f^{\uparrow\text{Str}}
\end{align*}
}~ \lstinline!_.map(f).filter(p) == _.filter(x => p(f(x))).map(f)!
\par\end{center}%
\end{minipage}
\begin{itemize}
\item \vspace{0.2cm}A transformation before \lstinline!map! equals a transformation
after \lstinline!map!
\item This is called a \textbf{naturality law}
\item We expect it to hold if the code works the same way for all types
\begin{itemize}
\item The naturality law is a mathematical expression of the programmer's
intuition about code ``working the same way for all types''
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Naturality laws: equations}

\vspace{-0.1cm}\textbf{Naturality law} for a function $t$ is an
equation involving an arbitrary function $f$ that permutes the order
of application of $t$ and of a lifted $f$

\vspace{-0.4cm}%
\begin{minipage}[c][1\totalheight][t]{0.26\columnwidth}%
\[
\xymatrix{\text{List}^{A}\ar[r]\sp(0.55){\text{headOpt}^{A}}\ar[d]\sp(0.4){f^{\uparrow\text{List}}} & \text{Opt}^{A}\ar[d]\sb(0.4){f^{\uparrow\text{Opt}}}\\
\xyScaleY{1.6pc}\xyScaleX{4.0pc}\text{List}^{B}\ar[r]\sp(0.55){\text{headOpt}^{B}} & \text{Opt}^{B}
}
\]
%
\end{minipage}\hfill{}%
\begin{minipage}[c][1\totalheight][b]{0.68\columnwidth}%
\begin{center}
\lstinline!_.map(f).headOption == _.headOption.map(f)!
\[
f^{\uparrow\text{List}}\bef\text{headOpt}=\text{headOpt}\bef f^{\uparrow\text{Opt}}
\]
\par\end{center}%
\end{minipage}
\begin{itemize}
\item Lifting $f$ before $t$ equals to lifting $f$ after $t$
\item Intuition: $t$ rearranges data in a collection, not looking at values
\end{itemize}
Further examples: 
\begin{itemize}
\item Reversing a list; $\text{reverse}^{A}:\text{List}^{A}\rightarrow\text{List}^{A}$
\end{itemize}
\begin{center}
\lstinline!_.map(f).reverse == _.reverse.map(f)!{\footnotesize{}
\[
(f^{:A\rightarrow B})^{\uparrow\text{List}}\bef\text{reverse}^{B}=\text{reverse}^{A}\bef(f^{:A\rightarrow B})^{\uparrow\text{List}}
\]
}{\footnotesize\par}
\par\end{center}
\begin{itemize}
\item The \lstinline!pure! method, \lstinline!pure[A]: A => L[A]!. Notation:
$\text{pu}_{L}:A\rightarrow L^{A}$
\end{itemize}
\begin{center}
\lstinline!pure(x).map(f) == pure(f(x))!{\footnotesize{}
\[
\text{pu}^{A}\bef(f^{:A\rightarrow B})^{\uparrow L}=f^{:A\rightarrow B}\bef\text{pu}^{B}
\]
}{\footnotesize\par}
\par\end{center}

\end{frame}

\begin{frame}{Natural transformations and their laws}

A \textbf{natural transformation} is a function $t$ with type signature
$F^{A}\rightarrow G^{A}$ that satisfies the naturality law $f^{\uparrow F}\bef t=t\bef f^{\uparrow G}$.
Notation $t:F\leadsto G$

Mnemonic rule: if $t:F\leadsto G$ then the lifting to $F$ is on
the left, the lifting to $G$ is on the right
\begin{itemize}
\item Many standard methods have the form of a natural transformation
\begin{itemize}
\item Examples: \lstinline!headOption!, \lstinline!lastOption!, \lstinline!reverse!,
\lstinline!swap!, \lstinline!map!, \lstinline!flatMap!, \lstinline!pure!
\end{itemize}
\item If there are several type parameters, use one at a time:
\begin{itemize}
\item For \lstinline!flatMap!, denote $\text{flm}:\left(A\rightarrow M^{B}\right)\rightarrow M^{A}\rightarrow M^{B}$,
fix $A$
\begin{itemize}
\item $\text{flm}:F^{B}\rightarrow G^{B}$ where $F^{B}\triangleq A\rightarrow M^{B}$
and $G^{B}\triangleq M^{A}\rightarrow M^{B}$
\end{itemize}
\item The naturality law $f^{\uparrow F}\bef\text{flm}=\text{flm}\bef f^{\uparrow G}$
then gives the equation
\[
\text{flm}\,(p^{:A\rightarrow M^{B}}\bef f^{\uparrow M})=\text{flm}\,(p^{:A\rightarrow M^{B}})\bef f^{\uparrow M}
\]
if we write out the code for $f^{\uparrow F}$ and $f^{\uparrow G}$:
\[
f^{\uparrow F}=p^{:A\rightarrow M^{B}}\rightarrow p\bef f^{\uparrow M}\quad,\quad\quad f^{\uparrow G}=q^{:M^{A}\rightarrow M^{B}}\rightarrow q\bef f^{\uparrow M}
\]
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{More practical uses of natural transformations I}

Recognize natural transformations in code and refactor

\vspace{0.3cm}\texttt{\textcolor{blue}{\footnotesize{}def ensureName(name:~Option{[}String{]},
id:~Long):~Option{[}(String, Long){]} =}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}~ ~ ~ name.map((\_, id))}}{\footnotesize\par}
\begin{itemize}
\item Recognize that the code works the same way for all types
\item Introduce type parameters \texttt{\textcolor{blue}{\footnotesize{}A}}
and \texttt{\textcolor{blue}{\footnotesize{}B}} instead of \texttt{\textcolor{blue}{\footnotesize{}String}}
and \texttt{\textcolor{blue}{\footnotesize{}Long}} 
\item The refactored code is a natural transformation:
\end{itemize}
\texttt{\textcolor{blue}{\footnotesize{}def toOptionPair{[}A, B{]}(x:~Option{[}A{]},
b:~B):~Option{[}(A, B){]} = }}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}~ ~ ~ x.map((\_, b))}}{\footnotesize\par}

The type signature is of the form \texttt{\textcolor{blue}{\footnotesize{}F{[}A{]}
=> G{[}A{]}}} if we define

\texttt{\textcolor{blue}{\footnotesize{}type F{[}A{]} = (Option{[}A{]},
B{]})}} and \texttt{\textcolor{blue}{\footnotesize{}type G{[}A{]}
= Option{[}(A, B){]}}}{\footnotesize\par}

and consider \texttt{\textcolor{blue}{\footnotesize{}B}} as a fixed
type

Alternatively, consider \texttt{\textcolor{blue}{\footnotesize{}A}}
as a fixed type and obtain a natural transformation \texttt{\textcolor{blue}{\footnotesize{}K{[}B{]}
=> L{[}B{]}}} with suitable definitions of \texttt{\textcolor{blue}{\footnotesize{}K{[}B{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}L{[}B{]}}} 
\begin{itemize}
\item The naturality law can be verified directly
\begin{itemize}
\item But it also follows from the product and co-product constructions
for natural transformations (to be shown below)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{More practical uses of natural transformations II}

Building up natural transformations from parts

\vspace{0.3cm}\texttt{\textcolor{blue}{\footnotesize{}def toOptionList{[}A,
B{]}:~List{[}(Option{[}A{]}, B){]} => List{[}Option{[}(A, B){]}{]}
=}}{\footnotesize\par}

\texttt{\textcolor{blue}{\footnotesize{}~ ~ ~ \_.map \{ case (x,
b) => x.map((\_, id)) \}}}{\footnotesize\par}
\begin{itemize}
\item If we have a functor $F$ and a natural transformation $G^{A}\rightarrow H^{A}$,
we can implement a natural transformation $F^{G^{A}}\rightarrow F^{H^{A}}$
\item In this example, the notation is $F=\text{List}$, $G^{A}=(\bbnum 1+A)\times B$,
and $H^{A}=\bbnum 1+A\times B$
\begin{itemize}
\item The type notation such as $(\bbnum 1+A)\times B$ helps recognize
type equivalences by using the rules of ordinary polynomial algebra:
\[
(\bbnum 1+A)\times B\cong\bbnum 1\times B+A\times B\cong B+A\times B
\]
\end{itemize}
\item Another example: \texttt{\textcolor{blue}{\footnotesize{}List{[}(Try{[}A{]},
B){]} => List{[}Try{[}(A, B){]}{]}}} with the same code as \texttt{\textcolor{blue}{\footnotesize{}toOptionList{[}A,
B{]}}} 
\item Denote \texttt{\textcolor{blue}{\footnotesize{}Try{[}A{]}}} by $E+A$
where $E$ denotes the type of the exception
\[
\text{List}^{\left(E+A\right)\times B}\rightarrow\text{List}^{E+A\times B}
\]
\item To prove the general property, write out the naturality law
\end{itemize}
\end{frame}

\begin{frame}{More practical uses of natural transformations III}

Using a constant functor (``phantom type parameter'')

\vspace{0.3cm}\texttt{\textcolor{blue}{\footnotesize{}def length{[}A{]}:~List{[}A{]}
=> Int = \{ \_.length \}}}{\footnotesize\par}
\begin{itemize}
\item The type signature is of the form \texttt{\textcolor{blue}{\footnotesize{}F{[}A{]}
=> G{[}A{]}}} or $F^{A}\rightarrow G^{A}$ if we define $F=\text{List}$
and $G^{A}=\text{Int}$, so that $G^{A}$ is a constant functor
\item The naturality law gives $f^{\uparrow F}\bef\text{length}=\text{length}\bef f^{\uparrow G}$,
but $F^{\uparrow G}=\text{id}$, so $f^{\uparrow F}\bef\text{length}=\text{length}$
for any $f^{:A\rightarrow B}$
\item We can choose $f(x)=c$ with any constant $c$ 
\begin{itemize}
\item The length of a list does not depend on the values stored in the list
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Reasoning with naturality I: Simplifying the \lstinline!pure! method}

\vspace{-0.2cm}The naturality law of \lstinline!pure! for a functor
$L$:

\vspace{-0.4cm}%
\begin{minipage}[c][1\totalheight][t]{0.26\columnwidth}%
\[
\xymatrix{A\ar[r]\sp(0.55){\text{pu}_{L}}\ar[d]\sp(0.4){f} & L^{A}\ar[d]\sp(0.4){f^{\uparrow L}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}B\ar[r]\sp(0.55){\text{pu}_{L}} & L^{B}
}
\]
%
\end{minipage}\hfill{}%
\begin{minipage}[c][1\totalheight][b]{0.68\columnwidth}%
\begin{center}
\lstinline!pure(a).map(f) == pure(f(a))!
\[
\text{pu}_{L}\bef f^{\uparrow L}=f\bef\text{pu}_{L}
\]
\par\end{center}%
\end{minipage}

\vspace{0.2cm}Fix a value $b^{:B}$ and set $A=\bbnum 1$ and $f\triangleq1\rightarrow b$
in the naturality law:

\vspace{-0.4cm}%
\begin{minipage}[c][1\totalheight][t]{0.26\columnwidth}%
\[
\xymatrix{\bbnum 1\ar[r]\sp(0.55){\text{pu}_{L}}\ar[d]\sp(0.4){1\rightarrow b} & L^{\bbnum 1}\ar[d]\sp(0.4){(1\rightarrow b)^{\uparrow L}}\\
\xyScaleY{1.6pc}\xyScaleX{3.0pc}B\ar[r]\sp(0.55){\text{pu}_{L}} & L^{B}
}
\]
%
\end{minipage}\hfill{}%
\begin{minipage}[c][1\totalheight][b]{0.68\columnwidth}%
\begin{center}
\lstinline!pure(()).map(_ => b) == pure(b)!
\[
\text{pu}_{L}\bef(1\rightarrow b)^{\uparrow L}=(1\rightarrow b)\bef\text{pu}_{L}
\]
\par\end{center}%
\end{minipage}

\vspace{0.2cm}We have expressed \lstinline!pure(b)! via a constant
value \lstinline!pure(())! of type \lstinline!L[Unit]!

The resulting function \lstinline!pure! will automatically satisfy
the naturality law!

The naturality law of \lstinline!pure! makes it \emph{equivalent}
to a ``wrapped unit'' value

This simplifies the definition of a \lstinline!Pointed! typeclass:

\lstinline!abstract class Pointed[L[_]: Functor] \{ def wu: L[Unit] \}!

Examples: for \lstinline!Option!, \lstinline!wu = Some(())!. For
\lstinline!List!, \lstinline!wu = List(())!
\end{frame}

\begin{frame}{Reasoning with naturality II: \lstinline!flatMap! and \lstinline!flatten!}

\vspace{-0.2cm}Use the curried type signature for \lstinline!flatMap!
for a monad $M$:

\vspace{0.3cm}\texttt{\textcolor{blue}{\footnotesize{}def flatMap{[}A,
B{]}:~(A => M{[}B{]})=> M{[}A{]} => M{[}B{]}}} 
\[
\text{flm}^{A,B}:(A\rightarrow M^{B})\rightarrow M^{A}\rightarrow M^{B}
\]

The naturality law with respect to the type parameter \texttt{\textcolor{blue}{\footnotesize{}A}}:

\vspace{-0.4cm}%
\begin{minipage}[c][1\totalheight][t]{0.26\columnwidth}%
\[
\xymatrix{M^{A}\ar[rd]\sp(0.55){\text{flm}\,(f\bef g)}\ar[d]\sb(0.4){f^{\uparrow M}}\\
\xyScaleY{1.6pc}\xyScaleX{4.0pc}M^{B}\ar[r]\sp(0.45){\text{flm}\,(g)} & M^{C}
}
\]
%
\end{minipage}\hfill{}%
\begin{minipage}[c][1\totalheight][b]{0.68\columnwidth}%
\begin{center}
\lstinline!_.flatMap(f andThen g) == _.map(f).flatMap(g)!
\[
\text{flm}\,(f^{:A\rightarrow B}\bef g^{:B\rightarrow M^{C}})=f^{\uparrow M}\bef\text{flm}\,(g)\quad.
\]
\par\end{center}%
\end{minipage}

\vspace{0.2cm}Express \lstinline!flatMap! through \lstinline!flatten!:

\lstinline!_.flatMap(f) == _.map(f).flatten!
\[
\text{flm}\,(g)=g^{\uparrow M}\bef\text{ftn}
\]
Express \lstinline!flatten! through \lstinline!flatMap!:
\[
\text{ftn}=\text{flm}\,(\text{id}^{:M^{A}\rightarrow M^{A}})
\]
The function \lstinline!flatten! is equivalent to \lstinline!flatMap!
with naturality law
\end{frame}

\begin{frame}{Reasoning with naturality III: The covariant Yoneda identity}

We have shown that the set of all natural transformations $A\rightarrow L^{A}$
is equivalent to the set of all values $L^{\bbnum 1}$

This property can be generalized to any type $Z$ instead of the unit
type ($\bbnum 1$):

The set of all natural transformations $\left(Z\rightarrow A\right)\rightarrow L^{A}$
is equivalent to the set of all values $L^{Z}$, where $Z$ is a fixed
type

To indicate that $Z$ is fixed by $A$ is varying within the natural
transformation, use a type signature with the universal quantifier:
\begin{align*}
\big(\forall A.\,A & \rightarrow L^{A}\big)\cong L^{\bbnum 1}\\
\big(\forall A.\,\left(Z\rightarrow A\right) & \rightarrow L^{A}\big)\cong L^{Z}\quad\quad\text{-- the covariant Yoneda identity}
\end{align*}

To prove:
\begin{enumerate}
\item Implement the isomorphism, $p:\big(\forall A.\,\left(Z\rightarrow A\right)\rightarrow L^{A}\big)\rightarrow L^{Z}$
and $q:L^{Z}\rightarrow\forall A.\,\left(Z\rightarrow A\right)\rightarrow L^{A}$
\item Show that $p\bef q=\text{id}$ and $q\bef p=\text{id}$
\end{enumerate}
\end{frame}

\begin{frame}{Reasoning with naturality IV: other derivations}

Naturality laws are often used in derivations of various typeclass
laws

Within the 11 existing chapters of my upcoming free book, ``\emph{The
Science of Functional Programming}'' (\texttt{\small{}\href{https://github.com/winitzki/sofp}{https://github.com/winitzki/sofp}}),
naturality laws are used at least 31 times in about 100 derivations
\begin{itemize}
\item Examples of such derivations:
\begin{itemize}
\item Composition of two co-pointed functors is again co-pointed
\begin{itemize}
\item A functor $F$ is co-pointed if there exists a natural transformation
$\text{ex}:\forall A.\,F^{A}\rightarrow A$
\end{itemize}
\item The product of two monads is again a monad
\item The product of two monad transformers is again a monad transformer
\end{itemize}
\end{itemize}
The most useful derivation technique is rewriting equations
\end{frame}

\begin{frame}{Example: properties of horizontal and vertical composition}

Bartosz Milewski's book ``Category theory for programmers'', Chapter
10, defines the horizontal and the vertical composition of natural
transformations

The horizontal composition of $\alpha:F^{A}\rightarrow G^{A}$ and
$\beta:G^{A}\rightarrow H^{A}$ is the ordinary function composition
$\left(\alpha\bef\beta\right):F^{A}\rightarrow H^{A}$

The vertical composition of $\alpha:F^{A}\rightarrow G^{A}$ and $\alpha^{\prime}:F^{\prime A}\rightarrow G^{\prime A}$
is $\left(\alpha\star\alpha^{\prime}\right):F^{F^{\prime A}}\rightarrow G^{G^{\prime A}}$
\begin{itemize}
\item Both compositions again give natural transformations
\end{itemize}
If we have four natural transformations $\alpha$, $\beta$, $\alpha^{\prime}$,
$\beta^{\prime}$ with type signatures
\begin{align*}
\alpha & :F^{A}\rightarrow G^{A}\quad,\quad\beta:G^{A}\rightarrow H^{A}\quad,\\
\alpha^{\prime} & :F^{\prime A}\rightarrow G^{\prime A}\quad,\quad\beta^{\prime}:G^{\prime A}\rightarrow H^{\prime A}\quad,
\end{align*}
we can write the distributive law,
\[
\left(\alpha\bef\beta\right)\star(\alpha^{\prime}\bef\beta^{\prime})=(\alpha\star\alpha^{\prime})\bef(\beta\star\beta^{\prime})
\]
To prove that these properties hold, write out the naturality laws
\end{frame}

\begin{frame}{Other constructions of natural transformations}

Natural transformations can be combined in several other ways

Given natural transformations \texttt{\textcolor{blue}{\footnotesize{}a{[}A{]}: F{[}A{]}
=> G{[}A{]}}} and \texttt{\textcolor{blue}{\footnotesize{}b{[}A{]}: K{[}A{]}
=> L{[}A{]}}}:
\begin{itemize}
\item pair product, \texttt{\textcolor{blue}{\footnotesize{}((F{[}A{]},
K{[}A{]})) => (G{[}A{]}, L{[}A{]})}} 
\item pair co-product, \texttt{\textcolor{blue}{\footnotesize{}Either{[}F{[}A{]},
K{[}A{]}{]} => Either{[}G{[}A{]}, L{[}A{]}{]}}} 
\item pair exponential, \texttt{\textcolor{blue}{\footnotesize{}(F{[}A{]}
=> K{[}A{]}) => (G{[}A{]} => L{[}A{]})}} where \texttt{\textcolor{blue}{\footnotesize{}F{[}A{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}G{[}A{]}}} must be contrafunctors
\begin{itemize}
\item are natural transformations implemented by combining \texttt{\textcolor{blue}{\footnotesize{}a{[}A{]}}}
and \texttt{\textcolor{blue}{\footnotesize{}b{[}A{]}}} 
\end{itemize}
\end{itemize}
Also, the identity function \texttt{\textcolor{blue}{\footnotesize{}identity{[}A{]}: A
=> A}} and the constant unit function of type \texttt{\textcolor{blue}{\footnotesize{}A
=> Unit}} are natural transformations

It follows that any purely functional combination of natural transformations
is again a natural transformation

No need to verify the naturality law in each case

Example: \texttt{\textcolor{blue}{\footnotesize{}(Option{[}A{]}, B)
=> Option{[}(A, B){]}}} 
\end{frame}

\begin{frame}{Summary of the type notation}

The short type notation helps in symbolic reasoning about types
\noindent \begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\small{}Description} & \textbf{\small{}Scala examples} & \textbf{\small{}Notation}\tabularnewline
\hline 
\hline 
{\footnotesize{}Typed value} & {\footnotesize{}}\lstinline!x: Int! & {\footnotesize{}$x^{:\text{Int}}$ or $x:\text{Int}$}\tabularnewline
\hline 
{\footnotesize{}Unit type} & {\footnotesize{}}\lstinline!Unit!{\footnotesize{}, }\lstinline!Nil!{\footnotesize{},
}\lstinline!None! & {\footnotesize{}$\bbnum 1$}\tabularnewline
\hline 
{\footnotesize{}Type parameter} & {\footnotesize{}}\lstinline!A! & {\footnotesize{}$A$}\tabularnewline
\hline 
{\footnotesize{}Product type} & {\footnotesize{}}\lstinline!(A, B)!{\footnotesize{} or }\lstinline!case class P(x: A, y: B)! & {\footnotesize{}$A\times B$}\tabularnewline
\hline 
{\footnotesize{}Co-product type} & {\footnotesize{}}\lstinline!Either[A, B]! & {\footnotesize{}$A+B$}\tabularnewline
\hline 
{\footnotesize{}Function type} & {\footnotesize{}}\lstinline!A => B! & {\footnotesize{}$A\rightarrow B$}\tabularnewline
\hline 
{\footnotesize{}Type constructor} & {\footnotesize{}}\lstinline!List[A]! & {\footnotesize{}$\text{List}^{A}$}\tabularnewline
\hline 
{\footnotesize{}Universal quantifier} & {\footnotesize{}}\lstinline!trait P \{ def f[A]: Q[A] \}! & {\footnotesize{}$P\triangleq\forall A.\,Q^{A}$}\tabularnewline
\hline 
{\footnotesize{}Existential quantifier} & {\footnotesize{}}%
\begin{minipage}[t]{0.43\paperwidth}%
{\footnotesize{}}\lstinline!sealed trait P[A]!{\footnotesize\par}

{\footnotesize{}}\lstinline!case class Q[A, B]() extends P[A]!{\footnotesize{}\vspace{0.2\baselineskip}
}{\footnotesize\par}%
\end{minipage} & {\footnotesize{}$P^{A}\triangleq\exists B.\,Q^{A,B}$}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Example: Scala code \lstinline!def flm(f: A => Option[B]): Option[A] => Option[B]!
is denoted by $\text{flm}:(A\rightarrow\bbnum 1+B)\rightarrow\bbnum 1+A\rightarrow\bbnum 1+B$
\end{frame}

\begin{frame}{Summary of the code notation}

The short code notation helps in symbolic reasoning about code
\noindent \begin{center}
\begin{tabular}{|c|c|}
\hline 
\textbf{\small{}Scala examples} & \textbf{\small{}Notation}\tabularnewline
\hline 
\hline 
{\small{}}\lstinline!()!{\small{} or }\lstinline!true!{\small{}
or }\lstinline!"abc"!{\small{} or }\lstinline!123! & {\small{}$1$, $\text{true}$, $\text{"abc"}$, $123$}\tabularnewline
\hline 
{\small{}}\lstinline!def f[A](x: A) = ...! & {\small{}$f^{A}(x^{:A})\triangleq...$}\tabularnewline
\hline 
{\small{}}\lstinline!\{ (x: A) => expr \}! & {\small{}$x^{:A}\rightarrow\text{expr}$}\tabularnewline
\hline 
{\small{}}\lstinline!f(x)!{\small{} or }\lstinline!x.pipe(f)!{\small{}
(Scala 2.13)} & {\small{}$f(x)$ or $x\triangleright f$}\tabularnewline
\hline 
{\small{}}\lstinline!val p: (A, B) = (a, b)! & {\small{}$p^{:A\times B}\triangleq a\times b$}\tabularnewline
\hline 
{\small{}}\lstinline!\{case (a, b) => expr\}!{\small{} or }\lstinline!p._1!{\small{}
or }\lstinline!p._2! & {\small{}$a\times b\rightarrow\text{expr}$ ~or~ $p\triangleright\pi_{1}$~or~
$p\triangleright\pi_{2}$}\tabularnewline
\hline 
{\small{}}\lstinline!Left[A, B](x)!{\small{} or }\lstinline!Right[A, B](y)! & {\small{}$x^{:A}+\bbnum 0^{:B}$ or $\bbnum 0^{:A}+y^{:B}$}\tabularnewline
\hline 
{\small{}\hspace*{-0.013\linewidth}}%
\begin{minipage}[c][1\totalheight][b]{0.5\columnwidth}%
{\small{}\vspace{0.14\baselineskip}
}{\footnotesize{}}\lstinline!val q: C = (p: Either[A, B]) match \{!{\footnotesize\par}

{\footnotesize{}~ ~}\lstinline!case Left(x)   => f(x)!{\footnotesize\par}

{\footnotesize{}~ ~}\lstinline!case Right(y)  => g(y)!{\footnotesize\par}

{\footnotesize{}}\lstinline!\}!{\small{}\vspace{0.2\baselineskip}
}{\small\par}%
\end{minipage}{\small{} \hspace*{-0.009\linewidth}} & {\small{}$q^{:C}\triangleq p^{:A+B}\triangleright\begin{array}{|c||c|}
 & C\\
\hline A & x^{:A}\rightarrow f(x)\\
B & y^{:B}\rightarrow g(y)
\end{array}$}\tabularnewline
\hline 
{\small{}}\lstinline!def f(x) = \{ ... f(y) ... \}! & {\small{}}%
\begin{minipage}[t]{0.3\columnwidth}%
\begin{center}
{\small{}\vspace{-0.64\baselineskip}
$f(x)\triangleq...~\overline{f}(y)~...$\vspace{0.15\baselineskip}
}
\par\end{center}%
\end{minipage}\tabularnewline
\hline 
{\small{}}\lstinline!f andThen g!{\small{} and }\lstinline!(f andThen g)(x)! & {\small{}$f\bef g$ and $x\triangleright f\bef g$~or~ $x\triangleright f\triangleright g$}\tabularnewline
\hline 
{\small{}}\lstinline!p.map(f).map(g)! & {\small{}$p\triangleright f^{\uparrow F}\triangleright g^{\uparrow F}$~or~
$p\triangleright f^{\uparrow F}\bef g^{\uparrow F}$}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

\end{frame}

\begin{frame}{Summary}
\begin{itemize}
\item Use naturality laws to obtain refactoring guaranteed to be correct
\item Recognize and refactor code to use natural transformations
\item Naturality laws allow us to reduce the number of type parameters in
certain functions
\item Short notation for code helps derive properties via symbolic calculations
\begin{itemize}
\item which is more efficient than ``staring at diagrams''
\end{itemize}
\item Full details and proofs are in the free upcoming book
\begin{itemize}
\item Draft of the book: \texttt{\href{https://github.com/winitzki/sofp}{https://github.com/winitzki/sofp}}
\end{itemize}
\end{itemize}
\end{frame}

\end{document}
