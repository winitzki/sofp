#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.15cm
\rightmargin 1.3cm
\bottommargin 1.3cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Nil,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\end_layout

\begin_layout Chapter
Computations in functor blocks.
 III.
 Monad transformers
\begin_inset CommandInset label
LatexCommand label
name "chap:monad-transformers"

\end_inset


\end_layout

\begin_layout Section
Slides
\end_layout

\begin_layout Paragraph
Combining monads
\end_layout

\begin_layout Standard
Programs often need to combine monadic effects (see code)
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Effect
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\triangleq$
\end_inset

 what else happens in 
\size footnotesize

\begin_inset Formula $A\rightarrow M^{B}$
\end_inset


\size default
 besides computing 
\begin_inset Formula $B$
\end_inset

 from 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
Examples of effects for some standard monads:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Option
\family default
\size default
\color inherit
 – computation will have no result or a single result
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
List
\family default
\size default
\color inherit
 – computation will have zero, one, or multiple results
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 – computation may fail to obtain its result, reports error
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Reader
\family default
\size default
\color inherit
 – computation needs to read an external context value
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Writer
\family default
\size default
\color inherit
 – some value will be appended to a (monoidal) accumulator
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
Future
\family default
\size default
\color inherit
 – computation will be scheduled to run later
\end_layout

\begin_layout Standard
How to combine several effects in the same functor block (
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
)?
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.35cm}
\end_layout

\end_inset


\family typewriter
\color blue

\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// This is not valid Scala!
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result = for { i 
\begin_inset Formula $\leftarrow$
\end_inset

 1 to n
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   j 
\begin_inset Formula $\leftarrow$
\end_inset

 Future { q(i) }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   k 
\begin_inset Formula $\leftarrow$
\end_inset

 maybeError(j) : Try[Int]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield f(k)
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color darkgray
// What should be the type of result??
\end_layout

\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  
\family default
\color darkgray
// This is not valid Scala!
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
(1 to n).flatMap { i 
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   Future(q(i)).flatMap { j 
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     maybeError(j).map { k 
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
       f(k)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
         }}}
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The code will work if we 
\begin_inset Quotes eld
\end_inset

unify
\begin_inset Quotes erd
\end_inset

 all effects in a new, larger monad
\end_layout

\begin_layout Standard
Need to compute the type of new monad that contains all given effects
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Combining monadic effects I.
 Trial and error
\end_layout

\begin_layout Standard
There are several ways of combining two monads into a new monad:
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M_{1}^{A}$
\end_inset

 and 
\begin_inset Formula $M_{2}^{A}$
\end_inset

 are monads then 
\begin_inset Formula $M_{1}^{A}\times M_{2}^{A}$
\end_inset

 is also a monad
\end_layout

\begin_layout Standard
But 
\begin_inset Formula $M_{1}^{A}\times M_{2}^{A}$
\end_inset

 describes two separate values with two separate effects
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M_{1}^{A}$
\end_inset

 and 
\begin_inset Formula $M_{2}^{A}$
\end_inset

 are monads then 
\begin_inset Formula $M_{1}^{A}+M_{2}^{A}$
\end_inset

 is usually not a monad
\end_layout

\begin_layout Standard
If it worked, it would be a choice between two different values / effects
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M_{1}^{A}$
\end_inset

 and 
\begin_inset Formula $M_{2}^{A}$
\end_inset

 are monads then one of 
\begin_inset Formula $M_{1}^{M_{2}^{A}}$
\end_inset

 or 
\begin_inset Formula $M_{2}^{M_{1}^{A}}$
\end_inset

 is often a monad
\end_layout

\begin_layout Standard
Examples and counterexamples for functor composition:
\end_layout

\begin_layout Standard
Combine 
\begin_inset Formula $Z\rightarrow A$
\end_inset

 and 
\begin_inset Formula $\text{List}^{A}$
\end_inset

 as 
\begin_inset Formula $Z\rightarrow\text{List}^{A}$
\end_inset


\end_layout

\begin_layout Standard
Combine 
\family typewriter
\size footnotesize
\color blue
Future[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Option[A]
\family default
\size default
\color inherit
 as 
\family typewriter
\size footnotesize
\color blue
Future[Option[A]]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
But 
\family typewriter
\size footnotesize
\color blue
Either[Z, Future[A]]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Option[Z 
\begin_inset Formula $\rightarrow$
\end_inset

 A]
\family default
\size default
\color inherit
 are not monads
\end_layout

\begin_layout Standard
Neither 
\family typewriter
\size footnotesize
\color blue
Future[State[A]]
\family default
\size default
\color inherit
 nor 
\family typewriter
\size footnotesize
\color blue
State[Future[A]]
\family default
\size default
\color inherit
 are monads
\end_layout

\begin_layout Standard
The order of effects matters when composition works both ways: 
\end_layout

\begin_layout Standard
Combine 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 (
\begin_inset Formula $M_{1}^{A}=Z+A$
\end_inset

) and 
\family typewriter
\size footnotesize
\color blue
Writer
\family default
\size default
\color inherit
 (
\begin_inset Formula $M_{2}^{A}=W\times A$
\end_inset

) 
\end_layout

\begin_layout Standard
as 
\begin_inset Formula $Z+W\times A$
\end_inset

 – either compute result and write a message, or all fails
\end_layout

\begin_layout Standard
as 
\begin_inset Formula $\left(Z+A\right)\times W$
\end_inset

 – message is always written, but computation may fail
\end_layout

\begin_layout Standard
Find a general way of defining a new monad with combined effects
\end_layout

\begin_layout Standard
Derive properties required for the new monad
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Combining monadic effects II.
 Lifting into a larger monad
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
If a 
\begin_inset Quotes eld
\end_inset

big monad
\begin_inset Quotes erd
\end_inset

 
\family typewriter
\size footnotesize
\color blue
BigM[A]
\family default
\size default
\color inherit
 
\emph on
somehow
\emph default
 combines all the needed effects:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\backslash
hspace{-0.35cm}
\end_layout

\end_inset


\family typewriter
\color blue

\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// This could be valid Scala...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val result: BigM[Int] = for {
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   i 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{1}$
\end_inset

(1 to n)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   j 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{2}$
\end_inset

(Future{ q(i) })
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   k 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{3}$
\end_inset

(maybeError(j))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield f(k)
\end_layout

\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\family roman
\color darkgray
// If we define the various
\end_layout

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
 // required 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 functions:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def lift
\begin_inset Formula $_{1}$
\end_inset

[A]: Seq[A] 
\begin_inset Formula $\rightarrow$
\end_inset

 BigM[A] = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def lift
\begin_inset Formula $_{2}$
\end_inset

[A]: Future[A] 
\begin_inset Formula $\rightarrow$
\end_inset

 BigM[A] = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def lift
\begin_inset Formula $_{3}$
\end_inset

[A]: Try[A] 
\begin_inset Formula $\rightarrow$
\end_inset

 BigM[A] = ???   
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Example 1: combining as 
\family typewriter
\size footnotesize
\color blue
BigM[A] = Future[Option[A]]
\family default
\size default
\color inherit
 with liftings:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\family typewriter
\color blue
def lift
\begin_inset Formula $_{1}$
\end_inset

[A]: Option[A] 
\begin_inset Formula $\rightarrow$
\end_inset

 Future[Option[A]] = Future.successful(_)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
def lift
\begin_inset Formula $_{2}$
\end_inset

[A]: Future[A] 
\begin_inset Formula $\rightarrow$
\end_inset

 Future[Option[A]] = _.map(x 
\begin_inset Formula $\rightarrow$
\end_inset

 Some(x))
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Example 2: combining as 
\family typewriter
\size footnotesize
\color blue
BigM[A] = List[Try[A]]
\family default
\size default
\color inherit
 with liftings:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.05cm}
\end_layout

\end_inset


\family typewriter
\color blue
def lift
\begin_inset Formula $_{1}$
\end_inset

[A]: Try[A] 
\begin_inset Formula $\rightarrow$
\end_inset

 List[Try[A]] = x 
\begin_inset Formula $\rightarrow$
\end_inset

 List(x)
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
def lift
\begin_inset Formula $_{2}$
\end_inset

[A]: List[A] 
\begin_inset Formula $\rightarrow$
\end_inset

 List[Try[A]] = _.map(x 
\begin_inset Formula $\rightarrow$
\end_inset

 Success(x))
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\size default
Remains to be understood:
\end_layout

\begin_layout Standard
Finding suitable laws for the liftings; checking that the laws hold
\end_layout

\begin_layout Standard
Building a 
\begin_inset Quotes eld
\end_inset

big monad
\begin_inset Quotes erd
\end_inset

 out of 
\begin_inset Quotes eld
\end_inset

smaller
\begin_inset Quotes erd
\end_inset

 ones, with lawful liftings
\end_layout

\begin_layout Standard
Is this always possible? Unique? Are there alternative solutions?
\end_layout

\begin_layout Standard
Ways of reducing the complexity of code; make liftings automatic
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Laws for monad liftings I.
 Identity laws
\end_layout

\begin_layout Standard
Whatever identities we expect to hold for monadic programs must continue
 to hold after lifting 
\family typewriter
\size footnotesize
\color blue
M
\begin_inset Formula $_{1}$
\end_inset


\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
M
\begin_inset Formula $_{2}$
\end_inset


\family default
\size default
\color inherit
 values into the 
\begin_inset Quotes eld
\end_inset

big monad
\begin_inset Quotes erd
\end_inset

 
\family typewriter
\size footnotesize
\color blue
BigM
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
We assume that 
\family typewriter
\size footnotesize
\color blue
M
\begin_inset Formula $_{1}$
\end_inset


\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
M
\begin_inset Formula $_{2}$
\end_inset


\family default
\size default
\color inherit
, and 
\family typewriter
\size footnotesize
\color blue
BigM
\family default
\size default
\color inherit
 already satisfy all the monad laws
\end_layout

\begin_layout Standard
Consider the various functor block constructions containing the liftings:
\end_layout

\begin_layout Standard
Left identity law after 
\family typewriter
\size footnotesize
\color blue
lift
\begin_inset Formula $_{1}$
\end_inset


\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\family typewriter
\color blue

\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "54col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// Anywhere inside a for/yield:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
i 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{1}$
\end_inset

(M
\begin_inset Formula $_{1}$
\end_inset

.pure(x))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
j 
\begin_inset Formula $\leftarrow$
\end_inset

 bigM(i) 
\family roman
\color darkgray
// Any BigM value.
\end_layout

\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "54col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// Must be equivalent to...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
i = x
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
j 
\begin_inset Formula $\leftarrow$
\end_inset

 bigM(x)
\end_layout

\end_inset


\begin_inset VSpace smallskip
\end_inset

lift
\begin_inset Formula $_{1}$
\end_inset

(M
\begin_inset Formula $_{1}$
\end_inset

.pure(x)).flatMap(b) = b(x)
\family default
\size default
\color inherit
 — in terms of Kleisli composition 
\begin_inset Formula $\left(\diamond\right)$
\end_inset

:
\end_layout

\begin_layout Standard
\align center

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula $\left(\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)^{:X\rightarrow\text{BigM}^{X}}\diamond b^{:X\rightarrow\text{BigM}^{Y}}=b$
\end_inset


\begin_inset space \hspace*{\fill}
\end_inset

with 
\begin_inset Formula $f^{:X\rightarrow M^{Y}}\diamond g^{:Y\rightarrow M^{Z}}\triangleq x\rightarrow f(x).\text{flatMap}(g)$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\size default
Right identity law after 
\family typewriter
\size footnotesize
\color blue
lift
\begin_inset Formula $_{1}$
\end_inset


\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\family typewriter
\color blue

\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "54col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// Anywhere inside a for/yield:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 bigM 
\family roman
\color darkgray
// Any BigM value.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
i 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{1}$
\end_inset

(M
\begin_inset Formula $_{1}$
\end_inset

.pure(x))
\end_layout

\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "54col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// Must be equivalent to...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
x 
\begin_inset Formula $\leftarrow$
\end_inset

 bigM
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
i = x
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset

b.flatMap(M
\begin_inset Formula $_{1}$
\end_inset

.pure andThen lift
\begin_inset Formula $_{1}$
\end_inset

) = b
\family default
\size default
\color inherit
 — in terms of Kleisli composition:
\end_layout

\begin_layout Standard
\align center

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula $b^{:X\rightarrow\text{BigM}^{Y}}\diamond\left(\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)^{:Y\rightarrow\text{BigM}^{Y}}=b$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\size default
The same identity laws must hold for 
\family typewriter
\size footnotesize
\color blue
M
\begin_inset Formula $_{2}$
\end_inset


\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
lift
\begin_inset Formula $_{2}$
\end_inset


\family default
\size default
\color inherit
 as well
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Laws for monad liftings II.
 Simplifying the laws
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\size default

\begin_inset Formula $\big(\text{pure}_{M_{1}}\bef\text{lift}_{1}\big)$
\end_inset

 is a unit for the Kleisli composition 
\begin_inset Formula $\diamond$
\end_inset

 in the monad 
\family typewriter
\size footnotesize
\color blue
BigM
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
But the monad 
\family typewriter
\size footnotesize
\color blue
BigM
\family default
\size default
\color inherit
 already has a unit element, namely 
\begin_inset Formula $\text{pure}_{\text{BigM}}$
\end_inset


\end_layout

\begin_layout Standard
The two-sided unit element is always unique: 
\begin_inset Formula $\text{u}=\text{u}\diamond\text{u}^{\prime}=\text{u}^{\prime}$
\end_inset


\end_layout

\begin_layout Standard
So the two identity laws for 
\begin_inset Formula $\big(\text{pure}_{M_{1}}\bef\text{lift}_{1}\big)$
\end_inset

 can be reduced to one law:
\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{pure}_{M_{1}}\bef\text{lift}_{1}=\text{pure}_{\text{BigM}}
\]

\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\size default
Refactoring a portion of a monadic program under 
\family typewriter
\size footnotesize
\color blue
lift
\begin_inset Formula $_{1}$
\end_inset


\family default
\size default
\color inherit
 gives another law:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\family typewriter
\color blue

\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "58col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// Anywhere inside a for/yield, this...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
i 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{1}$
\end_inset

(p) 
\family roman
\color darkgray
// Any M
\begin_inset Formula $_{1}$
\end_inset

 value.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
j 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{1}$
\end_inset

(q(i)) 
\family roman
\color darkgray
// Any M
\begin_inset Formula $_{1}$
\end_inset

 value.
\end_layout

\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family roman
\size footnotesize
\color darkgray
// must be equivalent to...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
pq = p.flatMap(q) 
\family roman
\color darkgray
// In M
\begin_inset Formula $_{1}$
\end_inset

.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
j 
\begin_inset Formula $\leftarrow$
\end_inset

 lift
\begin_inset Formula $_{1}$
\end_inset

(pq)
\family roman
\color darkgray
  // Now lift it.
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset

lift
\begin_inset Formula $_{1}$
\end_inset

(p).flatMap(q andThen lift
\begin_inset Formula $_{1}$
\end_inset

) = lift
\begin_inset Formula $_{1}$
\end_inset

(p flatMap q)
\end_layout

\begin_layout Standard
Rewritten equivalently through 
\size footnotesize

\begin_inset Formula $\text{flm}_{M}:\left(A\rightarrow M^{B}\right)\rightarrow M^{A}\rightarrow M^{B}$
\end_inset


\size default
 as
\end_layout

\begin_layout Standard
\align center

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula $\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(q\bef\text{lift}_{1}\right)=\text{flm}_{M_{1}}q\bef\text{lift}_{1}$
\end_inset

 – both sides are functions 
\begin_inset Formula $M_{1}^{A}\rightarrow\text{BigM}^{B}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\size default
Rewritten equivalently through 
\size footnotesize

\begin_inset Formula $\text{ftn}_{M}:M^{M^{A}}\rightarrow M^{A}$
\end_inset

,
\size default
 the law is
\end_layout

\begin_layout Standard
\align center

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula $\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}\text{lift}_{1}\bef\text{ftn}_{\text{BigM}}=\text{ftn}_{M_{1}}\bef\text{lift}_{1}$
\end_inset

 – both sides are functions 
\begin_inset Formula $M_{1}^{M_{1}^{A}}\rightarrow\text{BigM}^{A}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\size default
In terms of Kleisli composition 
\begin_inset Formula $\diamond_{M}$
\end_inset

 it becomes the 
\series bold
composition law
\series default
:
\end_layout

\begin_layout Standard
\align center

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\begin_inset Formula $\big(b^{:X\rightarrow M_{1}^{Y}}\bef\text{lift}_{1}\big)\diamond_{\text{BigM}}\big(c^{:Y\rightarrow M_{1}^{Z}}\bef\text{lift}_{1}\big)=\left(b\diamond_{M_{1}}c\right)\bef\text{lift}_{1}$
\end_inset


\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\backslash
hspace{-0.0cm}
\end_layout

\end_inset


\size default
Liftings 
\begin_inset Formula $\text{lift}_{1}$
\end_inset

 and 
\begin_inset Formula $\text{lift}_{2}$
\end_inset

 must obey an identity law and a composition law
\end_layout

\begin_layout Standard
The laws say that the liftings 
\series bold
commute with
\series default
 the monads' operations
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Laws for monad liftings III.
 The naturality law
\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $\text{lift}_{1}:M_{1}^{A}\rightarrow\text{BigM}^{A}$
\end_inset

 is a natural transformation 
\end_layout

\begin_layout Standard
It maps 
\begin_inset Formula $\text{pure}_{M_{1}}$
\end_inset

 to 
\begin_inset Formula $\text{pure}_{\text{BigM}}$
\end_inset

 and 
\begin_inset Formula $\text{flm}_{M_{1}}$
\end_inset

 to 
\begin_inset Formula $\text{flm}_{\text{BigM}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\text{lift}_{1}$
\end_inset

 is a 
\series bold
monad morphism
\series default
 between monads 
\begin_inset Formula $M_{1}^{\bullet}$
\end_inset

 and 
\begin_inset Formula $\text{BigM}^{\bullet}$
\end_inset


\end_layout

\begin_layout Standard
example: monad 
\begin_inset Quotes eld
\end_inset

interpreters
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $M^{A}\rightarrow N^{A}$
\end_inset

 are monad morphisms
\end_layout

\begin_layout Standard
The (functor) naturality law: for any 
\begin_inset Formula $f:X\rightarrow Y$
\end_inset

, 
\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\size default

\begin_inset Formula 
\[
\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}f=\text{fmap}_{M_{1}}f\bef\text{lift}_{1}
\]

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5cm}
\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M_{1}^{X}\ar[d]\sb(0.45){\text{fmap}_{M_{1}}\,f^{:X\rightarrow Y}}\ar[r]\sp(0.45){\ \text{lift}_{1}} & \text{BigM}^{X}\ar[d]\sp(0.45){\text{fmap}_{\text{BigM}}\,f^{:X\rightarrow Y}}\\
M_{1}^{Y}\ar[r]\sp(0.45){\text{lift}_{1}} & \text{BigM}^{Y}
}
\]

\end_inset


\size default
Derivation of the functor naturality law for 
\begin_inset Formula $\text{lift}_{1}$
\end_inset

:
\end_layout

\begin_layout Standard
Express 
\begin_inset Formula $\text{fmap}$
\end_inset

 as 
\begin_inset Formula $\text{fmap}_{M}f\triangleq f^{\uparrow M}=\text{flm}_{M}\left(f\bef\text{pure}_{M}\right)$
\end_inset

 for both monads
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $f^{:X\rightarrow Y}$
\end_inset

, use the law 
\size footnotesize

\begin_inset Formula $\text{flm}_{M_{1}}q\bef\text{lift}_{1}=\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(q\bef\text{lift}_{1}\right)$
\end_inset


\size default
 to compute 
\size footnotesize

\begin_inset Formula $\text{flm}_{M_{1}}\left(f\bef\text{pure}_{M_{1}}\right)\bef\text{lift}_{1}=\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(f\bef\text{pure}_{M_{1}}\bef\text{lift}_{1}\right)=\text{lift}_{1}\bef\text{flm}_{\text{BigM}}\left(f\bef\text{pure}_{\text{BigM}}\right)=\text{lift}_{1}\bef\text{fmap}_{\text{BigM}}f$
\end_inset


\end_layout

\begin_layout Standard
A monad morphism is always also a natural transformation of the functors
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Monad transformers I: Motivation
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset


\size default
Combine 
\begin_inset Formula $Z\rightarrow A$
\end_inset

 and 
\begin_inset Formula $1+A$
\end_inset

: only 
\begin_inset Formula $Z\rightarrow1+A$
\end_inset

 works, not 
\begin_inset Formula $1+\left(Z\rightarrow A\right)$
\end_inset


\end_layout

\begin_layout Standard
It is not possible to combine monads via a natural bifunctor 
\begin_inset Formula $B^{M_{1},M_{2}}$
\end_inset


\end_layout

\begin_layout Standard
It is not possible to combine arbitrary monads as 
\begin_inset Formula $M_{1}^{M_{2}^{\bullet}}$
\end_inset

 or 
\begin_inset Formula $M_{2}^{M_{1}^{\bullet}}$
\end_inset


\end_layout

\begin_layout Standard
Example: state monad 
\begin_inset Formula $\text{St}_{S}^{A}\triangleq S\rightarrow A\times S$
\end_inset

 does not compose
\end_layout

\begin_layout Standard
The trick: for a fixed 
\series bold
base 
\series default
monad 
\begin_inset Formula $L^{\bullet}$
\end_inset

, let 
\begin_inset Formula $M^{\bullet}$
\end_inset

 (
\series bold
foreign 
\series default
monad) vary
\end_layout

\begin_layout Standard
Call the desired result 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 the 
\series bold
monad transformer for
\series default
 
\begin_inset Formula $L$
\end_inset


\end_layout

\begin_layout Standard
In Scala: 
\family typewriter
\size footnotesize
\color blue
MyMonadT[M[_]:Monad, A]
\family default
\size default
\color inherit
 – e.g.
 
\family typewriter
\size footnotesize
\color blue
ReaderT
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
StateT
\family default
\size default
\color inherit
, etc.
\end_layout

\begin_layout Standard
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 is generic in 
\begin_inset Formula $M$
\end_inset

 but not in 
\begin_inset Formula $L$
\end_inset


\end_layout

\begin_layout Standard
No general formula for monad transformers seems to exist
\end_layout

\begin_layout Standard
For each base monad 
\begin_inset Formula $L$
\end_inset

, a different construction is needed
\end_layout

\begin_layout Standard
Some transformers are compositions 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

 or 
\begin_inset Formula $M^{L^{\bullet}}$
\end_inset

, others are not
\end_layout

\begin_layout Standard
Do all monads 
\begin_inset Formula $L$
\end_inset

 have a transformer? (Unknown.)
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3cm}
\end_layout

\end_inset


\size default
To combine 3 or more monads, 
\begin_inset Quotes eld
\end_inset

stack up
\begin_inset Quotes erd
\end_inset

 the transformers as 
\begin_inset Formula $T_{L_{1}}^{T_{L_{2}}^{T_{L_{3}}^{M}},\bullet}$
\end_inset


\end_layout

\begin_layout Standard
Example in Scala: 
\family typewriter
\size footnotesize
\color blue
StateT[S, ListT[Reader[R, ?], ?], A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Substitute nested transformers into the monad argument, not as 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Standard
This is called a 
\series bold
monad stack
\series default
 – but may not be 
\emph on
functor composition
\end_layout

\begin_layout Standard
because e.g.
\begin_inset space ~
\end_inset


\family typewriter
\size footnotesize
\color blue
State[S, List[Reader[R, A]]]
\family default
\size default
\color inherit
 is not a monad
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Monad transformers II: The requirements
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset


\size default
A 
\series bold
monad transformer
\series default
 for a 
\series bold
base
\series default
 monad 
\begin_inset Formula $L^{\bullet}$
\end_inset

 is a type constructor 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 parameterized by a monad 
\begin_inset Formula $M^{\bullet}$
\end_inset

, such that for all monads 
\begin_inset Formula $M^{\bullet}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 is a monad (the monad 
\begin_inset Formula $M$
\end_inset

 
\series bold
transformed with
\series default
 
\begin_inset Formula $T_{L}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Lifting
\begin_inset Quotes erd
\end_inset

 – a monad morphism 
\begin_inset Formula $\text{lift}_{L}^{M}:M^{A}\leadsto T_{L}^{M,A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Base lifting
\begin_inset Quotes erd
\end_inset

 – a monad morphism 
\begin_inset Formula $\text{blift}:L^{A}\leadsto T_{L}^{M,A}$
\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

base lifting
\begin_inset Quotes erd
\end_inset

 could not possibly be natural in 
\begin_inset Formula $L^{\bullet}$
\end_inset


\end_layout

\begin_layout Standard
Transformed identity monad (
\begin_inset Formula $\text{Id}$
\end_inset

) must become 
\begin_inset Formula $L$
\end_inset

, i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula $T_{L}^{\text{Id},\bullet}\cong L^{\bullet}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 is 
\series bold
monadically natural
\series default
 in 
\begin_inset Formula $M^{\bullet}$
\end_inset

 (but not in 
\begin_inset Formula $L^{\bullet}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 is natural w.r.t.
\begin_inset space ~
\end_inset

a monadic functor 
\begin_inset Formula $M^{\bullet}$
\end_inset

 as a type parameter
\end_layout

\begin_layout Standard
For any monad 
\begin_inset Formula $N^{\bullet}$
\end_inset

 and a monad morphism 
\begin_inset Formula $f:M^{\bullet}\leadsto N^{\bullet}$
\end_inset

 we need to have a monad morphism 
\begin_inset Formula $T_{L}^{M,\bullet}\leadsto T_{L}^{N,\bullet}$
\end_inset

 for the transformed monads: 
\begin_inset Formula $\text{mrun}_{L}^{M}:\left(M^{\bullet}\leadsto N^{\bullet}\right)\rightarrow T_{L}^{M,\bullet}\leadsto T_{L}^{N,\bullet}$
\end_inset

 with the 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 laws
\end_layout

\begin_layout Standard
If we implement 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 only via 
\begin_inset Formula $M$
\end_inset

's monad methods, naturality will hold 
\end_layout

\begin_layout Standard
Cf.
\begin_inset space ~
\end_inset


\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size small
\color inherit

\begin_inset Formula $:L^{A}\rightarrow(A\rightarrow F^{B})\rightarrow F^{L^{B}}$
\end_inset

 – natural w.r.t.
\begin_inset space ~
\end_inset

applicative 
\begin_inset Formula $F^{\bullet}$
\end_inset


\end_layout

\begin_layout Standard
This can be used for lifting a 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $M^{A}\leadsto A$
\end_inset

 to 
\begin_inset Formula $T_{L}^{M,\bullet}\leadsto T_{L}^{\text{Id},\bullet}=L^{\bullet}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Base runner
\begin_inset Quotes erd
\end_inset

: lifts 
\begin_inset Formula $L^{A}\leadsto A$
\end_inset

 into a monad morphism 
\begin_inset Formula $T_{L}^{M,\bullet}\leadsto M^{\bullet}$
\end_inset

; so 
\begin_inset Formula $\text{brun}_{L}^{M}:\left(L^{\bullet}\leadsto\bullet\right)\rightarrow T_{L}^{M,\bullet}\leadsto M^{\bullet}$
\end_inset

, must commute with 
\family typewriter
\size footnotesize
\color blue
lift
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
blift
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Monad transformers III: First examples
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\size default
Recall these monad constructions:
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M^{A}$
\end_inset

 is a monad then 
\begin_inset Formula $R\rightarrow M^{A}$
\end_inset

 is also a monad (for a fixed type 
\begin_inset Formula $R$
\end_inset

)
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M^{A}$
\end_inset

 is a monad then 
\begin_inset Formula $M^{Z+A\times W}$
\end_inset

 is also a monad (for fixed 
\begin_inset Formula $W,$
\end_inset

 
\begin_inset Formula $Z$
\end_inset

)
\end_layout

\begin_layout Standard
This gives the monad transformers for base monads 
\family typewriter
\size footnotesize
\color blue
Reader
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Writer
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
type ReaderT[R, M[_], A] = R 
\begin_inset Formula $\rightarrow$
\end_inset

 M[A]
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
type EitherT[Z, M[_], A] = M[Either[Z, A]]
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
type WriterT[W, M[_], A] = M[(W, A)]
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset


\family typewriter
\color blue
ReaderT
\family default
\size default
\color inherit
 composes with the foreign monad from the 
\emph on
outside
\end_layout

\begin_layout Standard

\family typewriter
\size footnotesize
\color blue
EitherT
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
WriterT
\family default
\size default
\color inherit
 must be composed 
\emph on
inside
\emph default
 the foreign monad
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.1cm}
\end_layout

\end_inset


\size default
Remaining questions:
\end_layout

\begin_layout Standard
What are transformers for other standard monads (
\family typewriter
\size footnotesize
\color blue
List
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
State
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Cont
\family default
\size default
\color inherit
)?
\end_layout

\begin_layout Standard
These monads do not compose (neither 
\begin_inset Quotes eld
\end_inset

inside
\begin_inset Quotes erd
\end_inset

 nor 
\begin_inset Quotes eld
\end_inset

outside
\begin_inset Quotes erd
\end_inset

 works)!
\end_layout

\begin_layout Standard
How to derive a monad transformer for an arbitrary given monad?
\end_layout

\begin_layout Standard
For monads obtained via known monad constructions?
\end_layout

\begin_layout Standard
For monads constructed via other monad transformers? (Stack them.)
\end_layout

\begin_layout Standard
Is it always possible? (No known counterexamples.)
\end_layout

\begin_layout Standard
Is a given monad's transformer unique? (No.)
\end_layout

\begin_layout Standard
How to avoid the boilerplate around 
\family typewriter
\size footnotesize
\color blue
lift
\family default
\size default
\color inherit
? (
\family typewriter
\size footnotesize
\color blue
mtl
\family default
\size default
\color inherit
-style transformers)
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Paragraph
Monad transformers IV: The zoology of 
\emph on
ad hoc
\emph default
 methods
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.2cm}
\end_layout

\end_inset


\size default
Need to choose the correct monad transformer construction, per monad:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Composed-inside
\begin_inset Quotes erd
\end_inset

, base monad is inside foreign monad: 
\begin_inset Formula $T_{L}^{M,A}=M^{L^{A}}$
\end_inset


\end_layout

\begin_layout Standard
Examples: the 
\series bold
linear
\series default
 monads 
\family typewriter
\size footnotesize
\color blue
OptionT
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
WriterT
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
EitherT
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Composed-outside
\begin_inset Quotes erd
\end_inset

 – the base monad is outside: 
\begin_inset Formula $T_{L}^{M,A}=L^{M^{A}}$
\end_inset


\end_layout

\begin_layout Standard
Examples: 
\family typewriter
\size footnotesize
\color blue
ReaderT
\family default
\size default
\color inherit
; 
\family typewriter
\size footnotesize
\color blue
SearchT
\family default
\size default
\color inherit
 for search monad 
\family typewriter
\size footnotesize
\color blue
S[A] = (A 
\begin_inset Formula $\rightarrow$
\end_inset

 Z) 
\begin_inset Formula $\rightarrow$
\end_inset

 A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
More generally: all 
\series bold
rigid
\series default
 monads have 
\begin_inset Quotes eld
\end_inset

outside
\begin_inset Quotes erd
\end_inset

 transformers
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Recursive
\begin_inset Quotes erd
\end_inset

: interleaves the base monad and the foreign monad
\end_layout

\begin_layout Standard
Examples: 
\family typewriter
\size footnotesize
\color blue
ListT
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
NonEmptyListT
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
FreeMonadT
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Monad constructions: defining a transformer for new monads
\end_layout

\begin_layout Standard
Product monads 
\begin_inset Formula $L_{1}^{A}\times L_{2}^{A}$
\end_inset

 – product transformer 
\begin_inset Formula $T_{L_{1}}^{M,A}\times T_{L_{2}}^{M,A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Contrafunctor-choice
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $H^{A}\rightarrow A$
\end_inset

 – composed-outside transformer
\end_layout

\begin_layout Standard
Free pointed monads 
\begin_inset Formula $A+L^{A}$
\end_inset

 – transformer 
\begin_inset Formula $M^{A+T_{L}^{M,A}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Irregular
\begin_inset Quotes erd
\end_inset

: none of the above constructions work, need something else
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula $T_{\text{State}}^{M,A}=S\rightarrow M^{S\times A}$
\end_inset


\size default
; 
\size footnotesize

\begin_inset Formula $T_{\text{Cont}}^{M,A}=\left(A\rightarrow M^{R}\right)\rightarrow M^{R}$
\end_inset


\size default
; 
\begin_inset Quotes eld
\end_inset

selector
\begin_inset Quotes erd
\end_inset

 
\size footnotesize

\begin_inset Formula $F^{A\rightarrow P^{Q}}\rightarrow P^{A}$
\end_inset


\size default
 – transformer 
\begin_inset Formula $F^{A\rightarrow T_{P}^{M,Q}}\rightarrow T_{P}^{M,A}$
\end_inset

; codensity 
\size footnotesize

\begin_inset Formula $\forall R.\left(A\rightarrow M^{R}\right)\rightarrow M^{R}$
\end_inset


\end_layout

\begin_layout Standard
Examples of monads 
\begin_inset Formula $K^{A}$
\end_inset

 for which no transformers exist? (not known)
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\size default

\begin_inset Formula $T_{\text{Cod}}$
\end_inset

, 
\begin_inset Formula $T_{\text{Sel}}$
\end_inset

, and 
\begin_inset Formula $T_{\text{Cont}}$
\end_inset

 transformers have no 
\family typewriter
\size footnotesize
\color blue
blift
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
brun
\family default
\size default
\color inherit
, or 
\family typewriter
\size footnotesize
\color blue
mrun
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Section
Practical use
\end_layout

\begin_layout Subsection
Combining effects by functor composition
\end_layout

\begin_layout Standard
Monads describe effects that depend on previously computed values.
 It is often necessary to combine effects of several monads in one value.
 For example, a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 can be computed concurrently, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 represents a possibly missing value.
 To describe a possibly missing value that is also computed concurrently,
 we need somehow to combine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Functor composition, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Option[A]]
\end_layout

\end_inset

, is one way of combining two functors.
 Consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Laws and structure
\end_layout

\begin_layout Subsection
Laws of monad transformers
\begin_inset CommandInset label
LatexCommand label
name "subsec:Laws-of-monad-transformers"

\end_inset


\end_layout

\begin_layout Standard
A monad transformer 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 is a type constructor with a type parameter 
\begin_inset Formula $A$
\end_inset

 and a monad parameter 
\begin_inset Formula $M$
\end_inset

, such that the following laws hold:
\end_layout

\begin_layout Enumerate

\series bold
Monad construction law
\series default
: 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 is a lawful monad for any monad 
\begin_inset Formula $M$
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!monad construction law
\end_layout

\end_inset

 In other words, the transformed monad 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 has methods 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 that satisfy the monad laws.
\end_layout

\begin_layout Enumerate

\series bold
Identity law
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!identity law
\end_layout

\end_inset

 
\begin_inset Formula $T_{L}^{\text{Id},\bullet}\cong L^{\bullet}$
\end_inset

 via a monadic isomorphism, where 
\begin_inset Formula $\text{Id}$
\end_inset

 is the identity monad, 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Lifting law
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!lifting law
\end_layout

\end_inset

 For any monad 
\begin_inset Formula $M$
\end_inset

, the function 
\begin_inset Formula $\text{lift}:M^{A}\rightarrow T_{L}^{M,A}$
\end_inset

 is a monad morphism.
 (In a shorter notation, 
\begin_inset Formula $\text{lift}:M\leadsto T_{L}^{M}$
\end_inset

.)
\end_layout

\begin_layout Enumerate

\series bold
Runner laws
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!runner laws
\end_layout

\end_inset

 For any monads 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 and any monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

, the runner 
\begin_inset Formula $\text{mrun}\left(\phi\right):T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

 is a monad morphism.
 Moreover, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mrun
\end_layout

\end_inset

 lifts monad morphisms from 
\begin_inset Formula $M\leadsto N$
\end_inset

 to 
\begin_inset Formula $T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

 and must satisfy the corresponding 
\series bold
lifting laws
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!lifting laws of runner
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{mrun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{mrun}\left(\phi\right)\bef\text{mrun}\left(\chi\right)=\text{mrun}\left(\phi\bef\chi\right)\quad.
\]

\end_inset

It follows from the identity law 
\begin_inset Formula $T_{L}^{\text{Id}}\cong L$
\end_inset

 that the base monad 
\begin_inset Formula $L$
\end_inset

 can be lifted into 
\begin_inset Formula $T_{L}^{M}$
\end_inset

: Setting 
\begin_inset Formula $\phi=\text{pu}_{M}:\text{Id}\leadsto M$
\end_inset

, we obtain
\begin_inset Formula 
\[
\text{mrun}\left(\text{pu}_{M}\right):T_{L}^{\text{Id}}\leadsto T_{L}^{M}=L\leadsto T_{L}^{M}.
\]

\end_inset

This function is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!base lifting
\end_layout

\end_inset


\series bold
base lifting
\series default
, 
\begin_inset Formula $\text{mrun}\left(\text{pu}_{M}\right)\triangleq\text{blift}:L^{A}\rightarrow T_{L}^{M,A}$
\end_inset

.
 The base lifting automatically satisfies the non-degeneracy law,
\begin_inset Formula 
\[
\text{blift}\bef\text{mrun}\left(\phi^{:M\leadsto\text{Id}}\right)=\text{id}\quad,
\]

\end_inset

for any monad morphism 
\begin_inset Formula $\phi:M\leadsto\text{Id}$
\end_inset

, because the left-hand side equals 
\begin_inset Formula $\text{mrun}\left(\text{pu}_{M}\bef\phi\right)$
\end_inset

, and the composition law for monad morphisms gives 
\begin_inset Formula $\text{pu}_{M}\bef\phi=\text{pu}_{\text{Id}}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Base runner laws
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!base runner laws
\end_layout

\end_inset

 For any monad morphism 
\begin_inset Formula $\theta:L\leadsto\text{Id}$
\end_inset

 and for any monad 
\begin_inset Formula $M$
\end_inset

, the base runner 
\begin_inset Formula $\text{brun}\left(\theta\right):T_{L}^{M}\leadsto M$
\end_inset

 is a monad morphism.
 The base runner must also satisfy the 
\series bold
non-degeneracy law
\series default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!non-degeneracy law
\end_layout

\end_inset

 
\begin_inset Formula 
\[
\text{lift}\bef\text{brun}\left(\theta\right)=\text{id}\quad.
\]

\end_inset

Since the monad transformer is specific to the base monad 
\begin_inset Formula $L$
\end_inset

 and does not support an arbitrary other base monad, there are no lifting
 laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

, unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mrun
\end_layout

\end_inset

.
 So the non-degeneracy law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 is not an automatic consequence of other laws.
\end_layout

\begin_layout Standard
In total, we listed 15 laws for monad transformers.
 Are all these laws necessary? 
\end_layout

\begin_layout Subsection
Examples of incorrect monad transformers
\end_layout

\begin_layout Standard
The laws of monad transformers guarantee that the transformed monad is able
 to represent, without loss of information, the operations of the base monad
 as well as the operations of the foreign monad.
 If some of these laws are omitted, we may obtain a type constructor that
 does not work correctly even though it has the methods with the required
 type signatures.
\end_layout

\begin_layout Standard
The simplest example of an incorrect monad transformer is obtained by defining
 the transformed monad to be the unit monad, 
\begin_inset Formula $T_{L}^{M,A}\triangleq\bbnum 1$
\end_inset

, for any monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 It is clear that this 
\begin_inset Quotes eld
\end_inset

transformer
\begin_inset Quotes erd
\end_inset

 is completely wrong: it cannot possibly keep the information about the
 monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, because the methods of the unit monad discard 
\emph on
all
\emph default
 information and return 
\begin_inset Formula $1$
\end_inset

.
 However, the type constructor 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 still has all the required methods 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

, 
\begin_inset Formula $\text{lift}_{T}$
\end_inset

, 
\begin_inset Formula $\text{mrun}_{T}$
\end_inset

, and 
\begin_inset Formula $\text{brun}_{T}$
\end_inset

 with the required type signatures (they are constant functions returning
 
\begin_inset Formula $1$
\end_inset

).
 All these functions are automatically monad morphisms, since a function
 from any monad to the unit monad is always a monad morphism.
 So, the fake 
\begin_inset Quotes eld
\end_inset

transformer
\begin_inset Quotes erd
\end_inset

 satisfies almost all of the monad transformer laws! However, the identity
 law 
\begin_inset Formula $T_{L}^{\text{Id}}\cong L$
\end_inset

 and the non-degeneracy law 
\begin_inset Formula $\text{lift}\bef\text{brun}\left(\theta\right)=\text{id}$
\end_inset

 are violated since 
\begin_inset Formula $T_{L}^{\text{Id}}=\bbnum 1\not\cong L$
\end_inset

 and 
\begin_inset Formula $\text{lift}\bef\text{brun}\left(\theta\right)=\left(\_\rightarrow1\right)\neq\text{id}$
\end_inset

.
 For this reason, the unit monad is not a lawful monad transformer.
\end_layout

\begin_layout Standard
This simple example demonstrates the importance of the monad transformer
 laws.
 A malicious programmer could give us a fake implementation of a 
\begin_inset Quotes eld
\end_inset

transformer
\begin_inset Quotes erd
\end_inset

 that appears to have all the methods with the correct type signatures but,
 instead of a bigger monad, constructs a unit monad dressed up as a type
 constructor 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

.
 The only way for us to detect the fraud is to find that the identity law
 and the non-degeneracy law are violated.
\end_layout

\begin_layout Standard
Other examples of fake 
\begin_inset Quotes eld
\end_inset

transformers
\begin_inset Quotes erd
\end_inset

 violating some of the laws are 
\begin_inset Formula $T_{L}^{M}=L$
\end_inset

 (no lifting law) and 
\begin_inset Formula $T_{L}^{M}=M$
\end_inset

 (no identity law).
\end_layout

\begin_layout Standard
In these cases, it is intuitively clear that the fake transformer definitions
 are incorrect because the information about either 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 is missing in 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 A potentially working definition of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 must be a type constructor whose definition somehow combines both 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 Many such definitions are possible, but few will satisfy the monad transformer
 laws.
\end_layout

\begin_layout Subsection
Examples of failure to define a generic monad transformer
\end_layout

\begin_layout Standard
It appears to be impossible to define 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 as a generic construction that works in the same way for all monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 We will now consider a few ways of combining the type constructors 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 in a way that is independent of their structure.
 In all these cases, we will find that some of the monad transformer laws
 are violated.
\end_layout

\begin_layout Standard
General ways of combining two type constructors 
\begin_inset Formula $L^{\bullet}$
\end_inset

 and 
\begin_inset Formula $M^{\bullet}$
\end_inset

 are functor composition 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

 or 
\begin_inset Formula $M^{L^{\bullet}}$
\end_inset

, disjunction 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

, and product 
\begin_inset Formula $L^{\bullet}\times M^{\bullet}$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Functor composition
\end_layout

\begin_layout Standard
A general way of combining two type constructors 
\begin_inset Formula $L^{\bullet}$
\end_inset

 and 
\begin_inset Formula $M^{\bullet}$
\end_inset

 is the functor composition 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

 or 
\begin_inset Formula $M^{L^{\bullet}}$
\end_inset

.
 However, the functor composition works only for certain monads and only
 in a certain order; so it cannot work as a generic monad transformer.
 A simple counterexample is 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq A\times A$
\end_inset

 where 
\begin_inset Formula $M^{L^{A}}$
\end_inset

 is a monad but 
\begin_inset Formula $L^{M^{A}}$
\end_inset

 is not (see Section
\begin_inset space ~
\end_inset

???).
 Another counterexample is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad, 
\begin_inset Formula $\text{State}_{S}^{A}\triangleq S\rightarrow S\times A$
\end_inset

, for which we have already shown that 
\begin_inset Formula $\bbnum 1+\text{State}_{S}^{A}$
\end_inset

 is not a monad and 
\begin_inset Formula $\text{State}_{S}^{Z\rightarrow A}$
\end_inset

 is not a monad (see Section
\begin_inset space ~
\end_inset

???).
 In other words, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad does not compose with arbitrary monads 
\begin_inset Formula $M$
\end_inset

 in either order.
\end_layout

\begin_layout Paragraph
Functor disjunction
\end_layout

\begin_layout Standard
The functor disjunction 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

 is in general not a monad when 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are arbitrary monads.
 An immediate counterexample is found by using two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monads, 
\begin_inset Formula $L^{A}\triangleq R\rightarrow A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq S\rightarrow A$
\end_inset

.
 The disjunction 
\begin_inset Formula $\left(R\rightarrow A\right)+\left(S\rightarrow A\right)$
\end_inset

 is a functor that is not a monad (and not even applicative, see Section
\begin_inset space ~
\end_inset

???).
\end_layout

\begin_layout Paragraph
Functor product
\end_layout

\begin_layout Standard
The functor product 
\begin_inset Formula $L^{\bullet}\times M^{\bullet}$
\end_inset

 is a monad for arbitrary monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 However, there is no naturally defined 
\begin_inset Formula $\text{lift}:M^{\bullet}\leadsto L^{\bullet}\times M^{\bullet}$
\end_inset

 because we cannot create values of type 
\begin_inset Formula $L^{A}$
\end_inset

 out of values of type 
\begin_inset Formula $M^{A}$
\end_inset

 for arbitrary monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Paragraph
Using the free monad
\end_layout

\begin_layout Standard
The functor composition 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

 and the disjunction 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

 may not always be monads, but they are always functors.
 So we can make monads out of them, by using the free monad construction.
 We get 
\begin_inset Formula $\text{Free}^{L^{M^{\bullet}}}$
\end_inset

, the free monad over 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

, and 
\begin_inset Formula $\text{Free}^{L^{\bullet}+M^{\bullet}}$
\end_inset

, the free monad over 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

.
 Many laws of the monad transformer are satisfied by these constructions.
 However, the identity laws fail because
\begin_inset Formula 
\[
\text{Free}^{L^{\text{Id}^{\bullet}}}\cong\text{Free}^{L^{\bullet}}\not\cong L\quad,\quad\quad\text{Free}^{L^{\bullet}+\text{Id}^{\bullet}}\not\cong L\quad,
\]

\end_inset

and the lifting laws are also violated because 
\begin_inset Formula $\text{lift}:M^{A}\rightarrow\text{Free}^{L^{\bullet}+M^{\bullet},A}$
\end_inset

 is not a monad morphism because it maps 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 into a non-pure value of the free monad.
 Nevertheless, these constructions are not useless.
 Once we run the free monad into a concrete (non-free) monad, we could arrange
 to hide the violations of these laws, so that the monad laws hold for the
 resulting (non-free) monad.
\end_layout

\begin_layout Paragraph
\begin_inset Quotes eld
\end_inset

Monoidal convolution
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The construction called 
\begin_inset Quotes eld
\end_inset


\series bold
monoidal convolution
\begin_inset Index idx
status open

\begin_layout Plain Layout
monoidal convolution
\end_layout

\end_inset


\series default

\begin_inset Quotes erd
\end_inset

 defines a new functor 
\begin_inset Formula $L\star M$
\end_inset

 via 
\begin_inset Formula 
\begin{equation}
\left(L\star M\right)^{A}\triangleq\exists P\exists Q.\left(P\times Q\rightarrow A\right)\times L^{P}\times M^{Q}\quad.\label{eq:definition-of-monoidal-convolution}
\end{equation}

\end_inset

This formula can be seen as a combination of the co-Yoneda identities
\begin_inset Formula 
\[
L^{A}\cong\exists P.L^{P}\times\left(P\rightarrow A\right)\quad,\quad\quad M^{A}\cong\exists Q.M^{Q}\times\left(Q\rightarrow A\right)\quad.
\]

\end_inset

The functor product 
\begin_inset Formula $L\times M$
\end_inset

 is equivalent to
\begin_inset Formula 
\begin{align}
 & L^{A}\times M^{A}\nonumber \\
\text{co-Yoneda identities for }L^{A}\text{ and }M^{A}:\quad & \cong\exists P.L^{P}\times\gunderline{\left(P\rightarrow A\right)}\times\exists Q.M^{Q}\times\gunderline{\left(Q\rightarrow A\right)}\nonumber \\
\text{equivalence in Eq.~(\ref{eq:equivalence-pq-a-for-monoidal-convolution})}:\quad & \cong\exists P.\exists Q.L^{P}\times M^{Q}\times\left(P+Q\rightarrow A\right)\label{eq:product-l-m-for-monoidal-convolution}
\end{align}

\end_inset

where we used the type equivalence 
\begin_inset Formula 
\begin{equation}
\left(P\rightarrow A\right)\times\left(Q\rightarrow A\right)\cong P+Q\rightarrow A\quad.\label{eq:equivalence-pq-a-for-monoidal-convolution}
\end{equation}

\end_inset

If we (arbitrarily) replace 
\begin_inset Formula $P+Q\rightarrow A$
\end_inset

 by 
\begin_inset Formula $P\times Q\rightarrow A$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:product-l-m-for-monoidal-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we will obtain Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-monoidal-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The monoidal convolution 
\begin_inset Formula $L\star M$
\end_inset

 always produces a functor since Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-monoidal-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is covariant in 
\begin_inset Formula $A$
\end_inset

.
 An example where the monoidal convolution fails to produce a monad transformer
 is 
\begin_inset Formula $L^{A}\triangleq1+A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq R\rightarrow A$
\end_inset

.
 We compute the functor 
\begin_inset Formula $L\star M$
\end_inset

 and establish that it is not a monad:
\begin_inset Formula 
\begin{align*}
 & \left(L\star M\right)^{A}\\
\text{definitions of }L,M,\star:\quad & \cong\exists P\exists Q.\gunderline{\left(P\times Q\rightarrow A\right)}\times\left(\bbnum 1+P\right)\times\left(R\rightarrow Q\right)\\
\text{curry the arguments, move quantifier}:\quad & \cong\exists P.\left(\bbnum 1+P\right)\times\gunderline{\exists Q.\left(Q\rightarrow P\rightarrow A\right)\times\left(R\rightarrow Q\right)}\\
\text{co-Yoneda identity with }\exists Q:\quad & \cong\exists P.\left(\bbnum 1+P\right)\times\left(\gunderline{R\rightarrow P}\rightarrow A\right)\\
\text{swap curried arguments}:\quad & \cong\exists P.\left(\bbnum 1+P\right)\times\left(P\rightarrow R\rightarrow A\right)\\
\text{co-Yoneda identity with }\exists P:\quad & \cong\bbnum 1+\left(R\rightarrow A\right)\quad.
\end{align*}

\end_inset

This functor is not a monad (see Section
\begin_inset space ~
\end_inset

???).
\end_layout

\begin_layout Paragraph
Codensity tricks***
\end_layout

\begin_layout Itemize
codensity monad over 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

: 
\begin_inset Formula $F^{A}\triangleq\forall B.\,\big(A\rightarrow L^{M^{B}}\big)\rightarrow L^{M^{B}}$
\end_inset

 – no lift 
\end_layout

\begin_layout Itemize
Codensity-
\begin_inset Formula $L$
\end_inset

 transformer: 
\begin_inset Formula $\text{Cod}_{L}^{M,A}\triangleq\forall B.\left(A\rightarrow L^{B}\right)\rightarrow L^{M^{B}}$
\end_inset

 – no lift 
\end_layout

\begin_deeper
\begin_layout Itemize
applies the continuation transformer to 
\begin_inset Formula $M^{A}\cong\forall B.\left(A\rightarrow B\right)\rightarrow M^{B}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Codensity composition: 
\begin_inset Formula $F^{A}\triangleq\forall B.\left(M^{A}\rightarrow L^{B}\right)\rightarrow L^{B}$
\end_inset

 – not a monad
\end_layout

\begin_deeper
\begin_layout Itemize
Counterexample: 
\begin_inset Formula $M^{A}\triangleq R\rightarrow A$
\end_inset

 and 
\begin_inset Formula $L^{A}\triangleq S\rightarrow A$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Functor composition with transformed monads
\end_layout

\begin_layout Standard
Suppose we are working with a base monad 
\begin_inset Formula $L$
\end_inset

 and a foreign monad 
\begin_inset Formula $M$
\end_inset

, and we have constructed the transformed monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 In this section, let us denote the transformed monad simply by 
\begin_inset Formula $T$
\end_inset

.
 
\end_layout

\begin_layout Standard
A useful property of monad transformers is that the monad 
\begin_inset Formula $T$
\end_inset

 adequately describes the effects of both monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 at the same time.
 Suppose we are working with a deeply nested type constructor involving
 many functor layers of monads 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, and 
\begin_inset Formula $T$
\end_inset

 such as
\begin_inset Formula 
\[
T^{M^{T^{L^{M^{L^{A}}}}}}\quad.
\]

\end_inset

The properties of the transformer allow us to convert this type to a single
 layer of the transformed monad 
\begin_inset Formula $T$
\end_inset

.
 In this example, we will have a natural transformation
\begin_inset Formula 
\[
T^{M^{T^{L^{M^{L^{A}}}}}}\rightarrow T^{A}\quad.
\]

\end_inset

To achieve this, we first use the methods 
\begin_inset Formula $\text{blift}$
\end_inset

 and 
\begin_inset Formula $\text{lift}$
\end_inset

 to convert each layer of 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 to a layer of 
\begin_inset Formula $T$
\end_inset

, lifting into functors as necessary.
 The result will be a number of nested layers of 
\begin_inset Formula $T$
\end_inset

.
 Second, we use 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 as many times as necessary to flatten all nested layers of 
\begin_inset Formula $T$
\end_inset

 into a single layer.
 The result is a value of type 
\begin_inset Formula $T^{A}$
\end_inset

.
\end_layout

\begin_layout Subsection
Stacking two monads
\begin_inset CommandInset label
LatexCommand label
name "subsec:Stacking-two-monads"

\end_inset


\end_layout

\begin_layout Standard
Suppose we know the transformers 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

 for some given monads 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 We can transform 
\begin_inset Formula $Q$
\end_inset

 with 
\begin_inset Formula $P$
\end_inset

 and obtain a monad 
\begin_inset Formula $R^{A}\triangleq T_{P}^{Q,A}$
\end_inset

.
 What would be the monad transformer 
\begin_inset Formula $T_{R}$
\end_inset

 for the monad 
\begin_inset Formula $R$
\end_inset

?
\end_layout

\begin_layout Standard
A simple solution is to first transform the foreign monad 
\begin_inset Formula $M$
\end_inset

 with 
\begin_inset Formula $T_{Q}$
\end_inset

, obtaining a new monad 
\begin_inset Formula $T_{Q}^{M,\bullet}$
\end_inset

, and then to transform that new monad with 
\begin_inset Formula $T_{P}$
\end_inset

.
 So the formula for the transformer 
\begin_inset Formula $T_{R}$
\end_inset

 is
\begin_inset Formula 
\[
T_{R}^{M,A}=T_{P}^{T_{Q}^{M,\bullet},A}\quad.
\]

\end_inset

Here the monad 
\begin_inset Formula $T_{Q}^{M,\bullet}$
\end_inset

 was substituted into 
\begin_inset Formula $T_{P}^{M,A}$
\end_inset

 as the foreign monad 
\begin_inset Formula $M$
\end_inset

 (not as the type parameter 
\begin_inset Formula $A$
\end_inset

).
 This way of composition is called 
\series bold
stacking
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!stacking
\end_layout

\end_inset


\series default
 the monad transformers.
 
\end_layout

\begin_layout Standard
In Scala code, this 
\begin_inset Quotes eld
\end_inset

stacking
\begin_inset Quotes erd
\end_inset

 composition is written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type RT[M, A] = PT[QT[M, ?], A]
\end_layout

\end_inset

The resulting monad is a 
\series bold
stack
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!stack of
\end_layout

\end_inset


\series default
 of three monads 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

.
 The order of monads in the stack is significant since, in general, there
 will be no monadic isomorphism between monads stacked in a different order.
\end_layout

\begin_layout Standard
We will now show that the transformer 
\begin_inset Formula $T_{R}$
\end_inset

 is lawful (satisfies all five laws shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

), as long as both 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

 satisfy the same five laws.
 To shorten the notation, we talk about a 
\begin_inset Quotes eld
\end_inset

monad 
\begin_inset Formula $T_{P}^{M}$
\end_inset


\begin_inset Quotes erd
\end_inset

 meaning the monad defined as 
\begin_inset Formula $T_{P}^{M,\bullet}$
\end_inset

 or, more verbosely, the monad 
\begin_inset Formula $G^{A}\triangleq T_{P}^{M,A}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Monad construction law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $T_{P}^{T_{Q}^{M}}$
\end_inset

 is a monad for any monad 
\begin_inset Formula $M$
\end_inset

.
 The monad construction law for 
\begin_inset Formula $T_{Q}$
\end_inset

 says that 
\begin_inset Formula $T_{Q}^{M}$
\end_inset

 is a monad.
 The monad construction law for 
\begin_inset Formula $T_{P}$
\end_inset

 says that 
\begin_inset Formula $T_{P}^{S}$
\end_inset

 is a monad for any monad 
\begin_inset Formula $S$
\end_inset

; in particular, for 
\begin_inset Formula $S=T_{Q}^{M}$
\end_inset

.
 Therefore, 
\begin_inset Formula $T_{P}^{S}=T_{P}^{T_{Q}^{M}}$
\end_inset

 is a monad, as required.
\end_layout

\begin_layout Paragraph
Identity law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $T_{P}^{T_{Q}^{\text{Id}}}\cong T_{P}^{Q}$
\end_inset

 via a monadic isomorphism.
 The identity law for 
\begin_inset Formula $T_{Q}$
\end_inset

 says that 
\begin_inset Formula $T_{Q}^{\text{Id}}\cong Q$
\end_inset

 via a monadic isomorphism.
 So, we already have a monad morphism 
\begin_inset Formula $\phi:Q\leadsto T_{Q}^{\text{Id}}$
\end_inset

 and its inverse, 
\begin_inset Formula $\chi:T_{Q}^{\text{Id}}\leadsto Q$
\end_inset

.
 The runner 
\begin_inset Formula $\text{mrun}_{P}$
\end_inset

 for 
\begin_inset Formula $T_{P}$
\end_inset

 can be applied to both 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

 since they are monad morphisms.
 So we obtain two new monad morphisms,
\begin_inset Formula 
\[
\text{mrun}_{P}\left(\phi\right):T_{P}^{Q}\leadsto T_{P}^{T_{Q}^{\text{Id}}}\quad;\quad\quad\text{mrun}_{P}\left(\chi\right):T_{P}^{T_{Q}^{\text{Id}}}\leadsto T_{P}^{Q}\quad.
\]

\end_inset

Are these two monad morphisms inverses of each other? To show this, we need
 to verify that
\begin_inset Formula 
\[
\text{mrun}_{P}\left(\phi\right)\bef\text{mrun}_{P}\left(\chi\right)=\text{id}\quad,\quad\quad\text{mrun}_{P}\left(\chi\right)\bef\text{mrun}_{P}\left(\phi\right)=\text{id}\quad.
\]

\end_inset

By the runner law for 
\begin_inset Formula $T_{P}$
\end_inset

, we have 
\begin_inset Formula $\text{mrun}_{P}\left(f\right)\bef\text{mrun}_{P}\left(g\right)=\text{mrun}_{P}\left(f\bef g\right)$
\end_inset

 for any two monad morphisms 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 We also have 
\begin_inset Formula $\text{mrun}_{P}\left(\text{id}\right)=\text{id}$
\end_inset

 by the same law.
 So, 
\begin_inset Formula 
\begin{align*}
\text{mrun}_{P}\left(\phi\right)\bef\text{mrun}_{P}\left(\chi\right) & =\text{mrun}_{P}\left(\phi\bef\chi\right)=\text{mrun}_{P}\left(\text{id}\right)=\text{id}\quad,\\
\text{mrun}_{P}\left(\chi\right)\bef\text{mrun}_{P}\left(\phi\right) & =\text{mrun}_{P}\left(\chi\bef\phi\right)=\text{mrun}_{P}\left(\text{id}\right)=\text{id}\quad.
\end{align*}

\end_inset

We have indeed obtained a monadic isomorphism between 
\begin_inset Formula $T_{P}^{Q}$
\end_inset

 and 
\begin_inset Formula $T_{P}^{T_{Q}^{\text{Id}}}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Lifting law
\end_layout

\begin_layout Standard
We need to show that there exists a monad morphism 
\begin_inset Formula $M\leadsto T_{P}^{T_{Q}^{M}}$
\end_inset

 for any monad 
\begin_inset Formula $M$
\end_inset

.
 The lifting law for 
\begin_inset Formula $T_{Q}$
\end_inset

 gives a monad morphism 
\begin_inset Formula $\text{lift}_{Q}:M\leadsto T_{Q}^{M}$
\end_inset

.
 The lifting law for 
\begin_inset Formula $T_{P}$
\end_inset

 can be applied to the monad 
\begin_inset Formula $T_{Q}^{M}$
\end_inset

, which gives a monad morphism 
\begin_inset Formula 
\[
\text{lift}_{P}:T_{Q}^{M}\leadsto T_{P}^{T_{Q}^{M}}\quad.
\]

\end_inset

The composition of this with 
\begin_inset Formula $\text{lift}_{Q}$
\end_inset

 is a monad morphism of the required type 
\begin_inset Formula $M\leadsto T_{P}^{T_{Q}^{M}}$
\end_inset

.
 (A composition of monad morphisms is again a monad morphism by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Paragraph
Runner law
\end_layout

\begin_layout Standard
We need to show that there exists a lawful lifting 
\begin_inset Formula 
\[
\text{mrun}_{R}:\left(M\leadsto N\right)\rightarrow T_{P}^{T_{Q}^{M}}\leadsto T_{P}^{T_{Q}^{N}}\quad.
\]

\end_inset

First, we have to define 
\begin_inset Formula $\text{mrun}_{R}\phi$
\end_inset

 for any given 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

.
 We use the lifting law for 
\begin_inset Formula $T_{Q}$
\end_inset

 to get a monad morphism
\begin_inset Formula 
\[
\text{lift}_{Q}\phi:T_{Q}^{M}\leadsto T_{Q}^{N}\quad.
\]

\end_inset

Now we can apply the lifting law for 
\begin_inset Formula $T_{P}$
\end_inset

 to this monad morphism and obtain
\begin_inset Formula 
\[
\text{lift}_{P}\left(\text{lift}_{Q}\phi\right):T_{P}^{T_{Q}^{M}}\leadsto T_{P}^{T_{Q}^{N}}\quad.
\]

\end_inset

This function has the correct type signature.
 So we can define
\begin_inset Formula 
\[
\text{lift}_{R}\triangleq\text{lift}_{Q}\bef\text{lift}_{P}=\text{lift}_{P}\circ\text{lift}_{Q}\quad.
\]

\end_inset

It remains to prove that 
\begin_inset Formula $\text{lift}_{R}$
\end_inset

 is a lawful lifting.
 We use the fact that both 
\begin_inset Formula $\text{lift}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{lift}_{Q}$
\end_inset

 are lawful liftings; we need to show that their composition is also a lawful
 lifting.
 To verify the identity law of lifting, apply 
\begin_inset Formula $\text{lift}_{R}$
\end_inset

 to an identity function 
\begin_inset Formula $\text{id}:M\leadsto M$
\end_inset

,
\begin_inset Formula 
\begin{align*}
 & \text{lift}_{R}\left(\text{id}^{:M\leadsto M}\right)=\text{lift}_{P}\gunderline{\left(\text{lift}_{Q}\text{id}^{:M\leadsto M}\right)}\\
\text{identity law for }\text{lift}_{Q}:\quad & =\text{lift}_{P}\big(\text{id}^{:T_{Q}^{M}\leadsto T_{Q}^{M}}\big)\\
\text{identity law for }\text{lift}_{P}:\quad & =\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law of lifting, apply 
\begin_inset Formula $\text{lift}_{R}$
\end_inset

 to a composition of two monad morphisms 
\begin_inset Formula $\phi:L\leadsto M$
\end_inset

 and 
\begin_inset Formula $\chi:M\leadsto N$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{lift}_{R}\left(\phi\bef\chi\right) & =\text{lift}_{P}\gunderline{\left(\text{lift}_{Q}\left(\phi\bef\chi\right)\right)}\\
\text{composition law for }\text{lift}_{Q}:\quad & =\gunderline{\text{lift}_{P}}\left(\text{lift}_{Q}\phi\bef\text{lift}_{Q}\chi\right)\\
\text{composition law for }\text{lift}_{P}:\quad & =\gunderline{\text{lift}_{P}\left(\text{lift}_{Q}\phi\right)}\bef\gunderline{\text{lift}_{P}\left(\text{lift}_{Q}\phi\right)}\\
\text{definition of }\text{lift}_{R}:\quad & =\text{lift}_{R}\phi\bef\text{lift}_{R}\chi\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Base runner law
\end_layout

\begin_layout Standard
We need to show that for any monad morphism 
\begin_inset Formula $\theta:T_{P}^{Q}\leadsto\text{Id}$
\end_inset

 and for any monad 
\begin_inset Formula $M$
\end_inset

, there exists a monad morphism 
\begin_inset Formula $\text{brun}_{R}\theta:T_{P}^{T_{Q}^{M}}\leadsto M$
\end_inset

.
 To define this morphism for a given 
\begin_inset Formula $\theta$
\end_inset

, we clearly need to use the base runners for 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

.
 The base runner for 
\begin_inset Formula $T_{Q}$
\end_inset

 has the type signature
\begin_inset Formula 
\[
\text{brun}_{Q}:\left(Q\leadsto\text{Id}\right)\rightarrow T_{Q}^{M}\leadsto M\quad.
\]

\end_inset

We can apply the base runner for 
\begin_inset Formula $T_{P}$
\end_inset

 to 
\begin_inset Formula $T_{Q}^{M}$
\end_inset

 as the foreign monad,
\begin_inset Formula 
\[
\text{brun}_{P}:\left(P\leadsto\text{Id}\right)\rightarrow T_{P}^{T_{Q}^{M}}\leadsto T_{Q}^{M}\quad.
\]

\end_inset

It is now clear that we could obtain a monad morphism 
\begin_inset Formula $T_{P}^{T_{Q}^{M}}\leadsto M$
\end_inset

 if we had some monad morphisms 
\begin_inset Formula $\phi:P\leadsto\text{Id}$
\end_inset

 and 
\begin_inset Formula $\chi:Q\leadsto\text{Id}$
\end_inset

,
\begin_inset Formula 
\[
\text{brun}_{P}\phi\bef\text{brun}_{Q}\chi:T_{P}^{T_{Q}^{M}}\leadsto M\quad.
\]

\end_inset

However, we are only given a single monad morphism 
\begin_inset Formula $\theta:T_{P}^{Q}\leadsto\text{Id}$
\end_inset

.
 How can we compute 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

 out of 
\begin_inset Formula $\theta$
\end_inset

? We can use the liftings 
\begin_inset Formula $\text{blift}_{P}:P\leadsto T_{P}^{Q}$
\end_inset

 and 
\begin_inset Formula $\text{lift}_{P}:Q\leadsto T_{P}^{Q}$
\end_inset

, which are both monad morphisms, and compose them with 
\begin_inset Formula $\theta$
\end_inset

:
\begin_inset Formula 
\[
\left(\text{blift}_{P}\bef\theta\right):P\leadsto\text{Id}\quad;\quad\quad\left(\text{lift}_{P}\bef\theta\right):Q\leadsto\text{Id}\quad.
\]

\end_inset

So we can define the monad morphism 
\begin_inset Formula $\text{brun}_{R}\theta$
\end_inset

 as
\begin_inset Formula 
\begin{align*}
\text{brun}_{R}\theta & :T_{P}^{T_{Q}^{M}}\leadsto M\quad,\\
\text{brun}_{R}\theta & \triangleq\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)\bef\text{brun}_{Q}\left(\text{lift}_{P}\bef\theta\right)\quad.
\end{align*}

\end_inset

Since we have defined 
\begin_inset Formula $\text{brun}_{R}\theta$
\end_inset

 as a composition of monad morphisms, 
\begin_inset Formula $\text{brun}_{R}\theta$
\end_inset

 is a monad morphism by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
To verify the non-degeneracy law of the base runner, 
\begin_inset Formula $\text{lift}_{R}\bef\text{brun}_{R}\theta=\text{id}$
\end_inset

, we need to use the non-degeneracy laws for the base runners of 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

, which are 
\begin_inset Formula 
\[
\text{lift}_{P}\bef\text{brun}_{P}\chi^{:P\leadsto\text{Id}}=\text{id}\quad,\quad\quad\text{lift}_{Q}\bef\text{brun}_{Q}\psi^{:Q\leadsto\text{Id}}=\text{id}\quad.
\]

\end_inset

Then we can write
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{lift}_{R}}\bef\gunderline{\text{brun}_{R}\theta}\\
\text{expand definitions}:\quad & =\text{lift}_{Q}\bef\gunderline{\text{lift}_{P}\bef\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)}\bef\text{brun}_{Q}\left(\text{lift}_{P}\bef\theta\right)\\
\text{non-degeneracy for }\text{brun}_{P}:\quad & =\gunderline{\text{lift}_{Q}\bef\text{brun}_{Q}\left(\text{lift}_{P}\bef\theta\right)}\\
\text{non-degeneracy for }\text{brun}_{Q}:\quad & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Stacking any number of monads
\begin_inset CommandInset label
LatexCommand label
name "subsec:Stacking-any-number-of-monads"

\end_inset


\end_layout

\begin_layout Standard
The monad transformer for 
\begin_inset Formula $T_{P}^{Q}$
\end_inset

 can be applied to another monad 
\begin_inset Formula $K$
\end_inset

; the result is the transformed monad
\begin_inset Formula 
\[
S^{A}\triangleq T_{P}^{T_{Q}^{K},A}.
\]

\end_inset

What is the monad transformer for the monad 
\begin_inset Formula $S$
\end_inset

? Assuming that we know the monad transformer 
\begin_inset Formula $T_{K}$
\end_inset

, we could stack the transformers one level higher:
\begin_inset Formula 
\[
T_{S}^{M,A}\triangleq T_{P}^{T_{Q}^{T_{K}^{M}},A}\quad.
\]

\end_inset

This looks like a stack of four monads 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $K$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

.
 Note that the type parameter 
\begin_inset Formula $A$
\end_inset

 is used as 
\begin_inset Formula $T_{P}^{(...),A}$
\end_inset

, that is, it belongs to the 
\emph on
outer
\emph default
 transformer 
\begin_inset Formula $T_{P}$
\end_inset

.
\end_layout

\begin_layout Standard
We can now define a transformer stack for any number of monads 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 in a similar way,
\begin_inset Formula 
\begin{equation}
T_{S}^{M,A}\triangleq T_{P}^{T_{Q}^{\iddots^{T_{Z}^{M}}},A}\quad.\label{eq:general-transformer-stack}
\end{equation}

\end_inset

The type parameter 
\begin_inset Formula $A$
\end_inset

 will always remain at the outer transformer level, while the foreign monad
 
\begin_inset Formula $M$
\end_inset

 will be in the innermost nested position.
\end_layout

\begin_layout Standard
It turns out that 
\begin_inset Formula $T_{S}$
\end_inset

 is a lawful monad transformer for 
\emph on
any
\emph default
 number of stacked monads.
 We can prove this by induction on the number of monads.
 In the previous section, we have derived the transformer laws for any 
\emph on
three
\emph default
 stacked monads (two monads 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 within the transformer and one foreign monad 
\begin_inset Formula $M$
\end_inset

).
 Now we need to derive the same laws for a general transformer stack, such
 as that in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:general-transformer-stack"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Let us temporarily denote by 
\begin_inset Formula $J$
\end_inset

 the monad 
\begin_inset Formula 
\[
J\triangleq T_{Q}^{\iddots^{T_{Z}^{\text{Id}}}}\quad,
\]

\end_inset

where we used the identity monad 
\begin_inset Formula $\text{Id}$
\end_inset

 in the place normally taken by a foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The monad 
\begin_inset Formula $J$
\end_inset

 is a shorter transformer stack than 
\begin_inset Formula $S$
\end_inset

, so the inductive assumption tells us that the transformer laws already
 hold for the transformer 
\begin_inset Formula $T_{J}$
\end_inset

 defined as
\begin_inset Formula 
\[
T_{J}^{M}\triangleq T_{Q}^{\iddots^{T_{Z}^{M}}}\quad.
\]

\end_inset

Since both 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{J}$
\end_inset

 are lawful transformers, their stacking composition 
\begin_inset Formula $T_{P}^{T_{J}^{M}}$
\end_inset

 is also a lawful transformer (this was shown in the Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In our notation, 
\begin_inset Formula $T_{S}^{M,A}=T_{P}^{T_{J}^{M},A}$
\end_inset

, and so we have shown that 
\begin_inset Formula $T_{S}^{M,A}$
\end_inset

 is a lawful transformer.
\end_layout

\begin_layout Section
Monad transformers via functor composition: General properties
\begin_inset CommandInset label
LatexCommand label
name "sec:Monad-transformers-that-use-composition"

\end_inset


\end_layout

\begin_layout Standard
We have seen examples of monad transformers that work via functor composition,
 either as composed-inside or as composed-outside.
 The simplest examples are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OptionT
\end_layout

\end_inset

 transformer,
\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A,\quad\quad T_{L}^{M,A}\triangleq M^{L^{A}}=M^{\bbnum 1+A}\quad,
\]

\end_inset

which puts the base monad 
\begin_inset Formula $L$
\end_inset

 
\emph on
inside
\emph default
 the monad 
\begin_inset Formula $M$
\end_inset

, and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

 transformer, 
\begin_inset Formula 
\[
L^{A}\triangleq R\rightarrow A,\quad\quad T_{L}^{M,A}\triangleq L^{M^{A}}=R\rightarrow M^{A}\quad,
\]

\end_inset

which puts the base monad 
\begin_inset Formula $L$
\end_inset

 
\emph on
outside
\emph default
 the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 
\end_layout

\begin_layout Standard
We can prove many properties of both kinds of monad transformers via a single
 derivation if we temporarily drop the distinction between the base monad
 and the foreign monad.
 We simply assume that two different monads, 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, have a functor composition 
\begin_inset Formula $T^{\bullet}\triangleq L^{M^{\bullet}}$
\end_inset

 that also happens to be a monad.
 Since the assumptions on the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are the same, the resulting properties of the composed monad 
\begin_inset Formula $T$
\end_inset

 will apply equally to both kinds of monad transformers.
\end_layout

\begin_layout Standard
To interpret the results, we will assume that 
\begin_inset Formula $L$
\end_inset

 is the base monad for the composed-outside transformers, and that 
\begin_inset Formula $M$
\end_inset

 is the base monad for the composed-inside transformers.
 For instance, we will be able to prove the laws of liftings 
\begin_inset Formula $L\leadsto T$
\end_inset

 and 
\begin_inset Formula $M\leadsto T$
\end_inset

 regardless of the choice of the base monad.
\end_layout

\begin_layout Standard
What properties of monad transformers will 
\emph on
not
\emph default
 be derivable in this way? Monad transformers depend on the structure on
 the base monad, but not on the structure of the foreign monad; the transformer'
s methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 are generic in the foreign monad.
 This is expressed via the monad transformer laws for the runners 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mrun
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

, which we will need to derive separately for each of the two kinds of transform
ers.
\end_layout

\begin_layout Subsection
Motivation for the 
\family typewriter
swap
\family default
 function
\end_layout

\begin_layout Standard
The first task is to show that the composed monad 
\begin_inset Formula $T^{\bullet}\triangleq L^{M^{\bullet}}$
\end_inset

 obeys the monad laws.
 For this, we need to define the methods for the monad 
\begin_inset Formula $T$
\end_inset

, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{pu}_{T}$
\end_inset


\begin_inset Quotes erd
\end_inset

) and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{ftn}_{T}$
\end_inset


\begin_inset Quotes erd
\end_inset

), with the type signatures
\begin_inset Formula 
\[
\text{pu}_{T}:A\rightarrow L^{M^{A}}\quad,\quad\text{ftn}_{T}:L^{M^{L^{M^{A}}}}\rightarrow L^{M^{A}}\quad.
\]

\end_inset

How can we implement these methods? 
\emph on
All we know
\emph default
 about 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 is that they are monads with their own methods 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

, 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

, and 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

.
 We can easily implement 
\begin_inset Formula 
\begin{equation}
\text{pu}_{T}\triangleq\text{pu}_{M}\bef\text{pu}_{L}\quad.\label{eq:def-of-pure-T}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}A\ar[r]\sp(0.5){\text{pu}_{M}}\ar[rd]\sb(0.45){\text{pu}_{T}\triangleq} & M^{A}\ar[d]\sp(0.45){\text{pu}_{L}}\\
 & L^{M^{A}}
}
\]

\end_inset

It remains to implement 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 In the type 
\begin_inset Formula $L^{M^{L^{M^{A}}}}$
\end_inset

, we have two layers of the functor 
\begin_inset Formula $L$
\end_inset

 and two layers of the functor 
\begin_inset Formula $M$
\end_inset

.
 We could use the available method 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 to flatten the two layers of 
\begin_inset Formula $L$
\end_inset

 if we could 
\emph on
somehow
\emph default
 bring these nested layers together.
 However, these layers are separated by a layer of the functor 
\begin_inset Formula $M$
\end_inset

.
 To show this layered structure in a more visual way, let us employ another
 notation for the functor composition, 
\begin_inset Formula 
\[
L\circ M\triangleq L^{M^{\bullet}}\quad.
\]

\end_inset

In this notation, the type signature for 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 is written as
\begin_inset Formula 
\[
\text{ftn}_{T}:L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

If we had 
\begin_inset Formula $L\circ L\circ M\circ M$
\end_inset

 here, we would have applied 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 and flattened the two layers of the functor 
\begin_inset Formula $L$
\end_inset

.
 Then we would have flattened the remaining two layers of the functor 
\begin_inset Formula $M$
\end_inset

.
 How can we achieve this? The trick is to 
\emph on
assume
\emph default
 that we have a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{sw}$
\end_inset


\begin_inset Quotes erd
\end_inset

), which can interchange the order of the layers.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is
\begin_inset Formula 
\[
\text{sw}:M\circ L\leadsto L\circ M\quad,
\]

\end_inset

which is equivalently written in a more verbose notation as
\begin_inset Formula 
\[
\text{sw}:M^{L^{A}}\rightarrow L^{M^{A}}\quad.
\]

\end_inset

If this operation were 
\emph on
somehow
\emph default
 defined for the two monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, we could implement 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 by first swapping the order of the inner layers 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 as 
\begin_inset Formula 
\[
L\circ M\circ L\circ M\leadsto L\circ L\circ M\circ M
\]

\end_inset

and then applying the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 methods of the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 The resulting code for the function 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and the corresponding type diagram are
\begin_inset Formula 
\begin{equation}
\text{ftn}_{T}\triangleq\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:define-flatten-via-swap}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}L^{M^{L^{M^{A}}}}\ar[r]\sp(0.5){\text{sw}^{\uparrow L}}\ar[rrd]\sb(0.5){\text{ftn}_{T}\triangleq} & L^{L^{M^{M^{A}}}}\ar[r]\sp(0.5){\text{ftn}_{L}} & L^{M^{M^{A}}}\ar[d]\sp(0.5){\text{ftn}_{M}^{\uparrow L}}\\
 &  & L^{M^{A}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
It turns out that in 
\emph on
both
\emph default
 cases (the composed-inside and the composed-outside transformers), the
 new monad's 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 method can be defined through the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation.
 For the two kinds of transformers, the type signatures of these functions
 are
\begin_inset Formula 
\begin{align*}
\text{composed-inside}:\quad\text{ftn}_{T}:M^{L^{M^{L^{A}}}}\rightarrow M^{L^{A}}\quad, & \quad\text{sw}:L^{M^{A}}\rightarrow M^{L^{A}}\quad,\\
\text{composed-outside}:\quad\text{ftn}_{T}:L^{M^{L^{M^{A}}}}\rightarrow L^{M^{A}}\quad, & \quad\text{sw}:M^{L^{A}}\rightarrow L^{M^{A}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
The difference between the operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a certain similarity between the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation introduced here and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 operation introduced in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:9-Traversable-functors-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for traversable functors.
 Indeed, the type signature of the sequence operation is 
\begin_inset Formula 
\[
\text{seq}:L^{F^{A}}\rightarrow F^{L^{A}}\quad,
\]

\end_inset

where 
\begin_inset Formula $F$
\end_inset

 is an arbitrary applicative functor (which could be 
\begin_inset Formula $M$
\end_inset

, since monads are applicative functors) and 
\begin_inset Formula $L$
\end_inset

 is a traversable functor.
 However, the similarity stops here.
 The laws required for the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation to yield a monad 
\begin_inset Formula $T$
\end_inset

 are different from the laws of traversable functors.
 In particular, if we wish 
\begin_inset Formula $M^{L^{\bullet}}$
\end_inset

 to be a monad, it is insufficient to require the monad 
\begin_inset Formula $L$
\end_inset

 to be a traversable functor.
 A simple counterexample is found with 
\begin_inset Formula $L^{A}\triangleq A\times A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq1+A$
\end_inset

.
 Both 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are traversable (since they are polynomial functors); but their composition
 
\begin_inset Formula $Q^{A}\triangleq1+A\times A$
\end_inset

 is not a monad.
\end_layout

\begin_layout Standard
Another difference between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 is that the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation needs to be generic in the foreign monad, which may be either
 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 according to the type of the monad transformer; whereas 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 is always generic in the applicative functor 
\begin_inset Formula $F$
\end_inset

.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout

\emph on
This is actually confusing! Let's not do this and always write 
\begin_inset Formula $\text{sw}_{L}^{M}:M^{L^{A}}\rightarrow L^{M^{A}}$
\end_inset


\end_layout

\begin_layout Plain Layout
To denote more clearly the monad with respect to which 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is generic, we may write
\begin_inset Formula 
\begin{align*}
\text{sw}_{L}^{M}:L^{M^{A}}\rightarrow M^{L^{A}}\quad & \text{for the composed-inside transformers,}\\
\text{sw}_{L}^{M}:M^{L^{A}}\rightarrow L^{M^{A}}\quad & \text{for the composed-outside transformers.}
\end{align*}

\end_inset

The superscript 
\begin_inset Formula $M$
\end_inset

 in 
\begin_inset Formula $\text{sw}_{L}^{M}$
\end_inset

 shows that 
\begin_inset Formula $M$
\end_inset

 is a 
\emph on
type parameter
\emph default
 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

; that is, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is generic in the monad 
\begin_inset Formula $M$
\end_inset

.
 The subscript 
\begin_inset Formula $L$
\end_inset

 in 
\begin_inset Formula $\text{sw}_{L}^{M}$
\end_inset

 shows that the implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 may need to use completely different code for different monads 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To avoid confusion, I use the name 
\begin_inset Quotes eld
\end_inset

swap
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

sequence
\begin_inset Quotes erd
\end_inset

 for the function 
\begin_inset Formula $\text{sw}_{L,M}:M^{L^{\bullet}}\leadsto L^{M^{\bullet}}$
\end_inset

 in the context of monad transformers.
 Let us now find out what laws are required for the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation.
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 operation was used in a 
\begin_inset CommandInset href
LatexCommand href
name "1993 paper"
target "http://web.cecs.pdx.edu/~mpj/pubs/composing.html"
literal "false"

\end_inset

 
\begin_inset Quotes eld
\end_inset

Composing monads
\begin_inset Quotes erd
\end_inset

 by M.
\begin_inset space ~
\end_inset

P.
\begin_inset space ~
\end_inset

Jones and L.
\begin_inset space ~
\end_inset

Duponcheel.
 They studied various ways of composing monads and also gave some arguments
 to show that no generic transformer could compose all monads 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

.
 The impossibility of a generic monad composition is demonstrated by the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad that, as I show in this chapter, does not compose with arbitrary
 other monads 
\begin_inset Formula $M$
\end_inset

 – either from inside or from outside.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Deriving the necessary laws for 
\family typewriter
swap
\end_layout

\begin_layout Standard
The first law is that 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 must be a natural transformation.
 Since 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 has only one type parameter, there is one naturality law: for any function
 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

, 
\begin_inset Formula 
\begin{equation}
f^{\uparrow L\uparrow M}\bef\text{sw}=\text{sw}\bef f^{\uparrow M\uparrow L}\quad.\label{eq:swap-law-0-naturality}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){f^{\uparrow L\uparrow M}}\ar[d]\sb(0.45){\text{sw}} & M^{L^{B}}\ar[d]\sp(0.45){\text{sw}}\\
L^{M^{A}}\ar[r]\sp(0.5){f^{\uparrow M\uparrow L}} & L^{M^{B}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
To derive further laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

, consider the requirement that the transformed monad 
\begin_inset Formula $T$
\end_inset

 should satisfy the monad laws:
\begin_inset Formula 
\begin{align*}
\text{pu}_{T}\bef\text{ftn}_{T}=\text{id}\quad, & \quad\quad\text{pu}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\text{id}\quad,\\
\text{ftn}_{T}^{\uparrow T}\bef\text{ftn}_{T} & =\text{ftn}_{T}\bef\text{ftn}_{T}\quad.
\end{align*}

\end_inset

Additionally, 
\begin_inset Formula $T$
\end_inset

 must satisfy the laws of a monad transformer.
 We will now discover the laws for 
\family typewriter
swap
\family default
 that make the laws for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 hold automatically, as long as 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 is derived from 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
We substitute Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the left identity law for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and simplify:
\begin_inset Formula 
\begin{align}
\text{id} & =\text{pu}_{T}\bef\gunderline{\text{ftn}_{T}}\nonumber \\
\text{replace }\text{ftn}_{T}\text{ using Eq.~(\ref{eq:define-flatten-via-swap})}:\quad & =\text{pu}_{T}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{replace }\text{pu}_{T}\text{ using Eq.~(\ref{eq:def-of-pure-T})}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{naturality of }\text{pu}_{L}:\quad & =\text{pu}_{M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{left identity law for }L:\quad & =\text{pu}_{M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:left-identity-ftn-T}
\end{align}

\end_inset

How could the last expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-identity-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) be equal to 
\begin_inset Formula $\text{id}$
\end_inset

? We know nothing about the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 methods of the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, except that these methods satisfy their monad laws.
 We could satisfy the law in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-identity-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) if we somehow reduce that expression to
\begin_inset Formula 
\[
\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=\left(\text{pu}_{M}\bef\text{ftn}_{M}\right)^{\uparrow L}=\text{id}\quad.
\]

\end_inset

This will be possible only if we are able to interchange the order of function
 compositions with 
\begin_inset Formula $\text{sw}$
\end_inset

 and eliminate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 from the expression.
 So, we must require the 
\begin_inset Quotes eld
\end_inset

outer-identity law
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

,
\begin_inset Formula 
\begin{equation}
\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow L}\quad.\label{eq:swap-law-1-M-identity}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc}L^{A}\ar[r]\sp(0.5){\text{pu}_{M}}\ar[rd]\sb(0.4){\text{pu}_{M}^{\uparrow L}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
 & L^{M^{A}}
}
\]

\end_inset

Intuitively, this law says that a pure layer of the monad 
\begin_inset Formula $M$
\end_inset

 remains pure after interchanging the order of layers with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
With this law, we can finish the derivation in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-identity-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{outer-identity law for }\text{sw}:\quad & =\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{functor composition law for }L:\quad & =\left(\text{pu}_{M}\bef\text{ftn}_{M}\right)^{\uparrow L}\\
\text{left identity law for }M:\quad & =\text{id}^{\uparrow L}\\
\text{functor identity law for }L:\quad & =\text{id}\quad.
\end{align*}

\end_inset

So, the 
\begin_inset Formula $M$
\end_inset

-identity law for 
\family typewriter
swap
\family default
 entails the left identity law for 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
In the same way, we motivate the 
\begin_inset Quotes eld
\end_inset

inner-identity
\begin_inset Quotes erd
\end_inset

 law for 
\family typewriter
swap
\family default
,
\begin_inset Formula 
\begin{equation}
\text{pu}_{L}^{\uparrow M}\bef\text{sw}=\text{pu}_{L}\quad.\label{eq:swap-law-2-L-identity}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc}M^{A}\ar[r]\sp(0.5){\text{pu}_{L}^{\uparrow M}}\ar[rd]\sb(0.45){\text{pu}_{L}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
 & L^{M^{A}}
}
\]

\end_inset

This law expresses the idea that a pure layer of the functor 
\begin_inset Formula $L$
\end_inset

 remains pure after swapping the order of layers.
\end_layout

\begin_layout Standard
Assuming this law, we can derive the right identity law for 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{T}^{\uparrow T}\bef\text{ftn}_{T}\\
\left(\text{by definition, }f^{\uparrow T}\triangleq f^{\uparrow M\uparrow L}\right):\quad & =\left(\text{pu}_{T}\right)^{\uparrow M\uparrow L}\bef\text{ftn}_{T}\\
\text{definitions of }\text{pu}_{T}\text{ and }\text{ftn}_{T}:\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{inner-identity law for }\text{sw},\text{ under }^{\uparrow L}:\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{right identity law for }L:\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=\gunderline{\left(\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}\right)}^{\uparrow L}\\
\text{right identity law for }M:\quad & =\text{id}^{\uparrow L}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Deriving the monad associativity law for 
\begin_inset Formula $T$
\end_inset

,
\begin_inset Formula 
\[
\text{ftn}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\text{ftn}_{T}\bef\text{ftn}_{T}\quad,
\]

\end_inset

turns out to require 
\emph on
two
\emph default
 further laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 Let us see why.
\end_layout

\begin_layout Standard
Substituting the definition of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 into the associativity law, we get
\begin_inset Formula 
\begin{align}
 & \left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\right)^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
 & \quad=\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:t-assoc-law-expanded}
\end{align}

\end_inset

The only hope of proving this law is being able to interchange 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 as well as 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

 with 
\begin_inset Formula $\text{sw}$
\end_inset

.
 In other words, the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 function should be in some way adapted to the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 methods of both monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
Let us look for such interchange laws.
 One possibility is to have a law involving 
\begin_inset Formula $\text{ftn}_{M}\bef\text{sw}$
\end_inset

, which is a function of type 
\begin_inset Formula $M^{M^{L^{A}}}\rightarrow L^{M^{A}}$
\end_inset

 or, in another notation, 
\begin_inset Formula $M\circ M\circ L\leadsto L\circ M$
\end_inset

.
 This function first flattens the two adjacent layers of 
\begin_inset Formula $M$
\end_inset

, obtaining 
\begin_inset Formula $M\circ L$
\end_inset

, and then swaps the two remaining layers, moving the 
\begin_inset Formula $L$
\end_inset

 layer outside.
 Let us think about what law could exist for this kind of transformation.
 It is plausible that we may obtain the same result if we first swap the
 layers twice, so that the 
\begin_inset Formula $L$
\end_inset

 layer moves to the outside, obtaining 
\begin_inset Formula $L\circ M\circ M$
\end_inset

, and then flatten the two inner 
\begin_inset Formula $M$
\end_inset

 layers.
 Writing this assumption in code, we obtain the 
\begin_inset Quotes eld
\end_inset

outer-interchange
\begin_inset Quotes erd
\end_inset

 law
\begin_inset Formula 
\begin{equation}
\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:swap-law-3-M-interchange}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc} & M^{M^{L^{A}}}\ar[r]\sp(0.5){\text{ftn}_{M}}\ar[ld]\sb(0.45){\text{sw}^{\uparrow M}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
M^{L^{M^{A}}}\ar[r]\sb(0.5){\text{sw}} & L^{M^{M^{A}}}\ar[r]\sb(0.5){\text{ftn}_{M}^{\uparrow L}} & L^{M^{A}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
The analogous 
\begin_inset Quotes eld
\end_inset

inner-interchange
\begin_inset Quotes erd
\end_inset

 law involving two layers of 
\begin_inset Formula $L$
\end_inset

 and a transformation 
\begin_inset Formula $M\circ L\circ L\leadsto L\circ M$
\end_inset

 is written as
\begin_inset Formula 
\begin{equation}
\text{ftn}_{L}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\quad.\label{eq:swap-law-4-L-interchange}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{3pc} & M^{L^{L^{A}}}\ar[r]\sp(0.5){\text{ftn}_{L}^{\uparrow M}}\ar[ld]\sb(0.45){\text{sw}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
L^{M^{L^{A}}}\ar[r]\sb(0.5){\text{sw}^{\uparrow L}} & L^{L^{M^{A}}}\ar[r]\sb(0.5){\text{ftn}_{L}} & L^{M^{A}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
At this point, we have simply written down these two interchange laws, hoping
 that they will help us derive the associativity law for 
\begin_inset Formula $T$
\end_inset

.
 We will now verify that this is indeed so.
\end_layout

\begin_layout Standard
Both sides of the law in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) involve compositions of several 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s.
 The heuristic idea of the proof is to use various laws to move all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s to right of the composition, while moving all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s to the left.
 In this way we will transform both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into a similar form, hoping to prove that they are equal.
\end_layout

\begin_layout Standard
We begin with the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) since it is simpler than the left-hand side, and look for ways of using
 the interchange laws.
 At every step of the calculation, there happens to be only one place where
 some law can be applied:
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{composition for }L:\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\left(\text{ftn}_{M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{outer-interchange for }\text{sw}:\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\left(\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{composition for }L:\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{sw}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\gunderline{\text{ftn}_{M}^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{ftn}_{L}:\quad & =\text{sw}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\left(\text{sw}^{\uparrow M}\bef\text{sw}\right)^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{ftn}_{L}:\quad & =\text{sw}^{\uparrow L}\bef\gunderline{\left(\text{sw}^{\uparrow M}\bef\text{sw}\right)^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

Now all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s are on the left and all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s on the right of the expression.
\end_layout

\begin_layout Standard
Transform the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in the same way as
\begin_inset Formula 
\begin{align*}
 & \left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}}\right)^{\uparrow M\uparrow L}\gunderline{\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{functor composition}:\quad & =\left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\right)^{\uparrow M\uparrow L}\bef\gunderline{\left(\text{ftn}_{M}^{\uparrow L\uparrow M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{sw}:\quad & =\left(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\right)^{\uparrow M\uparrow L}\bef\big(\text{sw}\bef\gunderline{\text{ftn}_{M}^{\uparrow M\uparrow L}}\big)^{\uparrow L}\gunderline{\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{ftn}_{L}:\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{L}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}}\\
\text{associativity of }\text{ftn}_{M}:\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\left(\text{ftn}_{L}^{\uparrow M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{inner-interchange for }\text{sw}:\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\big(\text{sw}\bef\text{sw}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}}\big)^{\uparrow L}\gunderline{\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{associativity of }\text{ftn}_{L}:\quad & =\big(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L}\big)^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

We have again managed to move all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s to the left and all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s to the right of the expression.
 
\end_layout

\begin_layout Standard
Comparing now the two sides of the associativity law, we see that all the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s occur in the same combination: 
\begin_inset Formula $\text{ftn}_{L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}$
\end_inset

.
 It remains to show that 
\begin_inset Formula 
\[
\text{sw}^{\uparrow L}\bef\left(\text{sw}^{\uparrow M}\bef\text{sw}\right)^{\uparrow L\uparrow L}=\big(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L}\big)^{\uparrow L}\quad.
\]

\end_inset

or equivalently
\begin_inset Formula 
\[
\left(\text{sw}\bef\text{sw}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\right)^{\uparrow L}=\big(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L}\big)^{\uparrow L}\quad.
\]

\end_inset

The two sides are equal due to the naturality law of 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
,
\begin_inset Formula 
\[
\text{sw}\bef\text{sw}^{\uparrow M\uparrow L}=\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}.
\]

\end_inset

This completes the proof of the following theorem:
\end_layout

\begin_layout Subsubsection
Theorem 
\begin_inset CommandInset label
LatexCommand label
name "sec:Theorem-swap-laws-to-monad-transformer-first-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If two monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are such that there exists a function
\begin_inset Formula 
\[
\text{sw}_{L,M}:M^{L^{A}}\rightarrow L^{M^{A}}
\]

\end_inset

(called 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

), which is a natural transformation satisfying four additional laws:
\begin_inset Formula 
\begin{align*}
\text{outer-identity}:\quad & \text{pu}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{pu}_{L}\quad,\\
\text{inner-identity}:\quad & \text{pu}_{M}\bef\text{sw}_{L,M}=\text{pu}_{M}^{\uparrow L}\quad,\\
\text{outer-interchange}:\quad & \text{ftn}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{sw}_{L,M}\bef\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\quad,\\
\text{inner-interchange}:\quad & \text{ftn}_{M}\bef\text{sw}_{L,M}=\text{sw}_{L,M}^{\uparrow M}\bef\text{sw}_{L,M}\bef\text{ftn}_{M}^{\uparrow L}\quad,
\end{align*}

\end_inset

then the functor composition
\begin_inset Formula 
\[
T^{A}\triangleq L^{M^{A}}
\]

\end_inset

is a monad with the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 defined by
\begin_inset Formula 
\begin{align}
\text{pu}_{T} & \triangleq\text{pu}_{M}\bef\text{pu}_{L}\quad,\label{eq:def-pure-T-via-pure-L-and-pure-M}\\
\text{ftn}_{T} & \triangleq\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:def-flatten-T-via-sw-and-flatten-L-M}
\end{align}

\end_inset


\end_layout

\begin_layout Subsection
Intuition behind the laws of 
\family typewriter
swap
\end_layout

\begin_layout Standard
The interchange laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 guarantee that any functor composition built up from 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, e.g.
\begin_inset space ~
\end_inset

like this,
\begin_inset Formula 
\[
M\circ M\circ L\circ M\circ L\circ L\circ M\circ M\circ L\quad,
\]

\end_inset

can be simplified to a value of type 
\begin_inset Formula $T^{A}=L^{M^{A}}$
\end_inset

 by flattening the layers using 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

, or 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

, or by interchanging the layers with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 We may apply flattening or interchange in any order, and we will always
 get the same final value of type 
\begin_inset Formula $T^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
In other words, the monadic effects of the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 can be arbitrarily interleaved, swapped, and flattened in any order, with
 no change to the final results.
 The programmer is free to refactor a monadic program, say, by first computing
 some 
\begin_inset Formula $L$
\end_inset

-effects in a separate functor block of 
\begin_inset Formula $L$
\end_inset

-
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

s and only then combining the result with the rest of the computation in
 the monad 
\begin_inset Formula $T$
\end_inset

.
 Regardless of the refactoring, the monad 
\begin_inset Formula $T$
\end_inset

 computes all the effects correctly.
 This is what programmers would expect of the monad 
\begin_inset Formula $T$
\end_inset

, if it is to be regarded as a useful monad transformer.
\end_layout

\begin_layout Standard
We will now derive the properties of the monad 
\begin_inset Formula $T$
\end_inset

 that follow from the interchange laws.
 We will find that it is easier to formulate these laws in terms of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 than in terms of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 In practice, all known examples of compositional monad transformers (the
 
\begin_inset Quotes eld
\end_inset

linear
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

 monads) are defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Deriving 
\family typewriter
swap
\family default
 from 
\family typewriter
flatten
\begin_inset CommandInset label
LatexCommand label
name "subsec:Deriving-swap-from-flatten"

\end_inset


\end_layout

\begin_layout Standard
We have shown that the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 method of the monad 
\begin_inset Formula $T^{\bullet}=L^{M^{\bullet}}$
\end_inset

 can be defined via the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 method.
 However, we have seen examples of some composable monads (such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

) where we already know the definitions of the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 method for the composed monad 
\begin_inset Formula $T$
\end_inset

.
 Does a suitable 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 function exist for these examples? In other words, if a 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 function for the monad 
\begin_inset Formula $T=L\circ M$
\end_inset

 is already known, can we establish whether a 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 function exists such that the
\emph on
 given
\emph default
 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 function is expressed via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

)? 
\end_layout

\begin_layout Standard
To answer this question, let us look at the type signature of 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 for 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{T}:L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

This type signature is different from 
\begin_inset Formula $\text{sw}:M\circ L\leadsto L\circ M$
\end_inset

 only because the argument of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 has extra layers of the functors 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 that are placed outside the 
\begin_inset Formula $M\circ L$
\end_inset

 composition.
 We can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 methods of 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 to add these extra layers to a value of type 
\begin_inset Formula $M\circ L$
\end_inset

, without modifying any monadic effects present in 
\begin_inset Formula $M\circ L$
\end_inset

.
 This will allow us to apply 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and to obtain a value of type 
\begin_inset Formula $L\circ M$
\end_inset

.
 The resulting code for the function 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and the corresponding type diagram are
\begin_inset Formula 
\begin{equation}
\text{sw}=\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\text{ftn}_{T}\quad.\label{eq:define-swap-via-flatten}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{4pc}M^{L^{A}}\ar[r]\sp(0.5){\text{pu}_{M}^{\uparrow L\uparrow M}}\ar[rrd]\sb(0.5){\text{sw}\triangleq} & M^{L^{M^{A}}}\ar[r]\sp(0.5){\text{pu}_{L}} & L^{M^{L^{M^{A}}}}\ar[d]\sp(0.45){\text{ftn}_{T}}\\
 &  & L^{M^{A}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
We have expressed 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{sw}$
\end_inset

 through each other.
 Are these functions always equivalent? To decide this, we need to answer
 two questions:
\end_layout

\begin_layout Enumerate
If we first define 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) through a given implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 and then substitute that 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

), will we always recover the initially given function 
\begin_inset Formula $\text{sw}$
\end_inset

? (Yes, assuming naturality for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.)
\end_layout

\begin_layout Enumerate
If we first define 
\begin_inset Formula $\text{sw}$
\end_inset

 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) through a given implementation of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and then substitute that 
\begin_inset Formula $\text{sw}$
\end_inset

 into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

), will we always recover the initially given function 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

? (No, not without additional laws for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.)
\end_layout

\begin_layout Standard
To answer the first question, substitute 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\gunderline{\text{ftn}_{T}}\\
\text{substitute }\text{ftn}_{T}:\quad & =\text{pu}_{M}^{\uparrow L\uparrow M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{pu}_{L}:\quad & =\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{left identity law for }L:\quad & =\gunderline{\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{sw}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{sw}:\quad & =\text{sw}\bef\gunderline{\text{pu}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}}\\
\text{functor composition for }L:\quad & =\text{sw}\bef\gunderline{\left(\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}\right)}^{\uparrow L}\\
\text{right identity law for }M:\quad & =\text{sw}\quad.
\end{align*}

\end_inset

So, indeed, we always recover the initial 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
To answer the second question, substitute 
\begin_inset Formula $\text{sw}$
\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
 & \gunderline{\text{sw}}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{substitute }\text{sw}:\quad & =\gunderline{\left(\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\text{ftn}_{T}\right)^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{functor composition }:\quad & =\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:deriv-sw-from-ftn-a}
\end{align}

\end_inset

At this point, we are stuck: we can find no laws to transform the last expressio
n.
 Without assuming additional laws, it 
\emph on
does not follow
\emph default
 that the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deriv-sw-from-ftn-a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equal to 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 Let us now derive those additional laws.
 
\end_layout

\begin_layout Standard
The only sub-expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deriv-sw-from-ftn-a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that we could possibly transform is the composition 
\begin_inset Formula $\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}$
\end_inset

.
 So, we need to assume a law involving the expression 
\begin_inset Formula 
\[
\big(\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\big):L\circ L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

This function flattens the two layers of 
\begin_inset Formula $\left(L\circ M\right)$
\end_inset

 and then flattens the remaining two layers of 
\begin_inset Formula $L$
\end_inset

.
 Another function with the same type signature could first flatten the two
 
\emph on
outside
\emph default
 layers of 
\begin_inset Formula $L$
\end_inset

 and then flatten the two remaining layers of 
\begin_inset Formula $\left(L\circ M\right)$
\end_inset

:
\begin_inset Formula 
\[
\big(\text{ftn}_{L}\bef\text{ftn}_{T}\big):L\circ L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

So we conjecture that a possibly useful additional law for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 is 
\begin_inset Formula 
\[
\text{ftn}_{L}\bef\text{ftn}_{T}=\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}L^{L^{M^{L^{M^{A}}}}}\ar[r]\sp(0.5){\text{ftn}_{L}}\ar[d]\sb(0.5){\text{ftn}_{T}^{\uparrow L}} & L^{M^{L^{M^{A}}}}\ar[d]\sp(0.5){\text{ftn}_{T}}\\
L^{L^{M^{A}}}\ar[r]\sb(0.5){\text{ftn}_{L}} & L^{M^{A}}
}
\]

\end_inset

This law expresses a kind of 
\begin_inset Quotes eld
\end_inset

compatibility
\begin_inset Quotes erd
\end_inset

 between the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
With this law, the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deriv-sw-from-ftn-a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{right identity law of }L:\quad & =\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

Again, we cannot proceed unless we assume a law involving the expression
\begin_inset Formula 
\[
\big(\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\big):L\circ M\circ L\circ M\circ M\leadsto L\circ M\quad.
\]

\end_inset

This function first flattens the two layers of 
\begin_inset Formula $\left(L\circ M\right)$
\end_inset

 and then flattens the remaining two layers of 
\begin_inset Formula $M$
\end_inset

.
 An alternative order of flattenings is to first flatten the 
\emph on
innermost
\emph default
 two layers of 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Formula 
\[
\big(\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\big):L\circ M\circ L\circ M\circ M\leadsto L\circ M\quad.
\]

\end_inset

The second conjectured law is therefore
\begin_inset Formula 
\[
\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}L^{M^{L^{M^{M^{A}}}}}\ar[r]\sp(0.5){\text{ftn}_{T}}\ar[d]\sb(0.5){\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}} & L^{M^{M^{A}}}\ar[d]\sp(0.5){\text{ftn}_{M}^{\uparrow L}}\\
L^{M^{L^{M^{A}}}}\ar[r]\sb(0.5){\text{ftn}_{T}} & L^{M^{A}}
}
\]

\end_inset

This law expresses a kind of 
\begin_inset Quotes eld
\end_inset

compatibility
\begin_inset Quotes erd
\end_inset

 between the monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
Assuming this law, we can finally complete the derivation:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{substitute the second conjecture}:\quad & =\gunderline{\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}}\bef\text{ftn}_{T}\\
\text{functor composition }:\quad & =\gunderline{\left(\text{pu}_{M}\bef\text{ftn}_{M}\right)}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\\
\text{left identity law of }M:\quad & =\text{ftn}_{T}\quad.
\end{align*}

\end_inset

We recovered the initial 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 by assuming two additional laws.
\end_layout

\begin_layout Standard
It turns out that these additional laws will always hold when 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-1-interchange-laws-for-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
It may be hard to verify directly the monad laws for 
\begin_inset Formula $L\circ M$
\end_inset

 because of deeply nested type constructors, e.g.
\begin_inset space ~
\end_inset


\begin_inset Formula $L\circ M\circ L\circ M\circ L\circ M$
\end_inset

.
 If the monad 
\begin_inset Formula $L\circ M$
\end_inset

 has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method (in practice, this is always the case), it is simpler to verify
 the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 and then obtain the monad laws of 
\begin_inset Formula $L\circ M$
\end_inset

 via Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-1-interchange-laws-for-ftn-T"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-1-interchange-laws-for-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
Assuming that
\end_layout

\begin_layout Itemize
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are monads,
\end_layout

\begin_layout Itemize
the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is a natural transformation 
\begin_inset Formula $M\circ L\leadsto L\circ M$
\end_inset

,
\end_layout

\begin_layout Itemize
the method 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 of the monad 
\begin_inset Formula $T=L\circ M$
\end_inset

 is 
\emph on
defined
\emph default
 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

),
\end_layout

\begin_layout Standard
show that the two interchange laws must hold for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{inner-interchange }:\quad & \text{ftn}_{L}\bef\text{ftn}_{T}=\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\quad,\\
\text{outer-interchange }:\quad & \text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-2-prove-compat-laws-for-T-from-swap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-2-prove-compat-laws-for-T-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
With the same assumptions as Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-1-interchange-laws-for-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and additionally assuming the inner and outer identity laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (see Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), show that the monad 
\begin_inset Formula $T^{\bullet}\triangleq L^{M^{\bullet}}$
\end_inset

 satisfies two 
\begin_inset Quotes eld
\end_inset

pure compatibility
\begin_inset Quotes erd
\end_inset

 laws,
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
pure
\family default
 compatibility laws
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{inner-pure-compatibility}:\quad & \text{ftn}_{L}=\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{T}\quad:L^{L^{M^{A}}}\rightarrow L^{M^{A}}\quad,\\
\text{outer-pure-compatibility}:\quad & \text{ftn}_{M}^{\uparrow L}=\text{pu}_{L}^{\uparrow T}\bef\text{ftn}_{T}\quad:L^{M^{M^{A}}}\rightarrow L^{M^{A}}\quad,
\end{align*}

\end_inset

or, expressed equivalently through the 
\begin_inset Formula $\text{flm}$
\end_inset

 methods instead of 
\begin_inset Formula $\text{ftn}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{flm}_{L}f^{:A\rightarrow L^{M^{B}}} & =\text{pure}_{M}^{\uparrow L}\bef\text{flm}_{T}f^{:A\rightarrow L^{M^{B}}}\quad,\\
\big(\text{flm}_{M}f^{:A\rightarrow M^{B}}\big)^{\uparrow L} & =\text{pure}_{L}^{\uparrow T}\bef\text{flm}_{T}(f^{\uparrow L})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Monad transformer identity law: Proofs
\end_layout

\begin_layout Standard
The identity law requires that 
\begin_inset Formula $T_{L}^{M}\cong L$
\end_inset

 if 
\begin_inset Formula $M=\text{Id}$
\end_inset

.
 We will now prove this law assuming that 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 are defined by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and that the two identity laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 hold (see Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

),
\begin_inset Formula 
\begin{align*}
\text{outer-identity}:\quad & \text{pu}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{pu}_{L}\quad,\\
\text{inner-identity}:\quad & \text{pu}_{M}\bef\text{sw}_{L,M}=\text{pu}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

Note that 
\begin_inset Formula $M$
\end_inset

 is the foreign monad for composed-outside transformers, 
\begin_inset Formula $T_{L}^{M}=L\circ M$
\end_inset

.
 Setting 
\begin_inset Formula $M=\text{Id}$
\end_inset

 in the inner-identity law, we obtain 
\begin_inset Formula 
\[
\text{pu}_{\text{Id}}\bef\text{sw}_{L,\text{Id}}=\text{pu}_{\text{Id}}^{\uparrow L}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{pu}_{\text{Id}}=\text{id}$
\end_inset

, it follows that 
\begin_inset Formula $\text{sw}_{L,\text{Id}}=\text{id}$
\end_inset

.
 In a similar way, for composed-inside transformers 
\begin_inset Formula $T_{L}^{M}=M\circ L$
\end_inset

 we need to switch the roles of 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 in the same computation and substitute 
\begin_inset Formula $L=\text{id}$
\end_inset

 into the outer-identity law,
\begin_inset Formula 
\[
\text{pu}_{\text{Id}}^{\uparrow M}\bef\text{sw}_{\text{Id},M}=\text{pu}_{\text{Id}}\quad.
\]

\end_inset

 We obtain 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\text{sw}_{L,\text{Id}}:L^{A}\rightarrow L^{A}$
\end_inset

 is a natural transformation for a monad 
\begin_inset Formula $L$
\end_inset

, so one may heuristically expect 
\begin_inset Formula $\text{sw}_{L,\text{Id}}$
\end_inset

 to be equal to the identity map (the only natural transformation 
\begin_inset Formula $L^{A}\rightarrow L^{A}$
\end_inset

 that exists for all monads 
\begin_inset Formula $L$
\end_inset

).
 Similarly, one may expect that 
\begin_inset Formula $\text{sw}_{\text{Id},M}:M^{A}\rightarrow M^{A}=\text{id}$
\end_inset

 since it is a natural transformation.
 But these are only heuristic expectations, while we have just shown that
 the properties 
\begin_inset Formula $\text{sw}_{L,\text{Id}}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

 follow from the previously established laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 without any new assumptions.
 These properties will be needed in the proofs below.
 
\end_layout

\begin_layout Standard
To demonstrate a monadic isomorphism between the monads 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

, we will consider separately the cases of composed-inside and composed-outside
 transformers.
\end_layout

\begin_layout Standard
For composed-inside transformers 
\begin_inset Formula $T_{L}^{M}=M\circ L$
\end_inset

, we set 
\begin_inset Formula $M=\text{Id}$
\end_inset

 and find that the monad 
\begin_inset Formula $T_{L}^{\text{Id}}=\text{Id}\circ L=L$
\end_inset

 is the same type constructor as 
\begin_inset Formula $L$
\end_inset

.
 So, the isomorphism maps between 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are simply the identity maps in both directions, 
\begin_inset Formula $\text{id}:T_{L}^{\text{Id},A}\rightarrow L^{A}$
\end_inset

 and 
\begin_inset Formula $\text{id}:L^{A}\rightarrow T_{L}^{\text{Id},A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
For composed-outside transformers 
\begin_inset Formula $T_{L}^{M}=L\circ M$
\end_inset

, the monad 
\begin_inset Formula $T_{L}^{\text{Id}}=L\circ\text{Id}=L$
\end_inset

 is again the same type constructor as 
\begin_inset Formula $L$
\end_inset

.
 The isomorphisms between 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are again the identity maps in both directions, 
\begin_inset Formula $\text{id}:T_{L}^{\text{Id},A}\rightarrow L^{A}$
\end_inset

 and 
\begin_inset Formula $\text{id}:L^{A}\rightarrow T_{L}^{\text{Id},A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We have found the isomorphism maps between 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
 However, we still need to verify that the monad structure of 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 is the same as that of 
\begin_inset Formula $L$
\end_inset

; otherwise the isomorphism would not be a 
\emph on
monadic
\emph default
 isomorphism (i.e.
\begin_inset space ~
\end_inset

an isomorphism that preserves the structure of the monads).
 To verify this, it is sufficient to show that the methods 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 defined by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for the monad 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 are 
\emph on
the same functions
\emph default
 as the given methods 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 of the monad 
\begin_inset Formula $L$
\end_inset

.
 If the monad's methods are the same functions, i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula $\text{pu}_{L}=\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}=\text{ftn}_{T}$
\end_inset

, then the identity map 
\begin_inset Formula $\text{id}:T^{A}\rightarrow L^{A}$
\end_inset

 will satisfy the laws of the monad morphism,
\begin_inset Formula 
\[
\text{pu}_{T}\bef\text{id}=\text{pu}_{L}\quad,\quad\quad\text{ftn}_{T}\bef\text{id}=\text{id}^{\uparrow T}\bef\text{id}\bef\text{ftn}_{L}\quad.
\]

\end_inset

In the same way, the laws of the monad morphism will hold for the identity
 map in the direction 
\begin_inset Formula $L\leadsto T$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
For composed-inside transformers:
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{M}=\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{M}=\text{ftn}_{T}$
\end_inset

.
 Designate 
\begin_inset Formula $L$
\end_inset

 as the foreign monad and 
\begin_inset Formula $M$
\end_inset

 as the base monad in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

), as appropriate for the composed-inside transformer 
\begin_inset Formula $T_{L}^{M}=M\circ L$
\end_inset

.
 Setting the foreign monad to identity, 
\begin_inset Formula $L=\text{Id}$
\end_inset

, in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives
\begin_inset Formula 
\[
\text{pu}_{T}=\text{pu}_{M}\bef\text{pu}_{\text{Id}}=\text{pu}_{M}.
\]

\end_inset


\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{ftn}_{M}=\text{ftn}_{T}$
\end_inset

, we use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $L=\text{Id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{T}\\
\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:\quad & =\text{sw}_{\text{Id},M}^{\uparrow\text{Id}}\bef\text{ftn}_{\text{Id}}\bef\text{ftn}_{M}^{\uparrow\text{Id}}\\
\text{use \text{ftn}_{\text{Id}}=\text{id} and \text{sw}_{\text{Id},M}=\text{id}}:\quad & =\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
For composed-outside transformers:
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{L}=\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}=\text{ftn}_{T}$
\end_inset

.
 Designate 
\begin_inset Formula $M$
\end_inset

 as the foreign monad and 
\begin_inset Formula $L$
\end_inset

 as the base monad in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

), as appropriate for the composed-outside transformer 
\begin_inset Formula $T_{L}^{M}=L\circ M$
\end_inset

.
 Setting the foreign monad to identity, 
\begin_inset Formula $M=\text{Id}$
\end_inset

, in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives
\begin_inset Formula 
\[
\text{pu}_{T}=\text{pu}_{\text{Id}}\bef\text{pu}_{L}=\text{pu}_{L}.
\]

\end_inset


\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{ftn}_{L}=\text{ftn}_{T}$
\end_inset

, use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $M=\text{Id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{T}\\
\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:\quad & =\text{sw}_{L,\text{Id}}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{\text{Id}}^{\uparrow L}\\
\text{use \text{ftn}_{\text{Id}}=\text{id} and \text{sw}_{L,\text{Id}}=\text{id}}:\quad & =\text{ftn}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Monad transformer lifting laws: Proofs
\end_layout

\begin_layout Standard
We will now derive the laws of monad transformer liftings from the laws
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

, using Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as definitions of the methods of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
To be specific, let us assume that 
\begin_inset Formula $L$
\end_inset

 is the base monad of the transformer.
 Only the monads' names will need to change for the other choice of the
 base monad.
\end_layout

\begin_layout Standard
The lifting morphisms of a compositional monad transformer are defined by
\begin_inset Formula 
\begin{align*}
\text{lift} & =\text{pu}_{L}:M^{A}\rightarrow L^{M^{A}}\quad,\\
\text{blift} & =\text{pu}_{M}^{\uparrow L}:L^{A}\rightarrow L^{M^{A}}\quad.
\end{align*}

\end_inset

Their laws of liftings (the identity and the composition laws) are 
\begin_inset Formula 
\begin{align*}
\text{pu}_{M}\bef\text{lift}=\text{pu}_{T}\quad,\quad & \quad\text{pu}_{L}\bef\text{blift}=\text{pu}_{T}\quad,\\
\text{ftn}_{M}\bef\text{lift}=\text{lift}^{\uparrow M}\bef\text{lift}\bef\text{ftn}_{T}\quad,\quad & \quad\text{ftn}_{L}\bef\text{blift}=\text{blift}^{\uparrow L}\bef\text{blift}\bef\text{ftn}_{T}\quad.
\end{align*}

\end_inset

The identity laws are verified quickly,
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{T}:\quad & \text{pu}_{M}\bef\text{lift}=\text{pu}_{M}\bef\text{pu}_{L}\\
\text{definition of }\text{pu}_{T}:\quad & =\text{pu}_{T}\quad,\\
\text{expect to equal }\text{pu}_{T}:\quad & \text{pu}_{L}\bef\text{blift}=\text{pu}_{L}\bef\text{pu}_{M}^{\uparrow L}\\
\text{naturality of }\text{pu}_{L}:\quad & =\text{pu}_{M}\bef\text{pu}_{L}=\text{pu}_{T}\quad.
\end{align*}

\end_inset

To verify the composition laws, we need to start from their right-hand sides
 because the left-hand sides cannot be simplified.
 We then substitute the definition of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 in terms of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 The composition law for 
\begin_inset Formula $\text{lift}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{M}\bef\text{pu}_{L}:\quad & \text{lift}^{\uparrow M}\bef\text{lift}\bef\text{ftn}_{T}\\
\text{definitions of }\text{lift}\text{ and }\text{ftn}_{T}:\quad & =\text{pu}_{L}^{\uparrow M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{pu}_{L}:\quad & =\text{pu}_{L}^{\uparrow M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{left identity law of }L:\quad & =\gunderline{\text{pu}_{L}^{\uparrow M}\bef\text{sw}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{inner-identity law of }\text{sw}:\quad & =\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{pu}_{L}:\quad & =\text{ftn}_{M}\bef\text{pu}_{L}\quad.
\end{align*}

\end_inset

The composition law for 
\begin_inset Formula $\text{blift}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{L}\bef\text{pu}_{M}^{\uparrow L}:\quad & \text{blift}^{\uparrow L}\bef\text{blift}\bef\text{ftn}_{T}\\
\text{definitions of }\text{blift}\text{ and }\text{ftn}_{T}:\quad & =\text{pu}_{M}^{\uparrow L\uparrow L}\bef\gunderline{\text{pu}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{functor composition in }L:\quad & =\text{pu}_{M}^{\uparrow L\uparrow L}\bef\gunderline{\left(\text{pu}_{M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{outer-identity law of }\text{sw}:\quad & =\gunderline{\left(\text{pu}_{M}^{\uparrow L\uparrow L}\bef\text{pu}_{M}^{\uparrow L\uparrow L}\right)}\bef\gunderline{\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality of }\text{ftn}_{L}:\quad & =\text{ftn}_{L}\bef\big(\text{pu}_{M}^{\uparrow L}\bef\gunderline{\text{pu}_{M}^{\uparrow L}\big)\bef\text{ftn}_{M}^{\uparrow L}}\\
\text{right identity law of }M:\quad & =\text{ftn}_{L}\bef\text{pu}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

So, the lifting laws for 
\begin_inset Formula $T$
\end_inset

 follow from the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Monad transformer runner laws: Proofs
\end_layout

\begin_layout Standard
The laws of runners are not symmetric with respect to the base monad and
 the foreign monad: the runner, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mrun
\end_layout

\end_inset

, is generic in the foreign monad (but not in the base monad).
 In each case, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function must be monadically natural with respect to the 
\emph on
foreign
\emph default
 monad.
 So, this law needs to be written differently, depending on the choice of
 the base monad.
 Let us consider separately the situations when either 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 is the base monad.
\end_layout

\begin_layout Paragraph
If the base monad is 
\begin_inset Formula $L$
\end_inset

, 
\end_layout

\begin_layout Standard
the runners are
\begin_inset Formula 
\begin{align*}
\text{mrun}\,\phi^{:M^{\bullet}\leadsto N^{\bullet}} & :L^{M^{\bullet}}\leadsto L^{N^{\bullet}}\quad,\quad\quad\text{mrun}\,\phi=\phi^{\uparrow L}\quad;\\
\text{brun}\,\theta^{:L^{\bullet}\leadsto\bullet} & :L^{M^{\bullet}}\leadsto M^{\bullet}\quad,\quad\quad\text{brun}\,\theta=\theta\quad.
\end{align*}

\end_inset

The laws of runners require that 
\begin_inset Formula $\text{mrun}\,\phi$
\end_inset

 and 
\begin_inset Formula $\text{brun}\,\theta$
\end_inset

 must be monad morphisms, i.e.
\begin_inset space ~
\end_inset

the identity and composition laws must hold for 
\begin_inset Formula $\text{mrun}\,\phi$
\end_inset

 and 
\begin_inset Formula $\text{brun}\,\theta$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{pu}_{L\circ M}\bef\text{mrun}\,\phi & =\text{pu}_{L\circ N}\quad,\\
\text{ftn}_{L\circ M}\bef\text{mrun}\,\phi & =\left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{L\circ N}\quad,\\
\text{pu}_{L\circ M}\bef\text{brun}\,\theta & =\text{pu}_{M}\quad,\\
\text{ftn}_{L\circ M}\bef\text{brun}\,\theta & =\left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

To derive these laws, we may use the identity and composition laws of monad
 morphisms for 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

.
 We also use Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as definitions of the monad 
\begin_inset Formula $T$
\end_inset

.
 Additionally, the 
\series bold
monadic naturality
\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality
\end_layout

\end_inset


\series default
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 with respect to 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

 are assumed to hold,
\begin_inset Formula 
\[
\text{sw}_{L,M}\bef\phi^{\uparrow L}=\phi\bef\text{sw}_{L,N}\quad,\quad\quad\text{sw}_{L,M}\bef\theta=\theta^{\uparrow M}\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[d]\sb(0.4){\phi} & L^{M^{A}}\ar[d]\sp(0.4){\phi^{\uparrow L}} & M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[rd]\sb(0.45){\theta^{\uparrow M}} & L^{M^{A}}\ar[d]\sp(0.4){\theta}\\
N^{L^{A}}\ar[r]\sb(0.5){\text{sw}_{L,N}} & L^{N^{A}} &  & M^{A}
}
\]

\end_inset


\end_layout

\begin_layout Standard
The first law to be shown is the identity law for 
\begin_inset Formula $\text{mrun}\,\phi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect this to equal }\text{pu}_{L\circ N}:\quad & \text{pu}_{L\circ M}\bef\text{mrun}\,\phi\\
\text{definitions of }\text{mrun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\phi^{\uparrow L}}\\
\text{naturality of }\text{pu}_{L}:\quad & =\gunderline{\text{pu}_{M}\bef\phi}\bef\text{pu}_{L}\\
\text{identity law for }\phi:\quad & =\text{pu}_{N}\bef\text{pu}_{L}\\
\text{definition of }\text{pu}_{L\circ N}:\quad & =\text{pu}_{L\circ N}\quad.
\end{align*}

\end_inset

The next law to be shown is the composition law for 
\begin_inset Formula $\text{mrun}\,\phi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect this to equal }\text{ftn}_{T}\bef\phi^{\uparrow L}:\quad & \left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{L\circ N}\\
\text{definitions of }\text{mrun}\text{ and }\text{ftn}_{L\circ N}:\quad & =\phi^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\phi^{\uparrow L}\bef\text{sw}_{L,N}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{N}^{\uparrow L}\\
\text{monadic naturality of }\text{sw}_{L,M}:\quad & =\gunderline{\phi^{\uparrow L\uparrow M\uparrow L}\bef\text{sw}_{L,M}^{\uparrow L}}\bef\phi^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{N}^{\uparrow L}\\
\text{naturality of }\text{sw}_{L,M}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\phi^{\uparrow M\uparrow L\uparrow L}\bef\phi^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{N}^{\uparrow L}\\
\text{naturality of }\text{ftn}_{L}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\left(\phi^{\uparrow M}\bef\phi\bef\text{ftn}_{N}\right)}^{\uparrow L}\\
\text{composition law for }\phi:\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\bef\phi^{\uparrow L}\\
\text{definition of }\text{ftn}_{T}:\quad & =\gunderline{\text{ftn}_{T}}\bef\phi^{\uparrow L}\quad.
\end{align*}

\end_inset

The next law is the identity law for 
\begin_inset Formula $\text{brun}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect this to equal }\text{pu}_{M}:\quad & \text{pu}_{L\circ M}\bef\text{brun}\,\theta\\
\text{definitions of }\text{brun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\theta}\\
\text{identity law for }\theta:\quad & =\text{pu}_{M}\quad.
\end{align*}

\end_inset

The last law to be shown is the composition law for 
\begin_inset Formula $\text{brun}\,\theta$
\end_inset

.
 Begin with its right-hand side since it is simpler,
\begin_inset Formula 
\begin{align*}
 & \left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{M}\\
\text{definition of }\text{brun}:\quad & =\theta^{\uparrow M\uparrow L}\bef\theta\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

We cannot simplify this expression any more, and yet it is still different
 from the left-hand side.
 So let us transform the left-hand side, hoping to obtain the same expression.
 In particular, we need to move 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

 to the right and 
\begin_inset Formula $\theta$
\end_inset

 to the left: 
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{L\circ M}\bef\text{brun}\,\theta\\
\text{definitions of }\text{ftn}_{L\circ M}\text{ and }\text{brun}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\theta}\\
\text{naturality of }\theta:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\theta}\bef\text{ftn}_{M}\\
\text{composition law for }\theta:\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\theta^{\uparrow L}}\bef\theta\bef\text{ftn}_{M}\\
\text{functor composition}:\quad & =\gunderline{\left(\text{sw}_{L,M}\bef\theta\right)^{\uparrow L}}\bef\theta\bef\text{ftn}_{M}\\
\text{monadic naturality of }\text{sw}_{L,M}:\quad & =\gunderline{\theta^{\uparrow M\uparrow L}}\bef\theta\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

We have transformed both sides of the law into the same expression.
\end_layout

\begin_layout Standard
The lifting laws for 
\begin_inset Formula $\text{mrun}$
\end_inset

 are
\begin_inset Formula 
\[
\text{mrun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{mrun}\left(\phi\right)\bef\text{mrun}\left(\chi\right)=\text{mrun}\left(\phi\bef\chi\right)\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{mrun}\left(\phi\right)=\phi^{\uparrow L}$
\end_inset

 in our case, these laws hold because they are the same as the functor laws
 of 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Standard
Finally, we verify the non-degeneracy law for 
\begin_inset Formula $\text{brun}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{lift}\bef\text{brun}\left(\theta\right)\\
\text{definitions of }\text{lift}\text{ and }\text{brun}:\quad & =\text{pu}_{L}\bef\theta\\
\text{identity law for }\theta:\quad & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
If the base monad is 
\begin_inset Formula $M$
\end_inset

, 
\end_layout

\begin_layout Standard
the runners have the type signatures
\begin_inset Formula 
\begin{align*}
\text{mrun}\,\phi^{:L^{\bullet}\leadsto N^{\bullet}} & :L^{M^{\bullet}}\leadsto N^{M^{\bullet}}\quad,\quad\quad\text{mrun}\,\phi=\phi\quad;\\
\text{brun}\,\theta^{:M^{\bullet}\leadsto\bullet} & :L^{M^{\bullet}}\leadsto L^{\bullet}\quad,\quad\quad\text{brun}\,\theta=\theta^{\uparrow L}\quad.
\end{align*}

\end_inset

The laws of runners require that 
\begin_inset Formula $\text{mrun}\,\phi$
\end_inset

 and 
\begin_inset Formula $\text{brun}\,\theta$
\end_inset

 must be monad morphisms, i.e.
\begin_inset space ~
\end_inset

the identity and composition laws must hold for 
\begin_inset Formula $\text{mrun}\,\phi$
\end_inset

 and 
\begin_inset Formula $\text{brun}\,\theta$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{pu}_{L\circ M}\bef\text{mrun}\,\phi & =\text{pu}_{N\circ M}\quad,\\
\text{ftn}_{L\circ M}\bef\text{mrun}\,\phi & =\left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{N\circ M}\quad,\\
\text{pu}_{L\circ M}\bef\text{brun}\,\theta & =\text{pu}_{L}\quad,\\
\text{ftn}_{L\circ M}\bef\text{brun}\,\theta & =\left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{L}\quad.
\end{align*}

\end_inset

The monadic naturality laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 with respect to 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

 are 
\begin_inset Formula 
\[
\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[d]\sb(0.4){\phi^{\uparrow M}} & L^{M^{A}}\ar[d]\sp(0.4){\phi} & M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[rd]\sb(0.45){\theta} & L^{M^{A}}\ar[d]\sp(0.4){\theta^{\uparrow L}}\\
M^{N^{A}}\ar[r]\sb(0.5){\text{sw}_{N,M}} & N^{M^{A}} &  & L^{A}
}
\]

\end_inset


\end_layout

\begin_layout Standard
The first law to be proved is
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{N\circ M}:\quad & \text{pu}_{L\circ M}\bef\text{mrun}\,\phi\\
\text{definitions of }\text{mrun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\phi}\\
\text{identity law for }\phi:\quad & =\text{pu}_{M}\bef\text{pu}_{N}\\
\text{definition of }\text{pu}_{N\circ M}:\quad & =\text{pu}_{N\circ M}\quad.
\end{align*}

\end_inset

The next law is the composition law for 
\begin_inset Formula $\text{mrun}\,\phi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect this to equal }\text{ftn}_{T}\bef\phi:\quad & \left(\text{mrun}\,\phi\right)^{\uparrow M\uparrow L}\bef\text{mrun}\,\phi\bef\text{ftn}_{N\circ M}\\
\text{definitions of }\text{mrun}\text{ and }\text{ftn}_{N\circ M}:\quad & =\phi^{\uparrow M\uparrow L}\bef\gunderline{\phi\bef\text{sw}_{N,M}^{\uparrow N}}\bef\text{ftn}_{N}\bef\text{ftn}_{M}^{\uparrow N}\\
\text{naturality of }\phi:\quad & =\gunderline{\phi^{\uparrow M\uparrow L}\bef\text{sw}_{N,M}^{\uparrow L}}\bef\phi\bef\text{ftn}_{N}\bef\text{ftn}_{M}^{\uparrow N}\\
\text{monadic naturality of }\text{sw}_{N,M}\text{ raised to }L:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\phi^{\uparrow L}\bef\phi\bef\text{ftn}_{N}}\bef\text{ftn}_{M}^{\uparrow N}\\
\text{composition law for }\phi:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\phi\bef\text{ftn}_{M}^{\uparrow N}}\\
\text{naturality of }\phi:\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\bef\phi\\
\text{definition of }\text{ftn}_{T}:\quad & =\gunderline{\text{ftn}_{T}}\bef\phi\quad.
\end{align*}

\end_inset

The next law is the identity law for 
\begin_inset Formula $\text{brun}\left(\theta\right)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect this to equal }\text{pu}_{L}:\quad & \text{pu}_{L\circ M}\bef\text{brun}\,\theta\\
\text{definitions of }\text{brun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\theta^{\uparrow L}}\\
\text{naturality of }\text{pu}_{L}:\quad & =\gunderline{\text{pu}_{M}\bef\theta}\bef\text{pu}_{L}\\
\text{identity law for }\theta:\quad & =\text{pu}_{L}\quad.
\end{align*}

\end_inset

The last law is the composition law for 
\begin_inset Formula $\text{brun}\left(\theta\right)$
\end_inset

.
 Begin with its right-hand side,
\begin_inset Formula 
\begin{align*}
 & \left(\text{brun}\,\theta\right)^{\uparrow M\uparrow L}\bef\text{brun}\,\theta\bef\text{ftn}_{L}\\
\text{definition of }\text{brun}:\quad & =\theta^{\uparrow L\uparrow M\uparrow L}\bef\theta^{\uparrow L}\bef\text{ftn}_{L}\\
\text{functor composition}:\quad & =\left(\theta^{\uparrow L\uparrow M}\bef\theta\right)^{\uparrow L}\bef\text{ftn}_{L}\\
\text{naturality of }\theta:\quad & =\left(\theta\bef\theta^{\uparrow L}\right)^{\uparrow L}\bef\text{ftn}_{L}\quad.
\end{align*}

\end_inset

We now transform the left-hand side, hoping to obtain the same expression.
 We need to move 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 to the right and 
\begin_inset Formula $\theta$
\end_inset

 to the left: 
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\theta^{\uparrow L}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}:\quad & \text{ftn}_{L\circ M}\bef\text{brun}\,\theta\\
\text{definitions of }\text{ftn}_{L\circ M}\text{ and }\text{brun}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\theta^{\uparrow L}}\\
\text{composition law for }\theta:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\left(\theta\bef\theta\right)^{\uparrow L}}\\
\text{naturality of }\text{ftn}_{L}:\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\left(\theta\bef\theta\right)^{\uparrow L\uparrow L}}\bef\text{ftn}_{L}\\
\text{functor composition}:\quad & =\gunderline{\left(\text{sw}_{L,M}\bef\theta^{\uparrow L}\right)}^{\uparrow L}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\\
\text{composition law for }\theta:\quad & =\gunderline{\theta^{\uparrow L}}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The lifting laws for 
\begin_inset Formula $\text{mrun}$
\end_inset

 are
\begin_inset Formula 
\[
\text{mrun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{mrun}\left(\phi\right)\bef\text{mrun}\left(\chi\right)=\text{mrun}\left(\phi\bef\chi\right)\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{mrun}\left(\phi\right)=\phi$
\end_inset

 in our case, these laws are trivially satisfied.
\end_layout

\begin_layout Standard
Finally, the non-degeneracy law for 
\begin_inset Formula $\text{brun}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{lift}\bef\text{brun}\left(\theta\right)\\
\text{definitions of }\text{lift}\text{ and }\text{brun}:\quad & =\text{pu}_{M}^{\uparrow L}\bef\theta^{\uparrow L}\\
\text{identity law for }\theta:\quad & =\text{id}^{\uparrow L}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Summary of results
\end_layout

\begin_layout Standard
The following two theorems summarize the derivations in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Monad-transformers-that-use-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Subsubsection
Theorem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Theorem-outside-transformer-swap-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (composed-outside)
\end_layout

\begin_layout Standard
For a base monad 
\begin_inset Formula $L$
\end_inset

 and a foreign monad 
\begin_inset Formula $M$
\end_inset

, the functor composition 
\begin_inset Formula $L\circ M$
\end_inset

 is a lawful monad transformer if a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function 
\begin_inset Formula $\text{sw}_{L,M}:M\circ L\leadsto L\circ M$
\end_inset

 exists, satisfying the conditions of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the monadic naturality laws
\begin_inset Formula 
\[
\text{sw}_{L,M}\bef\phi^{\uparrow L}=\phi\bef\text{sw}_{L,N}\quad,\quad\quad\text{sw}_{L,M}\bef\theta=\theta^{\uparrow M}\quad,
\]

\end_inset

with respect to arbitrary monad morphisms 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:L\leadsto\text{Id}$
\end_inset

.
 An additional law, 
\begin_inset Formula $\text{sw}_{L,\text{Id}}=\text{id}$
\end_inset

, follows from the conditions of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Theorem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Theorem-inside-transformer-swap-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (composed-inside)
\end_layout

\begin_layout Standard
For a base monad 
\begin_inset Formula $M$
\end_inset

 and a foreign monad 
\begin_inset Formula $L$
\end_inset

, the functor composition 
\begin_inset Formula $L\circ M$
\end_inset

 is a lawful monad transformer if a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function 
\begin_inset Formula $\text{sw}_{L,M}:M\circ L\leadsto L\circ M$
\end_inset

 exists, satisfying the conditions of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the monadic naturality laws
\begin_inset Formula 
\[
\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad,
\]

\end_inset

with respect to arbitrary monad morphisms 
\begin_inset Formula $\phi:L\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:M\leadsto\text{Id}$
\end_inset

.
 An additional law, 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

, follows from the conditions of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Theorems
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 enable us to check more easily whether a given base monad has a monad transform
er of a 
\begin_inset Quotes eld
\end_inset

composed
\begin_inset Quotes erd
\end_inset

 kind.
 It is easier to check the 6 laws for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function than to verify the 15 monad transformer laws directly.
 Also, the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 use simpler type constructors than the monad transformer laws.
\end_layout

\begin_layout Section
Composed-inside transformers: Linear monads
\begin_inset CommandInset label
LatexCommand label
name "sec:transformers-linear-monads"

\end_inset


\end_layout

\begin_layout Standard
A monad 
\begin_inset Formula $M$
\end_inset

 is 
\series bold
linear
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!linear
\end_layout

\end_inset


\series default
 if it is of the form 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are fixed types, and 
\begin_inset Formula $Q$
\end_inset

 is a monoid.
 (The polynomial 
\begin_inset Formula $P+Q\times A$
\end_inset

 is linear in its type parameter 
\begin_inset Formula $A$
\end_inset

.) Well-known examples of linear monads are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

.
 The general case 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

 represents a computation that can fail and at the same time produce a log
 message.
 So, 
\begin_inset Formula $M$
\end_inset

 can be seen as a composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A different (but also linear) monad is obtained from the composition of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

.
 The type constructor of this monad is 
\begin_inset Formula $Q\times\left(P+A\right)$
\end_inset

.
\end_layout

\begin_layout Standard
In general, composition of two linear monads 
\begin_inset Formula $M_{1}^{A}\triangleq P_{1}+Q_{1}\times A$
\end_inset

 and 
\begin_inset Formula $M_{2}^{A}\triangleq P_{2}+Q_{2}\times A$
\end_inset

 is again linear because
\begin_inset Formula 
\begin{align*}
 & P_{1}+Q_{1}\times\left(P_{2}+Q_{2}\times A\right)\\
\text{expand brackets}:\quad & =\gunderline{P_{1}+Q_{1}\times P_{2}}+\gunderline{Q_{1}\times Q_{2}}\times A\\
\text{define new }P,Q:\quad & =P+Q\times A\quad.
\end{align*}

\end_inset

Note that we need to define 
\begin_inset Formula $Q\triangleq Q_{1}\times Q_{2}$
\end_inset

, and so 
\begin_inset Formula $Q$
\end_inset

 is a monoid since, by assumption, 
\begin_inset Formula $Q_{1}$
\end_inset

 and 
\begin_inset Formula $Q_{2}$
\end_inset

 are monoids.
\end_layout

\begin_layout Standard
For a linear monad 
\begin_inset Formula $M$
\end_inset

 and any foreign monad 
\begin_inset Formula $L$
\end_inset

, the functor composition 
\begin_inset Formula $L\circ M$
\end_inset

 is a monad.
 For example, the type constructor for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OptionT
\end_layout

\end_inset

 monad transformer can be defined as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type OptionT[L[_], A] = L[Option[A]]
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type constructor must be nested 
\emph on
inside
\emph default
 the foreign monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

.
 This is the case for all linear monads.
 Also, linear monads are the only known examples of monads whose transformers
 are composed inside the foreign monad.
\end_layout

\begin_layout Subsection
Definitions of 
\family typewriter
swap
\family default
 and 
\family typewriter
flatten
\end_layout

\begin_layout Standard
To show that the monad transformer for the base monad 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

 is 
\begin_inset Formula $T_{M}^{L,A}=L^{M^{A}}$
\end_inset

, we will implement a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function having the type signature
\begin_inset Formula 
\[
\text{sw}_{N,M}:M^{L^{A}}\rightarrow L^{M^{A}}\quad,
\]

\end_inset

for the base monad 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

 and an arbitrary foreign monad 
\begin_inset Formula $L$
\end_inset

.
 We will then prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 satisfies all the required laws stated in Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This will guarantee that 
\begin_inset Formula $T_{M}^{L,A}=L^{M^{A}}$
\end_inset

 is a lawful monad transformer.
\end_layout

\begin_layout Standard
Expanding the definition of the type constructor 
\begin_inset Formula $M^{\bullet}$
\end_inset

, we can write the type signature of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function as 
\begin_inset Formula 
\[
\text{sw}_{L,M}:P+Q\times L^{A}\rightarrow L^{P+Q\times A}\quad.
\]

\end_inset

We can map 
\begin_inset Formula $P$
\end_inset

 to 
\begin_inset Formula $L^{P}$
\end_inset

 by applying 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

.
 We can also map 
\begin_inset Formula $Q\times L^{A}\rightarrow L^{Q\times A}$
\end_inset

 since 
\begin_inset Formula $L$
\end_inset

 is a functor,
\begin_inset Formula 
\[
q\times l\rightarrow\left(a\rightarrow q\times a\right)^{\uparrow L}l\quad.
\]

\end_inset

 It remains to unite these two functions.
 In the matrix notation, we write
\begin_inset Formula 
\begin{equation}
\text{sw}_{L,M}=\begin{array}{|c||c|}
P & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
Q\times L^{A} & q\times l\rightarrow(a^{:A}\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\quad.\label{eq:single-valued-monad-def-of-swap}
\end{equation}

\end_inset

In Scala, the code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type M[A, P, Q] = Either[P, (Q, A)]
\end_layout

\begin_layout Plain Layout

def swap[L[_]: Monad, A, P, Q]: M[L[A]] => L[M[A]] = {
\end_layout

\begin_layout Plain Layout

  case Left(p) => Monad[L].pure(Left(p))
\end_layout

\begin_layout Plain Layout

  case Right((q, la)) => la.map(a => Right((q, a)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function, we define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method for the transformed monad 
\begin_inset Formula $T$
\end_inset

 (short notation 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

) by the standard formula
\begin_inset Formula 
\[
\text{ftn}_{T}=\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\]

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method for 
\begin_inset Formula $T$
\end_inset

 (short notation 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

) is 
\begin_inset Formula $\text{pu}_{T}=\text{pu}_{M}\bef\text{pu}_{L}$
\end_inset

.
 In Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[L[_]: Monad, A, P, Q: Monoid](x: A): L[M[A]] =
\end_layout

\begin_layout Plain Layout

  Monad[L].pure(Right((Monoid[Q].empty, x)))
\end_layout

\begin_layout Plain Layout

def flatten[L[_]: Monad, A, P, Q: Monoid](tt: L[M[L[M[A]]]]): L[M[A]] =
\end_layout

\begin_layout Plain Layout

  tt.map(swap).flatten.map(_.flatten) // Assuming suitable implicits in scope.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we will verify that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 hold.
 We will need to use the code for the methods 
\begin_inset Formula $\text{fmap}_{M}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

, and 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 of the monad 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{fmap}_{M}f^{:A\rightarrow B} & =f^{\uparrow M}=\begin{array}{|c||cc|}
 & P & Q\times B\\
\hline P & \text{id} & \bbnum 0\\
Q\times A & \bbnum 0\enskip & q\times a\rightarrow q\times f(a)
\end{array}\quad,\\
\text{pu}_{M}a^{:A} & =0^{:P}+q_{0}\times a\quad,\quad\quad\text{pu}_{M}=\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline A & \bbnum 0\enskip & a\rightarrow q_{0}\times a
\end{array}\quad,\\
\text{ftn}_{M}^{:M^{M^{A}}\rightarrow M^{A}} & =\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline P & \text{id} & \bbnum 0\\
Q\times P & q\times p\rightarrow p & \bbnum 0\\
Q\times Q\times A & \bbnum 0 & q_{1}\times q_{2}\times a\rightarrow\left(q_{1}\oplus q_{2}\right)\times a
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Laws of 
\family typewriter
swap
\end_layout

\begin_layout Standard
We do not need to verify naturality since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is defined as a fully parametric function.
\end_layout

\begin_layout Paragraph
The inner-identity law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{L}^{\uparrow M}\bef\text{sw}=\text{pu}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{pu}_{L}^{\uparrow M}\bef\text{sw}= & \left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times a\rightarrow q\times\text{pu}_{L}a
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow(x^{:A}\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}l
\end{array}\right|\\
\text{composition}:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times a\rightarrow\gunderline{(a^{:A}\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\left(\text{pu}_{L}a\right)}
\end{array}\right|\\
\text{pu}_{L}\text{'s naturality}:\quad & =\begin{array}{|c||c|}
P & x^{:P}\rightarrow\text{pu}_{L}(x+\bbnum 0^{:Q\times A})\\
Q\times A & q\times a\rightarrow\text{pu}_{L}(\bbnum 0^{:P}+q\times a)
\end{array}\\
\text{matrix notation}:\quad & =\text{pu}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
The outer-identity law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{pu}_{M}\bef\text{sw} & =\left\Vert \begin{array}{cc}
\bbnum 0 & l^{:L^{A}}\rightarrow q_{0}\times l\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow(x^{:A}\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}l
\end{array}\right|\\
\text{composition}:\quad & =l^{:L^{A}}\rightarrow(x^{:A}\rightarrow\bbnum 0^{:P}+q_{0}\times x)^{\uparrow L}l\\
\text{definition of }\text{pu}_{M}:\quad & =l\rightarrow\text{pu}_{M}^{\uparrow L}l=\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
The inner-interchange law
\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $\text{ftn}_{L}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align}
\text{ftn}_{L}^{\uparrow M}\bef\text{sw}= & \left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\rightarrow q\times\text{ftn}_{L}l
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\right|\nonumber \\
 & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}(\text{ftn}_{L}l)
\end{array}\right|\quad,\label{eq:l-interchange-simplify-1}\\
\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}= & \left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\right|\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\nonumber \\
 & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\\
\big(q\times l\rightarrow(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l\big)\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}
\end{array}\right|\quad.\nonumber 
\end{align}

\end_inset

It is quicker to simplify each expression in the last column separately
 and then to compare with the column in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-simplify-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Simplify the upper expression:
\begin_inset Formula 
\begin{align*}
 & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\\
\text{naturality of }\text{pu}_{L}:\quad & =(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\\
\text{identity law of }L:\quad & =\gunderline{(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{sw}}\\
\text{definition of }\text{sw}:\quad & =(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\quad.
\end{align*}

\end_inset

This equals the upper expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-simplify-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Simplify the lower expression;
\begin_inset Formula 
\begin{align}
 & \big(q\times l\rightarrow\gunderline{(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l}\big)\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\nonumber \\
\text{definition of }\triangleright:\quad & =q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\quad.\label{eq:l-interchange-simplify-2}
\end{align}

\end_inset

Simplify the expression 
\begin_inset Formula $(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}$
\end_inset

 separately:
\begin_inset Formula 
\begin{align}
 & (a\rightarrow\bbnum 0^{:P}+q\times a)\bef\text{sw}\nonumber \\
\text{composition}:\quad & =a\rightarrow\gunderline{\text{sw}\,(\bbnum 0^{:P}+q\times a)}\nonumber \\
\text{definition of }\text{sw}:\quad & =\gunderline{a\rightarrow a\triangleright(}x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\nonumber \\
\text{omit argument}:\quad & =(x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\quad.\label{eq:l-interchange-simplify-3}
\end{align}

\end_inset

Then we continue simplifying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-simplify-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & q\times l\rightarrow l\triangleright\gunderline{(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\\
\text{use Eq.~(\ref{eq:l-interchange-simplify-3})}:\quad & =q\times l\rightarrow l\triangleright\gunderline{(x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\\
\text{naturality of }\text{ftn}_{L}:\quad & =q\times l\rightarrow\gunderline{l\triangleright\text{ftn}_{L}}\bef(x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\\
\text{definition of }\triangleright:\quad & =q\times l\rightarrow(x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}(\text{ftn}_{L}l)\quad.
\end{align*}

\end_inset

This equals the lower expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-simplify-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) after renaming 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Paragraph
The outer-interchange law
\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}$
\end_inset

.
 The left-hand side is written using the matrices for 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{ftn}_{M}\bef\text{sw}\nonumber \\
 & =\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
q\times p\rightarrow p & \bbnum 0\\
\bbnum 0 & q_{1}\times q_{2}\times a\rightarrow\left(q_{1}\oplus q_{2}\right)\times a
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times l\rightarrow(x\rightarrow\bbnum 0+q\times x)^{\uparrow L}l
\end{array}\right|\nonumber \\
 & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
\left(q\times p\rightarrow p+\bbnum 0\right)\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times a\rightarrow(x\rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}a
\end{array}\right|\quad.\label{eq:m-interchange-law-of-swap-linear-monads-left-hand-side}
\end{align}

\end_inset

We cannot simplify this any more, so we hope to transform the right-hand
 side, 
\begin_inset Formula $\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}$
\end_inset

, to the same column expression.
 Begin by writing the matrix for 
\begin_inset Formula $\text{sw}^{\uparrow M}$
\end_inset

, expanding the rows for the input type 
\begin_inset Formula $M^{M^{L^{A}}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{sw}^{\uparrow M}=~ & \begin{array}{|c||cc|}
P & \text{id} & \bbnum 0\\
Q\times P & \bbnum 0 & q\times p\rightarrow q\times\text{sw}\left(p+\bbnum 0\right)\\
Q\times Q\times L^{A} & \bbnum 0 & q_{1}\times q_{2}\times l\rightarrow q_{1}\times\text{sw}\left(\bbnum 0+q_{2}\times l\right)
\end{array}\\
 & =\begin{array}{|c||cc|}
P & \text{id} & \bbnum 0\\
Q\times P & \bbnum 0 & q\times p\rightarrow q\times\text{pu}_{L}\left(p+\bbnum 0\right)\\
Q\times Q\times L^{A} & \bbnum 0 & q_{1}\times q_{2}\times l\rightarrow q_{1}\times(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}l
\end{array}\quad.
\end{align*}

\end_inset

Then compute the composition 
\begin_inset Formula $\text{sw}^{\uparrow M}\bef\text{sw}$
\end_inset

 as
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow M}\bef\text{sw}\\
 & =\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times p\rightarrow q\times\text{pu}_{L}\left(p+\bbnum 0\right)\\
\bbnum 0 & q_{1}\times q_{2}\times l\rightarrow q_{1}\times(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}l
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times l\rightarrow(x\rightarrow\bbnum 0+q\times x)^{\uparrow L}l
\end{array}\right|\\
 & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\rightarrow(x^{:M^{A}}\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\left(\text{pu}_{L}\left(p+\bbnum 0\right)\right)\\
q_{1}\times q_{2}\times l\rightarrow(x^{:M^{A}}\rightarrow\bbnum 0^{:P}+q_{1}\times x)^{\uparrow L}(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}l
\end{array}\right|\\
 & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\rightarrow\text{pu}_{L}(\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\\
q_{1}\times q_{2}\times l\rightarrow(x^{:M^{A}}\rightarrow\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x))^{\uparrow L}l
\end{array}\right|\quad.
\end{align*}

\end_inset

Now we need to post-compose 
\begin_inset Formula $\text{ftn}_{M}^{\uparrow L}$
\end_inset

 with this column:
\begin_inset Formula 
\begin{align*}
\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L} & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\\
(q\times p\rightarrow\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x))^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}
\end{array}\right|\\
\text{pu}_{L}\text{'s naturality}:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{ftn}_{M}\bef\text{pu}_{L}\\
(q\times p\rightarrow\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\bef\text{ftn}_{M}\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\gunderline{\text{ftn}_{M}\left(\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x)\right)})^{\uparrow L}
\end{array}\right|\\
\text{compute }\text{ftn}_{M}(...):\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow\text{ftn}_{M}(x+\bbnum 0))\bef\text{pu}_{L}\\
(q\times p\rightarrow\text{ftn}_{M}(\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right)))\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}
\end{array}\right|\\
\text{compute }\text{ftn}_{M}(...):\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
(q\times p\rightarrow p+\bbnum 0)\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow(x^{:M^{A}}\rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}l
\end{array}\right|\quad.
\end{align*}

\end_inset

After renaming 
\begin_inset Formula $l$
\end_inset

 to 
\begin_inset Formula $a$
\end_inset

, this is the same as the column in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:m-interchange-law-of-swap-linear-monads-left-hand-side"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
Verify the laws of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

,
\begin_inset Formula 
\[
\text{sw}_{\text{Id},M}=\text{id}\quad,\quad\quad\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad.
\]

\end_inset

for arbitrary monad morphisms 
\begin_inset Formula $\phi:L\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:M\leadsto\text{Id}$
\end_inset

.
\end_layout

\begin_layout Standard
The first law is the swap identity law, 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{\text{Id},M}\\
\text{Eq.~(\ref{eq:single-valued-monad-def-of-swap}) with }L=\text{Id}:\quad & =\begin{array}{|c||c|}
P & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{\text{Id}}\\
Q\times\text{Id}^{A} & q\times l\rightarrow(a^{:A}\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow\text{Id}}l
\end{array}\\
\text{matrix notation}:\quad & =\begin{array}{|c||c|}
P & x^{:P}\rightarrow x+\bbnum 0^{:Q\times A}\\
Q\times A & q\times a\rightarrow\bbnum 0^{:P}+q\times a
\end{array}\\
 & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Begin with the left-hand side of the second law,
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{L,M}\bef\phi\\
\text{definition of }\text{sw}_{L,M}:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}l
\end{array}\right|\gunderline{\bef\phi}\\
\text{compose with }\phi:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\bef\phi\\
q\times l\rightarrow l\triangleright\gunderline{(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\phi}
\end{array}\right|\\
\text{naturality of }\phi:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times l\rightarrow l\triangleright\phi\bef(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\quad.
\end{align*}

\end_inset

The right-hand side is
\begin_inset Formula 
\begin{align*}
 & \phi^{\uparrow M}\bef\text{sw}_{N,M}\\
 & =\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\rightarrow q\times\phi\left(l\right)
\end{array}\right|\bef\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times n\rightarrow n\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\\
\text{composition}:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times l\rightarrow n\triangleright\phi\bef(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\quad.
\end{align*}

\end_inset

Both sides of the second law are now shown to be equal.
\end_layout

\begin_layout Standard
The left-hand side of the third law is
\begin_inset Formula 
\begin{align}
 & \text{sw}_{L,M}\bef\theta^{\uparrow L}\nonumber \\
\text{compose with }\theta^{\uparrow L}:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}\bef\theta^{\uparrow L}}\\
q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\theta^{\uparrow L}
\end{array}\right|\nonumber \\
\text{naturality of }\text{pu}_{L}:\quad & =\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\theta\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright\big(a\rightarrow\theta(\bbnum 0^{:P}+q\times a)\big)^{\uparrow L}
\end{array}\right|\quad.\label{eq:linear-monads-monadic-naturality-of-swap-2}
\end{align}

\end_inset

We expect this to equal the right-hand side, which we write as
\begin_inset Formula 
\begin{align}
 & m^{:M^{L^{A}}}\rightarrow\theta(m)\nonumber \\
\text{matrix notation}:\quad & =\left\Vert \begin{array}{c}
x^{:P}\rightarrow\theta(x+\bbnum 0^{:Q\times L^{A}})\\
q\times l\rightarrow\theta(\bbnum 0^{:P}+q\times l)
\end{array}\right|\quad.\label{eq:linear-monads-monadic-naturality-of-swap-1}
\end{align}

\end_inset

Now consider each line in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) separately.
 The upper line can be transformed as
\begin_inset Formula 
\begin{align*}
 & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\theta\bef\text{pu}_{L}}\\
\text{naturality of }\theta:\quad & =(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}^{\uparrow M}}\bef\theta\\
\text{definition of }^{\uparrow M}:\quad & =x^{:P}\rightarrow\left\Vert \begin{array}{cc}
x\enskip & \bbnum 0\end{array}\right|\triangleright\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\rightarrow q\times\text{pu}_{L}l
\end{array}\right|\bef\theta\\
\text{matrix notation}:\quad & =x^{:P}\rightarrow(x+\bbnum 0^{:Q\times L^{A}})\triangleright\theta\quad.
\end{align*}

\end_inset

This is now equal to the upper line of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
To proceed with the proof for the lower line of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to evaluate the monad morphism 
\begin_inset Formula $\theta:M^{A}\rightarrow A$
\end_inset

 on a specific value of type 
\begin_inset Formula $M^{A}$
\end_inset

 of the form 
\begin_inset Formula $\bbnum 0+q\times a$
\end_inset

.
 We note that the value 
\begin_inset Formula $\theta(\bbnum 0+q\times a)$
\end_inset

 must be of type 
\begin_inset Formula $A$
\end_inset

 and must be computed in the same way for all types 
\begin_inset Formula $A$
\end_inset

, because 
\begin_inset Formula $\theta$
\end_inset

 is a natural transformation.
 It seems clear that the result cannot depend on the value 
\begin_inset Formula $q^{:Q}$
\end_inset

 since 
\begin_inset Formula $Q$
\end_inset

 is a type not related to 
\begin_inset Formula $A$
\end_inset

.
 In other words, we expect that 
\begin_inset Formula $\theta(\bbnum 0+q\times a)=a$
\end_inset

 as a consequence of naturality of 
\begin_inset Formula $\theta$
\end_inset

.
 To derive this formally, we use the trick of starting with a unit type,
 
\begin_inset Formula $\bbnum 1$
\end_inset

, and mapping it to 
\begin_inset Formula $a$
\end_inset

 within the naturality law.
 For any values 
\begin_inset Formula $q^{:Q}$
\end_inset

, 
\begin_inset Formula $a^{:A}$
\end_inset

, we define 
\begin_inset Formula 
\begin{align*}
 & m^{:P+Q\times A}\triangleq\bbnum 0^{:P}+q\times a\quad,\\
 & m_{1}^{:P+Q\times\bbnum 1}\triangleq\bbnum 0^{:P}+q\times1\quad.
\end{align*}

\end_inset

We can compute 
\begin_inset Formula $m$
\end_inset

 from 
\begin_inset Formula $m_{1}$
\end_inset

 if we replace 
\begin_inset Formula $1$
\end_inset

 by 
\begin_inset Formula $a$
\end_inset

 under the functor 
\begin_inset Formula $M$
\end_inset

.
 To write this as a formula, define the function 
\begin_inset Formula $f^{:\bbnum 1\rightarrow A}$
\end_inset

 as 
\begin_inset Formula $f\triangleq\left(\_\rightarrow a\right)$
\end_inset

 using the fixed value 
\begin_inset Formula $a$
\end_inset

.
 Then we have 
\begin_inset Formula $m=f^{\uparrow M}m_{1}$
\end_inset

.
 Now we apply both sides of the naturality law 
\begin_inset Formula $f^{\uparrow M}\bef\theta=\theta\bef f$
\end_inset

 to the value 
\begin_inset Formula $m_{1}$
\end_inset

:
\begin_inset Formula 
\[
m_{1}\triangleright f^{\uparrow M}\bef\theta=m_{1}\triangleright\theta\bef f\quad.
\]

\end_inset

Simplify the left-hand side to
\begin_inset Formula 
\[
m_{1}\triangleright f^{\uparrow M}\bef\theta=\theta(f^{\uparrow M}m_{1})=\theta(m)=\theta(\bbnum 0^{:P}+q\times a)\quad.
\]

\end_inset

Simplify the right-hand side to 
\begin_inset Formula 
\[
m_{1}\triangleright\theta\bef f=f\left(\theta\left(m_{1}\right)\right)=a\quad,
\]

\end_inset

since 
\begin_inset Formula $f$
\end_inset

 always returns 
\begin_inset Formula $a$
\end_inset

.
 Therefore 
\begin_inset Formula 
\begin{equation}
\theta(\bbnum 0^{:P}+q\times a)=a\quad.\label{eq:runner-on-linear-monads}
\end{equation}

\end_inset

We can now compute the second line in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\begin{align*}
 & q\times l\rightarrow l\triangleright\big(a\rightarrow\theta(\bbnum 0^{:P}+q\times a)\big)^{\uparrow L}\\
\text{use Eq.~(\ref{eq:runner-on-linear-monads})}:\quad & =q\times l\rightarrow l\,\gunderline{\triangleright\,\big(a\rightarrow a\big)^{\uparrow L}}\\
\text{identity law}:\quad & =q\times l\rightarrow l\quad.
\end{align*}

\end_inset

The second line in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is the same function, 
\begin_inset Formula $q\times l\rightarrow l$
\end_inset

.
\end_layout

\begin_layout Standard
This concludes the proof of the swap laws for linear monads.
 It follows that linear monads have monad transformers of composed-inside
 kind.
\end_layout

\begin_layout Subsection
Composition of transformers for linear monads
\end_layout

\begin_layout Standard
We have just shown that the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 monad 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

 has the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function that satisfies the laws necessary for a composed-inside transformer.
 The other type of linear monad is the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 monad 
\begin_inset Formula $W^{A}\triangleq Q\times\left(P+A\right)$
\end_inset

.
 Do we need to show separately that the monad 
\begin_inset Formula $W$
\end_inset

 has a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function? Actually, that follows from the stacking property of monad transforme
rs (see Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-any-number-of-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The monad 
\begin_inset Formula $W$
\end_inset

 is a functor composition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad 
\begin_inset Formula $Q\times A$
\end_inset

 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad 
\begin_inset Formula $P+A$
\end_inset

, which is the same as applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad's transformer to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad.
 Because of the transformer stacking property, the monad transformer of
 
\begin_inset Formula $W$
\end_inset

 works as composed-inside.
\end_layout

\begin_layout Standard
We can show in general that the functor composition of any two linear monads
 has a composed-inside transformer.
 Suppose 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are linear monads, so their transformers are of the composed-inside kind:
\begin_inset Formula 
\[
T_{M_{1}}^{N}=N\circ M_{1}\quad,\quad\quad T_{M_{2}}^{N}=N\circ M_{2}\quad.
\]

\end_inset

The functor composition of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be seen as a monad stack,
\begin_inset Formula 
\[
M_{1}\circ M_{2}=T_{M_{2}}^{M_{1}}\quad.
\]

\end_inset

What is the transformer for the monad 
\begin_inset Formula $M_{1}\circ M_{2}$
\end_inset

? For any foreign monad 
\begin_inset Formula $N$
\end_inset

, we have the transformer stack
\begin_inset Formula 
\[
T_{M_{2}}^{T_{M_{1}}^{N}}=T_{M_{2}}^{N\circ M_{1}}=N\circ M_{1}\circ M_{2}\quad.
\]

\end_inset

Since this is a transformer stack, it is a lawful monad transformer, as
 we have seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So, this is the monad transformer for 
\begin_inset Formula $M_{1}\circ M_{2}$
\end_inset

, and it is of the composed-inside kind.
\end_layout

\begin_layout Section
Composed-outside transformers: Rigid monads
\begin_inset CommandInset label
LatexCommand label
name "sec:transformers-rigid-monads"

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:transformers-linear-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that the composed-inside monad transformers are available only for
 a limited subset of all monads, namely the monads
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!linear
\end_layout

\end_inset

 of the form 
\begin_inset Formula $M^{A}=P+Q\times A$
\end_inset

 and 
\begin_inset Formula $M^{A}=Q\times\left(P+A\right)$
\end_inset

, called 
\begin_inset Quotes eld
\end_inset

linear
\begin_inset Quotes erd
\end_inset

.
 It turns out that the composed-
\emph on
outside
\emph default
 transformers are available for a significantly wider range of monads.
 Those monads are called 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

 because one of their general properties is having a single 
\begin_inset Quotes eld
\end_inset

shape
\begin_inset Quotes erd
\end_inset

 (Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-wrapped-unit-is-unit"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!rigid
\end_layout

\end_inset

 (There does not seem to be another already accepted name for monads of
 this kind.)
\end_layout

\begin_layout Paragraph
Definition of rigid monads
\end_layout

\begin_layout Standard
A monad 
\begin_inset Formula $R$
\end_inset

 is 
\series bold
rigid
\series default
 if it has a lawful composed-outside monad transformer, 
\begin_inset Formula $T_{R}^{M}=R\circ M$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is a foreign monad.
 
\end_layout

\begin_layout Standard
This definition does not explain what monads are rigid or how to recognize
 a non-rigid monad.
 These questions will be answered below.
\end_layout

\begin_layout Standard
Two simplest examples of rigid monads are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad, 
\begin_inset Formula 
\begin{align*}
\text{(the \texttt{Reader} monad)} & :\quad\quad R^{A}\triangleq Z\rightarrow A\quad,\\
\text{(the \texttt{Search} monad)} & :\quad\quad S^{A}\triangleq\left(A\rightarrow Z\right)\rightarrow A\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
 These monads have composed-outside transformers:
\begin_inset Formula 
\begin{align*}
\text{(the \texttt{ReaderT} transformer)} & :\quad\quad T_{R}^{M,A}\triangleq Z\rightarrow M^{A}\quad,\\
\text{(the \texttt{SearchT} transformer)} & :\quad\quad T_{S}^{M,A}\triangleq\left(M^{A}\rightarrow Z\right)\rightarrow M^{A}\quad.
\end{align*}

\end_inset

To build intuition for rigid monads, we will look at some general constructions
 that create new rigid monads or combine existing rigid monads into new
 ones.
 In this section, we will prove that the following four constructions produce
 rigid monads:
\end_layout

\begin_layout Enumerate
Choice: 
\begin_inset Formula $C^{A}\triangleq H^{A}\rightarrow A$
\end_inset

 is a rigid monad if 
\begin_inset Formula $H$
\end_inset

 is any contrafunctor.
\end_layout

\begin_layout Enumerate
Composition: 
\begin_inset Formula $P\circ R$
\end_inset

 is a rigid monad if 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 are rigid monads.
\end_layout

\begin_layout Enumerate
Product: 
\begin_inset Formula $P^{A}\times R^{A}$
\end_inset

 is a rigid monad if 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 are rigid monads.
\end_layout

\begin_layout Enumerate
Selector: 
\begin_inset Formula $S^{A}\triangleq F^{A\rightarrow R^{Q}}\rightarrow R^{A}$
\end_inset

 is a rigid monad for any rigid monad 
\begin_inset Formula $R$
\end_inset

, any functor 
\begin_inset Formula $F$
\end_inset

, and any fixed type 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\begin_layout Standard
I do not know whether these four constructions are the only possible ways
 of creating new rigid monads.
 Below I will also mention other open questions I have about rigid monads.
\end_layout

\begin_layout Subsection
Rigid monad construction 1: choice
\begin_inset CommandInset label
LatexCommand label
name "subsec:Rigid-monad-construction-1-choice"

\end_inset


\end_layout

\begin_layout Standard
The construction I call 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!choice monad
\end_layout

\end_inset

the 
\series bold
choice
\series default
 monad, 
\begin_inset Formula $R^{A}\triangleq H^{A}\rightarrow A$
\end_inset

, defines a rigid monad 
\begin_inset Formula $R$
\end_inset

 for 
\emph on
any
\emph default
 given contrafunctor 
\begin_inset Formula $H$
\end_inset

.
 
\end_layout

\begin_layout Standard
This monad chooses a value of type 
\begin_inset Formula $A$
\end_inset

 given a contrafunctor 
\begin_inset Formula $H$
\end_inset

 that may 
\emph on
consume
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

 (and presumably could check some conditions on those values).
 The contrafunctor 
\begin_inset Formula $H$
\end_inset

 could be a constant contrafunctor 
\begin_inset Formula $H^{A}\triangleq Q$
\end_inset

, a function such as 
\begin_inset Formula $H^{A}\triangleq A\rightarrow Q$
\end_inset

, or a more complicated contrafunctor.
\end_layout

\begin_layout Standard
Different choices of the contrafunctor 
\begin_inset Formula $H$
\end_inset

 give specific examples of rigid monads, such as 
\begin_inset Formula $R^{A}\triangleq\bbnum 1$
\end_inset

 (the unit monad), 
\begin_inset Formula $R^{A}\triangleq A$
\end_inset

 (the identity monad), 
\begin_inset Formula $R^{A}\triangleq Z\rightarrow A$
\end_inset

 (the reader monad), as well as the 
\series bold
selector
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
name "http://math.andrej.com/2008/11/21/"
target "http://math.andrej.com/2008/11/21/"
literal "false"

\end_inset


\end_layout

\end_inset

 monad
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Sel
\family default
 (selector monad)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
selector monad
\end_layout

\end_inset

 
\begin_inset Formula $\text{Sel}^{Q,A}\triangleq\left(A\rightarrow Q\right)\rightarrow A$
\end_inset

.
 
\end_layout

\begin_layout Standard
The search monad represents the effect of searching for a value of type
 
\begin_inset Formula $A$
\end_inset

 that satisfies a condition expressed through a function of type 
\begin_inset Formula $A\rightarrow Q$
\end_inset

.
 The simplest example of a search monad is found by setting 
\begin_inset Formula $Q\triangleq\text{Boolean}$
\end_inset

.
 One may implement a function of type 
\begin_inset Formula $\left(A\rightarrow\text{Boolean}\right)\rightarrow A$
\end_inset

 that 
\emph on
somehow
\emph default
 finds a value of type 
\begin_inset Formula $A$
\end_inset

 that might satisfy the given predicate of type 
\begin_inset Formula $A\rightarrow\text{Boolean}$
\end_inset

.
 The intention is to return a value that, if possible, satisfies the predicate.
 If no such value can be found, 
\emph on
some
\emph default
 value of type 
\begin_inset Formula $A$
\end_inset

 is still returned.
\end_layout

\begin_layout Standard
A closely related monad is the search-with-failure monad, 
\begin_inset Formula $R^{A}\triangleq\left(A\rightarrow\text{Boolean}\right)\rightarrow\bbnum 1+A$
\end_inset

.
 This (non-rigid) monad will return an empty value 
\begin_inset Formula $1+\bbnum 0^{:A}$
\end_inset

 if no value satisfing the predicate was found.
 There is a natural transformation from the search monad to the search-with-fail
ure monad, implemented by checking whether the value returned by the search
 monad does actually satisfies the predicate.
\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $H$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $M$
\end_inset

 is a monad, and denote for brevity 
\begin_inset Formula 
\[
T^{A}\triangleq R^{M^{A}}\triangleq H^{M^{A}}\rightarrow M^{A}\quad.
\]

\end_inset

We will first give a self-contained proof that 
\begin_inset Formula $T$
\end_inset

 is a monad.
 To verify the laws of monad transformers for 
\begin_inset Formula $T$
\end_inset

, we will derive the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function and verify its laws.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-choice-monad-direct-proof"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-direct-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $T^{\bullet}\triangleq R^{M^{\bullet}}\triangleq H^{M^{\bullet}}\rightarrow M^{\bullet}$
\end_inset

 is a monad if 
\begin_inset Formula $M$
\end_inset

 is any monad and 
\begin_inset Formula $H$
\end_inset

 is any contrafunctor.
 (If we set 
\begin_inset Formula $M^{A}\triangleq A$
\end_inset

, this also proves that 
\begin_inset Formula $R$
\end_inset

 itself is a monad.)
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to define the monad instance for 
\begin_inset Formula $T$
\end_inset

 and prove the identity and the associativity laws for 
\begin_inset Formula $T$
\end_inset

, assuming that the monad 
\begin_inset Formula $M$
\end_inset

 satisfies these laws.
\end_layout

\begin_layout Standard
To define the monad instance for 
\begin_inset Formula $T$
\end_inset

, it is convenient to use the Kleisli formulation of the monad.
 In this formulation, we consider Kleisli morphisms of type 
\begin_inset Formula $A\rightarrow T^{B}$
\end_inset

 and then define the Kleisli identity morphism, 
\begin_inset Formula $\text{pu}_{T}:A\rightarrow T^{A}$
\end_inset

, and the Kleisli product operation 
\begin_inset Formula $\diamond_{T}$
\end_inset

,
\begin_inset Formula 
\[
f^{:A\rightarrow T^{B}}\diamond_{T}g^{:B\rightarrow T^{C}}:A\rightarrow T^{C}\quad.
\]

\end_inset

We are then required to define the operation 
\begin_inset Formula $\diamond_{T}$
\end_inset

 and to prove identity and associativity laws for it.
\end_layout

\begin_layout Standard
We notice that since the type constructor 
\begin_inset Formula $R$
\end_inset

 is itself a function type 
\begin_inset Formula $H^{A}\rightarrow A$
\end_inset

, the type of the Kleisli morphism 
\begin_inset Formula $A\rightarrow T^{B}$
\end_inset

 is actually 
\begin_inset Formula $A\rightarrow T^{B}\triangleq A\rightarrow H^{M^{B}}\rightarrow M^{B}$
\end_inset

.
 While proving the monad laws for 
\begin_inset Formula $T$
\end_inset

, we will need to use the monad laws for 
\begin_inset Formula $M$
\end_inset

 (since 
\begin_inset Formula $M$
\end_inset

 is an arbitrary, unknown monad).
 In order to use the monad laws for 
\begin_inset Formula $M$
\end_inset

, it would be helpful if we had the Kleisli morphisms for 
\begin_inset Formula $M$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 more easily available.
 If we flip the curried arguments of the Kleisli morphism type 
\begin_inset Formula $A\rightarrow H^{M^{B}}\rightarrow M^{B}$
\end_inset

 and instead consider the 
\series bold
flipped Kleisli
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
flipped@
\begin_inset Quotes eld
\end_inset

flipped Kleisli
\begin_inset Quotes erd
\end_inset

 technique
\end_layout

\end_inset

 morphisms of type 
\begin_inset Formula $H^{M^{B}}\rightarrow A\rightarrow M^{B}$
\end_inset

, the type 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 will be easier to reason about.
 Since the type 
\begin_inset Formula $A\rightarrow H^{M^{B}}\rightarrow M^{B}$
\end_inset

 is equivalent to 
\begin_inset Formula $A\rightarrow H^{M^{B}}\rightarrow M^{B}$
\end_inset

, any laws we prove for the flipped Kleisli morphisms will yield the correspondi
ng laws for the standard Kleisli morphisms.
 The use of flipped Kleisli morphisms makes the proof significantly shorter.
\end_layout

\begin_layout Standard
We temporarily denote by 
\begin_inset Formula $\tilde{\text{pu}}_{T}$
\end_inset

 and 
\begin_inset Formula $\tilde{\diamond}_{T}$
\end_inset

 the flipped Kleisli operations:
\begin_inset Formula 
\begin{align*}
\tilde{\text{pu}}_{T} & :\ H^{M^{A}}\rightarrow A\rightarrow M^{A}\\
f^{:H^{M^{B}}\rightarrow A\rightarrow M^{B}}\tilde{\diamond}_{T}g^{:H^{M^{C}}\rightarrow B\rightarrow M^{C}} & :\ H^{M^{C}}\rightarrow A\rightarrow M^{C}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To define the operations 
\begin_inset Formula $\tilde{\text{pu}}_{T}$
\end_inset

 and 
\begin_inset Formula $\tilde{\diamond}_{T}$
\end_inset

, we may use the methods 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

 as well as the Kleisli product 
\begin_inset Formula $\diamond_{M}$
\end_inset

 for the given monad 
\begin_inset Formula $M$
\end_inset

.
 The definitions are
\begin_inset Formula 
\begin{align*}
\tilde{\text{pu}}_{T} & =\_\rightarrow\text{pu}_{M}\quad\text{(the argument is unused)}\quad,\\
f\tilde{\diamond}_{T}g & =q\rightarrow\left(f\,p\right)\diamond_{M}\left(g\,q\right)\quad\text{where}\\
 & \quad p^{:H^{M^{B}}}=\left(\text{flm}_{M}\left(g\,q\right)\right)^{\downarrow H}q\quad.
\end{align*}

\end_inset

This definition works by using the Kleisli product 
\begin_inset Formula $\diamond_{M}$
\end_inset

 on values 
\begin_inset Formula $f\,p:A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $g\,q:B\rightarrow M^{C}$
\end_inset

.
 To obtain a value 
\begin_inset Formula $p:H^{M^{B}}$
\end_inset

, we use the function 
\begin_inset Formula $\text{flm}_{M}\left(g\,q\right):M^{B}\rightarrow M^{C}$
\end_inset

 to 
\begin_inset Formula $H$
\end_inset

-contramap 
\begin_inset Formula $q:H^{M^{C}}$
\end_inset

 into 
\begin_inset Formula $p:H^{M^{B}}$
\end_inset

.
\end_layout

\begin_layout Standard
Written as a single expression, the definition of 
\begin_inset Formula $\tilde{\diamond}_{T}$
\end_inset

 is
\begin_inset Formula 
\begin{equation}
f\tilde{\diamond}_{T}g=q\rightarrow f\left(\left(\text{flm}_{M}\left(g\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(g\,q\right)\quad.\label{eq:def-flipped-kleisli}
\end{equation}

\end_inset

Checking the left identity law:
\begin_inset Formula 
\begin{align*}
 & \tilde{\text{pu}}_{T}\tilde{\diamond}_{T}g\\
\text{definition of }\tilde{\diamond}_{T}:\quad & =q\rightarrow\gunderline{\tilde{\text{pu}}_{T}\left(\left(\text{flm}_{M}\left(g\,q\right)\right)^{\downarrow H}q\right)}\diamond_{M}\left(g\,q\right)\\
\text{definition of }\tilde{\text{pu}}_{T}:\quad & =q\rightarrow\gunderline{\text{pu}_{M}\diamond_{M}}g\,q\\
\text{left identity law for }M:\quad & =q\rightarrow g\,q\\
\text{function expansion}:\quad & =g
\end{align*}

\end_inset

Checking the right identity law:
\begin_inset Formula 
\begin{align*}
 & f\tilde{\diamond}_{T}\tilde{\text{pu}}_{T}\\
\text{definition of }\tilde{\diamond}_{T}:\quad & =q\rightarrow f\left(\left(\text{flm}_{M}\left(\tilde{\text{pu}}_{T}q\right)\right)^{\downarrow H}q\right)\diamond_{M}\gunderline{\left(\tilde{\text{pu}}_{T}q\right)}\\
\text{definition of }\tilde{\text{pu}}_{T}:\quad & =q\rightarrow f\left(\left(\text{flm}_{M}\left(\text{pu}_{M}\right)\right)^{\downarrow H}q\right)\gunderline{\diamond_{M}\text{pu}_{M}}\\
\text{right identity law for }M:\quad & =q\rightarrow f\gunderline{\left(\left(\text{id}\right)^{\downarrow H}q\right)}\\
\text{identity law for }H:\quad & =q\rightarrow f\,q\\
\text{function expansion}:\quad & =f
\end{align*}

\end_inset

Checking the associativity law: 
\begin_inset Formula $\left(f\tilde{\diamond}_{T}g\right)\tilde{\diamond}_{T}h$
\end_inset

 must equal 
\begin_inset Formula $f\tilde{\diamond}_{T}\left(g\tilde{\diamond}_{T}h\right)$
\end_inset

.
 We have
\begin_inset Formula 
\begin{align*}
 & \left(f\tilde{\diamond}_{T}g\right)\tilde{\diamond}_{T}h\\
 & =\left(s\rightarrow f\left(\left(\text{flm}_{M}\left(g\,s\right)\right)^{\downarrow H}s\right)\diamond_{M}\left(g\,s\right)\right)\tilde{\diamond}_{T}h\\
 & =q\rightarrow f\left(\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r\right)\diamond_{M}\left(g\,r\right)\diamond_{M}\left(h\,q\right)\quad\text{where}\\
 & \quad\quad\quad r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad;
\end{align*}

\end_inset

while 
\begin_inset Formula 
\begin{align*}
 & f\tilde{\diamond}_{T}\left(g\tilde{\diamond}_{T}h\right)\\
 & =f\tilde{\diamond}_{T}\left(q\rightarrow g\left(\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(h\,q\right)\right)\\
 & =q\rightarrow f\left(\left(\text{flm}_{M}\,k\right)^{\downarrow H}q\right)\diamond_{M}u\quad\text{where}\\
 & \quad\quad\quad r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad\text{and}\\
 & \quad\quad\quad u\triangleq\left(g\,r\right)\diamond_{M}\left(h\,q\right)\quad.
\end{align*}

\end_inset

It remains to show that the following two expressions are equal,
\begin_inset Formula 
\begin{align*}
 & f\left(\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r\right)\diamond_{M}\left(g\,r\right)\diamond_{M}\left(h\,q\right)\quad\text{and}\\
 & f\left(\left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(g\,r\right)\diamond_{M}\left(h\,q\right),\quad\text{where}\\
 & \quad\quad\quad r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad.
\end{align*}

\end_inset

These two expressions differ only by the following sub-expressions, 
\begin_inset Formula 
\[
\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r
\]

\end_inset

and 
\begin_inset Formula 
\[
\left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\quad,
\]

\end_inset

where 
\begin_inset Formula $r\triangleq\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q$
\end_inset

.
 Writing out the value 
\begin_inset Formula $r$
\end_inset

 in the last argument of 
\begin_inset Formula $\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}r$
\end_inset

 but leaving 
\begin_inset Formula $r$
\end_inset

 unexpanded everywhere else, we now rewrite the differing sub-expressions
 as
\begin_inset Formula 
\begin{align*}
 & \left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\quad\text{and}\\
 & \left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\quad.
\end{align*}

\end_inset

Now it becomes apparent that we need to put the two 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{flm}_{M}$
\end_inset


\begin_inset Quotes erd
\end_inset

s closer together and to combine them by using the associativity law of
 the monad 
\begin_inset Formula $M$
\end_inset

.
 Then we can rewrite the first sub-expression and transform it into the
 second one:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\left(\text{flm}_{M}\left(g\,r\right)\right)^{\downarrow H}\left(\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}}q\\
\text{composition law for }H:\quad & =\left(\text{flm}_{M}\left(g\,r\right)\bef\text{flm}_{M}\left(h\,q\right)\right)^{\downarrow H}q\\
\text{associativity law for }M:\quad & =\gunderline{\left(\text{flm}_{M}\left(\left(g\,r\right)\bef\text{flm}_{M}\left(h\,q\right)\right)\right)}^{\downarrow H}q\\
\text{definition of }\diamond_{M}\text{ via }\text{flm}_{M}:\quad & =\left(\text{flm}_{M}\left(\left(g\,r\right)\diamond_{M}\left(h\,q\right)\right)\right)^{\downarrow H}q\quad.
\end{align*}

\end_inset

This proves the associativity law for 
\begin_inset Formula $\tilde{\diamond}_{T}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-choice-monad-definition-of-flm"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-definition-of-flm"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The monad methods for 
\begin_inset Formula $T$
\end_inset

 defined in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-direct-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be written equivalently as 
\begin_inset Formula 
\begin{align}
\text{pu}_{T} & (a^{:A}):\ H^{M^{A}}\rightarrow M^{A}\quad,\nonumber \\
\text{pu}_{T} & (a)\triangleq\left(\_\rightarrow\text{pu}_{M}a\right)\quad;\nonumber \\
\text{flm}_{T} & \big(f^{:A\rightarrow H^{M^{B}}\rightarrow M^{B}}\big):\ \big(H^{M^{A}}\rightarrow M^{A}\big)\rightarrow H^{M^{B}}\rightarrow M^{B}\quad,\nonumber \\
\text{flm}_{T} & f\triangleq t^{:R^{M^{A}}}\rightarrow q^{:H^{M^{B}}}\rightarrow\big(\text{flm}_{M}(x^{:A}\rightarrow f\,x\,q)\big)^{\uparrow R}t\,q\quad.\label{eq:rigid-monad-flm-T-def}
\end{align}

\end_inset

Expressed through 
\begin_inset Formula $R$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method, which is implemented as
\begin_inset Formula 
\begin{equation}
\text{flm}_{R}g^{:A\rightarrow R^{B}}=t^{:R^{A}}\rightarrow q^{:H^{B}}\rightarrow(x^{:A}\rightarrow g\,x\,q)^{\uparrow R}t\,q\quad,\label{eq:rigid-monad-flm-R-def}
\end{equation}

\end_inset

the method 
\begin_inset Formula $\text{flm}_{T}$
\end_inset

 can be written as
\begin_inset Formula 
\begin{equation}
\text{flm}_{T}f=\text{flm}_{R}\left(y\rightarrow q\rightarrow\text{flm}_{M}(x\rightarrow f\,x\,q)\,y\right)\quad.\label{eq:rigid-monad-def-flm-t-via-flm-r}
\end{equation}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The definition of 
\begin_inset Formula $\tilde{\diamond}_{T}$
\end_inset

 in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-direct-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 used the flipped types of Kleisli morphisms, which is not the standard
 way of defining the methods of a monad.
 To restore the standard type signatures, we need to unflip the arguments:
\begin_inset Formula 
\begin{align*}
 & f^{:A\rightarrow H^{M^{B}}\rightarrow M^{B}}\diamond_{T}g^{:B\rightarrow H^{M^{C}}\rightarrow M^{C}}:\ A\rightarrow H^{M^{C}}\rightarrow M^{C}\quad;\\
 & f\diamond_{T}g=t\rightarrow q\rightarrow\left(\tilde{f}\left(\left(\text{flm}_{M}\left(b\rightarrow g\,b\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(b\rightarrow g\,b\,q\right)\right)t\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $\tilde{f}\triangleq h\rightarrow k\rightarrow f\,k\,h$
\end_inset

 is the flipped version of 
\begin_inset Formula $f$
\end_inset

.
 To replace 
\begin_inset Formula $\diamond_{M}$
\end_inset

 by 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

, express 
\begin_inset Formula $x\diamond_{M}y=x\bef\text{flm}_{M}y$
\end_inset

 to find
\begin_inset Formula 
\[
f\diamond_{T}g=t\rightarrow q\rightarrow\left(\tilde{f}\left(p^{\downarrow H}q\right)\bef p\right)t\quad\text{where }p=\text{flm}_{M}\left(x\rightarrow g\,x\,q\right)\quad.
\]

\end_inset

To obtain an implementation of 
\begin_inset Formula $\text{flm}_{T}$
\end_inset

, express 
\begin_inset Formula $\text{flm}_{T}$
\end_inset

 through 
\begin_inset Formula $\diamond_{T}$
\end_inset

 as 
\begin_inset Formula 
\[
\text{flm}_{T}g^{:A\rightarrow T^{B}}=\text{id}^{:T^{A}\rightarrow T^{A}}\diamond_{T}g\quad.
\]

\end_inset

Now we need to substitute 
\begin_inset Formula $f^{:T^{A}\rightarrow T^{A}}=\text{id}$
\end_inset

 into 
\begin_inset Formula $f\diamond_{T}g$
\end_inset

.
 Noting that 
\begin_inset Formula $\tilde{f}$
\end_inset

 will then become 
\begin_inset Formula 
\[
\tilde{f}=\left(h\rightarrow k\rightarrow\text{id}\,k\,h\right)=\left(h\rightarrow k\rightarrow k\,h\right)\quad,
\]

\end_inset

we get
\begin_inset Formula 
\begin{align*}
 & \text{flm}_{T}g^{:A\rightarrow T^{B}}=\text{id}\bef\text{flm}_{T}g\\
\text{definition of }\diamond_{T}:\quad & =t^{:T^{A}}\rightarrow q^{H^{M^{B}}}\rightarrow\left(\tilde{f}\left(p^{\downarrow H}q\right)\bef p\right)t\\
 & \quad\quad\text{where }p\triangleq\text{flm}_{M}\left(x\rightarrow g\,x\,q\right)\\
\text{substitute }f=\text{id}:\quad & =t\rightarrow q\rightarrow\left(\left(h\rightarrow k\rightarrow k\,h\right)\left(p^{\downarrow H}q\right)\bef p\right)t\\
\text{apply }k\text{ to }p^{\downarrow H}q:\quad & =t\rightarrow q\rightarrow\left(\left(k\rightarrow k\left(p^{\downarrow H}q\right)\right)\bef p\right)t\\
\text{definition of }\bef:\quad & =t\rightarrow q\rightarrow p\left(t\left(p^{\downarrow H}q\right)\right)\quad.
\end{align*}

\end_inset

By definition of the functor 
\begin_inset Formula $R^{A}\triangleq H^{A}\rightarrow A$
\end_inset

, we raise any function 
\begin_inset Formula $p^{:A\rightarrow B}$
\end_inset

 into 
\begin_inset Formula $R$
\end_inset

 as 
\begin_inset Formula 
\begin{align*}
p^{\uparrow R} & :\left(H^{A}\rightarrow A\right)\rightarrow H^{B}\rightarrow B\quad,\\
p^{\uparrow R}r^{H^{A}\rightarrow A} & \triangleq p^{\downarrow H}\bef r\bef p\\
 & =q^{H^{B}}\rightarrow p\left(r\left(p^{\downarrow H}q\right)\right)\quad.
\end{align*}

\end_inset

Finally, renaming 
\begin_inset Formula $g$
\end_inset

 to 
\begin_inset Formula $f$
\end_inset

, we obtain the desired code,
\begin_inset Formula 
\[
\text{flm}_{T}f=t\rightarrow q\rightarrow p^{\uparrow R}t\,q\quad\text{where }p\triangleq\text{flm}_{M}\left(x\rightarrow f\,x\,q\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To express 
\begin_inset Formula $\text{flm}_{T}$
\end_inset

 via 
\begin_inset Formula $\text{flm}_{R}$
\end_inset

, we just need to choose the value of 
\begin_inset Formula $g$
\end_inset

 such that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-R-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes equal to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-T-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Comparing these two expressions, we find that we need
\begin_inset Formula 
\[
\text{flm}_{M}(x\rightarrow f\,x\,q)=(y\rightarrow g\,y\,q)\quad.
\]

\end_inset

This is achieved if we define 
\begin_inset Formula $g\,y\,q=\text{flm}_{M}(x^{:A}\rightarrow f\,x\,q)\,y$
\end_inset

, or equivalently 
\begin_inset Formula 
\[
g=y\rightarrow q\rightarrow\text{flm}_{M}(x\rightarrow f\,x\,q)\,y\quad.
\]

\end_inset

This gives the desired Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-def-flm-t-via-flm-r"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-choice-monad-flatten-swap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-flatten-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The monad 
\begin_inset Formula $T$
\end_inset

 has the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 defined by
\begin_inset Formula 
\begin{align}
\text{ftn}_{T} & =t^{:T^{T^{A}}}\rightarrow q^{:H^{M^{A}}}\rightarrow q\triangleright\bigg(t\triangleright\big(\text{flm}_{M}(x^{:R^{M^{A}}}\rightarrow x\,q)\big)^{\uparrow R}\bigg)\quad,\label{eq:rigid-monad-def-of-ftn-t-via-forward}\\
\text{sw}_{R,M} & =m^{:M^{R^{A}}}\rightarrow q^{:H^{M^{A}}}\rightarrow\big(r^{:R^{A}}\rightarrow r(\text{pu}_{M}^{\downarrow H}q)\big)^{\uparrow M}m\quad.\label{eq:rigid-monad-short-formula-for-swap}
\end{align}

\end_inset

These functions are computationally equivalent (can be derived from each
 other).
 In the 
\begin_inset Formula $\triangleright$
\end_inset

-notation, the formula for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 is
\begin_inset Formula 
\begin{equation}
q\triangleright\big(m\triangleright\text{sw}_{R,M}\big)=m\triangleright(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}\quad.\label{eq:rigid-monad-1-forward-formula-for-swap}
\end{equation}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-T-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the relationship 
\begin_inset Formula $\text{ftn}_{T}=\text{flm}_{T}\text{id}^{:T^{A}\rightarrow T^{A}}$
\end_inset

, we find
\begin_inset Formula 
\begin{align*}
\text{ftn}_{T}t^{:T^{T^{A}}} & =\gunderline{\text{flm}_{T}}(\text{id})\,t\\
\text{use Eq.~(\ref{eq:rigid-monad-flm-T-def})}:\quad & =q\rightarrow\big(\text{flm}_{M}(x^{:A}\rightarrow f\,x\,q)\big)^{\uparrow R}\gunderline{t\,q}\\
\text{definition of }\triangleright:\quad & =q\rightarrow\gunderline{q\triangleright\big(t\triangleright\big(}\text{flm}_{M}(x^{:A}\rightarrow f\,x\,q)\big)^{\uparrow R}\big)\quad.
\end{align*}

\end_inset

Using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-def-flm-t-via-flm-r"
plural "false"
caps "false"
noprefix "false"

\end_inset

) instead of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-T-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we get
\begin_inset Formula 
\begin{align*}
\text{ftn}_{T} & =\text{flm}_{T}(\text{id})\\
 & =\text{flm}_{R}\left(y\rightarrow q\rightarrow\text{flm}_{M}(x\rightarrow x\,q)\,y\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Deriving the formulas for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset


\end_layout

\begin_layout Standard
We start with 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 as just obtained and substitute into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
\text{sw}_{R,M}(m) & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\gunderline{\text{ftn}_{T}}\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-def-flm-t-via-flm-r})}:\quad & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\text{flm}_{R}}\left(y\rightarrow q\rightarrow\text{flm}_{M}(x\rightarrow x\,q)\,y\right)\nonumber \\
\text{left identity law of }R:\quad & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\gunderline{\bef}\big(y\rightarrow q\rightarrow\text{flm}_{M}(x\rightarrow x\,q)\gunderline{\,y}\big)\nonumber \\
\triangleright\text{ notation}:\quad & =m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\gunderline{\triangleright\big(y\rightarrow}q\rightarrow\gunderline y\triangleright\text{flm}_{M}(x\rightarrow x\,q)\big)\\
\text{apply to argument }y:\quad & =q\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\triangleright\gunderline{\text{flm}_{M}}\left(x\rightarrow x\,q\right)\nonumber \\
\text{express }\text{flm}_{M}\text{ via }\text{ftn}_{M}:\quad & =q\rightarrow m\triangleright\gunderline{\text{pu}_{M}^{\uparrow R\uparrow M}\bef(x\rightarrow x\,q)^{\uparrow M}}\bef\text{ftn}_{M}\nonumber \\
\text{composition law of }M:\quad & =q\rightarrow m\triangleright\big(\text{pu}_{M}^{\uparrow R}\bef(x\rightarrow x\,q)\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-swap-derivation2}
\end{align}

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
To derive the formula for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

, we start with 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 as just obtained and substitute into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
 & \text{sw}_{R,M}(m)=m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\gunderline{\bef\text{ftn}_{T}}\nonumber \\
\triangleright\text{ notation}:\quad & =\big(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\big)\triangleright\gunderline{\text{ftn}_{T}}\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-def-of-ftn-t-via-forward})}:\quad & =q\rightarrow q\triangleright\bigg(\big(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\gunderline{\big)\triangleright\big(}\text{flm}_{M}(x\rightarrow x\,q)\big)^{\uparrow R}\bigg)\nonumber \\
\triangleright\text{ notation}:\quad & =q\rightarrow q\triangleright\bigg(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\big(\text{flm}_{M}(x\rightarrow x\,q)\big)^{\uparrow R}}\bigg)\nonumber \\
\text{pu}_{R}\text{'s naturality}:\quad & =q\rightarrow q\triangleright\bigg(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{flm}_{M}(x\rightarrow x\,q)\bef\text{pu}_{R}\bigg)\quad.\label{eq:rigid-monad-swap-derivation1}
\end{align}

\end_inset

To proceed, we need to use the definition of 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 written as 
\begin_inset Formula $\text{pu}_{R}x\,y=x$
\end_inset

, or in the pipe notation, 
\begin_inset Formula 
\[
y\triangleright\left(x\triangleright\text{pu}_{R}\right)=x\quad.
\]

\end_inset

With this simplification at hand, we continue from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-swap-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\begin{align*}
\text{Eq.~(\ref{eq:rigid-monad-swap-derivation1})}:\quad & q\rightarrow q\triangleright\bigg(\big(m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{flm}_{M}(x\rightarrow x\,q)\gunderline{\big)\triangleright\text{pu}_{R}}\bigg)\\
\text{use Eq.~(\ref{eq:rigid-monad-pure-t-simplification})}:\quad & =q\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{flm}_{M}(x\rightarrow x\,q)}\\
\text{express }\text{flm}_{M}\text{ via }\text{ftn}_{M}:\quad & =q\rightarrow m\triangleright\gunderline{\text{pu}_{M}^{\uparrow R\uparrow M}\bef(x\rightarrow x\,q)^{\uparrow M}}\bef\text{ftn}_{M}\\
\text{composition law of }M:\quad & =q\rightarrow m\triangleright\big(\text{pu}_{M}^{\uparrow R}\bef(x\rightarrow x\,q)\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset

It appears that simplifying this expression requires to rewrite the function
 
\begin_inset Formula $\text{pu}_{M}^{\uparrow R}\bef(x\rightarrow x\,q)$
\end_inset

.
 To proceed further, we need to use the definition of raising a function
 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to the functor 
\begin_inset Formula $R$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow R}\triangleq r^{:R^{A}}\rightarrow f^{\downarrow H}\bef r\bef f\quad,
\]

\end_inset

so we can write
\begin_inset Formula 
\begin{align}
 & \text{pu}_{M}^{\uparrow R}\bef(x\rightarrow x\,q)\nonumber \\
\text{function composition}:\quad & =r\rightarrow\gunderline{\text{pu}_{M}^{\uparrow R}r\,q}\nonumber \\
\text{definition of }^{\uparrow R}:\quad & =\gunderline{r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\bef}\text{pu}_{M}\nonumber \\
\text{forward composition}:\quad & =\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\bef\text{pu}_{M}\quad.\label{eq:rigid-monad-swap-derivation3}
\end{align}

\end_inset

In deriving Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-swap-derivation3"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we used the general property of the forward composition,
\begin_inset Formula 
\[
x\rightarrow y\triangleright f(x,y)\bef g\quad=\quad\left(x\rightarrow y\triangleright f(x,y)\right)\bef g\quad,
\]

\end_inset

where 
\begin_inset Formula $g$
\end_inset

 must not depend on 
\begin_inset Formula $x$
\end_inset

 or 
\begin_inset Formula $y$
\end_inset

.
 We can now rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-swap-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\begin{align*}
 & q\rightarrow m\triangleright\big(\gunderline{\text{pu}_{M}^{\uparrow R}\bef(x\rightarrow x\,q)}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
\text{use Eq.~(\ref{eq:rigid-monad-swap-derivation3})}:\quad & =q\rightarrow m\triangleright\big(\gunderline{(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\bef\text{pu}_{M}}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
\text{functor composition for }M:\quad & =q\rightarrow m\triangleright\big((r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\bef\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\\
\text{identity law of }M:\quad & =q\rightarrow\gunderline{m\triangleright\big(}(r\rightarrow\gunderline{q\triangleright\text{pu}_{M}^{\downarrow H}\bef r})\big)^{\uparrow M}\\
\triangleright\text{ notation}:\quad & =q\rightarrow\big(r\rightarrow r(\text{pu}_{M}^{\downarrow H}q)\big)^{\uparrow M}m\quad.
\end{align*}

\end_inset

The last expression coincides with Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-1-forward-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) follows by applying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the arguments 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 To make the computation clearer, we rename the bound variables 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 inside Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $m_{1}$
\end_inset

 and 
\begin_inset Formula $q_{1}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(\gunderline{m\triangleright\big(m_{1}}\rightarrow q_{1}\rightarrow\big(r\rightarrow r(\text{pu}_{M}^{\downarrow H}q_{1})\big)^{\uparrow M}\gunderline{m_{1}}\big)\big)\\
\text{apply to argument }m:\quad & =\gunderline{q\triangleright\big(q_{1}}\rightarrow m\triangleright\big(r\rightarrow r(\text{pu}_{M}^{\downarrow H}\gunderline{q_{1}})\big)^{\uparrow M}\big)\\
\text{apply to argument }q:\quad & =m\triangleright\big(r\rightarrow\gunderline{r(\text{pu}_{M}^{\downarrow H}q)}\big)^{\uparrow M}\\
\triangleright\text{ notation}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Deriving 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 from 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset


\end_layout

\begin_layout Standard
Given the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we can recover the original 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 function from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-def-of-ftn-t-via-forward"
plural "false"
caps "false"
noprefix "false"

\end_inset

) via the standard formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

), 
\begin_inset Formula $\text{ftn}_{T}=\text{sw}^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{M}^{\uparrow R}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{sw}^{\uparrow R}\bef\gunderline{\text{ftn}_{R}\bef\text{ftn}_{M}^{\uparrow R}}\nonumber \\
\text{naturality of }\text{ftn}_{R}:\quad & =\gunderline{\text{sw}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow R\uparrow R}}\bef\text{ftn}_{R}\nonumber \\
\text{composition under }R:\quad & =\big(\text{sw}\bef\text{ftn}_{M}^{\uparrow R}\gunderline{\big)^{\uparrow R}\bef\text{ftn}_{R}}\nonumber \\
\text{relating }\text{flm}_{R}\text{ and }\text{ftn}_{R}:\quad & =\gunderline{\text{flm}_{R}(}\text{sw}\bef\text{ftn}_{M}^{\uparrow R})\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-flm-R-def})}:\quad & =t\rightarrow q\rightarrow(x^{:A}\rightarrow(\text{sw}\bef\text{ftn}_{M}^{\uparrow R})\,x\,q)^{\uparrow R}\,t\,q\quad.\label{eq:rigid-monad-swap-ftn-derivation-4a}
\end{align}

\end_inset

To proceed, we need to transform 
\begin_inset Formula $\text{sw}\bef\text{ftn}_{M}^{\uparrow R}$
\end_inset

 in some way:
\begin_inset Formula 
\begin{align}
 & \text{sw}\bef\text{ftn}_{M}^{\uparrow R}\nonumber \\
\text{definitions}:\quad & =\big(m\rightarrow q\rightarrow m\triangleright\big((r\rightarrow\gunderline q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef(\gunderline{r\rightarrow\text{ftn}_{M}^{\downarrow H}\bef r\bef\text{ftn}_{M}})\nonumber \\
\text{composition}:\quad & =m\rightarrow\gunderline{\text{ftn}_{M}^{\downarrow H}}\bef\big(q\rightarrow m\triangleright\big((r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\nonumber \\
\text{expansion}:\quad & =m\rightarrow\big(q\rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}}\big)\bef\big(q\rightarrow m\triangleright\big((r\rightarrow\gunderline q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\nonumber \\
\text{composition}:\quad & =m\rightarrow\big(q\rightarrow m\triangleright\big((r\rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-swap-ftn-derivation4}
\end{align}

\end_inset

We can transform the sub-expression 
\begin_inset Formula $(r\rightarrow q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}\bef r)$
\end_inset

 to
\begin_inset Formula 
\begin{align}
\triangleright\text{ notation}:\quad & r\rightarrow q\triangleright\gunderline{\text{ftn}_{M}^{\downarrow H}\bef\text{pu}_{M}^{\downarrow H}}\bef r\nonumber \\
\text{composition law of }H:\quad & =r\rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})^{\downarrow H}\bef r\nonumber \\
\text{left identity law of }M:\quad & =r\rightarrow\gunderline{q\triangleright r}\nonumber \\
\triangleright\text{ notation}:\quad & =r\rightarrow r(q)\quad.\label{eq:rigid-monad-swap-ftn-derivation5}
\end{align}

\end_inset

Using this simplification, we continue transforming Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-swap-ftn-derivation4"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\begin{align*}
 & m\rightarrow\big(q\rightarrow m\triangleright\big((r\rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}\bef r})\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\\
\text{use Eq.~(\ref{eq:rigid-monad-swap-ftn-derivation5})}:\quad & =m\rightarrow\gunderline{\big(}q\rightarrow m\triangleright(r\rightarrow r(q))^{\uparrow M}\gunderline{\big)\bef}\text{ftn}_{M}\\
\text{composition}:\quad & =m\rightarrow q\rightarrow m\triangleright(r\rightarrow r(q)\gunderline{)^{\uparrow M}\bef\text{ftn}_{M}}\\
\text{relating }\text{flm}_{M}\text{ and }\text{ftn}_{M}:\quad & =m\rightarrow q\rightarrow\text{flm}_{M}\left(r\rightarrow r(q)\right)m\quad.
\end{align*}

\end_inset

Substituting this instead of 
\begin_inset Formula $\text{sw}\bef\text{ftn}_{M}^{\uparrow R}$
\end_inset

 into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-swap-ftn-derivation-4a"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we get
\begin_inset Formula 
\begin{align*}
 & \quad t\rightarrow q\rightarrow(x\rightarrow(\gunderline{\text{sw}\bef\text{ftn}_{M}^{\uparrow R}})\,x\,q)^{\uparrow R}\,t\,q\\
 & =t\rightarrow q\rightarrow(x\rightarrow\text{flm}_{M}\left(r\rightarrow r(q)\right)x)^{\uparrow R}\,t\,q\quad.
\end{align*}

\end_inset

The last expression is the same as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-def-of-ftn-t-via-forward"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-swap-laws-rigid-monad"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-swap-laws-rigid-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Without assuming the monad laws for the function 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

, the laws in Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 hold for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
After replacing the base monad 
\begin_inset Formula $L$
\end_inset

 by 
\begin_inset Formula $R$
\end_inset

, the required laws are
\begin_inset Formula 
\begin{align*}
\text{pu}_{R}^{\uparrow M}\bef\text{sw}=\text{pu}_{R}\quad, & \quad\quad\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow R}\quad,\\
\text{ftn}_{R}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow R}\bef\text{ftn}_{R}\quad, & \quad\quad\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow R}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Proof of the inner-identity law
\end_layout

\begin_layout Standard
Compute
\begin_inset Formula 
\begin{align}
 & \text{pu}_{R}^{\uparrow M}\bef\gunderline{\text{sw}}\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})}:\quad & =\big(m\rightarrow\gunderline{m\triangleright\text{pu}_{R}^{\uparrow M}}\big)\bef\big(m\rightarrow q\rightarrow\gunderline m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\big)\nonumber \\
\text{function composition}:\quad & =m\rightarrow q\rightarrow m\triangleright\gunderline{\text{pu}_{R}^{\uparrow M}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}}\nonumber \\
\text{functor law of }M:\quad & =m\rightarrow q\rightarrow m\triangleright\big(\text{pu}_{R}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}\quad.\label{eq:swap-laws-derivation1a}
\end{align}

\end_inset

To proceed, we simplify the expression 
\begin_inset Formula $\text{pu}_{R}\bef(r\rightarrow...)$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{pu}_{R}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\nonumber \\
\text{argument expansion}:\quad & =(m\rightarrow m\triangleright\text{pu}_{R})\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright r\big)\nonumber \\
\text{function composition}:\quad & =m\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\left(m\triangleright\text{pu}_{R}\right)\quad.\label{eq:swap-laws-derivation1}
\end{align}

\end_inset

We now have to use the definition of 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

, which is 
\begin_inset Formula $\text{pu}_{R}=x\rightarrow y\rightarrow x$
\end_inset

, or in the pipe notation, 
\begin_inset Formula 
\begin{equation}
y\triangleright\left(x\triangleright\text{pu}_{R}\right)=x\quad.\label{eq:rigid-monad-pure-t-simplification-1}
\end{equation}

\end_inset

With this simplification at hand, we continue from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-laws-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to
\begin_inset Formula 
\begin{align*}
 & m\rightarrow\gunderline{q\triangleright\text{pu}_{M}^{\downarrow H}}\triangleright\left(m\triangleright\text{pu}_{R}\right)\\
\text{use Eq.~(\ref{eq:rigid-monad-pure-t-simplification-1})}:\quad & =m\rightarrow m=\text{id}\quad.
\end{align*}

\end_inset

Therefore, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-laws-derivation1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes
\begin_inset Formula 
\begin{align*}
 & m\rightarrow q\rightarrow m\triangleright\gunderline{\big(\text{pu}_{R}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}}\\
 & =(m\rightarrow q\rightarrow\gunderline{m\triangleright\text{id}})\\
 & =(m\rightarrow q\rightarrow m)=\text{pu}_{R}\quad.
\end{align*}

\end_inset

This proves the inner-identity law.
\end_layout

\begin_layout Paragraph
Proof of the outer-identity law
\end_layout

\begin_layout Standard
The left-hand side of this law is
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}\bef\gunderline{\text{sw}}\\
\text{Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})}:\quad & =\big(m\rightarrow\gunderline{m\triangleright\text{pu}_{M}}\big)\bef\big(m\rightarrow q\rightarrow\gunderline m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\big)\\
\text{function composition}:\quad & =m\rightarrow q\rightarrow m\triangleright\gunderline{\text{pu}_{M}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}}\\
\text{naturality of }\text{pu}_{M}:\quad & =m\rightarrow q\rightarrow m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\bef\text{pu}_{M}\\
\triangleright\text{ notation}:\quad & =m\rightarrow q\rightarrow\gunderline{m\triangleright\big(r\rightarrow}q\triangleright\text{pu}_{M}^{\downarrow H}\bef\gunderline r\bef\text{pu}_{M}\big)\\
\text{apply function to }m:\quad & =m\rightarrow\gunderline{q\rightarrow q}\triangleright\text{pu}_{M}^{\downarrow H}\bef m\bef\text{pu}_{M}\\
\text{argument expansion}:\quad & =m\rightarrow\text{pu}_{M}^{\downarrow H}\bef m\bef\text{pu}_{M}\\
\text{definition of }{}^{\uparrow R}:\quad & =\text{pu}_{M}^{\uparrow R}\quad.
\end{align*}

\end_inset

This is equal to the right-hand side of the law.
\end_layout

\begin_layout Paragraph
Proof of the inner-interchange law
\end_layout

\begin_layout Standard
The law is written as
\begin_inset Formula 
\begin{equation}
\vspace{-0.25cm}\text{ftn}_{R}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow R}\bef\text{ftn}_{R}\quad.\label{eq:swap-law-3-formulation-R-M}
\end{equation}

\end_inset

We will apply both sides of the law to arbitrary 
\begin_inset Formula $m^{:M^{R^{R^{A}}}}$
\end_inset

 and 
\begin_inset Formula $q^{:H^{M^{A}}}$
\end_inset

, and transform both sides to the same expression.
 
\end_layout

\begin_layout Standard
Below, we will need a simplified formula for 
\begin_inset Formula $\text{ftn}_{R}$
\end_inset

 derived from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-R-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
\text{ftn}_{R} & =\text{flm}_{R}(\text{id})\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-flm-R-def})}:\quad & =t\rightarrow q\rightarrow(x\rightarrow x\,q)^{\uparrow R}t\,q\nonumber \\
\text{definition of }^{\uparrow R}:\quad & =t\rightarrow q\rightarrow\gunderline{\big(r\rightarrow}(x\rightarrow x\,q)^{\downarrow H}\bef r\bef(x\rightarrow x\,)\gunderline{\big)\,t}\,q\nonumber \\
\text{apply to argument}:\quad & =t\rightarrow q\rightarrow\big((x\rightarrow q\triangleright x)^{\downarrow H}\bef t\bef(x\gunderline{\rightarrow x\,q})\gunderline{\big)\,q}\nonumber \\
\text{use }\triangleright\text{ notation}:\quad & =t\rightarrow q\rightarrow\gunderline{q\triangleright\big(q\triangleright(}x\rightarrow q\triangleright x)^{\downarrow H}\bef t\big)\quad.\label{eq:ftn-R-simplified}
\end{align}

\end_inset

We first apply the left-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-law-3-formulation-R-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(m\triangleright\text{ftn}_{R}^{\uparrow M}\gunderline{\bef}\text{sw}\big)\\
\triangleright\text{ notation}: & =q\triangleright\big(m\triangleright\text{ftn}_{R}^{\uparrow M}\triangleright\gunderline{\text{sw}}\big)\\
\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:\quad & =m\triangleright\gunderline{\text{ftn}_{R}^{\uparrow M}\bef(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}}\\
\text{composition law for }M:\quad & =m\triangleright\big(\text{ftn}_{R}\bef(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.
\end{align*}

\end_inset

We now need to simplify the sub-expression under 
\begin_inset Formula $(...)^{\uparrow M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{R}\gunderline{\bef(r}\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright r)\\
\text{function composition}:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\gunderline{\text{ftn}_{R}(r)}\\
\text{use Eq.~(\ref{eq:ftn-R-simplified})}:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\big(q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}\triangleright(x\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright x)^{\downarrow H}}\bef r\big)\\
\text{composition law for }H:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\rightarrow q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}\bef x\bef\text{pu}_{M}})^{\downarrow H}\bef r\big)\\
\text{definition of }^{\uparrow R}:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x))^{\downarrow H}\bef r\big)\quad.
\end{align*}

\end_inset

The left-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-law-3-formulation-R-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then becomes
\begin_inset Formula 
\[
m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x))^{\downarrow H}\bef r\big)\big)^{\uparrow M}\quad.
\]

\end_inset

Now apply the right-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-law-3-formulation-R-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & q\triangleright\big(m\triangleright\text{sw}\bef\gunderline{\text{sw}^{\uparrow R}}\bef\text{ftn}_{R}\big)\nonumber \\
\text{definition of }^{\uparrow R}:\quad & =q\triangleright\big(\gunderline{m\triangleright\text{sw}\triangleright(x}\rightarrow\text{sw}^{\downarrow H}\bef x\bef\text{sw})\triangleright\text{ftn}_{R}\big)\nonumber \\
\text{apply to arguments}:\quad & =q\triangleright\big(\gunderline{\text{ftn}_{R}(}\text{sw}^{\downarrow H}\bef\text{sw}(m)\bef\text{sw})\big)\nonumber \\
\text{use Eq.~(\ref{eq:ftn-R-simplified})}:\quad & =q\triangleright\big(q\triangleright\gunderline{(x\rightarrow q\triangleright x)^{\downarrow H}\bef\text{sw}^{\downarrow H}}\bef\text{sw}(m)\bef\text{sw}\big)\nonumber \\
\text{composition law of }H:\quad & =q\triangleright\big(q\triangleright\big(\gunderline{\text{sw}\bef(x\rightarrow q\triangleright x)}\big)^{\downarrow H}\bef\text{sw}(m)\bef\text{sw}\big)\quad.\label{eq:swap-laws-derivation2}
\end{align}

\end_inset

To proceed, we simplify the sub-expression 
\begin_inset Formula $\text{sw}(m)\bef\text{sw}$
\end_inset

 separately by computing the function compositions:
\begin_inset Formula 
\begin{align*}
 & \text{sw}(m)\bef\text{sw}\\
 & =(q_{1}\rightarrow m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\gunderline{)\bef(}y\rightarrow q_{2}\rightarrow y\triangleright\big(r\rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\\
 & =q_{1}\rightarrow q_{2}\rightarrow(m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M})\triangleright\big(}r\rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M}}\\
 & =q_{1}\rightarrow q_{2}\rightarrow m\triangleright\big(\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\bef\big(}r\rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\big)^{\uparrow M}}\quad.
\end{align*}

\end_inset

Using this formula, we can write, for any 
\begin_inset Formula $z$
\end_inset

 of a suitable type,
\begin_inset Formula 
\begin{align}
q\triangleright(z\triangleright\text{sw}(m)\bef\text{sw}) & =m\triangleright\big(\big(r\rightarrow z\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\bef\big(r\rightarrow}q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}\nonumber \\
\text{function composition}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(z\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.\label{eq:swap-law-3-derivation-1}
\end{align}

\end_inset

Now we can substitute this into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-laws-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(q\triangleright\big(\text{sw}\bef(x\rightarrow q\triangleright x)\big)^{\downarrow H}\triangleright\gunderline{\text{sw}(m)\bef\text{sw}}\big)\\
\text{use Eq.~(\ref{eq:swap-law-3-derivation-1})}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\gunderline{\big(\text{sw}\bef(x\rightarrow q\triangleright x)\big)^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r)\big)^{\uparrow M}\\
H\text{'s composition}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(\gunderline{\text{pu}_{M}\bef\text{sw}}\bef(x\rightarrow q\triangleright x)\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\\
\text{outer-identity}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(\gunderline{\text{pu}_{M}^{\uparrow R}\bef(x\rightarrow q\triangleright x)}\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\\
\text{composition}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(x\rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x)\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.
\end{align*}

\end_inset

We arrived at the same expression as the left-hand side of the law.
\end_layout

\begin_layout Paragraph
Proof of the outer-interchange law
\end_layout

\begin_layout Standard
The law is written as
\begin_inset Formula 
\begin{equation}
\vspace{-0.25cm}\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow R}\quad.\label{eq:swap-law-4-formulation-R-M}
\end{equation}

\end_inset

We will apply both sides of the law to arbitrary 
\begin_inset Formula $m^{:M^{M^{R^{A}}}}$
\end_inset

 and 
\begin_inset Formula $q^{:H^{M^{A}}}$
\end_inset

, and transform both sides to the same expression.
 We begin with the more complicated right-hand side:
\begin_inset Formula 
\begin{align}
 & q\triangleright\big(m\triangleright\text{sw}^{\uparrow M}\gunderline{\bef}\text{sw}\gunderline{\bef}\text{ftn}_{M}^{\uparrow R}\big)\nonumber \\
\triangleright\text{ notation}:\quad & =q\triangleright\big((m\triangleright\text{sw}^{\uparrow M}\triangleright\text{sw})\triangleright\gunderline{\text{ftn}_{M}^{\uparrow R}}\big)\nonumber \\
\text{definition of }^{\uparrow R}:\quad & =q\triangleright\big(\text{ftn}_{M}^{\downarrow H}\gunderline{\bef}(m\triangleright\text{sw}^{\uparrow M}\triangleright\text{sw})\gunderline{\bef}\text{ftn}_{M}\big)\nonumber \\
\triangleright\text{ notation}:\quad & =\big(\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}}\triangleright(\gunderline{m\triangleright\text{sw}^{\uparrow M}}\triangleright\gunderline{\text{sw}})\big)\triangleright\text{ftn}_{M}\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:\quad & =\big(m\triangleright\gunderline{\text{sw}^{\uparrow M}}\triangleright\big(r\rightarrow q\triangleright\gunderline{\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\gunderline{\big)^{\uparrow M}}\big)\triangleright\text{ftn}_{M}\nonumber \\
\text{composition for }H\text{ and }M:\quad & =m\triangleright\big(\text{sw}\bef\big(r\rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})^{\downarrow H}\bef r\big)\big)^{\uparrow M}\bef\text{ftn}_{M}\nonumber \\
\text{left identity law of }M:\quad & =m\triangleright\big(\text{sw}\bef(r\rightarrow q\triangleright r)\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-1-swap-law-4-derivation-5}
\end{align}

\end_inset

Let us simplify the sub-expression 
\begin_inset Formula $\text{sw}\bef(r\rightarrow q\triangleright r)$
\end_inset

 separately:
\begin_inset Formula 
\begin{align}
 & \gunderline{\text{sw}}\bef\big(r\rightarrow q\triangleright r\big)=(x\rightarrow x\triangleright\text{sw})\bef(r\rightarrow q\triangleright r)\nonumber \\
\text{function composition}:\quad & =(x\rightarrow\gunderline{q\triangleright(x\triangleright\text{sw})})\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:\quad & =\gunderline{x\rightarrow x\triangleright\big(}r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\nonumber \\
\text{expand argument}:\quad & =\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.\label{eq:rigid-monad-1-swap-derivation-6}
\end{align}

\end_inset

Substituting this expression into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-1-swap-law-4-derivation-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we get
\begin_inset Formula 
\begin{align*}
 & m\triangleright\big(\gunderline{\text{sw}\bef(r\rightarrow q\triangleright r)}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
\text{use Eq.~(\ref{eq:rigid-monad-1-swap-derivation-6})}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\\
\text{naturality of }\text{ftn}_{M}:\quad & =m\triangleright\text{ftn}_{M}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Now write the left-hand side of the law:
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(m\triangleright\text{ftn}_{M}\gunderline{\bef}\text{sw}\big)=q\triangleright\big(m\triangleright\text{ftn}_{M}\triangleright\gunderline{\text{sw}}\big)\\
\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:\quad & =m\triangleright\text{ftn}_{M}\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}

\end_inset

This is equal to the right-hand side we just obtained.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-monad-1-swap-naturality-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-monad-1-swap-naturality-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The monadic naturality laws in Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 hold for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the base monad 
\begin_inset Formula $L\triangleq R$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The monadic naturality laws are 
\begin_inset Formula 
\[
\text{sw}_{R,\text{Id}}=\text{id}\quad,\quad\quad\text{sw}_{R,M}\bef\phi^{\uparrow R}=\phi\bef\text{sw}_{R,N}\quad,\quad\quad\text{sw}_{R,M}\bef\theta=\theta^{\uparrow M}\quad,
\]

\end_inset

where 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:R\leadsto\text{Id}$
\end_inset

 are arbitrary monad morphisms.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-swap-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives
\begin_inset Formula 
\[
\text{sw}_{R,M}(m)=q\rightarrow m\triangleright\big(\text{pu}_{M}^{\uparrow R}\bef(x\rightarrow x\,q)\big)^{\uparrow M}\bef\text{ftn}_{M}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify the first law, set 
\begin_inset Formula $M=\text{Id}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-1-forward-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and get ***
\begin_inset Formula 
\begin{align*}
 & q\triangleright(m\triangleright\text{sw}_{R,\text{Id}})\\
\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}}\bef r\gunderline{\big)^{\uparrow M}}\\
\text{use }M=\text{Id}\text{ and }\text{pu}_{M}=\text{id}:\quad & =\gunderline{m\triangleright(r\rightarrow}q\triangleright r)\\
\text{apply to argument }m:\quad & =q\triangleright\gunderline m=q\triangleright(m\triangleright\text{id})\quad.
\end{align*}

\end_inset

So, 
\begin_inset Formula $\text{sw}_{R,\text{Id}}=\text{id}$
\end_inset

 when applied to arbitrary argument values 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the second law, apply both sides to arbitrary 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 The left-hand side:
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(m\triangleright\text{sw}_{R,M}\gunderline{\bef}\phi^{\uparrow R}\big)=q\triangleright\big(m\triangleright\text{sw}_{R,M}\triangleright\gunderline{\phi^{\uparrow R}}\big)\\
\text{definition of }^{\uparrow R}:\quad & =q\triangleright\big(\phi^{\downarrow H}\bef(m\triangleright\text{sw}_{R,M})\bef\phi\big)\\
\triangleright\text{ notation}:\quad & =\gunderline{(q\triangleright\phi^{\downarrow H})}\triangleright(m\triangleright\gunderline{\text{sw}_{R,M}})\triangleright\phi\\
\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\gunderline{\phi^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\big)^{\uparrow M}\triangleright\phi\\
\text{composition law for }H:\quad & =m\triangleright\big(r\rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\phi})^{\downarrow H}\bef r\big)^{\uparrow M}\bef\phi\\
\text{identity law for }\phi:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M}\bef\phi}\\
\text{naturality of }\phi:\quad & =m\triangleright\gunderline{\phi\bef\big(}r\rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow N}}\quad.
\end{align*}

\end_inset

The right-hand side, when applied to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

, gives the same expression:
\begin_inset Formula 
\begin{align*}
 & q\triangleright(m\triangleright\phi\bef\text{sw}_{R,N})=q\triangleright(m\triangleright\phi\triangleright\gunderline{\text{sw}_{R,N})}\\
\text{use Eq.~(\ref{eq:rigid-monad-1-forward-formula-for-swap})}:\quad & =m\triangleright\phi\triangleright\big(r\rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\big)^{\uparrow N}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To argue that the third law holds,
\begin_inset Foot
status open

\begin_layout Plain Layout
This is not a fully rigorous proof of the third monadic naturality law.
 The place where the proof lacks rigor will be shown.
\end_layout

\end_inset

 apply the left-hand side to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & q\triangleright(m\triangleright\text{sw}_{R,M}\bef\theta)=q\triangleright(m\triangleright\text{sw}_{R,M}\triangleright\theta)\nonumber \\
 & =q\triangleright\big((q_{1}\rightarrow m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\triangleright\theta\big)\quad.\label{eq:rigid-monad-1-derivation7}
\end{align}

\end_inset

This expression cannot be simplified any further; and neither can the right-hand
 side 
\begin_inset Formula $q\triangleright(m\triangleright\theta^{\uparrow M})$
\end_inset

.
 We need more detailed information about the function 
\begin_inset Formula $\theta$
\end_inset

.
 
\end_layout

\begin_layout Standard
The type of 
\begin_inset Formula $\theta$
\end_inset

 is
\begin_inset Formula 
\[
\theta:\forall A.\,(H^{A}\rightarrow A)\rightarrow A\quad.
\]

\end_inset

To implement a function of this type, we need to write code that takes an
 argument of type 
\begin_inset Formula $H^{A}\rightarrow A$
\end_inset

 and returns a value of type 
\begin_inset Formula $A$
\end_inset

.
 Since the type 
\begin_inset Formula $A$
\end_inset

 is arbitrary, the code of 
\begin_inset Formula $\theta$
\end_inset

 cannot store a fixed value of type 
\begin_inset Formula $A$
\end_inset

 to use as the return value.
 The only possibility to implement a function 
\begin_inset Formula $\theta$
\end_inset

 with the required type signature seems to be by substituting a value of
 type 
\begin_inset Formula $H^{A}$
\end_inset

 into the given argument of type 
\begin_inset Formula $H^{A}\rightarrow A$
\end_inset

, which will return the result of type 
\begin_inset Formula $A$
\end_inset

.
 So,
\begin_inset Foot
status open

\begin_layout Plain Layout
This is where rigor is lacking: we did not prove that the type 
\begin_inset Formula $\forall A.\,(H^{A}\rightarrow A)\rightarrow A$
\end_inset

 is really 
\emph on
equivalent
\emph default
 to 
\begin_inset Formula $\forall A.\,H^{A}$
\end_inset

.
 Up to that assumption, the proof is rigorous.
\end_layout

\end_inset

 we need to produce a value of type 
\begin_inset Formula $H^{A}$
\end_inset

 for an arbitrary type 
\begin_inset Formula $A$
\end_inset

, that is, a value of type 
\begin_inset Formula $\forall A.\,H^{A}$
\end_inset

.
 Using the contravariant Yoneda identity, we can simplify this type expression
 to the type 
\begin_inset Formula $H^{\bbnum 1}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,H^{A}\cong\forall A.\,\gunderline{\bbnum 1}\rightarrow H^{A}\\
\text{use identity }(A\rightarrow\bbnum 1)\cong\bbnum 1:\quad & \cong\forall A.\,(A\rightarrow\bbnum 1)\rightarrow H^{A}\\
\text{contravariant Yoneda identity}:\quad & \cong H^{\bbnum 1}\quad.
\end{align*}

\end_inset

So, we can construct a 
\begin_inset Formula $\theta$
\end_inset

 if we store a value 
\begin_inset Formula $h_{1}$
\end_inset

 of type 
\begin_inset Formula $H^{\bbnum 1}$
\end_inset

 and compute 
\begin_inset Formula $h:H^{A}$
\end_inset

 as
\begin_inset Formula 
\[
h^{:H^{A}}=h_{1}^{:H^{1}}\triangleright(a^{:A}\rightarrow1)^{\downarrow H}\quad.
\]

\end_inset

Given a fixed value 
\begin_inset Formula $h_{1}:H^{\bbnum 1}$
\end_inset

, the code of 
\begin_inset Formula $\theta$
\end_inset

 is therefore
\begin_inset Formula 
\begin{equation}
\big(r^{:H^{A}\rightarrow A}\big)\triangleright\theta\triangleq h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright r\quad.\label{eq:rigid-monad-base-runner-1}
\end{equation}

\end_inset

Let us check whether this 
\begin_inset Formula $\theta$
\end_inset

 is a monad morphism 
\begin_inset Formula $R\leadsto\text{Id}$
\end_inset

.
 We need to verify the two laws of monad morphisms,
\begin_inset Formula 
\[
\text{pu}_{R}\bef\theta=\text{id}\quad,\quad\quad\text{ftn}_{R}\bef\theta=\theta^{\uparrow R}\bef\theta=\theta\bef\theta\quad.
\]

\end_inset

The identity law, applied to an arbitrary 
\begin_inset Formula $x:A$
\end_inset

, is
\begin_inset Formula 
\begin{align*}
 & x\triangleright\text{pu}_{R}\bef\theta=(x\triangleright\text{pu}_{R}\gunderline{)\triangleright\theta}\\
\text{definition of }r\triangleright\theta:\quad & =h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright(\gunderline{x\triangleright\text{pu}_{R}})\\
\text{definition of }x\triangleright\text{pu}_{R}:\quad & =\big(h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\gunderline{\big)\triangleright(\_\rightarrow}x)\\
\text{function composition}:\quad & =x\quad.
\end{align*}

\end_inset

This verifies the identity law.
 
\end_layout

\begin_layout Standard
The composition law, applied to an arbitrary 
\begin_inset Formula $r:R^{R^{A}}$
\end_inset

, expands to
\begin_inset Formula 
\begin{align*}
 & r\triangleright\text{ftn}_{R}\bef\theta=\gunderline{r\triangleright\text{ftn}_{R}}\triangleright\theta\\
\text{definition of }\text{ftn}_{R}:\quad & =\gunderline{r\triangleright\big(t\rightarrow}q\rightarrow q\triangleright\big(q\triangleright(x\rightarrow q\triangleright x)^{\downarrow H}\bef t\big)\big)\triangleright\theta\\
\text{apply to }r:\quad & =\big(q\rightarrow q\triangleright\big(q\triangleright(x\rightarrow q\triangleright x)^{\downarrow H}\bef r\big)\gunderline{\big)\triangleright\theta}\\
\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:\quad & =h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright\gunderline{\big(q\rightarrow}q\triangleright\big(q\triangleright(x\rightarrow q\triangleright x)^{\downarrow H}\bef r\big)\big)\\
\text{apply to }h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}:\quad & =h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright\big(h_{1}\triangleright\gunderline{(\_\rightarrow1)^{\downarrow H}\bef(x\rightarrow...)^{\downarrow H}}\bef r\big)\\
\text{composition under }H:\quad & =\gunderline{h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}}\triangleright\big(\gunderline{h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}}\triangleright r\big)\\
\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:\quad & =r\triangleright\theta\triangleright\theta=r\triangleright\theta\bef\theta\quad.
\end{align*}

\end_inset

This verifies the composition law; so 
\begin_inset Formula $\theta$
\end_inset

 is indeed a monad morphism.
\end_layout

\begin_layout Standard
Using the code of 
\begin_inset Formula $\theta$
\end_inset

 defined in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-base-runner-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we can now verify the monadic naturality law of 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 (with respect to the runners 
\begin_inset Formula $\theta$
\end_inset

 of that form).
 The left-hand side of the law is given by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-1-derivation7"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and is rewritten as
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big((q_{1}\rightarrow m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\gunderline{)\triangleright\theta}\big)\\
\text{definition of }\theta:\quad & =q\triangleright\big(h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\gunderline{\triangleright(q_{1}\rightarrow}m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\big)\\
\text{apply to argument}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright\gunderline{(\_\rightarrow1)^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\big)^{\uparrow M}\big)\\
H\text{'s composition law}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright(\gunderline{\text{pu}_{M}\bef(\_\rightarrow1)})^{\downarrow H}\bef r\big)^{\uparrow M}\big)\\
\text{compose functions}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright(\gunderline{\_\rightarrow1})^{\downarrow H}\triangleright r\big)^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

The right-hand side is
\begin_inset Formula 
\begin{align*}
 & q\triangleright(m\triangleright\gunderline{\theta}^{\uparrow M})\\
\text{function expansion}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow\gunderline{r\triangleright\theta}\big)^{\uparrow M}\big)\\
\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright r\big)^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

This expression is now the same as the left-hand side.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Statement 4.
\end_layout

\begin_layout Plain Layout
The rigid monad 
\begin_inset Formula $R^{A}\triangleq H^{A}\rightarrow A$
\end_inset

 satisfies the two compatibility laws with respect to any monad 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Proof.
\end_layout

\begin_layout Plain Layout
Denote for brevity 
\begin_inset Formula $T^{\bullet}\triangleq R^{M^{\bullet}}$
\end_inset

 and rewrite the compatibility laws in terms of 
\begin_inset Formula $\text{flm}$
\end_inset

 instead of 
\begin_inset Formula $\text{ftn}$
\end_inset

 (since our expressions for the monad 
\begin_inset Formula $T$
\end_inset

 always need to involve 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

).
 Then the two laws that we need to prove are 
\begin_inset Formula 
\begin{align*}
\text{flm}_{R}f^{:A\rightarrow R^{M^{B}}} & =\text{pure}_{M}^{\uparrow R}\bef\text{flm}_{T}f\quad\text{as functions }R^{A}\rightarrow R^{M^{B}},\\
\big(\text{flm}_{M}f^{A\rightarrow M^{B}}\big)^{\uparrow R} & =\text{pure}_{R}^{\uparrow T}\bef\text{flm}_{T}\big(f^{\uparrow R}\big)\quad\text{as functions }R^{M^{A}}\rightarrow R^{M^{B}}.
\end{align*}

\end_inset

A definition of 
\begin_inset Formula $\text{flm}_{R}$
\end_inset

 is obtained from 
\begin_inset Formula $\text{flm}_{T}$
\end_inset

 by choosing the identity monad 
\begin_inset Formula $M^{A}\triangleq A$
\end_inset

 instead of an arbitrary monad 
\begin_inset Formula $M$
\end_inset

.
 This replaces 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

 by 
\begin_inset Formula $\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{flm}_{T}f^{:A\rightarrow R^{M^{B}}} & =t^{:R^{M^{A}}}\rightarrow q^{H^{M^{B}}}\rightarrow\left(\text{flm}_{M}\left(x^{:A}\rightarrow f\,x\,q\right)\right)^{\uparrow R}t\,q\quad;\\
\text{flm}_{R}f^{:A\rightarrow R^{B}} & =r^{:R^{A}}\rightarrow q^{H^{B}}\rightarrow\left(x^{:A}\rightarrow f\,x\,q\right)^{\uparrow R}r\,q\quad.
\end{align*}

\end_inset

To prove the first compatibility law, rewrite its right-hand side as
\begin_inset Formula 
\begin{align*}
 & \text{pure}_{M}^{\uparrow R}\bef\text{flm}_{T}f\\
\text{definition of }\text{flm}_{T}:\quad & =\left(r^{:R^{A}}\rightarrow\text{pure}_{M}^{\uparrow R}r\right)\bef\left(r\rightarrow q\rightarrow\left(\text{flm}_{M}\left(x\rightarrow f\,x\,q\right)\right)^{\uparrow R}r\,q\right)\\
\text{expand }\bef\text{and simplify}:\quad & =r\rightarrow q\rightarrow\left(\text{flm}_{M}\left(x\rightarrow f\,x\,q\right)\right)^{\uparrow R}\left(\text{pure}_{M}^{\uparrow R}r\right)\,q\\
\text{composition law for }R:\quad & =r\rightarrow q\rightarrow\left(\text{pure}_{M}\bef\text{flm}_{M}\left(x\rightarrow f\,x\,q\right)\right)^{\uparrow R}r\,q\\
\text{left identity law for }M:\quad & =r\rightarrow q\rightarrow\left(x\rightarrow f\,x\,q\right)^{\uparrow R}r\,q\\
\text{definition of }\text{flm}_{R}:\quad & =\text{flm}_{R}f\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
To prove the second compatibility law, rewrite its right-hand side as
\begin_inset Formula 
\begin{align*}
 & \text{pure}_{R}^{\uparrow T}\bef\text{flm}_{T}\big(f^{\uparrow R}\big)\\
\text{definition of }\text{flm}_{T}\big(f^{\uparrow R}\big):\quad & =\left(t^{:T^{A}}\rightarrow\text{pure}_{R}^{\uparrow T}t\right)\bef\left(t\rightarrow q\rightarrow\left(\text{flm}_{M}\left(x\rightarrow f^{\uparrow R}x\,q\right)\right)^{\uparrow R}t\,q\right)\\
\text{expand }\bef\text{ and simplify}:\quad & =t^{:T^{A}}\rightarrow q\rightarrow\left(\text{flm}_{M}\left(x^{:R^{A}}\rightarrow f^{\uparrow R}x\,q\right)\right)^{\uparrow R}\left(\text{pure}_{R}^{\uparrow M\uparrow R}t\right)\,q\\
\text{composition law for }R:\quad & =t\rightarrow q\rightarrow\left(\text{pure}_{R}^{\uparrow M}\bef\text{flm}_{M}\left(x^{:R^{A}}\rightarrow f^{\uparrow R}x\,q\right)\right)^{\uparrow R}t\,q\\
\text{left naturality of }\text{flm}_{M}:\quad & =t\rightarrow q\rightarrow\left(\text{flm}_{M}\left(x^{:A}\rightarrow\left(\text{pure}_{R}\bef f^{\uparrow R}\right)x\,q\right)\right)^{\uparrow R}t\,q\\
\text{naturality of }\text{pure}_{R}:\quad & =t\rightarrow q\rightarrow\left(\text{flm}_{M}\left(x^{:A}\rightarrow\text{pure}_{R}\left(f\,x\right)\,q\right)\right)^{\uparrow R}t\,q\\
\text{definition of }\text{pure}_{R}:\quad & =t\rightarrow q\rightarrow\left(\text{flm}_{M}\left(x^{:A}\rightarrow f\,x\right)\right)^{\uparrow R}t\,q\\
\text{unapply }f\text{ and }\text{flm}_{M}f:\quad & =t\rightarrow q\rightarrow\left(\text{flm}_{M}f\right)^{\uparrow R}t\,q=\left(\text{flm}_{M}f\right)^{\uparrow R}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
Statement 5.
\end_layout

\begin_layout Plain Layout
Assume that 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are arbitrary (not necessarily rigid) monads such that the functor composition
 
\begin_inset Formula $T^{\bullet}\triangleq R^{M^{\bullet}}$
\end_inset

 is also a monad whose method 
\begin_inset Formula $\text{pure}_{T}$
\end_inset

 is defined by
\begin_inset Formula 
\[
\text{pure}_{R^{M}}=\text{pure}_{M}\bef\text{pure}_{R}\quad.
\]

\end_inset

Then the two 
\begin_inset Quotes eld
\end_inset

liftings
\begin_inset Quotes erd
\end_inset

 and the two 
\begin_inset Quotes eld
\end_inset

runners
\begin_inset Quotes erd
\end_inset

 defined by
\begin_inset Formula 
\begin{align*}
\text{lift}:M^{\bullet}\leadsto R^{M^{\bullet}} & \triangleq\text{pure}_{R}\quad,\\
\text{blift}:R^{\bullet}\leadsto R^{M^{\bullet}} & \triangleq\text{pure}_{M}^{\uparrow R}\quad,\\
\text{mrun}\,\big(\phi^{:M^{\bullet}\leadsto N^{\bullet}}\big):R^{M^{\bullet}}\rightarrow R^{N^{\bullet}} & \triangleq\phi^{\uparrow R}\quad,\\
\text{brun}\,\theta^{:R^{\bullet}\leadsto\bullet}:R^{M^{\bullet}}\rightarrow M^{\bullet} & \triangleq\theta^{:R^{M^{\bullet}}\leadsto M^{\bullet}}\quad,
\end{align*}

\end_inset

will satisfy the identity laws
\begin_inset Formula 
\begin{align*}
\text{pure}_{M}\bef\text{lift} & =\text{pure}_{T}\quad,\\
\text{pure}_{R}\bef\text{blift} & =\text{pure}_{T}\quad,\\
\text{pure}_{R^{M}}\bef\left(\text{mrun}\,\phi\right) & =\text{pure}_{N}\bef\text{pure}_{R}\quad,\\
\text{pure}_{R^{M}}\bef\left(\text{brun}\,\theta\right) & =\text{pure}_{M}\quad,
\end{align*}

\end_inset

where we assume that 
\begin_inset Formula $\phi:M^{\bullet}\leadsto N^{\bullet}$
\end_inset

 and 
\begin_inset Formula $\theta:M^{\bullet}\leadsto\bullet$
\end_inset

 are monad morphisms, and 
\begin_inset Formula $N$
\end_inset

 is an arbitrary monad.
\end_layout

\begin_layout Plain Layout
Proof.
\end_layout

\begin_layout Plain Layout
The first law is a direct consequence of the definition of 
\begin_inset Formula $\text{lift}$
\end_inset

.
 The second law follows from the naturality of 
\begin_inset Formula $\text{pure}_{R}$
\end_inset

,
\begin_inset Formula 
\[
\text{pure}_{R}\bef\text{pure}_{M}^{\uparrow R}=\text{pure}_{M}\bef\text{pure}_{R}\quad.
\]

\end_inset

The third law follows from the identity law for 
\begin_inset Formula $\phi$
\end_inset

,
\begin_inset Formula 
\[
\text{pure}_{M}\bef\phi=\text{pure}_{N},
\]

\end_inset

 if we write
\begin_inset Formula 
\begin{align*}
 & \text{pure}_{R^{M}}\bef\left(\text{mrun}\,\phi\right)\\
\text{definitions of }\text{pure}_{R^{M}}\text{ and }\text{mrun}:\quad & =\text{pure}_{M}\bef\text{pure}_{R}\bef\phi^{\uparrow R}\\
\text{naturality of }\text{pure}_{R}:\quad & =\text{pure}_{M}\bef\phi\bef\text{pure}_{R}\\
\text{identity law for }\phi:\quad & =\text{pure}_{N}\bef\text{pure}_{R}\quad.
\end{align*}

\end_inset

The fourth law follows from the identity law for 
\begin_inset Formula $\theta$
\end_inset

,
\begin_inset Formula 
\[
\text{pure}_{R}\bef\theta=\text{id},
\]

\end_inset

if we write
\begin_inset Formula 
\begin{align*}
 & \text{pure}_{R^{M}}\bef\left(\text{brun}\,\theta\right)\\
\text{definitions of }\text{pure}_{R^{M}}\text{ and }\text{brun}:\quad & =\text{pure}_{M}\bef\text{pure}_{R}\bef\theta\\
\text{identity law for }\theta:\quad & =\text{pure}_{M}\quad.
\end{align*}

\end_inset

In this proof, we have not actually used the assumption that 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $R^{M^{\bullet}}$
\end_inset

, and 
\begin_inset Formula $N$
\end_inset

 are monads.
 We only used the naturality of 
\begin_inset Formula $\text{pure}_{R}$
\end_inset

.
 So, it is sufficient to assume that these functors are pointed, and that
 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

 are morphisms of pointed functors.
 However, the four laws we just derived are mainly useful as identity laws
 for monad transformer methods.
\end_layout

\begin_layout Plain Layout
Statement 6.
\end_layout

\begin_layout Plain Layout
A monad transformer for the rigid monad 
\begin_inset Formula $R^{A}\triangleq H^{A}\rightarrow A$
\end_inset

 is 
\begin_inset Formula $T_{R}^{M,A}\triangleq R^{M^{A}}$
\end_inset

, with the four required methods defined as
\begin_inset Formula 
\begin{align*}
\text{lift}^{:M^{\bullet}\leadsto T^{\bullet}} & \triangleq\text{pure}_{R}\quad,\\
\text{blift}^{:R^{\bullet}\leadsto T^{\bullet}} & \triangleq\text{pure}_{M}^{\uparrow R}\quad,\\
\text{mrun}\,\phi^{:M^{\bullet}\leadsto N^{\bullet}} & \triangleq\phi^{\uparrow R}\quad,\\
\text{brun}\,\theta^{:R^{\bullet}\leadsto\bullet} & \triangleq\theta^{:R^{M^{\bullet}}\leadsto M^{\bullet}}\quad.
\end{align*}

\end_inset

Each of these four methods is a monad morphism for any monad morphism 
\begin_inset Formula $\phi:M^{\bullet}\leadsto N^{\bullet}$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 are arbitrary (not necessarily rigid) monads, and for any monad morphism
 
\begin_inset Formula $\theta:R^{A}\leadsto A$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Proof.
\end_layout

\begin_layout Plain Layout
Since 
\begin_inset Formula $\text{blift}$
\end_inset

 is a special case of 
\begin_inset Formula $\text{mrun}$
\end_inset

, we only need to prove the monad morphism laws for the three methods: 
\begin_inset Formula $\text{lift}$
\end_inset

, 
\begin_inset Formula $\text{mrun}$
\end_inset

, and 
\begin_inset Formula $\text{brun}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The identity laws follow from Statement
\begin_inset space ~
\end_inset

5, since 
\begin_inset Formula $T_{R}^{M,\bullet}=R^{M^{\bullet}}$
\end_inset

 is a functor composition.
 It remains to verify the composition laws,
\begin_inset Formula 
\begin{align*}
\left(f^{:A\rightarrow M^{B}}\bef\text{lift}\right)\diamond_{R^{M}}\left(g^{:B\rightarrow M^{C}}\bef\text{lift}\right) & =\left(f\diamond_{M}g\right)\bef\text{lift}\quad,\\
\left(f^{:A\rightarrow R^{M^{B}}}\bef\text{mrun}\,\phi\right)\diamond_{R^{N}}\left(g^{:B\rightarrow R^{M^{C}}}\bef\text{mrun}\,\phi\right) & =\left(f\diamond_{R^{M}}g\right)\bef\text{mrun}\,\phi\quad,\\
\left(f^{:A\rightarrow R^{M^{B}}}\bef\text{brun}\,\theta\right)\diamond_{M}\left(g^{:B\rightarrow R^{M^{C}}}\bef\text{brun}\,\theta\right) & =\left(f\diamond_{R^{M}}g\right)\bef\text{brun}\,\theta\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
For the first law, we need to use the definition of 
\begin_inset Formula $\text{lift}\triangleq\text{pure}_{R}$
\end_inset

, which is
\begin_inset Formula 
\[
\text{pure}_{R}x^{:A}\triangleq\_^{:H^{A}}\rightarrow x\quad.
\]

\end_inset

So the definition of 
\begin_inset Formula $\text{lift}$
\end_inset

 can be written as 
\begin_inset Formula 
\[
f\bef\text{lift}=x^{:A}\rightarrow\_^{:H^{M^{B}}}\rightarrow f\,x
\]

\end_inset

as a function that ignores its second argument (of type 
\begin_inset Formula $H^{M^{B}}$
\end_inset

).
 It is convenient to use the flipped Kleisli product 
\begin_inset Formula $\tilde{\diamond}_{R^{M}}$
\end_inset

 defined before in eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flipped-kleisli"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We compute 
\begin_inset Formula 
\begin{align*}
 & \left(f^{:A\rightarrow M^{B}}\bef\text{lift}\right)\tilde{\diamond}_{R^{M}}\left(g^{:B\rightarrow M^{C}}\bef\text{lift}\right)\\
\text{definition of }\text{lift}:\quad & =\left(\_\rightarrow f\right)\tilde{\diamond}_{R^{M}}\left(\_\rightarrow g\right)\\
\text{eq. (\ref{eq:def-flipped-kleisli})}:\quad & =q^{:H^{M^{B}}}\rightarrow\left(\_\rightarrow f\right)\left(\left(\text{flm}_{M}\left(\left(\_\rightarrow g\right)\,q\right)\right)^{\downarrow H}q\right)\diamond_{M}\left(\left(\_\rightarrow g\right)\,q\right)\\
\text{expanding the functions}:\quad & =q\rightarrow f\diamond_{M}g\\
\text{unflipping the definition of }\text{lift}:\quad & =q\rightarrow x\rightarrow\left(\left(f\diamond_{M}g\right)\bef\text{lift}\right)a\,x\quad.
\end{align*}

\end_inset

Note that the last function, of type 
\begin_inset Formula $H^{M^{B}}\rightarrow A\rightarrow M^{B}$
\end_inset

, ignores its first argument.
 Therefore, after unflipping this Kleisli function, it will ignore its second
 argument.
 This is precisely what the function 
\begin_inset Formula $\left(f\diamond_{M}g\right)\bef\text{lift}$
\end_inset

 must do.
\end_layout

\begin_layout Plain Layout
For the second and third laws, we need to use the composition laws for 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

, which can be written as
\begin_inset Formula 
\begin{align*}
\left(f^{:A\rightarrow M^{B}}\bef\phi\right)\diamond_{N}\left(g^{:B\rightarrow M^{C}}\bef\phi\right) & =\left(f\diamond_{M}g\right)\bef\phi\quad,\\
\left(f^{:A\rightarrow R^{B}}\bef\theta\right)\bef\left(g^{:B\rightarrow M^{C}}\bef\theta\right) & =\left(f\diamond_{M}g\right)\bef\theta\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rigid monad construction 2: composition
\end_layout

\begin_layout Standard
Functor composition is the second construction that produces rigid monads.
 This is a consequence of the properties of monad transformer stacks.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-composition-rigid-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-composition-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The composition 
\begin_inset Formula $R_{1}^{R_{2}^{\bullet}}$
\end_inset

 of two rigid monads 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 is also a rigid monad.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $R_{1}$
\end_inset

 is rigid, its outside-composition 
\begin_inset Formula $R_{1}\circ M$
\end_inset

 with any other monad 
\begin_inset Formula $M$
\end_inset

 is a monad.
 So 
\begin_inset Formula $R_{1}\circ R_{2}$
\end_inset

 is a monad.
 To show that 
\begin_inset Formula $R_{1}\circ R_{2}$
\end_inset

 is a rigid monad, we need to show that its monad transformer is of the
 composed-outside kind.
 By Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the stacking of monad transformers 
\begin_inset Formula $T_{R_{1}}$
\end_inset

and 
\begin_inset Formula $T_{R_{2}}$
\end_inset

 is a lawful monad transformer.
 Since the transformers for 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 are of the composed-outside kind, 
\begin_inset Formula $T_{R_{1}}^{M}=R_{1}\circ M$
\end_inset

 and 
\begin_inset Formula $T_{R_{2}}^{M}=R_{2}\circ M$
\end_inset

, the stack of transformers is 
\begin_inset Formula 
\[
T_{R_{1}}^{T_{R_{2}}^{M}}=R_{1}\circ T_{R_{2}}^{M}=R_{1}\circ(R_{2}\circ M)=R_{1}\circ R_{2}\circ M\quad.
\]

\end_inset

Therefore 
\begin_inset Formula $T^{M}\triangleq R_{1}\circ R_{2}\circ M$
\end_inset

 is a monad transformer applied to the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 This shows, by definition of a rigid monad, that 
\begin_inset Formula $R_{1}\circ R_{2}$
\end_inset

 is a rigid monad.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-rigid-composition-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-rigid-composition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the functor composition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad 
\begin_inset Formula $R_{1}^{A}\triangleq\left(A\rightarrow Q\right)\rightarrow A$
\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad 
\begin_inset Formula $R_{2}^{A}\triangleq Z\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
P^{A}\triangleq((Z\rightarrow A)\rightarrow Q)\rightarrow Z\rightarrow A\quad.
\]

\end_inset

It follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-composition-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the functor 
\begin_inset Formula $P^{\bullet}$
\end_inset

 is a rigid monad; so 
\begin_inset Formula $P$
\end_inset

's transformer is of the composed-outside kind.
 The the transformed monad for any foreign monad 
\begin_inset Formula $M$
\end_inset

 is 
\begin_inset Formula 
\[
T^{A}\triangleq((Z\rightarrow M^{A})\rightarrow Q)\rightarrow Z\rightarrow M^{A}\quad.
\]

\end_inset

To define the monad methods for 
\begin_inset Formula $T$
\end_inset

, we need to have the definitions of the transformers 
\begin_inset Formula $T_{R_{1}}^{M}$
\end_inset

 and 
\begin_inset Formula $T_{R_{2}}^{M}$
\end_inset

.
 Since both the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monads are special cases of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Choice
\end_layout

\end_inset

 monad construction (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-monad-construction-1-choice"
plural "false"
caps "false"
noprefix "false"

\end_inset

) where the contrafunctor 
\begin_inset Formula $H$
\end_inset

 is chosen to be 
\begin_inset Formula $H^{A}\triangleq A\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq Z$
\end_inset

 respectively, we can use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-T-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods for the transformers 
\begin_inset Formula $T_{R_{1}}^{M}$
\end_inset

 and 
\begin_inset Formula $T_{R_{2}}^{M}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type R1[A] = (A => Q) => A
\end_layout

\begin_layout Plain Layout

def map_R1[A, B](r1: R1[A])(f: A => B): R1[B] = { (b2q: B => Q) => f(r1(f
 andThen b2q)) }
\end_layout

\begin_layout Plain Layout

def flatMap_R1[A, B, M[_]: Monad](r1: R1[M[A]])(f: A => R1[M[B]]): R1[M[B]]
 = {
\end_layout

\begin_layout Plain Layout

  (q: M[B] => Q) => map_R1(r1){ (m: M[A]) => m.flatMap(x => f(x)(q)) }(q)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type R2[A] = Z => A
\end_layout

\begin_layout Plain Layout

def map_R2[A, B](r2: R2[A])(f: A => B): R2[B] = { r2 andThen f }
\end_layout

\begin_layout Plain Layout

def flatMap_R2[A, B, M[_]: Monad](r2: R2[M[A]])(f: A => R2[M[B]]): R2[M[B]]
 = {
\end_layout

\begin_layout Plain Layout

  z => map_R2(r2){ (m: M[A]) => m.flatMap(x => f(x)(z)) }(z)
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\end_inset

Now we can define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method for 
\begin_inset Formula $T$
\end_inset

 by using the monad 
\begin_inset Formula $T_{R_{2}}^{M}$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method for 
\begin_inset Formula $T_{R_{1}}^{M}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type T[A] = R1[R2[A]]
\end_layout

\begin_layout Plain Layout

def flatMap_T[A, B, M[_]: Monad](t: T[M[A]])(f: A => T[M[B]]): T[M[B]] =
 {
\end_layout

\begin_layout Plain Layout

  (q: R2[M[B]] => Q) => map_R1(t){ (m: R2[M[A]]) => flatMap_R2(m)(x => f(x)(q))
 }(q)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Does the composed monad have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

? 
\end_layout

\begin_layout Standard
The definitions of the monad methods for the composed monads are somewhat
 complicated.
 In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-monad-construction-1-choice"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we have proved the monad transformer laws for 
\begin_inset Formula $T_{R}^{M}\triangleq R\circ M$
\end_inset

 by defining a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function with type signature
\begin_inset Formula 
\[
\text{sw}_{R,M}:M\circ R\leadsto R\circ M\quad,
\]

\end_inset

and proving its laws.
 Suppose 
\begin_inset Formula $S$
\end_inset

 is also a rigid monad; then the composed monad 
\begin_inset Formula $R\circ S$
\end_inset

 is a rigid monad.
 Does 
\begin_inset Formula $T\triangleq R\circ S$
\end_inset

 have a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function,
\begin_inset Formula 
\[
\text{sw}_{T,M}:M\circ R\circ S\leadsto R\circ S\circ M\quad,
\]

\end_inset

satisfying all the required laws? If so, we may be able to find a simpler
 definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 for the monad stack 
\begin_inset Formula $R\circ S\circ M$
\end_inset

.
 Let us briefly investigate this question.
 However, keep in mind that the absence of a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function will not invalidate the composition properties of rigid monad
 stacks, because those properties were established without assuming the
 existence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 for the composed monad.
\end_layout

\begin_layout Standard
It turns out that we need yet another law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

3-swap
\begin_inset Quotes erd
\end_inset

 law) if we wish to prove that the composed monad also has a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Theorem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-3-swap-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-3-swap-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that two monads 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 both have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 methods, 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

, satisfying the 
\begin_inset Formula $8$
\end_inset

 laws listed in Theorems
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Theorem-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Additionally, assume that the 
\series bold
3-swap law
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!3-swap law
\end_layout

\end_inset


\series default
 holds with respect to an arbitrary monad 
\begin_inset Formula $M$
\end_inset

,
\begin_inset Formula 
\begin{equation}
\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}=\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\text{sw}_{R,S}\quad.\label{eq:rigid-monad-3-swap-law}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M\circ S\circ R\ar[d]\sb(0.45){\text{sw}_{S,M}}\ar[r]\sp(0.5){\text{sw}_{R,S}^{\uparrow M}} & M\circ R\circ S\ar[r]\sp(0.5){\text{sw}_{R,M}} & R\circ M\circ S\ar[d]\sp(0.4){\text{sw}_{S,M}^{\uparrow R}}\\
S\circ M\circ R\ar[r]\sp(0.5){\text{sw}_{R,M}^{\uparrow S}} & S\circ R\circ M\ar[r]\sp(0.5){\text{sw}_{R,S}} & R\circ S\circ M
}
\]

\end_inset

Then the composed monad 
\begin_inset Formula $T\triangleq R\circ S$
\end_inset

 also has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method defined by 
\begin_inset Formula 
\begin{equation}
\text{sw}_{T,M}=\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\quad,\label{eq:3-swap-def-of-sw-T-M}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{3pc}M\circ R\circ S\ar[rd]\sb(0.45){\text{sw}_{T,M}\triangleq}\ar[r]\sp(0.5){\text{sw}_{R,M}} & R\circ M\circ S\ar[d]\sp(0.5){\text{sw}_{S,M}^{\uparrow R}}\\
 & R\circ S\circ M
}
\]

\end_inset

which satisfies the same 
\begin_inset Formula $8$
\end_inset

 laws.
\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
We need to verify the 
\begin_inset Formula $8$
\end_inset

 laws for 
\begin_inset Formula $\text{sw}_{T,M}$
\end_inset

 (one naturality law, two identity laws, two interchange laws, and three
 monadic naturality laws), assuming that these 
\begin_inset Formula $8$
\end_inset

 laws hold for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

.
 In addition, we assume that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-3-swap-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds, where 
\begin_inset Formula $M$
\end_inset

 is an arbitrary monad.
 The monad methods of 
\begin_inset Formula $T$
\end_inset

 are defined by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) after renaming 
\begin_inset Formula $L\triangleq R$
\end_inset

 and 
\begin_inset Formula $M\triangleq S$
\end_inset

:
\begin_inset Formula 
\begin{align}
\text{pu}_{T} & =\text{pu}_{S}\bef\text{pu}_{R}\quad,\label{eq:3-swap-pu-T-via-pu-R-S}\\
\text{ftn}_{T} & =\text{sw}_{R,S}^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.\label{eq:3-swap-ftn-T-via-sw-R-S}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
As usual, we do not need to verify the naturality law for 
\begin_inset Formula $\text{sw}_{T,M}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
To verify the outer-identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{T}:\quad & \text{pu}_{T}^{\uparrow M}\bef\text{sw}_{T,M}\\
\text{use Eqs.~(\ref{eq:3-swap-def-of-sw-T-M})-(\ref{eq:3-swap-pu-T-via-pu-R-S})}:\quad & =\text{pu}_{S}^{\uparrow M}\bef\gunderline{\text{pu}_{R}^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{outer-identity law for }\text{sw}_{R,M}:\quad & =\text{pu}_{S}^{\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\text{sw}_{S,M}^{\uparrow R}}\\
\text{naturality of }\text{pu}_{R}:\quad & =\gunderline{\text{pu}_{S}^{\uparrow M}\bef\text{sw}_{S,M}}\bef\text{pu}_{R}\\
\text{outer-identity law for }\text{sw}_{S,M}:\quad & =\text{pu}_{S}\bef\text{pu}_{R}\\
\text{use Eq.~(\ref{eq:3-swap-pu-T-via-pu-R-S})}:\quad & =\text{pu}_{T}\quad.
\end{align*}

\end_inset

To verify the inner-identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}^{\uparrow T}:\quad & \text{pu}_{M}\bef\gunderline{\text{sw}_{T,M}}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\gunderline{\text{pu}_{M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,Mi}^{\uparrow R}\\
\text{inner-identity law for }\text{sw}_{R,M}:\quad & =\text{pu}_{M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}=\big(\gunderline{\text{pu}_{M}\bef\text{sw}_{S,M}}\big)^{\uparrow R}\\
\text{inner-identity law for }\text{sw}_{S,M}:\quad & =\text{pu}_{M}^{\gunderline{\uparrow S\uparrow R}}=\text{pu}_{M}^{\uparrow T}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Interchange laws
\end_layout

\begin_layout Standard
The outer-interchange law is
\begin_inset Formula 
\begin{equation}
\text{ftn}_{T}^{\uparrow M}\bef\text{sw}_{T,M}=\text{sw}_{T,M}\bef\text{sw}_{T,M}^{\uparrow T}\bef\text{ftn}_{T}\quad.\label{eq:3-swap-outer-interchange-T}
\end{equation}

\end_inset

We will use the outer-interchange laws for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{ftn}_{R}^{\uparrow M}\bef\text{sw}_{R,M}=\text{sw}_{R,M}\bef\text{sw}_{R,M}^{\uparrow R}\bef\text{ftn}_{R}\quad,\label{eq:3-swap-outer-interchange-R}\\
 & \text{ftn}_{S}^{\uparrow M}\bef\text{sw}_{S,M}=\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}\bef\text{ftn}_{S}\quad.\label{eq:3-swap-outer-interchange-S}
\end{align}

\end_inset

Begin with the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-outer-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) since it is more complicated:
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{T,M}\bef\text{sw}_{T,M}^{\uparrow T}\bef\text{ftn}_{T}\\
\text{definitions}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\big(\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\big)^{\uparrow S\uparrow R}\bef\text{sw}_{R,S}^{\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
^{\uparrow R}\text{-composition}:\quad & =\text{sw}_{R,M}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R\uparrow S}\bef\text{sw}_{R,S}}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{sw's naturality}:\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\text{sw}_{R,S}}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{Eq.~(\ref{eq:rigid-monad-3-swap-law})}:\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.
\end{align*}

\end_inset

In the last expression, all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s are to the right of all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s.
 So we look to rewrite the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-outer-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the same form:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{T}^{\uparrow M}\bef\text{sw}_{T,M}\\
\text{(\ref{eq:3-swap-def-of-sw-T-M}), (\ref{eq:3-swap-ftn-T-via-sw-R-S})}:\quad & =\big(\text{sw}_{R,S}^{\uparrow R}\bef\text{ftn}_{R}\bef\gunderline{\text{ftn}_{S}^{\uparrow R}\big)^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{naturality}:\quad & =\text{sw}_{R,S}^{\uparrow R\uparrow M}\bef\gunderline{\text{ftn}_{R}^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{ftn}_{S}^{\uparrow M\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{Eq.~(\ref{eq:3-swap-outer-interchange-R})}:\quad & =\text{sw}_{R,S}^{\uparrow R\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{R,M}^{\uparrow R}\bef\text{ftn}_{R}\bef\big(\gunderline{\text{ftn}_{S}^{\uparrow M}\bef\text{sw}_{S,M}}\big)^{\uparrow R}\\
\text{Eq.~(\ref{eq:3-swap-outer-interchange-S})}:\quad & =\text{sw}_{R,M}\bef\text{sw}_{R,S}^{\uparrow M\uparrow R}\bef\text{sw}_{R,M}^{\uparrow R}\bef\gunderline{\text{ftn}_{R}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}}\bef\text{ftn}_{S}\big)^{\uparrow R}\\
\text{naturality}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{R,S}^{\uparrow M\uparrow R}\bef\text{sw}_{R,M}^{\uparrow R}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}\big)^{\uparrow R\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{composition}:\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.
\end{align*}

\end_inset

Both sides of the outer-interchange law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-outer-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are now equal.
\end_layout

\begin_layout Standard
The proof of the inner-interchange law is simpler: the law says
\begin_inset Formula 
\begin{equation}
\text{ftn}_{M}\bef\text{sw}_{T,M}=\text{sw}_{T,M}^{\uparrow M}\bef\text{sw}_{T,M}\bef\text{ftn}_{M}^{\uparrow T}\quad.\label{eq:3-swap-inner-interchange-T}
\end{equation}

\end_inset

We will use the inner-interchange laws for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{ftn}_{M}\bef\text{sw}_{R,M}=\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{ftn}_{M}^{\uparrow R}\quad,\label{eq:3-swap-inner-interchange-R}\\
 & \text{ftn}_{M}\bef\text{sw}_{S,M}=\text{sw}_{S,M}^{\uparrow M}\bef\text{sw}_{S,M}\bef\text{ftn}_{M}^{\uparrow S}\quad.\label{eq:3-swap-inner-interchange-S}
\end{align}

\end_inset

Begin with the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-inner-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{M}\bef\text{sw}_{T,M}=\gunderline{\text{ftn}_{M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{use Eq.~(\ref{eq:3-swap-inner-interchange-R})}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\text{ftn}_{M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}}\\
\text{use Eq.~(\ref{eq:3-swap-inner-interchange-S}) under }^{\uparrow R}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\big(\text{sw}_{S,M}^{\uparrow M}\bef\text{sw}_{S,M}\bef\text{ftn}_{M}^{\uparrow S}\big)^{\uparrow R}}\\
\text{composition under }^{\uparrow R}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow M\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}}
\end{align*}

\end_inset

The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-inner-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{T,M}^{\uparrow M}\bef\text{sw}_{T,M}\bef\text{ftn}_{M}^{\uparrow T}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\big(\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\big)^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}\\
\text{naturality of }\text{sw}_{R,M}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\gunderline{\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow M\uparrow R}}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}\quad.
\end{align*}

\end_inset

The right-hand side is now equal to the left-hand side.
\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
We need to verify that the three laws,
\begin_inset Formula 
\[
\text{sw}_{T,\text{Id}}=\text{id}\quad,\quad\quad\text{sw}_{T,M}\bef\phi^{\uparrow T}=\phi\bef\text{sw}_{T,N}\quad,\quad\quad\text{sw}_{T,M}\bef\theta=\theta^{\uparrow M}\quad,
\]

\end_inset

hold for any monad morphisms 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:T\leadsto\text{Id}$
\end_inset

.
 We may assume that these laws already hold for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the first law, write
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{sw}_{T,\text{Id}}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\text{sw}_{R,\text{Id}}\bef\text{sw}_{S,\text{Id}}^{\uparrow R}\\
\text{first law for }\text{sw}_{R,\text{Id}}\text{ and }\text{sw}_{S,\text{Id}}:\quad & =\text{id}\bef\text{id}^{\uparrow R}=\text{id}\quad.
\end{align*}

\end_inset

To verify the second law, write
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\phi\bef\text{sw}_{T,N}:\quad & \text{sw}_{T,M}\bef\phi^{\uparrow T}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\phi^{\uparrow S\uparrow R}}\\
\text{second law for }\text{sw}_{S,M}\text{ under }^{\uparrow R}:\quad & =\gunderline{\text{sw}_{R,M}\bef\big(\phi}\bef\text{sw}_{S,N}\big)^{\uparrow R}\\
\text{second law for }\text{sw}_{R,M}:\quad & =\phi\bef\gunderline{\text{sw}_{R,N}\bef\text{sw}_{S,N}^{\uparrow R}}=\phi\bef\gunderline{\text{sw}_{T,N}}\quad.
\end{align*}

\end_inset

To verify the third law, we begin with the left-hand side,
\begin_inset Formula 
\[
\text{sw}_{T,M}\bef\theta=\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\bef\theta\quad.
\]

\end_inset

At this point, no relationship or law applies to the intermediate expression
 
\begin_inset Formula $\text{sw}_{S,M}^{\uparrow R}\bef\theta$
\end_inset

, so we need additional information to proceed.
 This information is given by Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Lemma-base-runner-for-composed-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which expresses 
\begin_inset Formula $\theta=\theta_{R}\bef\theta_{S}$
\end_inset

 where 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 are monad morphisms.
 So, we may use 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 with the monad morphism laws for 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, in particular with the third law:
\begin_inset Formula 
\[
\text{sw}_{R,M}\bef\theta_{R}=\theta_{R}^{\uparrow M}\quad,\quad\quad\text{sw}_{S,M}\bef\theta_{S}=\theta_{S}^{\uparrow M}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Now we can finish the proof of the third monadic naturality law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\theta^{\uparrow M}:\quad & \text{sw}_{T,M}\bef\gunderline{\theta}\\
\text{Lemma~\ref{subsec:Lemma-base-runner-for-composed-monad}}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\theta_{R}}\bef\theta_{S}\\
\text{naturality of }\theta_{R}:\quad & =\gunderline{\text{sw}_{R,M}\bef\theta_{R}}\bef\gunderline{\text{sw}_{S,M}\bef\theta_{S}}\\
\text{third law for }R\text{ and }S:\quad & =\theta_{R}^{\uparrow M}\bef\theta_{S}^{\uparrow M}=\theta^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Lemma 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Lemma-base-runner-for-composed-monad"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $R$
\end_inset

 is a rigid monad with a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 is any (not necessarily rigid) monad then any monad morphism 
\begin_inset Formula $\theta:R\circ S\leadsto\text{Id}$
\end_inset

 can be expressed as a composition 
\begin_inset Formula $\theta=\theta_{R}\bef\theta_{S}$
\end_inset

 where 
\begin_inset Formula 
\[
\theta_{R}\triangleq\text{pu}_{S}^{\uparrow R}\bef\theta\quad,\quad\quad\theta_{S}\triangleq\text{pu}_{R}\bef\theta
\]

\end_inset

are monad morphisms.
 In other words, all 
\begin_inset Quotes eld
\end_inset

runners
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\theta$
\end_inset

 for the composed monad 
\begin_inset Formula $R\circ S$
\end_inset

 can be written as a function composition of some 
\begin_inset Quotes eld
\end_inset

runners
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\theta_{R}:R\leadsto\text{Id}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}:S\leadsto\text{Id}$
\end_inset

 for the monads 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
How can we find 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 from the given 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\theta$
\end_inset

? Consider that 
\begin_inset Formula $\theta$
\end_inset

 will evaluate the operations of both monads 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, while 
\begin_inset Formula $\theta_{R}$
\end_inset

 can evaluate only the operations of 
\begin_inset Formula $R$
\end_inset

.
 To obtain 
\begin_inset Formula $\theta_{R}:R\leadsto\text{Id}$
\end_inset

 from 
\begin_inset Formula $\theta:R\circ S\leadsto\text{Id}$
\end_inset

, we need to prepend a function 
\begin_inset Formula $R\leadsto R\circ S$
\end_inset

.
 A suitable function of this type is 
\begin_inset Formula 
\[
\text{pu}_{S}^{\uparrow R}:R^{A}\rightarrow R^{S^{A}}\quad.
\]

\end_inset

So, 
\begin_inset Formula $\theta_{R}=\text{pu}_{S}^{\uparrow R}\bef\theta$
\end_inset

 has the correct type signature, 
\begin_inset Formula $R^{A}\rightarrow A$
\end_inset

.
 Similarly, 
\begin_inset Formula $\theta_{S}=\text{pu}_{R}\bef\theta$
\end_inset

 has the correct type signature, 
\begin_inset Formula $S^{A}\rightarrow A$
\end_inset

.
 So, we can define 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 from the given 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\theta$
\end_inset

 as
\begin_inset Formula 
\[
\theta_{R}\triangleq\text{pu}_{S}^{\uparrow R}\bef\theta\quad,\quad\quad\theta_{S}\triangleq\text{pu}_{R}\bef\theta\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{S}^{\uparrow R}$
\end_inset

 are the lifting and the base lifting of the monad transformer 
\begin_inset Formula $T_{R}^{S}=R\circ S$
\end_inset

, Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theorem-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{S}^{\uparrow R}$
\end_inset

 are monad morphisms.
 Since the composition of monad morphisms is again a monad morphism (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we see that 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 as defined above are monad morphisms.
\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset Formula $\theta=\theta_{R}\bef\theta_{S}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\theta:\quad & \theta_{R}\bef\theta_{S}=\text{pu}_{S}^{\uparrow R}\bef\gunderline{\theta\bef\text{pu}_{R}}\bef\theta\\
\text{naturality of }\theta:\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\gunderline{\uparrow T}}\bef\theta\bef\theta=\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\theta\bef\theta}\\
\text{composition law of }\theta:\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\text{ftn}_{T}\bef\theta}\quad.
\end{align*}

\end_inset

The last line differs from the required result, 
\begin_inset Formula $\theta$
\end_inset

, by the function 
\begin_inset Formula $\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\text{ftn}_{T}$
\end_inset

.
 We will finish the proof if we show that this function is identity:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\text{ftn}_{T}}\quad.\\
\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:\quad & =\text{pu}_{S}^{\uparrow R}\bef\gunderline{\text{pu}_{R}^{\uparrow S\uparrow R}\bef\text{sw}_{R,S}^{\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{outer-identity law for }\text{sw}_{R,S}:\quad & =\text{pu}_{S}^{\uparrow R}\bef\gunderline{\text{pu}_{R}^{\uparrow R}\bef\text{ftn}_{R}}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{identity law for }R:\quad & =\gunderline{\text{pu}_{S}^{\uparrow R}\bef\text{ftn}_{S}^{\uparrow R}}\\
\text{identity law for }S:\quad & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Rigid monad construction 3: product
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-product-rigid-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The product of rigid monads, 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

, is a rigid monad.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
If we show that 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

 has a composed-outside transformer, it will follow (by definition) that
 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

 is a rigid monad.
 It follows from Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-of-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (whose proof does not depend on any of the results of this section) that
 the lawful monad transformer 
\begin_inset Formula $T^{M,A}$
\end_inset

 for the product monad 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

 is the product of transformers 
\begin_inset Formula 
\[
T_{R_{1}}^{M,A}\times T_{R_{2}}^{M,A}=R_{1}^{M^{A}}\times R_{2}^{M^{A}}\quad,
\]

\end_inset

where 
\begin_inset Formula $M$
\end_inset

 is the foreign monad.
 This is the required composed-outside transformer for the monad 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

.
\end_layout

\begin_layout Subsection
Rigid monad construction 4: selector
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
selector monad
\end_layout

\end_inset


\series bold
selector monad
\series default
 
\begin_inset Formula $S^{A}\triangleq F^{A\rightarrow R^{Q}}\rightarrow R^{A}$
\end_inset

 is rigid if 
\begin_inset Formula $R^{\bullet}$
\end_inset

 is a rigid monad, 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is any functor, and 
\begin_inset Formula $Q$
\end_inset

 is any fixed type.
\end_layout

\begin_layout Subsection
Rigid functors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Rigid-functors"

\end_inset


\end_layout

\begin_layout Standard
The properties of rigid monads can be extended to a (possibly) larger class
 of rigid functors.
 We begin with a definition of a rigid functor that, unlike the definition
 of rigid monads (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:transformers-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

), does not refer to any monad transformer.
\end_layout

\begin_layout Paragraph
Definition of rigid functors
\end_layout

\begin_layout Standard
\begin_inset Formula $R$
\end_inset

 is a 
\series bold
rigid functor
\begin_inset Index idx
status open

\begin_layout Plain Layout
rigid functor
\end_layout

\end_inset


\series default
 if there exists a natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{fi}_{R}$
\end_inset


\begin_inset Quotes erd
\end_inset

) with the type signature
\begin_inset Formula 
\[
\text{fi}_{R}:\forall(A,B).\,(A\rightarrow R^{B})\rightarrow R^{A\rightarrow B}
\]

\end_inset

satisfying the non-degeneracy law
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (see below).
\end_layout

\begin_layout Standard
Not all functors admit a natural transformation with the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

.
 For example, the functor 
\begin_inset Formula $F^{A}\triangleq Z+A$
\end_inset

 is not rigid because the required type signature 
\begin_inset Formula 
\[
\forall(A,B).\,\left(A\rightarrow Z+B\right)\rightarrow Z+\left(A\rightarrow B\right)
\]

\end_inset

cannot be implemented.
 However, any functor 
\begin_inset Formula $R$
\end_inset

 admits the opposite natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseOut
\end_layout

\end_inset

 (short notation 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

), defined by
\begin_inset Formula 
\begin{align}
\text{fo} & :\forall(A,B).\,R^{A\rightarrow B}\rightarrow A\rightarrow R^{B}\quad,\nonumber \\
\text{fo} & \left(r\right)=a\rightarrow\big(f^{:A\rightarrow B}\rightarrow f\left(a\right)\big)^{\uparrow R}r\quad.\label{eq:fuseOut-def}
\end{align}

\end_inset

The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

 must satisfy the nondegeneracy law 
\begin_inset Formula 
\begin{equation}
\text{fi}_{R}\bef\text{fo}_{R}=\text{id}^{:(A\rightarrow R^{B})\rightarrow(A\rightarrow R^{B})}\quad.\label{eq:rigid-non-degeneracy-law}
\end{equation}

\end_inset

The opposite relation does not hold in general, 
\begin_inset Formula $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$
\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-fo-fi-not-id"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Note that the type signature of 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 is the same as the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 with respect to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad,
\begin_inset Formula 
\[
\text{sw}_{R,M}:M^{R^{A}}\rightarrow R^{M^{A}}\cong(Z\rightarrow R^{A})\rightarrow R^{Z\rightarrow A}\text{ if we set }M^{A}\triangleq Z\rightarrow A\quad.
\]

\end_inset

So we are prompted to ask whether any rigid monad having a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method might also admit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

.
 It turns out that all rigid monads (regardless of the existence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

) are also rigid functors.
 While proving that statement, we will not assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 exists for the monad 
\begin_inset Formula $R$
\end_inset

, but will use directly the definition of rigid monads via the composed-outside
 monad transformer.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-monads-are-rigid-functors"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-monads-are-rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A rigid monad 
\begin_inset Formula $R$
\end_inset

 is also a rigid functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
By assumption, the monad 
\begin_inset Formula $R$
\end_inset

 has the composed-outside monad transformer 
\begin_inset Formula $T_{R}^{M}=R\circ M$
\end_inset

 and the corresponding monad method 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 We can define the transformation 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 in the same way as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) defined the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method via 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 To use that formula, we need to set the foreign monad 
\begin_inset Formula $M$
\end_inset

 to be the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad, 
\begin_inset Formula $M^{B}\triangleq A\rightarrow B$
\end_inset

, with the fixed environment type 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{fi}_{R}(f^{:A\rightarrow R^{B}})=\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\text{ftn}_{T}\label{eq:rigid-monad-fuseIn-def}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2pc}\xyScaleX{4pc}A\rightarrow R^{B}\ar[r]\sp(0.5){\text{pu}_{M}^{\uparrow R\uparrow M}}\ar[rrd]\sb(0.5){\text{fi}_{R}\triangleq} & A\rightarrow R^{A\rightarrow B}\ar[r]\sp(0.5){\text{pu}_{R}} & R^{A\rightarrow R^{A\rightarrow B}}\ar[d]\sp(0.45){\text{ftn}_{T}}\\
 &  & R^{A\rightarrow B}
}
\]

\end_inset

Since 
\begin_inset Formula $M$
\end_inset

 is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad with the environment type 
\begin_inset Formula $A$
\end_inset

, we have
\begin_inset Formula 
\[
\text{pu}_{M}(x)=(\_^{:A}\rightarrow x)\quad,\quad\quad(f^{:X\rightarrow Y})^{\uparrow M}(r^{:A\rightarrow X})=r\bef f\quad.
\]

\end_inset

The type signature of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseOut
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{fo}:R^{A\rightarrow B}\rightarrow A\rightarrow R^{B}\quad,
\]

\end_inset

resembles 
\begin_inset Quotes eld
\end_inset

running
\begin_inset Quotes erd
\end_inset

 the composed monad 
\begin_inset Formula $R^{M^{B}}$
\end_inset

 into 
\begin_inset Formula $R^{B}$
\end_inset

, given a value of the environment (of type 
\begin_inset Formula $A$
\end_inset

).
 Indeed, given a fixed value 
\begin_inset Formula $a^{:A}$
\end_inset

, we can 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad into the identity monad.
 The corresponding 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\phi_{a}^{:M\leadsto\text{Id}}$
\end_inset

 is
\begin_inset Formula 
\begin{equation}
\phi_{a}^{:M^{X}\rightarrow X}=\big(m^{A\rightarrow X}\rightarrow m(a)\big)\quad.\label{eq:runner-phi-def}
\end{equation}

\end_inset

So we are inspired to use the runner law for the monad transformer 
\begin_inset Formula $T_{R}^{M}$
\end_inset

.
 That law (which holds since we assumed that 
\begin_inset Formula $T_{R}^{M}$
\end_inset

 satisfies all laws) says that the lifted 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\phi_{a}^{\uparrow R}$
\end_inset

 is a monad morphism 
\begin_inset Formula $T_{R}^{M}\leadsto T_{R}^{\text{Id}}\cong T_{R}^{M}\leadsto R$
\end_inset

.
 The monad morphism law for 
\begin_inset Formula $\phi_{a}^{\uparrow R}$
\end_inset

 is then written as
\begin_inset Formula 
\begin{equation}
\text{ftn}_{T}\bef\phi_{a}^{\uparrow R}=\phi_{a}^{\uparrow R\uparrow M\uparrow R}\bef\phi_{a}^{\uparrow R}\bef\text{ftn}_{R}\quad.\label{eq:rigid-monad-is-rigid-functor-derivation1}
\end{equation}

\end_inset

How could we use this law to obtain Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Compare Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fuseOut-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:runner-phi-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and derive the connection between the 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\phi_{a}$
\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseOut
\end_layout

\end_inset

 function (which always exists for any functor 
\begin_inset Formula $R$
\end_inset

),
\begin_inset Formula 
\[
\text{fo}_{R}=\big(r\rightarrow a\rightarrow r\triangleright\phi_{a}^{\uparrow R}\big)\quad,
\]

\end_inset

and then rewrite the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\begin{align*}
\text{expect to equal }m:\quad & m^{:M^{R^{B}}}\triangleright\text{fi}_{R}\bef\text{fo}_{R}=\left(m\triangleright\text{fi}_{R}\right)\triangleright\gunderline{\text{fo}_{R}}\\
\text{use Eq.~(\ref{eq:fuseOut-def})}:\quad & =a\rightarrow m\triangleright\gunderline{\text{fi}_{R}}\triangleright\phi_{a}^{\uparrow R}\\
\text{use Eq.~(\ref{eq:rigid-monad-fuseIn-def})}:\quad & =a\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\gunderline{\text{ftn}_{T}\bef\phi_{a}^{\uparrow R}}\\
\text{use Eq.~(\ref{eq:rigid-monad-is-rigid-functor-derivation1})}:\quad & =a\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\phi_{a}^{\uparrow R\uparrow M\uparrow R}\bef\phi_{a}^{\uparrow R}}\bef\text{ftn}_{R}\\
\text{naturality of }\text{pu}_{R}:\quad & =a\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\phi_{a}^{\uparrow R\uparrow M}\bef\phi_{a}\bef\gunderline{\text{pu}_{R}\bef\text{ftn}_{R}}\\
\text{left identity law of }R:\quad & =a\rightarrow m\triangleright\gunderline{(\text{pu}_{M}\bef\phi_{a})}^{\uparrow R\uparrow M}\bef\phi_{a}\\
\text{identity law for }\phi_{a}:\quad & =a\rightarrow m\triangleright\gunderline{\phi_{a}}\\
\text{definition~(\ref{eq:runner-phi-def}) for }\phi_{a}:\quad & =\gunderline{\left(a\rightarrow m(a)\right)}=m\quad.
\end{align*}

\end_inset

Here we used the monad morphism identity law for 
\begin_inset Formula $\phi_{a}$
\end_inset

,
\begin_inset Formula 
\[
\text{pu}_{M}\bef\phi_{a}=\big(x\rightarrow(\_\rightarrow x)\big)\bef(m\rightarrow a\triangleright m)=\left(x\rightarrow a\triangleright(\_\rightarrow x)\right)=\left(x\rightarrow x\right)=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-fo-fi-not-id"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-fo-fi-not-id"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To show that the opposite of the non-degeneracy law does not always hold,
 consider the rigid monads 
\begin_inset Formula $P^{A}\triangleq Z\rightarrow A$
\end_inset

 and 
\begin_inset Formula $R^{A}\triangleq\left(A\rightarrow Q\right)\rightarrow A$
\end_inset

, where 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 are fixed types.
 Since all rigid monads are rigid functors, it follows that the monads 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 have methods 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

, 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

, 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

, 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

 satisfying the non-degeneracy law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It turns out that additionally 
\begin_inset Formula $\text{fo}_{P}\bef\text{fi}_{P}=\text{id}$
\end_inset

, i.e.
\begin_inset space ~
\end_inset

the methods 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

 are inverses of each other, but 
\begin_inset Formula $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{fo}_{P}\bef\text{fi}_{P}=\text{id}$
\end_inset

, consider the type signatures of 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{fo}_{P} & :P^{A\rightarrow B}\rightarrow A\rightarrow P^{B}\cong\left(Z\rightarrow A\rightarrow B\right)\rightarrow\left(A\rightarrow Z\rightarrow B\right)\quad,\\
\text{fi}_{P} & :\big(A\rightarrow P^{B}\big)\rightarrow P^{A\rightarrow B}\cong\left(A\rightarrow Z\rightarrow B\right)\rightarrow\left(Z\rightarrow A\rightarrow B\right)\quad.
\end{align*}

\end_inset

The implementations of these functions are derived uniquely from type signatures
, as long as we require that these implementations are natural transformations.
 The functions 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

 switch the curried arguments of types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 of a function that returns values of type 
\begin_inset Formula $B$
\end_inset

.
 It is clear that these two functions are inverses of each other.
 To show this directly, consider the type signature of 
\begin_inset Formula $\text{fo}_{P}\bef\text{fi}_{P}$
\end_inset

,
\begin_inset Formula 
\[
\big(\text{fo}_{P}\bef\text{fi}_{P}\big):P^{A\rightarrow B}\rightarrow P^{A\rightarrow B}\cong\left(Z\rightarrow A\rightarrow B\right)\rightarrow\left(Z\rightarrow A\rightarrow B\right)\quad.
\]

\end_inset

There is only one implementation for this type signature as a natural transforma
tion, namely the identity function 
\begin_inset Formula $\text{id}^{Z\rightarrow A\rightarrow B}$
\end_inset

.
\end_layout

\begin_layout Standard
For the monad 
\begin_inset Formula $R$
\end_inset

, the type signatures of 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

 are
\begin_inset Formula 
\begin{align*}
\text{fi}_{R} & :\left(A\rightarrow\left(B\rightarrow Q\right)\rightarrow B\right)\rightarrow\left(\left(A\rightarrow B\right)\rightarrow Q\right)\rightarrow A\rightarrow B\quad,\\
\text{fo}_{R} & :\left(\left(\left(A\rightarrow B\right)\rightarrow Q\right)\rightarrow A\rightarrow B\right)\rightarrow A\rightarrow\left(B\rightarrow Q\right)\rightarrow B\quad,
\end{align*}

\end_inset

and the implementations are again derived uniquely from type signatures,
\begin_inset Formula 
\begin{align*}
f^{:A\rightarrow\left(B\rightarrow Q\right)\rightarrow B} & \triangleright\text{fi}_{R}=x^{:\left(A\rightarrow B\right)\rightarrow Q}\rightarrow a^{:A}\rightarrow f(a)(b^{:B}\rightarrow x(\_\rightarrow b))\quad,\\
g^{:\left(\left(A\rightarrow B\right)\rightarrow Q\right)\rightarrow A\rightarrow B} & \triangleright\text{fo}_{R}=a^{:A}\rightarrow y^{:B\rightarrow Q}\rightarrow g(h^{:A\rightarrow B}\rightarrow y(h(a)))(a)\quad.
\end{align*}

\end_inset

We notice that the implementation of 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 uses a constant function, 
\begin_inset Formula $\left(\_\rightarrow b\right)$
\end_inset

, which is likely to lose information.
 Indeed, while 
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$
\end_inset

 as it must be due to the rigid non-degeneracy law, we find that 
\begin_inset Formula 
\begin{align*}
\text{expect \emph{not} to equal }g:\quad & g\triangleright\text{fo}_{R}\bef\text{fi}_{R}=\left(g\triangleright\text{fo}_{R}\right)\triangleright\gunderline{\text{fi}_{R}}\\
\text{definition of }\text{fi}_{R}:\quad & =x\rightarrow a\rightarrow\gunderline{\text{fo}_{R}}(g)(a)(b\rightarrow x(\_\rightarrow b))\\
\text{definition of }\text{fo}_{R}:\quad & =x\rightarrow a\rightarrow g\big(h^{:A\rightarrow B}\rightarrow h(a)\triangleright\gunderline{(b\rightarrow}x(\_\rightarrow b))\big)(a)\\
\text{apply to argument }b:\quad & =x\rightarrow a\rightarrow g\big(h\rightarrow x(\_\rightarrow h(a))\big)(a)\quad.
\end{align*}

\end_inset

We cannot simplify the last line any further: the functions 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 are unknown, and we cannot calculate symbolically, say, the value of 
\begin_inset Formula $x(\_\rightarrow h(a))$
\end_inset

.
 If the last line were equal to 
\begin_inset Formula $g$
\end_inset

, we would expect it to be 
\begin_inset Formula $x\rightarrow a\rightarrow g(x)(a)$
\end_inset

.
 The difference is in the first argument of 
\begin_inset Formula $g$
\end_inset

, namely we have 
\begin_inset Formula $h\rightarrow x(\_\rightarrow h(a))$
\end_inset

 instead of 
\begin_inset Formula $x$
\end_inset

.
 The two last expressions are not always equal; they would be equal if we
 had 
\begin_inset Formula 
\[
\left(h\rightarrow x(h)\right)=\left(h\rightarrow x(k\rightarrow h(k))\right)
\]

\end_inset

instead of 
\begin_inset Formula $h\rightarrow x(\_\rightarrow h(a))$
\end_inset

.
 Consider again the argument of 
\begin_inset Formula $x$
\end_inset

 in the two last expressions: 
\begin_inset Formula $k\rightarrow h(a)$
\end_inset

 instead of 
\begin_inset Formula $k\rightarrow h(k)$
\end_inset

.
 Since 
\begin_inset Formula $h$
\end_inset

 is not always a constant function (
\begin_inset Formula $h$
\end_inset

 is an arbitrary function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

), the two expressions 
\begin_inset Formula $k\rightarrow h(a)$
\end_inset

 and 
\begin_inset Formula $k\rightarrow h(k)$
\end_inset

 are generally not equal.
 So, we must conclude that 
\begin_inset Formula $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-pair-functor-is-rigid"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-pair-functor-is-rigid"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Show that the functor 
\begin_inset Formula $F^{A}\triangleq A\times A\times A$
\end_inset

 is rigid.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-option-not-rigid"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-option-not-rigid"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the functor 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A$
\end_inset

 is not rigid.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-continuation-not-rigid-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-continuation-not-rigid-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the functor 
\begin_inset Formula $F^{A}\triangleq\left(A\rightarrow Z\right)\rightarrow Z$
\end_inset

 is not rigid.
 (Here 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.)
\end_layout

\begin_layout Standard
Since all rigid monads are rigid functors, we can reuse all the rigid monad
 constructions to obtain new rigid functors.
 The following statement demonstrates a construction of rigid functors that
 does not assume any monadic properties.
 It shows that the set of all rigid functors is larger than the set of all
 rigid monads.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-h-p"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-h-p"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $S^{\bullet}\triangleq H^{\bullet}\rightarrow P^{\bullet}$
\end_inset

 is rigid when 
\begin_inset Formula $H$
\end_inset

 is any contrafunctor and 
\begin_inset Formula $P$
\end_inset

 is any rigid functor.
 (Note that 
\begin_inset Formula $P$
\end_inset

 does not need to be a monad.)
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We assume that 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 are known and satisfy the non-degeneracy law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The function 
\begin_inset Formula $\text{fi}_{S}$
\end_inset

 is then defined by
\begin_inset Formula 
\begin{align*}
\text{fi}_{S} & :\big(A\rightarrow H^{B}\rightarrow P^{B}\big)\rightarrow H^{A\rightarrow B}\rightarrow P^{A\rightarrow B}\quad,\\
\text{fi}_{S} & =f^{:A\rightarrow H^{B}\rightarrow P^{B}}\rightarrow h^{:H^{A\rightarrow B}}\rightarrow\text{fi}_{P}\big(a\rightarrow f(a)\big(\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}h\big)\big)\quad,
\end{align*}

\end_inset

or, using the forwarding notation,
\begin_inset Formula 
\[
h\triangleright\text{fi}_{S}(f)=\big(a\rightarrow h\triangleright\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}\triangleright f(a)\big)\triangleright\text{fi}_{P}\quad.
\]

\end_inset

Let us write the definition of 
\begin_inset Formula $\text{fo}_{S}$
\end_inset

 as well,
\begin_inset Formula 
\begin{align*}
\text{fo}_{S} & :\big(H^{A\rightarrow B}\rightarrow P^{A\rightarrow B}\big)\rightarrow A\rightarrow H^{B}\rightarrow P^{B}\quad,\\
\text{fo}_{S} & =g^{:H^{A\rightarrow B}\rightarrow P^{A\rightarrow B}}\rightarrow a^{:A}\rightarrow h^{:H^{B}}\rightarrow\text{fo}_{P}\bigg(g\big(\left(p^{:A\rightarrow B}\rightarrow p(a)\right)^{\downarrow H}h\big)\bigg)(a)\quad,
\end{align*}

\end_inset

or, using the forwarding notation,
\begin_inset Formula 
\[
\text{fo}_{S}(g)=a\triangleright\big(h\triangleright\left(p\rightarrow p(a)\right)^{\downarrow H}\bef g\bef\text{fo}_{P}\big)\quad.
\]

\end_inset

To verify the non-degeneracy law for 
\begin_inset Formula $S$
\end_inset

, apply both sides to some arguments; we expect 
\begin_inset Formula $f\triangleright(\text{fi}_{S}\bef\text{fo}_{S})$
\end_inset

 to equal 
\begin_inset Formula $f$
\end_inset

 for an arbitrary 
\begin_inset Formula $f:A\rightarrow H^{B}\rightarrow P^{B}$
\end_inset

.
 To compare values, we need to apply both sides further to some arguments
 
\begin_inset Formula $a:A$
\end_inset

 and 
\begin_inset Formula $h:H^{B}$
\end_inset

.
 So we expect the following expression to equal 
\begin_inset Formula $f(a)(h)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\quad & \left(f\triangleright\text{fi}_{S}\bef\text{fo}_{S}\right)(a)(h)=(f\triangleright\text{fi}_{S}\triangleright\gunderline{\text{fo}_{S}})(a)(h)\\
\text{expand }\text{fo}_{S}:\quad & =a\triangleright\big(h\triangleright\left(p\rightarrow a\triangleright p\right)^{\downarrow H}\triangleright\gunderline{\text{fi}_{S}(f)}\triangleright\text{fo}_{P}\big)\\
\text{expand }\text{fi}_{S}:\quad & =a\triangleright\big(\big(a\rightarrow h\triangleright\gunderline{\left(p\rightarrow p(a)\right)^{\downarrow H}\bef\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\triangleright\text{fo}_{P}\big)\\
\text{compose }^{\downarrow H}:\quad & =a\triangleright\big(\big(a\rightarrow h\triangleright\gunderline{\left((b\rightarrow\_\rightarrow b)\bef(p\rightarrow p(a))\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\gunderline{\triangleright}\text{fo}_{P}\big)\quad.
\end{align*}

\end_inset

Computing the function composition
\begin_inset Formula 
\[
(b\rightarrow\_\rightarrow b)\bef(p\rightarrow p(a))=(b\rightarrow(\_\rightarrow b)(a))=(b\rightarrow b)=\text{id}\quad,
\]

\end_inset

and using the non-degeneracy law 
\begin_inset Formula $\text{fi}_{P}\bef\text{fo}_{P}=\text{id}$
\end_inset

, we can simplify further:
\begin_inset Formula 
\begin{align*}
 & a\triangleright\big(\big(a\rightarrow h\triangleright\gunderline{\left((b\rightarrow\_\rightarrow b)\bef(p\rightarrow p(a))\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\gunderline{\triangleright}\text{fo}_{P}\big)\\
\text{identity law for }H:\quad & =a\triangleright\big(\big(a\rightarrow h\triangleright f(a)\big)\triangleright\gunderline{\text{fi}_{P}\bef\text{fo}_{P}}\big)\\
\text{non-degeneracy}:\quad & =\gunderline{a\triangleright\big(a\rightarrow}h\triangleright f(a)\big)=h\triangleright f(a)\quad.
\end{align*}

\end_inset

This equals 
\begin_inset Formula $f(a)(h)$
\end_inset

, as required.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Statement 1.
\end_layout

\begin_layout Plain Layout
The composition 
\begin_inset Formula $R_{1}^{R_{2}^{\bullet}}$
\end_inset

 is a rigid functor if both 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 are rigid functors.
\end_layout

\begin_layout Plain Layout
Proof
\end_layout

\begin_layout Plain Layout
We will show that the non-degeneracy law 
\begin_inset Formula $\text{fi}_{T}\bef\text{fo}_{T}=\text{id}$
\end_inset

 holds for the rigid functor 
\begin_inset Formula $T^{\bullet}\triangleq R^{M^{\bullet}}$
\end_inset

 as long as 
\begin_inset Formula $M$
\end_inset

 is rigid.
\end_layout

\begin_layout Plain Layout
Since it is given that 
\begin_inset Formula $M$
\end_inset

 is rigid, we may use its method 
\begin_inset Formula $\text{fi}_{M}$
\end_inset

 satisfying the non-degeneracy law 
\begin_inset Formula $\text{fo}_{M}\left(\text{fi}_{M}\,f\right)=f$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Flip the curried arguments of the function type 
\begin_inset Formula $A\rightarrow T^{B}\triangleq A\rightarrow H^{M^{B}}\rightarrow M^{B}$
\end_inset

, to obtain 
\begin_inset Formula $H^{M^{B}}\rightarrow A\rightarrow M^{B}$
\end_inset

, and note that 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 can be mapped to 
\begin_inset Formula $M^{A\rightarrow B}$
\end_inset

 using 
\begin_inset Formula $\text{fi}_{M}$
\end_inset

.
 So we can implement 
\begin_inset Formula $\tilde{\text{fi}}_{T}$
\end_inset

 using 
\begin_inset Formula $\text{fi}_{M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\tilde{\text{fi}}_{T} & :\big(H^{M^{B}}\rightarrow A\rightarrow M^{B}\big)\rightarrow H^{M^{A\rightarrow B}}\rightarrow M^{A\rightarrow B}\\
\tilde{\text{fi}}_{T} & =f\rightarrow h\rightarrow\text{fi}_{M}\left(f\big(\left(b\rightarrow\_\rightarrow b\right)^{\uparrow M\downarrow H}h\big)\right)\\
\tilde{\text{fo}}_{T} & :\left(H^{M^{A\rightarrow B}}\rightarrow M^{A\rightarrow B}\right)\rightarrow H^{M^{B}}\rightarrow A\rightarrow M^{B}\\
\tilde{\text{fo}}_{T} & =g\rightarrow h\rightarrow a\rightarrow\text{fo}_{M}\left(g\big(\left(p^{:A\rightarrow B}\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)a
\end{align*}

\end_inset

To show the non-degeneracy law for 
\begin_inset Formula $T$
\end_inset

, compute
\begin_inset Formula 
\begin{align*}
 & \tilde{\text{fo}}_{T}\left(\tilde{\text{fi}}_{T}f\right)h^{:H^{M^{B}}}a^{:A}\\
\text{insert the definition of }\tilde{\text{fo}}_{T}\text{: }\quad & =\text{fo}_{M}\left(\left(\tilde{\text{fi}}_{T}f\right)\big(\left(p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)a\\
\text{insert the definition of }\tilde{\text{fi}}_{T}\text{: }\quad & =\text{fo}_{M}\left(\text{fi}_{M}\left(f\big(\left(b\rightarrow\_\rightarrow b\right)^{\uparrow M\downarrow H}\left(p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)\right)a\\
\text{nondegeneracy law for }\text{fi}_{M}\text{: }\quad & =f\big(\left(b\rightarrow\_\rightarrow b\right)^{\uparrow M\downarrow H}\left(p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)a\\
\text{composition laws for }M,H\text{: }\quad & =f\big(\left(b\rightarrow\_\rightarrow b\bef p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)a\\
\text{simplify }\text{: }\quad & =f\left(\left(b\rightarrow b\right)^{\uparrow M\downarrow H}h\right)a\\
\text{identity laws for }M,H\text{: }\quad & =f\,h\,a\quad.
\end{align*}

\end_inset

We obtained 
\begin_inset Formula $\tilde{\text{fo}}_{T}\left(\tilde{\text{fi}}_{T}\,f\right)h\,a=f\,h\,a$
\end_inset

.
 Therefore the non-degeneracy law 
\begin_inset Formula $\tilde{\text{fi}}_{T}\bef\tilde{\text{fo}}_{T}=\text{id}$
\end_inset

 holds.
 
\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Trying the triangle notation: It seems that 
\begin_inset Formula $\left(a\triangleright\right)$
\end_inset

 is not so useful, we could just write 
\begin_inset Formula $\left(f\rightarrow f(a)\right)$
\end_inset

 instead.
\begin_inset Formula 
\begin{align*}
\tilde{\text{fi}}\left(f\right) & =f\triangleright\tilde{\text{fi}}=\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}\bef f\quad,\\
\tilde{\text{fo}}\left(g\right) & =g\triangleright\tilde{\text{fo}}=h\rightarrow a\rightarrow g((a\triangleright)^{\downarrow H}h)a=h\rightarrow a\rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef g\bef\left(a\triangleright\right)\quad.
\end{align*}

\end_inset

Then
\begin_inset Formula 
\begin{align*}
 & f\triangleright\tilde{\text{fi}}\triangleright\tilde{\text{fo}}\\
 & =h\rightarrow a\rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef\left(f\triangleright\tilde{\text{fi}}\right)\bef\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}\bef f\bef\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow h\triangleright\left(b\rightarrow\_\rightarrow b\bef\left(a\triangleright\right)\right)^{\downarrow H}\bef f\bef\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow h\triangleright f\bef\left(a\triangleright\right)=h\rightarrow a\rightarrow h\triangleright f\triangleright\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow f(h)(a)=f
\end{align*}

\end_inset

What are the simplification rules?
\begin_inset Formula 
\begin{align*}
 & a\rightarrow x\triangleright\left(a\triangleright\right)=x\quad,\\
 & a\rightarrow a\triangleright f=f\quad,\\
 & x\triangleright\left(a\triangleright\right)=x(a)=a\triangleright x\quad,\\
 & x\triangleright y\triangleright\left(a\triangleright\right)=a\triangleright\left(x\triangleright y\right)\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-is-pointed"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-is-pointed"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A rigid functor 
\begin_inset Formula $R$
\end_inset

 is pointed; the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 can be defined as
\begin_inset Formula 
\[
\text{pu}_{R}(x^{:A})\triangleq\text{id}^{:R^{A}\rightarrow R^{A}}\triangleright\text{fi}_{R}\triangleright(\_\rightarrow x)^{\uparrow R}\quad.
\]

\end_inset

In particular, there is a selected value 
\begin_inset Formula $r_{1}$
\end_inset

 of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

), computed as 
\begin_inset Formula 
\begin{equation}
r_{1}\triangleq\text{pu}_{R}(1)=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\rightarrow1)^{\uparrow R}\quad.\label{eq:rigid-functor-def-of-wrapped-unit}
\end{equation}

\end_inset


\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
The method 
\begin_inset Formula $\text{fi}_{R}:(X\rightarrow R^{Y})\rightarrow R^{X\rightarrow Y}$
\end_inset

 with type parameters 
\begin_inset Formula $X=R^{A}$
\end_inset

 and 
\begin_inset Formula $Y=A$
\end_inset

 is applied to the identity function 
\begin_inset Formula $\text{id}:R^{A}=R^{A}$
\end_inset

, considered as a value of type 
\begin_inset Formula $X\rightarrow R^{Y}$
\end_inset

.
 The result is a value
\begin_inset Formula 
\[
\text{fi}_{R}(\text{id}):R^{R^{A}\rightarrow A}\quad.
\]

\end_inset

The result is transformed via the raised constant function 
\begin_inset Formula $\left(\_\rightarrow x\right)^{\uparrow R}$
\end_inset

, which takes 
\begin_inset Formula $R^{R^{A}\rightarrow A}$
\end_inset

 and returns 
\begin_inset Formula $R^{A}$
\end_inset

.
 The resulting code can be written as
\begin_inset Formula 
\[
\text{pu}_{R}(x)\triangleq(\_\rightarrow x)^{\uparrow R}(\text{fi}_{R}(\text{id}))=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\rightarrow x)^{\uparrow R}\quad.
\]

\end_inset

The function 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 defined in this way is a natural transformation since 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 is one.
 Applying 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 to a unit value, we obtain the selected value 
\begin_inset Formula $r_{1}$
\end_inset

 of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
\end_layout

\begin_layout Standard
The next theorem shows that 
\begin_inset Formula $r_{1}$
\end_inset

 is the 
\emph on
only
\emph default
 distinct value of the type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
 This means, in particular, that a rigid functor cannot be a disjunctive
 type defined with several constructors, such as 
\begin_inset Formula $\bbnum 1+A+A$
\end_inset

 or 
\begin_inset Formula $\text{List}^{A}$
\end_inset

.
 A rigid functor's type definition must have a single constructor.
 This is one motivation for the name 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

: the container 
\begin_inset Formula $R^{A}$
\end_inset

 has a fixed shape and bears no extra information other than holding some
 values of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Theorem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-wrapped-unit-is-unit"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-wrapped-unit-is-unit"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a rigid functor 
\begin_inset Formula $R$
\end_inset

 with the method 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 satisfying the non-degeneracy law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 is equivalent to the unit type, 
\begin_inset Formula $R^{\bbnum 1}\cong\bbnum 1$
\end_inset

.
 The value 
\begin_inset Formula $r_{1}$
\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-functor-def-of-wrapped-unit"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is the only available distinct value of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
 The isomorphism map between 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 is the function 
\begin_inset Formula $\left(1\rightarrow r_{1}\right)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
The plan of the proof is to apply both sides of the non-degeneracy law 
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$
\end_inset

 to the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

.
 To adapt the type parameters, consider the generic type signature of 
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}$
\end_inset

, 
\begin_inset Formula 
\[
\big(\text{fi}_{R}\bef\text{fo}_{R}\big):(A\rightarrow R^{B})\rightarrow(A\rightarrow R^{B})\quad,
\]

\end_inset

and set 
\begin_inset Formula $A=R^{\bbnum 1}$
\end_inset

 and 
\begin_inset Formula $B=\bbnum 1$
\end_inset

.
 The left-hand side of the law can be now applied to the identity function
 
\begin_inset Formula $\text{id}:R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

, which yields a value of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

, i.e.
\begin_inset space ~
\end_inset

a function 
\begin_inset Formula 
\[
f_{1}:R^{\bbnum 1}\rightarrow R^{\bbnum 1}\quad,\quad\quad f_{1}\triangleq\text{fo}_{R}(\text{fi}_{R}(\text{id}))\quad.
\]

\end_inset

We will show that 
\begin_inset Formula $f_{1}$
\end_inset

 is a constant function, 
\begin_inset Formula $f_{1}=(\_\rightarrow r_{1})$
\end_inset

, always returning the same value 
\begin_inset Formula $r_{1}$
\end_inset

 defined in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-is-pointed"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 However, the right-hand side of the non-degeneracy law applied to 
\begin_inset Formula $\text{id}$
\end_inset

 is the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

.
 So, the non-degeneracy law means that 
\begin_inset Formula $f_{1}=\text{id}$
\end_inset

.
 If the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

 always returns the same value (
\begin_inset Formula $r_{1}$
\end_inset

), it means that 
\begin_inset Formula $r_{1}$
\end_inset

 is the only distinct value of the type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
\end_layout

\begin_layout Standard
To begin the proof, note that for any fixed type 
\begin_inset Formula $A$
\end_inset

, the function type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 is equivalent to 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 This is so because there exists only one pure function of type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

, namely 
\begin_inset Formula $(\_\rightarrow1)$
\end_inset

.
 In other words, there is only one distinct value of the type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

, and the value is the function 
\begin_inset Formula $\left(\_\rightarrow1\right)$
\end_inset

.
 The code of this function is uniquely determined by its type signature.
\end_layout

\begin_layout Standard
The isomorphism between the types 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\bbnum 1$
\end_inset

 is realized by the functions 
\begin_inset Formula $u:\bbnum 1\rightarrow A\rightarrow\bbnum 1$
\end_inset

 and 
\begin_inset Formula $v:\left(A\rightarrow\bbnum 1\right)\rightarrow\bbnum 1$
\end_inset

.
 The code of these functions is also uniquely determined by their type signature
s:
\begin_inset Formula 
\[
u=\big(1\rightarrow\_^{:A}\rightarrow1\big)\quad,\quad\quad v=\big(\_^{:A\rightarrow\bbnum 1}\rightarrow1\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Applying 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 to the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

, we obtain a value 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula 
\[
g:R^{R^{\bbnum 1}\rightarrow\bbnum 1}\quad,\quad\quad g\triangleq\text{id}\triangleright\text{fi}_{R}\quad.
\]

\end_inset

Since the type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow\bbnum 1$
\end_inset

 is equivalent to 
\begin_inset Formula $\bbnum 1$
\end_inset

, the type 
\begin_inset Formula $R^{R^{\bbnum 1}\rightarrow\bbnum 1}$
\end_inset

 is equivalent to 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
 To use this equivalence explicitly, we need to raise the isomorphisms 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 into the functor 
\begin_inset Formula $R$
\end_inset

.
 The isomorphism will then map 
\begin_inset Formula $g:R^{R^{\bbnum 1}\rightarrow\bbnum 1}$
\end_inset

 to some 
\begin_inset Formula $g_{1}:R^{\bbnum 1}$
\end_inset

 by
\begin_inset Formula 
\[
g_{1}\triangleq v^{\uparrow R}(g)\quad.
\]

\end_inset

Substituting the definitions of 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $v$
\end_inset

, and 
\begin_inset Formula $r_{1}$
\end_inset

, we find that actually 
\begin_inset Formula $g_{1}=r_{1}$
\end_inset

:
\begin_inset Formula 
\[
g_{1}=\text{id}\triangleright\text{fi}_{R}\triangleright v^{\uparrow R}=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\rightarrow1)^{\uparrow R}=r_{1}\quad.
\]

\end_inset

We can now map 
\begin_inset Formula $g_{1}$
\end_inset

 back to 
\begin_inset Formula $g$
\end_inset

 via the raised isomorphism 
\begin_inset Formula $u$
\end_inset

:
\begin_inset Formula 
\begin{align}
g & =g_{1}\triangleright u^{\uparrow R}=r_{1}\triangleright u^{\uparrow R}\nonumber \\
\text{definition of }u:\quad & =r_{1}\triangleright\big(1\rightarrow\_\rightarrow1\big)^{\uparrow R}\quad.\label{eq:rigid-functor-derivation1}
\end{align}

\end_inset

Compute 
\begin_inset Formula $\text{fo}_{R}(g)$
\end_inset

 as
\begin_inset Formula 
\begin{align*}
 & \text{fo}_{R}(g)=g\triangleright\text{fo}_{R}\\
\text{use Eq.~(\ref{eq:fuseOut-def})}:\quad & =a^{:R^{\bbnum 1}}\rightarrow g\triangleright\big(f^{:A\rightarrow\bbnum 1}\rightarrow f\left(a\right)\big)^{\uparrow R}\\
\text{use Eq.~(\ref{eq:rigid-functor-derivation1})}:\quad & =a\rightarrow r_{1}\triangleright(1\rightarrow\_^{:A}\rightarrow1)^{\uparrow R}\triangleright\big(f^{:A\rightarrow\bbnum 1}\rightarrow f\left(a\right)\big)^{\uparrow R}\\
\text{composition under }^{\uparrow R}:\quad & =a\rightarrow r_{1}\triangleright(\gunderline{1\rightarrow1})^{\uparrow R}\\
(1\rightarrow1)\text{ is identity}:\quad & =(a\rightarrow r_{1}\triangleright\text{id})=(a^{:R^{\bbnum 1}}\rightarrow r_{1})=(\_^{:R^{\bbnum 1}}\rightarrow r_{1})\quad.
\end{align*}

\end_inset

So, 
\begin_inset Formula $\text{fo}_{R}(g)=\text{fo}_{R}(\text{fi}_{R}(\text{id}))$
\end_inset

 is a function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

 that ignores its argument and always returns the same value 
\begin_inset Formula $r_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
By virtue of the non-degeneracy law, 
\begin_inset Formula $\text{fo}_{R}(g)=\text{id}$
\end_inset

.
 We see that the identity function 
\begin_inset Formula $\text{id}:R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

 always returns the same value 
\begin_inset Formula $r_{1}$
\end_inset

.
 Applying this function to an arbitrary value 
\begin_inset Formula $x:R^{\bbnum 1}$
\end_inset

, we get
\begin_inset Formula 
\[
x=x\triangleright\text{id}=x\triangleright\text{fo}_{R}(g)=x\triangleright(\_\rightarrow r_{1})=r_{1}\quad.
\]

\end_inset

It means that all values of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 are equal to 
\begin_inset Formula $r_{1}$
\end_inset

.
 So the function 
\begin_inset Formula $1\rightarrow r_{1}$
\end_inset

 is indeed an isomorphism between the types 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
\end_layout

\begin_layout Standard
It follows from Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-wrapped-unit-is-unit"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that a rigid functor cannot be a disjunctive type with more than one constructo
r, so functors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 cannot be rigid.
 This partially explains the choice of the name 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

: a rigid functor has a fixed 
\begin_inset Quotes eld
\end_inset

shape
\begin_inset Quotes erd
\end_inset

 of the placement of data in it.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-product"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Product of rigid functors is rigid.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Product of rigid functors is rigid.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Standard
Some more use cases for rigid functors are shown in the next statements.
 The 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $R$
\end_inset

-valued 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 that can handle multiple 
\begin_inset Formula $M$
\end_inset

-effects at once; more precisely, an 
\begin_inset Formula $R$
\end_inset

-container of 
\begin_inset Formula $M$
\end_inset

-effects.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-multi-flatMap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-multi-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***For a rigid functor 
\begin_inset Formula $R$
\end_inset

 and a monad 
\begin_inset Formula $M$
\end_inset

, an 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $R$
\end_inset

-valued 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 can be defined,
\begin_inset Formula 
\[
\text{rflm}_{M,R}:(A\rightarrow R^{M^{B}})\rightarrow M^{A}\rightarrow R^{M^{B}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

refactoring
\begin_inset Quotes erd
\end_inset

 is a program transformation that does not significantly change the functionalit
y.
 ***
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-monadic-refactor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-monadic-refactor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***Given a rigid functor 
\begin_inset Formula $R$
\end_inset

, a refactoring function can be implemented,
\begin_inset Formula 
\[
\text{refactor}:((A\rightarrow B)\rightarrow C)\rightarrow(A\rightarrow R^{B})\rightarrow R^{C}\quad.
\]

\end_inset

This function transforms a program 
\begin_inset Formula $p(f^{:A\rightarrow B}):C$
\end_inset

 into a program 
\begin_inset Formula $\tilde{p}(\tilde{f}^{:A\rightarrow R^{B}}):R^{C}$
\end_inset

.
\end_layout

\begin_layout Section
Recursive monad transformers
\end_layout

\begin_layout Subsection
Transformer for the free monad 
\family typewriter
FreeT
\end_layout

\begin_layout Subsection
Transformer for the list monad 
\family typewriter
ListT
\end_layout

\begin_layout Section
Monad transformers for monad constructions
\end_layout

\begin_layout Subsection
Product of monad transformers
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-product-of-monad-transformers"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-of-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The transformer for a product of two monads is the product of transformers.
\end_layout

\begin_layout Subsection
Free pointed monad transformer
\end_layout

\begin_layout Section
Irregular and incomplete monad transformers
\end_layout

\begin_layout Subsection
The state monad transformer 
\family typewriter
StateT
\end_layout

\begin_layout Subsection
The continuation monad transformer 
\family typewriter
ContT
\end_layout

\begin_layout Subsection
The co-density monad transformer 
\family typewriter
CodT
\end_layout

\begin_layout Standard
The 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
co-density monad
\end_layout

\end_inset

co-density monad
\series default
 over a functor 
\begin_inset Formula $F$
\end_inset

 is defined as 
\begin_inset Formula 
\[
\text{Cod}^{F,A}\triangleq\forall B.\left(A\rightarrow F^{B}\right)\rightarrow F^{B}
\]

\end_inset


\end_layout

\begin_layout Standard
Properties:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Cod}^{F,\bullet}$
\end_inset

 is a monad for any functor 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is itself a monad then we have monad morphisms 
\begin_inset Formula $\text{inC}:F^{\bullet}\leadsto\text{Cod}^{F,\bullet}$
\end_inset

 and 
\begin_inset Formula $\text{outC}:\text{Cod}^{F,\bullet}\leadsto F^{\bullet}$
\end_inset

 such that 
\begin_inset Formula $\text{inC}\,\bef\text{outC}=\text{id}$
\end_inset


\end_layout

\begin_layout Itemize
A monad transformer for the co-density monad is 
\begin_inset Formula 
\[
T_{\text{Cod}}^{M,A}=\forall B.\left(A\rightarrow M^{F^{B}}\right)\rightarrow M^{F^{B}}
\]

\end_inset

However, this transformer does not have the base lifting morphism 
\begin_inset Formula 
\[
\text{blift}:\left(\forall B.\left(A\rightarrow F^{B}\right)\rightarrow F^{B}\right)\rightarrow\forall C.\left(A\rightarrow M^{F^{C}}\right)\rightarrow M^{F^{C}}
\]

\end_inset

since this type signature cannot be implemented.
 The co-density transformer also does not have any of the required 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 transformations 
\begin_inset Formula $\text{mrun}$
\end_inset

 and 
\begin_inset Formula $\text{brun}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{mrun} & :\left(M^{\bullet}\leadsto N^{\bullet}\right)\rightarrow\left(\forall B.\left(A\rightarrow M^{F^{B}}\right)\rightarrow M^{F^{B}}\right)\rightarrow\forall C.\left(A\rightarrow N^{F^{C}}\right)\rightarrow N^{F^{C}}\quad,\\
\text{brun} & :\left(\left(\forall B.\left(A\rightarrow F^{B}\right)\rightarrow F^{B}\right)\rightarrow A\right)\rightarrow\left(\forall C.\left(A\rightarrow M^{F^{C}}\right)\rightarrow M^{F^{C}}\right)\rightarrow M^{A}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Section
Summary and discussion
\end_layout

\begin_layout Subsection
Some properties of monad morphisms
\end_layout

\begin_layout Standard
In this section we prove certain properties of monad morphisms used elsewhere
 in this chapter.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-M-to-M-times-M-is-monadic-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-M-to-M-times-M-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monad 
\begin_inset Formula $M$
\end_inset

, the function 
\begin_inset Formula $\Delta:M^{A}\rightarrow M^{A}\times M^{A}$
\end_inset

 is a monad morphism between monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $M\times M$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use the definition of the product monad.
 The method 
\begin_inset Formula $\text{pu}_{M\times M}$
\end_inset

 is defined by
\begin_inset Formula 
\[
x\triangleright\text{pu}_{M\times M}=\text{pu}_{M}(x)\times\text{pu}_{M}(x)=x\triangleright\text{pu}_{M}\bef\Delta\quad,
\]

\end_inset

which is the identity law for 
\begin_inset Formula $\Delta$
\end_inset

.
 To verify the composition law for 
\begin_inset Formula $\Delta$
\end_inset

, 
\begin_inset Formula 
\[
\text{ftn}_{M}\bef\Delta=\Delta^{\uparrow M}\bef\Delta\bef\text{ftn}_{M\times M}\quad,
\]

\end_inset

we use the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monad-product-flatten-def-ftn"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $\text{ftn}_{M\times M}$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{M\times M}:M^{M^{\bullet}\times M^{\bullet}}\times M^{M^{\bullet}\times M^{\bullet}}\rightarrow M^{\bullet}\times M^{\bullet}=\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow M}\bef\text{ftn}_{M}\big)\quad,
\]

\end_inset

and compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{M}\bef\Delta:\quad & \gunderline{\Delta^{\uparrow M}\bef\Delta}\bef\text{ftn}_{M\times M}\\
\text{naturality of }\Delta:\quad & =\Delta\bef\big(\Delta^{\uparrow M}\boxtimes\Delta^{\uparrow M}\big)\bef\gunderline{\text{ftn}_{M\times M}}\\
\text{definition of }\text{ftn}_{M\times M}:\quad & =\Delta\bef\big(\Delta^{\uparrow M}\boxtimes\Delta^{\uparrow M}\big)\bef\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow M}\bef\text{ftn}_{M}\big)\\
\text{composition law of }\boxtimes:\quad & =\Delta\bef\big(\gunderline{\Delta^{\uparrow M}\bef\pi_{1}^{\uparrow M}}\bef\text{ftn}_{M}\big)\boxtimes\big(\gunderline{\Delta^{\uparrow M}\bef\pi_{2}^{\uparrow M}}\bef\text{ftn}_{M}\big)\\
\text{simplify }\Delta\bef\pi_{i}=\text{id}:\quad & =\Delta\bef\text{ftn}_{M}\boxtimes\text{ftn}_{M}\\
\text{duplication law of }\Delta:\quad & =\text{ftn}_{M}\bef\Delta\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-product-of-monadic-morphisms"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monads 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 and monad morphisms 
\begin_inset Formula $\phi:K\leadsto M$
\end_inset

 and 
\begin_inset Formula $\chi:L\leadsto N$
\end_inset

, the pair product 
\begin_inset Formula $\phi\boxtimes\chi:K^{\bullet}\times L^{\bullet}\leadsto M^{\bullet}\times N^{\bullet}$
\end_inset

 is a monad morphism between the product monads 
\begin_inset Formula $K\times L$
\end_inset

 and 
\begin_inset Formula $M\times N$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The definitions of 
\begin_inset Formula $\text{pu}_{K\times L}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{M\times N}$
\end_inset

 are
\begin_inset Formula 
\[
\text{pu}_{K\times L}=\text{pu}_{K}\boxtimes\text{pu}_{L}\quad,\quad\quad\text{pu}_{M\times N}=\text{pu}_{M}\boxtimes\text{pu}_{N}\quad.
\]

\end_inset

The identity law for 
\begin_inset Formula $\phi\boxtimes\chi$
\end_inset

 is verified by
\begin_inset Formula 
\begin{align*}
\text{expect to equal}\text{pu}_{M\times N}:\quad & \gunderline{\text{pu}_{K\times L}}\bef\phi\boxtimes\chi\\
\text{definition of }\text{pu}_{K\times L}:\quad & =\text{pu}_{K}\boxtimes\text{pu}_{L}\bef\phi\boxtimes\chi\\
\text{composition law of }\boxtimes:\quad & =(\gunderline{\text{pu}_{K}\bef\phi})\boxtimes(\gunderline{\text{pu}_{L}\bef\chi})\\
\text{identity laws for }\phi,\chi:\quad & =\text{pu}_{M}\boxtimes\text{pu}_{N}=\text{pu}_{M\times N}\quad.
\end{align*}

\end_inset

To verify the composition law for 
\begin_inset Formula $\phi\boxtimes\chi$
\end_inset

, we use the definitions 
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{K\times L}=\big(\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\big)^{:K^{K^{\bullet}\times L^{\bullet}}\rightarrow K^{\bullet}}\boxtimes\big(\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\big)^{:L^{K^{\bullet}\times L^{\bullet}}\rightarrow L^{\bullet}}\quad,\\
 & \text{ftn}_{M\times N}=\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\quad.
\end{align*}

\end_inset

Denote 
\begin_inset Formula $\psi\triangleq\phi\boxtimes\chi$
\end_inset

 for brevity.
 The required law is
\begin_inset Formula 
\[
\text{ftn}_{K\times L}\bef\psi=\psi^{\uparrow(K\times L)}\bef\psi\bef\text{ftn}_{M\times N}\quad.
\]

\end_inset

The left-hand side of this law is
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{K\times L}\bef\psi\\
\text{definition of }\text{ftn}_{M\times N}:\quad & =\big(\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\big)\boxtimes\big(\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\big)\bef\phi\boxtimes\chi\\
\text{composition law of }\boxtimes:\quad & =\big(\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi\big)\boxtimes\big(\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\bef\chi\big)
\end{align*}

\end_inset

The right-hand side is
\begin_inset Formula 
\begin{align*}
 & \gunderline{\psi^{\uparrow(K\times L)}}\bef\psi\bef\text{ftn}_{M\times N}\\
\text{lifting to }K\times L:\quad & =\big(\psi^{\uparrow K}\boxtimes\psi^{\uparrow L}\big)\bef(\phi\boxtimes\chi)\bef\gunderline{\text{ftn}_{M\times N}}\\
\text{definition of }\text{ftn}_{M\times N}:\quad & =\psi^{\uparrow K}\boxtimes\psi^{\uparrow L}\bef\phi\boxtimes\chi\bef\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\\
\text{composition law of }\boxtimes:\quad & =\big(\psi^{\uparrow K}\bef\phi\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\psi^{\uparrow L}\bef\chi\bef\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\quad.
\end{align*}

\end_inset

Consider now the first part of the pair product in the last line:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\psi^{\uparrow K}\bef\phi}\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\\
\text{naturality of }\phi:\quad & =\phi\bef\gunderline{\psi^{\uparrow M}\bef\pi_{1}^{\uparrow M}}\bef\text{ftn}_{M}\\
\text{projection law of }\pi_{1}:\quad & =\gunderline{\phi\bef\pi_{1}^{\uparrow M}}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\\
\text{naturality of }\phi:\quad & =\pi_{1}^{\uparrow K}\bef\gunderline{\phi\bef\phi^{\uparrow M}\bef\text{ftn}_{M}}\\
\text{composition law of }\phi:\quad & =\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi\quad.
\end{align*}

\end_inset

In the same way, we find that the second part of the pair product is 
\begin_inset Formula $\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\bef\chi$
\end_inset

, and so the composition law holds.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-projection-is-monadic-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-projection-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, the projection function 
\begin_inset Formula $\pi_{1}:M^{\bullet}\times N^{\bullet}\leadsto M^{\bullet}$
\end_inset

 is a monad morphism.
 Same for 
\begin_inset Formula $\pi_{2}:M^{\bullet}\times N^{\bullet}\leadsto N^{\bullet}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
It is sufficient to verify the laws for 
\begin_inset Formula $\pi_{1}$
\end_inset

; the proof for 
\begin_inset Formula $\pi_{2}$
\end_inset

 will be similar.
 The identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{M\times N}\bef\pi_{1}\\
\text{definition of }\text{pu}_{M\times N}:\quad & =(\text{pu}_{M}\boxtimes\text{pu}_{N})\bef\pi_{1}\\
\text{projection law of }\pi_{1}:\quad & =\text{pu}_{M}\quad.
\end{align*}

\end_inset

The composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\pi_{1}\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}:\quad & \gunderline{\text{ftn}_{M\times N}}\bef\pi_{1}\\
\text{definition of }\text{ftn}_{M\times N}:\quad & =\gunderline{\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)}\boxtimes\big(\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\bef\gunderline{\pi_{1}}\\
\text{projection law of }\pi_{1}:\quad & =\pi_{1}\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-product-swap-is-monadic-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-swap-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, the component-swapping function 
\begin_inset Formula $\sigma:M^{\bullet}\times N^{\bullet}\leadsto N^{\bullet}\times M^{\bullet}$
\end_inset

 is a monad morphism.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The code for 
\begin_inset Formula $\sigma$
\end_inset

 can be written as a combination of other functions as 
\begin_inset Formula $\sigma=\Delta\bef\left(\pi_{2}\boxtimes\pi_{1}\right)$
\end_inset

.
 The functions 
\begin_inset Formula $\Delta$
\end_inset

, 
\begin_inset Formula $\pi_{1}$
\end_inset

, and 
\begin_inset Formula $\pi_{2}$
\end_inset

 are monad morphisms by Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-M-to-M-times-M-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-projection-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The function product 
\begin_inset Formula $\pi_{1}\boxtimes\pi_{2}$
\end_inset

 is a monad morphism by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So 
\begin_inset Formula $\sigma$
\end_inset

 is a composition of monad morphisms; by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $\sigma$
\end_inset

 is a monad morphism.
\end_layout

\begin_layout Subsection
Exercises
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-transformer-extra-layer"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 is a lawful monad transformer for the base monad 
\begin_inset Formula $L$
\end_inset

 and a foreign monad 
\begin_inset Formula $M$
\end_inset

.
 Can we modify 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 and construct another monad transformer for 
\begin_inset Formula $L$
\end_inset

 that still satisfies all transformer laws?
\end_layout

\begin_layout Standard
One possibility is to compose 
\begin_inset Formula $T$
\end_inset

 with an extra layer of the monads 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

.
 Define 
\begin_inset Formula $U$
\end_inset

 and 
\begin_inset Formula $V$
\end_inset

 by
\begin_inset Formula 
\[
U^{A}\triangleq L^{T_{L}^{M,A}}\quad,\quad\quad V^{A}\triangleq M^{T_{L}^{M,A}}\quad.
\]

\end_inset

In a shorter notation, 
\begin_inset Formula $U\triangleq L\circ T_{L}^{M}$
\end_inset

 and 
\begin_inset Formula $V\triangleq M\circ T_{L}^{M}$
\end_inset

.
 We have the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 functions 
\begin_inset Formula 
\begin{align*}
\text{sw}_{L,T} & :T_{L}^{M}\circ L\leadsto L\circ T_{L}^{M}\quad,\\
\text{sw}_{M,T} & :T_{L}^{M}\circ M\leadsto M\circ T_{L}^{M}\quad,
\end{align*}

\end_inset

defined using the already given methods 
\begin_inset Formula $\text{lift}$
\end_inset

 and 
\begin_inset Formula $\text{blift}$
\end_inset

 of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 as
\begin_inset Formula 
\begin{align*}
\text{sw}_{L,T} & =\text{blift}^{\uparrow T}\bef\text{ftn}_{T}\bef\text{pu}_{L}\quad,\\
\text{sw}_{M,T} & =\text{lift}^{\uparrow T}\bef\text{ftn}_{T}\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

We can define the monad methods 
\begin_inset Formula $\text{ftn}_{U}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{V}$
\end_inset

 using these 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 functions.
 Will 
\begin_inset Formula $U$
\end_inset

 and/or 
\begin_inset Formula $V$
\end_inset

 be lawful monad transformers for 
\begin_inset Formula $L$
\end_inset

?
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-transformer-extra-layer-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
Show that there exist monad morphisms between the selection 
\begin_inset Formula $\left(A\rightarrow R\right)\rightarrow A$
\end_inset

 and the continuation 
\begin_inset Formula $\left(A\rightarrow R\right)\rightarrow R$
\end_inset

 monads.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Chapter eleven of the functional programming tutorial computations in a
 central context have been one of the teams in this tutorial and this is
 a final part this which talks about moon and transformers to begin let
 me look at some code that needs to compute a value in the future but the
 value is of optional type so these kind of computations often happen in
 application code when you are computing some value in the future but the
 value itself has additional logic and option is a simplest such example
 so imagine that we would like to implement a program that computes a value
 using a future and then if this value is a non-empty option the computation
 continues and then it can compute another value again in the future using
 what was concluded before and that computation again returns an optional
 type and we again see if that is a non-empty option and if so we continue
 and return another future value and so on and if at any time this option
 is empty after having computed it we need to stop some way short-cut the
 computation by returning a feature of none right away so that's what we
 have to do so the code then starts looking like this now I just write here
 option of one very simple computations for which I wouldn't have to do
 such coding but in real life test as a function that takes time to compute
 so I put it into a future and then it might return an empty result I don't
 know that in advance let's suppose and then I need to match on that result
 so you see this code is quite difficult to read and difficult to modify
 that is to maintain and the reason is that it's full of repetitions so
 there are all these match expressions that always have the same structure
 if there is a Sun then we continue if there is none then we were transfusion
 successful now it is precisely that kind of repetition that was eliminated
 by using the function block or the for yield block but so we eliminate
 them but only for the outer type constructor the inner type constructor
 remains and we still have to do the same thing for it and we could not
 use the same for yield block to deal with the future chaining and the option
 chain because this is a limitation of the function block the factor in
 which we perform the computation must be the same throughout the entire
 function block so the full yield delimit a block of thunder computations
 where to the right-hand side of the arrow there must be always the same
 factor type so future in this example once the first line is giving you
 a future everything to the right of the arrow must be of type future of
 something so it's future this also must be future which it is will have
 having the right code like this and so on so it could not be that in the
 next line I write something like X is equal to X X going to X hoped this
 would not actually compile because this X optical type option it is not
 of type future of something so this would not actually compile and that's
 why we need to write this code so this difficult to write and difficult
 to maintain code unfortunately is unavoidable if we simply use the function
 block on the type constructor that is nested when you have one monad and
 composed in the type constructor with another monnet like this we will
 have this problem whenever this happens so this could be a future of option
 or it could be a list of either or any kind of combination like that will
 give rise to ugly code of this kind so one solution that could be easy
 to implement is to wrap this type constructor into a new class for which
 we implement a monad syntax directly so here's how it works so we create
 a type wrapper which is just a case class with a single value inside and
 this wrapped value is of type future option and now we directly define
 for this case class the methods map and flatmap and they're defined by
 simply doing a nested map and then and the map inside so that's nested
 flat map and then we write this code where we match on the resulting option
 by hint so so this basically replaces all the repetitive code above were
 in the case of none where we turn a successful future of none and if the
 case of nonempty option then we continue we continue with the next computation
 so that is the flat map defined for this wrapped class once we have done
 this we also do some convenience functions which I will talk about later
 such as the lift and I define for convenience some implicit conversions
 so that I can just convert future of a into this future option where I
 promote a to option trivially by using some apply and another opposite
 conversion converts the nested type constructor into a wrapped s to type
 constructing automatically so that is what I do here once this is defined
 the code above is magically transformed into this so the pure computations
 are just examples like I said this is a very simple example and don't really
 need to do this future option stuff in real code this would be a function
 that returns a value of type future of option of something and it could
 have been non-trivial could return in the future that fails or it could
 return a future that succeeds with an empty option or it could return a
 future with succeeds with a non-empty option and so now the code becomes
 very straightforward easy to maintain at the same time I could do operations
 like this or else directly on this type where the or else refers to the
 optional type inside future I implemented there or else for convenience
 like this and the left is a function that transforms option a option B
 into a future option A to future shouldn't be so this is kind of a lifting
 of that kind so this is the basic idea of monad transformers namely how
 to avoid having to write repetitive code languages and instead write with
 some of course and definitions that you need to do but eventually you would
 write code language so in other words we could say we have combined a future
 monad and the option monad into one big moment future with option which
 we can manipulate in a functor block director with no need for pattern
 matching or anything else so all the pattern matching within the future
 is done automatic so this is an example of combining two monads so it is
 very often necessary to combine different monad effects where effect is
 informal notion it is not a specific clearly defined type it is an informal
 notion which expresses the idea that in in a monad M the type of dysfunction
 expresses a computation that takes a and computes perhaps a value of B
 and also to compute something else or something else happens while we were
 computing a value of B or maybe you compute many values of B or maybe none
 at all or maybe you fail with some error message or maybe something else
 happens so whatever else happens while you're computing be from a in this
 function that's the effect of the monad M and so an example would be for
 option is that the computation can have no result or a single result for
 list computation to have multiple results for either it could fail to obtain
 the result and then report an error for the reader it always gives a result
 but it needs to read an external value for that writer it always gives
 a result but additionally there is some accumulator which is of a monoid
 type and some value will be appended to that accumulator for the future
 you might compute computer value might fail with an error but all of that
 will be run later it will not be computed right away so those are the effects
 of some standard monads and often you would like to combine them so you
 would like to have a list of either-or future of options and learning and
 that could be given combinations of more than two when you want to combine
 reader and writer and future at the same time so how do we combine effects
 well I just showed you a code where I combined effects although it required
 me to do acquainted quite some work obviously what you could not do is
 you could you could not simply write code with first a future of something
 which has a future type and then a different monad on the right side of
 the arrow that would not compile so if this has a type try and this has
 a type future they're not compatible future and try are not compatible
 types and so this would not work if you wanted to do that and you need
 to do something else you'd have to unify both right-hand sides into a bigger
 moment such that you somehow transform this into the value of a bigger
 monad he also transformed this into the value of a bigger movement so these
 operations are called lifting so you lift the small nut into the bigger
 moment you also lift the small nut and a bigger more not and then if you
 can do that and I have done this in my code I just showed you using an
 implicit conversion so if I can do that I can just write code like this
 indeed and implicit conversions will take care or maybe I can just put
 some type annotations and in there that would take care of types and then
 on the right hand side of the accumulator arrow I will always have the
 same type constructor and that is therefore I'm going to be valid Scala
 code so to see that this is not valid it's easy to see that because I should
 translate this into flat maps see the first thing is in sequence the second
 thing is the future so the flat map on a sequence takes this function but
 the future is a different kind type constructor than the sequence on a
 flat map has a type signature that requires a sequence here so that would
 not compile so the conclusion is that in order to combine different effects
 in the same function block we need to unify all these effects in a new
 unit that is in some sense larger than all the previous monads and contains
 all of them so the main goal of this chapter is to learn how we can compute
 the type of this new moon at how can we decide what that type constructor
 is how to implement the moon add instance for it for any kind of moon does
 that you might want to use so there are several ways of combining two models
 into a new bigger moon at that we could try and many of these ways just
 won't work so the easiest way would be well why don't I just take a product
 of these two moons that's a monad we know that the reason is that this
 is not what we need this is a moon Atias but it describes two separate
 values of type a each having a separate effect on it that's not what we
 need we need a single value of type a that has a combination of two effects
 possibly and that's not all this describes now maybe a disjunction because
 that could be the first effect on a or the second effect on a unfortunately
 this is usually not a monad and even even if it is a monad this is really
 a choice between two different effects work even two different values it's
 not one value with the combination of two effects with with the first effect
 and the second effect remember the Scala speech revulsion the combination
 is at the same time being computed in the future and it returns an optional
 result so this doesn't work now the next what we can try is functor composition
 so we can pose and one of them - we can compose in two different orders
 and sometimes indeed that works it is often at one end when you compose
 so let's look at some examples but if one unit is this and the second model
 is this then we can compose and the composition is this type constructor
 and that is actually correct it as a monad similarly future of option as
 I just showed can be combined in case a moment unfortunately if you try
 to combine in there in the other order for example do some following this
 or something like this those are not units so you can combine option and
 reader this is the reader who not only in one order you can come compose
 reader outside and options if you try option outside and you're either
 inside the result is not imminent also you cannot combine State mana with
 other moons like this so for example neither disorder nor that order is
 a minute so from these examples we see first of all sometimes it works
 but sometimes it requires a specific order of composition and it does not
 work with the other order and sometimes it does not work with composition
 at all so I will show that later that the state monad is such that it does
 not compose with other monads in either order so as a comment when composition
 works both ways and example would be either and writer so they can be composed
 in both ways this would be one result of composition this would be another
 and both of these are monads but these moments express different kinds
 of effects so for instance here we either compute result and write a message
 or everything failed we have an error message will have no result and no
 blog messages here we have always a log message the computation may fail
 does not give us a result of type a but the log message is always written
 so we can have an error message and a log message in the same time so these
 are obviously two different kinds of logic that you could express or two
 different kinds of effects so the task in front of us is of course to avoid
 try on there we don't want to do that every time that we need to compose
 two monads we need to have a general way defining a new combined monads
 and we need to show that it is always a moment so that we don't have to
 prove things every time when we write code so that is what we would like
 to achieve and we would go a very long way towards that goal in this chapter
 so what we would achieve is that we will have a monad say Big M big manga
 that somehow combines only effects so instead of the code that I showed
 here which is invalid trying to combine the sequence future and try in
 a single functor block that is not valid but if we somehow define a big
 model that combines sequence future and try in the same big moment then
 we had also we would have three functions for lifting I would call them
 lifts one left two and lifts three for now which would lift a sequence
 value into the big model a future value into the big wallet and a try value
 into the big magnet so then we could just write a function block like this
 lift lift lift after lifting the right hand sides are of type big M of
 something this is now valid and this would work the result would be of
 type maybe Big M of int or something here are two examples of these liftings
 so combining future and option would require us to define two liftings
 option a into future option a and future in the future optionally so these
 lifters are easy define and that's how we would probably have to write
 code in another example suppose we want to combine list of track list and
 try so that works try inside the list networks I don't think that try would
 work outside the list as I'm Oona and these are the two lifting so that's
 easy enough and you see that could work now they're still of course a lot
 of work to be done if we were to go this way for each pair of moments or
 even for each combination which could be very very many we would have to
 define these wave teams we'd have to define the monad instance for a big
 M I haven't even talked about that I haven't even said what the type of
 Big M is for this combination for this I know but for this I haven't said
 that so how to combine list feature and try in a single type constructor
 this is a non-trivial question which is not easy to resolve by trial and
 error composition would not necessarily work we need also to check that
 the laws of the mana told for these moments which I also will check but
 haven't done yet so all these questions remain is it always possible how
 to find such a type constructor is it unique are there several options
 alternative solutions are they some of them better than others these liftings
 what are the laws that they have to satisfy and and so on also can we somehow
 reduce the complexity instead of having to define liftings for all possible
 combinations maybe we find fewer and make other things automatic so let
 me first talk about the laws of liftings so we assume that there will be
 a monadic program such as this one with some liftings and we ask what are
 the laws for these liftings now we assume that the monads m1 m2 and also
 the big model whatever it might be already satisfied all the Monad laws
 how would we argue about lifting laws so for example imagine a functor
 block in which we have code like this so first we have a lifting of a pure
 value so we have an m1 pure and we lift it so that becomes a big moon add
 value and then we continue with some big monad stuff depends on high now
 since this is just pure our initial code without liftings which is incorrect
 would have been just I going to the pure of X and then continuing with
 that I usually code like this is equivalent to this kind of code where
 we don't need to do monadic arrow and the left arrow we don't need that
 if we just use pure we just say i equals x and continue and so we expect
 that with lifting it will be the same that we can replace this code with
 this equivalently so this is a law that the function lift must satisfy
 we write it down is like this this is the law now of course it's not very
 nice to reason about code so I prefer to reason about a more condensed
 notation rather than Scala code syntax and in particular it is convenient
 often to use the closely composition criminals which is composition of
 functions of these types the nicely functions and so if we rewrite this
 code in terms of closely functions then it looks like this the composition
 of the flow-rate composition of pure of n1 and lifts one flat map with
 some arbitrary B which is some x2 big animals voice this is this B must
 be equal to B so that's what we get if we remember that the classic composition
 is replacing this kind of code so F composition with G is a function that
 is like this another law is that if we have a lifting of pure after some
 valid computation then we expect that this X again has just ik equal to
 Omega there's no effect here and this should remain so after lifting so
 therefore this code must be equivalent to this code writing the same code
 that is the equation like this and writing it in terms of the class like
 composition it becomes this equation and of course the same identity laws
 must hold for the second moment in its second lifting so these moments
 we consider to be only cause fruiting right now and both of them need to
 be lifted into the big mullet if this construction is to be of practical
 use now these laws are kind of complicated let's simplify them these laws
 basically say that this function this this composition of pure em and lift
 is the identity for the closely composition so this Purim lifts to the
 left of B equals B and p.m.
 lift to the right of B also equals B and so this function is the unit for
 the classic composition but this monad already has a unit in the classical
 composition laneway it as this viewer of the Big M and in the Monod the
 two-sided unit element is unique and similarly this is so in a closely
 composition so if you have two different unit elements U and u Prime and
 we can easily write this equation which is that you Kleist a product u
 prime it must be equal to u because U prime is a unit element it also must
 be equal to u prime because u is the unit element and so u must be equal
 to u prime so the unit element is always unique and so these two identity
 laws that we have seen here can we actually produced a single or equivalent
 to saying that this forward composition of pure hand and lift it must be
 equal to the pure function of the big moment so we have now reduced the
 identity law to a single identity law and let us now derive another one
 for the lifting which is that if we have some kind of lift one of everything
 so we have a portion of a program that just uses the first moment and keeps
 lifting it into the big moment we should be able to refactor this into
 a nomadic program that only works within the first moment and then lift
 the result of that program into the big moment so this would be the equivalent
 program first we'll do the flat map in the moon atom one and then we lift
 the result into the big moment so this program it is kind of reasonable
 should be equivalent to this if it's not it would be kind of strange that
 I cannot refactor my programs the idea is that lifting should be transparent
 it should be just tight from massaging for the moment so usually if I have
 a nomadic program like this imagine there's no lifting I can always refactor
 it I can do this what not somewhere else and then put the results of that
 flat map back here you can always do that that's the usual associative
 'ti buna so I should be able to do the same if I lift into the big moment
 so that law when written out it becomes this equation and unfortunately
 now this is a little unwieldy to you to think about so let let us rewrite
 it equivalently through the flat map function so the flat map function
 which I did denote F L M it is with this type signature which is not the
 same as the usual flat map in scala but it is easier to reason about and
 then using this flat map we write this code like that so we have a lift
 then we have a flat map of this function and then it's the same as first
 doing a flat map and then lifting the result on both sides of this law
 are functions of this type signature lifting and one into the big moment
 we can further simplify this if we rewrite flat map through flatten flatten
 has this type signature and the law becomes lift one and then lift one
 lifted four raised to the big moment using its map function and then followed
 by flat map in the big Monat is equal to flat map in the m1 mu not followed
 by lift so these are easy to obtain if you remember that flat map is map
 followed by flatten in other words it's this map followed by flat so that's
 basically how I get from here to here and the function Q disappears from
 the law in this formulation so it becomes simpler there's no arbitrary
 function from A to B nothing like that it's just both sides are functions
 of this type there's only one type a involved as a type parameter whereas
 in this law there is a function q and they're two type parameters a B and
 in this formulation they're two arbitrary functions P and Q so in this
 way the laws is simply the law is simplified can be simplified even more
 if we write it in terms of Chrysler composition then it becomes a law that
 is for some functions B and C of class Li type signature the be lifted
 and closely composed with C lifted is equal to twice Li composition of
 B and C all lifted notice I am using two different closely compositions
 in this law and the left I am using the class decomposition in the big
 moon on the right in the moon at M one to make it clear I use the subscript
 in each case so this is maybe slightly more difficult to read with the
 subscript so squint at it and imagine that the subscript isn't there keep
 it just in mind and then you see be lifted composed with C lifted is be
 composed C all lifted so that's the composition law in other words the
 lifting of functions before composition is equal to lifting of functions
 after composition in other words the liftings commute with a closely competitio
n and also the lifting is commute with pure pure after lifting is the same
 as the other pure and so the laws expressed the idea intuitively that these
 liftings lift 1 and lift two of course as well should commute with the
 operations pure and flatmap of the magnets so this is how we can think
 about these laws and remember them so the liftings must lift peer-to-peer
 and compress a closely composition into classically composition additionally
 the liftings must be natural transformations but actually it is a consequence
 of the fact that they lift pure to pure and flatmap to flat map or flattened
 to flatten or glass the composition to place the composition now the term
 that I use for such functions and that commute with monads and lift purity
 pure and flat map to flatten ax is monad morphism so it's not just the
 function or morphism but it's a monad morphism in other words it's a morphism
 that agrees or is compatible with the structure of the moon and and it's
 a function between f1 and Big M so it is compatible in this way with structures
 of these two moments whatever structure is an n1 it maps into that correspondin
g structure in Big M and in the previous chapter we already saw an example
 of an antique morphism although we did not talk about it I didn't talk
 about it I talked about magnetic interpreters not run one one addict program
 and obtain a monadic value in another moment these must actually satisfy
 these laws in order to be useful and so Mahna Mahna the interpreters are
 always magnetic morphisms unless they are be very useful and now let me
 derive the naturality law for this lift now lift has this type signature
 so naturality for it means that if i have some function f from X to Y and
 I lifted to m1 and I also lifted too big him so that's the F map of 1/2
 and I am in m1 or in Big M then the lifting must commute with that so in
 other words first you lift and then you map X to Y or you first map X to
 Y then you lift it doesn't matter and that is the equation that we can
 write expressing this equivalent system now we can derive this law actually
 from the fact that lift is a magnetic morphism so this is not a separate
 law that we need to check once we know that it is a one-man ignore thism
 how so this is a derivation F map can be expressed through a flat map and
 pyrrha and that is a monad law for both movements and then this is the
 lifting law for flat map and instead of saying this so we write that so
 this column of F here is the left hand side or actually that the right
 hand side of this law is f map f lift 1 so instead of f map I write this
 and the result is that so in this way I what I'm trying to get is that
 I replace in this law F Maps through F Elam and the right and on the left
 and I hope that I get an identity after that so I begin with the left hand
 with the right hand side where I replaced F map through a felon now I used
 this law that FLM of some function and then lifted is lifting followed
 by a column of this where Q is equal to a composition of F and P rm1 so
 that results in this expression we have left one FLN Big M which I didn't
 enjoy it of composition of this Q which is this and left so that is here
 now I'll use the fact that pure M followed by lift one is pure Big M which
 is this law therefore I have here F followed by pure Big M now this is
 flat map in Big M therefore this is a law of Big M which is this okay which
 I can replace this by flat by F map of begin so now the result is this
 which is the left hand side of the law and trying to prove so I started
 from the right-hand side replaced things in it identically and I got the
 left hand side using the fact that lift 1 satisfies the laws of a magnetic
 north ISM so monad morphism therefore is always a natural transformation
 so how do we deal with the problem of combining many moments and reducing
 the amount of work so to look at an example if we can bind listen this
 on that only this combination works this is a functor composition of this
 and this where the reader is outside and the option is inside the other
 order would not work this is not a minute and so this destroys our hopes
 of somehow always writing a formula combining M 1 and M 2 for arbitrary
 M 1 and M 2 using some kind of natural combination or by functor this would
 not work and another example is that the state monad does not compose in
 any order with other moons let me show some code that explains why not
 a stone if I try to compose optional is reader in the other order then
 I try to combo I'd really defined flatmap further also and define a flat
 map with this type signature so I get so this o R is an option of reader
 and I need to get an or R of B from or of a and the function a to or me
 now if FA is none we have nothing to do except return there's no a available
 in our so they cannot possibly use F and return some non-trivial for B
 so we have to return none here now suppose we have a non empty option and
 then we have a function R T so now how can we return an option of artemiy
 we have a function that takes a and returns this or B now unfortunately
 we cannot use this F either because to use F we need a function we need
 the value of that a but we don't have it we have a function from R to a
 we don't have an R and so we cannot apply F to anything at this point we
 have to decide at this point without applying F which will give us some
 option we need to return either a nun or a some heartily so trying to return
 the nun here would be bad because then I would return none in both cases
 so we basically have a flat model that always returns an empty option and
 that has no hope of satisfying the identity law which is that flat map
 of something with pure is equal to that something but if our flat map always
 returns an empty option this will never work so let's try to return a non
 empty option okay so we start returning it we have an R now we can use
 this function f by computing R to a of origin of type a and applying F
 to that so we get an option over hard to be here but we are inside this
 function we are required to return a value of type B but we don't have
 that we have an option of something which could be none and this point
 could be empty and if it is not empty as we can return the value of time
 but if it is empty we are stuck we cannot return a value of type B so there
 is no good implementation of flat map in this case a pure we can implement
 with a flat map no let's look at the statement so this is the statement
 type constructor so let's compose it with reader well I need to implement
 flat map with this type signature work as R is this combination the state
 with this radio inside now I will follow the types and there's only one
 way of implementing it so we start with a function s we need to return
 as RB which is s going to a pair of s and R to me so start with s then
 we can compute FA of s we get these things now we want to return the pair
 of s 1 and a function are to be now how do we get a be only way to get
 a B is to apply the function f to some a so we have an a yes we can apply
 after a we can give an R 2 that give it a B so finally we get a B but we
 have to discard this value s not we obtained lust so and this is suspicious
 in the state monad we should not discard updated values of the state yes
 but we have to discard it because we are returning must return s here and
 the function are to be is inside so we cannot give this s which we only
 computed here back over and over there and this is indeed the problem that
 we described certain parts of the state so essentially we have not used
 f in computing the new state I have used f to compute the new value but
 F only gives you not only gives you a value it only gives you an effect
 of taking on the state and is updating we are ignoring and indeed it will
 violate the identity law which is this one of the identity laws and I can
 show that this is so because if I compute the flatmap according to the
 code over there then it will be a function that always ignores the value
 which is okay it's the pure but it always returns the unmodified state
 s so the first element of the pair is always going to be unmodified state
 s and this could not be equal to F it should it should equal F this should
 equal f of X but it cannot because F could modify the state language F
 could be of this form which modifies the state but our flat map will never
 modify the state in this combination with pure and so that cannot possibly
 be equal to f of X for arbitrary functions F no F I could have an effect
 and we should have accumulated that effect we are not now trying to compose
 state monad with reader inside fails what about composing it outside let's
 take an option another simple model and compose it outside with state Bible
 you know go through this in detail but it's a very simple computation and
 basically either you're always return none in your flattener an empty option
 which is bad or you're stuck you're trying to return the value you need
 and you don't get it you have an option of something but you need that
 value itself so you have an option in the wrong place and you're stuck
 you're not able to compute a be just like we're not able to compute early
 previously so this shows that the state moment fails to compose with other
 moments in either order so it does come to us with some owners in one order
 in with other models in another order but you cannot in advance say I compose
 the state monad outside with an arbitrary other monad and that result is
 valid or not no that doesn't work or inside no doesn't work so this is
 a problem and [Music] the solution is actually what is called mono transformers
 the main trick is that we're not going to try to combine arbitrary to monads
 we're going to fix one moment which will go call the base model and look
 I will denote it as L and for a fixed L I will let the other one at vary
 so that will be called a foreign minute and we'll try to assimilate the
 foreign minute into a fixed base model and combine them in this way so
 the result is a type constructor on which I call T LOM and it still has
 a type parameter you're not it here by this placeholder symbol so this
 placeholder symbol is just a type parameter that I'm not writing so I introduce
 this notation in the previous chapter and this color this is written simply
 like that it says type parameter that we're not writing so this type constructo
r depends on both L and M and it gives you a new moment and it is such that
 for a fixed L this M is actually a type parameter so this works for a fixed
 L and for any M so fixed base model and arbitrary foreign moment so that's
 what that transformer is it's a type constructor it depends on L and M
 but it depends on them in a different way so it is generic and M but not
 an L in other words for each L for each baseman on L there is a different
 construction t om but the construction is the same for all M so the fixed
 L the construction is the same for all M so in other words its generic
 in him so right away that is important to understand that there's no general
 formula that takes a monad L and produces the transformer doesn't seem
 to exist so for each L for each base moment he'll we need a different construct
ion of the city em the foreign moment will be generic but the basement will
 not be just a parameter and finally there is a question whether some monads
 have a transformer or not now I don't know how to answer this question
 but I do have examples of monads that don't have full-featured transformers
 and maybe this is not a problem but I do not have examples of monads where
 I don't know how to make a transformer so this question seems to be difficult
 and in practice every moment that we can write down as a type constructor
 will have a transformer or at least halfway I will talk about this in more
 detail very soon so what is the advantage of having this approach of using
 this approach when we fix the base model and vary the foreign model the
 advantage is that now we can easily compose three or more units by simply
 composing the Transformers since the transformer is generic in this one
 on M I can put that monad M as the type parameter and I can set it to a
 transformer for a different moment I'm missing here another type parameter
 placeholder but the notation is difficult as it is so in Scala for example
 you would have transformers such as State T of list T of freighter so you
 can do that with these placeholders which correspond to my lowitz and in
 this way you can stack together many many wonders with no additional work
 once you have implemented transformer for each Manette you can stack any
 number of them like this so no need to have a combinatorial explosion in
 how many different transformers you need combined future and option future
 in list list an option listen either future and either know it just implement
 a transformer for list transformer for either transform an option transformer
 for reader and then you just stack them and this is called the moon a stack
 but make sure you don't mix together and one on stack and composition of
 type constructors will functor composition because this is not the same
 as a simple composition like this the transformer is not just a composition
 for someone as it is but for others it is not unlike for the state model
 it is not a composition as we have seen i cannot work as a composition
 also for some units the composition goes inside and for others outside
 the transformer is a type constructor that is always outside but the result
 of it could be that some things are inside work or even transcribed in
 some difficult way that is neither composition inside nor outside so monad
 stack is not the same as composing type constructors formulas this is not
 a minute this would not work well that transformers will always work they
 will always produce and will not satisfy all the laws so what are the requireme
nts for mana transformers for all foreign there must be the following properties
 so first of all this must be a monad which I call the moon at em transformed
 with this transform ITL so it's a foreign moment that has been assimilated
 somehow onto the base model and the result is this big larger moment that
 has both effects there must be a lifting which is this function monad morphism
 between em the foreign Monat and the transformer there's also the base
 lifting which lifts the basement in the new transformer but it is not natural
 in L because L is not a natural type Brown or not generic type parameter
 in the transformer another property is that if we take the identity monad
 as M and the result must be equivalent to hell and this is not natural
 because the identity monad does not have an effect so if we transform that
 assimilate and that then just the effects of L remain and that's the same
 as just having L now the fact that the transformer is magnetically natural
 in the mannered M means that there are these other properties namely T
 must be paralyzed by him as a type parameter and for any other moment in
 we could we should be able to map M - n inside the T so if we know how
 to map M - n using some melodic morphism then we should also know how to
 map transform the M to transformed him so this I call em Ron so if I know
 how to run the moon and em into some other moment and I should know how
 to run the transform model into the transform the other monitor also these
 runners must commute with lifts and baseless so if I first lift and then
 run for example for lift L and then I run [Music] then I should obtain
 the same result as when I first run and then lift so we will look at the
 precise formulation of this a little later now this naturality will always
 hold automatically as long as we implement this mu not only using the moon
 had methods of him we don't use the structure of M but only call its methods
 pure and flat map and this situation is similar to what happened in chapter
 9 when we talked about I talked about Traverse so this Traverse had this
 type signature and it was natural with respect to negative function f so
 did not use the structure of the function f only the fact that it was a
 negative and this therefore can be used to run the monad for example take
 this runner if it exists and lift it to this runner which is a runner from
 TM to L so we can eliminate the effects of M or run them evaluate them
 perform them and get just an L which are so effects of L and M were combined
 in this monad we can separately run or evaluate effects of M and the effects
 of L should remain similarly there should be a base runner where we can
 run the effects of L inside the transferrin monad and the result is just
 M left that's the base runner and again it should commute with lift and
 base lifts why do we need these runners well the only way to evaluate Mona's
 is to run them to actually perform the effects and unless these laws hold
 performing the effects would give incorrect results when we combine the
 effects so we should be able to combine the effects without changing our
 ability to run them separately so we can combine L and M effects but we
 can run ill and not M work we can just run em but not l separately as much
 as we can as much as we need to separate them so these are the requirements
 and I will go through these requirements later to prove that they hold
 for all the monad transformers here are some first examples if we have
 a reader then the reader composed outside works if we have this mu knot
 which is a combination of either and writer then this can be composed inside
 these are monarch instructions that I have proved in Chapter 7 and actually
 these are ma not transformers for these moments from the reader and for
 this moment which is a combination of either and writer so therefore these
 are the Transformers reader te 30 and writer T which we can write down
 immediately already having proved that these are models we still haven't
 proved other laws but we have proved that the Campbell combine types Ramona's
 notice that the reader composes with the foreign loan add from the outside
 but either in writer compose inside that foreign unit and this must be
 so other the other way around is wrong it doesn't work does not produce
 a minute for her betray him which I just showed you thank God the remaining
 questions for us so what about other movements so now we chanced to know
 this before but what about other moments we don't know and they don't compose
 me neither of them composes inside or outside with arbitrary other monads
 so we also have a lot of other melodic instructions how to find transformers
 for the results of those constructions if we use them and if we know transforme
rs for some previous moment we made new moments out of previous moments
 how to find transformers for them what about monads constructed using a
 transformer what's a transformer for that and whether it's always possible
 as like I said it is unknown maybe there are some owners that don't have
 transformers I haven't seen good examples of that now is a transformer
 unique now it is not almost sure why but usually there is one transformer
 against preferred that's the simplest and that's what people usually mean
 when they say the mono transformer and another final issue is all this
 boilerplate around lift now lifting is still quite cumbersome you need
 all this lifting and the code is cumbersome because they're all these especiall
y if you have more than two monads combined and there's lift of lift of
 lift in different orders and that makes code difficult to maintain so there
 are solutions for that which are called MTL style transformers until stands
 for monad transformer library so I'll talk about these issues in order
 in the rest of this chapter here's an overview of all what I know about
 one on transformers each one that has a different transformer so it's really
 a zoology and each construction is ad-hoc so there's no general method
 for them so some will not have composed inside transformer so these are
 the option right here and either for each Monett we need to know what that
 is so we will see how that works so for someone as it's composed inside
 for others it's composed outside so this is the formula what are those
 moments that can pose outside the reader and also there's a unit called
 the search monad which is this type which I have shown before the chapter
 7 I didn't call it specifically a search moment but this and similar moments
 have transformers and that can pose outside and more generally I define
 I will define a class of factors that are called the rigid and muninn saturated
 or have outside transformers so they're kind of they're they're generalizing
 the reader and this kind of monad there are several other such types another
 type of monads is recursive lists non-empty lists and free movement they
 are defined recursively and neither of the compositions worked for them
 they need a different construction which is interleaving the basement and
 the foreign unit inside the recursion so it cannot be just composition
 another type of monads is monads obtained from constructions so for example
 product a unit has a product of transformers so you need to know the transforme
r for L one transformer for L 2 and then you make a product that is the
 transformer for the product monent another construction that I already
 described in chapter 7 is this we have a contra factor H and have a function
 from its to a so this construction works for any control factor H and gives
 you a moment and this moment has a composed outside transformer it is rigid
 another class of one else is free pointed minutes this is also construction
 from chapter 7 a transformer for that Monod looks like this it's neither
 composition outside nor inside and requires you to know the transformer
 for the m'lad l and then you know how to define a transformer for this
 moment finally there are irregular moments where none of these constructions
 work for example the statement for the statement composition doesn't work
 these constructions doesn't don't work you need to put the formula at the
 precise spot inside the statement and then it works for the continuation
 or not you need to put the foreign wallet in here otherwise nothing works
 there is a another class of Mona's that I call selectors for them you have
 to do this again it's neither composition nor constructions like that finally
 there is a good density monitor which again you have to put the foreign
 model inside at specific places so these are irregular so each has its
 own recipe and there doesn't seem to be much of a system here it is not
 clear that one odds could exist with no transformers but one suspicious
 fact is that some transformers do not have several of the required methods
 so for example the continuation monad transformer does not have a base
 lifting in other words you cannot lift a value of the continuation monad
 into the value of these types of continuation when it is a - R - R cannot
 lift that into a TOA Mart anymore for arbitrary yeah now this is a problem
 in my view it means that these transformers are not fully usable they kind
 of half work but unless I can lift both my monads into a transformer I
 cannot really replace in the functor block the previous monad with the
 big moment so in my view this is a problem and you could argue that these
 transformers are incorrect they are not fully featured they do not satisfy
 the required laws I couldn't get that and I will talk about this later
 so now I begin with the composed inside transformers which is the first
 class of transformers in my 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
