#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Relational parametricity proofs]{Proving "theorems for free" via relational parametricity}
\subtitle{A tutorial, with example code in Scala}
\author{Sergei Winitzki}
\date{2023-01-01}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\usepackage[nocenter]{qtree}
\usepackage{relsize}
\renewcommand\arraystretch{1.4}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Outline of the tutorial
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Motivation: practical applications of the parametricity theorem
\end_layout

\begin_layout Itemize
What is 
\begin_inset Quotes eld
\end_inset

fully parametric code
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Naturality laws and their uses
\end_layout

\begin_deeper
\begin_layout Itemize
Example: Covariant and contravariant Yoneda identities
\end_layout

\end_deeper
\begin_layout Itemize
A complete proof of 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset

 in 6 steps
\end_layout

\begin_deeper
\begin_layout Itemize
Step 1: Deriving 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 methods from types
\end_layout

\begin_layout Itemize
Step 2: Motivation for the relational approach to naturality laws
\end_layout

\begin_layout Itemize
Step 3: Definition and examples of relations
\end_layout

\begin_layout Itemize
Step 4: Definition and properties of the relational lifting (
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
Step 5: Proof of the relational naturality law
\end_layout

\begin_layout Itemize
Step 6: Deriving the wedge law from the relational naturality law
\end_layout

\end_deeper
\begin_layout Itemize
Advanced applications of the parametricity theorem: beyond Yoneda
\end_layout

\begin_deeper
\begin_layout Itemize
Church encodings of recursive types
\end_layout

\begin_layout Itemize
Simplifying universally quantified types where Yoneda fails
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Applications of parametricity.
 
\begin_inset Quotes eld
\end_inset

Theorems for free
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Parametricity theorem
\series default
: any fully parametric function obeys a certain law
\end_layout

\begin_layout Standard
Some applications:
\end_layout

\begin_layout Standard
Naturality laws for code that works in the same way for all types
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def headOption[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case Nil            => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case head :: tail   => Some(head)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Itemize
Naturality law for 
\family typewriter
\size small
\color blue
headOption
\family default
\size default
\color inherit
: for all 
\family typewriter
\size small
\color blue
x:
\begin_inset space ~
\end_inset

List[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
,
\end_layout

\begin_layout LyX-Code

\size small
\color blue
x.headOption.map(f) == x.map(f).headOption
\end_layout

\begin_layout Standard
Uniqueness properties for fully parametric functions
\end_layout

\begin_layout Itemize
The 
\family typewriter
\size small
\color blue
map
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
contramap
\family default
\size default
\color inherit
 methods uniquely follow from types
\end_layout

\begin_layout Itemize
There is only one function 
\family typewriter
\size small
\color blue
f
\family default
\size default
\color inherit
 with type signature 
\family typewriter
\size small
\color blue
f[A]: A => (A, A)
\end_layout

\begin_layout Standard
Type equivalence for universally quantified types
\end_layout

\begin_layout Itemize
The type of functions 
\family typewriter
\size small
\color blue
pure[A]: A => F[A]
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
F[Unit]
\end_layout

\begin_deeper
\begin_layout Itemize
In Scala 3, this type is written as 
\family typewriter
\size small
\color blue
[A] => A => F[A]
\end_layout

\end_deeper
\begin_layout Itemize
The type 
\family typewriter
\size small
\color blue
[A] => (A, (R, A) => A) => A
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
List[R]
\end_layout

\begin_layout Itemize
The type 
\family typewriter
\size small
\color blue
[A] => ((A => R) => A) => A
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
R
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Requirements for parametricity.
 Fully parametric code
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Parametricity theorem works only if the code is 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize

\series bold
\begin_inset Quotes eld
\end_inset

Fully parametric
\begin_inset Quotes erd
\end_inset


\series default
 code: use only type parameters and 
\family typewriter
\size small
\color blue
Unit
\family default
\size default
\color inherit
, no run-time type reflection, no external libraries or built-in types
\end_layout

\begin_deeper
\begin_layout Itemize
For instance, no 
\family typewriter
\size small
\color blue
IO
\family default
\size default
\color inherit
-like monads
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Fully parametric
\begin_inset Quotes erd
\end_inset

 is a stronger restriction than 
\begin_inset Quotes eld
\end_inset

purely functional
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Parametricity theorem applies only to a subset of a programming language
\end_layout

\begin_layout Itemize
Usually, it is a certain flavor of typed lambda calculus
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of code that is not fully parametric
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Explicit matching on type parameters using type reflection:
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def badHeadOpt[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case Nil                 => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case (head: Int) :: tail => None // Run-time type match!
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case head :: tail        => Some(head)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Standard
Using typeclasses: define a typeclass 
\size small
\color blue
NotInt[A]
\size default
\color inherit
 with the method 
\size small
\color blue
notInt[A]
\size default
\color inherit
 that returns 
\size small
\color blue
true
\size default
\color inherit
 unless 
\size small
\color blue
A = Int
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def badHeadOpt[A: NotInt]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case h :: tail if notInt[A]   => Some(h)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case _ => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Standard
Failure of naturality law:
\end_layout

\begin_layout LyX-Code

\size small
\color blue
scala> badHeadOpt(List(10, 20, 30).map(x => s"x = $x"))
\end_layout

\begin_layout LyX-Code

\size small
\color blue
res0: Option[String] = Some(x = 10)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size small
\color blue
scala> badHeadOpt(List(10, 20, 30)).map(x => s"x = $x")
\end_layout

\begin_layout LyX-Code

\size small
\color blue
res1: Option[String] = None
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace 100baselineskip%
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Fully parametric programs are written using the 9 code constructions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = { // 3
\end_layout

\begin_layout Plain Layout

   case Nil            => Nil
\end_layout

\begin_layout Plain Layout

//   8   1                1,7 
\end_layout

\begin_layout Plain Layout

   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

//   8       6             2 4     6  5 2 4     6    7   9
\end_layout

\begin_layout Plain Layout

}           // This code uses each of the nine allowed constructions.
\end_layout

\end_inset


\begin_inset VSpace -20baselineskip%
\end_inset


\end_layout

\begin_layout Enumerate
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value (or equivalent type), e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use bound variable (a given argument of the function)
\end_layout

\begin_layout Enumerate
Create a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr(x) }
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create a product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 (or via pattern matching)
\end_layout

\begin_layout Enumerate
Create a co-product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a co-product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...
 => ...
 }
\end_layout

\end_inset

 (pattern matching)
\end_layout

\begin_layout Enumerate
Use a recursive call: e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

 within the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Naturality laws require 
\family typewriter
map
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Naturality law: applying 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

F[A] => G[A]
\family default
\size default
\color inherit
 
\emph on
before
\emph default
 
\family typewriter
\size small
\color blue
_.map(f)
\family default
\size default
\color inherit
 equals applying 
\family typewriter
\size small
\color blue
t[B]:
\begin_inset space ~
\end_inset

F[B] => G[B]
\family default
\size default
\color inherit
 
\emph on
after
\emph default
 
\family typewriter
\size small
\color blue
_.map(f)
\family default
\size default
\color inherit
 for any function 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar[d]\sb(0.5){~\mathtt{\_.map(f)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar[d]\sp(0.5){\mathtt{\_.map(f)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size small
\color blue
F = List
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
G = Option
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
t = headOption
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset

The naturality law of 
\family typewriter
\size small
\color blue
headOption
\family default
\size default
\color inherit
: for all 
\family typewriter
\size small
\color blue
x:
\begin_inset space ~
\end_inset

List[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
,
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
x.headOption.map(f) = x.map(f).headOption
\end_layout

\begin_layout Standard
Naturality laws are formulated using 
\family typewriter
\size small
\color blue
_.map
\family default
\size default
\color inherit
 for 
\family typewriter
\size small
\color blue
F
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G
\end_layout

\begin_layout Standard
What is the code of 
\family typewriter
\size small
\color blue
map
\family default
\size default
\color inherit
 for a given 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Itemize
Equivalently, the code of 
\family typewriter
\size small
\color blue
fmap[A, B]:
\begin_inset space ~
\end_inset

(A => B) => F[A] => F[B]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Using naturality laws: the Yoneda identities
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For covariant 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
, the type 
\family typewriter
\size small
\color blue
F[R]
\family default
\size default
\color inherit
 is equivalent to the type of functions 
\family typewriter
\size small
\color blue
p[A]:
\begin_inset space ~
\end_inset

(R => A) => F[A]
\family default
\size default
\color inherit
 satisfying the naturality law:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
p[A](k).map(f) == p[B](k andThen f)
\family default
\size default
\color inherit
 for all 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\end_layout

\begin_layout Standard
Isomorphism maps:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
inY[A]:
\begin_inset space ~
\end_inset

F[R] => (R => A) => F[A] = fr => k => fr.map[A](k)
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
outY:
\begin_inset space ~
\end_inset

([A] => (R => A) => F[A]) => F[R] = p => p[R](identity[R])
\end_layout

\begin_layout Standard
Proofs of isomorphism:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
outY(inY(fr)) == outY(k => fr.map(k)) == fr.map(identity) == fr
\end_layout

\begin_layout Standard
The other direction:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
inY(outY(p)) == k => outY(p).map(k) == k => p(identity).map(k)
\end_layout

\begin_layout Standard
Use the naturality law: 
\family typewriter
\size small
\color blue
p(identity).map(k) == p(identity andThen k)
\end_layout

\begin_layout Standard
So: 
\family typewriter
\size small
\color blue
inY(outY(p)) == k => p(k) == p
\end_layout

\begin_layout Itemize
The naturality law and the code of 
\family typewriter
\size small
\color blue
inY
\family default
\size default
\color inherit
 must use 
\emph on
the same
\emph default
 
\family typewriter
\size small
\color blue
_.map
\end_layout

\begin_layout Standard
For contravariant 
\family typewriter
\size small
\color blue
G[A]
\family default
\size default
\color inherit
, the type 
\family typewriter
\size small
\color blue
G[R]
\family default
\size default
\color inherit
 is equivalent to the type of functions 
\family typewriter
\size small
\color blue
q[A]:
\begin_inset space ~
\end_inset

(A => R) => G[A]
\family default
\size default
\color inherit
 satisfying the appropriate naturality law
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example applications of the Yoneda identities
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Many types can be converted to the form 
\family typewriter
\size small
\color blue
[A] => (R => A) => F[A]
\family default
\size default
\color inherit
 with a covariant 
\family typewriter
\size small
\color blue
F
\family default
\size default
\color inherit
 or to 
\family typewriter
\size small
\color blue
[A] => (A => R) => G[A]
\family default
\size default
\color inherit
 with a contravariant 
\family typewriter
\size small
\color blue
G
\end_layout

\begin_layout Standard
Some examples (assume covariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 and contravariant 
\family typewriter
\size small
\color blue
G[_]
\family default
\size default
\color inherit
):
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => A
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
Nothing
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => F[A]
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
F[Nothing]
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => G[A]
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
G[Unit]
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => A => A
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
Unit
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => A => F[A]
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
F[Unit]
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => (A, A) => A
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
Boolean
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => (A, A) => F[A]
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
F[Boolean]
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => (P => A) => Q => A
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
Q => P
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => (A => P) => A => Q
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
P => Q
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
[A] => F[A] => (A => P) => Q
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
F[P] => Q
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
flatMap
\family default
\size default
\color inherit
 is equivalent to 
\family typewriter
\size small
\color blue
flatten
\family default
\size default
\color inherit
: (use Yoneda w.r.t.
\begin_inset space ~
\end_inset


\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
)
\family typewriter
\size small
\color blue

\begin_inset Newline newline
\end_inset

def flatMap[A, B]: M[A] => (A => M[B]) => M[B]
\begin_inset Newline newline
\end_inset

def flatten[B]: M[M[B]] => M[B]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Fully parametric type constructors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
What is the 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 function for a given type constructor 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Itemize
If the code of 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

F[A] => G[A]
\family default
\size default
\color inherit
 is fully parametric, then there are only a few ways to build the type construct
ors 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[_]
\end_layout

\begin_layout Itemize
Such 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset

 type constructors 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 are built as: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = Unit
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
F[A] = B
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
B
\family default
\size default
\color inherit
 is another type parameter
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = A
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = (G[A], H[A])
\family default
\size default
\color inherit
 — product types
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = Either[G[A], H[A]]
\family default
\size default
\color inherit
 — co-product types
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = G[A] => H[A]
\family default
\size default
\color inherit
 — function types
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = G[F[A], A]
\family default
\size default
\color inherit
 — recursive types
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = [X] => G[A, X]
\family default
\size default
\color inherit
 — universally quantified types
\end_layout

\begin_layout Standard
The recursive type construction (
\family typewriter
\size small
\color blue
Fix
\family default
\size default
\color inherit
) can be defined as:
\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
case class Fix[G[_, _], A](unfix:
\begin_inset space ~
\end_inset

G[Fix[G[_, _], A], A])
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
F[A] = Fix[G, A]
\family default
\size default
\color inherit
 satisfies the type equation 
\family typewriter
\size small
\color blue
F[A] = G[F[A], A]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Deriving 
\family typewriter
fmap
\family default
 from types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset VSpace -25baselineskip%
\end_inset

What is the 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 function for a covariant type constructor 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
?
\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
fmap_F[A, B]:
\begin_inset space ~
\end_inset

(A => B) => F[A] => F[B]
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = Unit
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
F[A] = B
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
fmap_F(f) = identity
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = A
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
fmap_F(f) = f
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = (G[A], H[A])
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
fmap_G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fmap_H
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
fmap_F(f) = { case (ga, ha) => (fmap_G(f)(ga), fmap_H(f)(ha)) }
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = Either[G[A], H[A]]
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
fmap_F(f) = {
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case Left(ga)
\begin_inset space ~
\end_inset

 => Left(fmap_G(f)(ga))
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case Right(ha) => Right(fmap_H(f)(ha))
\begin_inset Newline newline
\end_inset

}
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = G[A] => H[A]
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
cmap_G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fmap_H
\begin_inset Newline newline
\end_inset

cmap_G[A, B]:
\begin_inset space ~
\end_inset

(A => B) => G[B] => G[A]
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
We define 
\family typewriter
\size small
\color blue
fmap_F(f)(p:
\begin_inset space ~
\end_inset

G[A] => H[A]) =
\begin_inset Newline newline
\end_inset

 cmap_G(f) andThen p andThen fmap_H(f)
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = G[F[A], A]
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
fmap_G1
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fmap_G2
\begin_inset Newline newline
\end_inset

fmap_F(f) = fmap_G1(fmap_F(f)) andThen fmap_G2(f)
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = [X] => G[A, X]
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
fmap_G1
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
fmap_F(f) = p => [X] => fmap_G1(f)(p[X]))
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Deriving 
\family typewriter
cmap
\family default
 from types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset VSpace -25baselineskip%
\end_inset

When 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 is contravariant, we need the 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 function
\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
cmap_G[A, B]:
\begin_inset space ~
\end_inset

(A => B) => G[B] => G[A]
\end_layout

\begin_layout Itemize
Use structural indunction on the type of 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = Unit
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
F[A] = B
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
cmap_F(f) = identity
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = A
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
F
\family default
\size default
\color inherit
 is 
\emph on
not
\emph default
 contravariant!
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = (G[A], H[A])
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
cmap_G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
cmap_H
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
cmap_F(f) = { case (gb, hb) => (cmap_G(f)(gb), cmap_H(f)(hb)) }
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = Either[G[A], H[A]]
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
cmap_F(f) = {
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case Left(gb)
\begin_inset space ~
\end_inset

 => Left(cmap_G(f)(gb))
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case Right(hb) => Right(cmap_H(f)(hb))
\begin_inset Newline newline
\end_inset

}
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = G[A] => H[A]
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
fmap_G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
cmap_H
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
We define 
\family typewriter
\size small
\color blue
cmap_F(f)(k:
\begin_inset space ~
\end_inset

G[B] => H[B]) =
\begin_inset Newline newline
\end_inset

 fmap_G(f) andThen k andThen cmap_H(f)
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = G[F[A], A]
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
fmap_G1
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
cmap_G2
\begin_inset Newline newline
\end_inset

cmap_F(f) = fmap_G1(cmap_F(f)) andThen cmap_G2(f)
\end_layout

\begin_layout Enumerate
If 
\family typewriter
\size small
\color blue
F[A] = [X] => G[A, X]
\family default
\size default
\color inherit
 then we need 
\family typewriter
\size small
\color blue
cmap_G1
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
cmap_F(f) = k => [X] => cmap_G1(f)(k[X]))
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Detect covariance and contravariance from types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The same constructions for 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 except for function types
\end_layout

\begin_layout Itemize
The function arrow (
\family typewriter
\size small
\color blue
=>
\family default
\size default
\color inherit
) swaps covariant and contravariant positions
\end_layout

\begin_layout Itemize
In any fully parametric type expression, each type parameter is either in
 a covariant position or in a contravariant position
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
type F[A, B] = (A => Either[A, B], A => (B => A) => (A, B))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
                -           +  +   -     +    -      +  +
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
F[A, B]
\family default
\size default
\color inherit
 is covariant w.r.t.
\begin_inset space ~
\end_inset


\family typewriter
\size small
\color blue
B
\family default
\size default
\color inherit
 since 
\family typewriter
\size small
\color blue
B
\family default
\size default
\color inherit
 is always in covariant positions
\end_layout

\begin_deeper
\begin_layout Itemize
But 
\family typewriter
\size small
\color blue
F[A, B]
\family default
\size default
\color inherit
 is neither covariant nor contravariant w.r.t.
\begin_inset space ~
\end_inset


\family typewriter
\size small
\color blue
A
\end_layout

\begin_layout Itemize
We can recognize co(ntra)variance by counting nested function arrows
\end_layout

\end_deeper
\begin_layout Itemize
Defined in this way, co(ntra)variance is independent of subtyping
\end_layout

\begin_layout Itemize
We can generate the code for 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 mechanically, from types
\end_layout

\begin_layout Itemize
A type expression 
\family typewriter
\size small
\color blue
F[A, B, ...]
\family default
\size default
\color inherit
 can be analyzed with respect to each of the type parameters separately,
 and found to be covariant, contravariant, or neither (
\begin_inset Quotes eld
\end_inset

invariant
\begin_inset Quotes erd
\end_inset

) 
\end_layout

\begin_layout Itemize
We can write the naturality law for any type signature 
\family typewriter
\size small
\color blue
F[A] => G[A]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 
\begin_inset Quotes eld
\end_inset

Invariant
\begin_inset Quotes erd
\end_inset

 type constructors.
 Profunctors
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For 
\begin_inset Quotes eld
\end_inset

invariant
\begin_inset Quotes erd
\end_inset

 types, we use a trick: rename contravariant positions
\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size small
\color blue
type F[A] = Either[A => (A, A), (A, A) => A]
\end_layout

\begin_layout Itemize
Define 
\family typewriter
\size small
\color blue
type P[X, A] = Either[X => (A, A), (X, X) => A]
\end_layout

\begin_layout Itemize
Then 
\family typewriter
\size small
\color blue
F[A] = P[A, A]
\family default
\size default
\color inherit
 while 
\family typewriter
\size small
\color blue
P[X, A]
\family default
\size default
\color inherit
 is contravariant in 
\family typewriter
\size small
\color blue
X
\family default
\size default
\color inherit
 and covariant in 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
.
 Such 
\family typewriter
\size small
\color blue
P[X, A]
\family default
\size default
\color inherit
 are called 
\series bold
profunctors
\end_layout

\begin_layout Itemize
We can implement 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 with respect to 
\family typewriter
\size small
\color blue
X
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 with respect to 
\family typewriter
\size small
\color blue
A
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
def fmapP[X, A, B]: (A => B) => P[X, A] => P[X, B]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
def cmapP[X, Y, A]: (X => Y) => P[Y, A] => P[X, A]
\end_layout

\begin_layout Itemize
Then we can compose 
\family typewriter
\size small
\color blue
cmapP
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fmapP
\family default
\size default
\color inherit
 to get 
\family typewriter
\size small
\color blue
xmapF
\family default
\size default
\color inherit
:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\size small
\color blue
def xmapF[A, B]: (A => B, B => A) => P[A, A] => P[B, B] =
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
\begin_inset space ~
\end_inset

 (f, g) => cmapP[A, B, A](g) andThen fmapP[B, A, B](f)
\end_layout

\end_deeper
\begin_layout Itemize
What if we compose in another order? A commutativity law holds:
\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{P[A,A]}\ar[d]\sb(0.5){~\mathtt{fmapP(f)}}\ar[r]\sp(0.5){\mathtt{~\mathtt{cmapP(g)}}}\ar[rd]\sp(0.5){\mathtt{~\mathtt{xmapF(f,g)}}} & \mathtt{P[B,A]}\ar[d]\sp(0.5){\mathtt{~\mathtt{fmapP(f)}}}\\
\mathtt{P[A,B]}\ar[r]\sp(0.5){~\mathtt{cmapP(g)}} & \mathtt{P[B,B]}
}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Verifying the functor laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 need to satisfy two functor laws
\end_layout

\begin_layout Itemize
Identity law:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
fmap(identity) = identity
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
cmap(identity) = identity
\end_layout

\begin_layout Itemize
Composition law: for any 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
,
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
fmap(f) andThen fmap(g) = fmap(f andThen g)
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
 
\family typewriter
\size small
\color blue
cmap(g) andThen cmap(f) = cmap(f andThen g)
\end_layout

\begin_layout Itemize
Go through each case and prove that the laws hold
\end_layout

\begin_deeper
\begin_layout Itemize
Proofs by induction on the type structure
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Functor laws: composition law for tuples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset VSpace -25baselineskip%
\end_inset

We will prove the composition law for 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 in case 3
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
fmap_F(f) = { case (ga, ha) => (fmap_G(f)(ga), fmap_H(f)(ha)) }
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
For any 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
 and values 
\family typewriter
\size small
\color blue
ga:
\begin_inset space ~
\end_inset

G[A], ha:
\begin_inset space ~
\end_inset

H[A]
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
Apply 
\family typewriter
\size small
\color blue
fmap_F(f) andThen fmap_F(g)
\family default
\size default
\color inherit
 to the tuple 
\family typewriter
\size small
\color blue
(ga, ha)
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
fmap_F(f)((ga, ha)) == ( fmap_G(f)(ga), fmap_H(f)(ha) )
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
fmap_F(g)((fmap_G(f)(ga), fmap_H(f)(ha)))
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
== (fmap_G(g)(fmap_G(f)(ga)), fmap_H(g)(fmap_H(f)(ha)))
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
== ( (fmap_G(f) andThen fmap_G(g))(ga), (fmap_H(f) andThen fmap_H(f))(ha)
 )
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
Apply 
\family typewriter
\size small
\color blue
fmap_F(f andThen g)
\family default
\size default
\color inherit
 to the tuple 
\family typewriter
\size small
\color blue
(ga, ha)
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
fmap_F(f andThen g)((ga, ha)) == ( fmap_G(f andThen g)(ga), fmap_H(f andThen
 g)(ha) )
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
The law holds for 
\family typewriter
\size small
\color blue
fmap_F
\family default
\size default
\color inherit
 if it already holds for 
\family typewriter
\size small
\color blue
fmap_G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fmap_H
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Functor laws: composition law for function types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We will prove the composition law for 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 in case 5
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
cmap_F(f)(k) == fmap_G(f) andThen k andThen cmap_H(f)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
For any 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
kc:
\begin_inset space ~
\end_inset

G[C] => H[C]
\family default
\size default
\color inherit
:
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Apply 
\family typewriter
\size small
\color blue
cmap_F(g) andThen cmap_F(f)
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
kc
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
cmap_F(g)(kc) == fmap_G(g) andThen kc andThen cmap_H(g) 
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
cmap_F(f)(fmap_G(g) andThen kc andThen cmap_H(g))
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
== fmap_G(f) andThen fmap_G(g) andThen kc andThen cmap_H(g) andThen cmap_H(f)
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
== fmap_G(f andThen g) andThen kc andThen cmapH(f andThen g)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
This is the same as 
\family typewriter
\size small
\color blue
cmap_F(f andThen g)(kc)
\family default
\size default
\color inherit
by inductive assumption
\family typewriter
\size small
\color blue

\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
The law holds for 
\family typewriter
\size small
\color blue
cmap_F
\family default
\size default
\color inherit
 if it already holds for 
\family typewriter
\size small
\color blue
fmap_G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
cmap_H
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Functor laws: composition law for recursive types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We will prove the composition law for 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 in case 6
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
fmap_F(f) = fmap_G1(fmap_F(f)) andThen fmap_G2(f)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
For any 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
kc:
\begin_inset space ~
\end_inset

G[C] => H[C]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
ga:
\begin_inset space ~
\end_inset

G[A]
\family default
\size default
\color inherit
:
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
LHS: 
\family typewriter
\size small
\color blue
fmap_F(f) andThen fmap_F(g) == fmap_G1(fmap_F(f)) andThen fmap_G2(f) andThen
 fmap_G1(fmap_F(g)) andThen fmap_G2(g)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
RHS: 
\family typewriter
\size small
\color blue
fmap_F(f andThen g) == fmap_G1(fmap_F(f andThen g)) andThen fmap_G2(f andThen
 g) == fmap_G1(fmap_F(f) andThen fmap_F(g)) andThen fmap_G2(f) andThen fmap_G2(g
) == fmap_G1(fmap_F(f)) andThen fmap_G1(fmap_F(g)) andThen fmap_G2(f) andThen
 fmap_G2(g)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
LHS equals RHS if the commutativity law holds for 
\family typewriter
\size small
\color blue
G
\end_layout

\begin_layout Itemize
The law holds for 
\family typewriter
\size small
\color blue
fmap_F
\family default
\size default
\color inherit
 if the composition laws and the commutativity law already hold for 
\family typewriter
\size small
\color blue
fmap_G1
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fmap_G2
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 1.
 Summary
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
xmap
\family default
\size default
\color inherit
 follow from a given type expression 
\family typewriter
\size small
\color blue
F[A]
\end_layout

\begin_layout Itemize
The code of 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
xmap
\family default
\size default
\color inherit
 is always fully parametric and lawful
\end_layout

\begin_deeper
\begin_layout Itemize
That is the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 code to be used by naturality laws
\end_layout

\end_deeper
\begin_layout Itemize
Consistency of the definition of 
\family typewriter
\size small
\color blue
xmap
\family default
\size default
\color inherit
 requires a commutativity law
\end_layout

\begin_layout Itemize
Functor laws for recursive types require a commutativity law
\end_layout

\begin_deeper
\begin_layout Itemize
The commutativity laws follow from naturality and will be proved later
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 2.
 Motivation for relational parametricity.
 I.
 Papers
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Parametricity theorem: any fully parametric function satisfies a certain
 law
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Relational parametricity
\begin_inset Quotes erd
\end_inset

 is a powerful method for proving the parametricity theorem and for using
 it to prove other laws
\end_layout

\begin_layout Itemize
Main papers: 
\begin_inset CommandInset href
LatexCommand href
name "Reynolds (1983)"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

 and Wadler 
\begin_inset CommandInset href
LatexCommand href
name "“Theorems for free”"
target "https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf"
literal "false"

\end_inset

 (1989)
\end_layout

\begin_deeper
\begin_layout Itemize
Those papers are limited in scope and hard to understand
\end_layout

\end_deeper
\begin_layout Itemize
There are 
\emph on
few
\emph default
 pedagogical tutorials on relational parametricity
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "On a relation of functions"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Backhouse (1990) 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "The algebra of programming"
target "https://themattchan.com/docs/algprog.pdf"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Bird and O.
\begin_inset space ~
\end_inset

de Moor (1997)
\end_layout

\end_deeper
\begin_layout Itemize
This tutorial derives the main results 
\emph on
not
\emph default
 following any of the above
\end_layout

\begin_layout Itemize
This tutorial explains a minimum of necessary knowledge and notation
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 2.
 Motivating relational parametricity.
 II.
 The difficulty
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Naturality laws are formulated via liftings (
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
cmap
\family default
\size default
\color inherit
), for example:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
fmap(f) andThen t == t andThen fmap(f)
\end_layout

\begin_layout Standard
Cannot lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
F[A] => F[B]
\family default
\size default
\color inherit
 when 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 is not covariant!
\end_layout

\begin_layout Itemize
For covariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 we lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
fmap(f):
\begin_inset space ~
\end_inset

F[A] => F[B]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
For contravariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 we lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
cmap(f):
\begin_inset space ~
\end_inset

F[B] => F[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
In general, 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 will be neither covariant nor contravariant
\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size small
\color blue
foldLeft
\family default
\size default
\color inherit
 with respect to type parameter 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
def foldLeft[T, A]: List[T] => (T => A => A) => A => A
\end_layout

\begin_layout Itemize
This is 
\emph on
not
\emph default
 of the form 
\family typewriter
\size small
\color blue
F[A] => G[A]
\family default
\size default
\color inherit
 with 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[_]
\family default
\size default
\color inherit
 being both covariant or both contravariant
\end_layout

\begin_deeper
\begin_layout Itemize
Because some occurrences of 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 are in covariant and contravariant positions together in function arguments,
 e.g., 
\family typewriter
\size small
\color blue
(T => A => A) =>...
\end_layout

\end_deeper
\begin_layout Itemize
What law (similar to a naturality law) does 
\family typewriter
\size small
\color blue
foldLeft
\family default
\size default
\color inherit
 obey with respect to the type parameter 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Itemize
We need to formulate a more general naturality law that applies to all type
 constructors 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
, not necessarily covariant nor contravariant
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 2.
 Motivating relational parametricity.
 III.
 The solution
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The difficulty is resolved using three nontrivial ideas:
\end_layout

\begin_layout Enumerate
Replace functions 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 by binary relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
The
\series bold
 graph
\series default
 relation: 
\family typewriter
\size small
\color blue
(a, b) in graph(f)
\family default
\size default
\color inherit
 means 
\family typewriter
\size small
\color blue
f(a) == b
\end_layout

\begin_layout Itemize
Relations are more general than functions, can be many-to-many
\end_layout

\begin_layout Itemize
Instead of 
\family typewriter
\size small
\color blue
f(a) == b
\family default
\size default
\color inherit
, we will write 
\family typewriter
\size small
\color blue
(a, b) in r
\end_layout

\end_deeper
\begin_layout Enumerate
It is 
\emph on
always
\emph default
 possible to lift 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
rmap(r):
\begin_inset space ~
\end_inset

F[A] <=> F[B]
\end_layout

\begin_layout Enumerate
Reformulate the naturality law of 
\family typewriter
\size small
\color blue
t
\family default
\size default
\color inherit
 via relations: for any 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
,
\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar@{<->}[d]\sb(0.5){~\mathtt{rmap(r)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar@{<->}[d]\sp(0.5){\mathtt{rmap(r)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset


\end_layout

\end_inset

To read the diagram: the starting values are on the left
\begin_inset Newline newline
\end_inset

For any 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
, for any 
\family typewriter
\size small
\color blue
fa:
\begin_inset space ~
\end_inset

F[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fb:
\begin_inset space ~
\end_inset

F[B]
\family default
\size default
\color inherit
 such that
\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
(fa, fb) in rmap_F(r)
\family default
\size default
\color inherit
, we require 
\family typewriter
\size small
\color blue
(t(fa), t(fb)) in rmap_G(r)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
The relational naturality law will reduce to the ordinary naturality law
 when 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[_]
\family default
\size default
\color inherit
 are both co(ntra)variant and 
\family typewriter
\size small
\color blue
r = graph(f)
\family default
\size default
\color inherit
 for any 
\family typewriter
\size small
\color blue
f:A => B
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 2.
 Formulating naturality laws via relations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset VSpace -25baselineskip%
\end_inset

Ordinary naturality law of 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

F[A] => G[A]
\family default
\size default
\color inherit

\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar[d]\sb(0.5){~\mathtt{fmap\_F(f)}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar[d]\sp(0.5){\mathtt{fmap\_G(f)}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\forall$
\end_inset

 
\family typewriter
\size small
\color blue
fa:
\begin_inset space ~
\end_inset

F[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
fb:
\begin_inset space ~
\end_inset

F[B]
\family default
\size default
\color inherit
 if 
\family typewriter
\size small
\color blue
fa.map(f) == fb
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
t(fa).map(f) == t(fb)
\end_layout

\begin_layout Standard
Rewrite this via relations: For all 
\family typewriter
\size small
\color blue
fa:
\begin_inset space ~
\end_inset

F[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
fb:
\begin_inset space ~
\end_inset

F[B]
\family default
\size default
\color inherit
, when 
\family typewriter
\size small
\color blue
(fa, fb) in graph(fmap_F(f))
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t(fa), t(fb)) in graph(fmap_G(f))
\end_layout

\begin_layout Standard
We expect: 
\family typewriter
\size small
\color blue
graph(fmap(f)) == rmap(graph(f))
\family default
\size default
\color inherit
, replace 
\family typewriter
\size small
\color blue
graph(f)
\family default
\size default
\color inherit
 by 
\family typewriter
\size small
\color blue
r
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Standard
when 
\family typewriter
\size small
\color blue
(fa, fb) in rmap_F(graph(f))
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t(fa), t(fb)) in rmap_G(graph(f))
\end_layout

\begin_layout Standard
when 
\family typewriter
\size small
\color blue
(fa, fb) in rmap_F(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t(fa), t(fb)) in rmap_G(r)
\family default
\size default
\color inherit

\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar@{<->}[d]\sb(0.5){~\mathtt{rmap\_F(r)}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar@{<->}[d]\sp(0.5){\mathtt{rmap\_G(r)}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 3.
 Definition of relations.
 Examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
In the terminology of relational databases: 
\end_layout

\begin_layout Itemize
A relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 is a table with 2 columns (
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
B
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
A row 
\family typewriter
\size small
\color blue
(a:
\begin_inset space ~
\end_inset

A, b:
\begin_inset space ~
\end_inset

B)
\family default
\size default
\color inherit
 means that the value 
\family typewriter
\size small
\color blue
a
\family default
\size default
\color inherit
 is related to the value 
\family typewriter
\size small
\color blue
b
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Mathematically speaking: a relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 is a subset 
\begin_inset Formula $r\subset A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
We write 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 to mean 
\begin_inset Formula $a\times b\in r$
\end_inset

 where 
\begin_inset Formula $a\in A$
\end_inset

 and 
\begin_inset Formula $b\in B$
\end_inset


\end_layout

\begin_layout Standard
Relations can be many-to-many while functions 
\family typewriter
\size small
\color blue
A => B
\family default
\size default
\color inherit
 are many-to-one
\end_layout

\begin_layout Standard
A function 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 generates the
\series bold
 graph
\series default
 relation 
\family typewriter
\size small
\color blue
graph(f):
\begin_inset space ~
\end_inset

A <=> B
\end_layout

\begin_layout Itemize
Two values 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
 are in 
\family typewriter
\size small
\color blue
graph(f)
\family default
\size default
\color inherit
 if 
\family typewriter
\size small
\color blue
f(a) == b
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
graph(identity:
\begin_inset space ~
\end_inset

A => A)
\family default
\size default
\color inherit
 gives an 
\series bold
identity
\series default
 
\series bold
relation
\series default
 
\family typewriter
\size small
\color blue
id:
\begin_inset space ~
\end_inset

A <=> A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Example of a relation that can be many-to-many: given any 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => C
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
, define the 
\series bold
pullback relation
\series default
: 
\family typewriter
\size small
\color blue
pull(f, g):
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
;
\family typewriter
\size small
\color blue

\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

(a:
\begin_inset space ~
\end_inset

A, b:
\begin_inset space ~
\end_inset

B) in pull(f, g) 
\family default
\size default
\color inherit
means
\family typewriter
\size small
\color blue
 f(a) == g(b)
\end_layout

\begin_layout Itemize
The pullback relation is 
\emph on
not
\emph default
 the graph of a function 
\family typewriter
\size small
\color blue
A => B
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
B => A
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 3.
 Relational combinators
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Given two relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s:
\begin_inset space ~
\end_inset

X <=> Y
\family default
\size default
\color inherit
, we define new relations:
\end_layout

\begin_layout Itemize
Pair product: 
\family typewriter
\size small
\color blue
prod(r, s)
\family default
\size default
\color inherit
 of type 
\family typewriter
\size small
\color blue
(A, X) <=> (B, Y)
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
((a, x), (b, y)) in prod(r, s)
\family default
\size default
\color inherit
 means 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(x, y) in s
\end_layout

\begin_layout Itemize
Pair co-product: 
\family typewriter
\size small
\color blue
psum(r, s)
\family default
\size default
\color inherit
 of type 
\family typewriter
\size small
\color blue
Either[A, X] <=> Either[B, Y]
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
(Left(a), Left(b)) in psum(r, s)
\family default
\size default
\color inherit
 if 
\family typewriter
\size small
\color blue
(a, b) in r
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
(Right(x), Right(y)) in psum(r, s)
\family default
\size default
\color inherit
 if 
\family typewriter
\size small
\color blue
(x, y) in s
\end_layout

\begin_layout Itemize
Pair mapper: 
\family typewriter
\size small
\color blue
pmap(r, s)
\family default
\size default
\color inherit
 of type 
\family typewriter
\size small
\color blue
(A => X) <=> (B => Y)
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
(f, g) in pmap(r, s)
\family default
\size default
\color inherit
 means when 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(f(a), g(b)) in s
\end_layout

\begin_layout Itemize
Reverse: 
\family typewriter
\size small
\color blue
rev(r)
\family default
\size default
\color inherit
 has type 
\family typewriter
\size small
\color blue
B <=> A
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
(b, a) in rev(r)
\family default
\size default
\color inherit
 means 
\family typewriter
\size small
\color blue
(a, b) in r
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 4.
 The relational lifting (
\family typewriter
rmap
\family default
)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For a type constructor 
\family typewriter
\size small
\color blue
F
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
, need 
\family typewriter
\size small
\color blue
rmap(r):
\begin_inset space ~
\end_inset

F[A] <=> F[B]
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 for 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 by induction over the 
\emph on
type expression
\emph default
 of 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
For a fully parametric 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 we have seven cases:
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = Unit
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
F[A] = Z
\family default
\size default
\color inherit
 (a fixed type other than 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
): 
\family typewriter
\size small
\color blue
rmap(r) = id
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = A
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
rmap_F(r) = r
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = (G[A], H[A])
\family default
\size default
\color inherit
: 
\family typewriter
\size small
\color blue
rmap_F(r) = prod(rmap_G(r), rmap_H(r))
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = Either[G[A], H[A]]
\family default
\size default
\color inherit
:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
rmap_F(r) = psum(rmap_G(r), rmap_H(r))
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = G[A] => H[A]
\family default
\size default
\color inherit
: 
\family typewriter
\size small
\color blue
rmap_F(r) = pmap(rmap_G(r), rmap_H(r))
\end_layout

\begin_layout Enumerate
Recursive type: 
\family typewriter
\size small
\color blue
F[A] = G[A, F[A]]
\family default
\size default
\color inherit
:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
rmap_F(r) = rmap2_G(r, rmap_F(r))
\end_layout

\begin_layout Enumerate
Universally quantified type: 
\family typewriter
\size small
\color blue
F[A] = [X] => G[A, X]
\family default
\size default
\color inherit
:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
rmap_F(r) = forall(X, Y).
 forall(s:
\begin_inset space ~
\end_inset

X <=> Y).
 rmap2_G(r, s)
\end_layout

\begin_layout Itemize
The inductive assumption is that liftings to 
\family typewriter
\size small
\color blue
G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
H
\family default
\size default
\color inherit
 are already defined
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
rmap2
\family default
\size default
\color inherit
 similarly (and 
\family typewriter
\size small
\color blue
rmap3
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
rmap4
\family default
\size default
\color inherit
, ...)
\end_layout

\begin_layout Standard
For purely covariant or contravariant 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 we will get 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
cmap
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 4.
 Example: 
\family typewriter
rmap
\family default
 for function types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Compare 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 for function types
\end_layout

\begin_layout Standard
To rewrite 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 via relations, introduce intermediate arguments
\end_layout

\begin_layout Standard
Let 
\family typewriter
\size small
\color blue
F[A] = G[A] => H[A]
\family default
\size default
\color inherit
 and take any 
\family typewriter
\size small
\color blue
p:
\begin_inset space ~
\end_inset

G[A] => H[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
q = fmap_F(f)(p) = (gb:
\begin_inset space ~
\end_inset

G[B]) => fmap_H(f)(p(cmap_G(f)(gb))
\end_layout

\begin_layout Standard
Rewrite this via relations: 
\family typewriter
\size small
\color blue
(p, q) in graph(fmap_F(f))
\family default
\size default
\color inherit
 means:
\begin_inset Newline newline
\end_inset

for all 
\family typewriter
\size small
\color blue
gb:
\begin_inset space ~
\end_inset

G[B]
\family default
\size default
\color inherit
 we must have 
\family typewriter
\size small
\color blue
q(gb) = fmap_H(f)(p(cmap_G(f)(gb))
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
ga:
\begin_inset space ~
\end_inset

G[A] = cmap_G(f)(gb)
\family default
\size default
\color inherit
, then: 
\family typewriter
\size small
\color blue
q(gb) = fmap_H(f)(p(ga))
\end_layout

\begin_layout Standard
But 
\family typewriter
\size small
\color blue
ga = cmap_G(f)(gb)
\family default
\size default
\color inherit
 means 
\family typewriter
\size small
\color blue
(ga, gb) in rev(graph(cmap_G(f)))
\end_layout

\begin_layout Standard
So, the relational formulation of 
\family typewriter
\size small
\color blue
fmap_F
\family default
\size default
\color inherit
 is:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
(p, q) in graph(fmap_F(f))
\family default
\size default
\color inherit
 means for all 
\family typewriter
\size small
\color blue
ga:
\begin_inset space ~
\end_inset

G[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
gb:
\begin_inset space ~
\end_inset

G[B]
\family default
\size default
\color inherit
 when
\family typewriter
\size small
\color blue

\begin_inset Newline newline
\end_inset

(ga, gb) in rev(graph(cmap_G(f)))
\family default
\size default
\color inherit
 then:
\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
(p(ga), q(gb)) in graph(fmap_H(f))
\end_layout

\begin_layout Standard
Replace 
\family typewriter
\size small
\color blue
graph(f)
\family default
\size default
\color inherit
 by an arbitrary relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
; replace
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
graph(fmap_F(f))
\family default
\size default
\color inherit
 by 
\family typewriter
\size small
\color blue
rmap_F(r)
\family default
\size default
\color inherit
; 
\family typewriter
\size small
\color blue
rev(graph(cmap_G(f)))
\family default
\size default
\color inherit
 by 
\family typewriter
\size small
\color blue
rmap_G(r)
\end_layout

\begin_layout Standard
Then we get: 
\family typewriter
\size small
\color blue
(p, q) in rmap(r)
\family default
\size default
\color inherit
 means for all 
\family typewriter
\size small
\color blue
ga:
\begin_inset space ~
\end_inset

G[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
gb:
\begin_inset space ~
\end_inset

G[B]
\family default
\size default
\color inherit
 when
\family typewriter
\size small
\color blue

\begin_inset Newline newline
\end_inset

(ga, gb) in rmap_G(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(p(ga), q(gb)) in rmap_H(r)
\end_layout

\begin_layout Standard
This is the same as 
\family typewriter
\size small
\color blue
(p, q) in pmap(rmap_G(r), rmap_H(r))
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 4.
 Properties of 
\family typewriter
rmap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Use 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 to lift a relation 
\family typewriter
\size small
\color blue
r
\family default
\size default
\color inherit
 to a type constructor
\end_layout

\begin_layout Standard
Two main examples of relations generated by functions:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
graph(f)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
pull(f, g)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Three main examples of type constructors (
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
G[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
H[A]
\family default
\size default
\color inherit
):
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 is covariant then:
\family typewriter
\size small
\color blue
 rmap(graph(f)) == graph(fmap(f))
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
G[A] = A => A
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa, fb) in rmap(graph(f))
\family default
\size default
\color inherit
 means:
\begin_inset Newline newline
\end_inset

when 
\family typewriter
\size small
\color blue
(a, b) in graph(f)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa(a), fb(b)) in graph(f)
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset

or: 
\family typewriter
\size small
\color blue
f(fa(a)) == fb(f(a))
\family default
\size default
\color inherit
 or: 
\family typewriter
\size small
\color blue
fa andThen f == f andThen fb
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
This relation between 
\family typewriter
\size small
\color blue
fa
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fb
\family default
\size default
\color inherit
 has the form of a pullback
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
H[A] = (A => A) => A
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa, fb) in rmap_H(graph(f))
\family default
\size default
\color inherit
 means:
\begin_inset Newline newline
\end_inset

when 
\family typewriter
\size small
\color blue
(p, q) in rmap_G(graph(f))
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa(p), fb(q)) in graph(f)
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
equivalently: if 
\family typewriter
\size small
\color blue
p andThen f == f andThen q
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
f(fa(p))==fb(q)
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
This is 
\emph on
not
\emph default
 a pullback relation: cannot express 
\family typewriter
\size small
\color blue
p
\family default
\size default
\color inherit
 through 
\family typewriter
\size small
\color blue
q
\end_layout

\begin_layout Standard
It is hard to use relations that are neither a graph nor a pullback
\end_layout

\begin_layout Standard
This happens when lifting to a sufficiently complicated type constructor
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: applying relational naturality to 
\family typewriter
[A] => A => A
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Example: 
\family typewriter
\size small
\color blue
t[A] = identity[A]
\family default
\size default
\color inherit
 of type 
\family typewriter
\size small
\color blue
P[A] = A => A
\end_layout

\begin_layout Itemize
The value 
\family typewriter
\size small
\color blue
t
\family default
\size default
\color inherit
 has type 
\family typewriter
\size small
\color blue
[A] => A => A
\end_layout

\begin_layout Standard
Relational naturality law says:
\end_layout

\begin_layout Itemize
For any types 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
B,
\family default
\size default
\color inherit
 and for any relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B,
\family default
\size default
\color inherit
 we have:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
(t[A], t[B]) in rmap_P(r)
\end_layout

\begin_layout Standard
For the type 
\family typewriter
\size small
\color blue
P[A] = A => A
\family default
\size default
\color inherit
 we have:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
rmap_P(r):
\begin_inset space ~
\end_inset

(A => A) <=> (B => B)
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
rmap_P(r) = pmap(r, r)
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
(p, q) in pmap(r, r)
\family default
\size default
\color inherit
 means: for any 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
, if 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(p(a), q(b)) in r
\end_layout

\begin_layout Itemize
So, 
\family typewriter
\size small
\color blue
(t[A], t[B]) in rmap_P(r)
\family default
\size default
\color inherit
 means: for any 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
, if 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t(a), t(b)) in r
\end_layout

\begin_layout Standard
Trick: choose 
\family typewriter
\size small
\color blue
r
\family default
\size default
\color inherit
 such that 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 only when 
\family typewriter
\size small
\color blue
a == a0
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
b == b0
\end_layout

\begin_layout Itemize
Whenever 
\family typewriter
\size small
\color blue
a == a0
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
b == b0
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
t(a) == a0
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
t(b) == b0
\end_layout

\begin_layout Itemize
So, 
\family typewriter
\size small
\color blue
t(a0) == a0
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
t(b0) == b0
\family default
\size default
\color inherit
 for all 
\family typewriter
\size small
\color blue
a0:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
b0:
\begin_inset space ~
\end_inset

B
\end_layout

\begin_layout Itemize
It means that 
\family typewriter
\size small
\color blue
t
\family default
\size default
\color inherit
 must be an identity function
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 5.
 Formulation of relational naturality law
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Instead of proving relational properties for 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

P[A] => Q[A]
\family default
\size default
\color inherit
, use the function type and the quantified type constructions and get:
\end_layout

\begin_layout Itemize
Any fully parametric 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

F[A]
\family default
\size default
\color inherit
 satisfies for any 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 the relation 
\family typewriter
\size small
\color blue
(t[A], t[B]) in rmap_F(r)
\end_layout

\begin_layout Standard
It is convenient to prove the relational law with a free variable:
\end_layout

\begin_layout Itemize
Any fully parametric expression 
\family typewriter
\size small
\color blue
t[A](z):
\begin_inset space ~
\end_inset

Q[A]
\family default
\size default
\color inherit
 with 
\family typewriter
\size small
\color blue
z:
\begin_inset space ~
\end_inset

P[A]
\family default
\size default
\color inherit
 satisfies, for any relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 and for any 
\family typewriter
\size small
\color blue
z1:
\begin_inset space ~
\end_inset

P[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
z2:
\begin_inset space ~
\end_inset

P[B]
\family default
\size default
\color inherit
, the law:
\begin_inset Newline newline
\end_inset

if 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_P(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t[A](z1), t[B](z2)) in rmap_Q(r)
\end_layout

\begin_layout Itemize
Equivalently: 
\family typewriter
\size small
\color blue
(t[A], t[B]) in pmap(rmap_P(r), rmap_Q(r))
\end_layout

\begin_layout Standard
This applies to expressions containing 
\emph on
one
\emph default
 free variable (
\family typewriter
\size small
\color blue
z
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
Any number of free variables can be grouped into a tuple
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 5.
 Outline of the proof of the relational naturality law
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The theorem says that 
\family typewriter
\size small
\color blue
t[A](z)
\family default
\size default
\color inherit
 satisfies its relational naturality law
\end_layout

\begin_layout Standard
Proof goes by induction on the structure of the code of 
\family typewriter
\size small
\color blue
t[A](z)
\end_layout

\begin_layout Standard
At the top level, 
\family typewriter
\size small
\color blue
t[A](z)
\family default
\size default
\color inherit
 must have one of the 9 code constructions
\end_layout

\begin_layout Standard
Each construction decomposes the code of 
\family typewriter
\size small
\color blue
t[A](z)
\family default
\size default
\color inherit
into sub-expressions
\end_layout

\begin_layout Standard
The inductive assumption is that the theorem holds for all sub-expressions
 (including the free variable 
\family typewriter
\size small
\color blue
z
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Standard
In each inductive case, we choose arbitrary 
\family typewriter
\size small
\color blue
z1:
\begin_inset space ~
\end_inset

P[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
z2:
\begin_inset space ~
\end_inset

P[B]
\family default
\size default
\color inherit
 such that 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_P(r)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 5.
 First four inductive cases of the proof
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Constant type: 
\family typewriter
\size small
\color blue
t[A](z) = c
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
c:
\begin_inset space ~
\end_inset

C
\family default
\size default
\color inherit
 has a fixed type 
\family typewriter
\size small
\color blue
C
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
We have 
\family typewriter
\size small
\color blue
rmap_P(r) == id
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(c, c) in id
\family default
\size default
\color inherit
 holds
\end_layout

\begin_layout Standard
Use argument: 
\family typewriter
\size small
\color blue
t[A](z) = z
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
z
\family default
\size default
\color inherit
 is a value of type 
\family typewriter
\size small
\color blue
P[A]
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_P(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t(z1), t(z2)) in rmap_Q(r)
\end_layout

\begin_layout Standard
Create function: 
\family typewriter
\size small
\color blue
t(z) = h => s(z, h)
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
h:
\begin_inset space ~
\end_inset

H[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s(z, h):
\begin_inset space ~
\end_inset

S[A]
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_P(r)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(h1, h2) in rmap_H(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(s(z1, h1), s(z2, h2)) in rmap_S(r)
\end_layout

\begin_layout Standard
Use function: 
\family typewriter
\size small
\color blue
t(z) = g(z)(h(z))
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
g(z):
\begin_inset space ~
\end_inset

H[A] => Q[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
h(z):
\begin_inset space ~
\end_inset

H[A]
\family default
\size default
\color inherit
 are sub-expressions:
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_P(r)
\family default
\size default
\color inherit
 then inductive assumption says:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
(h(z1), h(z2)) in rmap_H(r)
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(h1, h2) in rmap_H(r)
\family default
\size default
\color inherit
 then inductive assumption says:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
(g(h1), g(h2)) in rmap_Q(r)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 5.
 Next four inductive cases of the proof
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Create tuple: 
\family typewriter
\size small
\color blue
t[A](z) = (p(z), q(z))
\family default
\size default
\color inherit
 and***:
\end_layout

\begin_layout Itemize
We have 
\family typewriter
\size small
\color blue
rmap_P(r) =
\end_layout

\begin_layout Standard
Use tuple: 
\family typewriter
\size small
\color blue
t[A](z) = g[A](z)._1
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
g[A]
\family default
\size default
\color inherit
 has type 
\family typewriter
\size small
\color blue
(Q[A],L[A])
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in ***
\end_layout

\begin_layout Standard
Create disjunction: 
\family typewriter
\size small
\color blue
t[A](z) = Left[K[A], L[A]](g[A](z))
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) ***
\end_layout

\begin_layout Standard
Use disjunction: 
\family typewriter
\size small
\color blue
t(z) = _ match {
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 case Left(x) => p(z)(x)
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 case Right(y) => q(z)(y)
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
}
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_Q(r)
\family default
\size default
\color inherit
 then (***
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 6.
 From relational naturality  to the wedge law
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
***Create tuple: 
\family typewriter
\size small
\color blue
t[A](z) = (p(z), q(z))
\family default
\size default
\color inherit
 and***:
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Step 6.
 From the wedge law to naturality laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
***Create tuple: 
\family typewriter
\size small
\color blue
t[A](z) = (p(z), q(z))
\family default
\size default
\color inherit
 and***:
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Advanced applications.
 I.
 Church encodings
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Recursive types defined by induction: 
\family typewriter
\size small
\color blue
T 
\begin_inset Formula $\cong$
\end_inset

 S[T]
\family default
\size default
\color inherit
 with 
\emph on
covariant
\emph default
 
\family typewriter
\size small
\color blue
S[_]
\end_layout

\begin_layout Itemize
Isomorphism is given by 
\family typewriter
\size small
\color blue
fix:
\begin_inset space ~
\end_inset

S[T] => T
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
unfix:
\begin_inset space ~
\end_inset

T => S[T]
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
fix andThen unfix == identity
\family default
\size default
\color inherit
; 
\family typewriter
\size small
\color blue
unfix andThen fix == identity
\end_layout

\begin_layout Itemize
Church encoding: 
\family typewriter
\size small
\color blue
CT = [A] => (S[A] => A) => A
\family default
\size default
\color inherit
 (fully parametric)
\end_layout

\begin_layout Itemize
Using Scala 2 traits: 
\family typewriter
\size small
\color blue
trait CT { def run[A](fix:
\begin_inset space ~
\end_inset

S[A] => A):
\begin_inset space ~
\end_inset

A }
\end_layout

\begin_layout Itemize
The Church encoding (
\family typewriter
\size small
\color blue
CT
\family default
\size default
\color inherit
) is equivalent to the inductive definition (
\family typewriter
\size small
\color blue
T
\family default
\size default
\color inherit
)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Advanced applications.
 II.
 Quantified types
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Define 
\family typewriter
\size small
\color blue
type F[R] = [A] => ((A => R) => A) => A
\end_layout

\begin_layout Itemize
This is the Church encoding of an (invalid) recursive type 
\family typewriter
\size small
\color blue
T 
\begin_inset Formula $\cong$
\end_inset

 T => R
\end_layout

\begin_layout Itemize
We will use the relational naturality law to prove that 
\family typewriter
\size small
\color blue
F[R] 
\begin_inset Formula $\cong$
\end_inset

 R
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Theorems for free
\begin_inset Quotes erd
\end_inset

 are laws always satisfied by fully parametric code
\end_layout

\begin_layout Itemize
Relational parametricity is a powerful proof technique
\end_layout

\begin_layout Itemize
Relational parametricity has a steep learning curve
\end_layout

\begin_deeper
\begin_layout Itemize
The result may be a relation that is difficult to interpret as code
\end_layout

\begin_layout Itemize
Cannot directly write code that manipulates relations
\end_layout

\begin_layout Itemize
All calculations need to be done symbolically or with proof assistants
\end_layout

\end_deeper
\begin_layout Itemize
Naturality laws and the wedge law are shortcuts to 
\begin_inset Quotes eld
\end_inset

theorems for free
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
But a few proofs in FP do require the relational naturality law
\end_layout

\end_deeper
\begin_layout Itemize
More details in the free book — 
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "27col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename book-draft-cover.png
	lyxscale 20
	width 2.5cm

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
