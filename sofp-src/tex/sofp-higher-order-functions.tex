
\chapter{The logic of types. II. Curried functions\label{chap:Higher-order-functions} }

\section{Functions that return functions}

\subsection{Motivation and first examples}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
Consider the task of preparing a logger function that prints messages
with a configurable prefix. 

A simple logger function can be a value of type \lstinline!String => Unit!,
such as:
\begin{lstlisting}
val logger: String => Unit = { message => println(s"INFO: $message") }

scala> logger("hello world")
INFO: hello world
\end{lstlisting}
This function prints any given message with the logging prefix \lstinline!"INFO"!. 

The standard library function \lstinline!println(...)! always returns
a \lstinline!Unit! value after printing its arguments. As we already
know, there is only a single value of type \lstinline!Unit!, and
that value is denoted by \lstinline!()!. To see that \lstinline!println!
returns \lstinline!Unit!, run this code:
\begin{lstlisting}
scala> val x = println(123)
123
x: Unit = ()
\end{lstlisting}

The task is to make the logging prefix configurable. A simple solution
is to implement a function \lstinline!logWith! that takes a prefix
as an argument and returns a new logger containing that prefix. Note
that the function \lstinline!logWith! returns a new \emph{function},
i.e., a new value of type \lstinline!String => Unit!:
\begin{lstlisting}
def logWith(prefix: String): (String => Unit) = {
    message => println(s"$prefix: $message")
}
\end{lstlisting}
The body of \lstinline!logWith! consists of a nameless function \lstinline!message => println(...)!,
which is a value of type \lstinline!String => Unit!. This value will
be returned when we evaluate \lstinline!logWith("...")!.

We can now use \lstinline!logWith! to create some logger functions:
\begin{lstlisting}
scala> val info = logWith("INFO")
info: String => Unit = <function1>

scala> val warn = logWith("WARN")
warn: String => Unit = <function1>
\end{lstlisting}
The created loggers are then usable as ordinary functions:
\begin{lstlisting}
scala> info("hello")
INFO: hello

scala> warn("goodbye")
WARN: goodbye
\end{lstlisting}
The values \lstinline!info! and \lstinline!warn! can be used by
any code that needs a logging function.

It is important that the prefix is \textsf{``}baked into\textsf{''} functions created
by \lstinline!logWith!. A logger such as \lstinline!warn! will always
print messages with the prefix \lstinline!"WARN"!, and the prefix
cannot be changed any more. This is because the value \lstinline!prefix!
is treated as a local constant within the body of the nameless function
computed and returned by \lstinline!logWith!. For instance, the body
of the function \lstinline!warn! is equivalent to:
\begin{lstlisting}
{ val prefix = "WARN"; (message => s"$prefix: $message") }
\end{lstlisting}
Whenever a new function is created using \lstinline!logWith(prefix)!,
the (immutable) reference to \lstinline!prefix! is stored within
the body of the newly created function. This is a general feature
of nameless functions: the function\textsf{'}s body captures references to
all the outer-scope values it uses. One sometimes says that the function\textsf{'}s
body \textsf{``}closes over\textsf{''} those values; for this reason, nameless functions
are also called \textsf{``}\textbf{\index{closure}closures}\textsf{''}. 

However, nameless functions do not \emph{copy} values from outer scopes.
Those values are captured by reference. This distinction is important
in Scala as it supports mutable values (as well as classes that encapsulate
mutable values).

Here is an example of a function body capturing references to variables:
\begin{lstlisting}
var c: Int = 10  // Mutable variable!
val f: Int => Int = {
  val p = 10
  val q = 20
  x => p + q * x + c
}
\end{lstlisting}
The body of the function \lstinline!f! is equivalent to \lstinline!{ x => 10 + 20 * x + c }!.
The values \lstinline!p = 10! and \lstinline!q = 20! are local constants
captured in the function\textsf{'}s body. However, the value \lstinline!c!
is captured by reference. If we change \lstinline!c!, the behavior
of \lstinline!f! will also change:
\begin{lstlisting}
scala> f(10)
res0: Int = 220

scala> c = 1000
c: Int = 1000

scala> f(10)
res1: Int = 1210 
\end{lstlisting}
A captured reference to a mutable external variable \lstinline!c!
makes the function \lstinline!f! itself mutable, even though \lstinline!f!
was defined as a \lstinline!val!. We will avoid such code in this
book and instead use immutable values.

\subsection{Curried and uncurried functions}

Reasoning mathematically about the following code:
\begin{lstlisting}
val info = logWith("INFO")
info("hello")
\end{lstlisting}
we would expect that \lstinline!info! is \emph{the same value} as
\lstinline!logWith("INFO")!, and so the code \lstinline!info("hello")!
should have the same effect as the code \lstinline!logWith("INFO")("hello")!.
This is indeed so:
\begin{lstlisting}
scala> logWith("INFO")("hello")
INFO: hello
\end{lstlisting}
The syntax \lstinline!logWith("INFO")("hello")! looks like the function
\lstinline!logWith! applied to \emph{two} arguments. Yet, \lstinline!logWith!
was defined as a function with a single argument of type \lstinline!String!.
This is not a contradiction because \lstinline!logWith("INFO")! returns
a function that accepts an additional argument. So, expressions \lstinline!logWith("INFO")!
and \lstinline!logWith("INFO")("hello")! are both valid. In this
sense, we are allowed to apply \lstinline!logWith! to one argument
at a time.

A function that can be applied to arguments in this way is called
a \index{curried function}\textbf{curried} function. 

While a curried function can be applied to one argument at a time,
an \textbf{uncurried}\index{uncurried function} function must be
applied to all arguments at once, e.g.:
\begin{lstlisting}
def prefixLog(prefix: String, message: String): Unit = println(s"$prefix: $message")
\end{lstlisting}

The type of the curried function \lstinline!logWith! is \lstinline!String => (String => Unit)!.
By Scala\textsf{'}s syntax conventions, the function arrow (\lstinline!=>!)
groups to the \emph{right}. So, the parentheses in the type expression
\lstinline!String => (String => Unit)! are not needed. The function\textsf{'}s
type can be written as \lstinline!String => String => Unit!.

The type \lstinline!String => String => Unit! is different from \lstinline!(String => String) => Unit!,
which is the type of a function returning \lstinline!Unit! and having
a single argument of type \lstinline!String => String!. 

When an argument\textsf{'}s type is a function type, e.g., \lstinline!String => String!,
it \emph{must} be enclosed in parentheses, as in \lstinline!(String => String) => Unit!.

In general, a curried function takes an argument and returns another
function that again takes an argument and returns another function,
and so on, until finally a non-function type is returned. So, the
type signature of a curried function generally looks like \lstinline!A => B => C => ... => R => S!,
where \lstinline!A!, \lstinline!B!, ..., \lstinline!R! are the
\textbf{curried arguments}\index{curried arguments} and \lstinline!S!
is the \textsf{``}final\textsf{''} result type.

For example, in the type expression \lstinline!A => B => C => D!
the types \lstinline!A!, \lstinline!B!, \lstinline!C! are the types
of curried arguments, and \lstinline!D! is the final result type.
It takes time to get used to reading this kind of syntax.

In Scala, functions defined with multiple argument lists (enclosed
in multiple pairs of parentheses) are curried functions. We have seen
examples of curried functions before:
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
def fmap[A, B](f: A => B)(xs: Option[A]): Option[B]
def foldLeft[A, R](xs: Seq[A])(init: R)(update: (R, A) => R): R
\end{lstlisting}
The type signatures of these functions can be also written equivalently
without argument names, although this is less convenient in practical
coding:
\begin{lstlisting}
def map[A, B]: Seq[A] => (A => B) => Seq[B]
def fmap[A, B]: (A => B) => Option[A] => Option[B]
def foldLeft[A, R]: Seq[A] => R => ((R, A) => R) => R
\end{lstlisting}
Curried arguments of a \emph{function type}, such as \lstinline!(A => B)!,
need parentheses.

To summarize, a curried function such as \lstinline!logWith! can
be defined in three equivalent ways in Scala:
\begin{lstlisting}[numbers=left]
def logWith1(prefix: String)(message: String): Unit = println(s"$prefix: $message")
def logWith2(prefix: String): String => Unit = { message => println(s"$prefix: $message") }
def logWith3: String => String => Unit = { prefix => message => println(s"$prefix: $message") }
\end{lstlisting}
For clarity, we will sometimes enclose nameless functions in parentheses
or curly braces. 

Line 3 above shows that the arrow symbols \lstinline!=>! group to
the right within the \emph{code} of nameless functions. So, \lstinline!x => y => expr!
means \lstinline!{x => {y => expr}}!, a nameless function taking
an argument \lstinline!x! and returning a nameless function that
takes an argument \lstinline!y! and returns an expression \lstinline!expr!.
This syntax convention is helpful since the code \lstinline!x => y => z!
visually corresponds to the curried function\textsf{'}s type signature \lstinline!A => B => C!,
which uses the same syntax convention. Also, the syntax \lstinline!(x => y) => z!
could not possibly work for a nameless function because  matching
a function against the pattern \lstinline!x => y! makes no sense.
If we matched a function such as \lstinline!{ t => t + 20 }! against
the pattern \lstinline!x => y! by setting \lstinline!x = t! and
\lstinline!y = t + 20!, we would have no value for the bound variable
\lstinline!t!. (What would be the integer value of \lstinline!y!?)
So, \lstinline!x => (y => z)! is the only sensible way of adding
parentheses to \lstinline!x => y => z!.

Although the code \lstinline!(x => y) => z! is invalid, the type
expression \lstinline!(A => B) => C! is valid. We may write a nameless
function of type \lstinline!(A => B) => C! as \lstinline!f => expr!
where \lstinline!f: A => B! is the argument and \lstinline!expr!
the body.

\subsection{Equivalence of curried and uncurried functions}

We defined the curried function \lstinline!logWith! in order to be
able to create logger functions such as \lstinline!info! and \lstinline!warn!.
However, some curried functions, such as \lstinline!foldLeft!, are
almost always applied to all possible arguments. A curried function
applied to all its possible arguments is equivalent to an uncurried
function that takes all those arguments at once. Let us look at this
equivalence in more detail.

Consider a curried function with type signature \lstinline!Int => Int => Int!.
This function takes an integer and returns an (uncurried) function
taking an integer and returning an integer. An example of such a curried
function is:
\begin{lstlisting}
def f1(x: Int): Int => Int = { y => x - y }
\end{lstlisting}

The function takes an integer \lstinline!x! and returns the expression
\lstinline!y => x - y!, which is a function of type \lstinline!Int => Int!.
The code of \lstinline!f1! can be written equivalently as:
\begin{lstlisting}
val f1: Int => Int => Int = { x => y => x - y }
\end{lstlisting}
Let us rewrite \lstinline!f1! as a function that takes its two arguments
at once:
\begin{lstlisting}
def f2(x: Int, y: Int): Int = x - y
\end{lstlisting}
The function \lstinline!f2! has type signature \lstinline!(Int, Int) => Int!.
Calling \lstinline!f1! and \lstinline!f2! requires different syntax:
\begin{lstlisting}
scala> f1(20)(4)
res0: Int = 16

scala> f2(20, 4)
res1: Int = 16
\end{lstlisting}
The main difference is that \lstinline!f2! must be applied at once
to both arguments, while \lstinline!f1! could be applied to just
the first argument (\lstinline!20!). Applying a curried function
to some but not all possible arguments is called a \textbf{\index{partial application}partial
application}. The result of evaluating \lstinline!f1(20)! is a function
that can be later applied to another argument:
\begin{lstlisting}
scala> val r1 = f1(20)
r1: Int => Int = <function1> 

scala> r1(4)
res2: Int = 16
\end{lstlisting}

Applying a curried function to all possible arguments is called a
\index{curried function!full application}\textbf{full} application.
A full application returns a value that is not of a function type.
So, it cannot be applied to more arguments.

To partially apply an \emph{uncurried} function, we can use the underscore
($\_$) symbol:
\begin{lstlisting}[numbers=left]
scala> val r2: Int => Int = f2(20, _)
r2: Int => Int = <function1>

scala> r2(4)
res3: Int = 16
\end{lstlisting}
(The type annotation \lstinline!Int => Int! is required in line 1.)
This code creates a function \lstinline!r2! by applying \lstinline!f2!
to the first argument but not to the second. Then \lstinline!r2!
is the same function as \lstinline!r1! defined above; i.e., \lstinline!r2!
returns the same values for the same arguments as \lstinline!r1!.
A more verbose syntax for a partial application is:
\begin{lstlisting}
scala> val r3: Int => Int = { x => f2(20, x) }  // Same as r2 above.
r3: Int => Int = <function1>

scala> r3(4)
res4: Int = 16
\end{lstlisting}

We can see that a curried function, such as \lstinline!f1!, is better
adapted for partial application than \lstinline!f2!, because the
syntax is shorter. However, the \emph{types} of functions \lstinline!f1!
and \lstinline!f2! are\textbf{ equivalent}\index{type equivalence}:
for any \lstinline!f1! of type \lstinline!Int => Int => Int! we
can reconstruct \lstinline!f2! of type \lstinline!(Int, Int) => Int!
and vice versa, without loss of information:
\begin{lstlisting}
def f2new(x: Int, y: Int): Int = f1(x)(y)             // f2new is equal to f2
def f1new: Int => Int => Int = { x => y => f2(x, y) } // f1new is equal to f1
\end{lstlisting}
It is clear that the function \lstinline!f1new! computes the same
results as \lstinline!f1!, and that the function \lstinline!f2new!
computes the same results as \lstinline!f2!. The equivalence of the
functions \lstinline!f1! and \lstinline!f2! is not \emph{equality}
 \textemdash{} these functions are \emph{different}; but each of them
can be reconstructed from the other. The one-to-one correspondence
between all functions of type \lstinline!Int => Int => Int! and all
functions of type \lstinline!(Int, Int) => Int! is what we call the
\textsf{``}equivalence of types\textsf{''}.

More generally, a curried function has a type signature of the form
\lstinline!A => B => C => ... => R => S!, where \lstinline!A!, \lstinline!B!,
\lstinline!C!, ..., \lstinline!S! are some types. A function with
this type signature is equivalent to an uncurried\index{uncurried function}
function with type signature \lstinline!(A,B,C,...,R) => S!. The
uncurried function takes all arguments at once, while the curried
function takes one argument at a time. Other than that, these two
functions compute the same results given the same arguments.

We have seen how a curried function can be converted to an equivalent
uncurried one, and vice versa. The Scala library defines the methods
\lstinline!curried! and \lstinline!uncurried! that convert between
these forms of functions. To convert between \lstinline!f2! and \lstinline!f1!:
\begin{lstlisting}
scala> val f1c = (f2 _).curried
f1c: Int => (Int => Int) = <function1>

scala> val f2u = Function.uncurried(f1c)
f2u: (Int, Int) => Int = <function2> 
\end{lstlisting}
The syntax \lstinline!(f2 _)! is needed in Scala to convert methods
to function values. Recall that Scala has two ways of defining a function:
one as a method\index{Scala method} (defined using \lstinline!def!),
another as a function value\index{function as a value} (defined using
\lstinline!val!). The extra underscore is unnecessary in Scala 3.

The methods \lstinline!curried! and \lstinline!uncurried! are quick
to implement (see Section~\ref{subsec:Examples-of-fully-parametric}
below). These functions are called the \textbf{currying}\index{currying}
and \textbf{uncurrying}\index{uncurrying} transformations.

\section{Fully parametric functions\label{sec:Fully-parametric-functions}}

Scala code may declare functions with type parameters, which are set
only when the function is applied to specific arguments. Examples
of such functions are \lstinline!map! and \lstinline!filter!, written
as:
\begin{lstlisting}
def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
def filter[A](xs: Seq[A])(p: A => Boolean): Seq[A]
\end{lstlisting}
Such functions can be applied to arguments of different types without
changing the function\textsf{'}s code. It is better to write a single function
with type parameters instead of writing several functions with repeated
code but working with different types.

When we apply the function \lstinline!map! as \lstinline!map(xs)(f)!
to a specific value \lstinline!xs! of type, say, \lstinline!Seq[Int]!,
and a specific function \lstinline!f! of type, say, \lstinline!Int => String!,
the Scala compiler will automatically set the type parameters \lstinline!A = Int!
and \lstinline!B = String! in the code of \lstinline!map!. We may
also set type parameters explicitly and write, for example, \lstinline!map[Int, String](xs)(f)!.
This syntax shows a certain similarity between type parameters such
as \lstinline!Int!, \lstinline!String! and \textsf{``}value parameters\textsf{''}
(arguments) \lstinline!xs! and \lstinline!f!. Setting type parameters,
e.g., \lstinline!map[Int, String]!, means substituting \lstinline!A = Int!,
\lstinline!B = String! into the type signature of the function, similarly
to how setting value parameters means substituting specific values
into the function body.

In the functions \lstinline!map! and \lstinline!filter! as just
shown, some types are parameters while others are specific types,
such as \lstinline!Seq! and \lstinline!Boolean!. It is sometimes
possible to replace \emph{all} specific types in the type signature
of a function by type parameters. The result is a \textsf{``}fully parametric\textsf{''}
function.

We call a function \textbf{fully parametric}\index{fully parametric!function|textit}
if its arguments have types described by type parameters, and the
code of the function does not use any information about its argument
types, other than assuming that those types correctly match the type
signature. In addition to type parameters, a fully parametric function
may use the \lstinline!Unit! type, tuple types, disjunctive types,
and function types. Fully parametric functions may not use any library-defined
types such as \lstinline!Int! or \lstinline!String!.

What kind of functions are fully parametric? To build up intuition,
let us compare the following two functions that have the same type
signature:
\begin{lstlisting}
def cos_sin(p: (Double, Double)): (Double, Double) = p match {
  case (x, y) =>
    val r = math.sqrt(x * x + y * y)
    (x / r, y / r)   // Return cos and sin of the angle, or `NaN` when undefined.
}

def swap(p: (Double, Double)): (Double, Double) = p match {
  case (x, y) => (y, x)
}
\end{lstlisting}
We can introduce type parameters into the type signature of \lstinline!swap!
to make it fully parametric:
\begin{lstlisting}
def swap[A, B](p: (A, B)): (B, A) = p match {
  case (x, y) => (y, x)
}
\end{lstlisting}
Converting \lstinline!swap! into a fully parametric function is possible
because the operation of swapping the parts of a tuple \lstinline!(A, B)!
works in the same way for all types \lstinline!A!, \lstinline!B!.
No changes were made in the body of the function. The specialized
version of \lstinline!swap! working on \lstinline!(Double, Double)!
can be obtained from the fully parametric version of \lstinline!swap!
if we set the type parameters as \lstinline!A = Double!, \lstinline!B = Double!.

In contrast, the function \lstinline!cos_sin! performs a computation
that is specific to the type \lstinline!Double!. That computation
cannot be generalized to an arbitrary type parameter \lstinline!A!
instead of the type \lstinline!Double!. For instance, the code of
\lstinline!cos_sin! uses the function \lstinline!math.sqrt!, which
is defined only for the type \lstinline!Double!. 

To generalize \lstinline!cos_sin! to a fully parametric function
that works with a type parameter \lstinline!A!, we would need to
replace all computations specific to the type \lstinline!Double!
by new arguments working with the type parameter \lstinline!A!. For
example, we could introduce two new arguments (named, say, \lstinline!distance!
and \lstinline!ratio!) and replace \lstinline!cos_sin! by the fully
parametric function \lstinline!cos_sin_parametric!:
\begin{lstlisting}
def cos_sin_parametric[A](p: (A, A), distance: (A, A) => A, ratio: (A, A) => A): (A, A) = p match {
  case (x, y) =>
    val r = distance(x, y)
    (ratio(x, r), ratio(y, r))
}
\end{lstlisting}

A fully parametric function has all its arguments typed with type
parameters or with some combinations of type parameters, i.e., \textbf{type
expressions}\index{type expression} such as \lstinline!(A, B)! or
\lstinline!X => Either[X, Y]!.

The \lstinline!swap! operation for pairs is already defined in the
Scala library:
\begin{lstlisting}
scala> (1, "abc").swap
res0: (String, Int) = (abc,1)
\end{lstlisting}
If needed, other swapping functions can be implemented for tuples
with more elements, e.g.:
\begin{lstlisting}
def swapAC[A, B, C]: ((A, B, C)) => (C, B, A) = { case (x, y, z) => (z, y, x) }
\end{lstlisting}
The Scala syntax requires \emph{double} parentheses around tuple types\index{tuples!as function arguments}
of arguments but not around the tuple type of a function\textsf{'}s result.
So, the function \lstinline!cos_sin! may be written as a value like
this:
\begin{lstlisting}
val cos_sin: ((Double, Double)) => (Double, Double) = ...
\end{lstlisting}

Further examples of fully parametric functions are the identity function,
the \lstinline!const! function, the function composition methods,
and the currying / uncurrying transformations. 

The \index{identity function}identity function is available in the
Scala library as \lstinline!identity[T]!:
\begin{lstlisting}
def identity[T]: T => T = (t => t)
\end{lstlisting}
In the mathematical notation, we write the identity function as \textsf{``}$\text{id}$\textsf{''}
for brevity.

The function available in the Scala library as \lstinline!Function.const[C, X]!
takes an argument \lstinline!c! of type \lstinline!C! and returns
\emph{a new function} that always returns \lstinline!c!:
\begin{lstlisting}
def const[C, X](c: C): X => C = (_ => c)
\end{lstlisting}
The syntax \lstinline!_ => c! is used to emphasize that the new returned
function ignores its argument. One-argument functions that ignore
their argument are called \textbf{constant functions}.\index{constant function}

\subsection{Function composition\label{subsec:Examples-of-fully-parametric}}

\index{function composition}Consider two functions \lstinline!f: Int => Double!
and \lstinline!g: Double => String!. We can apply \lstinline!f!
to an integer argument \lstinline!x! and get a result \lstinline!f(x)!
of type \lstinline!Double!. Applying \lstinline!g! to that result
gives a \lstinline!String! value \lstinline!g(f(x))!. The transformation
from an \lstinline!x! of type \lstinline!Int! to a final \lstinline!String!
value \lstinline!g(f(x))! can be viewed as a new function of type
\lstinline!Int => String!. That new function is called the \textbf{forward
composition}\index{forward composition} of the two functions \lstinline!f!
and \lstinline!g!. In Scala, the forward composition of \lstinline!f!
and \lstinline!g! is written as \lstinline!f andThen g!:
\begin{lstlisting}
val f: Int => Double = (x => 5.67 + x)
val g: Double => String = (x => f"Result x = $x%3.2f")

scala> val h = f andThen g       // h(x) is defined as g(f(x)).
h: Int => String = <function1>

scala> h(40)
res36: String = Result x = 45.67
\end{lstlisting}
The Scala compiler derives the type of \lstinline!h! automatically
as \lstinline!Int => String!.

This book denotes the forward composition by the symbol ${\displaystyle \bef}$
(which can be read as \textsf{``}before\textsf{''}). We define $f\bef g$ (reads \textsf{``}$f$
before $g$\textsf{''}) by:
\begin{equation}
f\bef g\triangleq x\rightarrow g(f(x))\quad.\label{eq:def-of-forward-composition}
\end{equation}
The symbol $\triangleq$ means \textsf{``}is defined as\textsf{''} or \textsf{``}is equal
by definition to\textsf{''}.

We may implement the forward composition as a fully parametric function:
\begin{lstlisting}
def andThen[X, Y, Z](f: X => Y)(g: Y => Z): X => Z = { x => g(f(x)) }
\end{lstlisting}
This type signature requires the types of the function arguments to
match in a certain way, or else the composition is undefined (and
the code would produce a type error). The method \lstinline!andThen!
is an example of a function that \emph{both} returns a new function
\emph{and} takes other functions as arguments.

The \textbf{backward composition}\index{backward composition} of
two functions $f$ and $g$ works in the opposite order: first $g$
is applied and then $f$. This operation is denoted by the symbol
$\circ$ (pronounced \textsf{``}after\textsf{''}):
\begin{equation}
f\circ g\triangleq x\rightarrow f(g(x))\quad.\label{eq:def-of-backward-composition}
\end{equation}
In Scala, the backward composition is called \lstinline!compose!
and used as \lstinline!f compose g!. This method may be implemented
as a fully parametric function:
\begin{lstlisting}
def compose[X, Y, Z](f: Y => X)(g: Z => Y): Z => X = { z => f(g(z)) }
\end{lstlisting}

We have already seen the methods \lstinline!curried! and \lstinline!uncurried!
from the Scala library. As an illustration, here is the code for the
\textbf{uncurrying}\index{uncurrying} transformation (converting
curried functions to uncurried):
\begin{lstlisting}
def uncurry[A, B, R](f: A => B => R): ((A, B)) => R = { case (a, b) => f(a)(b) }
\end{lstlisting}

These examples show that fully parametric functions perform operations
so general that they work in the same way for all types. Some arguments
of fully parametric functions may have complicated types such as \lstinline!A => B => R!,
which are type expressions built up from type parameters. But fully
parametric functions do not use values of specific types such as \lstinline!Int!
or \lstinline!String!.

Functions with type parameters are often called \textsf{``}generic\index{generic functions}\textsf{''}.
This book uses the term \textsf{``}\index{fully parametric!function}\textbf{fully
parametric}\textsf{''} to designate a certain restricted kind of generic functions.

\subsection{Laws of function composition\label{subsec:Laws-of-function-composition}}

The operations of function composition, introduced in Section~\ref{subsec:Examples-of-fully-parametric},
have three important properties or \textsf{``}laws\textsf{''}:
\begin{itemize}
\item The two \textbf{identity laws}\index{identity laws!of function composition}:
the composition of any function $f$ with an identity function (\lstinline!identity[A]!)
will give again the function $f$.
\item The \textbf{associativity law}\index{associativity law!of function composition}:
the consecutive composition of three functions $f$, $g$, $h$ does
not depend on the order in which the pairs are composed.
\end{itemize}
These laws hold equally for the forward and the backward composition,
since those are just syntactic variants of the same operation. Let
us write these laws rigorously as equations and prove them.

\paragraph{Proofs with forward composition}

The composition of the identity function with an arbitrary function
$f$ on the left is written as $f\bef\text{id}$. The composition
with the function $f$ on the right is written as $\text{id}\bef f$.
In both cases, the result must be equal to the function $f$. The
resulting two laws are:
\begin{align*}
{\color{greenunder}\text{left identity law of function composition}:}\quad & \text{id}\bef f=f\quad,\\
{\color{greenunder}\text{right identity law of function composition}:}\quad & f\bef\text{id}=f\quad.
\end{align*}
To prove that these laws hold, we need to show that the functions
at both sides of the laws  give the same result when applied to an
arbitrary value $x$. Let us first clarify how the type parameters
must be set for all types to match consistently.

The laws must hold for an arbitrary function $f$. Assume that $f$
has the type signature $A\rightarrow B$, where $A$ and $B$ are
arbitrary types (type parameters). Consider the left identity law.
The function $(\text{id}\bef f)$ is, by definition~(\ref{eq:def-of-forward-composition}),
a function that takes an argument $x$, applies $\text{id}$ to that
$x$, and then applies $f$ to the result: 
\[
\text{id}\bef f=\left(x\rightarrow f\left(\text{id}\,(x)\right)\right)\quad.
\]
If $f$ has type $A\rightarrow B$, its argument must be of type $A$,
or else the types will not match. Therefore, the identity function
must have type $A\rightarrow A$, and the argument $x$ must have
type $A$. With these choices of the type parameters, the function
$\left(x\rightarrow f(\text{id}(x))\right)$ will have type $A\rightarrow B$.
This type matches the right-hand side of the law, which is just $f$.
We add type annotations to the code as \emph{superscripts}:
\[
\text{id}^{:A\rightarrow A}\bef f^{:A\rightarrow B}=\big(x^{:A}\rightarrow f\left(\text{id}\,(x)\right)\big)^{:A\rightarrow B}\quad.
\]
In the Scala syntax, this formula may be written as:
\begin{lstlisting}
identity[A] andThen (f: A => B) == { x: A => f(identity(x)) }: A => B
\end{lstlisting}

We will follow the convention where type parameters are single uppercase
letters, as is common in Scala code (although this convention is not
enforced by the Scala compiler). The colon symbol ($:$) in the superscript
$x^{:A}$ means a type annotation, as in Scala code \lstinline!x:A!.
Superscripts \emph{without} a colon, such as $\text{id}^{A}$, denote
type parameters, as in Scala code \lstinline!identity[A]!. Since
the function \lstinline!identity[A]! has type \lstinline!A => A!,
we can write $\text{id}^{A}$ or equivalently (but more verbosely)
$\text{id}^{:A\rightarrow A}$ to denote that function.

Now we can prove the law. By definition of the identity function,
we have $\text{id}\,(x)=x$, and so:
\[
\text{id}\bef f=\left(x\rightarrow f(\text{id}\,(x))\right)=\left(x\rightarrow f(x)\right)=f\quad.
\]
The last step works since $x\rightarrow f(x)$ is a function that
takes an argument $x$ and applies $f$ to that argument. This is
the same function as $f$. We say that $x\rightarrow f(x)$ is an
\textbf{expanded form}\index{expanded form of a function} of the
function $f$.

We turn to the right identity law, $f\bef\text{id}=f$. Write out
the left-hand side:
\[
f\bef\text{id}=\left(x\rightarrow\text{id}\,(f(x))\right)\quad.
\]
To check that the types match, assume that $f^{:A\rightarrow B}$.
Then $x$ must have type $A$, and the identity function must have
type $B\rightarrow B$. The result of $\text{id}\,(f(x))$ will also
have type $B$. With these choices of type parameters, all types match:
\[
f^{:A\rightarrow B}\bef\text{id}^{:B\rightarrow B}=\big(x^{:A}\rightarrow\text{id}\,(f(x))\big)^{:A\rightarrow B}\quad.
\]
Since $\text{id}\,(f(x))=f(x)$, we find:
\[
f\bef\text{id}=\left(x\rightarrow f(x)\right)=f\quad.
\]
In this way, we have demonstrated that both identity laws hold. 

The associativity law is written as an equation like this:
\begin{align}
{\color{greenunder}\text{associativity law of function composition}:}\quad & (f\bef g)\bef h=f\bef(g\bef h)\quad.\label{eq:associativity-of-function-composition}
\end{align}
Let us verify that the types match here. The types of the functions
$f$, $g$, and $h$ must be such that all the function compositions
match. If $f$ has type $A\rightarrow B$ for some type parameters
$A$ and $B$, then the argument of $g$ must be of type $B$. So,
we must have $g^{:B\rightarrow C}$, where $C$ is another type parameter.
The composition $f\bef g$ has type $A\rightarrow C$, so $h$ must
have type $C\rightarrow D$ for some type $D$. Assuming the types
as $f^{:A\rightarrow B}$, $g^{:B\rightarrow C}$, and $h^{:C\rightarrow D}$,
we find that the types in all the compositions $f\bef g$, $g\bef h$,
$(f\bef g)\bef h$, and $f\bef(g\bef h)$ match. We can rewrite Eq.~(\ref{eq:associativity-of-function-composition})
with type annotations: 
\begin{equation}
(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\bef h^{:C\rightarrow D}=f^{:A\rightarrow B}\bef(g^{:B\rightarrow C}\bef h^{:C\rightarrow D})\quad.\label{eq:associativity-law-for-function-composition-with-types}
\end{equation}

After checking the types, we are ready to verify the associativity
law. Note that both sides of the law~(\ref{eq:associativity-law-for-function-composition-with-types})
are functions of type $A\rightarrow D$. To prove that two functions
are equal means to prove that they return the same results when applied
to the same arguments. So, let us apply both sides of Eq.~(\ref{eq:associativity-law-for-function-composition-with-types})
to an arbitrary value $x^{:A}$. Using definition~(\ref{eq:def-of-forward-composition})
for the forward composition, we find:
\begin{align*}
\left((f\bef g)\bef h\right)(x) & =h\left(\left(f\bef g\right)(x)\right)=h(g(f(x)))\quad,\\
\left(f\bef(g\bef h)\right)(x) & =\left(g\bef h\right)(f(x))=h(g(f(x)))\quad.
\end{align*}
Both sides of the law are equal when applied to an arbitrary value
$x$. This concludes the proof.

Because of the associativity law, we do not need parentheses when
writing the expression $f\bef g\bef h$. The function $(f\bef g)\bef h$
is equal to the function $f\bef(g\bef h)$.

In the proof, we have omitted the type annotations since we already
checked that all types match. Checking the types beforehand allows
us to write shorter derivations.

\paragraph{Proofs with backward composition}

This book prefers to use the \textbf{forward composition}\index{forward composition}
$f\bef g$ rather than the backward\index{backward composition} composition
$g\circ f$. If desired, all equations can be converted from one notation
to the other by reversing the order of compositions:
\[
f\bef g\triangleq g\circ f
\]
for any functions $f^{:A\rightarrow B}$ and $g^{:B\rightarrow C}$.
Let us see how to prove the composition laws in the backward notation.
We will just need to reverse the order of function compositions in
the proofs above.

The left identity and right identity laws are:
\[
f\circ\text{id}=f\quad\quad,\quad\text{id}\circ f=f\quad.
\]
To match the types, we need to choose the type parameters as:
\[
f^{:A\rightarrow B}\circ\text{id}^{:A\rightarrow A}=f^{:A\rightarrow B}\quad\quad,\quad\text{id}^{B\rightarrow B}\circ f^{:A\rightarrow B}=f^{:A\rightarrow B}\quad.
\]
We now apply both sides of the laws to an arbitrary value $x^{:A}$.
For the left identity law, we find:
\begin{align*}
{\color{greenunder}\text{use definition~(\ref{eq:def-of-backward-composition})}:}\quad & f\circ\text{id}=\left(x\rightarrow f(\text{id}\,(x))\right)=\left(x\rightarrow f(x)\right)=f\quad.
\end{align*}
Similarly for the right identity law:
\[
\text{id}\circ f=\left(x\rightarrow\text{id}\,(f(x))\right)=\left(x\rightarrow f\left(x\right)\right)=f\quad.
\]
The associativity law,
\[
h\circ\left(g\circ f\right)=\left(h\circ g\right)\circ f\quad,
\]
is proved by applying both sides to an arbitrary value $x$ of a suitable
type:
\begin{align*}
\left(h\circ\left(g\circ f\right)\right)(x) & =h\left(\left(g\circ f\right)(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad,\\
\left(\left(h\circ g\right)\circ f\right)(x) & =\left(h\circ g\right)\left(f(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad.
\end{align*}
The types are checked by assuming that $f$ has the type $f^{:A\rightarrow B}$.
The types in $g\circ f$ match only when $g^{:B\rightarrow C}$, and
then $g\circ f$ is of type $A\rightarrow C$. The type of $h$ must
be $h^{:C\rightarrow D}$ for the types in $h\circ\left(g\circ f\right)$
to match. We can write the associativity law with type annotations
as:
\begin{equation}
h^{:C\rightarrow D}\circ(g^{:B\rightarrow C}\circ f^{:A\rightarrow B})=(h^{:C\rightarrow D}\circ g^{:B\rightarrow C})\circ f^{:A\rightarrow B}\quad.\label{eq:assoc-law-for-composition-with-types-backward}
\end{equation}
The associativity law allows us to omit parentheses in the expression
$h\circ g\circ f$. 

The length of calculations is the same in the forward and the backward
notation. One difference is that types of function compositions are
more visually clear in the forward notation: it is harder to check
that types match in Eq.~(\ref{eq:assoc-law-for-composition-with-types-backward})
than in Eq.~(\ref{eq:associativity-law-for-function-composition-with-types}).
To make the backward notation easier to work with, one could write\footnote{This is done in the book \textsf{``}Program design by calculation\textsf{''} by J.~N.~Oliveira
where the backward composition is used exclusively, see \texttt{\href{http://www4.di.uminho.pt/~jno/ps/pdbc.pdf}{http://www4.di.uminho.pt/$\sim$jno/ps/pdbc.pdf}}} the function types in reverse as, e.g., $g^{:C\leftarrow B}\circ f^{:B\leftarrow A}$.

\subsection{Example: A function that is \emph{not} fully parametric}

Fully parametric functions do not make any decisions based on the
actual types of arguments. As an example of code that is \emph{not}
fully parametric, consider the following \textsf{``}fake identity\textsf{''} function:
\begin{lstlisting}
def fid[A]: A => A = {
  case x: Int   => (x - 1).asInstanceOf[A]     // Special code for A = Int.
  case x        =>  x                          // Standard code for all other types A.
}
\end{lstlisting}
This function\textsf{'}s type signature is the same as that of \lstinline!identity[A]!,
and its behavior is the same for all types \lstinline!A! except for
\lstinline!A = Int!:
\begin{lstlisting}
scala> fid("abc")
res0: String = abc

scala> fid(true)
res1: Boolean = true

scala> fid(0)
res2: Int = -1
\end{lstlisting}
While Scala allows us to write this kind of code, the result is confusing:
the type signature \lstinline!A => A! does not indicate a special
behavior with \lstinline!A = Int!. In any case, \lstinline!fid!
is not a fully parametric function.

Let us see whether the identity laws of function composition hold
when using \lstinline!fid[A]! instead of the correct function \lstinline!identity[A]!.
To see that, we compose \lstinline!fid! with a simple function \lstinline!f_1!
defined by:
\begin{lstlisting}
def f_1: Int => Int = { x => x + 1 }
\end{lstlisting}
The composition (\lstinline!f_1 andThen fid!) has type \lstinline!Int => Int!.
Since \lstinline!f_1! has type \lstinline!Int => Int!, Scala will
automatically set the type parameter \lstinline!A = Int! in \lstinline!fid[A]!:
\begin{lstlisting}[mathescape=true]
scala> def f_2 = f_1 andThen fid    // $\color{dkgreen} f_{2}=f_{1}\bef\text{fid}$
f_2: Int => Int
\end{lstlisting}
By the identity law, we should have $f_{2}=f_{1}\bef\text{id}=f_{1}$.
But we can check that \lstinline!f_1! and \lstinline!f_2! are not
equal:
\begin{lstlisting}
scala> f_1(0)
res3: Int = 1

scala> f_2(0)
res4: Int = 0
\end{lstlisting}

It is important that we are able to detect that \lstinline!fid! is
not a fully parametric function by checking whether some equation
holds, without looking at the code of \lstinline!fid!. In this book,
we will always formulate any desired properties through equations
or \textsf{``}laws\textsf{''}. To verify that a law holds, we will perform symbolic
calculations\index{symbolic calculations} similar to the proofs in
Section~\ref{subsec:Laws-of-function-composition}. These calculations
are \textbf{symbolic} in the sense that we are manipulating symbols
(such as $x$, $f$, $g$, $h$) without substituting any specific
values for these symbols but only using some general rules and properties.
This is similar to symbolic calculations in mathematics, such as $\left(x-y\right)(x^{2}+xy+y^{2})=x^{3}-y^{3}$.
In the next section, we will get more experience with symbolic calculations
relevant to functional programming.

\section{Symbolic calculations with nameless functions}

\subsection{Calculations with curried functions}

In mathematics, functions are evaluated by substituting their argument
values into their body. Each sub-expression is then evaluated and
its result substituted into the larger expression.

Nameless functions are evaluated in the same way. For example, applying
the nameless function $x\rightarrow x+10$ to an integer $2$, we
substitute $2$ instead of $x$ in \textquotedblleft $x+10$\textquotedblright{}
and get the sub-expression \textquotedblleft $2+10$\textquotedblright .
Then we evaluate that sub-expression to $12$. The computation is
written like this:
\[
(x\rightarrow x+10)(2)=2+10=12\quad.
\]
To run this computation in Scala, we need to add a type annotation
to the nameless function as in $(x^{:\text{Int}}\rightarrow x+10)(2)$.
The code is:
\begin{lstlisting}
scala> ((x: Int) => x + 10)(2)
res0: Int = 12 
\end{lstlisting}

Curried function calls such as $f(x)(y)$ or $\left(x\rightarrow\text{expr}(x)\right)(y)(z)$
may look unfamiliar and confusing. We need to get some experience
working with them.

Consider the expression \lstinline!(x => y => x - y)(20)(4)!, and
begin with the curried argument \lstinline!20!. Applying a nameless
function of the form \lstinline!(x => ...)! to \lstinline!20! means
substituting \lstinline!x = 20! into the body of the function. After
that substitution, we obtain the expression \lstinline!y => 20 - y!,
which is again a nameless function. Applying that function to the
remaining argument \lstinline!(4)! means substituting \lstinline!y = 4!
into the body of \lstinline!y => 20 - y!. We get the expression \lstinline!20 - 4!,
which equals \lstinline!16!. Test in Scala:
\begin{lstlisting}
scala> ((x: Int) => (y: Int) => x - y)(20)(4)
res1: Int = 16
\end{lstlisting}

Applying a curried function such as \lstinline!x => y => z => expr(x,y,z)!
to three curried arguments \lstinline!10!, \lstinline!20!, and \lstinline!30!
means substituting \lstinline!x = 10!, \lstinline!y = 20!, and \lstinline!z = 30!
into the expression \lstinline!expr(x,y,z)!. 

This calculation is made easier by the convention that \lstinline!f(g)(h)!
means first applying \lstinline!f! to \lstinline!g! and then applying
the result to \lstinline!h!. In other words, function application
groups to the \emph{left}: \lstinline!f(g)(h) = (f(g))(h)!. It would
be confusing if function application grouped to the right and \lstinline!f(g)(h)!
meant first applying \lstinline!g! to \lstinline!h! and then applying
\lstinline!f! to the result. If \emph{that} were the syntax convention,
it would be harder to reason about applying a curried function to
its arguments.

We see that the right grouping of the function arrow \lstinline!=>!
is well adapted to the left grouping of function applications. All
functional languages follow these syntactic conventions.

To make calculations shorter, we will write code in a mathematical
notation rather than in the Scala syntax. Type annotations are written
with a \emph{colon} in the superscript. For example, $x^{:\text{Int}}\rightarrow x+10$
is the code notation corresponding to the Scala expression \lstinline!(x: Int) => x + 10!.

The symbolic evaluation of the Scala code \lstinline!((x: Int) => (y: Int) => x - y)(20)(4)!
can be written as:
\begin{align*}
 & (\gunderline{x^{:\text{Int}}}\rightarrow y^{:\text{Int}}\rightarrow\gunderline x-y)\gunderline{\left(20\right)}\left(4\right)\\
{\color{greenunder}\text{apply function and substitute }x=20:}\quad & =(\gunderline{y^{:\text{Int}}}\rightarrow20-\gunderline y)\gunderline{\left(4\right)}\\
{\color{greenunder}\text{apply function and substitute }y=4:}\quad & =20-4=16\quad.
\end{align*}
In the above step-by-step calculation, the colored underlines and
comments at left are added for clarity. A colored underline indicates
a sub-expression that is going to be rewritten at the \emph{next}
step.

Here we performed calculations by substituting an argument into a
function at each step. A compiled Scala program is evaluated in a
similar way at run time.

Nameless functions are \emph{values} and can be used as part of larger
expressions, just as any other values. For instance, nameless functions
can be arguments of other functions (nameless or not). Here is an
example of applying a nameless function $f\rightarrow f(9)$ to the
nameless function $x\rightarrow x\%\,4$:
\begin{align*}
 & (f\rightarrow\gunderline f(9))\left(x\rightarrow x\%\,4\right)\\
{\color{greenunder}\text{substitute }f=\left(x\rightarrow x\%\,4\right):}\quad & =(x\rightarrow\gunderline x\%\,4)(9)\\
{\color{greenunder}\text{substitute }x=9:}\quad & =9\%\,4=1\quad.
\end{align*}
In the nameless function $f\rightarrow f(9)$, the argument $f$ has
to be itself a function, otherwise the expression $f(9)$ would make
no sense. The argument $x$ of $f(x)$ must be an integer, or else
we would not be able to compute $x\%\,4$. The result of computing
$f(9)$ is $1$, an integer. We conclude that $f$ must have type
$\text{Int}\rightarrow\text{Int}$, or else the types do not match.

To verify this result in Scala, we need to specify a type annotation
for $f$:
\begin{lstlisting}
scala> ((f: Int => Int) => f(9))(x => x % 4)
res2: Int = 1
\end{lstlisting}
No type annotation is needed for $x\rightarrow x\%\,4$ because the
Scala compiler already knows the type of $f$ and figures out that
$x$ in $x\rightarrow x\%\,4$ must have type \lstinline!Int!.

Let us summarize the syntax conventions for curried nameless functions:
\begin{itemize}
\item Function expressions group everything to the right: $x\rightarrow y\rightarrow z\rightarrow e$
means $x\rightarrow\left(y\rightarrow\left(z\rightarrow e\right)\right)$.
\item Function calls group everything to the left: $f(x)(y)(z)$ means $\big((f(x))(y)\big)(z)$.
The expression $f(x)$ is a new function that is applied to $y$,
giving again a new function that is finally applied to $z$.
\item Function applications group stronger than infix operations, so $f(x)+y$
means $(f(x))+y$, as usual in mathematics, and not $f(x+y)$.
\end{itemize}
Here are some more examples of performing function applications symbolically.
Types are omitted for brevity; every non-function value is of type
\texttt{}\lstinline!Int!:
\begin{align*}
\left(x\rightarrow x*2\right)(10) & =10*2=20\quad.\\
\left(p\rightarrow z\rightarrow z*p\right)\left(t\right) & =(z\rightarrow z*t)\quad.\\
\left(p\rightarrow z\rightarrow z*p\right)(t)(4) & =(z\rightarrow z*t)(4)=4*t\quad.
\end{align*}
Some results of these computation are integer values such as $20$;
other results are nameless functions such as $z\rightarrow z*t$.
Verify this in Scala:
\begin{lstlisting}
scala> ((x: Int) => x * 2)(10)
res3: Int = 20

scala> ((p: Int) => (z: Int) => z * p)(10)
res4: Int => Int = <function1>

scala> ((p: Int) => (z: Int) => z * p)(10)(4)
res5: Int = 40 
\end{lstlisting}

In the following examples, some arguments are themselves functions.
Consider an expression that uses the nameless function $\left(g\rightarrow g(2)\right)$
as an argument:
\begin{align}
 & (f\rightarrow p\rightarrow\gunderline f(p))\left(g\rightarrow g(2)\right)\label{eq:higher-order-functions-derivation0}\\
{\color{greenunder}\text{substitute }f=\left(g\rightarrow g(2)\right):}\quad & =p\rightarrow(g\rightarrow\gunderline g(2))\,(p)\nonumber \\
{\color{greenunder}\text{substitute }g=p:}\quad & =p\rightarrow p(2)\quad.\label{eq:higher-order-functions-derivation1}
\end{align}
The final result, $p\rightarrow p(2)$, cannot be simplified any more. 

The function $p\rightarrow p(2)$ applies \emph{its} argument ($p$)
to the value $2$. A possible value for $p$ is the function $x\rightarrow x+4$.
Let us apply expression~(\ref{eq:higher-order-functions-derivation0})
to $x\rightarrow x+4$:
\begin{align*}
 & \gunderline{\left(f\rightarrow p\rightarrow f(p)\right)\left(g\rightarrow g(2)\right)}\left(x\rightarrow x+4\right)\\
{\color{greenunder}\text{use Eq.~(\ref{eq:higher-order-functions-derivation1})}:}\quad & =(p\rightarrow\gunderline p(2))\left(x\rightarrow x+4\right)\\
{\color{greenunder}\text{substitute }p=\left(x\rightarrow x+4\right):}\quad & =(x\rightarrow\gunderline x+4)\left(2\right)\\
{\color{greenunder}\text{substitute }x=2:}\quad & =2+4=6\quad.
\end{align*}

To verify this calculation in Scala, we need to add appropriate type
annotations for $f$ and $p$. To figure out the types, we reason
like this:

We know that the function $f\rightarrow p\rightarrow f(p)$ is being
applied to the arguments $f=\left(g\rightarrow g(2)\right)$ and $p=\left(x\rightarrow x+4\right)$.
So, the argument $f$ in $f\rightarrow p\rightarrow f(p)$ must be
a function that takes $p$ as an argument.

The variable $x$ in $x\rightarrow x+4$ must be of type \lstinline!Int!.
So, the type of the expression $x\rightarrow x+4$ is $\text{Int}\rightarrow\text{Int}$,
and the type of the argument $p$ must be the same. We write $p^{:\text{Int}\rightarrow\text{Int}}$.

Finally, we need to make sure that the types match in the function
$f\rightarrow p\rightarrow f(p)$. Types match in $f(p)$ if the type
of $f$\textsf{'}s argument is the same as the type of $p$, which is $\text{Int}\rightarrow\text{Int}$.
So, $f$\textsf{'}s type must be $\left(\text{Int}\rightarrow\text{Int}\right)\rightarrow A$
for some type $A$. Since in our example $f=\left(g\rightarrow g(2)\right)$,
types match only if $g$ has type $\text{Int}\rightarrow\text{Int}$.
But then $g(2)$ has type $\text{Int}$, and so we must have $A=\text{Int}$.
Thus, the type of $f$ is $\left(\text{Int}\rightarrow\text{Int}\right)\rightarrow\text{Int}$.
We know enough to write the Scala code now:
\begin{lstlisting}
scala> ((f: (Int => Int) => Int) => p => f(p))(g => g(2))(x => x + 4)
res6: Int = 6
\end{lstlisting}
Type annotations for $p$, $g$, and $x$ may be omitted: Scala\textsf{'}s
compiler can figure out the missing types from the given type of $f$.
However, extra type annotations often make code clearer.

\subsection{Examples: Deriving a function\textsf{'}s type from its code\index{examples (with code)}}

Checking that the types match is an important part of the functional
programming paradigm, both in the practice of writing code and in
theoretical derivations of laws for various functions. For instance,
in the derivations of the composition laws (Section~\ref{subsec:Laws-of-function-composition}),
we were able to deduce the possible type parameters for $f$, $g$,
and $h$ in the expression $f\bef g\bef h$. This worked because the
composition operation \lstinline!andThen! (denoted by the symbol
$\bef$) is fully parametric. Given a fully parametric function, one
can derive the most general type signature that matches the body of
that function. The same type-deriving procedure may also help in converting
a given function to a fully parametric form.

Let us look at some examples of doing this.

\subsubsection{Example \label{subsec:Example-hof-derive-types-1}\ref{subsec:Example-hof-derive-types-1}}

The functions \lstinline!const! and \lstinline!id! were defined
in Section~\ref{subsec:Examples-of-fully-parametric}. What is the
value \lstinline!const(id)! and what is its type? Determine the most
general type parameters in the expression \lstinline!const(id)!.

\subparagraph{Solution}

We need to treat the functions \lstinline!const! and \lstinline!id!
as values, since our goal is to apply \lstinline!const! to \lstinline!id!.
Write the code of these functions in a short notation:
\[
\text{const}^{C,X}\triangleq c^{:C}\rightarrow\_^{:X}\rightarrow c\quad,\quad\quad\text{id}^{A}\triangleq a^{:A}\rightarrow a\quad.
\]
The types will match in the expression \lstinline!const(id)! only
if the argument of the function \lstinline!const! has the same type
as the type of \lstinline!id!. Since \lstinline!const! is a curried
function, we need to look at its \emph{first} curried argument, which
is of type $C$. The type of \lstinline!id! is $A\rightarrow A$,
where $A$ is (so far) an arbitrary type. So, the type parameter $C$
in $\text{const}^{C,X}$ must be equal to $A\rightarrow A$:
\[
C=A\rightarrow A\quad.
\]
 The type parameter $X$ in $\text{const}^{C,X}$ is not constrained,
so we keep it as $X$. The result of applying \lstinline!const! to
\lstinline!id! is of type $X\rightarrow C$, which equals $X\rightarrow A\rightarrow A$.
In this way, we find:
\[
\text{const}^{A\rightarrow A,X}(\text{id}^{A}):X\rightarrow A\rightarrow A\quad.
\]
The types $A$ and $X$ remain arbitrary. The type $X\rightarrow A\rightarrow A$
is the most general type for the expression \lstinline!const(id)!
because we have not made any assumptions about the types except requiring
that all functions must be always applied to arguments of the correct
types.

To compute the value of \lstinline!const(id)!, it remains to substitute
the code of \lstinline!const! and \lstinline!id!. Since we already
checked the types, we may omit all type annotations:
\begin{align*}
 & \gunderline{\text{const}}\left(\text{id}\right)\\
{\color{greenunder}\text{definition of const}:}\quad & =(c\rightarrow x\rightarrow\gunderline c)(\text{id})\\
{\color{greenunder}\text{apply function, substitute }c=\text{id}:}\quad & =x\rightarrow\gunderline{\text{id}}\\
{\color{greenunder}\text{definition of }\text{id}:}\quad & =x\rightarrow a\rightarrow a\quad.
\end{align*}

The function $\left(x\rightarrow a\rightarrow a\right)$ takes an
argument $x^{:X}$ and returns the identity function $a^{:A}\rightarrow a$.
It is clear that the argument $x$ is ignored by this function. So,
we can rewrite it equivalently as:
\[
\text{const}\left(\text{id}\right)=\_^{:X}\rightarrow a^{:A}\rightarrow a\quad.
\]


\subsubsection{Example \label{subsec:Example-hof-derive-types-2}\ref{subsec:Example-hof-derive-types-2}}

Implement a function \lstinline!twice! that takes a function \lstinline!f: Int => Int!
as its argument and returns a function that applies \lstinline!f!
twice. For instance, if the function \lstinline!f! is \lstinline!{ x => x + 3 }!,
the result of \lstinline!twice(f)! should be equal to the function
\lstinline!x => x + 6!. Test this with the expression \lstinline!twice(x => x + 3)(10)!.
After implementing the function \lstinline!twice!, generalize it
to a fully parametric function.

\subparagraph{Solution}

According to the requirements, the function \lstinline!twice! must
return a new function of type \lstinline!Int => Int!. So, the type
signature of \lstinline!twice! is:
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = ???
\end{lstlisting}
Since \lstinline!twice(f)! must be a new function with an integer
argument, we begin the code of \lstinline!twice! by writing a new
nameless function \lstinline!{ (x: Int) => ... }!,
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = { (x: Int) => ??? }
\end{lstlisting}
The new function must apply \lstinline!f! twice to its argument,
that is, it must return \lstinline!f(f(x))!. We can finish the implementation
now:
\begin{lstlisting}
def twice(f: Int => Int): Int => Int = { x => f(f(x)) }
\end{lstlisting}
The type annotation \lstinline!(x: Int)! can be omitted. Let us verify
that \lstinline!twice(x => x+3)(10)! equals \lstinline!10 + 6!:
\begin{lstlisting}
scala> val g = twice(x => x + 3)  // Expect g to be equal to the function { x => x + 6 }.
g: Int => Int = <function1>

scala> g(10)                      // Expect twice(x => x + 3)(10) to be equal to (x => x + 6)(10) = 16.
res0: Int = 16
\end{lstlisting}

To transform \lstinline!twice! into a fully parametric function means
replacing its type signature by a fully parameterized type signature
while keeping the function body unchanged:
\begin{lstlisting}
def twice[A, B, ...](f: ...): ... = { x => f(f(x)) }
\end{lstlisting}

To determine the type signature and the possible type parameters $A$,
$B$, ..., we need to determine the most general type that matches
the function body. The function body is the expression $x\rightarrow f(f(x))$.
Assume that $x$ has type $A$; for types to match in the sub-expression
$f(x)$, we need $f$ to have type $A\rightarrow B$ for some type
$B$. The sub-expression $f(x)$ will then have type $B$. For types
to match in $f(f(x))$, the argument of $f$ must have type $B$;
but we already assumed $f^{:A\rightarrow B}$. This is consistent
only if $A=B$. In this way, $x^{:A}$ implies $f^{:A\rightarrow A}$,
and the expression $x\rightarrow f(f(x))$ has type $A\rightarrow A$.
We can now write the type signature of \lstinline!twice!:
\begin{lstlisting}
def twice[A](f: A => A): A => A = { x => f(f(x)) }
\end{lstlisting}
This fully parametric function can be written in the code notation
as:
\begin{equation}
\text{twice}^{A}\triangleq f^{:A\rightarrow A}\rightarrow x^{:A}\rightarrow f(f(x))=f^{:A\rightarrow A}\rightarrow f\bef f\quad.\label{eq:hof-def-of-twice-in-math-notation}
\end{equation}

The procedure of deriving the most general type for a given code is
called \textbf{type inference}\index{type inference|textit}. In Example~\ref{subsec:Example-hof-derive-types-2},
the presence of the type parameter $A$ and the type signature $\left(A\rightarrow A\right)\rightarrow A\rightarrow A$
have been \textsf{``}inferred\textsf{''} from the code $f\rightarrow x\rightarrow f(f(x))$.

\subsubsection{Example \label{subsec:Example-hof-derive-types-3}\ref{subsec:Example-hof-derive-types-3}}

Consider the fully parametric function \lstinline!twice! defined
in Example~\ref{subsec:Example-hof-derive-types-2}. What is the
most general type of \lstinline!twice(twice)!, and what computation
does it perform? Test your answer on the expression \lstinline!twice(twice)(x => x + 3)(10)!.
What are the type parameters in that expression?

\subparagraph{Solution}

Note that \lstinline!twice(twice)! means that the function \lstinline!twice!
is used as \emph{its own} argument, i.e., this is \lstinline!twice(f)!
with \lstinline!f = twice!. We begin by assuming unknown type parameters
as \lstinline!twice[A](twice[B])!. The function \lstinline!twice[A]!
of type $\left(A\rightarrow A\right)\rightarrow A\rightarrow A$ can
be applied to the argument \lstinline!twice[B]! only if \lstinline!twice[B]!
has type $A\rightarrow A$. But \lstinline!twice[B]! is of type $\left(B\rightarrow B\right)\rightarrow B\rightarrow B$.
The symbol $\rightarrow$ groups to the right, so we have:
\[
\left(B\rightarrow B\right)\rightarrow B\rightarrow B=\left(B\rightarrow B\right)\rightarrow\left(B\rightarrow B\right)\quad.
\]
This can match with $A\rightarrow A$ only if we set $A=\left(B\rightarrow B\right)$.
So, the most general type of \lstinline!twice(twice)! is:
\begin{equation}
\text{twice}^{B\rightarrow B}(\text{twice}^{B}):\left(B\rightarrow B\right)\rightarrow B\rightarrow B\quad.\label{eq:hof-twice-example-solved3}
\end{equation}
After checking that types match, we may omit types from further calculations.

Example~\ref{subsec:Example-hof-derive-types-2} defined \lstinline!twice!
with the \lstinline!def! syntax. To use \lstinline!twice! as an
argument in the expression \lstinline!twice(twice)!, it is convenient
to define \lstinline!twice! as a value, \lstinline!val twice = ...!
However, the function \lstinline!twice! needs type parameters, and
Scala 2 does not directly support \lstinline!val! definitions with
type parameters. Scala 3 supports type parameters appearing together
with arguments in a nameless function:
\begin{lstlisting}
val twice = [A] => (f: A => A) => (x: A) => f(f(x)) // Valid only in Scala 3.
\end{lstlisting}
Keeping this in mind, we use the definition of \lstinline!twice!
from Eq.~(\ref{eq:hof-def-of-twice-in-math-notation}): $\text{twice}\,(f)=f\bef f$,
which omits the curried argument $x^{:A}$ and makes the calculation
shorter. Substituting that into \lstinline!twice(twice)!, we find:
\begin{align*}
 & \text{twice}\,(\text{twice})=\text{twice}\bef\text{twice}\\
{\color{greenunder}\text{expand function composition}:}\quad & =f\rightarrow\text{twice}\,(\gunderline{\text{twice}}\,(f))\quad.\\
{\color{greenunder}\text{definition of }\text{twice}\,(f):}\quad & =f\rightarrow\gunderline{\text{twice}}\,(f\bef f)\\
{\color{greenunder}\text{definition of twice}:}\quad & =f\rightarrow f\bef f\bef f\bef f\quad.
\end{align*}
This clearly shows that \lstinline!twice(twice)! is a function applying
its (function-typed) argument \emph{four} times.

The types in \lstinline!twice(twice)(x => x + 3)! follow from Eq.~(\ref{eq:hof-twice-example-solved3}):
since \lstinline!x => x + 3! has type \lstinline!Int => Int!, types
will match only if we set $B=\text{Int}$. The result is \lstinline!twice[Int => Int](twice[Int])!.
To test, we need to write at least one type parameter in the code,
or else Scala cannot correctly infer the types in \lstinline!twice(twice)!:
\begin{lstlisting}
scala> twice(twice[Int])(x => x + 3)(10) // Or write `twice[Int => Int](twice)(x => x + 3)(10)` .
res0: Int = 22
\end{lstlisting}
This confirms that \lstinline!twice(twice)(x => x + 3)! equals the
function \lstinline!x => x + 12!.

\subsubsection{Example \label{subsec:Example-hof-derive-types-4}\ref{subsec:Example-hof-derive-types-4}}

\textbf{(a)} Infer a general type signature with type parameter(s)
for the given function \lstinline!p!:
\begin{lstlisting}
def p[...]:... = { f => f(2) }
\end{lstlisting}
\textbf{(b)} Could we choose the type parameters in the expression
\lstinline!p(p)! such that the types match?

\subparagraph{Solution}

\textbf{(a)} In the nameless function $f\rightarrow f(2)$, the argument
$f$ must be itself a function with an argument of type \lstinline!Int!,
otherwise the sub-expression $f(2)$ is ill-typed. So, types will
match if $f$ has type $\text{Int}\rightarrow\text{Int}$ or $\text{Int}\rightarrow\text{String}$
or similar. The most general case is when $f$ has type $\text{Int}\rightarrow A$,
where $A$ is an arbitrary type (i.e., a type parameter); then the
value $f(2)$ has type $A$. Since the nameless function $f\rightarrow f(2)$
has an argument $f$ of type $\text{Int}\rightarrow A$ and a result
$f(2)$ of type $A$, we find that the type of $p$ must be $\left(\text{Int}\rightarrow A\right)\rightarrow A$.
With this type assignment, all types match. The type parameter $A$
remains undetermined and is added to the type signature of the function
\lstinline!p!. The code is:
\begin{lstlisting}
def p[A]: (Int => A) => A = { f => f(2) }
\end{lstlisting}

\textbf{(b)} The expression \lstinline!p(p)! applies \lstinline!p!
to itself, just as \lstinline!twice(twice)! did in Example~\ref{subsec:Example-hof-derive-types-3}.
Begin by writing \lstinline!p(p)! with unknown type parameters: \lstinline!p[A](p[B])!.
Then  try to choose \lstinline!A! and \lstinline!B! so that the
types match in that expression. Does the type of \lstinline!p[B]!,
which is \lstinline!(Int => B) => B!, match the type of the argument
of \lstinline!p[A]!, which is \lstinline!Int => A!, with some choice
of \lstinline!A! and \lstinline!B!? A function type \lstinline!P => Q!
matches \lstinline!X => Y! only if \lstinline!P = X! and \lstinline!Q = Y!.
So, \lstinline!(Int => B) => B! can match \lstinline!Int => A! only
if \lstinline!Int => B! matches \lstinline!Int! and if \lstinline!B = A!.
But it is impossible for \lstinline!Int => B! to match \lstinline!Int!,
no matter how we choose \lstinline!B!. 

We conclude that the expression \lstinline!p[A](p[B])! has a problem:
for any choice of \lstinline!A! and \lstinline!B!, some type will
be mismatched. One says that the expression \lstinline!p(p)! is \textbf{not
well-typed}\index{well-typed expression}. Such expressions contain
a type error and are rejected by the Scala compiler. $\square$

In the examples seen so far, we inferred the most general type of
a code expression simply by trying to make all function types match
the types of their arguments. The Damas-Hindley-Milner algorithm\footnote{\texttt{\href{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system\#Algorithm_W}{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner\_type\_system\#Algorithm\_W}}}
performs type inference\index{type inference} (or determines that
there is a type error) for any code containing functions, tuples,
and disjunctive types.

\section{Summary}

\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\small{}Notation} & \textbf{\small{}Scala syntax} & \textbf{\small{}Comments}\tabularnewline
\hline 
\hline 
{\small{}$x^{:A}$} & {\small{}}\lstinline!x: A! & {\small{}a value or an argument of type }\lstinline!A!\tabularnewline
\hline 
{\small{}$f^{:A\rightarrow B}$} & {\small{}}\lstinline!f: A => B! & {\small{}a function of type }\lstinline!A => B!\tabularnewline
\hline 
{\small{}$x^{:\text{Int}}\rightarrow x+1$} & {\small{}}\lstinline!(x: Int) => x + 1! & {\small{}a nameless function of type }\lstinline!Int => Int!\tabularnewline
\hline 
{\small{}$f^{A,B}\triangleq...$} & {\small{}}\lstinline!def f[A, B] = ...! & {\small{}a function with type parameters}\tabularnewline
\hline 
{\small{}$\text{id}^{A}$, also $\text{id}^{:A\rightarrow A}$} & {\small{}}\lstinline!identity[A]! & {\small{}the standard \textsf{``}identity\textsf{''} function}\tabularnewline
\hline 
{\small{}$A\rightarrow B\rightarrow C$} & {\small{}}\lstinline!A => B => C! & {\small{}the type of a curried function}\tabularnewline
\hline 
{\small{}$f\bef g$} & {\small{}}\lstinline!f andThen g! & {\small{}forward composition of functions}\tabularnewline
\hline 
{\small{}$g\circ f$} & {\small{}}\lstinline!g compose f! & {\small{}backward composition of functions}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Some notation for symbolic reasoning about code.\label{tab:Mathematical-notation-for-code}}
\end{table}
Table~\ref{tab:Mathematical-notation-for-code} shows the notations
introduced in this chapter. 

What can we do using this chapter\textsf{'}s techniques?
\begin{itemize}
\item Make functions that return new functions and/or take functions as
arguments.
\item Simplify expressions symbolically when functions are applied to arguments.
\item Derive a general type for a given code expression (perform type inference).
\item Convert functions to a fully parametric form when possible.
\end{itemize}
The following examples and exercises illustrate these techniques further.

\subsection{Examples\index{examples (with code)}}

\subsubsection{Example \label{subsec:Example-hof-simple-1}\ref{subsec:Example-hof-simple-1}}

Implement a function that applies a given function $f$ repeatedly
to an initial value $x_{0}$, until a given function \lstinline!cond!
returns \lstinline!true!:
\begin{lstlisting}
def converge[X](f: X => X, x0: X, cond: X => Boolean): X = ???
\end{lstlisting}


\subparagraph{Solution}

We call \lstinline!find! on an iterator that keeps applying \lstinline!f!;
this stops when the condition is \lstinline!true!:
\begin{lstlisting}
def converge[X](f: X => X, x0: X, cond: X => Boolean): X = 
  Stream.iterate(x0)(f)   // Type is Stream[X].
  .find(cond)             // Type is Option[X].
  .get                    // Type is X.
\end{lstlisting}
The method \lstinline!get! is a \index{partial function}partial
function that can be applied only to non-empty \lstinline!Option!
values. It is safe to call \lstinline!get! here, because the stream
is unbounded and, if the condition \lstinline!cond! never becomes
\lstinline!true!, the program will run out of memory (since \lstinline!Stream.iterate!
keeps all computed values in memory) or the user will run out of patience.
So, \lstinline!_.find(cond)! can never return an empty \lstinline!Option!
value. Of course, it is not satisfactory that the program crashes
when the sequence does not converge. Exercise~\ref{subsec:Exercise-hof-simple-8}
will implement a safer version of this function by limiting the allowed
number of iterations.

A tail-recursive implementation that works in constant memory is:
\begin{lstlisting}
@tailrec def converge[X](f: X => X, x0: X, cond: X => Boolean): X =
  if (cond(x0)) x0 else converge(f, f(x0), cond)
\end{lstlisting}
To test this code, compute an approximation to $\sqrt{q}\,$ by Newton\textsf{'}s
method\index{Newton\textsf{'}s method} with the iteration function $f(x)=\frac{1}{2}\left(x+\frac{q}{x}\right)$.
We iterate $f(x)$ starting with $x_{0}=q/2$ until a given precision
is obtained:
\begin{lstlisting}
def approx_sqrt(q: Double, precision: Double): Double = {
      def cond(x: Double): Boolean = math.abs(x * x - q) <= precision
      def iterate_sqrt(x: Double): Double = 0.5 * (x + q / x)
      converge(iterate_sqrt, q / 2, cond)
}
\end{lstlisting}
Newton\textsf{'}s method for $\sqrt{q}\,$ is guaranteed to converge when $q\geq0$.
Test it:
\begin{lstlisting}
scala> approx_sqrt(25, 1.0e-8)
res0: Double = 5.000000000016778
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-hof-simple-2}\ref{subsec:Example-hof-simple-2}}

Using both \lstinline!def! and \lstinline!val!, define a Scala function
that takes an integer \lstinline!x! and returns a function that adds
\lstinline!x! to \emph{its} argument.

\subparagraph{Solution}

Let us first write down the required type signature. The function
must take an integer argument \lstinline!x: Int!, and the return
value must be a function of type \lstinline!Int => Int!:
\begin{lstlisting}
def add_x(x: Int): Int => Int = ???
\end{lstlisting}
We are required to return a function that adds \lstinline!x! to its
argument. Let us call that argument \lstinline!z!, to avoid confusion
with the \lstinline!x!. So, we are required to return the function
\lstinline!{ z => z + x }!. Since functions are values, we return
a new function by writing a nameless function expression:
\begin{lstlisting}
def add_x(x: Int): Int => Int = { z => z + x }
\end{lstlisting}
To implement the same function by using a \lstinline!val!, we first
convert the type signature of \lstinline!add_x! to the equivalent
curried type $\text{Int}\rightarrow\text{Int}\rightarrow\text{Int}$.
Now we can write the Scala code of a function \lstinline!add_x_v!:
\begin{lstlisting}
val add_x_v: Int => Int => Int = { x => z => z + x }
\end{lstlisting}
The function \lstinline!add_x_v! is equal to \lstinline!add_x! except
for using the \lstinline!val! syntax instead of \lstinline!def!.
We do not need to write the type of the arguments \lstinline!x! and
\lstinline!z! since we already wrote the type $\text{Int}\rightarrow\text{Int}\rightarrow\text{Int}$
of \lstinline!add_x_v!. 

\subsubsection{Example \label{subsec:Example-hof-simple-3}\ref{subsec:Example-hof-simple-3}}

Using \lstinline!def! and \lstinline!val!, implement a curried function
\lstinline!prime_f! that takes a function $f$ and an integer $x$,
and returns \lstinline!true! when $f(x)$ is prime. Use the function
\lstinline!isPrime! from Section~\ref{subsec:Nameless-functions}. 

\subparagraph{Solution}

First, determine the required type signature of \lstinline!prime_f!.
The value $f(x)$ must have type \lstinline!Int!, or else we cannot
check whether it is prime. So, $f$ must have type $\text{Int}\rightarrow\text{Int}$.
Since \lstinline!prime_f! should be a curried function, we need to
put each argument into its own set of parentheses:
\begin{lstlisting}
def prime_f(f: Int => Int)(x: Int): Boolean = ???
\end{lstlisting}
To implement \lstinline!prime_f!, we need to return the result of
\lstinline!isPrime! applied to \lstinline!f(x)!. A simple solution
is:
\begin{lstlisting}
def prime_f(f: Int => Int)(x: Int): Boolean = isPrime(f(x))
\end{lstlisting}

To implement the same function using \lstinline!val!, rewrite its
type signature as:
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = ???
\end{lstlisting}
(The parentheses around \lstinline!Int => Int! are mandatory as \lstinline!Int => Int => Int => Boolean!
would be a completely different type.) The implementation is:
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = { f => x => isPrime(f(x)) }
\end{lstlisting}
The code \lstinline!isPrime(f(x))! is a forward composition of the
functions \lstinline!f! and \lstinline!isPrime!, so we can write:
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = (f => f andThen isPrime)
\end{lstlisting}
A nameless function of the form \lstinline!f => f.something! is equivalent
to a shorter Scala syntax \lstinline!(_.something)!. We finally rewrite
the code of \lstinline!prime_f! as:
\begin{lstlisting}
val prime_f: (Int => Int) => Int => Boolean = (_ andThen isPrime)
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-hof-simple-4}\ref{subsec:Example-hof-simple-4}}

Implement a function \lstinline!choice(x, p, f, g)! that takes a
value $x$, a predicate $p$, and two functions $f$ and $g$. The
return value must be $f(x)$ if $p(x)$ returns \lstinline!true!;
otherwise the return value must be $g(x)$. Infer the most general
type for this function.

\subparagraph{Solution}

The code of this function must be:
\begin{lstlisting}
def choice[...](x, p, f, g) = if (p(x)) f(x) else g(x)
\end{lstlisting}
To infer the most general type for this code, begin by assuming that
$x$ has type $A$, where $A$ is a type parameter. Then the predicate
$p$ must have type \lstinline!A => Boolean!. Since $p$ is an arbitrary
predicate, the value $p(x)$ will be sometimes \lstinline!true! and
sometimes \lstinline!false!. So, \lstinline!choice(x, p, f, g)!
will sometimes compute $f(x)$ and sometimes $g(x)$. It follows that
type $A$ must be the argument type of both $f$ and $g$, which means
that the most general types so far are $f^{:A\rightarrow B}$ and
$g^{:A\rightarrow C}$, yielding the type signature:
\[
\text{choice}(x^{:A},p^{:A\rightarrow\text{Boolean}},f^{:A\rightarrow B},g^{:A\rightarrow C})\quad.
\]

What could be the return type of \lstinline!choice(x, p, f, g)!?
If $p(x)$ returns \lstinline!true!, the function \lstinline!choice!
returns $f(x)$, which is of type $B$. Otherwise, \lstinline!choice!
returns $g(x)$, which is of type $C$. However, the type signature
of \lstinline!choice! must be fixed in advance (at compile time)
and cannot depend on the value $p(x)$ computed at run time. So, the
types of $f(x)$ and of $g(x)$ must be the same, $B=C$. The type
signature of \lstinline!choice! will thus have only two type parameters,
$A$ and $B$:
\begin{lstlisting}
def choice[A, B](x: A, p: A => Boolean, f: A => B, g: A => B): B =
  if (p(x)) f(x) else g(x)
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-hof-derive-types-5}\ref{subsec:Example-hof-derive-types-5}}

Infer the most general type for the fully parametric function:
\begin{lstlisting}
def q[...]: ... = { f => g => g(f) }
\end{lstlisting}
What types are inferred for the expressions \lstinline!q(q)! and
\lstinline!q(q(q))!?

\subparagraph{Solution}

To begin, assume $f^{:A}$ with a type parameter $A$. In the sub-expression
$g\rightarrow g(f)$, the curried argument $g$ must itself be a function,
because it is being applied to $f$ as $g(f)$. So, we assign types
as $f^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(f)$, where
$A$ and $B$ are type parameters. Then the final returned value $g(f)$
has type $B$. Since there are no other constraints on the types,
the types $A$ and $B$ remain arbitrary, so we add them to the type
signature:
\begin{lstlisting}
def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end{lstlisting}

To match types in the expression \lstinline!q(q)!, we first assume
arbitrary type parameters and write \lstinline!q[A, B](q[C, D])!.
We need to introduce new type parameters $C$, $D$ because those
type parameters may need to be set differently from $A$, $B$ when
we try to match the types in the expression \lstinline!q(q)!.

The type of the first curried argument of \lstinline!q[A, B]!, which
is $A$, must match the entire type of \lstinline!q[C, D]!, which
is $C\rightarrow\left(C\rightarrow D\right)\rightarrow D$. So, we
must choose $A$ as:
\[
A=C\rightarrow\left(C\rightarrow D\right)\rightarrow D\quad.
\]
The type of \lstinline!q(q)! becomes:
\begin{align*}
q^{A,B}(q^{C,D}) & :\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\quad,\\
 & \quad\text{where}\quad A=C\rightarrow\left(C\rightarrow D\right)\rightarrow D\quad.
\end{align*}
There are no other constraints on the type parameters $B$, $C$,
$D$.

We use this result to infer the most general type for \lstinline!q(q(q))!.
Denote $r\triangleq q(q)$ for brevity; then, as we just found, $r$
has type $\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B$.
To infer types in the expression \lstinline!q(r)!, we introduce new
type parameters $E$, $F$ and write \lstinline!q[E, F](r)!. The
type of the argument of \lstinline!q[E, F]! is $E$, and this must
be the same as the type of $r$. This gives the constraint:
\[
E=\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\quad.
\]
Other than that, the type parameters are arbitrary. The type of the
expression \lstinline!q(q(q))! is $\left(E\rightarrow F\right)\rightarrow F$.
We conclude that the most general type of \lstinline!q(q(q))! is:
\begin{align*}
q^{E,F}(q^{A,B}(q^{C,D})) & :\left(\left(\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\right)\rightarrow F\right)\rightarrow F\quad,\\
\text{where}\quad & A=C\rightarrow\left(C\rightarrow D\right)\rightarrow D\\
\text{and}\quad & E=\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\quad.
\end{align*}
It is clear from this derivation that expressions such as \lstinline!q(q(q(q)))!,
\lstinline!q(q(q(q(q))))!, etc., are well-typed.

Let us test these results in Scala, renaming the type parameters for
clarity to \lstinline!A!, \lstinline!B!, \lstinline!C!, \lstinline!D!:
\begin{lstlisting}
scala> def qq[A, B, C]: ((A => (A => B) => B) => C) => C = q(q)
qq: [A, B, C]=> ((A => ((A => B) => B)) => C) => C

scala> def qqq[A, B, C, D]: ((((A => (A => B) => B) => C) => C) => D) => D = q(q(q))
qqq: [A, B, C, D]=> ((((A => ((A => B) => B)) => C) => C) => D) => D
\end{lstlisting}
We did not need to write any type parameters within the expressions
\lstinline!q(q)! and \lstinline!q(q(q))! because the full type signature
was declared for each of these expressions. Since the Scala compiler
did not print any error messages, we are assured that the types match
correctly.

\subsubsection{Example \label{subsec:Example-not-typeable}\ref{subsec:Example-not-typeable}}

For the following expressions, infer the most general types or show
that the expression is not well-typed with simple types:

\textbf{(a)} $f\rightarrow f(f)\quad.$

\textbf{(b)} $f\rightarrow f(h\rightarrow h(f))\quad.$

\textbf{(c)} $f\rightarrow g\rightarrow f(h\rightarrow h(g))\quad.$

By \textsf{``}simple types\textsf{''} we mean that $f$, $g$, $h$ cannot have \emph{their
own} type parameters.

\subparagraph{Solution}

\textbf{(a)} The type of $f$ is unknown, so we begin by assigning
an arbitrary type $A$ to it. Types now need to match in the expression
$f(f)$ with $f^{:A}$. So, the type $A$ must be a function type
whose argument is again of type $A$. We can write that function type
as $A\rightarrow B$, where $B$ is another arbitrary type. Now, types
match only if $A$ and $A\rightarrow B$ is the same type. But there
are no simple types $A$ and $B$ such that $A=A\rightarrow B$. So,
the expression $f\rightarrow f(f)$ is not well-typed.

This conclusion holds only because we do not allow the function $f$
to have its own type parameters. Otherwise, the expression $f(f)$
could be well-typed. See, for instance, Example~\ref{subsec:Example-hof-derive-types-3}
showing that the expression \lstinline!twice(twice)! is well-typed.

\textbf{(b)} Begin by assigning type parameters as $f^{:A}$ and $h^{:B}$,
where $A$ and $B$ are unknown. To match types in $h(f)$, the type
of $h$ must be a function type with an argument of type $A$. So,
we must have $B=A\rightarrow C$, where $C$ is unknown. Then $h(f)$
has type $C$, and $h\rightarrow h(f)$ has type $(A\rightarrow C)\rightarrow C$.
This is the type of an argument of $f$, so $A=((A\rightarrow C)\rightarrow C)\rightarrow D$,
where $D$ is unknown. But we cannot have a simple type $A$ that
satisfies the type equation $A=((A\rightarrow C)\rightarrow C)\rightarrow D$.
We conclude that the expression $f\rightarrow f(h\rightarrow h(f))$
is not well-typed. 

\textbf{(c) }Begin by assigning type parameters as $f^{:A}$, $g^{:B}$,
$h^{:C}$. To match types in $h(g)$, we must have $C=B\rightarrow D$.
Then $h\rightarrow h(f)$ has type $C\rightarrow D$, and that must
be the type of $f$\textsf{'}s argument. So, we must have: 
\[
A=(C\rightarrow D)\rightarrow E=((B\rightarrow D)\rightarrow D)\rightarrow E\quad.
\]
There are no other restrictions. We have found the most general type:
\[
\big(f^{:((B\rightarrow D)\rightarrow D)\rightarrow E}\rightarrow g^{:B}\rightarrow f(h^{:B\rightarrow D}\rightarrow h(g))\big):(((B\rightarrow D)\rightarrow D)\rightarrow E)\rightarrow B\rightarrow E\quad.
\]
The type parameters $B$, $D$, $E$ remain arbitrary. 

\subsubsection{Example \label{subsec:Example-hof-curried}\ref{subsec:Example-hof-curried}}

Infer types in the code expression:
\[
\left(f\rightarrow g\rightarrow g(f)\right)\left(f\rightarrow g\rightarrow g(f)\right)\left(f\rightarrow f(10)\right)\quad,
\]
and simplify the code through symbolic calculations.

\subparagraph{Solution}

The given expression is a curried function $f\rightarrow g\rightarrow g(f)$
applied to two curried arguments. The plan is to consider each of
these sub-expressions in turn, assigning types for them using type
parameters, and then to figure out how to set the type parameters
so that all types match.

Begin by renaming the shadowed variables ($f$ and $g$) to remove
shadowing:
\begin{equation}
\left(f\rightarrow g\rightarrow g(f)\right)\left(x\rightarrow y\rightarrow y(x)\right)\left(h\rightarrow h(10)\right)\quad.\label{eq:example-hof-curried-function-solved1}
\end{equation}
 As we have seen in Example~\ref{subsec:Example-hof-derive-types-5},
the sub-expression $f\rightarrow g\rightarrow g(f)$ is typed as $f^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(f)$,
where $A$ and $B$ are some type parameters. The sub-expression $x\rightarrow y\rightarrow y(x)$
is the same function as $f\rightarrow g\rightarrow g(f)$ but with
possibly different type parameters, say, $x^{:C}\rightarrow y^{:C\rightarrow D}\rightarrow y(x)$.
The types $A$, $B$, $C$, $D$ are so far unknown.

Finally, the variable $h$ in the sub-expression $h\rightarrow h(10)$
must have type $\text{Int}\rightarrow E$, where $E$ is another type
parameter. So, the sub-expression $h\rightarrow h(10)$ is a function
of type $\left(\text{Int}\rightarrow E\right)\rightarrow E$.

The types must match in the entire expression~(\ref{eq:example-hof-curried-function-solved1}):
\begin{equation}
(f^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(f))(x^{:C}\rightarrow y^{:C\rightarrow D}\rightarrow y(x))(h^{:\text{Int}\rightarrow E}\rightarrow h(10))\quad.\label{eq:example-hof-curried-function-solved2}
\end{equation}
It follows that $f$ must have the same type as $x\rightarrow y\rightarrow y(x)$,
while $g$ must have the same type as $h\rightarrow h(10)$. The type
of $g$, which we know as $A\rightarrow B$, will match the type of
$h\rightarrow h(10)$, which we know as $\left(\text{Int}\rightarrow E\right)\rightarrow E$,
only if $A=\left(\text{Int}\rightarrow E\right)$ and $B=E$. It follows
that $f$ has type $\text{Int}\rightarrow E$. At the same time, the
type of $f$ must match the type of $x\rightarrow y\rightarrow y(x)$,
which is $C\rightarrow(C\rightarrow D)\rightarrow D$. This can work
only if $C=\text{Int}$ and $E=(C\rightarrow D)\rightarrow D=(\text{Int}\rightarrow D)\rightarrow D$.

In this way, we have found all the relationships between the type
parameters $A$, $B$, $C$, $D$, $E$ in Eq.~(\ref{eq:example-hof-curried-function-solved2}).
The type $D$ remains arbitrary, while the type parameters $A$, $B$,
$C$, $E$ are expressed as:
\begin{align}
A & =\text{Int}\rightarrow\left(\text{Int}\rightarrow D\right)\rightarrow D\quad,\label{eq:example-hof-curried-solved3}\\
B & =E=\left(\text{Int}\rightarrow D\right)\rightarrow D\quad,\label{eq:example-hof-curried-solved4}\\
C & =\text{Int}\quad.\nonumber 
\end{align}
The entire expression in Eq.~(\ref{eq:example-hof-curried-function-solved2})
is a full application of a curried function, and thus has the same
type as the \textsf{``}final\textsf{''} result expression $g(f)$, which has type
$B$. So, the entire expression in Eq.~(\ref{eq:example-hof-curried-function-solved2})
has type $B=\left(\text{Int}\rightarrow D\right)\rightarrow D$.

Having established that types match, we can now omit the type annotations
and rewrite the code:
\begin{align*}
 & (\gunderline f\rightarrow g\rightarrow g(\gunderline f))\gunderline{\left(x\rightarrow y\rightarrow y(x)\right)}\left(h\rightarrow h(10)\right)\\
{\color{greenunder}\text{substitute }f=x\rightarrow y\rightarrow y(x):}\quad & =\big(\gunderline g\rightarrow\gunderline g(x\rightarrow y\rightarrow y(x))\big)\gunderline{\left(h\rightarrow h(10)\right)}\\
{\color{greenunder}\text{substitute }g=h\rightarrow h(10):}\quad & =(\gunderline h\rightarrow\gunderline h(10))\gunderline{\left(x\rightarrow y\rightarrow y(x)\right)}\\
{\color{greenunder}\text{substitute }h=x\rightarrow y\rightarrow y(x):}\quad & =(\gunderline x\rightarrow y\rightarrow y(\gunderline x))\gunderline{(10)}\\
{\color{greenunder}\text{substitute }x=10:}\quad & =y\rightarrow y(10)\quad.
\end{align*}
The type of this expression is $\left(\text{Int}\rightarrow D\right)\rightarrow D$
with a type parameter $D$. Since the argument $y$ is an arbitrary
function, we cannot simplify either $y(10)$ or $y\rightarrow y(10)$
any further. So, the final simplified form of Eq.~(\ref{eq:example-hof-curried-function-solved1})
is $y^{:\text{Int}\rightarrow D}\rightarrow y(10)$.

To test this, we first define the function $f\rightarrow g\rightarrow g(f)$
as in Example~\ref{subsec:Example-hof-derive-types-5}:
\begin{lstlisting}
def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end{lstlisting}
We also define the function $h\rightarrow h(10)$ with a general type
$\left(\text{Int}\rightarrow E\right)\rightarrow E$:
\begin{lstlisting}
def r[E]: (Int => E) => E = { h => h(10) }
\end{lstlisting}
To help Scala evaluate Eq.~(\ref{eq:example-hof-curried-function-solved2}),
we need to set the type parameters for the first \lstinline!q! function
as \lstinline!q[A, B]! where $A$ and $B$ are given by Eqs.~(\ref{eq:example-hof-curried-solved3})\textendash (\ref{eq:example-hof-curried-solved4}):
\begin{lstlisting}
scala> def s[D] = q[Int => (Int => D) => D, (Int => D) => D](q)(r)
s: [D]=> (Int => D) => D
\end{lstlisting}
To verify that the function $s^{D}$ indeed equals $y^{:\text{Int}\rightarrow D}\rightarrow y(10)$,
we apply $s^{D}$ to some functions of type $\text{Int}\rightarrow D$,
say, with $D=\text{Boolean}$ or $D=\text{Int}$:
\begin{lstlisting}
scala> s(_ > 0)  // Set D = Boolean and evaluate (10 > 0).
res6: Boolean = true

scala> s(_ + 20) // Set D = Int and evaluate (10 + 20).
res7: Int = 30
\end{lstlisting}


\subsubsection{Example \label{subsec:Example-hof-composition}\ref{subsec:Example-hof-composition}}

Compute $\left(x\rightarrow y\rightarrow x(x(y))\right)\bef\left(p\rightarrow p(2)\right)\bef\left(z\rightarrow z+3\right)$
symbolically and infer types.

\subparagraph{Solution}

The forward composition $f\bef g$ substitutes the \emph{body} of
$f$ into the argument of $g$:
\begin{align*}
{\color{greenunder}\text{substitute }y=f(x):}\quad & (x\rightarrow f(x))\bef(\gunderline y\rightarrow\gunderline{g(y)})=\left(x\rightarrow g(f(x))\right)\quad.
\end{align*}
Here, we substituted $f(x)$ instead of $y$ in $g(y)$ and obtained
$g(f(x))$. This shows how to compute the forward compositions left
to right:
\begin{align*}
 & \left(x\rightarrow y\rightarrow x(x(y))\right)\bef(p\rightarrow p(2))=x\rightarrow(y\rightarrow x(x(y)))(2)=x\rightarrow x(x(2))\quad.\\
 & \left(x\rightarrow x(x(2))\right)\bef\left(z\rightarrow z+3\right)=x\rightarrow x(x(2))+3\quad.
\end{align*}
Computing the pairwise combinations in another order, we get the same
result:
\begin{align*}
{\color{greenunder}\text{first compute}:}\quad & \left(p\rightarrow p(2)\right)\bef\left(z\rightarrow z+3\right)=p\rightarrow p(2)+3\quad.\\
{\color{greenunder}\text{then compute}:}\quad & \left(x\rightarrow y\rightarrow x(x(y))\right)\bef\left(p\rightarrow p(2)+3\right)\\
 & \quad=x\rightarrow\left(y\rightarrow x(x(y))\right)(2)+3\\
 & \quad=x\rightarrow x(x(2))+3\quad.
\end{align*}
This is to be expected due to the associativity law~(\ref{eq:associativity-of-function-composition}).
Types are inferred as: 
\[
\left(x\rightarrow y\rightarrow x(x(y))\right)^{:(\text{Int}\rightarrow\text{Int})\rightarrow(\text{Int}\rightarrow\text{Int})}\bef\left(p\rightarrow p(2)\right)^{:(\text{Int}\rightarrow\text{Int})\rightarrow\text{Int}}\bef\left(z\rightarrow z+3\right)^{:\text{Int}\rightarrow\text{Int}}\quad.
\]


\subsubsection{Example \label{subsec:Example-hof-const-function}\ref{subsec:Example-hof-const-function}}

We are given a function $q^{:A\rightarrow A}$, and we only know that
for any $f^{:A\rightarrow A}$ the law $f\bef q=q\bef f$ holds (i.e.,
$q$ commutes with every function). Show that $q$ must be an identity
function.

\subparagraph{Solution}

Since the law must hold for any $f$, we may choose $f$ at will.
Let us fix a value $z^{:A}$ and choose $f\triangleq\_\rightarrow z$,
that is, a constant function returning $z$. Applying both sides of
the law $f\bef q=q\bef f$ to an arbitrary $x^{:A}$, we get:
\[
(f\bef q)(x)=q(f(x))=q(z)\quad,\quad\quad(q\bef f)(x)=f(q(x))=z\quad.
\]
It follows that $q(z)=z$ for any chosen $z^{:A}$. In other words,
$q$ is an identity function ($\text{id}^{:A\rightarrow A}$).

\subsection{Exercises\index{exercises}}

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-7}\ref{subsec:Exercise-hof-simple-7}}

Revise the function from Exercise~\ref{subsec:ch1-transf-Exercise-4},
making it a curried function and replacing the hard-coded number $100$
by a \emph{curried} first argument. The type signature should become
\texttt{}\lstinline!Int => List[List[Int]] => List[List[Int]]!\texttt{.}

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-8}\ref{subsec:Exercise-hof-simple-8}}

Implement the function \lstinline!converge! from Example~\ref{subsec:Example-hof-simple-1}
as a curried function with an additional argument to set the maximum
number of iterations, returning \lstinline!Option[Double]! as the
final result type. The new version of \lstinline!converge! should
return \lstinline!None! if the convergence condition is not satisfied
after the given maximum number of iterations. The type signature and
an example test:
\begin{lstlisting}
@tailrec def convergeN[X](cond: X => Boolean)(x0: X)(maxIter: Int)(f: X => X): Option[X] = ???

scala> convergeN[Int](_ < 0)(0)(10)(_ + 1) // This does not converge.
res0: Option[Int] = None

scala> convergeN[Double]{ x => math.abs(x * x - 25) < 1e-8 }(1.0)(10) { x => 0.5 * (x + 25 / x ) }
res1: Option[Double] = Some(5.000000000053722)
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Exercise-hof-simple-7-1}\ref{subsec:Exercise-hof-simple-7-1}}

Implement a fully parametric, information-preserving, curried function
that recovers from an error using a given function argument. The type
signature and an example test:
\begin{lstlisting}
def recover[E, A]: Option[Either[E, A]] => (E => A) => Option[A] = ???

scala> recover(Some(Left("error"))) { _ => 123 }
res0: Option[Int] = Some(123)
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Exercise-hof-simple-1}\ref{subsec:Exercise-hof-simple-1}}

For \lstinline!id! and \lstinline!const! as defined above, what
are the types of \lstinline!id(id)!, \lstinline!id(id)(id)!, \lstinline!id(id(id))!,
\lstinline!id(const)!, and \lstinline!const(const)!? Simplify these
code expressions by symbolic calculations.

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-1-1}\ref{subsec:Exercise-hof-simple-1-1}}

For the function \lstinline!twice! from Example~\ref{subsec:Example-hof-derive-types-2},
show that the function \lstinline!twice(twice(f)))! is the same as
\lstinline!twice(twice)(f)! for any \lstinline!f: Int => Int!. 

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-3}\ref{subsec:Exercise-hof-simple-3}}

For the function \lstinline!twice! from Example~\ref{subsec:Example-hof-derive-types-2},
infer the most general type for the function \lstinline!twice(twice(twice)))!.
What does that function do? Test your answer on an example.

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-4}\ref{subsec:Exercise-hof-simple-4}}

Define a function \lstinline!thrice! similarly to \lstinline!twice!
except it should apply a given function $3$ times. What does the
function \lstinline!thrice(thrice(thrice)))! do?

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-5}\ref{subsec:Exercise-hof-simple-5}}

Define a function \lstinline!ence! similarly to \lstinline!twice!
except it should apply a given function $n$ times, where $n$ is
an additional curried argument.

\subsubsection{Exercise \label{subsec:Exercise-hof-simple-6}\ref{subsec:Exercise-hof-simple-6}}

Define a fully parametric function \lstinline!flip(f)! that swaps
arguments for any given uncurried function \lstinline!f! having two
arguments. To test: 

\begin{lstlisting}
def f(x: Int, y: Int) = x - y    // Expect f(10, 2) == 8.
val g = flip(f)                  // Now expect g(2, 10) == 8.

scala> assert( f (10, 2) == 8 && g(2, 10) == 8 )
\end{lstlisting}


\subsubsection{Exercise \label{subsec:Exercise-hof-simple-8-1}\ref{subsec:Exercise-hof-simple-8-1}}

Write a function \lstinline!curry2! converting a function of type
\texttt{}\lstinline!(A, A) => A! into an equivalent curried function
of type \texttt{}\lstinline!A => A => A!.

\subsubsection{Exercise \label{subsec:Exercise-hof-curried-1}\ref{subsec:Exercise-hof-curried-1}}

Apply the function $\left(x\rightarrow\_\rightarrow x\right)$ to
the value $\left(z\rightarrow z(q)\right)$ where $q^{:Q}$ is a given
value of type $Q$. Infer types in these expressions.

\subsubsection{Exercise \label{subsec:Exercise-hof-curried-3}\ref{subsec:Exercise-hof-curried-3}}

Infer types in the following expressions and test in Scala:

\textbf{(a)} $p\rightarrow q\rightarrow r\rightarrow p(q(r))\quad.$

\textbf{(b)} $p\rightarrow q\rightarrow q(r\rightarrow p)\quad.$

\textbf{(c)} $p\rightarrow q\rightarrow q(r\rightarrow q(p))\quad.$

\textbf{(d)} $p\rightarrow q\rightarrow q(r\rightarrow p(q))\quad.$

\textbf{(e)} $p\rightarrow q\rightarrow p(r\rightarrow r(q))\quad.$

\textbf{(f)} $p\rightarrow q\rightarrow q(r\rightarrow r(p(q)))\quad.$

\subsubsection{Exercise \label{subsec:Exercise-hof-curried-4}\ref{subsec:Exercise-hof-curried-4}}

Show that the following expressions \emph{cannot} be well-typed with
simple types (see Example~\ref{subsec:Example-not-typeable} for
reference):

\textbf{(a)} $p\rightarrow q\rightarrow p(q)(p(q))\quad.$

\textbf{(b)} $p\rightarrow q\rightarrow q(r\rightarrow p(q(r)))\quad.$

\subsubsection{Exercise \label{subsec:Exercise-hof-curried-2}\ref{subsec:Exercise-hof-curried-2}}

Infer types and simplify the following code expressions by symbolic
calculations:

\textbf{(a)} $q\rightarrow\left(x\rightarrow y\rightarrow z\rightarrow x(z)(y(z))\right)\left(a\rightarrow a\right)\left(b\rightarrow b(q)\right)\quad.$

\textbf{(b)} $\left(f\rightarrow g\rightarrow h\rightarrow f(g(h))\right)(x\rightarrow x)\quad.$

\textbf{(c)} $\left(x\rightarrow y\rightarrow x(y)\right)\left(x\rightarrow y\rightarrow x\right)\quad.$

\textbf{(d)} $\left(x\rightarrow y\rightarrow x(y)\right)\left(x\rightarrow y\rightarrow y\right)\quad.$

\textbf{(e)} $x\rightarrow\left(f\rightarrow y\rightarrow f(y)(x)\right)\left(z\rightarrow\_\rightarrow z\right)\quad.$

\textbf{(f)} $z\rightarrow\left(x\rightarrow y\rightarrow x\right)\left(x\rightarrow x(z)\right)(y\rightarrow y(z))\quad.$

\subsubsection{Exercise \label{subsec:Exercise-hof-composition}\ref{subsec:Exercise-hof-composition}}

Infer types and simplify the following code expressions by symbolic
calculations:

\textbf{(a)} $\left(z\rightarrow z+1\right)\bef\left(x\rightarrow y\rightarrow x/y\right)\bef\left(p\rightarrow p(2)\right)\quad.$

\textbf{(b)} $\left(p\rightarrow q\rightarrow p+q+1\right)\bef\left(f\rightarrow f\bef f\right)\bef(x\rightarrow x(1))\quad.$

\subsubsection{Exercise \label{subsec:Exercise-hof-composition-1}\ref{subsec:Exercise-hof-composition-1}}

In the following statements, the types $A$ and $B$ are fixed, and
functions are \emph{not} assumed to be fully parametric in $A$ or
$B$.

\textbf{(a)} Given a function $h^{:A\rightarrow B}$ that satisfies
the law $f^{:A\rightarrow A}\bef h^{:A\rightarrow B}=h^{:A\rightarrow B}$
for any $f^{:A\rightarrow A}$, prove that the function $h$ must
ignore its argument and return a fixed value of type $B$.

\textbf{(b)} We are given two functions $g^{:A\rightarrow A}$ and
$h^{:B\rightarrow B}$. We only know that $g$ and $h$ satisfy the
law $f^{:A\rightarrow B}\bef h^{:B\rightarrow B}=g^{:A\rightarrow A}\bef f^{:A\rightarrow B}$
for any function $f^{:A\rightarrow B}$. Prove that both $g$ and
$h$ must be equal to identity functions of suitable types: $g^{:A\rightarrow A}=\text{id}^{A}$
and $h^{:B\rightarrow B}=\text{id}^{B}$.

Hint: choose $f$ to be a suitable \emph{constant} function\index{constant function}
and substitute $f$ into the given laws.

\section{Discussion and further developments}

\subsection{Higher-order functions}

The \textbf{order\index{order of a function}} of a function is the
number of function arrows (\lstinline!=>!) contained in the type
signature of that function. If a function\textsf{'}s type signature contains
more than one arrow, the function is called a \textbf{\index{higher-order function}higher-order}
function. Higher-order functions take functions as arguments and/or
return functions.

The methods \lstinline!andThen!, \lstinline!compose!, \lstinline!curried!,
and \lstinline!uncurried! are examples of higher-order functions
that take other functions as arguments \emph{and} return new functions.

The following examples illustrate the concept of a function\textsf{'}s \textsf{``}order\textsf{''}.
Consider the code:
\begin{lstlisting}
def f1(x: Int): Int = x + 10
\end{lstlisting}
The function \texttt{}\lstinline!f1! has type signature \texttt{}\lstinline!Int => Int!
and order $1$, so it is \emph{not} a higher-order function.
\begin{lstlisting}
def f2(x: Int): Int => Int = (z => z + x)
\end{lstlisting}
The function \texttt{}\lstinline!f2! has type signature \texttt{}\lstinline!Int => Int => Int!
and is a higher-order function of order $2$. 
\begin{lstlisting}
def f3(g: Int => Int): Int = g(123)
\end{lstlisting}
The function \texttt{}\lstinline!f3! has type signature \texttt{}\lstinline!(Int => Int) => Int!
and is a higher-order function of order $2$.

Note that \texttt{}\lstinline!f2! is a higher-order function only
because its return value is of a function type. An equivalent computation
can be performed by an uncurried function that is \emph{not} higher-order:
\begin{lstlisting}
scala> def f2u(x: Int, z: Int): Int = z + x   // Type signature (Int, Int) => Int
\end{lstlisting}
Unlike \lstinline!f2!, the function \lstinline!f3! \emph{cannot}
be converted to a first-order function because \lstinline!f3! has
an argument of a function type. Converting to an uncurried form cannot
eliminate such arguments.

\subsection{Name shadowing and the scope of bound variables}

Bound variables are introduced in nameless functions whenever an argument
is defined. For example, in the nameless function $x\rightarrow y\rightarrow x+y$,
the bound variables are the curried arguments $x$ and $y$. The variable
$y$ is only defined within the scope $\left(y\rightarrow x+y\right)$
of the inner function; the variable $x$ is defined within the entire
scope of $x\rightarrow y\rightarrow x+y$.

Another way of introducing bound variables in Scala is to write a
\lstinline!val! or a \lstinline!def! within curly braces:
\begin{lstlisting}
val x = {
  val y = 10          // Bound variable `y`.
  y + y * y
}     // Same as `val x = 10 + 10 * 10`.
\end{lstlisting}

A bound variable is invisible outside the scope that defines it. So,
it is easy to rename a bound variable: no outside code could possibly
use it and depend on its value.

However, outside code may define a variable that (by chance) has the
same name as a bound variable inside the scope. Consider an example
from calculus where a function $f$ is defined via an integral:
\[
f(x)=\int_{0}^{x}\frac{dx}{1+x}\quad.
\]
Here, \emph{two} bound variables named $x$ are defined in two scopes:
one in the scope of $f$, another in the scope of the nameless function
$x\rightarrow\frac{1}{1+x}$. The convention in mathematics is to
treat these two $x$\textsf{'}s as two \emph{completely} \emph{different} variables
that just happen to have the same name. In sub-expressions where both
of these bound variables are visible, priority is given to the bound
variable defined in the smaller inner scope. The outer definition
of $x$ is then \textbf{shadowed}\index{shadowed name} (hidden) by
the inner definition of $x$. For this reason, evaluating $f(10)$
will give:
\[
f(10)=\int_{0}^{10}\frac{dx}{1+x}=\log_{e}(11)\approx2.398\quad,
\]
rather than $\int_{0}^{10}\frac{dx}{1+10}=\frac{10}{11}$. The outer
definition $x=10$ is shadowed within the expression $\frac{1}{1+x}$
by the definition of $x$ in the smaller local scope of $x\rightarrow\frac{1}{1+x}$.

Since this is the standard mathematical convention, the same convention
is adopted in functional programming. A variable defined in a function
scope (i.e., a bound variable) will shadow any outside definitions
of a variable with the same name.

Name shadowing is not advisable in practical programming, because
it usually decreases the clarity of code and so invites errors. Consider
the nameless function:
\[
x\rightarrow x\rightarrow x\quad,
\]
and let us decipher this confusing syntax. The symbol $\rightarrow$
groups to the right, so $x\rightarrow x\rightarrow x$ is the same
as $x\rightarrow\left(x\rightarrow x\right)$. It is a function that
takes $x$ and returns $x\rightarrow x$. Since the argument $x$
in $\left(x\rightarrow x\right)$ may be renamed to y without changing
the function, we can rewrite the code to:
\[
x\rightarrow\left(y\rightarrow y\right)\quad.
\]
Having removed name shadowing, we can more easily understand this
code and reason about it. For instance, it becomes clear that this
function ignores its argument $x$ and always returns the same value
(the identity function $y\rightarrow y$). So, we can rewrite $\left(x\rightarrow x\rightarrow x\right)$
as $\left(\_\rightarrow y\rightarrow y\right)$, which is clearer.

\subsection{Operator syntax for function applications}

In mathematics, function applications are sometimes written without
parentheses, for instance: $\cos x$ or $\log z$. Commonly used formulas
such as $2\sin x\cos x$ imply parentheses as $2\cdot(\sin\left(x\right))\cdot(\cos\left(x\right))$.
This convention allows us to treat certain functions as \textsf{``}operators\textsf{''}
that are written without parentheses, similar to the operators of
summation, $\sum_{k}f(k)$, or differentiation, $\frac{d}{dx}f(x)$.

Some programming languages (such as OCaml, Haskell, and F\#) have
adopted this \textsf{``}operator syntax\index{operator syntax}\textsf{''}, making
parentheses optional for all function arguments. In those languages,
\lstinline!f x! means the same as \lstinline!f(x)!.\footnote{The operator syntax has a long history in programming. It is used
in Unix shell commands, for example \lstinline!cp file1 file2!, and
also in the language \lstinline!Tcl!. In LISP-like languages, function
applications are enclosed in parentheses but the arguments are space-separated,
for example \lstinline!(f 10 20)!.} Parentheses are still used, for example, in expressions such as \lstinline!f(g x)!.
For curried functions, function applications group to the left, so
\lstinline!f x y z! means \lstinline!((f x) y) z!. Function applications
group stronger than infix operations, so \lstinline!f x + y! means
\lstinline!(f x) + y!, following the convention used in mathematics
where \textsf{``}$\cos x+y$\textsf{''} groups \textsf{``}$\cos x$\textsf{''} stronger than the infix
\textsf{``}$+$\textsf{''} operation.

This book does not use the \textsf{``}operator syntax\textsf{''} when reasoning about
code. Scala does not support the parentheses-free operator syntax;
parentheses are needed around each curried argument (or a curried
list of arguments).

In programming language theory, curried functions are \textsf{``}simpler\textsf{''}
because they always have a \emph{single} argument (but may return
a function that will consume further arguments). From the point of
view of programming practice, curried functions are often harder to
read and to write.

In the operator syntax, a curried function \lstinline!f! is applied
to curried arguments as, e.g., \lstinline!f 20 4!. This departs further
from the mathematical tradition and requires some getting used to.
If the two arguments are more complicated than just $20$ and $4$,
the resulting expression may become harder to read, compared with
the syntax where commas are used to separate the arguments. (Consider,
for instance, the expression \lstinline!f (g 10) (h 20) + 30!.) To
improve readability of code, programmers may prefer to define names
for complicated expressions and then use those names as curried arguments.

In Scala, the choice of whether to use curried or uncurried function
signatures is mostly a matter of syntactic convenience. Most Scala
code seems to be written with uncurried functions.

One of the syntactic features of Scala is the ability to give a curried
argument using the curly brace syntax. Compare the two definitions
of the function \lstinline!summation! described in Section~\ref{subsec:Nameless-functions-in-mathematical-notation}:
\begin{lstlisting}
def summation1(a: Int, b: Int, g: Int => Double): Double = (a to b).map(g).sum

def summation2(a: Int, b: Int)(g: Int => Double): Double = (a to b).map(g).sum
\end{lstlisting}
These functions are applied to arguments like this:
\begin{lstlisting}
scala> summation1(1, 10, { x => x * x * x + 2 * x })
res0: Double = 3135.0

scala> summation2(1, 10) { x => x * x * x + 2 * x }
res1: Double = 3135.0
\end{lstlisting}
The code that calls \lstinline!summation2! is easier to read because
the curried argument is syntactically separated from the rest of the
code by curly braces. This is especially useful when the curried argument
is itself a function with a complicated body, since Scala\textsf{'}s curly
braces syntax allows function bodies to contain local definitions
(\lstinline!val! or \lstinline!def!) of new bound variables.

Another feature of Scala is the \textsf{``}dotless\textsf{''} method syntax: for example,
\lstinline!xs map f! is equivalent to \lstinline!xs.map(f)! and
\lstinline!f andThen g! is equivalent to \lstinline!f.andThen(g)!.
The \textsf{``}dotless\textsf{''} syntax is available only for infix methods, such
as \lstinline!map!, defined on specific types such as \lstinline!Seq!.
In Scala 3, the \textsf{``}dotless\textsf{''} syntax is generally enabled by the \lstinline!infix def!
annotation. Do not confuse Scala\textsf{'}s \textsf{``}dotless\textsf{''} method syntax with
the operator syntax used in Haskell and other languages.

\subsection{Deriving a function\textsf{'}s code from its type\label{subsec:Deriving-a-function-s-code}}

We have seen how the procedure of type inference\index{type inference}
derives the type signature from a function\textsf{'}s code. A well-known algorithm
for type inference is the Damas-Hindley-Milner algorithm,\footnote{See \texttt{\href{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system}{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner\_type\_system}}}
with a Scala implementation available.\footnote{See \texttt{\href{http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/}{http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/}}}

It is remarkable that one can sometimes perform \textsf{``}\index{code inference}code
inference\textsf{''}: derive a function\textsf{'}s \emph{code} from the function\textsf{'}s
type signature. We will now look at some examples of this.

Consider a fully parametric function that performs partial applications\index{partial application}
for arbitrary other functions. A possible type signature is:
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = ???
\end{lstlisting}

How can we implement \lstinline!pa!? Since \lstinline!pa(x)(f)!
must return a function of type \lstinline!B => C!, we have no choice
other than to begin writing a nameless function in the code:
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y: B =>
  ??? // Need to compute a value of type C in this scope.
}
\end{lstlisting}
In the inner scope, we need to compute a value of type \lstinline!C!,
and we have values \lstinline!x: A!, \lstinline!y: B!, and \lstinline!f: (A, B) => C!.
How can we compute a value of type \lstinline!C!? If we knew that
\lstinline!C = Int! when \lstinline!pa(x)(f)! is applied, we could
have simply selected a fixed integer value, say, \lstinline!1!, as
the value of type \lstinline!C!. If we knew that \lstinline!C = String!,
we could have selected a fixed string, say, \lstinline!"hello"!,
as the value of type \lstinline!C!. But a fully parametric function
cannot use any knowledge of the types of its actual arguments.

So, a fully parametric function cannot produce a value of an arbitrary
type \lstinline!C! from scratch. The only way of producing a value
of type \lstinline!C! is by applying the function \lstinline!f!
to arguments of types \lstinline!A! and \lstinline!B!. Since the
types \lstinline!A! and \lstinline!B! are arbitrary, we cannot obtain
any values of these types other than \lstinline!x: A! and \lstinline!y: B!.
So, the only way of getting a value of type \lstinline!C! is to compute
\lstinline!f(x, y)!. Thus, the body of \lstinline!pa! must be:
\begin{lstlisting}
def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y => f(x, y) }
\end{lstlisting}
In this way, we have \emph{unambiguously} derived the body of this
function from its type signature, by assuming that the function must
be fully parametric.

Another example is the operation of forward composition $f\bef g$
viewed as a fully parametric function with type signature:
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = ???
\end{lstlisting}
To implement \lstinline!before!, we need to create a nameless function
of type \lstinline!A => C!:
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = { x: A =>
  ??? // Need to compute a value of type C in this scope.
}
\end{lstlisting}
In the inner scope, we need to compute a value of type $C$ from the
values $x^{:A}$, $f^{:A\rightarrow B}$, and $g^{:B\rightarrow C}$.
Since the type $C$ is arbitrary, the only way of obtaining a value
of type $C$ is by applying $g$ to an argument of type $B$. In turn,
the only way of obtaining a value of type $B$ is to apply $f$ to
an argument of type $A$. Finally, we have only one value of type
$A$, namely $x^{:A}$. So, the only way of obtaining the required
result is to compute $g(f(x))$.

We have derived the body of the function from its type signature:
\begin{lstlisting}
def before[A, B, C](f: A => B, g: B => C): A => C = { x => g(f(x)) }
\end{lstlisting}

Chapter~\ref{chap:5-Curry-Howard} will show how code can be derived
from type signatures for a wide range of fully parametric functions.
