
\appendix

\chapter{Notations\label{chap:Appendix-Notations}}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%
\global\long\def\pplus{{\displaystyle }{+\negmedspace+}}%
This book chooses certain notations differently from what the functional
programming community currently uses. The proposed notation is well
adapted to reasoning about types and code, and especially for designing
data types and proving the laws of various typeclasses.

\section{Summary of notations}
\begin{description}
\item [{$A$}] \textemdash{} type parameter. Names of type parameters are
always capitalized.
\item [{$F^{A}$}] \textemdash{} type constructor $F$ with type argument
$A$. In Scala, \lstinline!F[A]!
\item [{$F^{\bullet}$}] \textemdash{} the type constructor $F$ understood
as a type-level function. In Scala, \lstinline!F[_]! 
\item [{$x^{:A}$}] \textemdash{} value $x$ has type $A$; in Scala, \lstinline!x:A!.
Value names are always in lowercase.
\item [{$\bbnum 1,\,1$}] \textemdash{} the unit type and its value; in
Scala, \lstinline!Unit! and \lstinline!()!
\item [{$\bbnum 0$}] \textemdash{} the void type. In Scala, \lstinline!Nothing!
\item [{$A+B$}] \textemdash{} a disjunctive type (co-product). In Scala,
this type is \lstinline!Either[A, B]! 
\item [{$x^{:A}+\bbnum 0^{:B}$}] \textemdash{} a value of a disjunctive
type $A+B$. In Scala, \lstinline!Left(x)!
\item [{$A\times B$}] \textemdash{} a product (tuple) type. In Scala,
this type is \lstinline!(A, B)!
\item [{$a^{:A}\times b^{:B}$}] value of a tuple type $A\times B$. In
Scala, \lstinline!(a, b)!
\item [{$A\rightarrow B$}] \textemdash{} the function type, mapping from
$A$ to $B$
\item [{$x^{:A}\rightarrow f$}] \textemdash{} a nameless function (as
a value). In Scala, \lstinline!{ x: A => f }!
\item [{$\text{id}$}] \textemdash{} an identity function; in Scala, \lstinline!identity[A]!
\item [{$\triangleq$}] \textemdash{} \textsf{``}is defined to be\textsf{''} or \textsf{``}is equal
by definition\textsf{''}
\item [{$\overset{!}{=}$}] \textemdash{} \textsf{``}must be equal according to
what we know\textsf{''}
\item [{$\overset{?}{=}$}] \textemdash{} \textsf{``}we ask \textemdash{} is it
equal? \textemdash{} because we still need to prove that\textsf{''}
\item [{$\square$}] \textemdash{} \textsf{``}this proof or this derivation or
this definition or this example is finished\textsf{''}
\item [{$\cong$}] \textemdash{} for types, a natural isomorphism between
types; for values, \textsf{``}equivalent\textsf{''} values according to an already
established isomorphism
\item [{$A^{:F^{B}}$}] \textemdash{} special type annotation, used for
defining GADTs
\item [{$\wedge$}] \textemdash{} logical conjunction; $\alpha\wedge\beta$
means \textsf{``}both $\alpha$ and $\beta$ are true\textsf{''}
\item [{$\vee$}] \textemdash{} logical disjunction; $\alpha\vee\beta$
means \textsf{``}either $\alpha$ or $\beta$ or both are true\textsf{''}
\item [{$\Rightarrow$}] \textemdash{} logical implication; $\alpha\Rightarrow\beta$
means \textsf{``}if $\alpha$ is true then $\beta$ is true\textsf{''}
\item [{$\text{fmap}_{F}$}] \textemdash{} the standard method \lstinline!fmap!
of a functor $F$. In Scala, \lstinline!Functor[F].fmap!
\item [{$\text{flm}_{F},\text{ftn}_{F},\text{pu}_{F}$}] \textemdash{}
the standard methods \lstinline!flatMap!, \lstinline!flatten!, and
\lstinline!pure! of a monad $F$
\item [{$F\leadsto G$}] \textemdash{} a natural transformation between
functors $F$ and $G$. In Scala, \lstinline!F ~> G!
\item [{$\forall A.\,P^{A}$}] \textemdash{} a universally quantified type
expression. In Scala 3, \lstinline![A] => P[A]!
\item [{$\exists A.\,P^{A}$}] \textemdash{} an existentially quantified
type expression. In Scala, \lstinline!{ type A; val x: P[A] }! 
\item [{$f\bef g$}] \textemdash{} the forward composition of functions:
$f\bef g$ is $x\rightarrow g(f(x))$. In Scala, \lstinline!f andThen g!
\item [{$f\circ g$}] \textemdash{} the backward composition of functions:
$f\circ g$ is $x\rightarrow f(g(x))$. In Scala, \lstinline!f compose g!
\item [{$F\circ G$}] \textemdash{} the backward composition of type constructors:
$(F\circ G)^{A}\triangleq F^{G^{A}}$. In Scala, \lstinline!F[G[A]]! 
\item [{$\triangleright$}] \textemdash{} use a value as the argument of
a function: $x\triangleright f$ is $f(x)$. In Scala, \lstinline!x.pipe(f)!
\item [{$f^{\uparrow G}$}] \textemdash{} a function $f$ lifted to a functor
$G$; same as $\text{fmap}_{G}(f)$
\item [{$f^{\uparrow G\uparrow H}$}] \textemdash{} a function lifted first
to $G$ and then to $H$. In Scala, \lstinline!h.map(_.map(f))! 
\item [{$f^{\downarrow H}$}] \textemdash{} a function $f$ lifted to a
contrafunctor $H$ 
\item [{$S^{\bullet,T}$}] \textemdash{} the type constructor defined by
fixing one of the type parameters of another type constructor. For
instance: $(S^{\bullet,T})^{A}\triangleq S^{A,T}$. In Scala, \lstinline!S[*, T]!.
Similarly, $(S^{A,\bullet})^{B}\triangleq S^{A,B}$. 
\item [{$\diamond_{M}$}] \textemdash{} the Kleisli composition operation
for the monad $M$
\item [{$L\varangle M$}] or equivalently $T_{L}^{M}$ \textemdash{} the
monad $L$\textsf{'}s transformer applied to a monad $M$
\item [{$\oplus$}] \textemdash{} the binary operation of a monoid. In
Scala, \lstinline!x |+| y!
\item [{$\Delta$}] \textemdash{} the standard \textsf{``}diagonal\textsf{''} function
of type $\forall A.\,A\rightarrow A\times A$
\item [{$\pi_{1},\pi_{2},...$}] \textemdash{} the projections from a tuple
to its first, second, ..., parts
\item [{$\boxtimes$}] \textemdash{} pair product of functions: $(f\boxtimes g)(a\times b)\triangleq f(a)\times g(b)$,
also applies to relations
\item [{$\boxplus$}] \textemdash{} pair co-product of functions or relations
\item [{$\ogreaterthan$}] \textemdash{} pair mapper of relations
\item [{$\left[a,b,c\right]$}] \textemdash{} an ordered sequence of values.
In Scala, \lstinline!Seq(a, b, c)!
\item [{$\begin{array}{||cc|}
x\rightarrow x & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}$}] ~ \textemdash{} a function that works with disjunctive types
(a \textsf{``}\index{disjunctive functions}disjunctive function\textsf{''})
\end{description}

\section{Detailed explanations}

$F^{A}$ means a type constructor $F$ with a type parameter $A$.
In Scala, this is \lstinline!F[A]!. Type parameters are uppercase
($A$, $B$, ...). Type constructors with multiple type parameters
are denoted by $F^{A,B,C}$. Nested type constructors such as Scala\textsf{'}s
\lstinline!F[G[A]]! are denoted by $F^{G^{A}}$, meaning $F^{(G^{A})}$.

$x^{:A}$ means a value $x$ that has type $A$; this is a \textbf{\index{type annotation}type
annotation}. In Scala, a type annotation is \lstinline!x:A!. The
colon symbol, $:$, in the superscript shows that $A$ is not a type
argument (as it would be in a type constructor, $F^{A}$). A less
concise notation for $x^{:A}$ is $x:A$.

$\bbnum 1$ means the unit type\index{unit type}, and $1$ means
the value of the unit type. In Scala, the unit type is \lstinline!Unit!,
and its value is \lstinline!()!. An example of this notation is $\bbnum 1+A$,
which corresponds to \lstinline!Option[A]! in Scala.

$\bbnum 0$ means the void\index{void type} type (the type with no
values). In Scala, this is the type \lstinline!Nothing!. The notation
$\bbnum 0$ is often used to denote an empty part of disjunctive types
or values. E.g., the disjunctive type \lstinline!Option[A]! has two
parts: \lstinline!Some[A]! and \lstinline!None!. These types are
denoted by $\bbnum 0+A$ and $\bbnum 1+\bbnum 0$ respectively. Similarly,
$A+\bbnum 0$ denotes the first part of the type $A+B$ (in Scala,
\lstinline!Left[A]!), while $\bbnum 0+B$ denotes its second part
(in Scala, \lstinline!Right[A]!). Values of disjunctive types are
denoted similarly. E.g., $x^{:A}+\bbnum 0^{:B}$ denotes a value of
the left part of the type $A+B$. In Scala, this value is written
with fully annotated types as \lstinline!Left[A,B](x)!.

$A+B$ means the disjunctive type made from types $A$ and $B$. In
Scala, this is the type \texttt{}\lstinline!Either[A, B]!.

$x^{:A}+\bbnum 0^{:B}$ denotes a value of a disjunctive type $A+B$,
where $x$ is the value of type $A$, which is the chosen case, and
$\bbnum 0$ stands for other possible cases. For example, $x^{:A}+\bbnum 0^{B}$
is \lstinline!Left[A,B](x)! in Scala. Type annotations $^{:A}$ and
$^{:B}$ may be omitted if the types are unambiguous from the context.

$A\times B$ means the product type made from types $A$ and $B$.
In Scala, this is the tuple type \lstinline!(A,B)!.

$a^{:A}\times b^{:B}$ means a value of a tuple type $A\times B$;
in Scala, this is the tuple value \lstinline!(a, b)!. Type annotations
$^{:A}$ and $^{:B}$ may be omitted if the types are unambiguous
from the context.

$A\rightarrow B$ means the type of functions $A$ to $B$. In Scala,
this is the type \lstinline!A => B!. The function type\textsf{'}s arrow binds
weaker than $+$, which binds weaker than $\times$. So, $A+B\rightarrow C\times D$
means $(A+B)\rightarrow(C\times D)$.

$x^{:A}\rightarrow y$ means a nameless function with argument $x$
of type $A$ and function body $y$. (Usually, the body $y$ will
be an expression that uses $x$. In Scala, this is \lstinline!{ x: A => y }!.
Type annotation $^{:A}$ may be omitted if the type is unambiguous
from the context.

$\text{id}$ means the identity function. The type of its argument
should be either specified as $\text{id}^{A}$ or $\text{id}^{:A\rightarrow A}$,
or else should be unambiguous from the context. In Scala,  \lstinline!identity[A]!
corresponds to $\text{id}^{A}$.

$\triangleq$ means \textsf{``}equal by definition\textsf{''}. A definition of a function
$f$ is written as $f\triangleq(x^{:\text{Int}}\rightarrow x+10)$;
in Scala, this is \lstinline!val f = { x: Int => x + 10 }!. A definition
of a type constructor $F$ is written as $F^{A}\triangleq\bbnum 1+A$;
in Scala, this is \lstinline!type F[A] = Option[A]!.

$\cong$ for types means an equivalence (an isomorphism) of types.
For example, $A+A\times B\cong A\times\left(\bbnum 1+B\right)$. The
same symbol $\cong$ for \emph{values} means \textsf{``}equivalent\textsf{''} according
to an equivalence relation that needs to be established in the text.
For example, if we have established an equivalence that allows nested
tuples to be reordered whenever needed, we can write $\left(a\times b\right)\times c\cong a\times\left(b\times c\right)$,
meaning that these values are mapped to each other by the established
isomorphism functions. 

$A^{:F^{B}}$ in type definitions means that the definition assigns
the type $F^{B}$ to the type expression $A$. This notation is used
for defining GADTs. For example, the Scala code:

\begin{lstlisting}
sealed trait F[A]
case class F1() extends F[Int]
case class F2[A](a: A) extends F[(A, String)]
\end{lstlisting}
defines a GADT\index{GADT} written in type notation as $F^{A}\triangleq\bbnum 1^{:F^{\text{Int}}}+A^{:F^{A\times\text{String}}}$.

$\wedge$ (conjunction), $\vee$ (disjunction), and $\Rightarrow$
(implication) are used in formulas of Boolean as well as constructive
logic in Chapter~\ref{chap:5-Curry-Howard}, e.g., $\alpha\wedge\beta$,
where Greek letters stand for logical propositions.

$\text{fmap}_{F}$ is a functor $F$\textsf{'}s the standard method \lstinline!fmap!
of the \lstinline!Functor! typeclass. In Scala, this may be written
as \texttt{}\lstinline!Functor[F].fmap!. Since each functor $F$
has its own specific implementation of $\text{fmap}_{F}$, the subscript
\textsf{``}$F$\textsf{''} is \emph{not} a type parameter of $\text{fmap}_{F}$. The
function $\text{fmap}_{F}$ has two type parameters, which may be
written as $\text{fmap}_{F}^{A,B}$, and we may write its type signature
as $\text{fmap}_{F}^{A,B}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}$.
In most cases, the type parameters $A$, $B$ can be omitted without
loss of clarity.

$\text{pu}_{F}$ denotes a monad $F$\textsf{'}s method \lstinline!pure!.
This function has type signature $A\rightarrow F^{A}$ and has a type
parameter $A$. In the code notation, the type parameter may be either
omitted or denoted as $\text{pu}_{F}^{A}$. If we are using \lstinline!pure!
with a complicated type, e.g., $\bbnum 1+P^{B}$, as of the type parameter
$A$, we may write the type parameter for clarity as $\text{pu}_{F}^{\bbnum 1+P^{B}}$.
The type signature of that function then becomes: 
\[
\text{pu}_{F}^{1+P^{B}}:\bbnum 1+P^{B}\rightarrow F^{\bbnum 1+P^{B}}\quad.
\]
But in most cases we will not need to write out the type parameters.

$\text{flm}_{F}$ denotes the curried version of a monad $F$\textsf{'}s method
\lstinline!flatMap!. The type signature of $\text{flm}_{F}$ is $\text{flm}_{F}:(A\rightarrow F^{B})\rightarrow F^{A}\rightarrow F^{B}$.
Note that Scala\textsf{'}s standard \lstinline!flatMap! type signature is
not curried. The curried method $\text{flm}_{F}$ is easier to use
in calculations involving the monad laws.

$\text{ftn}_{F}$ denotes a monad $F$\textsf{'}s method \lstinline!flatten!
with the type signature $\text{ftn}_{F}:F^{F^{A}}\rightarrow F^{A}$.

$F^{\bullet}$ means the type constructor $F$ understood as a type-level
function, \textemdash{} that is, with a type parameter unspecified.
In Scala, this is \lstinline!F[_]!. The bullet symbol, $\bullet$,
is a placeholder for the missing type parameter. When the type parameter
$B$ of a bifunctor $P^{A,B}$ is fixed as $B=Z$, we get a functor
(with respect to $A$) denoted by $P^{\bullet,Z}$. In Scala, this
is written using the \textsf{``}kind projector\textsf{''}\index{kind@\textsf{``}kind projector\textsf{''} plugin}
plugin\footnote{\texttt{\href{https://github.com/typelevel/kind-projector}{https://github.com/typelevel/kind-projector}}}
syntax as \lstinline!Lambda[A => P[A, Z]]!. Another example: $T_{L}^{M,\bullet}$
denotes a monad transformer for the base monad $L$ and the foreign
monad $M$. The foreign monad $M$ is a type parameter in $T_{L}^{M,\bullet}$.
The symbol $\bullet$ stands for the transformer\textsf{'}s second type parameter.
(The base monad $L$ is not a type parameter in $T_{L}^{M,\bullet}$
because the construction of the monad transformer depends on the internal
details of $L$.)

$F\leadsto G$ means a natural transformation between two functors
$F$ and $G$. In some Scala libraries, this is denoted by \lstinline!F ~> G!.

$\forall A.\,P^{A}$ is a universally quantified type expression,
in which $A$ is a bound type parameter.

$\exists A.\,P^{A}$ is an existentially quantified type expression,
in which $A$ is a bound type parameter.

$\bef$ means the forward composition\index{forward composition}
of functions: $f\bef g$ (reads \textsf{``}$f$ before $g$\textsf{''}) is the function
defined as $x\rightarrow g(f(x))$.

$\circ$ means the backward composition\index{backward composition}
of functions: $f\circ g$ (reads \textsf{``}$f$ after $g$\textsf{''}) is the function
defined as $x\rightarrow f(g(x))$.

$\circ$ with type constructors means their (backward) composition,
for example $F\circ G$ denotes the type constructor $F^{G^{\bullet}}$.
In Scala, this is \lstinline!F[G[A]]!. 

$x\triangleright f$ (the \textbf{pipe notation})\index{pipe notation}\index{\$@$\triangleright$-notation!see \textsf{``}pipe notation\textsf{''}}
is a different syntax for $f(x)$. The value $x$ is passed as the
argument to the function $f$. In Scala, the expression $x\triangleright f$
is written as \lstinline!x.pipe(f)! or, if \lstinline!f! is a method,
\lstinline!x.f!. This syntax is used with many standard methods such
as \lstinline!size! or \lstinline!toSeq!. Because the argument $x$
is to the left of the function $f$ in this notation, forward compositions
of functions such as $x\triangleright f\triangleright g$ are naturally
grouped to the left as it is done in Scala code, for example \lstinline!x.toSeq.sorted!.
The operation $\triangleright$ (pronounced \textsf{``}pipe\textsf{''}) groups weaker
than the forward composition ($\bef$), and so we have $x\triangleright f\bef g=x\triangleright f\triangleright g$
in this notation. Reasoning about code in the pipe notation uses the
identities:
\begin{align*}
x\triangleright f=f(x)\quad,\quad\quad & \left(x\triangleright f\right)\triangleright g=x\triangleright f\triangleright g\quad,\\
x\triangleright f\bef g=x\triangleright\left(f\bef g\right)\quad,\quad\quad & x\triangleright f\triangleright g=x\triangleright f\bef g\quad.
\end{align*}
The pipe symbol groups stronger than the function arrow, so $x\rightarrow y\triangleright f$
is the same as $x\rightarrow(y\triangleright f)$. Here are some examples
of reasoning with functions in the pipe notation:
\begin{align*}
 & \left(a\rightarrow a\triangleright f\right)=\left(a\rightarrow f(a)\right)=f\quad,\\
 & f\triangleright\left(y\rightarrow a\triangleright y\right)=a\triangleright f=f(a)\quad,\\
 & f(y(x))=x\triangleright y\triangleright f\neq x\triangleright\left(y\triangleright f\right)=f(y)(x)\quad.
\end{align*}
The correspondence between the forward composition and the backward
composition:
\begin{align*}
 & f\bef g=g\circ f\quad,\\
 & x\triangleright(f\bef g)=x\triangleright f\bef g=x\triangleright f\triangleright g=g(f(x))=(g\circ f)(x)\quad.
\end{align*}

$f^{\uparrow G}$ means a function $f$ lifted to a functor $G$.
For a function $f^{:A\rightarrow B}$, the application of $f^{\uparrow G}$
to a value $g^{:G^{A}}$ is written as $f^{\uparrow G}(g)$ or as
$g\triangleright f^{\uparrow G}$. In Scala, this is \lstinline!g.map(f)!.
Nested lifting (i.e., lifting to the functor composition $H\circ G$)
can be written as $f^{\uparrow G\uparrow H}$, which means $\left(f^{\uparrow G}\right)^{\uparrow H}$,
and produces a function of type $H^{G^{A}}\rightarrow H^{G^{B}}$.
Applying a nested lifting to a value $h$ of type $H^{G^{A}}$ is
written as $h\triangleright f^{\uparrow G\uparrow H}$. In Scala,
this is \lstinline!h.map(_.map(f))!. The functor composition law
is written as:
\[
p^{\uparrow G}\bef q^{\uparrow G}=\left(p\bef q\right)^{\uparrow G}\quad.
\]
The notation $x\triangleright p^{\uparrow G}\triangleright q^{\uparrow G}$
is intended to be similar to the Scala code \lstinline!x.map(p).map(q)!.

$f^{\downarrow H}$ means a function $f$ lifted to a contrafunctor
$H$. For a function $f^{:A\rightarrow B}$, the application of $f^{\downarrow H}$
to a value $h:H^{B}$ is written as $h\triangleright f^{\downarrow H}$
and yields a value of type $H^{A}$. In Scala, this may be written
as \lstinline!h.contramap(f)!. Repeated lifting is denoted as, e.g.,
$f^{\downarrow H\uparrow G}\triangleq(f^{\downarrow H})^{\uparrow G}$.

$\diamond_{M}$ means the Kleisli composition operation for a given
monad $M$. This is a binary operation working on two Kleisli functions
of types $A\rightarrow M^{B}$ and $B\rightarrow M^{C}$ and yields
a new function of type $A\rightarrow M^{C}$.

$L\varangle M$ denotes the monad $L$\textsf{'}s transformer applied to a
foreign monad $M$. We define $(K\varangle L)\varangle M\triangleq K\varangle(L\varangle M)$,
which makes the monad transformer application into an associative
operation.

$\oplus$ means the binary operation of a monoid, e.g., $x\oplus y$.
For this expression to make sense, a specific monoid type should be
defined . In Scala libraries, $x\oplus y$ is often denoted as \lstinline!x |+| y!.

$\Delta$ means the standard \textsf{``}diagonal\textsf{''} function of type $\forall A.\,A\rightarrow A\times A$,
i.e., $\Delta\triangleq a^{:A}\rightarrow a\times a$. In Scala:
\begin{lstlisting}
def delta[A](a: A): (A, A) = (a, a)
\end{lstlisting}

$\pi_{1},\pi_{2},...$ denote the functions extracting the first,
second, ..., parts in a tuple. In Scala, $\pi_{1}$ is \lstinline!(_._1)!.

$\boxtimes$ means the pair product\index{pair product of functions}
of functions, defined by $(f\boxtimes g)(a\times b)=f(a)\times g(b)$.
In Scala, the pair product can be implemented as a higher-order function:
\begin{lstlisting}
def pair_product[A,B,P,Q](f: A => P, g: B => Q): ((A, B)) => (P, Q) = {
  case (a, b) => (f(a), g(b))
}
\end{lstlisting}
The operations $\Delta$, $\pi_{i}$ (where $i=1,2,...$), and $\boxtimes$
allow us to express any function operating on tuples. Useful properties
for reasoning about code of such functions: 
\begin{align*}
{\color{greenunder}\text{identity law}:}\quad & \Delta\bef\pi_{i}=\text{id}\quad,\\
{\color{greenunder}\text{naturality law}:}\quad & f\bef\Delta=\Delta\bef(f\boxtimes f)\quad,\\
{\color{greenunder}\text{left and right projection laws}:}\quad & (f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f\quad,\quad\quad(f\boxtimes g)\bef\pi_{2}=\pi_{2}\bef g\quad,\\
{\color{greenunder}\text{composition law}:}\quad & (f\boxtimes g)\bef(p\boxtimes q)=(f\bef p)\boxtimes(g\bef q)\quad,
\end{align*}
as well as the functor lifting laws for $\Delta$ and $\pi_{i}$:
\begin{align*}
 & f^{\uparrow F}\bef\Delta=\Delta\bef f^{\uparrow(F\times F)}=\Delta\bef(f^{\uparrow F}\boxtimes f^{\uparrow F})\quad,\\
 & (f^{\uparrow F}\boxtimes f^{\uparrow G})\bef\pi_{1}=f^{\uparrow(F\times G)}\bef\pi_{1}=\pi_{1}\bef f^{\uparrow F}\quad.
\end{align*}

$\left[a,b,c\right]$ means an ordered sequence of values, such as
a list or an array. In Scala, this can be \lstinline!List(a, b, c)!,
\lstinline!Vector(a, b, c)!, \lstinline!Array(a, b, c)!, or another
collection type.

$f^{:Z+A\rightarrow Z+A\times A}\triangleq\,\begin{array}{||cc|}
z\rightarrow z & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,\,$ is the \textbf{matrix notation}\index{matrix notation} for a function
whose input and/or output type is a disjunctive type (\index{disjunctive functions}a
\textbf{disjunctive function}). In Scala, the function $f$ is written
as:
\begin{lstlisting}
def f[Z, A]: Either[Z, A] => Either[Z, (A, A)] = {
  case Left(z)   => Left(z)       // Identity function on Z.
  case Right(a)  => Right((a, a)) // Delta on A.
}
\end{lstlisting}
The rows of the matrix indicate the different \lstinline!case!s in
the function\textsf{'}s code, corresponding to the different parts of the input
disjunctive type. If the input type is not disjunctive, there will
be only one row. The columns of the matrix indicate the parts of the
output disjunctive type. If the output type is not disjunctive, there
will be only one column.

A matrix may show all parts of the disjunctive types in separate \textsf{``}type
row\textsf{''} and \textsf{``}type column\textsf{''}:
\begin{equation}
f^{:Z+A\rightarrow Z+A\times A}\triangleq\,\begin{array}{|c||cc|}
 & Z & A\times A\\
\hline Z & \text{id} & \bbnum 0\\
A & \bbnum 0 & a\rightarrow a\times a
\end{array}\quad.
\end{equation}
This notation clearly indicates the input and the output types of
the function and is useful for reasoning about the code. The vertical
double line separates the \emph{input} types from the function code
(output types have a single line). In the code above, the \textsf{``}type
column\textsf{''} shows the parts of the input disjunctive type $Z+A$. The
\textsf{``}type row\textsf{''} shows the parts of the output disjunctive type $Z+A\times A$.

The matrix notation is adapted to \emph{forward} function composition
($f\bef g$). Assume that $A$ is a monoid type, and consider the
composition of the function $f$ shown above and the function $g$
defined as:
\begin{lstlisting}
def g[Z, A: Monoid]: Either[Z, (A, A)] => A = {
  case Left(_)          => Monoid[A].empty
  case Right((a1, a2))  => a1 |+| a2
}
\end{lstlisting}
In the matrix notation, the function $g$ is written (with and without
types) as:
\[
g\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline Z & \_\rightarrow e^{:A}\\
A\times A & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad,\quad\quad g\triangleq\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad.
\]
The forward composition $f\bef g$ is computed by forward-composing
the matrix elements using the rules of the ordinary matrix multiplication,
omitting any terms containing $\bbnum 0$:
\begin{align*}
f\bef g & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,\bef\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\\
 & =\,\,\begin{array}{||c|}
\text{id}\bef(\_\rightarrow e^{:A})\\
\left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)
\end{array}\,=\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}\quad.
\end{align*}
Applying a function to a disjunctive value such as $x^{:Z+A}$ is
computed by writing $x$ as a row vector:
\[
x=z^{:Z}+\bbnum 0^{:A}=\,\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\quad.
\]
Then the computation $x\triangleright f\bef g$ again follows the
rules of matrix multiplication:
\[
x\triangleright f\bef g=\,\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}\,=z\triangleright(\_\rightarrow e)=e\quad.
\]
Since the standard rules of matrix multiplication are associative,
the properties of the $\triangleright$-notation such as $x\triangleright(f\bef g)=(x\triangleright f)\triangleright g$
are guaranteed to hold with matrices.

To use the matrix notation with \emph{backward} compositions ($f\circ g$),
all code matrices need to be transposed. (A standard identity of matrix
calculus is that the transposition reverses the order of composition:
$\left(AB\right)^{T}=B^{T}A^{T}$.) The input types will then appear
in the \emph{top} \emph{row} and the output types in the left column.
The double line is at the top of a code matrix since that is where
the function inputs come from. The above calculations are then rewritten
as:
\begin{align*}
g\circ f & =\,\begin{array}{|c|cc|}
 & Z & A\times A\\
\hline\hline A & \_\rightarrow e^{:A} & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\,\circ\,\begin{array}{|c|cc|}
 & Z & A\\
\hline\hline Z & \text{id} & \bbnum 0\\
A\times A & \bbnum 0 & a\rightarrow a\times a
\end{array}\\
 & =\,\,\begin{array}{|cc|}
\hline\hline \text{id}\bef(\_\rightarrow e^{:A}) & \left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)\end{array}\,=\,\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\quad.\\
(g\circ f)(x) & =\,\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\,\,\begin{array}{|c|}
z^{:Z}\\
\bbnum 0
\end{array}\,=(\_\rightarrow e^{:A})(z)=e\quad.
\end{align*}
The \emph{forward} composition ($\bef$) may be easier to read and
to reason about in the matrix notation.

\chapter{Glossary of terms\label{chap:Appendix-Glossary-of-terms}}
\begin{description}
\item [{Code~notation}] \index{code notation}A mathematical notation
developed in this book for deriving properties of code in functional
programs. Variables have optional type annotations, such as $x^{:A}$
or $f^{:A\rightarrow B}$. Nameless functions are denoted by$x^{:A}\rightarrow f$,
products by $a\times b$, and values of a disjunctive type $A+B$
are written as $x^{:A}+\bbnum 0^{:B}$ or $\bbnum 0^{:A}+y^{:B}$.
Functions working with disjunctive types are denoted by matrices.
Lifting of functions to functors, such as $\text{fmap}_{L}(f)$, is
denoted by $f^{\uparrow L}$; function compositions are denoted by
$f\bef g$ (forward composition) and $f\circ g$ (backward composition);
and function applications by $f(x)$ or equivalently $x\triangleright f$.
See Appendix~\ref{chap:Appendix-Notations} for details.
\item [{\index{contrafunctor}Contrafunctor}] A type constructor having
the properties of a contravariant functor\index{contrafunctor} with
respect to a type parameter. Instead of \textsf{``}contravariant functor\textsf{''},
this book uses the shorter name \textsf{``}contrafunctor\textsf{''}.
\item [{Disjunctive~type}] \index{disjunctive type}A type representing
one of several distinct possibilities. In Scala, this is usually implemented
as a sealed trait extended by several case classes. The standard Scala
disjunction types are \lstinline!Option[A]! and \lstinline!Either[A, B]!.
Also known as \index{sum type!see \textsf{``}disjunctive type\textsf{''}}\textbf{sum
}type, \textbf{tagged union}\index{tagged union!see \textsf{``}disjunctive type\textsf{''}}
type, \textbf{co-product}\index{co-product type!see \textsf{``}disjunctive type\textsf{''}}
type, and variant type (in Object Pascal and in OCaml). The shortest
name is \textsf{``}sum type,\textsf{''} but the word \textsf{``}disjunctive\textsf{''} is less ambiguous
to the ear than the word \textsf{``}sum\textsf{''}.
\item [{Exponential-polynomial~type}] \index{exponential-polynomial type}A
type constructor built using products, disjunctions (sums or co-products),
and function types (\textsf{``}exponentials\textsf{''}), as well as type parameters
and fixed types. For example,  \lstinline!type F[A] = Either[(A, A), Int => A]!
is an exponential-polynomial type constructor. Such type constructors
are always profunctors and can also be functors or contrafunctors.
\item [{\index{functor block}Functor~block}] A short syntax for composing
several \lstinline!map!, \lstinline!flatMap!, and \lstinline!filter!
operations applied to a functor-typed value. The type constructor
corresponding to that value must be a functor and is fixed throughout
the entire functor block. For example, the Scala code:
\begin{lstlisting}
for { x <- List(1,2,3); y <- List(10, x); if y > 2 }
  yield 2 * y
\end{lstlisting}
is equivalent to the code:
\begin{lstlisting}
List(1, 2, 3).flatMap(x => List(10, x))
  .filter(y => y > 1).map(y => 2 * y)
\end{lstlisting}
and computes the value \lstinline!List(20, 20, 20, 6)!. This is a
functor block that \textsf{``}raises\textsf{''} computations to the \lstinline!List!
functor. Similar syntax exists in a number of languages and is called
a \textbf{\textsf{``}for-comprehension\textsf{''}}\index{for-comprehensions (Python)@\texttt{for}-comprehensions (Python)}
or a \textsf{``}list comprehension\textsf{''} in Python, \textbf{\textsf{``}do-notation\textsf{''}}\index{do-notation (Haskell)@\texttt{do}-notation (Haskell)}
in Haskell, and \textbf{\textsf{``}computation expressions\textsf{''}}\index{computation expressions (F#)@computation expressions (F\#)}
in F\#. I use the name \textsf{``}functor block\textsf{''} in this book because it
is shorter and more descriptive. (The type constructor used in a functor
block needs to be at least a functor but does not have to be a monad.)
\item [{\index{GADT}GADT}] \textsf{``}Generalized algebraic data type\textsf{''}, a type
constructor with explicitly indexed type parameters. A Scala example
of a GADT is:
\begin{lstlisting}
sealed trait F[A]
final case class F1[A](x: A, y: A)   extends F[Int]
final case class F2[A](s: Int, t: A) extends F[Unit]
\end{lstlisting}
The type notation for this GADT is $F^{A}\triangleq\left(A\times A\right)^{:F^{\text{Int}}}+\left(\text{Int}\times A\right)^{:F^{\bbnum 1}}$.
Usually, a GADT is a type constructor such as \lstinline!F[A]! whose
definition uses type parameters other than \lstinline!A!, or sets
the type parameters to type expressions other than \lstinline!A!.
\item [{Kleisli~function}] \index{Kleisli!functions} A function with
type signature $A\rightarrow M^{B}$ (in Scala, \lstinline!A => M[B]!)
for some fixed monad $M$. Also called a Kleisli morphism\index{Kleisli!morphisms}
(a morphism in the Kleisli category corresponding to the monad $M$).
The monadic method $\text{pure}_{M}:A\rightarrow M^{A}$ has the type
signature of a Kleisli function. The Kleisli composition operation,
$\diamond_{M}$, is a binary operation that combines two Kleisli functions
(of types $A\rightarrow M^{B}$ and $B\rightarrow M^{C}$) into a
new Kleisli function (of type $A\rightarrow M^{C}$).
\item [{\index{method}Method}] This word is used in two ways: 1) A method$_{1}$
is a Scala function defined as a member of a typeclass. For example,
\lstinline!flatMap! is a method defined in the \lstinline!Monad!
typeclass. 2) A method$_{2}$ is a Scala function defined as a member
of a data type declared as a Java-compatible \lstinline!class! or
\lstinline!trait!. Trait methods$_{2}$ are necessary in Scala when
implementing functions whose arguments have type parameters (because
Scala function values defined via \lstinline!val! cannot have type
parameters). So, many typeclasses such as \lstinline!Functor! or
\lstinline!Monad!, whose methods$_{1}$ require type parameters,
will use Scala \lstinline!traits! with methods$_{2}$ for their implementation.
The same applies to type constructions with quantified types, such
as the Church encoding. 
\item [{Nameless~function}] \index{nameless function}An expression of
function type, representing a function. For example, \lstinline!(x: Int) => x * 2!.
Also known as function expression, function literal, anonymous function,\index{anonymous function!see \textsf{``}nameless functions\textsf{''}}
closure, \index{lambda-function!see \textsf{``}nameless function\textsf{''}}lambda-function,
lambda-expression, or simply a \textsf{``}lambda\textsf{''}.
\item [{Partial~function}] A function that may fail to return a result
for some values of arguments, unlike a \textsf{``}total function\textsf{''} that is
guaranteed to work for all values of arguments. For some values of
arguments, a partial function may fail with an exception or enter
an infinite loop and never return a value.
\item [{Polynomial~functor}] \index{polynomial functor}A type constructor
built using disjunctions (sums), products (tuples), type parameters
and fixed types. For example, in Scala, \lstinline!type F[A] = Either[(Int, A, A), A]!
is a polynomial functor with respect to the type parameter \lstinline!A!,
while \lstinline!Int! is a fixed type (not a type parameter). The
type notation for this \lstinline!F! is $F^{A}=\text{Int}\times A\times A+A$,
which resembles a polynomial in the type variable $A$ with coefficients
made from fixed types (such as \lstinline!Int!). Polynomial functors
are also known as \textbf{algebraic data types}\index{algebraic data types}.
\item [{Product~type}] \index{product type}A type representing several
values given at once. In Scala, product types are the tuple types,
for example \lstinline!(Int, String)!, and case classes. Also known
as \index{tuples}\textbf{tuple} type, \textbf{struct} (in C and C++),
and \textbf{record}.
\item [{\index{profunctor}Profunctor}] A type constructor with two type
parameters, contravariant in the first parameter and covariant in
the second. An example of a profunctor is \lstinline!F[A, B] = (A => Int, B)!.
The code notation for this \lstinline!F! is $F^{A,B}=(A\rightarrow\text{Int})\times B$.
This book also calls a \textsf{``}profunctor\textsf{''} a type constructor whose type
parameter occurs in both covariant and contravariant positions and
having a function \lstinline!xmap! satisfying the appropriate laws;
see Section~\ref{subsec:f-Profunctors}. An example of that kind
of \textsf{``}profunctor\textsf{''} is \lstinline!G[A] = (A => Int, A)!.
\item [{Total~function}] A function that is guaranteed to return a result
for all values of arguments, unlike a \textsf{``}partial function\textsf{''} that
may fail to return a result for some values of arguments. A total
function will never enter an infinite loop or throw an exception,
as long as the arguments have the right types.
\item [{Typeclass~constraint}] A type parameter constrained to a certain
subset of types that belong to a given typeclass. In Scala, the syntax
is:
\begin{lstlisting}
def double[T: Semigroup](t: T): T = implicitly[Semigroup[T]].combine(t, t)
\end{lstlisting}
This function is defined only for types \lstinline!T! for which a
\lstinline!Semigroup! typeclass instance is available. The typeclass
instance data is passed to the function as an implicit argument. This
allows the function to work in a different way for every type \lstinline!T!.
\item [{Type~notation}] \index{type notation}A mathematical notation
for type expressions developed in this book for easier reasoning about
types in functional programs. Disjunctive types are denoted by $+$,
product types by $\times$, and function types by $\rightarrow$.
The unit type is denoted by $\bbnum 1$, and the void type by $\bbnum 0$.
The function arrow $\rightarrow$ groups weaker than $+$, which in
turn groups weaker than $\times$. This means:
\[
Z+A\rightarrow Z+A\times A\quad\text{is the same as}\quad\left(Z+A\right)\rightarrow\left(Z+\left(A\times A\right)\right)\quad.
\]
 Type parameters are denoted by superscripts. As an example, the Scala
definition\texttt{}
\begin{lstlisting}
type F[A] = Either[(A, A => Option[Int]), String => List[A]]
\end{lstlisting}
is written in the type notation as: 
\[
F^{A}\triangleq A\times\left(A\rightarrow\bbnum 1+\text{Int}\right)+(\text{String}\rightarrow\text{List}^{A})\quad.
\]
\end{description}

\section{How the term \textquotedblleft algebra\textquotedblright{} is used
in functional programming}

This book avoids using the terms \textsf{``}algebra\index{algebra}\textsf{''} or
\textsf{``}algebraic\index{algebraic}\textsf{''} because these terms are too ambiguous.
As we will see, the FP community uses the word \textsf{``}algebra\textsf{''} in at
least \emph{three} incompatible ways.

\paragraph{Definition 0.}

In mathematics, an \textquotedblleft algebra\textquotedblright{} is
a vector space with a multiplication operation ($*$) satisfying certain
properties, such as distributivity: $z*(x+y)=z*x+z*y$. For example,
the set of all $10\times10$ matrices with real coefficients is a
$100$-dimensional vector space that satisfies the required properties.
Such matrices form an \textquotedblleft algebra\textquotedblright{}
in the mathematical sense. (This meaning of the word \textsf{``}algebra\textsf{''}
is \emph{not} used in FP.)

\paragraph{Definition 1.}

For a given functor $F$, an \textsf{``}$F$-algebra\textsf{''}\index{$F$-algebra}
is a type $T$ and a function with type signature $F^{T}\rightarrow T$.
This definition comes from category theory. The name \textsf{``}$F$-algebra\textsf{''}
emphasizes the dependence on a chosen functor $F$. There is no direct
connection between \textsf{``}$F$-algebra\textsf{''} and Definition~0, except when
the functor $F$ is defined by $F^{A}\triangleq A\times A$: a function
of type $T\times T\rightarrow T$ may then be interpreted as a \textsf{``}multiplication\textsf{''}
operation for values of type $T$. However, even in that case $T$
will not necessarily satisfy the laws of a vector space.

A recursive type $T$ defined by $F^{T}\cong T$ has an isomorphism
$F^{T}\rightarrow T$ and so is an $F$-algebra. Recursive polynomial
types are known as \textsf{``}algebraic\textsf{''} in this sense: they are $F$-algebras
with a polynomial pattern functor $F$ and an added requirement of
isomorphism for the map $F^{T}\rightarrow T$. In terms of category
theory, least fixpoints of a type equation $F^{T}\cong T$ is the
\textsf{``}initial $F$-algebra\textsf{''}.\footnote{See \texttt{\href{https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt}{https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt}} }

Another use of $F$-algebras is in formulating properties of $P$-typeclasses.\index{$P$-typeclass}
A $P$-typeclass is a $P$-algebra with (usually) additional laws
imposed. This book prefers the term \textsf{``}$P$-typeclass\textsf{''} for brevity,
although those typeclasses could also be called \textsf{``}$P$-algebraic\textsf{''}.

The \textsf{``}algebra\textsf{''} defined in this sense is also relevant to the Church
encoding of a free monad (also known as the \textsf{``}tagless final\index{tagless final}\textsf{''}
pattern), or more generally to Church encodings of free $P$-typeclasses
that involve functions of type $\forall E^{\bullet}.\,(S^{E}\leadsto E)\leadsto E$.
That type uses a higher-order type $S^{E}$ parameterized by a \emph{type
constructor} parameter $E^{\bullet}$. In this context, a value of
type $S^{E}\leadsto E$ (or, more verbosely, $\forall A.\,S^{A,E^{\bullet}}\rightarrow E^{A}$)
suggests the existence of an $S$-algebra in the category of type
constructors. However, knowing about the existence of that $S$-algebra
does not provide any help or additional insights for practical work
with the Church encodings of free typeclasses.

\paragraph{Definition 2.}

Polynomial data types (for example, \lstinline!type F[A] = Option[(A, A)]!)
are often called \textquotedblleft algebraic data types\index{algebraic data types}\textquotedblright{}
(ADTs). An ADT may admit some binary or unary operations, but this
does not turn it into an algebra in the sense of Definition~0. The
types of ADTs are also not of the form $F^{A}\rightarrow A$ and are
not necessarily defined recursively via a type equation $F^{T}\cong T$,
so Definition~1 does not apply directly. The word \textsf{``}algebraic\textsf{''}
in \textsf{``}ADT\textsf{''} may be better understood as referring to \textsf{``}school-level
algebra\textsf{''} dealing with polynomials, as the ADTs are built from \textsf{``}sums\textsf{''}
and \textsf{``}products\textsf{''} of types. 

Instead of calling types \textsf{``}algebraic\textsf{''}, this book uses more precise
terms \textquotedblleft polynomial types\textquotedblright{} and \textquotedblleft exponential-polynomial
types\textquotedblright . Data types containing functions, such as
\lstinline!Option[Int => (A, A)]!, are exponential-polynomial (but
not polynomial).

\paragraph{Definition 3.}

One talks about the \textquotedblleft algebra\textquotedblright{}
of properties of functions such as \lstinline!map! or \lstinline!flatMap!,
meaning that these functions satisfy certain \textsf{``}algebraic\textsf{''} laws
(e.g., the composition, naturality, or associativity laws). But these
laws do not make functions \lstinline!map! or \lstinline!flatMap!
into an algebra in the sense of Definitions~0 or~1. There is also
no relation to the ADTs of Definition~2. So, this is a different
usage of the word \textsf{``}algebra\textsf{''}. However, there is no general \textsf{``}algebra
of laws\textsf{''} that we can use. Every derivation proceeds in a different
way, specific to the laws being proved. In mathematics, \textsf{``}algebraic\textsf{''}
equations are distinguished from differential or integral equations.
In that sense, the laws used in FP are \emph{always} algebraic: they
are just equations with compositions and applications of functions.
So, there is no advantage in calling FP laws \textsf{``}algebraic\textsf{''}. 

We find that the current usage of the word \textsf{``}algebra\textsf{''} in FP is
both inconsistent and unhelpful to software practitioners. In this
book, the word \textsf{``}algebra\textsf{''} always means a branch of mathematics,
as in \textsf{``}high-school algebra\textsf{''}. Instead of \textsf{``}algebras\textsf{''} as in Definitions~1
to~3, this book talks about \textsf{``}polynomial types\textsf{''} or \textsf{``}recursive
polynomial types\textsf{''}, \textsf{``}equations\textsf{''} or \textsf{``}laws\textsf{''}, and $P$-typeclasses.\index{$P$-typeclass}

\chapter{Parametricity theorem and naturality laws\label{app:Proofs-of-naturality-parametricity}}

Functional programming focuses on a small set of language features
\textemdash{} the six type constructions and the nine code constructions\index{nine code constructions},
introduced in Sections~\ref{subsec:Type-notation-and-standard-type-constructions}
and~\ref{subsec:Short-notation-for-eight-code-constructions}. These
constructions, summarized again in Tables~\ref{tab:Mathematical-notation-for-basic-code-constructions}
and \ref{tab:six-pure-type-constructions}\textendash \ref{tab:nine-pure-code-constructions},
create \textbf{fully parametric} programs\index{fully parametric!code}
and are sufficient to implement all design patterns of functional
programming. At the same time, restricting programs to be fully parametric
will enable several ways of mathematical reasoning about code. Examples
of such reasoning are treating programs as mathematical values (referential
transparency\index{referential transparency}); deriving the most
general type from code (type inference\index{type inference}); and
deriving code from type (code inference\index{code inference}).

Additionally, all fully parametric programs will automatically satisfy
certain laws derived from the so-called \textsf{``}parametricity theorem\textsf{''}.
The most often used laws of this kind are naturality laws for natural
transformations, i.e., for functions of type $\forall A.\,F^{A}\rightarrow G^{A}$
where both $F$ and $G$ are functors (or both contrafunctors). Not
having to verify naturality laws by hand saves a lot of time.

Other laws that follow automatically from parametricity are composition
laws for functors, commutativity laws for bifunctors, and dinaturality
laws for profunctors. This Appendix presents sufficient theoretical
material to be able to derive all those laws. 

\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\small{}Type construction} & \textbf{\small{}Scala example} & \textbf{\small{}Type notation}\tabularnewline
\hline 
\hline 
{\small{}unit or \textsf{``}named unit\textsf{''}} & {\small{}}\lstinline!Unit!{\small{} or }\lstinline!None! & {\small{}$\bbnum 1$}\tabularnewline
\hline 
{\small{}type parameter} & {\small{}}\lstinline!A!{\small{} as in }\lstinline!F[A]! & {\small{}$A$ as in $F^{A}$}\tabularnewline
\hline 
{\small{}product type} & {\small{}}\lstinline!(A, B)! & {\small{}$A\times B$}\tabularnewline
\hline 
{\small{}co-product type} & {\small{}}\lstinline!Either[A, B]! & {\small{}$A+B$}\tabularnewline
\hline 
{\small{}function type} & {\small{}}\lstinline!A => B! & {\small{}$A\rightarrow B$}\tabularnewline
\hline 
{\small{}recursive type} & {\small{}}\lstinline!Fix[F[_]]! & {\small{}$\text{Fix}^{F}$}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{\index{fully parametric!type constructions}The six type constructions
that may be used in fully parametric programs.\label{tab:six-pure-type-constructions}}
\end{table}

\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\small{}Code construction} & \textbf{\small{}Scala example} & \textbf{\small{}Code notation}\tabularnewline
\hline 
\hline 
{\small{}1. Use unit value} & {\small{}}\lstinline!()! & {\small{}$1$}\tabularnewline
\hline 
{\small{}2. Use given argument} & {\small{}}\lstinline!x! & {\small{}$x$}\tabularnewline
\hline 
{\small{}3. Create function} & {\small{}}\lstinline!x => expression! & {\small{}$x\rightarrow expression$}\tabularnewline
\hline 
{\small{}4. Use function} & {\small{}}\lstinline!f(x)! & $f(x)$ ~or~ $x\triangleright f$\tabularnewline
\hline 
{\small{}5. Create tuple} & {\small{}}\lstinline!(a, b)! & {\small{}$a\times b$}\tabularnewline
\hline 
{\small{}6. Use tuple} & {\small{}}\lstinline!{ case (a, b) => ... }!{\small{} or }\lstinline!p._1!{\small{}
or }\lstinline!p._2!{\small{} } & {\small{}$a\times b\rightarrow...$ ~or~ $p\triangleright\pi_{1}$
~or~ $p\triangleright\pi_{2}$}\tabularnewline
\hline 
{\small{}7. Create disjunctive value} & {\small{}}\lstinline!Left[A, B](a)! & {\small{}}%
\begin{minipage}[c]{0.19\columnwidth}%
{\small{}\vspace{0.2\baselineskip}
$a^{:A}+\bbnum 0^{:B}$ ~or~~ $\begin{array}{|cc|}
a & \bbnum 0\end{array}$\vspace{0.2\baselineskip}
}%
\end{minipage}\tabularnewline
\hline 
{\small{}8. Use disjunctive value} & {\small{}}%
\begin{minipage}[c]{0.33\columnwidth}%
{\small{}}\lstinline!p match { case Left(a)   => f(a)            case Right(b)  => g(b)          }!%
\end{minipage} & {\small{}}%
\begin{minipage}[c]{0.23\columnwidth}%
{\small{}\vspace{0.2\baselineskip}
$p\,\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & a\rightarrow f(a)\\
B & b\rightarrow g(b)
\end{array}$\vspace{0.2\baselineskip}
}%
\end{minipage}\tabularnewline
\hline 
{\small{}9. Recursive call} & {\small{}}\lstinline!def f(x) = { ... f(y) ... }! & {\small{}$f(x)\triangleq...~\overline{f}(y)~...$}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{\index{fully parametric!code constructions}The nine code constructions
of fully parametric programs.\label{tab:nine-pure-code-constructions}}
\end{table}

The practical uses of parametricity were showcased in \index{Philip Wadler}P.~Wadler\textsf{'}s
paper\footnote{See \texttt{\href{https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf}{https://people.mpi-sws.org/$\sim$dreyer/tor/papers/wadler.pdf}}
and some further explanations in the blog posts \texttt{\href{https://reasonablypolymorphic.com/blog/theorems-for-free/}{https://reasonablypolymorphic.com/blog/theorems-for-free/}}
and \texttt{\href{https://bartoszmilewski.com/2014/09/22/}{https://bartoszmilewski.com/2014/09/22/}}\\
The title of the paper (\textsf{``}Theorems for free\textsf{''}\index{theorems for free})
is misleading. As we will see, the theorems are obtained only at the
cost of restricting all code to the nine FP code constructions, which
excludes most of the code in today\textsf{'}s real-world applications.} based on results derived by J.~Reynolds.\index{John Reynolds}\footnote{See \texttt{\href{https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf}{https://people.mpi-sws.org/$\sim$dreyer/tor/papers/reynolds.pdf}}.
This book does not use those results. } The Reynolds-Wadler approach first replaces functions of type $A\rightarrow B$
by many-to-many relations between values of types $A$ and $B$. Then
the parametricity theorem shows that a certain law holds for relations.
Since we are usually interested in deriving laws as equations rather
than relations, the last step replaces all relations by functions.

To use the relational approach to parametricity, one needs to learn
the techniques for working with relations, which will be unfamiliar
to most programmers.\footnote{Beginner-level tutorials on relations and relational parametricity
are rare. One is in a paper by \index{Ronald Backhouse}R.~Backhouse,
see \texttt{\href{https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions}{https://www.researchgate.net/publication/262348393\_On\_a\_Relation\_on\_Functions}}} Only a few parametricity properties can be proved without using relations.
However, a practicing programmer will mostly only use the \emph{formulations}
of the resulting laws rather than their proofs. Adapting the parametricity
theorem to the needs of FP practitioners, this Appendix will begin
by summarizing the naturality laws and other properties of fully parametric
code. Then Section~\ref{sec:Parametricity-theorem-for-relations}
will prove the parametricity theorem via the relational approach.%
\begin{comment}
Section~\ref{sec:Commutativity-laws-for-type-constructors} proves
that fully parametric type constructors obey commutativity laws. Section~\ref{sec:Naturality-laws-for-fully-parametric-functions}
shows, without using relations, that fully parametric functions satisfy
dinaturality laws (a generalization of naturality laws to arbitrary
type signatures). An important consequence, proved in Section~\ref{sec:Uniqueness-of-functor-and-contrafunctor},
is that the code implementing the functor and contrafunctor typeclasses
is unique. Finally, Section~\ref{sec:Parametricity-theorem-for-relations}
explains the relational approach to parametricity and proves the relational
parametricity theorem. 

Additional literature:

{[}1{]}: Girard, J.-Y.; Scedrov, A. \& Scott, P. J. Normal Forms and
Cut-Free Proofs as Natural Transformations. Logic From Computer Science,
Mathematical Science Research Institute Publications 21, Springer-Verlag,
1992, 217-241. http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.811

{[}2{]}: Bainbridge, E. S.; Freyd, P. J.; Scedrov, A. \& Scott, P.
J. Functorial polymorphism. Theoretical computer science, Elsevier,
1990, 70, 35-64. https://core.ac.uk/display/82270459

{[}3{]}: De Lataillade, J. Dinatural Terms in System F. Logic in Computer
Science, 24th Annual IEEE Symposium, 267-276, 2009. https://www.irif.fr/\textasciitilde delatail/dinat.pdf

{[}4{]}: Pistone, P. On completeness and parametricity in the realizability
semantics of System F. https://arxiv.org/abs/1802.05143

{[}5{]}: https://libres.uncg.edu/ir/asu/f/Johann\_Patricia\_2014\_A\_Relationally\_Parametric\_Model\_Of\_Dependent\_Type\_Theory..pdf

See discussion here: https://cstheory.stackexchange.com/questions/42256/is-case-analysis-on-normal-forms-of-lambda-terms-sufficient-to-prove-parametrici
\end{comment}

Parametricity properties only hold for fully parametric code.\index{fully parametric!code}
This restriction prohibits, for instance, any use of \index{GADT}GADTs,
\lstinline!null! values, mutable values, multithreading, exceptions,
run-time type reflection, or calling any external libraries that are
not known to be fully parametric. Code that uses those features of
Scala will not be covered by the parametricity theorem proved in this
Appendix and may fail naturality laws. 

An example of non-fully parametric code is the following function:
\begin{lstlisting}
def headOptBad[A]: List[A] => Option[A] = {
  case Nil                   => None
  case (head: Int) :: tail   => Some((head + 100).asInstanceOf[A])
  case head :: tail          => Some(head)
}
\end{lstlisting}
This code has no side effects, is purely functional and referentially\index{referential transparency}
transparent. But it is not fully parametric because \lstinline!headOptBad[A]!
does not work in the same way for all type parameters \lstinline!A!.
When \lstinline!A! is set to \lstinline!Int!, the behavior is different
than for all other types. This breaks the naturality law:
\begin{lstlisting}
scala> headOptBad[String](  List(1, 2, 3).map(x => s"value = $x")  )
res0: Option[String] = Some(value = 1)

scala> headOptBad[Int]( List(1, 2, 3) ).map(x => s"value = $x")
res1: Option[String] = Some(value = 101)
\end{lstlisting}
So, full parametricity is a stronger restriction on code than referential
transparency.

Here is an example of fully parametric code that uses all nine constructions:
\begin{lstlisting}
def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = {      // 3
   case Nil            => Nil
//   8   1                1,7 
   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
//   8       6             2 4     6  5 2 4     6    7   9
}  // This code uses each of the nine fully parametric constructions.
\end{lstlisting}
For instance, the expression \lstinline!head :: tail! is a tuple
pattern that extracts the two parts of a tuple (construction 6). The
recursive call \lstinline!fmap(f)(tail)! corresponds to construction
9.

\section{Practical use of parametricity properties}

\subsection{Naturality and dinaturality laws\label{sec:Naturality-laws-for-fully-parametric-functions} }

Parametricity properties apply to fully parametric expressions (most
often, functions) with at least one type parameter. Examples of such
functions are the \lstinline!map!, \lstinline!filter!, and \lstinline!fold!
methods for the \lstinline!Option! functor (denoted by $\text{Opt}^{A}\triangleq\bbnum 1+A$),
with the following type signatures:
\begin{align*}
 & \text{fmap}_{\text{Opt}}^{A,B}:\left(A\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad,\\
 & \text{filt}_{\text{Opt}}^{A}:\left(A\rightarrow\bbnum 2\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{A}\quad,\\
 & \text{fold}_{\text{Opt}}^{A,B}:B\times\left(A\times B\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow B\quad.
\end{align*}
These methods satisfy certain parametricity laws, one law per type
parameter.

When a function\textsf{'}s type signature is that of a \emph{natural transformation}\index{natural transformation}
between functors or between contrafunctors, the parametricity laws
have the form derived in Section~\ref{subsec:Naturality-laws-and-natural-transformations}.
If $t:\forall A.\,G^{A}\rightarrow H^{A}$ where $G$ and $H$ are
functors then $t$ obeys the naturality law:
\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad t^{A}\bef f^{\uparrow H}=f^{\uparrow G}\bef t^{B}\quad.\label{eq:naturality-law-for-functors}
\end{equation}
If $t:\forall A.\,G^{A}\rightarrow H^{A}$ where $G$ and $H$ are
contrafunctors then $t$ obeys the naturality law:
\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad f^{\downarrow G}\bef t^{A}=t^{B}\bef f^{\downarrow H}\quad.\label{eq:naturality-law-for-contrafunctors}
\end{equation}

For example, if we fix the type parameter $A$ in the \lstinline!fmap!
method, we obtain a type signature of the form $F^{B}\rightarrow G^{B}$
where $F$ and $G$ are functors:
\[
\text{fmap}_{\text{Opt}}^{A,B}:F^{B}\rightarrow G^{B}\quad,\quad\quad F^{B}\triangleq A\rightarrow B\quad,\quad\quad G^{B}\triangleq\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad.
\]
The corresponding naturality law is:
\[
\text{fmap}_{\text{Opt}}\bef f^{\uparrow G}=f^{\uparrow F}\bef\text{fmap}_{\text{Opt}}\quad.
\]

Fixing the type parameter $B$ in $\text{fold}_{\text{Opt}}^{A,B}\,$
produces a type signature of the form:
\[
\text{fold}_{\text{Opt}}^{A}:H^{A}\rightarrow K^{A}\quad,\quad\quad H^{A}\triangleq B\times\left(A\times B\rightarrow B\right)\quad,\quad\quad K^{A}\triangleq\text{Opt}^{A}\rightarrow B\quad,
\]
where $K$ and $H$ are contrafunctors. The corresponding naturality
law is:
\[
f^{\downarrow H}\bef\text{fold}_{\text{Opt}}=\text{fold}_{\text{Opt}}\bef f^{\downarrow K}\quad.
\]

Fixing the type parameter $A$ in $\text{fold}_{\text{Opt}}^{A,B}$
gives a type signature that is \emph{not} of the form $\forall B.\,P^{B}\rightarrow Q^{B}$
(with any functors or contrafunctors $P$, $Q$) because $B$ is used
in too many places. In general, it is not straightforward to write
naturality laws for functions with such type signatures. 

To make progress, we note that each occurrence of a type parameter
in a type signature must be either in a covariant or in a contravariant
position. So, any fully parametric type signature may be written in
the form $\forall A.\,P^{A,A}$ using some \emph{profunctor}\index{profunctor}
$P^{X,Y}$ (contravariant in $X$ and covariant in $Y$). For instance,
we can write in this way the type signature of \lstinline!fold! with
the parameter $A$ fixed:
\[
\text{fold}_{\text{Opt}}^{A,B}:P^{B,B}\quad,\quad\quad\text{where}\quad P^{X,Y}\triangleq X\times(A\times Y\rightarrow X)\rightarrow\text{Opt}^{A}\rightarrow Y\quad.
\]
The profunctor $P$ is complicated but the form of the type signature
($P^{B,B}$) is simpler.

Given a fully parametric expression $p$ with the type signature $p:\forall A.\,P^{A,A}$,
where $P^{X,Y}$ is some profunctor, one can write the \textbf{wedge
law}\index{wedge law!of profunctors}\index{profunctor!wedge law}
of $p$:
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{3.0pc}\forall Z.\,P^{Z,Z}\ar[d]\sp(0.4){\text{set }Z=A}\ar[r]\sp(0.55){\text{set }Z=B} & P^{B,B}\ar[d]\sp(0.37){f^{\downarrow P^{\bullet,B}}}\\
P^{A,A}\ar[r]\sp(0.55){f^{\uparrow P^{A,\bullet}}} & P^{A,B}
}
\]
\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=p^{B}\triangleright f^{\downarrow P^{\bullet,B}}\quad.\label{eq:wedge-law-for-profunctors}
\end{equation}
The diagram is read by starting from a value $p$ of type $\forall Z.\,P^{Z,Z}$.
We set $Z=A$ and $Z=B$ in $p$ and obtain two values, $p^{A}$ and
$p^{B}$, of types $P^{A,A}$ and $P^{B,B}$ respectively. The values
$p^{A}$ and $p^{B}$ must then satisfy Eq.~(\ref{eq:wedge-law-for-profunctors}). 

We will prove later in this Appendix that the wedge law~(\ref{eq:wedge-law-for-profunctors})
is a consequence of the parametricity theorem. In turn, the naturality
laws~(\ref{eq:naturality-law-for-functors}) and~(\ref{eq:naturality-law-for-contrafunctors})
are consequences of the wedge law, as will be shown in Statement~\ref{subsec:Statement-naturality-laws-from-wedge-law}
below.

The wedge law is not easy to use in practice because the profunctors
$P$ are often complicated (as the example of \lstinline!fold! shows).
When we need to derive naturality laws for \emph{function types},
it helps to specialize the wedge law to the case $P^{A,A}=G^{A,A}\rightarrow H^{A,A}$,
where $G^{X,Y}$ and $H^{X,Y}$ are some profunctors. The result (also
derived in Statement~\ref{subsec:Statement-naturality-laws-from-wedge-law})
is the \textbf{dinaturality law}\index{dinaturality law}:
\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad f^{\downarrow G^{\bullet,A}}\bef p^{A}\bef f^{\uparrow H^{A,\bullet}}=f^{\uparrow G^{B,\bullet}}\bef p^{B}\bef f^{\downarrow H^{\bullet,B}}\quad.\label{eq:dinaturality-law-for-profunctors}
\end{equation}
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{2.0pc} & G^{A,A}\ar[r]\sb(0.5){p^{A}} & H^{A,A}\ar[rd]\sb(0.4){f^{\uparrow H^{A,\bullet}}\negthickspace}\\
G^{B,A}\negthickspace\negthickspace\negthickspace\ar[rd]\sp(0.55){~~f^{\uparrow G^{B,\bullet}}}\ar[ru]\sb(0.6){\negthickspace f^{\downarrow G^{\bullet,A}}} &  &  & \negthickspace\negthickspace\negthickspace H^{A,B}\\
 & G^{B,B}\ar[r]\sp(0.5){p^{B}} & H^{B,B}\ar[ru]\sp(0.45){f^{\downarrow H^{\bullet,B}}\negthickspace}
}
\]

This diagram illustrates the dinaturality law as an equation between
functions of type $G^{B,A}\rightarrow H^{A,B}$. To build up intuition
for that law, notice that Eq.~(\ref{eq:dinaturality-law-for-profunctors})
combines the laws~(\ref{eq:naturality-law-for-functors})\textendash (\ref{eq:naturality-law-for-contrafunctors})
in the way required for all types to match. On the other hand, the
laws~(\ref{eq:naturality-law-for-functors}) and~(\ref{eq:naturality-law-for-contrafunctors})
will follow from Eq.~(\ref{eq:dinaturality-law-for-profunctors})
when $G^{A,A}$ and $H^{A,A}$ are both functors or both contrafunctors
with respect to $A$.

Functions $p:\forall A.\,G^{A,A}\rightarrow H^{A,A}$ satisfying Eq.~(\ref{eq:dinaturality-law-for-profunctors})
are called \textbf{dinatural transformations}\index{dinatural transformation}.
The property of dinaturality is weaker than naturality.\emph{ }A \emph{natural}
transformation between profunctors $G$ and $H$ would be a function
$t$ with type signature $\forall(A,B).\,G^{A,B}\rightarrow H^{A,B}$
defined for arbitrary (not necessarily equal) type parameters $A$,
$B$. If we are given a transformation $p^{A}:G^{A,A}\rightarrow H^{A,A}$
then, as a rule, it will be impossible to extend the code of $p^{A}$
to some $t^{A,B}:G^{A,B}\rightarrow H^{A,B}$ that works with arbitrary
type parameters $A$, $B$.

With the formulas~(\ref{eq:naturality-law-for-functors})\textendash (\ref{eq:dinaturality-law-for-profunctors}),
we can write naturality laws more quickly, starting from any given
type signature of the form $\forall A.\,P^{A,A}$. The following examples
show how to derive naturality laws by specializing the general law~(\ref{eq:dinaturality-law-for-profunctors})
to certain profunctors $G$ and $H$.

\subsubsection{Example \label{subsec:Example-derive-naturality-of-filter-from-dinaturality}\ref{subsec:Example-derive-naturality-of-filter-from-dinaturality}
(naturality law of \lstinline!filter!)\index{examples}}

To derive the naturality law of \lstinline!filter!, express \lstinline!filter!\textsf{'}s
type signature through profunctors $G$ and $H$ as:
\[
\text{filt}_{F}^{A}:G^{A,A}\rightarrow H^{A,A}\quad,\quad\quad G^{X,Y}\triangleq(X\rightarrow\bbnum 2)\quad,\quad\quad H^{X,Y}\triangleq F^{X}\rightarrow F^{Y}\quad,
\]
and then write the law~(\ref{eq:dinaturality-law-for-profunctors}):
\begin{equation}
f^{\downarrow G^{\bullet,A}}\bef\text{filt}_{F}^{A}\bef f^{\uparrow H^{A,\bullet}}\overset{?}{=}f^{\uparrow G^{B,\bullet}}\bef\text{filt}_{F}^{B}\bef f^{\downarrow H^{\bullet,B}}\quad.\label{eq:filter-law-via-dinatural-transformation-derivation1}
\end{equation}
It remains to substitute the code for the liftings using the specific
types of $H$ and $G$:
\begin{align*}
(f^{:A\rightarrow B})^{\downarrow G^{\bullet,A}}=p^{:B\rightarrow\bbnum 2}\rightarrow f\bef p\quad, & \quad\quad f^{\uparrow G^{B,\bullet}}=\text{id}\quad,\\
(f^{:A\rightarrow B})^{\downarrow H^{\bullet,B}}=q^{:F^{B}\rightarrow F^{B}}\rightarrow f^{\uparrow F}\bef q\quad, & \quad\quad f^{\uparrow H^{A,\bullet}}=q^{:F^{A}\rightarrow F^{A}}\rightarrow q\bef f^{\uparrow F}\quad.
\end{align*}
Then we rewrite Eq.~(\ref{eq:filter-law-via-dinatural-transformation-derivation1})
as:
\[
(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\overset{?}{=}\text{id}\bef\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)\quad.
\]
To simplify the form of the naturality law, apply both sides to an
arbitrary $p^{:P^{B,A}}=p^{:B\rightarrow\bbnum 2}$:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p\triangleright(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\\
{\color{greenunder}\triangleright\text{-notation}:}\quad & \quad=\gunderline{p\triangleright(p}\rightarrow f\bef p)\triangleright\text{filt}_{F}\triangleright(q\rightarrow q\bef f^{\uparrow F})\\
{\color{greenunder}\text{apply functions}:}\quad & \quad=\gunderline{(f\bef p)\triangleright\text{filt}_{F}}\triangleright(q\rightarrow q\bef f^{\uparrow F})=\gunderline{\text{filt}_{F}(f\bef p)\triangleright(q}\rightarrow q\bef f^{\uparrow F})=\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p\triangleright\gunderline{\text{id}\bef}\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)=p\triangleright\text{filt}_{F}\triangleright(q\rightarrow f^{\uparrow F}\bef q)\\
 & \quad=\gunderline{\text{filt}_{F}(p)\triangleright(q}\rightarrow f^{\uparrow F}\bef q)=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\end{align*}
We obtained the naturality law~(\ref{eq:naturality-law-of-filter})
of \lstinline!filter!:
\[
\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\]


\subsubsection{Example \label{subsec:Example-derive-naturality-of-fold-from-dinaturality}\ref{subsec:Example-derive-naturality-of-fold-from-dinaturality}
(naturality law of \lstinline!fold!)}

To derive the naturality law of \lstinline!fold! with respect to
the type parameter $B$, we write the type signature of \lstinline!fold!
as $G^{B,B}\rightarrow H^{B,B}$ with some profunctors $G$, $H$:
\[
\text{fold}_{F}^{A,B}:G^{B,B}\rightarrow H^{B,B}\quad\quad\text{where}\quad G^{X,Y}\triangleq Y\times(A\times X\rightarrow Y)\quad\text{ and }\quad H^{X,Y}\triangleq F^{A}\rightarrow Y\quad.
\]
Since the type parameter $A$ is fixed, let us write the law~(\ref{eq:dinaturality-law-for-profunctors})
with an arbitrary function $f^{:B\rightarrow C}$:
\begin{equation}
(f^{:B\rightarrow C})^{\downarrow G^{\bullet,B}}\bef\text{fold}_{F}^{B}\bef f^{\uparrow H^{B,\bullet}}\overset{!}{=}f^{\uparrow G^{C,\bullet}}\bef\text{fold}_{F}^{C}\bef f^{\downarrow H^{\bullet,C}}\quad.\label{eq:fold-naturality-from-profunctor-derivation2}
\end{equation}
The lifting code required for the profunctors $G^{X,Y}\triangleq Y\times\left(A\times X\rightarrow Y\right)$
and $H^{X,Y}\triangleq F^{A}\rightarrow Y$ is:
\begin{align*}
(f^{:B\rightarrow C})^{\downarrow G^{\bullet,B}}=\text{id}^{B}\boxtimes(h^{:A\times C\rightarrow B}\rightarrow a^{:A}\times b^{:B}\rightarrow h(a\times f(b)))\quad, & \quad\quad f^{\uparrow G^{C,\bullet}}=f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f)\quad,\\
(f^{:B\rightarrow C})^{\downarrow H^{\bullet,C}}=\text{id}\quad, & \quad\quad f^{\uparrow H^{B,\bullet}}=q^{:F^{A}\rightarrow B}\rightarrow q\bef f\quad.
\end{align*}
Substituting this code into the law~(\ref{eq:fold-naturality-from-profunctor-derivation2})
and applying to an arbitrary $p^{:G^{C,B}}=z^{:B}\times h^{:A\times C\rightarrow B}$,
we get:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (z\times h)\triangleright\gunderline{(f^{:B\rightarrow C})^{\downarrow G^{\bullet,B}}}\bef\text{fold}_{F}\bef\gunderline{f^{\uparrow H^{B,\bullet}}}\\
{\color{greenunder}\text{definitions of liftings}:}\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\gunderline{\bef}\text{fold}_{F}\gunderline{\bef}(q\rightarrow q\bef f)\\
{\color{greenunder}\triangleright\text{-notation}:}\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\triangleright\text{fold}_{F}\triangleright(q\rightarrow q\bef f)\\
{\color{greenunder}\text{apply functions}:}\quad & \quad=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & (z\times h)\triangleright\gunderline{f^{\uparrow G^{C,\bullet}}}\bef\text{fold}_{F}\bef\gunderline{f^{\downarrow H^{\bullet,C}}}=(z\times h)\triangleright(f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f))\bef\text{fold}_{F}\bef\text{id}\\
{\color{greenunder}\text{apply functions}:}\quad & \quad=\text{fold}_{F}(f(z)\times(h\bef f))\quad.
\end{align*}
We obtain the dinaturality law of \lstinline!fold!:
\[
\text{fold}_{F}(f(z)\times(h\bef f))=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad.
\]


\subsubsection{Statement \label{subsec:Statement-naturality-laws-from-wedge-law}\ref{subsec:Statement-naturality-laws-from-wedge-law}}

The laws~(\ref{eq:naturality-law-for-functors})\textendash (\ref{eq:dinaturality-law-for-profunctors})
are special cases of the wedge law~(\ref{eq:wedge-law-for-profunctors}). 

\subparagraph{Proof}

We assume that the wedge law holds for any values $p$ of type $\forall A.\,P^{A,A}$.

To prove Eq.~(\ref{eq:naturality-law-for-functors}), we define $P^{X,Y}\triangleq G^{X}\rightarrow H^{Y}$.
The two liftings of a function $f^{:A\rightarrow B}$ to $P$ are:
\[
f^{\uparrow P^{A,\bullet}}=p^{:G^{A}\rightarrow H^{A}}\rightarrow p\bef f^{\uparrow H}\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=p^{:G^{B}\rightarrow H^{B}}\rightarrow f^{\uparrow G}\bef p\quad.
\]
So, the wedge law~(\ref{eq:wedge-law-for-profunctors}) gives:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=p^{A}\bef f^{\uparrow H}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p^{B}\triangleright f^{\downarrow P^{\bullet,B}}=f^{\uparrow G}\bef p^{B}\quad.
\end{align*}
We obtain $p^{A}\bef f^{\uparrow H}=f^{\uparrow G}\bef p^{B}$, which
is the same as Eq.~(\ref{eq:naturality-law-for-functors}).

To prove Eq.~(\ref{eq:naturality-law-for-contrafunctors}), we define
$P^{X,Y}\triangleq G^{Y}\rightarrow H^{X}$. The two liftings of a
function $f^{:A\rightarrow B}$ to $P$ are:
\[
f^{\uparrow P^{A,\bullet}}=p^{:G^{A}\rightarrow H^{A}}\rightarrow f^{\downarrow G}\bef p\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=p^{:G^{B}\rightarrow H^{B}}\rightarrow p\bef f^{\downarrow H}\quad.
\]
So, the wedge law~(\ref{eq:wedge-law-for-profunctors}) gives:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=f^{\downarrow G}\bef p^{A}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p^{B}\triangleright f^{\downarrow P^{\bullet,B}}=p^{B}\bef f^{\downarrow H}\quad.
\end{align*}
We obtain $f^{\downarrow G}\bef p^{A}=p^{B}\bef f^{\downarrow H}$,
which is the same as Eq.~(\ref{eq:naturality-law-for-contrafunctors}).

To prove Eq.~(\ref{eq:dinaturality-law-for-profunctors}), we define
$P^{X,Y}\triangleq G^{Y,X}\rightarrow H^{X,Y}$. Note that we need
to swap $X$ and $Y$ in $G^{Y,X}$ in order to conform to the required
variance of $P^{X,Y}$ (contravariant in $X$ and covariant in $Y$). 

The two liftings of a function $f^{:A\rightarrow B}$ to $P$ are
expressed as:
\[
f^{\uparrow P^{A,\bullet}}=p^{:G^{A,A}\rightarrow H^{A,A}}\rightarrow f^{\downarrow G^{\bullet,A}}\bef p\bef f^{\uparrow H^{A,\bullet}}\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=p^{:G^{B,B}\rightarrow H^{B,B}}\rightarrow f^{\uparrow G^{B,\bullet}}\bef p\bef f^{\downarrow H^{\bullet,B}}\quad.
\]
So, the wedge law~(\ref{eq:wedge-law-for-profunctors}) gives:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=f^{\downarrow G^{\bullet,A}}\bef p^{A}\bef f^{\uparrow H^{A,\bullet}}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p^{B}\triangleright f^{\downarrow P^{\bullet,B}}=f^{\uparrow G^{B,\bullet}}\bef p^{B}\bef f^{\downarrow H^{\bullet,B}}\quad.
\end{align*}
We obtain $f^{\downarrow G^{\bullet,A}}\bef p^{A}\bef f^{\uparrow H^{A,\bullet}}=f^{\uparrow G^{B,\bullet}}\bef p^{B}\bef f^{\downarrow H^{\bullet,B}}$,
which is the same as Eq.~(\ref{eq:dinaturality-law-for-profunctors}).
$\square$

\subsection{Uniqueness of functor and contrafunctor liftings\label{sec:Uniqueness-of-functor-and-contrafunctor}}

Naturality and dinaturality laws use function liftings such as $f^{\uparrow G}$
or $f^{\uparrow P^{A,\bullet}}$. How are these liftings defined?
Sections~\ref{subsec:f-Functor-constructions} and~\ref{subsec:f-Contrafunctor-constructions}
derive lawful and fully parametric implementations of the \lstinline!fmap!
and \lstinline!cmap! methods for all functors and contrafunctors
built up from the six type constructions. The naturality laws involved
in the parametricity theorem must use precisely those \textsf{``}standard\textsf{''}
implementations of \lstinline!fmap! and \lstinline!cmap!, because
the proof of the parametricity theorem significantly depends on the
code of those standard implementations.

The structure of a given fully parametric type constructor $F$ dictates
a unique implementation of a lifting $f^{\uparrow F}$ or $f^{\downarrow F}$.
Let us summarize these implementations for the six type constructions
for the case when $F^{A}$ is covariant in $A$:

\paragraph{Constant type}

If $F^{A}\triangleq Z$ where $Z$ is a fixed type then $f^{\uparrow F}=\text{id}^{:Z\rightarrow Z}$.

\paragraph{Type parameter}

If $F^{A}\triangleq A$ then $f^{\uparrow F}=f$. If $F^{A}\triangleq G^{H^{A}}$
then $f^{\uparrow F}=(f^{\uparrow H})^{\uparrow G}$ if both $G$
and $H$ are functors and $f^{\uparrow F}=(f^{\downarrow H})^{\downarrow G}$
if both $G$ and $H$ are contrafunctors.

\paragraph{Products}

If $F^{A}\triangleq G^{A}\times H^{A}$ then $f^{\uparrow F}=f^{\uparrow G}\boxtimes f^{\uparrow H}$.

\paragraph{Co-products}

If $F^{A}\triangleq G^{A}+H^{A}$ then $f^{\uparrow F}=f^{\uparrow G}\boxplus f^{\uparrow H}$.

\paragraph{Function types}

If $F^{A}\triangleq G^{A}\rightarrow H^{A}$ then $f^{\uparrow F}=p^{:G^{A}\rightarrow H^{A}}\rightarrow f^{\downarrow G}\bef p\bef f^{\uparrow H}$.

\paragraph{Recursive type}

If $F^{A}\triangleq S^{A,F^{A}}$ then $f^{\uparrow F}=f^{\uparrow S^{\bullet,F^{A}}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{B,\bullet}}$.
Here $\overline{f^{\uparrow F}}$ is a recursive call to $f^{\uparrow F}$.

In addition, we will need a seventh type construction: the universally
quantified\index{types!universally quantified} type.

\paragraph{Quantified type}

If $F^{A}\triangleq\forall X.\,P^{X,A}$ where $P^{X,A}$ is covariant
in $A$ then: 
\[
f^{\uparrow F}=\forall Y.\,p^{:\forall X.\,P^{X,A}}\rightarrow p^{Y}\triangleright f^{\uparrow P^{Y,\bullet}}\quad.
\]

It turns out that there no other lawful implementations of \lstinline!fmap!
for these type constructions, if we assume that the naturality laws
hold:

\subsubsection{Statement \label{subsec:Statement-functor-is-unique}\ref{subsec:Statement-functor-is-unique}}

There is only one implementation of a given functor $F$\textsf{'}s \lstinline!fmap!
method that satisfies the identity, composition, and naturality laws.
Here, the naturality laws are formulated with the standard implementations
of the liftings.

\subparagraph{Proof}

Section~\ref{subsec:f-Functor-constructions} derived the standard
implementations of the \lstinline!fmap! method for all functors $F$
built up via the six type constructions. Throughout this book, this
standard lifting code is denoted by $\text{fmap}_{F}(f)$ and equivalently
by $f^{\uparrow F}$. Now suppose that there exists \emph{another}
lawful implementation of \lstinline!fmap! for $F$, denoted by $\text{fmap}_{F}^{\prime}(f)$:
\[
\text{fmap}_{F}^{\prime}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad,\quad\quad\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B})=\text{???}^{:F^{A}\rightarrow F^{B}}\quad.
\]
We will now show that $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$.
Let us fix the type parameter $A$ and apply the naturality law to
$\text{fmap}_{F}^{\prime}$ with respect to $B$. The resulting law
involves an arbitrary $g^{:B\rightarrow C}$:
\[
\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]
In the naturality law, the lifting $g^{\uparrow F}$ means the \emph{standard}
lifting code: $g^{\uparrow F}\triangleq\text{fmap}_{F}(g)$. By assumption,
$\text{fmap}_{F}^{\prime}$ obeys the composition law, so we may write:
\[
\text{fmap}_{F}^{\prime}(f\bef g)=\text{fmap}_{F}^{\prime}(f)\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]
Since $f^{:A\rightarrow B}$ is arbitrary, we can choose $A=B$ and
$f=\text{id}^{:B\rightarrow B}$ to obtain:
\[
\text{fmap}_{F}^{\prime}(\text{id})\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(\text{id})\bef g^{\uparrow F}\quad.
\]
The identity law for $\text{fmap}_{F}^{\prime}$ gives $\text{fmap}_{F}^{\prime}(\text{id})=\text{id}$,
so we can simplify the last equation to:
\[
\text{fmap}_{F}^{\prime}(g)\overset{!}{=}g^{\uparrow F}=\text{fmap}_{F}(g)\quad.
\]
This must hold for arbitrary $g^{:B\rightarrow C}$, which proves
that $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$.

\subsubsection{Statement \label{subsec:Statement-contrafunctor-is-unique}\ref{subsec:Statement-contrafunctor-is-unique}}

Any contrafunctor $H$ has a unique implementation of a lawful \lstinline!cmap!
method. 

\subparagraph{Proof}

We use similar arguments as in the proof of Statement~\ref{subsec:Statement-functor-is-unique}.
For any lawful alternative implementation $\text{cmap}_{H}^{\prime}$,
the naturality law is:
\[
\text{cmap}_{H}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}(g^{:B\rightarrow C})^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(f)\quad.
\]
By assumption, the identity and composition law hold for $\text{cmap}_{H}^{\prime}$.
Setting $f=\text{id}^{:B\rightarrow B}$, we get:
\[
\text{cmap}_{H}^{\prime}(\text{id}\bef g)=\text{cmap}_{H}^{\prime}(g)\overset{!}{=}g^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(\text{id})=g^{\downarrow H}\quad.
\]
This must hold for arbitrary $g^{:B\rightarrow C}$, which shows that
$\text{cmap}_{H}^{\prime}(g)=g^{\downarrow H}=\text{cmap}_{H}(g)$
as required. $\square$

We just proved that lawful implementations of \lstinline!fmap! and
\lstinline!cmap! are unique when they obey the naturality laws. However,
this does not yet prove that any implementation of \lstinline!fmap!
and \lstinline!cmap! satisfying only the functor laws must also satisfy
naturality laws or be fully parametric (Problem~\ref{subsec:Problem-unique-functor-liftings}).

\subsection{Commutativity laws for bifunctors and profunctors\label{sec:Commutativity-laws-for-type-constructors}}

A special property that holds as a consequence of parametricity is
the bifunctor commutativity law\index{commutativity law!of bifunctors}~(\ref{eq:f-fmap-fmap-bifunctor-commutativity})
introduced in Section~\ref{subsec:Bifunctors}. If a type constructor
$P^{A,B}$ is a functor with respect to $A$ and $B$ separately then
the liftings with respect to the two type parameters will commute:
\[
\text{for all }A,B,C,D,f^{:A\rightarrow C},g^{:B\rightarrow D}\quad:\quad f^{\uparrow P^{\bullet,B}}\bef g^{\uparrow P^{C,\bullet}}=g^{\uparrow P^{A,\bullet}}\bef f^{\uparrow P^{\bullet,D}}\quad.
\]
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{3.0pc}P^{A,B}\ar[r]\sp(0.5){f^{\uparrow P^{\bullet,B}}}\ar[d]\sp(0.45){g^{\uparrow P^{A,\bullet}}} & P^{C,B}\ar[d]\sb(0.45){g^{\uparrow P^{C,\bullet}}}\\
P^{A,D}\ar[r]\sp(0.5){f^{\uparrow P^{\bullet,D}}} & P^{C,D}
}
\]

Similar properties hold for type constructors with any number of type
parameters that are either covariant or contravariant with respect
to each of those type parameters.

We will now prove that the commutativity law holds for any type constructors
with two type parameters, assuming that their lifting methods satisfy
\emph{naturality} laws with respect to each type parameter separately.\footnote{B.~Yorgey showed a proof of the commutativity law for bifunctors
based on the Reynolds-Wadler relational parametricity theorem, see
the blog post \texttt{\href{https://byorgey.wordpress.com/2018/03/30/}{https://byorgey.wordpress.com/2018/03/30/}}\index{Brent Yorgey} } As we will show later (without using these commutativity laws), naturality
laws follow from parametricity. So, the commutativity laws hold for
any type constructors with two type parameters as long as the lifting
code is fully parametric.

\subsubsection{Statement \label{subsec:Proof-of-the-profunctor-commutativity-law}\ref{subsec:Proof-of-the-profunctor-commutativity-law}}

Assume a profunctor $P^{A,B}$ contravariant with respect to $A$
and covariant with respect to $B$, such that $\text{cmap}_{P^{\bullet,B}}$
obeys the naturality law with respect to the type parameter $B$.
Then the profunctor \textbf{commutativity law}\index{commutativity law!of profunctors}\index{profunctor!commutativity law}
holds:
\begin{align}
{\color{greenunder}\text{commutativity law of }P:}\quad & \text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{fmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,D}}(f)\quad,\nonumber \\
{\color{greenunder}\text{in a shorter notation}:}\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.\label{eq:profunctor-commutativity-law}
\end{align}
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,B}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})~~~}\ar[d]\sb(0.45){\text{fmap}_{P^{C,\bullet}}(g)} & P^{A,B}\ar[d]\sb(0.45){\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})}\\
P^{C,D}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,D}}(f)} & P^{A,D}
}
\]


\subparagraph{Proof}

The type signature of the \lstinline!cmap! method is:
\[
\text{cmap}_{P^{\bullet,B}}:(A\rightarrow C)\rightarrow P^{C,B}\rightarrow P^{A,B}\quad.
\]
If we fix \lstinline!cmap!\textsf{'}s argument as an arbitrary function $f^{:A\rightarrow C}$
and hold the type parameters $A$ and $C$ fixed, the value $\text{cmap}_{P^{\bullet,B}}(f)$
has the type of a natural transformation between two functors covariant
in $B$. By assumption, \lstinline!cmap! obeys the naturality law
with respect to the parameter $B$. So, the following law holds:
\[
\text{for all }g^{:B\rightarrow D}:\quad\text{cmap}_{P^{\bullet,B}}(f)\bef g^{\uparrow P^{A,\bullet}}\overset{!}{=}g^{\uparrow P^{C,\bullet}}\bef\text{cmap}_{P^{\bullet,D}}(f)\quad.
\]
This equation is exactly the same as the commutativity law~(\ref{eq:profunctor-commutativity-law})
that we need to prove. $\square$

Similarly, we can prove the commutativity laws for bifunctors and
bi-contrafunctors.

\subsubsection{Statement \label{subsec:Proofs-of-commutativity-for-bifunctor}\ref{subsec:Proofs-of-commutativity-for-bifunctor}}

Any bifunctor or bi-contrafunctor satisfies its commutativity law
as long as its lifting methods satisfy the naturality laws. A \textbf{bi-contrafunctor}
$P^{A,B}$ is a type constructor contravariant with respect to both
$A$ and $B$. The commutativity law for bi-contrafunctors is written
as:
\begin{align}
{\color{greenunder}\text{commutativity law of }P:}\quad & \text{cmap}_{P^{\bullet,D}}(f^{:A\rightarrow C})\bef\text{cmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{cmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,B}}(f)\quad.\nonumber \\
{\color{greenunder}\text{shorter notation}:}\quad & f^{\downarrow P^{\bullet,D}}\bef g^{\downarrow P^{A,\bullet}}=g^{\downarrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\quad.\label{eq:bi-contrafunctor-commutativity-law}
\end{align}
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,D}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,D}}(f)~~~}\ar[d]\sb(0.45){\text{cmap}_{P^{C,\bullet}}(g)} & P^{A,D}\ar[d]\sb(0.45){\text{cmap}_{P^{A,\bullet}}(g)}\\
P^{C,B}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,B}}(f)} & P^{A,B}
}
\]


\subparagraph{Proof}

The commutativity law of bifunctors is Eq.~(\ref{eq:f-fmap-fmap-bifunctor-commutativity}),
written more briefly as:
\[
\text{fmap}_{F^{\bullet,B}}(f^{:A\rightarrow C})\bef(g^{:B\rightarrow D})^{\uparrow F^{C,\bullet}}=g^{\uparrow F^{A,\bullet}}\bef\text{fmap}_{F^{\bullet,D}}(f)\quad.
\]
This equation is the same as the naturality law of $\text{fmap}_{F^{\bullet,B}}$
with respect to the type parameter $B$, where the function $f^{:A\rightarrow C}$
is fixed but $g^{:B\rightarrow D}$ is arbitrary. That naturality
law holds by assumption.

The commutativity law~(\ref{eq:bi-contrafunctor-commutativity-law})
of bi-contrafunctors is the same as the naturality law of $\text{cmap}_{P^{A,\bullet}}$
with respect to the type parameter $A$. That naturality law holds
by assumption.$\square$

The same techniques and proofs apply to type constructors with more
than two type parameters. Liftings with respect to separate type
parameters always commute.

\section{Relational formulation of parametricity\label{sec:Parametricity-theorem-for-relations}\label{subsec:Relations-between-types}}

Naturality laws are formulated using arbitrary functions $f^{:A\rightarrow B}$
between arbitrary types $A$ and $B$. Typically, a naturality law
is an equation that involves the function $f$ lifted to some functors.
For instance, $f^{\uparrow G}\bef t=t\bef f^{\uparrow H}$ is the
naturality law of a natural transformation $t:\forall A.\,G^{A}\rightarrow H^{A}$,
where $G$ and $H$ are some functors.

To prove that naturality laws hold for any fully parametric function
$t$, we need to use induction in the structure of the code of $t$.
The proof will decompose $t$ into smaller sub-expressions for which
the naturality law should hold by the inductive assumption. Some of
those sub-expressions will have types that are no longer of the form
$\forall A.\,G^{A}\rightarrow H^{A}$. So, we need to generalize naturality
laws to type signatures of the form $\forall A.\,P^{A,A}$, where
$P^{X,Y}$ is a profunctor (contravariant in $X$ and covariant in
$Y$). 

Generalizing the naturality law to profunctors is not easy because
we cannot lift an arbitrary function $f^{:A\rightarrow B}$ to a function
of type $P^{A,A}\rightarrow P^{B,B}$. To resolve this difficulty,
the Reynolds-Wadler approach replaces functions $f^{:A\rightarrow B}$
by arbitrary many-to-many relations between values of types $A$ and
$B$. The type of those relations is denoted by $A\leftrightarrow B$.
It turns out that any relation $r$ of type $A\leftrightarrow B$
\emph{can} be lifted to a relation (denoted by $r^{\updownarrow P}$)
of type $P^{A,A}\leftrightarrow P^{B,B}$. The lifting operation can
be defined for any exponential-polynomial profunctor $P$. Using that
operation, we will prove the \textsf{``}relational parametricity theorem\textsf{''}:
any fully parametric code expression (not necessarily a function)
of type $\forall A.\,P^{A,A}$ satisfies a specially formulated relational
naturality law. That law will then allow us to derive the wedge law~(\ref{eq:wedge-law-for-profunctors})
and the ordinary naturality laws.

\paragraph{Remark}

Parametricity can be extended to types and code constructions beyond
those covered in this book. The scope of material in this Appendix
is intentionally limited to theory that has already proven its wide
practical importance for programmers. For instance, we do not cover
parametricity for functions with typeclass constraints. The corresponding
theory is complicated\footnote{The theory of parametricity applied to functions with typeclass constraints
is developed by J.~Voigtl\"ander\index{Janis@Janis Voigtl\"ander}
in the paper \texttt{\href{https://www.janis-voigtlaender.eu/papers/FreeTheoremsInvolvingTypeConstructorClasses.pdf}{https://www.janis-voigtlaender.eu/papers/FreeTheoremsInvolvingTypeConstructorClasses.pdf}}} and yet delivers few practically useful results. For example, Statement~\ref{subsec:Statement-identity-monad-morphism}(b)
considers functions with the following type signature:
\begin{lstlisting}
def epsilon[M[_]: Monad, A]: M[A] => M[A]
\end{lstlisting}
If \lstinline!epsilon! is a monad morphism that works in the same
way for all monads \lstinline!M! and all types \lstinline!A!, can
we prove that \lstinline!epsilon! is an identity function? The theory
of parametricity with typeclass constraints does not appear to give
a solution to that problem; a completely different technique is required.
The analogous question involving functors \emph{can} be answered via
parametricity. It follows from the Yoneda lemma for functors (Statement~\ref{subsec:Statement-covariant-yoneda-identity-for-type-constructors})
that any fully parametric function with the type signature $\forall F^{\bullet}.\,\forall A.\,F^{A}\rightarrow F^{A}$,
where $F$ is a functor, or in Scala:
\begin{lstlisting}
def epsilon[F[_]: Functor, A]: F[A] => F[A]
\end{lstlisting}
must be an identity function. $\square$

\subsection{Relations between values of different types}

Programmers are familiar with \textsf{``}relations\textsf{''} as tables in relational
databases. A simple table has two columns with values of some fixed
types, say \lstinline!INT! and \lstinline!FLOAT!. As an example,
consider a table called \lstinline!R! containing this data:
\begin{center}
$R=$ %
\begin{tabular}{|c|c|}
\hline 
\lstinline!SAMPLE_COUNT: INT! & \lstinline!MEAN_VALUE: FLOAT!\tabularnewline
\hline 
\hline 
{\footnotesize{}150} & {\footnotesize{}0.92}\tabularnewline
\hline 
{\footnotesize{}150} & {\footnotesize{}0.95}\tabularnewline
\hline 
{\footnotesize{}180} & {\footnotesize{}0.95}\tabularnewline
\hline 
{\footnotesize{}180} & {\footnotesize{}1.02}\tabularnewline
\hline 
{\footnotesize{}200} & {\footnotesize{}0.95}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Each row of the table \lstinline!R! has a value of type \lstinline!INT!
and a value of type \lstinline!FLOAT! (no \lstinline!NULL! values
are allowed). The existence of a row $\left(180,0.95\right)$ means
that the values $180$ and $0.95$ are \textsf{``}in the relation\textsf{''} \lstinline!R!.
More generally, two values $a^{:\text{Int}}$ and $b^{:\text{Float}}$
are in the relation \lstinline!R! only if there exists a row $\left(a,b\right)$
in the table \lstinline!R!. All other pairs of values $\left(a,b\right)$
are \emph{not} in the relation \lstinline!R!. 

The table \lstinline!R! contains several values in the first column
that correspond to the same value in the second column, and vice versa.
So, the relation \lstinline!R! is many-to-many and cannot be represented
by a function of type \lstinline!Int => Float! or of type \lstinline!Float => Int!.
Instead, we must view the relation \lstinline!R! as a subset of the
set of \emph{all} possible pairs $(a^{:\text{Int}},b^{:\text{Float}})$.
The table \lstinline!R! lists the pairs that belong to that subset.

Instead of listing the pairs, we may describe a relation by implementing
a function telling us whether two given values are in the relation.
The Scala type signature for such a function could be:
\begin{lstlisting}
def inRelationR(a: Int, b: Float): Boolean
\end{lstlisting}
In the short code notation, this function is written as $r:\text{Int}\times\text{Float}\rightarrow\bbnum 2$.
The value $r(a\times b)$ is \lstinline!true! if and only if the
two given values $a$ and $b$ are in the relation $r$.

For proving the parametricity theorem, we will need relations between
values of arbitrary types. Replacing \lstinline!Int! and \lstinline!Float!
by type parameters $A$ and $B$, we get the following definition:

\subsubsection{Definition \label{subsec:Definition-relation-between-A-B}\ref{subsec:Definition-relation-between-A-B}}

A \textbf{relation} of\index{parametricity theorem!relation between values}\index{relation between values!see \textsf{``}value relation\textsf{''}}\index{value relation}
type $A\leftrightarrow B$ is a function $r:A\times B\rightarrow\bbnum 2$.
The type notation $A\leftrightarrow B$ indicates that relations are
more general than functions of types $A\rightarrow B$ or $B\rightarrow A$.
If values $x$ and $y$ are in a relation $r$, we write $(x,y)\in r$
or with full type annotations: $(x^{:A},y^{:B})\in r^{:A\leftrightarrow B}$.
The condition $(x,y)\in r$ is equivalent to $r(x,y)=\text{true}$.
$\square$

Defined in this sense, relations hold between values of given types.
Certain values $x^{:A}$ and $y^{:B}$ will be in a given relation
$r^{:A\leftrightarrow B}$, while other values of the same types will
not be in the relation $r$. This should not be confused with \index{type relation}\emph{type
relations} described in Section~\ref{subsec:Typeclasses-type-relations},
where certain \emph{types} will be in a given type relation while
other types will not be in that relation. We will not use any type
relations in this Appendix, so we will write simply \textsf{``}a relation
between $A$ and $B$\textsf{''} to mean \textsf{``}a relation between \emph{values}
of types $A$ and $B$\textsf{''}.

A simple example of a relation is the \textbf{identity relation}\index{identity relation},
denoted by $\text{id}^{:A\leftrightarrow A}$. The identity relation
holds only when two values of type $A$ are equal:
\[
(x^{:A},y^{:A})\in\text{id}^{:A\leftrightarrow A}\quad\text{ means }\quad x=y\quad.
\]

To use the parametricity theorem in practice, we will need to convert
functions into relations. A function $f^{:A\rightarrow B}$ generates
the \index{function graph relation}\textbf{function graph} \textbf{relation}
denoted by $\left<f\right>$ and defined as:
\[
(a^{:A},b^{:B})\in\left<f\right>\text{ means }f(a)=b\quad\text{or equivalently}:\quad a\triangleright f=b\quad.
\]
Function graph relations $\left<f\right>$ are generally \emph{many-to-one}
relations because one or more values of type $A$ may be related to
a single value of type $B$.

Given a relation $r^{:A\leftrightarrow B}$, we can swap $x^{:A}$
and $y^{:B}$ in the condition $(x,y)\in r$ and obtain the \index{reverse relation}\textbf{reverse
relation} of type $B\leftrightarrow A$, denoted $\text{rev}\left(r\right)$,
such that $(y,x)\in\text{rev}\left(r\right)$. For a function $f^{:A\rightarrow B}$,
the reverse function graph relation $\text{rev}\left<f\right>$ has
type $B\leftrightarrow A$ and is generally a one-to-many relation. 

The operation \lstinline!rev! is its own inverse, displaying an isomorphism
between the relation types $A\leftrightarrow B$ and $B\leftrightarrow A$:
\[
\text{rev}\left(\text{rev}\left(r\right)\right)=r\quad.
\]
To prove this, substitute the definition of \lstinline!rev! twice:
\[
(x^{:A},y^{:B})\in\text{rev}\,\big(\text{rev}\,(r)\big)\quad\text{is the same as}:\quad(y,x)\in\text{rev}\,(r)\quad\text{and is the same as}:\quad(x,y)\in r\quad.
\]

Here is an example of a relation $r^{:A\leftrightarrow B}$ that is
\emph{not} equivalent to a function graph:
\[
(x^{:A},y^{:B})\in r\text{ means }p(x)=q(y)\text{ where }p^{:A\rightarrow C}\text{ and }q^{:B\rightarrow C}\text{ are some given functions}\quad.
\]
We call this a \textbf{pullback relation}\index{pullback relation|textit}
and denote it by $\text{pull}\,(p,q)$. For some choices of $p$ and
$q$, there will be many different values $x_{1}$, $x_{2}$, $y_{1}$,
$y_{2}$, ..., such that $p(x_{1})=p(x_{2})=q(y_{1})=q(y_{2})=...$
Then the pullback relation will be many-to-many and will not be equivalent
to $\left<f\right>$ or to $\text{rev}\left<f\right>$ for any function
$f$. 

In the derivations below, we will often use relations of type $P^{A,A}\leftrightarrow P^{B,B}$,
where $P^{X,Y}$ is a profunctor (contravariant in $X$ and covariant
in $Y$). For any function $f^{:A\rightarrow B}$, there is a special
pullback relation of type $P^{A,A}\leftrightarrow P^{B,B}$: 

\subsubsection{Definition \label{subsec:Definition-wedge-relation}\ref{subsec:Definition-wedge-relation}}

Given a profunctor\index{profunctor!wedge relation}\index{wedge relation|textit}
$P^{X,Y}$ and a function $f^{:A\rightarrow B}$, two values $x^{:P^{A,A}}$
and $y^{:P^{B,B}}$ are \textbf{in a} $\left(P,f\right)$-\textbf{wedge
relation} if $x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$.
This condition can be written more concisely as $(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})$.

The wedge relation comes up often in applications of the relational
parametricity theorem. The $\left(P,f\right)$-wedge relation generalizes
the wedge law~(\ref{eq:wedge-law-for-profunctors}) to two arbitrary
values $x$ and $y$. The wedge law of an expression $p:\forall A.\,P^{A,A}$
is equivalent to the requirement that $p^{A}$ and $p^{B}$ are in
the $\left(P,f\right)$-wedge relation for all $f^{:A\rightarrow B}$
and for all types $A$, $B$. 

\subsection{Relational product, co-product, and pair mapper. Relational lifting}

To motivate the formulation of the relational naturality law, we will
begin by rewriting ordinary naturality laws involving functions, such
as Eq.~(\ref{eq:naturality-law-for-functors}), in terms of relations.
A naturality law involves lifting an arbitrary function $f^{:A\rightarrow B}$
to some functors or contrafunctors. Lifting a function $f^{:A\rightarrow B}$
to a functor $G$ yields a function $f^{\uparrow G}$ of type $G^{A}\rightarrow G^{B}$.
Lifting $f$ to a contrafunctor $H$ yields a function $f^{\downarrow H}:H^{B}\rightarrow H^{A}$.
Below we will define a lifting of an arbitrary relation $r^{:A\leftrightarrow B}$
to an arbitrary type constructor $G$. The lifted relation will have
type $G^{A}\leftrightarrow G^{B}$ and will be denoted by $r^{\updownarrow G}$.

It turns out that the lifted relation $r^{\updownarrow G}$ can be
expressed through the initial relation $r$ via certain \textsf{``}\textbf{relational
combinators}\textsf{''}.\index{relational combinators} This section defines
the pair mapper, the product, and the co-product combinators.

\paragraph{Remark}

Binary relations support some additional operations, such as union,
intersection, and composition (an operation similar to \lstinline!JOIN!
in relational databases). The composition of two relations $r:A\leftrightarrow B$
and $s:B\leftrightarrow C$ is a new relation of type $A\leftrightarrow C$,
denoted by $r\circ s$ and defined as $(x^{:A},z^{:C})\in r\circ s$
when $\exists y^{:B}:(x,y)\in r$ and $(y,z)\in s$. However, this
book shows that the practically useful parametricity properties are
proved without using the composition, union, or intersection of relations.
In fact, the simultaneous lifting construction (Definition~\ref{subsec:Definition-simultaneous-relational-lifting})
\emph{cannot} be defined via the relational composition, in particular
because $(r\circ s)^{\updownarrow F}\neq r^{\updownarrow F}\circ s^{\updownarrow F}$
for some type constructors $F$ and because the relation $(r\circ s)\ogreaterthan(u\circ v)$
follows from but is \emph{not} equivalent to $(r\ogreaterthan u)\circ(s\ogreaterthan v)$.
$\square$

To motivate the pair mapper construction, begin by considering a natural
transformation $t:\forall A.\,G^{A}\rightarrow H^{A}$ with its naturality
law $f^{\uparrow G}\bef t=t\bef f^{\uparrow H}$. To obtain a relational
formulation of that law, we first apply both sides to an arbitrary
value $p^{:G^{A}}$:
\[
p\triangleright f^{\uparrow G}\triangleright t^{B}=p\triangleright t^{A}\triangleright f^{\uparrow H}\quad,\quad\quad\text{or equivalently}:\quad t^{B}(p\triangleright f^{\uparrow G})=t^{A}(p)\triangleright f^{\uparrow H}\quad,
\]
and denote by $q$ the value $q^{:G^{B}}\triangleq p\triangleright f^{\uparrow G}$.
This definition of $q$ is equivalent to the condition $(p,q)\in\langle f^{\uparrow G}\rangle$.
Now we can rewrite the naturality law of $t$ via relations: 
\begin{equation}
\forall f^{:A\rightarrow B},p^{:G^{A}},q^{:G^{B}}\quad:\quad\quad\text{when}\quad(p,q)\in\langle f^{\uparrow G}\rangle\quad\quad\text{then}\quad(t^{A}(p),t^{B}(q))\in\langle f^{\uparrow H}\rangle\quad.\label{eq:naturality-law-of-t-derivation1}
\end{equation}

We will define a concise notation for conditions of this form because
they are used often when working with relations.

\subsubsection{Definition \label{subsec:Definition-pair-mapper-of-relations}\ref{subsec:Definition-pair-mapper-of-relations}}

\index{pair mapper of relations}The \textbf{pair mapper of relations}
$r^{:A\leftrightarrow C}$ and $s^{:B\leftrightarrow D}$ is a relation
$r\varogreaterthan s$ defined by:
\begin{align*}
 & \big(r^{:A\leftrightarrow C}\varogreaterthan s^{:B\leftrightarrow D}\big):\left(A\rightarrow B\right)\leftrightarrow\left(C\rightarrow D\right)\quad,\\
 & (f^{:A\rightarrow B},g^{:C\rightarrow D})\in r\varogreaterthan s\quad\text{means}\quad\quad\forall x^{:A},y^{:C}\quad:\quad\text{if }(x,y)\in r\quad\text{then}\quad(f(x),g(y))\in s\quad.
\end{align*}
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.2pc}A\ar@{<->}[d]\sp(0.5){r}\ar[rr]\sp(0.5){f} & \ar@{<->}[d(0.9)]\sp(0.55){r\varogreaterthan s} & B\ar@{<->}[d]\sp(0.5){s}\\
C\ar[rr]\sb(0.5){g} &  & D
}
\]

\noindent The operation $\ogreaterthan$ associates to the right,
so that $r\ogreaterthan s\ogreaterthan t\triangleq r\ogreaterthan\left(s\ogreaterthan t\right)$.
The type diagram at left illustrates the pair mapper construction.
To read the diagram, we start with two values, $x^{:A}$ at the top
left and $y^{:C}$ at the bottom left, and two relations, $r^{:A\leftrightarrow C}$
and $s^{:B\leftrightarrow D}$. The values $x$ and $y$ are arbitrary
as long as $(x,y)\in r$. The new relation $r\ogreaterthan s$ is
between functions of types $A\rightarrow B$ and $C\rightarrow D$.
Two functions $\left(f,g\right)$ are in the relation $r\varogreaterthan s$
if the diagram commutes, which means that $(f(x),g(y))\in s$. $\square$

Using Definition~\ref{subsec:Definition-pair-mapper-of-relations},
we can now rewrite the naturality law~(\ref{eq:naturality-law-of-t-derivation1})
as:
\[
\text{for any }f^{:A\rightarrow B}\quad:\quad(t^{A},t^{B})\in\langle f^{\uparrow G}\rangle\ogreaterthan\langle f^{\uparrow H}\rangle\quad.
\]

It appears reasonable to expect that the relation $\left<f\right>$
lifted to $G$ is the same relation as $\langle f^{\uparrow G}\rangle$:
\[
\left<f\right>^{\updownarrow G}=\langle f^{\uparrow G}\rangle\quad.
\]
We will prove this property in Statement~\ref{subsec:Statement-lifting-function-relation-covariant-1})
below. Then we rewrite Eq.~(\ref{eq:naturality-law-of-t-derivation1})
as:
\[
\text{for any }f^{:A\rightarrow B}:\quad(t^{A},t^{B})\in\left<f\right>^{\updownarrow G}\ogreaterthan\left<f\right>^{\updownarrow H}\quad.
\]
So far, this is just the ordinary naturality law written in terms
of function graph relation $\left<f\right>$. We now replace $\left<f\right>$
by an arbitrary relation $r^{:A\leftrightarrow B}$ and obtain the\index{naturality law!in terms of relations}
\textbf{relational naturality law}:
\begin{equation}
\text{for any relation }r^{:A\leftrightarrow B}:\quad(t^{A},t^{B})\in r^{\updownarrow G}\ogreaterthan r^{\updownarrow H}\quad.\label{eq:naturality-law-of-t-derivation2}
\end{equation}

Note the similarity of the relation $r^{\updownarrow G}\ogreaterthan r^{\updownarrow H}$
and the type $G^{A}\rightarrow H^{A}$ of $t$. Denote the type signature
of $t$ by $P^{A}\triangleq G^{A}\rightarrow H^{A}$. If we \emph{define}
the lifting $r^{\updownarrow P}$ as $r^{\updownarrow G}\ogreaterthan r^{\updownarrow H}$,
the law~(\ref{eq:naturality-law-of-t-derivation2}) becomes:
\begin{equation}
\text{for any relation }r^{:A\leftrightarrow B}:\quad(t^{A},t^{B})\in r^{\updownarrow P}\quad.\label{eq:naturality-law-of-t-derivation3}
\end{equation}

This generalization of the naturality law from functions to relations
now has a concise form: The components $t^{A}$ and $t^{B}$ of a
natural transformation $t$ belong to \emph{any} relation $r$ lifted
to $t$\textsf{'}s type signature (the type constructor $P$). This prepares
us for the formulation of the parametricity theorem below. At the
same time, this motivates using the pair mapper operation ($\ogreaterthan$)
to define the lifting a relation to a function type constructor such
as $G^{A}\rightarrow H^{A}$.

To build intuition, let us prove a simple property of the pair mapper:

\subsubsection{Statement \label{subsec:Statement-pair-mapper-rev}\ref{subsec:Statement-pair-mapper-rev}}

For any two relations $r^{:A\leftrightarrow C}$ and $s^{:B\leftrightarrow D}$,
we have:
\[
\text{rev}\,(r\varogreaterthan s)=(\text{rev}\,(r))\varogreaterthan\text{rev}\,(s)\quad.
\]


\subparagraph{Proof}

Write the left-hand side in detail. For any functions $f^{:A\rightarrow B}$
and $g^{:C\rightarrow D}$, the relation $(g^{:C\rightarrow D},f^{:A\rightarrow B})\in\text{rev}\,(r\varogreaterthan s)$
means the same as $(f,g)\in r\varogreaterthan s$, or:
\[
\forall x^{:A},y^{:C}:\quad\text{when}\quad(x,y)\in r\quad\text{then}\quad(f(x),g(y))\in s\quad.
\]
The right-hand side: $(g^{:C\rightarrow D},f^{:A\rightarrow B})\in(\text{rev}\,(r))\varogreaterthan\text{rev}\,(s)$
means:
\[
\forall y^{:C},x^{:A}:\quad\text{when}\quad(y,x)\in\text{rev}\,(r)\quad\text{then}\quad(g(y),f(x))\in\text{rev}\,(s)\quad.
\]
The conditions for both sides are equivalent. $\square$ 

What about lifting a relation to product ($G^{A}\times H^{A}$) or
co-product ($G^{A}+H^{A}$) type constructors? Recall that lifting
a function to $G^{A}\times H^{A}$ involves the pair product of functions\index{pair product of functions}
($\boxtimes$):
\[
\big(f^{:A\rightarrow C}\boxtimes g^{:B\rightarrow D}\big):A\times B\rightarrow C\times D\quad,\quad\quad f\boxtimes g\triangleq a\times b\rightarrow f(a)\times g(b)\quad.
\]
Namely, the lifting of a function $k^{:A\rightarrow B}$ to $G^{A}\times H^{A}$
is defined by $k^{\uparrow(G\times H)}\triangleq k^{\uparrow G}\boxtimes k^{\uparrow H}$. 

The pair co-product of functions\index{pair co-product of functions}
is defined in Exercise~\ref{subsec:Exercise-reasoning-1-4-1}(b):
\begin{align*}
 & \big(f^{:A\rightarrow C}\boxplus g^{:B\rightarrow D}\big):A+B\rightarrow C+D\quad,\\
 & (f\boxplus g)(a^{:A}+\bbnum 0^{:B})\triangleq f(a)+\bbnum 0^{:D}\quad,\quad\quad(f\boxplus g)(\bbnum 0+b^{:B})\triangleq\bbnum 0^{:C}+g(b)\quad,\\
 & (k^{:A\rightarrow B})^{\uparrow(G+H)}\triangleq k^{\uparrow G}\boxplus k^{\uparrow H}\quad.
\end{align*}

We will now define the analogous constructions for relations.

\subsubsection{Definition \label{subsec:Definition-pair-product-of-relations}\ref{subsec:Definition-pair-product-of-relations}}

Given two relations $r^{:A\leftrightarrow C}$ and $s^{:B\leftrightarrow D}$,
the \textbf{pair product} \index{pair product of relations} $r\boxtimes s$
is a relation between values of the product types $A\times B$ and
$C\times D$:
\[
\big(r^{:A\leftrightarrow C}\boxtimes s^{:B\leftrightarrow D}\big):A\times B\leftrightarrow C\times D\quad,\quad\quad(a\times b,c\times d)\in r\boxtimes s\quad\text{when}\quad(a,c)\in r\text{ and }(b,d)\in s\quad.
\]

The second construction is the pair co-product of relations\index{pair co-product of relations},
which creates a relation between co-products of types. The definition
resembles that of the \index{pair co-product of functions}pair co-product
of functions:

\subsubsection{Definition \label{subsec:Definition-pair-co-product-of-relations}\ref{subsec:Definition-pair-co-product-of-relations}}

The \textbf{pair co-product} of relations $r^{:A\leftrightarrow C}$
and $s^{:B\leftrightarrow D}$ is a relation $r\boxplus s$ defined
by:
\begin{align*}
 & \big(r^{:A\leftrightarrow C}\boxplus s^{:B\leftrightarrow D}\big):A+B\leftrightarrow C+D\quad,\\
 & \text{either}\quad\quad(a^{:A}+\bbnum 0^{:B},c^{:C}+\bbnum 0^{:D})\in r\boxplus s\quad\text{when}\quad(a,c)\in r\quad,\\
 & \text{or}\quad\quad(\bbnum 0^{:A}+b^{:B},\bbnum 0^{:C}+d^{:D})\in r\boxplus s\quad\text{when}\quad(b,d)\in s\quad.
\end{align*}

If we are given two values $x^{:A+B}$ and $y^{:C+D}$, how do we
decide whether $(x,y)\in r\boxplus s$? The value $x$ is either of
the form $a+\bbnum 0$ (for some value $a^{:A}$) or of the form $\bbnum 0+b$
(for some $b^{:B}$). Similarly, $y$ is either of the form type $c^{:C}+\bbnum 0$
or of the form $\bbnum 0+d^{:D}$. The relation $r\boxplus s$ is
defined such that $(x,y)$ is in $r\boxplus s$ when one of the two
cases holds: (1) either $x$ and $y$ are both in the first parts
of their disjunctive types (and then we must have $(a,c)\in r$),
or (2) $x$ and $y$ are both in the second parts (and then we must
have $(b,d)\in s$). Any other combinations of values (such as $x=a+\bbnum 0$
and $y=\bbnum 0+d$) are \emph{not} in the relation $r\boxplus s$.

To build more intuition, let us prove some properties of the relational
operations $\boxtimes$, $\boxplus$, and $\ogreaterthan$ when applied
to function graph relations.

\subsubsection{Example \label{subsec:Example-pair-product-pair-mapper-relation}\ref{subsec:Example-pair-product-pair-mapper-relation}\index{examples}}

For arbitrary given functions $f^{:A\rightarrow B}$ and $g^{:C\rightarrow D}$,
show that:

\textbf{(a)} $\left<f\right>\boxtimes\left<g\right>=\left<f\boxtimes g\right>$,
both relations having type $A\times C\leftrightarrow B\times D$.

\textbf{(b)} $\left<f\right>\boxplus\left<g\right>=\left<f\boxplus g\right>$,
both relations having type $A+C\leftrightarrow B+D$.

\textbf{(c)} $\left<f\right>\ogreaterthan\text{id}^{:C\leftrightarrow C}=\text{rev}\,\langle l^{:B\rightarrow C}\rightarrow f\bef l\rangle$,
both relations having type $\left(A\rightarrow C\right)\leftrightarrow\left(B\rightarrow C\right)$.

\textbf{(d)} $\text{id}^{:A\leftrightarrow A}\ogreaterthan\left<g\right>=\langle k^{:A\rightarrow C}\rightarrow k\bef g\rangle$,
both relations having type $\left(A\rightarrow C\right)\leftrightarrow\left(A\rightarrow D\right)$.

\textbf{(e)} $\left<f\right>\ogreaterthan\left<g\right>=\text{pull}\,(k^{:A\rightarrow C}\rightarrow k\bef g,\;l^{:B\rightarrow C}\rightarrow f\bef l)$,
both relations having type $\left(A\rightarrow C\right)\leftrightarrow\left(B\rightarrow D\right)$.

\textbf{(f)} $\left<f\right>\ogreaterthan\text{rev}\left<g\right>=\text{rev}\langle k^{:B\rightarrow C}\rightarrow f\bef k\bef g\rangle$,
both relations having type $\left(A\rightarrow D\right)\leftrightarrow\left(B\rightarrow C\right)$.

\textbf{(g)} $(\text{rev}\left<f\right>)\ogreaterthan\left<g\right>=\langle k^{:B\rightarrow C}\rightarrow f\bef k\bef g\rangle$,
both relations having type $\left(B\rightarrow C\right)\leftrightarrow\left(A\rightarrow D\right)$.

\subparagraph{Solution}

We will use various relations with arbitrary values $a^{:A}$, $b^{:B}$,
$c^{:C}$, $d^{:D}$.

\textbf{(a)} The following conditions are equivalent:
\begin{align*}
 & (a\times c,b\times d)\in\left<f\right>\boxtimes\left<g\right>\quad\text{means}\quad(a,b)\in\left<f\right>\quad\text{and}\quad(c,d)\in\left<g\right>\quad\text{or}:\quad f(a)=b\text{ and }g(c)=b\quad,\\
 & (a\times c,b\times d)\in\left<f\boxtimes g\right>\quad\text{means}\quad(a\times c)\triangleright(f\boxtimes g)=b\times d\quad\text{or}:\quad f(a)\times g(c)=b\times d\quad.
\end{align*}

\textbf{(b)} The following conditions are equivalent:
\begin{align*}
 & (a+\bbnum 0,b+\bbnum 0)\in\left<f\right>\boxplus\left<g\right>\quad\text{means}\quad(a,b)\in\left<f\right>\quad\text{or equivalently}:\quad a\triangleright f=b\quad,\\
 & (a+\bbnum 0,b+\bbnum 0)\in\left<f\boxplus g\right>\quad\text{means}\quad(a+\bbnum 0)\triangleright(f\boxplus g)=b+\bbnum 0\quad\text{or equivalently}:\quad a\triangleright f=b\quad.
\end{align*}
Similarly we can show that the conditions $(\bbnum 0+c,\bbnum 0+d)\in\left<f\right>\boxplus\left<g\right>$
and $(\bbnum 0+c,\bbnum 0+d)\in\left<f\boxplus g\right>$ are equivalent.
Values from different parts of the disjunctions, such as $(a+\bbnum 0,\bbnum 0+d)$,
are not in the relation $\left<f\right>\boxplus\left<g\right>$ by
definition of $\boxplus$. They are also not in the relation $\left<f\boxplus g\right>$
since the function $f\boxplus g$ preserves the left and right parts
of the disjunctions.

\textbf{(c)} Two functions $k^{:A\rightarrow C}$ and $l^{:B\rightarrow C}$
are in the relation $\left<f\right>\ogreaterthan\text{id}^{:C\leftrightarrow C}$
if:
\[
\text{for all }a^{:A},b^{:B}\quad:\quad\text{when}\quad(a,b)\in\left<f\right>\quad\text{then}\quad(k(a),l(b))\in\text{id}^{:C\leftrightarrow C}\quad.
\]
Simplifying the last condition, we get:
\[
\text{for all }a^{:A}\quad:\quad k(a)=l(f(a))\quad,\quad\text{or equivalently}:\quad k=f\bef l\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $k=\psi(l)$
where the function $\psi$ is defined as:
\[
\psi:\left(B\rightarrow C\right)\rightarrow A\rightarrow C\quad,\quad\quad\psi\triangleq l^{:B\rightarrow C}\rightarrow f\bef l\quad.
\]
This relation is denoted by $\text{rev}\left<\psi\right>$. It follows
that $\left<f\right>\ogreaterthan\text{id}^{:C\leftrightarrow C}=\text{rev}\left<\psi\right>=\text{rev}\langle l^{:B\rightarrow C}\rightarrow f\bef l\rangle$.

\textbf{(d)} Two functions $k^{:A\rightarrow C}$ and $l^{:A\rightarrow D}$
are in the relation $\text{id}^{:A\leftrightarrow A}\ogreaterthan\left<g\right>$
if:
\[
\text{for all }x^{:A},y^{:A}\quad:\quad\text{when}\quad(x,y)\in\text{id}^{:A\leftrightarrow A}\quad\text{then}\quad(k(x),l(y))\in\left<g\right>\quad.
\]
Simplifying the last condition, we get:
\[
\text{for all }x^{:A}\quad:\quad g(k(x))=l(x)\quad,\quad\text{or equivalently}:\quad l=k\bef g\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $\phi(k)=l$
where:
\[
\phi:\left(A\rightarrow C\right)\rightarrow A\rightarrow D\quad,\quad\phi\triangleq k^{:A\rightarrow C}\rightarrow k\bef g\quad.
\]
This relation is denoted by $\left<\phi\right>$. It follows that
we may write $\text{id}^{:A\leftrightarrow A}\ogreaterthan\left<g\right>=\left<\phi\right>=\langle k^{:A\rightarrow C}\rightarrow k\bef g\rangle$.

\textbf{(e)} Two functions $k^{:A\rightarrow C}$ and $l^{:B\rightarrow D}$
are in the relation $\left<f\right>\ogreaterthan\left<g\right>$ if:
\[
\text{for all }a^{:A},b^{:B}\quad:\quad\text{when}\quad(a,b)\in\left<f\right>\quad\text{then}\quad(k(a),l(b))\in\left<g\right>\quad.
\]
Simplifying the last condition, we get:
\[
\text{for all }a^{:A}\quad:\quad g(k(a))=l(f(a))\quad,\quad\text{or equivalently}:\quad f\bef l=k\bef g\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $\phi(k)=\psi(l)$
where: 
\[
\phi:\left(A\rightarrow C\right)\rightarrow A\rightarrow D\quad,\quad\phi\triangleq k^{:A\rightarrow C}\rightarrow k\bef g\quad,\quad\psi:\left(B\rightarrow D\right)\rightarrow A\rightarrow D\quad,\quad\psi\triangleq l^{:B\rightarrow C}\rightarrow f\bef l\quad.
\]
 This is a pullback relation that we denote by $\text{pull}\,(\phi,\psi)=\text{pull}\,\big(k^{:A\rightarrow C}\rightarrow k\bef g,\;l^{:B\rightarrow C}\rightarrow f\bef l\big)$.

\textbf{(f)} Two functions $k^{:B\rightarrow C}$ and $l^{:A\rightarrow D}$
are in the relation $\left<f\right>\ogreaterthan\text{rev}\left<g\right>$
if:
\[
\text{for all }x^{:B},y^{:A}\quad:\quad\text{when}\quad(x,y)\in\left<f\right>\quad\text{then}\quad(k(x),l(y))\in\text{rev}\left<g\right>\quad.
\]
Simplifying the last line, we get:
\[
\text{for all }x^{:B}\quad:\quad g(l(f(x)))=k(x)\quad,\quad\text{or equivalently}:\quad f\bef l\bef g=k\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $\phi(l)=k$
or as $(k,l)\in\text{rev}\left<\phi\right>$, where: 
\[
\phi:\left(B\rightarrow C\right)\rightarrow A\rightarrow D\quad,\quad\phi\triangleq k^{:B\rightarrow C}\rightarrow f\bef k\bef g\quad.
\]
So, we get: $\left<f\right>\ogreaterthan\text{rev}\left<g\right>=\text{rev}\left<\phi\right>=\text{rev}\langle k^{:B\rightarrow C}\rightarrow f\bef k\bef g\rangle$.

\textbf{(g)} Apply the reversing operation to both sides of item \textbf{(f)},
we get:
\[
\text{rev}\,(\left<f\right>\ogreaterthan\text{rev}\left<g\right>)=(\text{rev}\left<f\right>)\ogreaterthan\left<g\right>\overset{!}{=}\langle k^{:B\rightarrow C}\rightarrow f\bef k\bef g\rangle\quad.
\]
Here we have used Statement~\ref{subsec:Statement-pair-mapper-rev}
and the property $\text{rev}\left(\text{rev}\,(r)\right)=r$. $\square$

We now turn to defining the relational lifting $r^{\updownarrow G}$
for an arbitrary type constructor $G$. It will turn out that we actually
need to define a more general operation: the \emph{simultaneous} lifting
of several relations to a type constructor with several type parameters.
For clarity, we postpone that definition and begin by lifting a single
relation.

\subsubsection{Definition \label{subsec:Definition-relational-lifting}\ref{subsec:Definition-relational-lifting}
(relational lifting)}

Given a relation $r^{:A\leftrightarrow B}$ and a fully parametric
type constructor $G$, the relational lifting of $r$ to $G$, denoted
by $r^{\updownarrow G}$, is a new relation of type $G^{A}\leftrightarrow G^{B}$.
The relation $r^{\updownarrow G}$ is defined by induction on the
structure of $G$ as shown below in items \textbf{(a)}\textendash \textbf{(g)}.
We will use arbitrary type constructors $K$, $L$, $H$, and $S$
that are assumed to be fully parametric but not necessarily covariant
or contravariant. 

\textbf{(a)} If $G^{A}\triangleq Z$ with a fixed type $Z$ (different
from $A$), we define $r^{\updownarrow G}\triangleq\text{id}^{:Z\leftrightarrow Z}$.

\textbf{(b)} If $G\triangleq\text{Id}$ (that is, $G^{A}\triangleq A$)
then we define $r^{\updownarrow\text{Id}}\triangleq r$. 

\textbf{(c)} If $G^{A}\triangleq K^{A}\times L^{A}$ then we define
$r^{\updownarrow G}\triangleq r^{\updownarrow K}\boxtimes r^{\updownarrow L}$.
The inductive assumptions are that the relational liftings $r^{\updownarrow K}$
and $r^{\updownarrow L}$ are already defined.

\textbf{(d)} If $G^{A}\triangleq K^{A}+L^{A}$ then we define $r^{\updownarrow G}\triangleq r^{\updownarrow K}\boxplus r^{\updownarrow L}$
with the same inductive assumptions.

\textbf{(e)} If $G^{A}\triangleq K^{A}\rightarrow L^{A}$ then we
define $r^{\updownarrow G}\triangleq r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}$
with the same inductive assumptions.

\textbf{(f)} If $G^{A}\triangleq S^{A,G^{A}}$ is defined recursively
via a pattern functor $S$, we define $r^{\updownarrow G}$ by:
\[
r^{\updownarrow G}\triangleq\big(r,\overline{r^{\uparrow G}}\big)^{\updownarrow S}\quad.
\]
Here the notation $(r,s)^{\updownarrow S}$ means the \emph{simultaneous}
lifting of the two relations $r$, $s$ to the type constructor $S$
(see Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
below). The inductive assumption is that simultaneous liftings to
$S$ are already defined. Also note that we use $\overline{r^{\updownarrow G}}$
recursively within the definition of $r^{\updownarrow G}$. This is
allowed since we understand $r^{\updownarrow G}$ to be a function
(of type $G^{A}\times G^{B}\rightarrow\bbnum 2$, see Definition~\ref{subsec:Definition-relation-between-A-B}),
and it is permitted to define functions recursively. 

\textbf{(g)} If $G^{A}\triangleq\forall X.\,H^{X,A}$, we define $r^{\updownarrow G}$
of type $(\forall X.\,H^{X,A})\leftrightarrow(\forall Y.\,H^{Y,B})$
by:
\[
(p^{:\forall X.\,H^{X,A}},q^{:\forall X.\,H^{X,B}})\in r^{\updownarrow\forall X.\,H^{X,\bullet}}\quad\text{means}\quad\forall(X,Y).\,\forall s^{X\leftrightarrow Y}.\,(p^{X},q^{Y})\in(s,r)^{\updownarrow H}\quad.
\]
Here $(s,r)^{\updownarrow H}$ denotes the simultaneous lifting of
$s$ and $r$ to $H$ (Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
below). A shorter way of writing the formula above is by formulating
a relation between $p^{X}$ and $q^{Y}$:
\begin{equation}
\forall(X,Y):\quad\big(r^{\updownarrow\forall Z.\,H^{Z,\bullet}}\big)^{X,Y}\triangleq\forall s^{:X\leftrightarrow Y}.\,(s,r)^{\updownarrow H}\quad.\label{eq:relational-lifting-quantified-types-short}
\end{equation}
The inductive assumption is that the simultaneous lifting to $H$
is already defined. $\square$

We can see that Definition~\ref{subsec:Definition-relational-lifting}
translates the type structure of $G^{A}$ into an analogous relational
structure. Constant types ($Z$) are replaced by identity relations
($\text{id}^{:Z\leftrightarrow Z}$). Each occurrence of $A$ in $G^{A}$
is replaced by an occurrence of the relation $r$ being lifted. Products,
co-products, and function arrows are replaced by the relational operations
$\boxtimes$, $\boxplus$, and $\ogreaterthan$. Recursive usage of
types are replaced by the recursive usage of the lifted relations.
Universally quantified types ($\forall X$) are replaced by universally
quantified relations between new arbitrary types. 

So, an expression for the relational lifting $r^{\updownarrow G}$
can be written immediately by looking at the structure of $G$. For
instance, lifting a relation $r^{:A\leftrightarrow B}$ to a type
constructor $G^{A}\triangleq\forall X.\,\left(A\rightarrow X\right)\times\left(X\rightarrow A+Z\right)$
is written as:
\[
\big(r^{\updownarrow G}\big)^{X,Y}=\forall s^{:X\leftrightarrow Y}.\,(r\ogreaterthan s)\boxtimes\big(s\ogreaterthan(r\boxplus\text{id}^{:Z\leftrightarrow Z})\big)\quad.
\]
 We will illustrate this technique in Example~\ref{subsec:Example-relational-lifting}
below.

To get more intuition, let us prove some properties of function graph
relations, $r\triangleq\left<f\right>$. In some (but not in all)
cases, one can express the lifted relation $\left<f\right>^{\updownarrow P}$
through ordinary function liftings $f^{\uparrow P}$ and $f^{\downarrow P}$
and the $\left(P,f\right)$-wedge condition.

\subsubsection{Example \label{subsec:Example-relational-lifting}\ref{subsec:Example-relational-lifting}\index{examples}}

Consider the function graph relation $\left<f\right>$ of a given
function $f^{:A\rightarrow B}$. Use Definition~\ref{subsec:Definition-relational-lifting}
to compute the lifting $\left<f\right>^{\updownarrow P}$ for the
following type constructors $P$:

\textbf{(a)} $P^{A}\triangleq A+A\times A\quad$.

\textbf{(b)} $P^{A}\triangleq(R\rightarrow A)\times(A\rightarrow S)$
where $R$ and $S$ are fixed types.

\textbf{(c)} $P^{A}\triangleq A\rightarrow A\quad$.

\textbf{(d)} $P^{A}\triangleq A\rightarrow\left(A\rightarrow R\right)\rightarrow R$
where $R$ is a fixed type.

\textbf{(e)} $P^{A}\triangleq\left(A\rightarrow A\right)\rightarrow A\quad$.

In each case \textbf{(a)}\textendash \textbf{(e)}, express $P^{A}\triangleq N^{A,A}$
where $N^{X,Y}$ is a suitable profunctor and compare the condition
$(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$ with the $\left(N,f\right)$-wedge
relation ($p_{1}\triangleright f^{\uparrow N}=p_{2}\triangleright f^{\downarrow N}$). 

\subparagraph{Solution}

In each case, the lifted relation $\left<f\right>^{\updownarrow P}$
has type $P^{A}\leftrightarrow P^{B}$.

\textbf{(a)} At the top level, $P^{A}$ is a disjunctive type : $P^{A}=\text{Id}^{A}+H^{A}$
where $H^{A}\triangleq A\times A=\text{Id}^{A}\times\text{Id}^{A}$.
The lifting to the identity functor is given by $r^{\updownarrow\text{Id}}\triangleq r$
according to Definition~\ref{subsec:Definition-relational-lifting}(b).
So, the lifting $r^{\updownarrow P}$ can be written as:
\[
r^{\updownarrow P}=r^{\updownarrow\text{Id}}\boxplus r^{\updownarrow H}=r^{\updownarrow\text{Id}}\boxplus\big(r^{\updownarrow\text{Id}}\boxtimes r^{\updownarrow\text{Id}}\big)=r\boxplus\big(r\boxtimes r\big)\quad.
\]
We see that the relational formula $r^{\updownarrow P}=r\boxplus\big(r\boxtimes r\big)$
repeats the type structure $P^{A}=A+A\times A$.

Setting now $r=\left<f\right>$, we find:
\[
\left<f\right>^{\updownarrow P}=\left<f\right>\boxplus\left<f\right>^{\updownarrow H}=\left<f\right>\boxplus\big(\left<f\right>\boxtimes\left<f\right>\big)\quad.
\]
Use Definition~\ref{subsec:Definition-relational-lifting}(d) to
express the condition for some values $(x^{:P^{A}},y^{:P^{B}})$ to
be in the relation $\left<f\right>\boxplus\left<f\right>^{\updownarrow H}$:
\[
(x,y)\in\left<f\right>^{\updownarrow P}\text{ if }x=x_{1}+\bbnum 0,\,y=y_{1}+\bbnum 0,\,(x_{1},y_{1})\in\left<f\right>\text{ or }x=\bbnum 0+x_{2},\,y=\bbnum 0+y_{2},\,(x_{2},y_{2})\in\left<f\right>^{\updownarrow H}\quad.
\]
The condition $(x_{1},y_{1})\in\left<f\right>$ means $f(x_{1})=y_{1}$.
Finally, Definition~\ref{subsec:Definition-relational-lifting}(c)
gives:
\[
(a_{1}^{:A}\times a_{2}^{:A},b_{1}^{:B}\times b_{2}^{:B})\in\left<f\right>\boxtimes\left<f\right>\text{ if }(a_{1},b_{1})\in\left<f\right>\text{ and }(a_{2},b_{2})\in\left<f\right>\quad.
\]
The last condition is simplified to:
\[
(a_{1}^{:A}\times a_{2}^{:A},b_{1}^{:B}\times b_{2}^{:B})\in\left<f\right>^{\updownarrow H}\text{ if }f(a_{1})=b_{1}\text{ and }f(a_{2})=b_{2}\quad.
\]

Putting the pieces together, we obtain the following definition of
the relation $\left<f\right>^{\updownarrow P}$:
\[
(x^{:P^{A}},y^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ if }x=x_{1}+\bbnum 0\text{ and }y=f(x_{1})+\bbnum 0,\text{ or }x=\bbnum 0+a_{1}\times a_{2}\text{ and }y=\bbnum 0+f(a_{1})\times f(a_{2})\quad.
\]
We note that this condition is equivalent to applying $f^{\uparrow P}$:
\[
(x^{:P^{A}},y^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ if }x\triangleright f^{\uparrow P}=y\quad,\quad\text{ or more concisely}:\quad\left<f\right>^{\updownarrow P}=\langle f^{\uparrow P}\rangle\quad.
\]

Statement~\ref{subsec:Statement-lifting-function-relation-covariant-1}(a)
below will show that $\left<f\right>^{\updownarrow P}=\langle f^{\uparrow P}\rangle$
for all functors $P$.

With $N^{X,Y}\triangleq P^{Y}$, the $\left(N,f\right)$-wedge relation
is equivalent to the equation $x\triangleright f^{\uparrow P}=y$.

\textbf{(b)} At the top level, $P^{A}$ is a product: $P^{A}=G^{A}\times H^{A}$
where $G^{A}\triangleq R\rightarrow A$ and $H^{A}\triangleq A\rightarrow S$.
By Definition~\ref{subsec:Definition-relational-lifting}(c), we
get $r^{\updownarrow P}=r^{\updownarrow G}\boxtimes r^{\updownarrow H}$.
To compute $r^{\updownarrow G}$, we note that $G$ is an exponential
functor construction, $G^{A}=K^{A}\rightarrow\text{Id}^{A}$, that
uses a constant functor $K^{A}\triangleq R$. Lifting to a constant
functor gives $r^{\updownarrow K}=\text{id}^{:R\leftrightarrow R}$
according to Definition~\ref{subsec:Definition-relational-lifting}(a).
So, we find:
\[
r^{\updownarrow G}=\text{id}^{:R\leftrightarrow R}\ogreaterthan r^{\updownarrow\text{Id}}=\text{id}^{:R\leftrightarrow R}\ogreaterthan r\quad.
\]
We treat $r^{\updownarrow H}$ similarly and obtain $r^{\updownarrow H}=r\ogreaterthan\text{id}^{:S\leftrightarrow S}$.
Put the pieces together:
\[
r^{\updownarrow P}=r^{\updownarrow G}\boxtimes r^{\updownarrow H}=(\text{id}^{:R\leftrightarrow R}\ogreaterthan r)\boxtimes(r\ogreaterthan\text{id}^{:S\leftrightarrow S})\quad.
\]
We see that $r^{\updownarrow P}$ repeats the type structure of $P^{A}=(R\rightarrow A)\times(A\rightarrow S)$.
The occurrences of $A$ in $P^{A}$ are replaced by $r$, while constant
types ($R$, $S$) are replaced by the corresponding identity relations
($\text{id}^{:R\leftrightarrow R}$ and $\text{id}^{:S\leftrightarrow S}$).
We will see a similar pattern in the remaining parts of this example.

We now set $r=\left<f\right>$ and transform $\left<f\right>^{\updownarrow P}$
to a more specific formula for a relation of type $P^{A}\leftrightarrow P^{B}$
where $A$, $B$ are arbitrary types. For arbitrary values $g_{1}^{:R\rightarrow A}$,
$g_{2}^{:R\rightarrow B}$, $h_{1}^{:A\rightarrow S}$, $h_{2}^{:B\rightarrow S}$,
we write:
\[
(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}\text{ means }(g_{1},g_{2})\in\text{id}^{:R\leftrightarrow R}\ogreaterthan\left<f\right>\text{ and }(h_{1},h_{2})\in\left<f\right>\ogreaterthan\text{id}^{:S\leftrightarrow S}\quad.
\]

The condition $(g_{1},g_{2})\in\text{id}\ogreaterthan\left<f\right>$
is rewritten using Definition~\ref{subsec:Definition-relational-lifting}(e):
\[
(g_{1}^{:R\rightarrow A},g_{2}^{:R\rightarrow B})\in\text{id}\ogreaterthan\left<f\right>\text{ means if }(r_{1}^{:R},r_{2}^{:R})\in\text{id}^{:R\leftrightarrow R}\text{ then }(g_{1}(r_{1}),g_{2}(r_{2}))\in\left<f\right>\quad.
\]
The identity relation between $r_{1}$ and $r_{2}$ holds only if
$r_{1}=r_{2}$. We find:
\[
(g_{1}^{:R\rightarrow A},g_{2}^{:R\rightarrow B})\in\text{id}^{:R\leftrightarrow R}\ogreaterthan\left<f\right>\text{ means }\forall r^{:R}.\,f(g_{1}(r))=g_{2}(r)\quad\text{or equivalently}:\quad g_{1}\bef f=g_{2}\quad.
\]

The condition $(h_{1},h_{2})\in\left<f\right>^{\updownarrow H}$ is
rewritten using the same definitions:
\[
(h_{1}^{:A\rightarrow S},h_{2}^{:B\rightarrow S})\in\left<f\right>\ogreaterthan\text{id}^{:S\leftrightarrow S}\text{ means if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(h_{1}(a),h_{2}(b))\in\text{id}\quad.
\]
We simplify this to:
\[
(h_{1}^{:A\rightarrow S},h_{2}^{:B\rightarrow S})\in\left<f\right>\ogreaterthan\text{id}^{:S\leftrightarrow S}\text{ means }h_{1}(a)=h_{2}(f(a))\quad\text{or equivalently}:\quad h_{1}=f\bef h_{2}\quad.
\]

Finally, the lifted relation $\left<f\right>^{\updownarrow P}$ is
expressed as:
\[
(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}\text{ if }g_{1}\bef f=g_{2}\text{ and }h_{1}=f\bef h_{2}\quad.
\]

Defining the profunctor $N^{X,Y}\triangleq\left(R\rightarrow Y\right)\times\left(X\rightarrow S\right)$,
we find that $g_{1}\times h_{1}$ has type $N^{A,A}$ and $g_{2}\times h_{2}$
has type $N^{B,B}$. Then the condition $(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}$
is \emph{equivalent} to the $\left(N,f\right)$-wedge relation:
\[
(g_{1}\times h_{1})\triangleright f^{\uparrow N^{A,\bullet}}=(g_{2}\times h_{2})\triangleright f^{\downarrow N^{\bullet,B}}\quad.
\]

\textbf{(c)} Using Definition~\ref{subsec:Definition-relational-lifting}(b)
and (e), we get:
\begin{align*}
 & r^{\updownarrow P}=r^{\updownarrow\text{Id}}\ogreaterthan r^{\updownarrow\text{Id}}=r\ogreaterthan r\quad,\quad\quad\text{so}\quad\left<f\right>^{\updownarrow P}=\left<f\right>\ogreaterthan\left<f\right>\quad;\\
 & (p_{1}^{:A\rightarrow A},p_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad\text{if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(p_{1}(a),p_{2}(b))\in\left<f\right>\quad.
\end{align*}
The condition can be rewritten as a single equation:
\[
(p_{1}^{:A\rightarrow A},p_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad f(p_{1}(a))=p_{2}(f(a))\quad\text{or equivalently}:\quad p_{1}\bef f=f\bef p_{2}\quad.
\]
This is the same as the $\left(N,f\right)$-wedge relation ($p_{1}\triangleright f^{\uparrow N}=p_{2}\triangleright f^{\downarrow N}$)
with the profunctor $N^{X,Y}\triangleq X\rightarrow Y$.

\textbf{(d)} Since $P^{A}=\text{Id}^{A}\rightarrow Q^{A}$ is a function
type (with $Q^{A}\triangleq\left(A\rightarrow R\right)\rightarrow R$),
we use Definition~\ref{subsec:Definition-relational-lifting}(e):
\[
r^{\updownarrow P}=r^{\updownarrow\text{Id}}\ogreaterthan r^{\updownarrow Q}=r\ogreaterthan(r\ogreaterthan\text{id}^{:R\leftrightarrow R})\ogreaterthan\text{id}^{:R\leftrightarrow R}\quad.
\]
Let us now substitute $r=\left<f\right>$ and simplify the conditions:
\[
(p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>\ogreaterthan\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad\text{if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(p_{1}(a),p_{2}(b))\in\left<f\right>^{\updownarrow Q}\quad.
\]
The definition of $\left<f\right>^{\updownarrow Q}$ is obtained if
we set $K^{A}\triangleq A\rightarrow R$:
\[
(q_{1}^{:Q^{A}},q_{2}^{:Q^{B}})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad\text{if }(k_{1}^{:A\rightarrow R},k_{2}^{:B\rightarrow R})\in\left<f\right>^{\updownarrow K}\text{ then }(q_{1}(k_{1}),q_{2}(k_{2}))\in\text{id}\quad.
\]
Expanding the definition of $\left<f\right>^{\updownarrow K}$ as
we did in part \textbf{(b)} of this example, we get:
\[
(q_{1},q_{2})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad\text{if }b=f(a)\text{ and }k_{1}(a)=k_{2}(b)\text{ then }q_{1}(k_{1})=q_{2}(k_{2})\quad.
\]
This simplifies to $k_{1}(a)=k_{2}(f(a))$, or $k_{1}=f\bef k_{2}$.
So, we finally express $\left<f\right>^{\updownarrow Q}$ and $\left<f\right>^{\updownarrow P}$
as:
\begin{align*}
 & (q_{1}^{:Q^{A}},q_{2}^{:Q^{B}})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad(k\rightarrow f\bef k)\bef q_{1}=q_{2}\quad,\\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad a\rightarrow\big((k\rightarrow f\bef k)\bef p_{1}(a)\big)=f\bef p_{2}\quad.
\end{align*}

Defining $N^{X,Y}\triangleq X\rightarrow\left(Y\rightarrow R\right)\rightarrow R$,
we find that the last formula is equivalent to the $\left(N,f\right)$-wedge
relation for $p_{1}$ and $p_{2}$:
\[
p_{1}\triangleright f^{\uparrow N}=p_{1}\bef(q\rightarrow(k\rightarrow f\bef k)\bef q)\quad,\quad\quad p_{2}\triangleright f^{\downarrow N}=f\bef p_{2}\quad.
\]

\textbf{(e)} We may write $P^{A}=Q^{A}\rightarrow\text{Id}^{A}$ with
$Q^{A}\triangleq A\rightarrow A$ and use Definition~\ref{subsec:Definition-relational-lifting}(e):
\begin{align*}
 & r^{\updownarrow P}=r^{\updownarrow Q}\ogreaterthan r^{\updownarrow\text{Id}}=(r\ogreaterthan r)\ogreaterthan r\quad,\quad\quad\left<f\right>^{\updownarrow P}=(\left<f\right>\ogreaterthan\left<f\right>)\ogreaterthan\left<f\right>\quad,\\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in(\left<f\right>\ogreaterthan\left<f\right>)\ogreaterthan\left<f\right>\quad\text{means}\quad\text{if }(q_{1}^{:A\rightarrow A},q_{2}^{:B\rightarrow B})\in\left<f\right>\ogreaterthan\left<f\right>\text{ then }(p_{1}(q_{1}),p_{2}(q_{2}))\in\left<f\right>\quad.\\
 & (q_{1}^{:A\rightarrow A},q_{2}^{:B\rightarrow B})\in\left<f\right>\ogreaterthan\left<f\right>\quad\text{means}\quad\text{if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(q_{1}(a),q_{2}(b))\in\left<f\right>\quad.
\end{align*}
Simplifying these conditions, we get:
\begin{align}
 & (q_{1},q_{2})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad q_{1}\bef f=f\bef q_{2}\quad,\nonumber \\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad\text{if }q_{1}\bef f=f\bef q_{2}\text{ then }f(p_{1}(q_{1}))=p_{2}(q_{2})\quad.\label{eq:relational-lifting-example-e-derivation1}
\end{align}
The condition for $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$
\emph{cannot} be written as a single equation involving $p_{1}$ and
$p_{2}$ because we cannot express $q_{1}$ through $q_{2}$ or $q_{2}$
through $q_{1}$. The relation between $q_{1}$ and $q_{2}$ is many-to-many
and is not equivalent to a function graph.

Let us define $N^{X,Y}\triangleq\left(Y\rightarrow X\right)\rightarrow Y$
and write the $\left(N,f\right)$-wedge relation for $p_{1}^{:N^{A,A}}$
and $p_{2}^{:N^{B,B}}$:
\begin{equation}
k^{:B\rightarrow A}\triangleright(p_{1}\triangleright f^{\uparrow N})=k\triangleright(p_{2}\triangleright f^{\downarrow N})\quad\text{or equivalently}:\quad f(p_{1}(f\bef k))=p_{2}(k\bef f)\quad.\label{eq:N-f-wedge-relation-example-derivation1}
\end{equation}
We notice that if we set $q_{1}\triangleq f\bef k$ and $q_{2}\triangleq k\bef f$
then the precondition $q_{1}\bef f=f\bef q_{2}$ in Eq.~(\ref{eq:relational-lifting-example-e-derivation1})
will be satisfied, and it will follow that $f(p_{1}(q_{1}))=p_{2}(q_{2})$.
So, the $\left(N,f\right)$-wedge relation is a \emph{consequence}
of the relation $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$.
However, if we are given some functions $f$, $q_{1}$, and $q_{2}$
such that the precondition $q_{1}\bef f=f\bef q_{2}$ holds, it does
not follow that there exists a function $k$ such that $q_{1}=f\bef k$
and $q_{2}=k\bef f$. A simple counterexample is found when $f$ is
a \emph{constant} function (it ignores its argument and always returns
a fixed value):
\[
f^{:A\rightarrow B}\triangleq\_^{:A}\rightarrow b_{0}\quad,\quad\quad\text{where }b_{0}\text{ is a fixed value of type }B\quad.
\]
Then the precondition $q_{1}\bef f=f\bef q_{2}$ is reduced to the
condition $q_{2}(b_{0})=b_{0}$ with \emph{no} restrictions on $q_{1}$.
But if $q_{1}^{:A\rightarrow A}$ were expressed as $q_{1}=f\bef k$
with some $k^{:B\rightarrow A}$, we would have $q_{1}=\_\rightarrow k(b_{0})$.
So, any function $q_{1}$ expressed as $f\bef k$ must be a constant
function. This is a stronger restriction than $q_{1}\bef f=f\bef q_{2}$
because more pairs $\left(q_{1},q_{2}\right)$ satisfy $q_{1}\bef f=f\bef q_{2}$.
Accordingly, the $\left(N,f\right)$-wedge relation~(\ref{eq:N-f-wedge-relation-example-derivation1})
constrains the functions $\left(p_{1},p_{2}\right)$ weaker and is
satisfied by more pairs $\left(p_{1},p_{2}\right)$ than the relation
$\left<f\right>^{\updownarrow P}$. So, the $\left(N,f\right)$-wedge
relation is\emph{ weaker} than the relation $\left<f\right>^{\updownarrow P}$.
$\square$

Below we will prove (Statement~\ref{subsec:Statement-wedge-law-from-parametricity})
that the $\left(N,f\right)$-wedge relation is always a \emph{consequence}
of the corresponding lifted relation $\left<f\right>^{\updownarrow P}$.
Example~\ref{subsec:Example-relational-lifting} shows that the $\left(N,f\right)$-wedge
relation is \emph{equivalent} to $\left<f\right>^{\updownarrow P}$
only when the type structure of $P$ is sufficiently simple.

Definition~\ref{subsec:Definition-relational-lifting} was motivated
by the ordinary lifting of functions to functors or contrafunctors.
Indeed, as we will prove in Statement~\ref{subsec:Statement-lifting-function-relation-covariant-1}
below, the relational lifting $\langle f\rangle^{\updownarrow P}$
is consistent with the ordinary liftings when $P^{A}$ is a functor
or a contrafunctor. Namely, $\left<f\right>^{\updownarrow P}=\langle f^{\uparrow P}\rangle$
if $P$ is a functor and $\left<f\right>^{\updownarrow P}=\text{rev}\langle f^{\downarrow P}\rangle$
if $P$ is a contrafunctor. 

\subsection{Properties of relational lifting. Simultaneous lifting}

Definition~\ref{subsec:Definition-relational-lifting} requires some
additional work to be fully usable. This section proves the properties
of relational lifting that will be needed later in this Appendix.

We begin by pointing out an ambiguity in applying Definition~\ref{subsec:Definition-relational-lifting}(g)
to $G^{A}\triangleq\forall X.\,H^{X,A}$ when $H^{X,A}$ does \emph{not}
depend on the type parameter $A$; that is, when $H^{X,A}=K^{X}$
with some $K$. In that case, the type constructor $G$ is a constant
functor: $G^{A}=Z\triangleq\forall X.\,K^{X}$. We may lift a relation
$r^{:A\leftrightarrow B}$ to $G^{A}\triangleq Z$ using Definition~\ref{subsec:Definition-relational-lifting}(a)
and obtain $r^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}$.
To show that Definition~\ref{subsec:Definition-relational-lifting}
is consistent, we need to prove that Definitions~\ref{subsec:Definition-relational-lifting}(a)
and~(g) define the same lifted relation $r^{\updownarrow G}$. We
will show this is the next statement by using the relational naturality
law~(\ref{eq:relational-naturality-law-simplified}). That law is
the result of the relational parametricity theorem (Section~\ref{subsec:Relational-parametricity-theorem}),
which we will prove without using the next statement. In this way,
the relational parametricity theorem turns out to be a necessary requirement
for the consistency of Definition~\ref{subsec:Definition-relational-lifting}.

\subsubsection{Statement \label{subsec:Statement-parametricity-gives-identity-relation}\ref{subsec:Statement-parametricity-gives-identity-relation}}

For a quantified type $Z\triangleq\forall X.\ H^{X}$, the relation
$\text{id}^{:Z\leftrightarrow Z}$ has an equivalent form:
\[
(p^{:\forall X.\,H^{X}},q^{:\forall Y.\,H^{Y}})\in\text{id}\quad\text{ is equivalent to}:\quad\forall(X,Y).\,\forall s^{:X\leftrightarrow Y}.\,(p^{X},q^{Y})\in s^{\updownarrow H}\quad,
\]
or: $\forall s^{:X\leftrightarrow Y}.\,s^{\updownarrow H}=\text{id}$,
as long as $p$ and $q$ are implemented via fully parametric code.

\subparagraph{Proof}

We need to prove the equivalence in both directions.

If some $p$ and $q$ satisfy $(p^{X},q^{Y})\in s^{\updownarrow H}$
where we may choose $s$ arbitrarily, let us choose $s$ to be the
identity relation and force $X$ and $Y$ to be the same type:
\[
(x^{:X},y^{:Y})\in s\text{ only when }X=Y\text{ and }x=y\quad.
\]
Lifting an identity relation will produce an identity relation (Statement~\ref{subsec:Statement-relational-lifting-identity-law}),
so:
\[
\forall(X,Y).\,(p^{X},q^{Y})\in s^{\updownarrow H}\text{ with }s^{\updownarrow H}=\text{id}\quad\text{ means }\quad X=Y\text{ and }p^{X}=q^{X}\quad.
\]
This is the same as the identity relation between $p$ and $q$.

It remains to show that $(p^{X},q^{Y})\in s^{\updownarrow H}$ when
$p=q$. In other words, $(p^{X},p^{Y})\in s^{\updownarrow H}$ for
any $s^{:X\leftrightarrow Y}$. Since $p$ is fully parametric, it
obeys the naturality law~(\ref{eq:relational-naturality-law-simplified}),
which we will prove below without using this statement. We set $Q^{X}\triangleq H^{X}$,
$r\triangleq s$, and $t\triangleq p$ in the naturality law~(\ref{eq:relational-naturality-law-simplified}):
\[
\forall(X,Y).\,\forall s^{:X\leftrightarrow Y}.\,(p^{X},p^{Y})\in s^{\updownarrow H}\quad.
\]
$\square$

Another important construction required for Definition~\ref{subsec:Definition-relational-lifting}
is the simultaneous lifting of two relations (say, $r^{:A\leftrightarrow B}$
and $s^{:X\leftrightarrow Y}$) to a type constructor with two type
parameters (say, $G^{A,X}$ ). The result should be a new relation
of type $G^{A,X}\leftrightarrow G^{B,Y}$. It turns out that the simultaneous
lifting \emph{cannot} be expressed via the liftings $r^{\updownarrow G^{\bullet,X}}$
and $s^{\updownarrow G^{A,\bullet}}$ performed with respect to each
type parameter separately. Instead, we need to define the simultaneous
relational lifting as a special new operation. 

\subsubsection{Definition \label{subsec:Definition-simultaneous-relational-lifting}\ref{subsec:Definition-simultaneous-relational-lifting}
(simultaneous relational lifting)}

For any fully parametric type constructor $G$ with two type parameters,
we define the simultaneous lifting of two relations $r^{:A\leftrightarrow B}$
and $s^{:X\leftrightarrow Y}$ to $G$ as a new relation denoted by
$(r,s)^{\updownarrow G}$ of type $G^{A,X}\leftrightarrow G^{B,Y}$.
We use induction on the structure of $G$:

\textbf{(a)} If $G^{A,X}\triangleq Z$ with a fixed type $Z$, we
define $(r,s)^{\updownarrow G}\triangleq\text{id}^{:Z\leftrightarrow Z}$.

\textbf{(b)} If $G^{A,X}\triangleq A$, we define $(r,s)^{\updownarrow G}\triangleq r$.
If $G^{A,X}\triangleq X$, we define $(r,s)^{\updownarrow G}\triangleq s$.

\textbf{(c)} If $K$ and $L$ are any fully parametric type constructors,
we define: 
\begin{align*}
{\color{greenunder}\text{for}\quad G^{A,X}\triangleq K^{A,X}\times L^{A,X}\quad:}\quad & (r,s)^{\updownarrow G}\triangleq(r,s)^{\updownarrow K}\boxtimes(r,s)^{\updownarrow L}\quad;\\
{\color{greenunder}\text{for}\quad G^{A,X}\triangleq K^{A,X}+L^{A,X}\quad:}\quad & (r,s)^{\updownarrow G}\triangleq(r,s)^{\updownarrow K}\boxplus(r,s)^{\updownarrow L}\quad;\\
{\color{greenunder}\text{for}\quad G^{A,X}\triangleq K^{A,X}\rightarrow L^{A,X}\quad:}\quad & (r,s)^{\updownarrow G}\triangleq(r,s)^{\updownarrow K}\ogreaterthan(r,s)^{\updownarrow L}\quad.
\end{align*}
The last relation is between functions of types $K^{A,X}\rightarrow L^{A,X}$
and $K^{B,Y}\rightarrow L^{B,Y}$. 

The inductive assumption is that simultaneous liftings to $K$ and
$L$ are already defined.

\textbf{(d)} If $G^{A,X}\triangleq S^{A,X,G^{A,X}}$ is defined recursively
via a pattern functor $S$, we define:
\[
(r,s)^{\updownarrow G}\triangleq\big(r,s,\overline{(r,s)^{\updownarrow G}}\big)^{\updownarrow S}\quad.
\]
Here we use $\overline{(r,s)^{\updownarrow G}}$ recursively within
the definition of $(r,s)^{\updownarrow G}$. This is allowed since
we understand $(r,s)^{\updownarrow G}$ to be a function, and it is
permitted to define functions recursively. The inductive assumption
is that simultaneous liftings of any \emph{three} relations to $S$
are already defined. 

\textbf{(e)} If $G^{A,X}\triangleq\forall Z.\,H^{Z,A,X}$, we define
$(r,s)^{\updownarrow G}$ of type $(\forall U.\,H^{U,A,X})\leftrightarrow(\forall V.\,H^{V,B,Y})$
by:
\[
(p^{:\forall U.\,H^{U,A,X}},q^{:\forall V.\,H^{V,B,Y}})\in(r,s)^{\updownarrow\forall Z.\,H^{Z,\bullet,\bullet}}\quad\text{means}\quad\forall(U,V).\,\forall w^{U\leftrightarrow V}.\,(p^{U},q^{V})\in(w,r,s)^{\updownarrow H^{\bullet,\bullet,\bullet}}\quad.
\]
A shorter way of writing this definition is by formulating a relation
between $p^{U}$ and $q^{V}$ directly:
\begin{equation}
\forall(U,V):\quad\big((r,s)^{\updownarrow\forall Z.\,H^{Z,\bullet,\bullet}}\big)^{U,V}\triangleq\forall w^{:U\leftrightarrow V}.\,(w,r,s)^{\updownarrow H^{\bullet,\bullet,\bullet}}\quad.\label{eq:relational-lifting-quantified-types-short-1}
\end{equation}
The inductive assumption is that simultaneous liftings to $H$ are
already defined. $\square$

Parts (d) and (e) of Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
use a simultaneous lifting of \emph{three} relations. Comparing Definitions~\ref{subsec:Definition-relational-lifting}
and~\ref{subsec:Definition-simultaneous-relational-lifting}, we
see that a similar inductive definition can be given for simultaneous
liftings of $n$ relations (with $n=1,2,...$) to a type constructor
with $n$ type parameters. We omit the details. This book will only
need simultaneous liftings of two relations.

When working with dinaturality laws (Section~\ref{sec:Naturality-laws-for-fully-parametric-functions}),
we used profunctors $P^{X,Y}$ whose type parameters are set to the
same type (e.g., $G^{A}\triangleq P^{A,A}$). In that case, there
is an ambiguity in lifting a relation $r^{:A\leftrightarrow B}$ to
$G$: First, Definition~\ref{subsec:Definition-relational-lifting}
defines $r^{\updownarrow G}$ as a relation of type $G^{A}\leftrightarrow G^{B}$,
which is the same type as $P^{A,A}\leftrightarrow P^{B,B}$. Second,
we may lift the pair of two relations $\left(r,r\right)$ simultaneously
to $P$ according to Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
and obtain another relation $\left(r,r\right)^{\updownarrow P}$ of
the same type $P^{A,A}\leftrightarrow P^{B,B}$. The next statement
shows that $(r,r)^{\updownarrow P}=r^{\updownarrow G}$.

\subsubsection{Statement \label{subsec:Statement-relational-lifting-consistency-PAA}\ref{subsec:Statement-relational-lifting-consistency-PAA}}

Given any fully parametric type constructor $P^{X,Y}$, define $G^{A}\triangleq P^{A,A}$.
For any relation $r^{:A\leftrightarrow B}$, the liftings $r^{\updownarrow G}$
and $\left(r,r\right)^{\updownarrow P}$ will produce the same relation
of type $P^{A,A}\leftrightarrow P^{B,B}$.

\subparagraph{Proof}

We enumerate all cases of Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
for the type constructor $P$ and the corresponding cases of Definition~\ref{subsec:Definition-relational-lifting}
for $G$. In each case, we will show that $(r,r)^{\updownarrow P}=r^{\updownarrow G}$.

If $P^{A,X}\triangleq Z$ with a fixed type $Z$, we have also $G^{A}=Z$.
Then $(r,r)^{\updownarrow P}=\text{id}^{:Z\leftrightarrow Z}$ and
$r^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}$.

If $P^{A,X}\triangleq A$ or $P^{A,X}=X$, we have $G^{A}=A$. In
both cases $(r,r)^{\updownarrow P}\triangleq r$ and $r^{\updownarrow G}=r$.

If $P\triangleq K\times L$ then we have $G^{A}=K^{A,A}\times L^{A,A}$.
Denote $M^{A}\triangleq K^{A,A}$ and $N^{A}\triangleq L^{A,A}$,
so that $G^{A}=M^{A}\times N^{A}$. The inductive assumptions are
$(r,r)^{\updownarrow K}=r^{\updownarrow M}$ and $(r,r)^{\updownarrow L}=r^{\updownarrow N}$.
We find:
\[
(r,r)^{\updownarrow P}=(r,r)^{\updownarrow K}\boxtimes(r,r)^{\updownarrow L}=r^{\updownarrow M}\boxtimes r^{\updownarrow N}=r^{\updownarrow(M\times N)}=r^{\updownarrow G}\quad.
\]

If $P\triangleq K+L$ with $G^{A}=M^{A}+N^{A}$ and the same inductive
assumptions, we get: 
\[
(r,r)^{\updownarrow P}=(r,r)^{\updownarrow K}\boxplus(r,r)^{\updownarrow L}=r^{\updownarrow M}\boxplus r^{\updownarrow N}=r^{\updownarrow(M+N)}=r^{\updownarrow G}\quad.
\]

If $P\triangleq K\rightarrow L$ with $G^{A}=M^{A}\rightarrow N^{A}$
and the same inductive assumptions, we find: 
\[
(r,r)^{\updownarrow P}=(r,r)^{\updownarrow K}\ogreaterthan(r,r)^{\updownarrow L}=r^{\updownarrow M}\ogreaterthan r^{\updownarrow N}=r^{\updownarrow(M^{\bullet}\rightarrow N^{\bullet})}=r^{\updownarrow G}\quad.
\]

If $P^{A,X}\triangleq S^{A,X,P^{A,X}}$ with a pattern functor $S$,
the type constructor $G$ is defined by: 
\[
G^{A}\triangleq P^{A,A}=S^{A,A,P^{A,A}}=S^{A,A,G^{A}}\quad.
\]
Denote $Q^{A,X}\triangleq S^{A,A,X}$ and obtain $G^{A}=Q^{A,G^{A}}$.
So, the lifting to $G$ is given by $r^{\updownarrow G}=\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow Q}$.
Now write the definition of lifting to $P$ and simplify:
\begin{align*}
 & (r,r)^{\updownarrow P}=\big(r,r,\overline{(r,r)^{\updownarrow P}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\overline{(r,r)^{\updownarrow P}}=\overline{r^{\updownarrow G}}:}\quad & =\big(r,r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow Q}=\big(r,r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S}:}\quad & =\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow Q}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =r^{\updownarrow G}\quad.
\end{align*}

If $P^{A,X}\triangleq\forall Z.\,S^{Z,A,X}$, the type constructor
$G$ is $G^{A}=\forall Z.\,S^{Z,A,A}$. Denote $Q^{Z,A}\triangleq S^{Z,A,A}$
and obtain $G^{A}=\forall Z.\,Q^{Z,A}$. The lifting $(r,r)^{\updownarrow P}$
is a relation of type $\forall U.\,S^{U,A,A}\leftrightarrow\forall V.\,S^{V,A,A}$
written as:
\begin{align*}
 & \forall(U,V):\quad\big((r,r)^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}\big)^{U,V}=\forall w^{:U\leftrightarrow V}.\,(w,r,r)^{\updownarrow S^{\bullet,\bullet,\bullet}}\\
{\color{greenunder}\text{inductive assumption }(w,r,r)^{\updownarrow S}=(w,r)^{\updownarrow Q}:}\quad & =\forall w^{:U\leftrightarrow V}.\,(w,r)^{\updownarrow Q}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =\big(r^{\updownarrow G}\big)^{U,V}\quad.
\end{align*}


\subsection{Proof of the relational parametricity theorem\label{subsec:Relational-parametricity-theorem}}

Our goal is to prove that any fully parametric function $t:\forall A.\,P^{A}\rightarrow Q^{A}$
obeys the law~(\ref{eq:naturality-law-of-t-derivation2}):
\[
\forall A,B.\,\forall r^{:A\leftrightarrow B}.\,(t^{A},t^{B})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}\quad.
\]
The proof will need to go by induction on the structure of the code
of the function $t$, which is built from smaller sub-expressions
using the nine code constructions of Table~\ref{tab:nine-pure-code-constructions}.
The inductive assumption is that all sub-expressions already satisfy
the relational naturality law. A problem with this approach is that
some sub-expressions of $t$ may contain free variables or may not
have the type signature of a function. To illustrate this, write the
code of $t$ as $t=z^{:P^{A}}\rightarrow\text{expr}(z)$, or in Scala:
\begin{lstlisting}
def t[A] = { z: P[A] => expr(z) }
\end{lstlisting}
where \textsf{``}\lstinline!expr(z)!\textsf{''} is the function\textsf{'}s body. That function
body \emph{itself} does not necessarily have a type signature of the
form $K^{A}\rightarrow L^{A}$. Also, \textsf{``}\lstinline!expr(z)!\textsf{''} may
contain $z$ as a free variable defined outside the scope of \textsf{``}\lstinline!expr(z)!\textsf{''},
and the type of $z$ may depend on the type parameter $A$. So, we
cannot directly apply the relational naturality law~(\ref{eq:naturality-law-of-t-derivation2})
to the subexpressions, which prevents us from using induction. The
relational naturality law needs to be reformulated to describe function
\emph{bodies}, i.e., arbitrary expressions that may contain externally
defined variables. A suitable formulation of the relational naturality
law is given in the next definition and will be the goal of Statement~\ref{subsec:Statement-main-relational-parametricity-1}.

\subsubsection{Definition \label{subsec:Definition-relational-naturality-law}\ref{subsec:Definition-relational-naturality-law}
(relational naturality law)}

Consider any expression $t:\forall A.\,Q^{A}$ containing a single
free variable\index{free variable} $x^{:P^{A}}$, where $P$ and
$Q$ are any type constructors. Define the \textbf{binding function}
$t^{\prime}:\forall A.\,P^{A}\rightarrow Q^{A}$ such that $t=\tilde{t}(x)$
and $\tilde{t}$ has no free variables. (The binding function describes
how the expression $t$ depends on its free variable $x$.) Then the
\textbf{relational naturality law}\index{naturality law!in terms of relations}
of $t$ is written as:
\begin{equation}
\forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}\quad.\label{eq:relational-naturality-law-1}
\end{equation}
If $t$ contains several free variables ($x_{1}^{:P_{1}^{A}}$, $x_{2}^{:P_{2}^{A}}$,
etc.), we define the binding function $\tilde{t}$ as a curried function
of all the free variables. For example, with \emph{two} free variables
we will have $t=\tilde{t}(x_{1})(x_{2})$, so that $\tilde{t}^{A}$
will have type $P_{1}^{A}\rightarrow P_{2}^{A}\rightarrow Q^{A}$.
Then the relational naturality law is written as:
\begin{equation}
\forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow P_{1}}\ogreaterthan r^{\updownarrow P_{2}}\ogreaterthan r^{\updownarrow Q}\quad.\label{eq:relational-naturality-law-two-free-vars}
\end{equation}
The generalization to any number of free variables is straightforward.
$\square$

If $t$ contains no free variables, we may still write $t$ as $\tilde{t}(x)$
where $\tilde{t}$ does not depend on $x$, setting $P^{A}\triangleq\bbnum 1$
for simplicity. In that case, Eq.~(\ref{eq:relational-naturality-law-1})
is simplified to:
\begin{align}
 & \forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,\forall x_{1}^{:\bbnum 1},x_{2}^{:\bbnum 1}.\,\quad\text{if }x_{1}=x_{2}\text{ then }(\tilde{t}^{A}(x_{1}),\tilde{t}^{B}(x_{2}))\in r^{\updownarrow Q}\quad,\nonumber \\
{\color{greenunder}\text{or equivalently}:}\quad & \forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,(t^{A},t^{B})\in r^{\updownarrow Q}\quad.\label{eq:relational-naturality-law-simplified}
\end{align}
Even in that case, to save time, we will keep using Eq.~(\ref{eq:relational-naturality-law-1})
and writing $t=\tilde{t}(x)$.

When an expression contains more than one free variable, we can also
gather all the free variables into a tuple. This creates an equivalent
expression with just one free variable:

\subsubsection{Statement \label{subsec:Statement--relational-naturality-tuple-1}\ref{subsec:Statement--relational-naturality-tuple-1} }

The relational naturality law for an expression $t:\forall A.\,Q^{A}$
containing two free variables $z_{1}^{:K^{A}}$ and $z_{2}^{:L^{A}}$
and the binding function $\tilde{t}(z_{1})(z_{2})=t$ is equivalent
to the relational naturality law for the expression $u$ with \emph{one}
free variable $h$ defined as:
\[
h^{:K^{A}\times L^{A}}\triangleq z_{1}\times z_{2}\quad,\quad\quad u\triangleq\tilde{u}(h)\triangleq\tilde{t}(h\triangleright\pi_{1})(h\triangleright\pi_{2})\quad.
\]


\subparagraph{Proof}

The relational naturality laws for $t$ and $u$ say that, for all
types $A$, $B$, and relations $r^{:A\leftrightarrow B}$:
\[
(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}\ogreaterthan r^{\updownarrow Q}\quad,\quad\quad(\tilde{u}^{A},\tilde{u}^{B})\in r^{\updownarrow(K\times L)}\ogreaterthan r^{\updownarrow Q}\quad.
\]
We need to show that these two relations are equivalent given the
definition of $\tilde{u}$ via $\tilde{t}$. This is similar to the
equivalence of curried and uncurried function types: $A\rightarrow(B\rightarrow C)\cong A\times B\rightarrow C$.
We write out the definition of the pair mapper operation ($\ogreaterthan$)
and obtain: 
\begin{align*}
(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}\ogreaterthan r^{\updownarrow Q}\quad\text{means}\quad: & \quad\forall x_{1}^{:K^{A}},x_{2}^{:L^{A}},y_{1}^{:K^{B}},y_{2}^{:L^{B}}:\,\text{ if }(x_{1},y_{1})\in r^{\updownarrow K}\text{ and }(x_{2},y_{2})\in r^{\updownarrow L}\\
 & \quad\quad\text{ then }(\tilde{t}(x_{1})(x_{2}),\tilde{t}(y_{1})(y_{2}))\in r^{\updownarrow Q}\quad;\\
(\tilde{u}^{A},\tilde{u}^{B})\in r^{\updownarrow(K\times L)}\ogreaterthan r^{\updownarrow Q}\quad\text{means}\quad: & \quad\forall h^{:K^{A}\times L^{A}},w^{:K^{B}\times L^{B}}:\,\text{ if }(h,w)\in r^{\updownarrow(K\times L)}\\
 & \quad\quad\text{ then }(\tilde{u}(h),\tilde{u}(w))\in r^{\updownarrow Q}\quad.
\end{align*}
By Definition~\ref{subsec:Definition-relational-lifting}(c) we have
$r^{\updownarrow(K\times L)}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}$,
and so we may write: 
\[
(h,w)\in r^{\updownarrow(K\times L)}\quad\text{ if }\quad h=x_{1}\times x_{2}\quad,\quad w=y_{1}\times y_{2}\quad,\quad(x_{1},x_{2})\in r^{\updownarrow K}\quad,\quad\text{ and }\quad(y_{1},y_{2})\in r^{\updownarrow L}\quad.
\]
When $h=x_{1}\times x_{2}$ and $w=y_{1}\times y_{2}$, we will have
$\tilde{u}(h)=\tilde{t}(x_{1},x_{2})$ and $\tilde{u}(w)=\tilde{t}(y_{1},y_{2})$.
It follows that the relational naturality laws for $t$ and $u$ are
equivalent. $\square$

Due to Statement~\ref{subsec:Statement--relational-naturality-tuple-1},
we are allowed to assume that the expression $t$ always has a \emph{single}
free variable. This simplifies the formulation of the main theorem:

\subsubsection{Statement \label{subsec:Statement-main-relational-parametricity-1}\ref{subsec:Statement-main-relational-parametricity-1}
(relational parametricity theorem)}

Let $H$ and $Q$ be any fully parametric type constructors. Any fully
parametric expression $t:\forall A.\,Q^{A}$ of the form $t=\forall A.\,\tilde{t}^{A}(h)$
containing a single free variable $h^{:H^{A}}$ satisfies the relational
naturality law~(\ref{eq:relational-naturality-law-1}).

\subparagraph{Proof }

By assumption, $t$ is built up from the nine constructions of Table~\ref{tab:nine-pure-code-constructions}.
So, one of these nine constructions is at the top level in the syntax
tree of $t$. For each of those constructions, we will prove that
$t$ satisfies Eq.~(\ref{eq:relational-naturality-law-1}) as long
as all its sub-expressions do. Throughout the proof, all relational
naturality laws will involve an arbitrary relation $r^{:A\leftrightarrow B}$
between arbitrary types $A$, $B$. For brevity, we will not write
the quantifiers $\forall A,B,r^{:A\leftrightarrow B}$ in front of
all formulas.

To shorten the proof further, we note that in every inductive case
the expression $t$ and all its sub-expressions will contain the same
free variable $h$. So, all relational naturality laws will follow
the pattern \textsf{``}for all $h_{1}^{:H^{A}}$ and $h_{2}^{:H^{B}}$ satisfying
the relation $(h_{1},h_{2})\in r^{\updownarrow H}$, some other values
are in some other relation\textsf{''}. Let us choose arbitrary but fixed values
$h_{1}^{:H^{A}}$ and $h_{2}^{:H^{B}}$ satisfying $(h_{1},h_{2})\in r^{\updownarrow H}$,
denote $t_{1}\triangleq\tilde{t}^{A}(h_{1})$ and $t_{2}\triangleq\tilde{t}^{B}(h_{2})$,
and simplify the law~(\ref{eq:relational-naturality-law-1}) to:
\begin{equation}
(t_{1},t_{2})\in r^{\updownarrow Q}\quad\text{where}\quad t_{1}\triangleq\tilde{t}^{A}(h_{1})\text{ and }t_{2}\triangleq\tilde{t}^{B}(h_{2})\quad.\label{eq:relational-naturality-law-with-fixed-h}
\end{equation}
We will now prove this form of the law. Inductive assumptions will
always begin with \textsf{``}for all $h_{1}$ and $h_{2}$ ...\textsf{''}, so we are
allowed to substitute the fixed values $h_{1}$, $h_{2}$ into each
of the inductive assumptions and write those assumptions also in the
form of Eq.~(\ref{eq:relational-naturality-law-with-fixed-h}).

\paragraph{Use unit value}

In this case, $t\triangleq1$ and has the unit type ($Q^{A}\triangleq\bbnum 1$).
Since $t$ contains no free variables, the law~(\ref{eq:relational-naturality-law-with-fixed-h})
becomes:
\[
(1,1)\in r^{\updownarrow Q}\quad.
\]
This holds because by Definition~\ref{subsec:Definition-relational-lifting}(a)
we have $r^{\updownarrow Q}=\text{id}$ regardless of $r$.

The same proof applies for $t\triangleq c$ where $c$ is a value
of a fixed type $C$ (not built from $A$ or $B$).

\paragraph{Use argument}

In this case, $t\triangleq h$ where $h^{:H^{A}}$ is the free variable
(say, the argument of the function whose body is $t$). So, we must
have $Q=H$ and $\tilde{t}=\forall A.\,\text{id}^{:H^{A}\rightarrow H^{A}}$.
Then the law~(\ref{eq:relational-naturality-law-with-fixed-h}) becomes:
\begin{align*}
 & (t_{1},t_{2})\in r^{\updownarrow H}\quad\text{where}\quad t_{1}\triangleq h_{1}\text{ and }t_{2}\triangleq h_{2}\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & (h_{1},h_{2})\in r^{\updownarrow H}\quad.
\end{align*}
The last condition holds trivially, since $(h_{1},h_{2})\in r^{\updownarrow H}$
is already assumed.

\paragraph{Create function}

In this case, $t\triangleq\forall A.\,p^{:P^{A}}\rightarrow\tilde{g}^{A}(h)(p)$
where the sub-expression $\tilde{g}^{A}(h)(p):G^{A}$ contains two
free variables ($h^{:H^{A}}$ and $p^{:P^{A}}$). Because $\tilde{g}(h)(p)$
is defined with curried arguments, the binding function $\tilde{t}$
satisfies:
\[
\tilde{t}(h)=t=p\rightarrow\tilde{g}(h)(p)=\tilde{g}(h)\quad,\quad\quad\text{or equivalently}:\quad\tilde{t}=\tilde{g}.
\]
The type of $\tilde{g}$ is $H^{A}\rightarrow Q^{A}$, where we set
$Q^{A}\triangleq P^{A}\rightarrow G^{A}$. Definition~\ref{subsec:Definition-relational-lifting}(e)
gives $r^{\updownarrow Q}=r^{\updownarrow P}\ogreaterthan r^{\updownarrow G}$.
So, the inductive assumption for $g$ may be written as:
\[
(g_{1},g_{2})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow G}\quad\text{where}\quad g_{1}\triangleq\tilde{g}^{A}(h_{1})=t_{1}\text{ and }g_{2}\triangleq\tilde{g}^{B}(h_{2})=t_{2}\quad.
\]
This is equivalent to:
\[
(t_{1},t_{2})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow G}=r^{\updownarrow Q}\quad,
\]
which is the law~(\ref{eq:relational-naturality-law-with-fixed-h})
we needed to prove.

\paragraph{Use function}

In this case, $t=\tilde{t}(h)\triangleq k(p)$ where $k^{:\forall A.\,P^{A}\rightarrow Q^{A}}$
and $p^{:\forall A.\,P^{A}}$ are some sub-expressions. Both $k$
and $p$ may contain $h^{:H^{A}}$ as a free variable: $k\triangleq\tilde{k}(h)$
and $p\triangleq\tilde{p}(h)$. Denote for brevity $K^{A}\triangleq P^{A}\rightarrow Q^{A}$.
The inductive assumptions say that the laws~(\ref{eq:relational-naturality-law-with-fixed-h})
already hold for both $k$ and $p$:
\begin{align*}
{\color{greenunder}\text{for }k:}\quad & (k_{1},k_{2})\in r^{\updownarrow K}=r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}\quad\quad\text{where}\quad k_{1}\triangleq\tilde{k}^{A}(h_{1})\text{ and }k_{2}\triangleq\tilde{k}^{B}(h_{2})\quad,\\
{\color{greenunder}\text{for }p:}\quad & (p_{1},p_{2})\in r^{\updownarrow P}\quad\quad\text{where}\quad p_{1}\triangleq\tilde{p}^{A}(h_{1})\text{ and }p_{2}\triangleq\tilde{p}^{B}(h_{2})\quad.
\end{align*}
We need to show that:
\[
(t_{1},t_{2})\in r^{\updownarrow Q}\quad\quad\text{where}\quad t_{1}\triangleq\tilde{t}^{A}(h_{1})=k_{1}(p_{1})\text{ and }t_{2}\triangleq\tilde{t}^{B}(h_{2})=k_{2}(p_{2})\quad.
\]
By definition of $\ogreaterthan$, the inductive assumption $(k_{1},k_{2})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}$
means:
\[
(k_{1}(p_{1}),k_{2}(p_{2}))\in r^{\updownarrow Q}\quad\text{whenever}\quad(p_{1},p_{2})\in r^{\updownarrow P}\quad.
\]
Since $(p_{1},p_{2})\in r^{\updownarrow P}$ already holds by the
other inductive assumption, we obtain $(t_{1},t_{2})\in r^{\updownarrow Q}$.

\paragraph{Create tuple}

In this case, $t=\tilde{t}(h)\triangleq k^{:K^{A}}\times l^{:L^{A}}$,
where the sub-expressions $k$ and $l$ contain the free variable
$h^{:H^{A}}$ via $k\triangleq\tilde{k}(h)$ and $l\triangleq\tilde{l}(h)$.
We have $Q^{A}\triangleq K^{A}\times L^{A}$, so we use Definition~\ref{subsec:Definition-relational-lifting}(c)
for the lifting $r^{\updownarrow Q}$ to get $r^{\updownarrow Q}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}$.
We need to prove that:
\begin{align*}
 & (t_{1},t_{2})\in r^{\updownarrow Q}\quad\text{or equivalently}:\quad(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow K}\boxtimes r^{\updownarrow L}\quad,\\
 & \quad\text{where}\quad t_{1}\triangleq k_{1}\times l_{1}\triangleq\tilde{k}^{A}(h_{1})\times\tilde{l}^{A}(h_{1})\quad,\quad\quad t_{2}\triangleq k_{2}\times l_{2}\triangleq\tilde{k}^{A}(h_{2})\times\tilde{l}^{A}(h_{2})\quad.
\end{align*}
The inductive assumptions are that the relational naturality law~(\ref{eq:relational-naturality-law-with-fixed-h})
holds for $k$ and $l$:
\[
(k_{1},k_{2})\in r^{\updownarrow K}\quad,\quad\quad(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\]
By definition of $\boxtimes$ for relations, we obtain the required
property: $(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow K}\boxtimes r^{\updownarrow L}$.

\paragraph{Use tuple}

It is sufficient to consider the case $t\triangleq\pi_{1}(g)$ where
$g^{:\forall A.\,Q^{A}\times L^{A}}$ is a sub-expression that contains
the free variable $h^{:H^{A}}$. The proof for $t=\pi_{2}(g)$ is
analogous. 

We need to prove that $t$ satisfies the relational naturality law
if $g$ does. Define $g=\tilde{g}(h)$ and:
\[
g_{1}\triangleq\tilde{g}^{A}(h_{1})\quad,\quad\quad g_{2}\triangleq\tilde{g}^{B}(h_{2})\quad,\quad\quad t_{1}\triangleq\pi_{1}(g_{1})\quad,\quad\quad t_{2}\triangleq\pi_{1}(g_{2})\quad.
\]

The relational naturality law of $g$, which holds by the inductive
assumption, is:
\[
(g_{1},g_{2})\in r^{\updownarrow(Q\times L)}\quad.
\]
By Definition~\ref{subsec:Definition-relational-lifting}(c) for
the lifting $r^{\updownarrow(Q\times L)}$, we have:
\[
(g_{1},g_{2})\in r^{\updownarrow(Q\times L)}\quad\text{ means }\quad(\pi_{1}(g_{1}),\pi_{1}(g_{2}))\in r^{\updownarrow Q}\text{ and }(\pi_{2}(g_{1}),\pi_{2}(g_{2}))\in r^{\updownarrow L}\quad.
\]
The condition $(\pi_{1}(g_{1}),\pi_{1}(g_{2}))\in r^{\updownarrow Q}$
is the same as the relational naturality law of $t$.

\paragraph{Create disjunction}

We consider the case $t\triangleq g+\bbnum 0$ where $Q^{A}\triangleq K^{A}+L^{A}$
and $g^{:\forall A.\,K^{A}}$ is a sub-expression that may contain
the free variable $h^{:H^{A}}$ as $g\triangleq\tilde{g}(h)$. Define
for convenience: 
\[
g_{1}\triangleq\tilde{g}^{A}(h_{1})\quad,\quad\quad g_{2}\triangleq\tilde{g}^{B}(h_{2})\quad,\quad\quad t_{1}=g_{1}+\bbnum 0\quad,\quad\quad t_{2}=g_{2}+\bbnum 0\quad.
\]
The inductive assumption is that $g(h)$ satisfies its relational
naturality law, which is $(g_{1},g_{2})\in r^{\updownarrow K}$. By
Definition~\ref{subsec:Definition-relational-lifting}(d) for the
lifting $r^{\updownarrow(K+L)}$, we have:
\[
(t_{1},t_{2})=(g_{1}+\bbnum 0,g_{2}+\bbnum 0)\in r^{\updownarrow(K+L)}=r^{\updownarrow K}\boxplus r^{\updownarrow L}\text{ when }(g_{1},g_{2})\in r^{\updownarrow K}\quad.
\]
So, the relational naturality law of $t$ holds. The proof for $t\triangleq\bbnum 0+g$
is analogous.

\paragraph{Use disjunctive type}

In this case, $t\triangleq\forall A.\,\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p\\
L^{A} & q
\end{array}\,\,$ is a pattern-matching function of type $\forall A.\,Q^{A}$ with
$Q^{A}\triangleq K^{A}+L^{A}\rightarrow G^{A}$. The sub-expressions
$p^{:\forall A.\,K^{A}\rightarrow G^{A}}$ and $q^{:\forall A.\,L^{A}\rightarrow G^{A}}$
may contain the free variable $h^{:H^{A}}$. We define:
\[
p\triangleq\tilde{p}(h)\quad,\quad p_{1}\triangleq\tilde{p}^{A}(h_{1})\quad,\quad p_{2}\triangleq\tilde{p}^{B}(h_{2})\quad,\quad\quad q\triangleq\tilde{q}(h)\quad,\quad q_{1}\triangleq\tilde{q}^{A}(h_{1})\quad,\quad q_{2}\triangleq\tilde{q}^{B}(h_{2})\quad.
\]
Then we have:
\[
t_{1}=\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p_{1}\\
L^{A} & q_{1}
\end{array}\quad,\quad\quad t_{2}=\,\begin{array}{|c||c|}
 & G^{B}\\
\hline K^{B} & p_{2}\\
L^{B} & q_{2}
\end{array}\quad.
\]
By the inductive assumption, the relational naturality law already
holds for $p$ and $q$:
\begin{align*}
 & \text{if }(k_{1}^{:K^{A}},k_{2}^{:K^{B}})\in r^{\updownarrow K}\text{ then }\big(p_{1}(k_{1}),p_{2}(k_{2})\big)\in r^{\updownarrow G}\quad,\\
 & \text{if }(l_{1}^{:L^{A}},l_{2}^{:L^{B}})\in r^{\updownarrow L}\text{ then }\big(q_{1}(l_{1}),q_{2}(l_{2})\big)\in r^{\updownarrow G}\quad.
\end{align*}
To derive the specific form of the law for $t$, we use Definition~\ref{subsec:Definition-relational-lifting}(e)
for the lifting $r^{\updownarrow Q}$:
\[
\text{if }(x_{1}^{:K^{A}+L^{A}},x_{2}^{:K^{B}+L^{B}})\in r^{\updownarrow(K+L)}\text{ then }\big(t_{1}(x_{1}),t_{2}(x_{2})\big)\in r^{\updownarrow G}\quad.
\]
By Definition~\ref{subsec:Definition-relational-lifting}(d), the
values $x_{1}$ and $x_{2}$ are in relation $r^{\updownarrow(K+L)}$
only if both $x_{1}$ and $x_{2}$ are in the same part of the disjunction
($K^{\bullet}+L^{\bullet}$). We consider separately the case when
they are in the left part or in the right part.

If both $x_{1}$ and $x_{2}$ in the left part, we can write $x_{1}=k_{1}^{:K^{A}}+\bbnum 0$
and $x_{2}=k_{2}^{:K^{B}}+\bbnum 0$ with some $k_{1}$ and $k_{2}$.
Then the condition $(x_{1},x_{2})\in r^{\updownarrow(K+L)}$ is equivalent
to $(k_{1},k_{2})\in r^{\updownarrow K}$, while the values $t_{1}(x_{1})$
and $t_{2}(x_{2})$ are expressed as:
\[
t_{1}(x_{1})=(k_{1}+\bbnum 0)\triangleright\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p_{1}\\
L^{A} & q_{1}
\end{array}\,=p_{1}(k_{1})\quad,\quad\quad t_{2}(x_{2})=(k_{2}+\bbnum 0)\triangleright\,\begin{array}{|c||c|}
 & G^{B}\\
\hline K^{B} & p_{2}\\
L^{B} & q_{2}
\end{array}\,=p_{2}(k_{2})\quad.
\]
So, the conclusion of the relational naturality law of $t$ holds
due to the relational law of $p$:
\[
\big(t_{1}(x_{1}),t_{2}(x_{2})\big)=\big(p_{1}(k_{1}),p_{2}(k_{2})\big)\in r^{\updownarrow G}\quad.
\]

A similar argument proves the law for the case when both $x_{1}$
and $x_{2}$ in the right part. We write $x_{1}=\bbnum 0+l_{1}^{:L^{A}}$
and $x_{2}=\bbnum 0+l_{2}^{:L^{B}}$ and reduce the relational naturality
law of $t$ to that of $q$.

\paragraph{Recursive call}

In this case, $t\triangleq g$ where $g$ is a recursive call to a
function (defined outside that expression). When proving a law of
a recursively defined function, we may assume that the law holds for
recursive calls to that function. So, the inductive assumption says
that $g$ is some expression for which the relational naturality law
already holds. It then holds for $t$ since $t=g$.

This completes the proof of the relational parametricity theorem.

\subsection{Deriving the wedge law and the naturality laws from parametricity}

A programmer usually needs to derive laws in terms of \emph{functions}
rather than relations. To convert the relational naturality law~(\ref{eq:relational-naturality-law-simplified})
into a law involving functions, we first choose $r$ to be a graph
relation, $r\triangleq\left<f\right>$, with an arbitrary function
$f$. Then we need to express the lifted relation $r^{\updownarrow Q}$
via an equation and derive the corresponding equation for $t$. However,
this is not always possible: Example~\ref{subsec:Example-relational-lifting}(e)
shows that for sufficiently complicated type constructors $Q$, the
lifted graph relation $\left<f\right>^{\updownarrow Q}$ is \emph{not}
expressible as a single equation. Nevertheless, for many type signatures
found in practice, this problem does not arise and the relational
naturality law is reduced to the dinaturality law~(\ref{eq:dinaturality-law-for-profunctors})
via the wedge law~(\ref{eq:wedge-law-for-profunctors}). For those
type signatures, the dinaturality law  and the wedge law are shortcuts
for using the parametricity theorem without having to work with a
fully general relational laws. For fully parametric natural transformations
with type signatures of the form $\forall A.\,G^{A}\rightarrow H^{A}$,
the wedge law reduces to the naturality laws~(\ref{eq:naturality-law-for-functors})
or~(\ref{eq:naturality-law-for-contrafunctors}). In this way, proving
the wedge law entails proving all the naturality laws for fully parametric
functions.

We will now derive the wedge law from the relational naturality law
of \lstinline!xmap!.\footnote{Our proof is adapted from the blog post by B.~Milewski\index{Bartosz Milewski}
(\texttt{\href{https://bartoszmilewski.com/2017/04/11/}{https://bartoszmilewski.com/2017/04/11/}}).
A different derivation of the dinaturality law from the relational
parametricity theorem was given by J.~Voigtl\"ander\index{Janis@Janis Voigtl\"ander}
in the paper \texttt{\href{https://arxiv.org/pdf/1908.07776.pdf}{https://arxiv.org/pdf/1908.07776.pdf}}.
A proof of the dinaturality law based on finding a syntactic normal
form of fully parametric code (and \emph{without} using relational
 parametricity) is in the paper \textsf{``}Dinatural terms in System $F$\textsf{''}
by J.~de Lataillade\index{Joachim de Lataillade}: see \texttt{\href{https://www.irif.fr/~delatail/dinat.pdf}{https://www.irif.fr/$\sim$delatail/dinat.pdf}}} 

\subsubsection{Statement \label{subsec:Statement-wedge-law-from-parametricity}\ref{subsec:Statement-wedge-law-from-parametricity}}

\textbf{(a)} For a profunctor $P^{X,Y}$ with fully parametric liftings,
define $T^{A}\triangleq P^{A,A}$. Then:
\[
\text{for all }X,Y,f^{:X\rightarrow Y},x^{:P^{X,X}},y^{:P^{Y,Y}}\quad:\quad\text{if}\quad(x,y)\in\left<f\right>^{\updownarrow T}\quad\text{then}\quad x\triangleright f^{\uparrow P^{X,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,Y}}\quad.
\]
In other words, the $\left(P,f\right)$-wedge relation is a consequence
of the lifted graph relation $\left<f\right>^{\updownarrow T}$.

\textbf{(b)} Any fully parametric value $t$ of type $\forall A.\,P^{A,A}$
satisfies the wedge law\index{wedge law!of profunctors}~(\ref{eq:wedge-law-for-profunctors}):
\[
\text{for all }X,Y,f^{:X\rightarrow Y}\quad:\quad t^{X}\triangleright f^{\uparrow P^{X,\bullet}}=t^{Y}\triangleright f^{\downarrow P^{\bullet,Y}}\quad.
\]
In other words, $t^{X}$ and $t^{Y}$ are always in the $(P,f)$-wedge
relation\index{wedge relation} for any function $f^{:X\rightarrow Y}$.

\subparagraph{Proof}

\textbf{(a)} The profunctor $P$ has an \lstinline!xmap! method with
the type signature:
\[
\text{xmap}_{P}:\forall A,B,C,D.\,\left(B\rightarrow A\right)\rightarrow\left(C\rightarrow D\right)\rightarrow P^{A,C}\rightarrow P^{B,D}\quad.
\]
This method may be defined by:
\[
\text{xmap}_{P}(f^{:B\rightarrow A})(g^{:C\rightarrow D})=f^{\downarrow P^{\bullet,C}}\bef g^{\uparrow P^{A,\bullet}}\quad.
\]
Here, we do not assume the profunctor commutativity law (Statement~\ref{subsec:Proof-of-the-profunctor-commutativity-law})
but simply choose a specific order of composition, namely $f\bef g$,
while defining \lstinline!xmap!. We can now express the $\left(P,f\right)$-wedge
relation in terms of \lstinline!xmap!:
\[
x\triangleright f^{\uparrow P^{X,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,Y}}\quad\text{is equivalent to}:\quad\text{xmap}_{P}(\text{id})(f)(x)=\text{xmap}_{P}(f)(\text{id})(y)\quad.
\]
The condition we are required to prove can now be expressed via \lstinline!xmap!
like this:
\begin{equation}
\text{if}\quad(x,y)\in\left<f\right>^{\updownarrow T}\quad\text{then}\quad\text{xmap}_{P}(\text{id})(f)(x)=\text{xmap}_{P}(f)(\text{id})(y)\quad.\label{eq:wedge-law-from-parametricity-derivation1}
\end{equation}
The \lstinline!xmap! method is implemented by fully parametric code.
It follows from Statement~\ref{subsec:Statement-main-relational-parametricity-1}
that \lstinline!xmap! satisfies a relational naturality law. Since
\lstinline!xmap! has four type parameters ($A$, $B$, $C$, $D$),
its relational naturality law involves 8 arbitrary types (denote them
by $A$, $B$, $C$, $D$, $A^{\prime}$, $B^{\prime}$, $C^{\prime}$,
$D^{\prime}$) and 4 arbitrary relations (denote them by $a^{:A\leftrightarrow A^{\prime}}$,
$b^{:B\leftrightarrow B^{\prime}}$, $c^{:C\leftrightarrow C^{\prime}}$,
and $d^{:D\leftrightarrow D^{\prime}}$). With these notations, we
write the relational naturality law of \lstinline!xmap! as:
\begin{equation}
\forall(a,b,c,d)\quad:\quad(\text{xmap}_{P}^{A,B,C,D},\text{xmap}_{P}^{A^{\prime},B^{\prime},C^{\prime},D^{\prime}})\in(b\ogreaterthan a)\ogreaterthan(c\ogreaterthan d)\ogreaterthan(a,c)^{\updownarrow P}\ogreaterthan(b,d)^{\updownarrow P}\quad,\label{eq:relational-naturality-law-of-xmap}
\end{equation}
where $(a,c)^{\updownarrow P}$ and $(b,d)^{\updownarrow P}$ are
simultaneous liftings to the profunctor $P$ (see Definition~\ref{subsec:Definition-simultaneous-relational-lifting}).
Writing out the definition of the pair mapper ($\ogreaterthan$),
we express this law as:
\begin{align}
 & \forall\big(a^{:A\leftrightarrow A^{\prime}},b^{:B\leftrightarrow B^{\prime}},c^{:C\leftrightarrow C^{\prime}},d^{:D\leftrightarrow D^{\prime}},g^{:B\rightarrow A},h^{:B^{\prime}\rightarrow A^{\prime}},k^{:C\rightarrow D},l^{:C^{\prime}\rightarrow D^{\prime}},x^{:P^{A,C}},y^{:P^{A^{\prime},C^{\prime}}}\big)\quad:\nonumber \\
 & \quad\text{if}\quad\quad(g,h)\in b\ogreaterthan a\quad,\quad(k,l)\in c\ogreaterthan d\quad,\quad\text{and}\quad(x,y)\in(a,c)^{\updownarrow P}\quad,\nonumber \\
 & \quad\text{then}\quad\quad\big(\text{xmap}_{P}(g)(k)(x),\,\text{xmap}_{P}(h)(l)(y)\big)\in(b,d)^{\updownarrow P}\quad.\label{eq:xmap-relational-law-derivation2}
\end{align}
The relational naturality law~(\ref{eq:xmap-relational-law-derivation2})
of \lstinline!xmap! holds for arbitrary choices of 8 types, 4 relations,
and 4 functions, in addition to the values $x$ and $y$. The plan
of the proof is to substitute certain carefully chosen functions and
relations into Eq.~(\ref{eq:xmap-relational-law-derivation2}) in
order to derive Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1}). 

We note that Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1})
says that two \lstinline!xmap(...)! values must be equal (both values
having type $P^{X,Y}$). This can be obtained from Eq.~(\ref{eq:xmap-relational-law-derivation2})
only if the relation $(b,d)^{\updownarrow P}$ is an identity relation
of type $P^{X,Y}\leftrightarrow P^{X,Y}$. We will prove in Statement~\ref{subsec:Statement-relational-lifting-identity-law}
below that a simultaneous lifting of two identity relations gives
again an identity relation. This suggests choosing $b=\text{id}$
and $d=\text{id}$, which also requires us to set the types as $B=B^{\prime}=X$
and $D=D^{\prime}=Y$.

The relations $a$ and $c$ need to be chosen such that the precondition
$(x,y)\in(a,c)^{\updownarrow P}$ in Eq.~(\ref{eq:xmap-relational-law-derivation2})
reproduces the precondition $(x,y)\in\left<f\right>^{\updownarrow T}$
in Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1}). Statement~\ref{subsec:Statement-relational-lifting-consistency-PAA}
shows that $r^{\updownarrow T}=(r,r)^{\updownarrow P}$ for any relation
$r$. In particular, $\left<f\right>^{\updownarrow T}=(\left<f\right>,\left<f\right>)^{\updownarrow P}$.
So, we need to set $a=c=\left<f\right>$ and the corresponding types
$A=C=X$ and $A^{\prime}=C^{\prime}=Y$.

The functions $g$, $h$, $k$, and $l$ in Eq.~(\ref{eq:xmap-relational-law-derivation2})
are chosen such that:
\[
\text{xmap}_{P}(g)(k)(x)=\text{xmap}_{P}(\text{id})(f)(x)\quad,\quad\quad\text{xmap}_{P}(h)(l)(x)=\text{xmap}_{P}(f)(\text{id})(x)\quad.
\]
This implies $g=\text{id}$, $h=k=f$, and $l=\text{id}$. With these
choices, the preconditions $(g,h)\in b\ogreaterthan a$ and $(k,l)\in c\ogreaterthan d$
will automatically hold in Eq.~(\ref{eq:xmap-relational-law-derivation2}).
So, the conclusion of Eq.~(\ref{eq:xmap-relational-law-derivation2})
also holds, which proves Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1}). 

\textbf{(b)} The relational parametricity theorem (Statement~\ref{subsec:Statement-main-relational-parametricity-1})
gives $(t^{X},t^{Y})\in c^{\updownarrow T}$ for any relation $c^{:X\leftrightarrow Y}$.
We can now choose $c\triangleq\left<f\right>$ and use the result
of part \textbf{(a)} where we set $x\triangleq t^{X}$ and $y\triangleq t^{Y}$.
Then we obtain $t^{X}\triangleright f^{\uparrow P^{X,\bullet}}=t^{Y}\triangleright f^{\downarrow P^{\bullet,Y}}$,
which is the wedge law of $t$. $\square$

While proving Statement~\ref{subsec:Statement-wedge-law-from-parametricity},
we used the \textbf{identity laws}\index{identity laws!of relational lifting}
of the relational lifting:

\subsubsection{Statement \label{subsec:Statement-relational-lifting-identity-law}\ref{subsec:Statement-relational-lifting-identity-law}}

\textbf{(a)} An identity relation can be removed from a simultaneous
lifting. For instance, given any type constructor $H$ with two type
parameters, a fixed type $T$, and any relation $r^{:A\leftrightarrow B}$,
we have: 
\[
(r,\text{id}^{:T\leftrightarrow T})^{\updownarrow H}=r^{\updownarrow G}\quad,\quad\quad\text{where we defined}:\quad G^{A}\triangleq H^{A,T}\quad.
\]

\textbf{(b)} Lifting one or more identity relations produces again
an identity relation: 
\[
\text{for any }G,H,\text{etc}.:\quad(\text{id}^{:A\leftrightarrow A})^{\updownarrow G}=\text{id}^{:G^{A}\leftrightarrow G^{A}}\quad,\quad\quad(\text{id}^{:A\leftrightarrow A},\text{id}^{:X\leftrightarrow X})^{\updownarrow H}=\text{id}^{:H^{A,X}\leftrightarrow H^{A,X}}\quad,\quad\text{etc}.
\]


\subparagraph{Proof}

\textbf{(a)} Enumerate all cases of Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
for $H$.

If $H^{A,X}\triangleq Z$ with a fixed type $Z$, we have also $G^{A}=Z$.
Then $(r,s)^{\updownarrow H}\triangleq\text{id}^{:Z\leftrightarrow Z}$
and $r^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}$ for any
relations $r$, $s$. So, $(r,\text{id})^{\updownarrow H}=r^{\updownarrow G}$.

If $H^{A,X}\triangleq A$, we have $G^{A}=A$. Then $(r,s)^{\updownarrow H}\triangleq r$
and $r^{\updownarrow G}=r$ for any relation $r$, so we obtain $(r,\text{id})^{\updownarrow H}=r^{\updownarrow G}$.

The next three similar cases use the inductive assumptions $(r,\text{id})^{\updownarrow K}=r^{\updownarrow K^{\bullet,T}}$
and $(r,\text{id})^{\updownarrow L}=r^{\updownarrow L^{\bullet,T}}$:
\begin{align*}
{\color{greenunder}\text{if }H^{A,X}\triangleq K^{A,X}\times L^{A,X}:}\quad & (r,\text{id})^{\updownarrow H}=(r,\text{id})^{\updownarrow K}\boxtimes(r,\text{id})^{\updownarrow L}=r^{\updownarrow K^{\bullet,T}}\boxtimes r^{\updownarrow L^{\bullet,T}}=r^{\updownarrow(K^{\bullet,T}\times L^{\bullet,T})}=r^{\updownarrow G}\quad;\\
{\color{greenunder}\text{if }H^{A,X}\triangleq K^{A,X}+L^{A,X}:}\quad & (r,\text{id})^{\updownarrow H}=(r,\text{id})^{\updownarrow K}\boxplus(r,\text{id})^{\updownarrow L}=r^{\updownarrow K^{\bullet,T}}\boxplus r^{\updownarrow L^{\bullet,T}}=r^{\updownarrow(K^{\bullet,T}+L^{\bullet,T})}=r^{\updownarrow G}\quad;\\
{\color{greenunder}\text{if }H^{A,X}\triangleq K^{A,X}\rightarrow L^{A,X}:}\quad & (r,\text{id})^{\updownarrow H}=(r,\text{id})^{\updownarrow K}\ogreaterthan(r,\text{id})^{\updownarrow L}=r^{\updownarrow K^{\bullet,T}}\ogreaterthan r^{\updownarrow L^{\bullet,T}}=r^{\updownarrow(K^{\bullet,T}\rightarrow L^{\bullet,T})}=r^{\updownarrow G}\quad.
\end{align*}

If $H^{A,X}\triangleq S^{A,X,H^{A,X}}$ with a pattern functor $S$,
the type constructor $G$ is defined by: 
\[
G^{A}\triangleq H^{A,T}=S^{A,T,H^{A,T}}=S^{A,T,G^{A}}\quad.
\]
So, the lifting to $G$ is given by $r^{\updownarrow G}=\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{\bullet,T,\bullet}}$.
Write the definition of lifting to $H$ and simplify:
\begin{align*}
 & (r,\text{id})^{\updownarrow H}=\big(r,\text{id},\overline{(r,\text{id})^{\updownarrow H}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\overline{(r,\text{id})^{\updownarrow H}}=\overline{r^{\updownarrow G}}:}\quad & =\big(r,\gunderline{\text{id}},\overline{r^{\updownarrow G}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption about lifting id to }S:}\quad & =\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{\bullet,T,\bullet}}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =r^{\updownarrow G}\quad.
\end{align*}

If $H^{A,X}\triangleq\forall Z.\,S^{Z,A,X}$, the type constructor
$G$ is $G^{A}=\forall Z.\,S^{Z,A,T}$. The lifting $(r,\text{id})^{\updownarrow H}$
is a relation of type $\forall U.\,S^{U,A,X}\leftrightarrow\forall V.\,S^{V,A,X}$
written as:
\begin{align*}
 & \forall(U,V):\quad\big((r,\text{id})^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}\big)^{U,V}=\forall w^{:U\leftrightarrow V}.\,(w,r,\gunderline{\text{id}})^{\updownarrow S^{\bullet,\bullet,\bullet}}\\
{\color{greenunder}\text{omitting id from lifting to }S:}\quad & =\forall w^{:U\leftrightarrow V}.\,(w,r)^{\updownarrow S^{\bullet,\bullet,T}}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =(r^{\updownarrow G})^{U,V}\quad.
\end{align*}
Here we used the inductive assumption that identity relations may
be omitted from liftings to $S$.

\textbf{(b)} Enumerate all cases of Definition~\ref{subsec:Definition-relational-lifting}
for $G$ or Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
for $H$. The proofs are similar, so we will only prove that $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.

If $H^{A,X}\triangleq Z$ with a fixed type $Z$, we have $(r,s)^{\updownarrow H}\triangleq\text{id}^{:Z\leftrightarrow Z}$
for any relations $r$, $s$.

If $H^{A,X}\triangleq A$, we have $(r,s)^{\updownarrow H}\triangleq r$
for any relation $r$, so we obtain $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.
Similarly if $H^{A,X}\triangleq X$ then we obtain $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.

The next three similar cases use the inductive assumptions $(\text{id},\text{id})^{\updownarrow K}=\text{id}$
and $(\text{id},\text{id})^{\updownarrow L}=\text{id}$:
\begin{align*}
{\color{greenunder}\text{if }H\triangleq K\times L:}\quad & (\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id})^{\updownarrow K}\boxtimes(\text{id},\text{id})^{\updownarrow L}=\text{id}\boxtimes\text{id}\quad;\\
{\color{greenunder}\text{if }H\triangleq K+L:}\quad & (\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id})^{\updownarrow K}\boxplus(\text{id},\text{id})^{\updownarrow L}=\text{id}\boxplus\text{id}\quad;\\
{\color{greenunder}\text{if }H\triangleq K\rightarrow L:}\quad & (\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id})^{\updownarrow K}\ogreaterthan(\text{id},\text{id})^{\updownarrow L}=\text{id}\ogreaterthan\text{id}\quad.
\end{align*}
It follows from Example~\ref{subsec:Example-pair-product-pair-mapper-relation}
with $f=\text{id}$ and $g=\text{id}$ that:
\[
\text{id}\boxtimes\text{id}=\text{id}\quad,\quad\quad\text{id}\boxplus\text{id}=\text{id}\quad,\quad\quad\text{and}\quad\quad\text{id}\ogreaterthan\text{id}=\text{id}\quad.
\]
So, in all three cases we obtain: $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.

If $H^{A,X}\triangleq S^{A,X,H^{A,X}}$ with a pattern functor $S$,
we have:
\[
(\text{id},\text{id})^{\updownarrow H}=\big(\text{id},\text{id},\overline{(\text{id},\text{id})^{\updownarrow H}}\big)^{\updownarrow S}=(\text{id},\text{id},\text{id})^{\updownarrow S}\quad,
\]
because by the inductive assumption the identity law holds for the
recursive call: $\overline{(\text{id},\text{id})^{\updownarrow H}}=\text{id}$.
Another inductive assumption is that the identity law holds for the
liftings to $S$. So, we get: 
\[
(\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id},\text{id})^{\updownarrow S}=\text{id}\quad.
\]

If $H^{A,X}\triangleq\forall Z.\,S^{Z,A,X}$, the lifting $(\text{id},\text{id})^{\updownarrow H}$
is a relation of type $\forall U.\,S^{U,A,X}\leftrightarrow\forall V.\,S^{V,A,X}$
written as:
\[
\forall(U,V):\quad\big((\text{id},\text{id})^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}\big)^{U,V}=\forall w^{:U\leftrightarrow V}.\,(w,\text{id},\text{id})^{\updownarrow H^{\bullet,\bullet,\bullet}}\quad.
\]
As we showed in part \textbf{(a)}, any identity relation may be omitted
from the lifting:
\[
\forall w^{:U\leftrightarrow V}.\,(w,\gunderline{\text{id}^{:A\leftrightarrow A}},\gunderline{\text{id}^{:X\leftrightarrow X}})^{\updownarrow H^{\bullet,\bullet,\bullet}}=\forall w^{:U\leftrightarrow V}.\,w^{\updownarrow H^{\bullet,A,X}}\quad.
\]
By Statement~\ref{subsec:Statement-parametricity-gives-identity-relation}
used for $H^{\bullet,A,X}$ as a type constructor with one type parameter,
the relation $\forall w.\,w^{\updownarrow H^{\bullet,A,X}}$ is the
identity relation for the type $\forall Z.\,H^{Z,A,X}$. We find that
$(\text{id},\text{id})^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}=\text{id}$.
$\square$

\begin{comment}
commutativity law does not hold!
\end{comment}


\section{Applications of parametricity: beyond Yoneda\label{sec:Applications-of-parametricity:beyond-Yoneda}}

The previous section proved the parametricity theorem and the wedge
law, for any fully parametric code built up from the constructions
in Table~\ref{tab:nine-pure-code-constructions}. That law is sufficient
to obtain all naturality laws for functions that have the type signature
of a natural transformation. In particular, one can prove that the
two Yoneda identities (Section~\ref{subsec:Yoneda-identities}) hold:
\begin{align*}
{\color{greenunder}\text{for any contrafunctor }H:}\quad & \forall A.\,(A\rightarrow Z)\rightarrow H^{A}\cong H^{Z}\quad,\\
{\color{greenunder}\text{for any functor }F:}\quad & \forall A.\,(Z\rightarrow A)\rightarrow F^{A}\cong F^{Z}\quad.
\end{align*}
 as long as all values of those types are implemented via fully parametric
code.

However, the wedge law does not give sufficient information for certain
proofs involving parametricity for more complicated type signatures.
This section will show some techniques that go beyond applications
of naturality laws and Yoneda identities.

\subsection{Strong dinaturality: definition and general properties\label{subsec:Strong-dinaturality.-General-properties}}

For certain type signatures, the relational naturality law entails
a property called the \textsf{``}strong dinaturality\textsf{''}. This property is
not expressed as a single equation and is more complicated than the
wedge law but is still simpler to use than the full relational naturality
law. In this book, strong dinaturality is used to prove Statements~\ref{subsec:relational-property-for-foldFn},
\ref{subsec:Statement-Church-encoding-recursive-type-covariant},
and~\ref{subsec:Statement-strong-dinaturality-property-of-fix},
while in all other places the wedge law is sufficient. This and the
following sections will prove that the strong dinaturality law follows
from the relational naturality law.

\paragraph{Remark}

Strong dinaturality does \emph{not} hold when the type signature involves
deeply nested functions such as $F^{R}\triangleq\forall A.\,(\left(A\rightarrow R\right)\rightarrow A)\rightarrow A$.
It turns out that $F^{R}\cong R$ (see Exercise~\ref{par:Problem-Peirce-law}).
To prove that, one needs to use more advanced techniques that use
the relational naturality law in its full generality. The wedge law
still holds for functions of type $F^{R}$ but does not provide enough
information for proving the type equivalence $F^{R}\cong R$. $\square$

As motivation, we begin by looking at the wedge law~(\ref{eq:wedge-law-for-profunctors})
in more detail.

We have seen in Statement~\ref{subsec:Statement-wedge-law-from-parametricity}
that fully parametric values automatically satisfy the wedge law.
The proof showed that the $\left(P,f\right)$-wedge relation is a
consequence of the lifted graph relation $(x,y)\in\left<f\right>^{\updownarrow T}$
where $T^{A}\triangleq P^{A,A}$. Note that the type diagrams for
the wedge law~(\ref{eq:wedge-law-for-profunctors}), the dinaturality
law~(\ref{eq:dinaturality-law-for-profunctors}), and the commutativity
law~(\ref{eq:profunctor-commutativity-law}) involve three relations
between values $x^{:P^{A,A}}$ and $y^{:P^{B,B}}$:
\begin{align*}
{\color{greenunder}\text{a }\left(P,f\right)\text{-wedge relation}:}\quad & x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad,\quad\text{or}:\quad(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad,\\
{\color{greenunder}\text{the left part of a dinaturality diagram}:}\quad & \exists z^{:P^{B,A}}\quad\text{such that}\quad x=z\triangleright f^{\downarrow P^{\bullet,A}}\text{ and }y=z\triangleright f^{\uparrow P^{B,\bullet}}\quad,\\
{\color{greenunder}\text{a graph relation }\left<f\right>\text{ lifted to }T:}\quad & (x,y)\in\left<f\right>^{\updownarrow T}\quad.
\end{align*}
To make the notation shorter, we define the \textbf{pushout} \textbf{relation}\index{pushout relation|textit}
denoted by $\text{push}\,(p,q)$:
\[
(x^{:A},y^{:B})\in\text{push}\,(p,q)\text{ means }\exists z^{:C}\text{ such that }x=p(z)\text{ and }y=q(z)\quad.
\]
Here $A$, $B$, $C$ are any types and $p^{:C\rightarrow A}$ and
$q^{:C\rightarrow A}$ are any given functions. The left fragment
of the dinaturality diagram is then written as $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$.

The pullback and pushout relations may be used to reformulate the
commutativity law~(\ref{eq:profunctor-commutativity-law}) as: 
\[
\text{for any }x^{:P^{A,A}},y^{:P^{B,B}}\quad:\quad\text{if}\quad(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad\text{then}\quad(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad.
\]
We find that the $\left(P,f\right)$-wedge relation, denoted by $\text{pull}\,(f^{\uparrow P},f^{\downarrow P})$,
is a consequence of both the lifted relation $\left<f\right>^{\updownarrow T}$
and of the relation $\text{push}\,(f^{\downarrow P},f^{\uparrow P})$,
which we may call the $\left(P,f\right)$-pushout relation.

The $\left(P,f\right)$-pushout relation is generally stronger than
the lifted relation $\left<f\right>^{\updownarrow T}$:

\subsubsection{Statement \label{subsec:Statement-profunctor-pushout-entails-lifted-f}\ref{subsec:Statement-profunctor-pushout-entails-lifted-f}}

We assume a fully parametric profunctor $P$, arbitrary types $X$,
$Y$, and arbitrary values $x^{:P^{X,X}}$, $y^{:P^{Y,Y}}$, and $f^{:X\rightarrow Y}$.
If $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$ then
$(x,y)\in\left<f\right>^{\updownarrow T}$, where we defined $T^{A}\triangleq P^{A,A}$.

\subparagraph{Proof}

The relation $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$
means that there exists $z^{:P^{Y,X}}$ such that $x=z\triangleright f^{\downarrow P}$
and $y=z\triangleright f^{\uparrow P}$. Rewrite the expressions for
$x$ and $y$ using the \lstinline!xmap! method of $P$:
\[
x=\text{xmap}_{P}(f)(\text{id})(z)\quad,\quad\quad y=\text{xmap}_{P}(\text{id})(f)(z)\quad.
\]
We need to show that $(x,y)\in\left<f\right>^{\updownarrow T}$, which
we can write in terms of \lstinline!xmap! like this:
\begin{equation}
\forall z^{:P^{Y,X}}:\quad\big(\text{xmap}_{P}(f)(\text{id})(z),\,\text{xmap}_{P}(\text{id})(f)(z)\big)\in\left<f\right>^{\updownarrow T}\quad.\label{eq:pushout-relation-entails-lifted-derivation1}
\end{equation}
This equation is similar to the relational naturality law~(\ref{eq:relational-naturality-law-of-xmap})
of \lstinline!xmap! that was used in the proof of Statement~\ref{subsec:Statement-wedge-law-from-parametricity}:
\[
\forall(a,b,c,d)\quad:\quad(\text{xmap}_{P}^{A,B,C,D},\text{xmap}_{P}^{A^{\prime},B^{\prime},C^{\prime},D^{\prime}})\in(b\ogreaterthan a)\ogreaterthan(c\ogreaterthan d)\ogreaterthan(a,c)^{\updownarrow P}\ogreaterthan(b,d)^{\updownarrow P}\quad.
\]
As we did the proof of that statement, we will now choose specific
types and relations in this law in order to derive Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1}).
We begin by writing out the definition of $\ogreaterthan$:
\begin{align}
 & \forall\big(a^{:A\leftrightarrow A^{\prime}},b^{:B\leftrightarrow B^{\prime}},c^{:C\leftrightarrow C^{\prime}},d^{:D\leftrightarrow D^{\prime}},g^{:B\rightarrow A},h^{:B^{\prime}\rightarrow A^{\prime}},k^{:C\rightarrow D},l^{:C^{\prime}\rightarrow D^{\prime}},x^{:P^{A,C}},y^{:P^{A^{\prime},C^{\prime}}}\big)\quad:\nonumber \\
 & \quad\text{if}\quad\quad(g,h)\in b\ogreaterthan a\quad,\quad(k,l)\in c\ogreaterthan d\quad,\quad\text{and}\quad(x,y)\in(a,c)^{\updownarrow P}\quad,\nonumber \\
 & \quad\text{then}\quad\quad\big(\text{xmap}_{P}(g)(k)(x),\,\text{xmap}_{P}(h)(l)(y)\big)\in(b,d)^{\updownarrow P}\quad.\label{eq:xmap-relational-law-derivation3}
\end{align}

The conclusion of Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1})
is that two \lstinline!xmap(...)! values are in the relation $\left<f\right>^{\updownarrow T}$.
We can reproduce that conclusion using Eq.~(\ref{eq:xmap-relational-law-derivation3})
if we set $b=d=\left<f\right>$ since, by Statement~\ref{subsec:Statement-relational-lifting-consistency-PAA},
we will then have $(b,d)^{\updownarrow P}=(\left<f\right>,\left<f\right>)^{\updownarrow P}=\left<f\right>^{\updownarrow T}$.
The corresponding types need to be set as $B=D=X$ and $B^{\prime}=D^{\prime}=Y$.

Next, we need to find the values $g$, $h$, $k$, $l$, $x$, and
$y$ such that the \lstinline!xmap(...)! expressions in Eq.~(\ref{eq:xmap-relational-law-derivation3})
reproduce those in Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1}):
\[
\text{xmap}_{P}(g)(k)(x)=\text{xmap}_{P}(f)(\text{id})(z)\quad,\quad\quad\text{xmap}_{P}(h)(l)(y)=\text{xmap}_{P}(\text{id})(f)(z)\quad.
\]
It is clear that we need to set $g=l=f$, $h=\text{id}$, $k=\text{id}$,
and $x=y=z$. This also implies that we set the types as $B=C^{\prime}=X$,
$A=D^{\prime}=Y$, $A^{\prime}=B^{\prime}=Y$, and $C=D=X$.

Since we have $x=y$, the precondition $(x,y)\in(a,c)^{\updownarrow P}$
will hold if $(a,c)^{\updownarrow P}$ is an identity relation. To
achieve that, we choose $a=\text{id}$ and $c=\text{id}$, which also
means setting $A=A^{\prime}=Y$ and $C=C^{\prime}=X$. 

Finally, we can check that the preconditions $(g,h)\in b\ogreaterthan a$
and $(k,l)\in c\ogreaterthan d$ in Eq.~(\ref{eq:xmap-relational-law-derivation3})
will then hold automatically. So, we may use the conclusion of Eq.~(\ref{eq:xmap-relational-law-derivation3}),
which proves Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1}).
$\square$

It turns out that for some (but not all) profunctors $P$, the $\left(P,f\right)$-wedge
relation is \emph{equivalent} to the $\left(P,f\right)$-pushout relation:

\subsubsection{Definition \label{subsec:Definition-profunctor-pushout-property}\ref{subsec:Definition-profunctor-pushout-property}}

A profunctor $P^{X,Y}$ %
\begin{comment}
empty arrow
\end{comment}
{} has the \textbf{pushout property}\index{profunctor!pushout property}\index{pushout property of profunctors}
if the relation $\text{push}\,(f^{\downarrow P},f^{\uparrow P})$
is a consequence of $\text{pull}\,(f^{\uparrow P},f^{\downarrow P})$.
So, for any $x^{:P^{A,A}}$, $y^{:P^{B,B}}$:
\[
\text{if }(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\text{ then }(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad.
\]
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{1.5pc} & P^{A,A}\ar[d]\sb(0.4){f^{\uparrow P^{A,\bullet}}} & \ar@{}[d]\sb(0.4){\displaystyle \Rightarrow} & P^{B,A}\ar[r]\sp(0.55){f^{\downarrow P^{\bullet,A}}}\ar[d]\sb(0.4){f^{\uparrow P^{B,\bullet}}} & P^{A,A}\ar[d]\sb(0.4){f^{\uparrow P^{A,\bullet}}}\\
P^{B,B}\ar[r]\sp(0.6){f^{\downarrow P^{\bullet,B}}} & P^{A,B} &  & P^{B,B}\ar[r]\sp(0.6){f^{\downarrow P^{\bullet,B}}} & P^{A,B}
}
\]

\noindent In other words, for any $f^{:A\rightarrow B}$ and any values
$x^{:P^{A,A}}$ and $y^{:P^{B,B}}$ in the $\left(P,f\right)$-wedge
relation ($x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$),
we can compute a value $p^{:P^{B,A}}$ such that $x=p\triangleright f^{\downarrow P^{\bullet,A}}$
and $y=p\triangleright f^{\uparrow P^{B,\bullet}}$. The type diagram
means that a wedge starting with arbitrary $x^{:P^{A,A}}$ and $y^{:P^{B,B}}$
can be always completed to a square that represents the profunctor
commutativity law~(\ref{eq:profunctor-commutativity-law}). $\square$

Below we will perform structural analysis for profunctors $P$ with
the pushout property and give some examples. The significance of those
$P$ is that we can obtain a property that is stronger than ordinary
dinaturality:

\subsubsection{Definition \label{subsec:Definition-strong-dinaturality}\ref{subsec:Definition-strong-dinaturality}}

A function $t^{A}:P^{A,A}\rightarrow Q^{A,A}$ is \textbf{strongly
dinatural} \index{strong dinaturality law}if for any $f^{:A\rightarrow B}$,
$x^{:P^{A,A}}$, and $y^{:P^{B,B}}$ the following property holds:
\begin{equation}
\text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad.\label{eq:strong-dinaturality-law}
\end{equation}
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{1.0pc}P^{A,A}\ar[rd]\sb(0.35){f^{\uparrow P^{A,\bullet}}\negthickspace\negthickspace}\ar[rr]\sp(0.5){t^{A}} &  & Q^{A,A}\ar[rd]\sp(0.5){f^{\uparrow Q^{A,\bullet}}}\\
 & P^{A,B} & \negthickspace\Rightarrow & Q^{A,B}\\
P^{B,B}\ar[ru]\sp(0.5){f^{\downarrow P^{\bullet,B}}\negthickspace\negthickspace\negthickspace}\ar[rr]\sp(0.5){t^{B}} &  & Q^{B,B}\ar[ru]\sb(0.65){\negthickspace\negthickspace f^{\downarrow Q^{\bullet,B}}}
}
\]

The strong dinaturality law is an equation (the \textsf{``}conclusion\textsf{''})
that is required to hold only when some values satisfy another equation
(the law\textsf{'}s \textsf{``}precondition\textsf{''}). The type diagram for that law, shown
at left, is a truncated form of the type diagram for Eq.~(\ref{eq:dinaturality-law-for-profunctors}).
The diagram starts with two arbitrary values of types $P^{A,A}$ and
$P^{B,B}$. The implication symbol ($\Rightarrow$) here means that
the left part of the diagram is an assumption used by the right part.

In terms of the wedge relations, strong dinaturality\textsf{'}s \textsf{``}precondition\textsf{''}
is the $\left(P,f\right)$-wedge relation for $(x,y)$, and the \textsf{``}conclusion\textsf{''}
is the $\left(Q,f\right)$-wedge relation for $(t^{A}(x),t^{B}(y))$.
So, the strong dinaturality condition~(\ref{eq:strong-dinaturality-law})
can be expressed as a relation using the pair mapper ($\ogreaterthan$):
\[
(t^{A},t^{B})\in\text{pull}\big(f^{\uparrow P^{A,\bullet}},f^{\downarrow P^{\bullet,B}}\big)\ogreaterthan\text{pull}\big(f^{\uparrow Q^{A,\bullet}},f^{\downarrow Q^{\bullet,B}}\big)\quad.
\]
For comparison, the ordinary dinaturality property of $t$ is written
in a similar way as:
\[
(t^{A},t^{B})\in\text{push}\,(f^{\downarrow P^{\bullet,A}},f^{\uparrow P^{B,\bullet}})\ogreaterthan\text{pull}\big(f^{\uparrow Q^{A,\bullet}},f^{\downarrow Q^{\bullet,B}}\big)\quad.
\]


\subsubsection{Statement \label{subsec:Statement-strong-dinaturality-pushout}\ref{subsec:Statement-strong-dinaturality-pushout}}

If a profunctor $P$ has the pushout property and $Q$ is any profunctor
then any fully parametric function $t:\forall A.\,P^{A,A}\rightarrow Q^{A,A}$
is strongly dinatural.

\subparagraph{Proof}

By Statements~\ref{subsec:Statement-naturality-laws-from-wedge-law}
and~\ref{subsec:Statement-wedge-law-from-parametricity}, the function
$t$ satisfies the ordinary dinaturality law:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
The pushout property of $P$ means:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad.
\]
Chaining the implications, we find:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
This is the strong dinaturality law of $t$. $\square$

The name \textsf{``}strong dinaturality\textsf{''} suggests that this property is
stronger than the ordinary dinaturality. Indeed, strongly dinatural
transformations are always dinatural:

\subsubsection{Statement \label{subsec:Statement-strong-dinaturality-entails-dinaturality}\ref{subsec:Statement-strong-dinaturality-entails-dinaturality}}

\textbf{(a)} Any function $t^{A}:P^{A,A}\rightarrow Q^{A,A}$ satisfying
Eq.~(\ref{eq:strong-dinaturality-law}) will also satisfy Eq.~(\ref{eq:dinaturality-law-for-profunctors}).

\textbf{(b)} A natural transformation $t^{A}:F^{A}\rightarrow G^{A}$
(where $F$ and $G$ are both functors or both contrafunctors) is
strongly dinatural.

\textbf{(c)} A natural transformation $t^{X,Y}:P^{X,Y}\rightarrow Q^{X,Y}$
between profunctors $P$ and $Q$ gives a strongly dinatural transformation
$t^{A,A}:P^{A,A}\rightarrow Q^{A,A}$ if we set $X\triangleq A$ and
$Y\triangleq A$ in $t^{X,Y}$.

\subparagraph{Proof}

\textbf{(a)} The law~(\ref{eq:dinaturality-law-for-profunctors})
is an equality of functions of type $P^{B,A}\rightarrow Q^{A,B}$.
We will now show that those functions will give equal results when
applied to an arbitrary value $p:P^{B,A}$. Choose $x\triangleq p\triangleright f^{\downarrow P^{\bullet,A}}$
and $y\triangleq p\triangleright f^{\uparrow P^{B,\bullet}}$. The
precondition in Eq.~(\ref{eq:strong-dinaturality-law}) is satisfied
with these $x$ and $y$:
\begin{align*}
{\color{greenunder}\text{expect to equal }(y\triangleright f^{\downarrow P^{\bullet,B}}):}\quad & \gunderline x\triangleright f^{\uparrow P^{A,\bullet}}=p\,\gunderline{\triangleright\,f^{\downarrow P^{\bullet,A}}\triangleright f^{\uparrow P^{A,\bullet}}}\\
{\color{greenunder}\text{profunctor commutativity law of }P:}\quad & =p\triangleright f^{\uparrow P^{B,\bullet}}\triangleright f^{\downarrow P^{\bullet,B}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad.
\end{align*}
So, we can use the law~(\ref{eq:strong-dinaturality-law})\textsf{'}s conclusion
and obtain Eq.~(\ref{eq:dinaturality-law-for-profunctors}) applied
to $p$, completing the proof:
\begin{align*}
 & \gunderline x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}\overset{!}{=}\gunderline y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad,\\
{\color{greenunder}\text{definitions of }x,y:}\quad & p\triangleright f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{!}{=}p\triangleright f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\end{align*}

\textbf{(b)} Consider the case where $F$ and $G$ are both functors.
We may view $t^{A}:F^{A}\rightarrow G^{A}$ as a function with the
type signature $t:\forall A.\,P^{A,A}\rightarrow Q^{A,A}$ if we define
the profunctors $P^{X,Y}\triangleq F^{Y}$ and $Q^{X,Y}\triangleq G^{Y}$.
Since $P^{X,Y}$ and $Q^{X,Y}$ ignore the type parameter $X$, we
have the liftings $f^{\uparrow P}=f^{\uparrow F}$, $f^{\downarrow P}=\text{id}$,
$f^{\uparrow Q}=f^{\uparrow G}$, and $f^{\downarrow Q}=\text{id}$.
The strong dinaturality law of $t$ is then written as:
\[
\text{when}\quad x^{:F^{A}}\triangleright f^{\uparrow F}=y^{:F^{B}}\quad\text{ then}\quad x\triangleright t\triangleright f^{\uparrow G}\overset{?}{=}y\triangleright t\quad.
\]
This is equivalent to $x\triangleright t\bef f^{\uparrow G}=x\triangleright f^{\uparrow F}\bef t$,
which holds by the assumed naturality of $t$.

A similar proof works when $F$ and $G$ are both contrafunctors.

We may also derive part \textbf{(b)} from part \textbf{(c)}.

\textbf{(c)} A natural transformation $t^{X,Y}:P^{X,Y}\rightarrow Q^{X,Y}$
satisfies naturality laws separately with respect to the type parameters
$X$ and $Y$. So, for all $f^{:A\rightarrow B}$ we have:
\[
f^{\uparrow P^{X,\bullet}}\bef t^{X,B}=t^{X,A}\bef f^{\uparrow Q^{X,\bullet}}\quad,\quad\quad f^{\downarrow P^{\bullet,Y}}\bef t^{A,Y}=t^{B,Y}\bef f^{\downarrow Q^{\bullet,Y}}\quad.
\]
We need to verify the strong dinaturality law of $t^{A,A}$:
\[
\text{when}\quad x^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright t^{A,A}\bef f^{\uparrow Q^{A,\bullet}}\overset{?}{=}y\triangleright t^{B,B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\]
Using the precondition of that law and the naturality laws of $t^{X,Y}$,
rewrite the conclusion of that law:
\begin{align*}
 & x\triangleright\gunderline{t^{A,A}\bef f^{\uparrow Q^{A,\bullet}}}=\gunderline{x\triangleright f^{\uparrow P^{A,\bullet}}}\bef t^{A,B}=y\triangleright f^{\downarrow P^{\bullet,B}}\bef t^{A,B}\\
 & \overset{?}{=}y\triangleright\gunderline{t^{B,B}\bef f^{\downarrow Q^{\bullet,B}}}=y\triangleright f^{\downarrow P^{\bullet,B}}\bef t^{A,B}\quad.
\end{align*}
The two sides of the strong dinaturality law are now equal. $\square$

Properties of strongly dinatural transformations are in some ways
similar to those of ordinary natural transformations. For instance,
the composition of two natural transformations is again a natural
transformation.

\subsubsection{Statement \label{subsec:Statement-natural-transformations-composition-1}\ref{subsec:Statement-natural-transformations-composition-1}}

For any functors $P$, $Q$, $R$ and natural transformations $u:P^{A}\rightarrow Q^{A}$
and $v:Q^{A}\rightarrow R^{A}$, the composition $t\triangleq u\bef v$
is a natural transformation (of type $P^{A}\rightarrow R^{A}$).

\subparagraph{Proof}

The naturality laws for $u$ and $v$ are written with an arbitrary
$f^{:A\rightarrow B}$ as:
\[
f^{\uparrow P}\bef u=u\bef f^{\uparrow Q}\quad,\quad\quad f^{\uparrow Q}\bef v=v\bef f^{\uparrow R}\quad.
\]
The required naturality law for $t$ is derived by a direct calculation:

\begin{wrapfigure}{l}{0.3\columnwidth}%
\vspace{-1.6\baselineskip}
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.0pc}P^{A}\ar[d]\sp(0.45){f^{\uparrow P}}\ar[r]\sp(0.5){u} & Q^{A}\ar[d]\sp(0.45){f^{\uparrow Q}}\ar[r]\sp(0.5){v} & R^{A}\ar[d]\sp(0.45){f^{\uparrow R}}\\
P^{B}\ar[r]\sp(0.5){u} & Q^{B}\ar[r]\sp(0.5){v} & R^{B}
}
\]
\vspace{-2.8\baselineskip}
\end{wrapfigure}%

~\vspace{-1\baselineskip}
\begin{align*}
{\color{greenunder}\text{expect to equal }t\bef f^{\uparrow R}:}\quad & f^{\uparrow P}\bef\gunderline t=\gunderline{f^{\uparrow P}\bef u}\bef v\\
{\color{greenunder}\text{naturality of }u:}\quad & =u\bef\gunderline{f^{\uparrow Q}\bef v}\\
{\color{greenunder}\text{naturality of }v:}\quad & =\gunderline{u\bef v}\bef f^{\uparrow R}=t\bef f^{\uparrow R}\quad.
\end{align*}
This calculation shows that the above type diagram commutes. $\square$

An analogous proof goes also for compositions of natural transformations
between contrafunctors.

It turns out that strong dinatural transformations also compose:

\subsubsection{Statement \label{subsec:Statement-strongly-dinatural-transformation-composition-1}\ref{subsec:Statement-strongly-dinatural-transformation-composition-1}}

For any profunctors $P$, $Q$, $R$ and any two strongly dinatural
transformations $u:P^{A,A}\rightarrow Q^{A,A}$ and $v:Q^{A,A}\rightarrow R^{A,A}$,
the transformation $t\triangleq u\bef v$ is also strongly dinatural.

\subparagraph{Proof}

We assume that the strong dinaturality law holds for $u$ and $v$:
given $f^{:A\rightarrow B}$,
\begin{align*}
 & \text{for }x^{:P^{A,A}}\text{ and }y^{:P^{B,B}}:\quad\text{ when}\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright u^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=y\triangleright u^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad,\\
 & \text{for }m^{:Q^{A,A}}\text{ and }n^{:Q^{B,B}}:\quad\text{ when}\quad m\triangleright f^{\uparrow Q^{A,\bullet}}=n\triangleright f^{\downarrow Q^{\bullet,B}}\quad\text{ then}\quad m\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}=n\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\end{align*}
We need to show that the strong naturality law holds for $t\triangleq u\bef v$:
\[
\text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright u^{A}\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}\overset{?}{=}y\triangleright u^{B}\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\]
For any $x$ and $y$ satisfying the above assumption, let $m\triangleq x\triangleright u^{A}$
and $n\triangleq y\triangleright u^{B}$. Then the precondition of
the strong dinaturality law of $v$ is satisfied due to the strong
dinaturality law of $u$:
\[
m\triangleright f^{\uparrow Q^{A,\bullet}}=x\triangleright u^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=y\triangleright u^{B}\triangleright f^{\downarrow Q^{\bullet,B}}=n\triangleright f^{\downarrow Q^{\bullet,B}}\quad.
\]
So, we can use the conclusion of the strong dinaturality law of $v$
with these $m$ and $n$:
\[
x\triangleright u^{A}\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}=m\triangleright v^{A}\triangleright f^{\uparrow R^{A,\bullet}}\overset{!}{=}n\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}=y\triangleright u^{B}\triangleright v^{B}\triangleright f^{\downarrow R^{\bullet,B}}\quad.
\]
This is the same as the conclusion of the strong dinaturality law
of $t$. $\square$

The type parameters of a natural transformation can be substituted
by some profunctors to obtain a strongly dinatural transformation.
Two versions of this result are proved next.

\subsubsection{Statement \label{subsec:Statement-strong-dinatural-substitute-functor-in-natural-1}\ref{subsec:Statement-strong-dinatural-substitute-functor-in-natural-1}}

Suppose $u^{A}:G^{A}\rightarrow H^{A}$ is a natural transformation,
and suppose $P^{X,Y}$ is some fully parametric profunctor. Define
the function $t$ by:
\[
t^{A}:G^{P^{A,A}}\rightarrow H^{P^{A,A}}\quad,\quad\quad t^{A}\triangleq u^{P^{A,A}}\quad,
\]
i.e., as the unmodified code of the function $u^{A}$ with a substituted
type parameter ($P^{A,A}$ instead of $A$). Then $t$ is a strongly
dinatural transformation between profunctors $G^{P^{A,A}}$ and $H^{P^{A,A}}$.

\subparagraph{Proof}

By assumption, the naturality law of $u$ holds for any $k^{:R\rightarrow S}$
and says that:
\[
k^{\uparrow G}\bef u^{S}=u^{R}\bef k^{\uparrow H}\quad.
\]
The strong dinaturality law of $t$ says that for arbitrary $x^{:G^{P^{A,A}}}$,
$y^{:G^{P^{B,B}}}$, and $f^{:A\rightarrow B}$,
\[
\text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G}=y\triangleright f^{\downarrow P^{\bullet,B}\uparrow G}\quad\text{ then}\quad x\triangleright t^{A}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H}\overset{?}{=}y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H}\quad.
\]
Substitute $t^{A}\triangleq u^{P^{A,A}}$ into the above equation
and use the naturality law of $u$:
\begin{align*}
{\color{greenunder}\text{expect to equal }(y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H}):}\quad & x\triangleright\gunderline{t^{A}}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H}=x\triangleright\gunderline{u^{P^{A,A}}\bef f^{\uparrow P^{A,\bullet}\uparrow H}}\\
{\color{greenunder}\text{naturality law of }u\text{ with }R\triangleq P^{A,A}\text{ and }S\triangleq P^{A,B}:}\quad & =\gunderline{x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G}}\bef u^{P^{A,B}}\\
{\color{greenunder}\text{assumption }(x\triangleright f^{\uparrow P\uparrow G}=y\triangleright f^{\downarrow P\uparrow G}):}\quad & =y\triangleright\gunderline{f^{\downarrow P^{\bullet,B}\uparrow G}\bef u^{P^{A,B}}}\\
{\color{greenunder}\text{naturality law of }u\text{ with }R\triangleq P^{B,B}\text{ and }S\triangleq P^{A,B}:}\quad & =y\triangleright u^{P^{B,B}}\bef f^{\downarrow P^{\bullet,B}\uparrow H}=y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H}\quad.
\end{align*}


\subsubsection{Statement \label{subsec:Statement-strong-dinatural-substitute-profunctor-in-natural-1}\ref{subsec:Statement-strong-dinatural-substitute-profunctor-in-natural-1}}

Assume that $G^{X,Y}$ and $H^{X,Y}$ are bifunctors, $P^{X,Y}$ and
$Q^{X,Y}$ are profunctors, and $u^{A,B}:G^{A,B}\rightarrow H^{A,B}$
is a natural transformation (separately with respect to the type parameters
$A$ and $B$). Assume that $G$ and $H$ satisfy their commutativity
laws. Define the function $t$ by:
\[
t^{A}:G^{P^{A,A},Q^{A,A}}\rightarrow H^{P^{A,A},Q^{A,A}}\quad,\quad\quad t\triangleq u^{P^{A,A},Q^{A,A}}\quad,
\]
i.e., as the unmodified code of $u^{A,B}$ with substituted type parameters
($P^{A,A}$ and $Q^{A,A}$ instead of $A$ and $B$). Then $t$ is
a strongly dinatural transformation between profunctors $G^{P^{A,A},Q^{A,A}}$
and $H^{P^{A,A},Q^{A,A}}$.

\subparagraph{Proof}

The assumed naturality law of $u$ holds separately with respect to
each type parameter:
\[
f^{\uparrow G^{\bullet,B}}\bef u^{B,B}=u^{A,B}\bef f^{\uparrow H^{\bullet,B}}\quad,\quad\quad f^{\uparrow G^{A,\bullet}}\bef u^{A,B}=u^{A,A}\bef f^{\uparrow H^{A,\bullet}}\quad.
\]
To formulate the strong dinaturality law of $t$, we need to start
with arbitrary $x^{:G^{P^{A,A}}}$, $y^{:G^{P^{B,B}}}$, and $f^{:A\rightarrow B}$,
and lift $f$ to functors such as $G^{P^{A,\bullet},Q^{A,\bullet}}$.
Since, by assumption, $G$ obeys the commutativity law, we may lift
$f$ to $G^{P^{A,\bullet},Q^{A,\bullet}}$ via a composition of liftings
with respect to $P$ and $Q$ in any order, for example $x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow G^{P,\bullet}}$.
We handle the lifting to the contrafunctor $G^{P^{\bullet,A},Q^{\bullet,A}}$
similarly. So, let us write the strong dinaturality law of $t$: 
\begin{align*}
 & \text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}\uparrow G^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow G^{P,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}\uparrow G^{\bullet,Q}}\triangleright f^{\downarrow Q^{\bullet,B}\uparrow G^{P,\bullet}}\\
 & \quad\text{then}\quad x\triangleright t^{A}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow H^{P,\bullet}}\overset{?}{=}y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H^{\bullet,Q}}\triangleright f^{\downarrow Q^{\bullet,B}\uparrow H^{P,\bullet}}\quad.
\end{align*}
Substitute $t\triangleq u^{P^{A,A},Q^{A,A}}$ into the above equation
and use the naturality laws of $u$:
\begin{align*}
 & x\triangleright t^{A}\triangleright f^{\uparrow P^{A,\bullet}\uparrow H^{\bullet,Q}}\triangleright f^{\uparrow Q^{A,\bullet}\uparrow H^{P,\bullet}}=x\triangleright\gunderline{u\bef f^{\uparrow P\uparrow H}\bef}f^{\uparrow Q\uparrow H}=x\triangleright f^{\uparrow P\uparrow G}\bef\gunderline{u\bef f^{\uparrow Q\uparrow H}}=\gunderline{x\triangleright f^{\uparrow P\uparrow G}\triangleright f^{\uparrow Q\uparrow G}}\bef u\\
 & =y\triangleright f^{\downarrow P\uparrow G}\bef\gunderline{f^{\downarrow Q\uparrow G}\bef u}=y\triangleright\gunderline{f^{\downarrow P\uparrow G}\bef u}\bef f^{\downarrow Q\uparrow H}=y\triangleright u\bef f^{\downarrow P\uparrow H}\bef f^{\downarrow Q\uparrow H}\\
 & =y\triangleright t^{B}\triangleright f^{\downarrow P^{\bullet,B}\uparrow H^{\bullet,Q}}\triangleright f^{\downarrow Q^{\bullet,B}\uparrow H^{P,\bullet}}\quad.
\end{align*}
We omitted the full type annotations for brevity, since we already
checked that types match. $\square$

Other known combinators for ordinary natural transformations are the
pair product and pair co-product (see Exercise~\ref{subsec:Exercise-reasoning-1-4-1}b).
It turns out that the same combinators work for strong dinatural transformations:

\subsubsection{Statement \label{subsec:Statement-pair-product-coproduct-strongly-dinatural-1}\ref{subsec:Statement-pair-product-coproduct-strongly-dinatural-1}}

For any two strongly dinatural transformations $u^{:P^{A,A}\rightarrow R^{A,A}}$
and $v^{:Q^{A,A}\rightarrow S^{A,A}}$:

\textbf{(a)} The pair product $t\triangleq u\boxtimes v$ (of type
$P^{A,A}\times Q^{A,A}\rightarrow R^{A,A}\times S^{A,A}$) is strongly
dinatural.

\textbf{(b)} The pair co-product\index{pair co-product of functions}
$t\triangleq u\boxplus v$ (of type $P^{A,A}+Q^{A,A}\rightarrow R^{A,A}+S^{A,A}$)
is strongly dinatural.

\subparagraph{Proof}

\textbf{(a)} The strong dinaturality law of $t\triangleq u\boxtimes v$
says that, for any $f^{:A\rightarrow B}$:
\begin{align*}
 & \text{when}\quad(x_{1}^{:P^{A,A}}\times y_{1}^{:Q^{A,A}})\triangleright f^{\uparrow(P^{A,\bullet}\times Q^{A,\bullet})}=(x_{2}^{:P^{B,B}}\times y_{2}^{:Q^{B,B}})\triangleright f^{\downarrow(P^{\bullet,B}\times Q^{\bullet,B})}\\
 & \quad\text{then}\quad(x_{1}\times y_{1})\triangleright t\triangleright f^{\uparrow(R^{A,\bullet}\times S^{A,\bullet})}=(x_{2}\times y_{2})\triangleright t\triangleright f^{\downarrow(R^{\bullet,B}\times S^{\bullet,B})}\quad.
\end{align*}
Substituting the definitions of liftings to $P\times Q$ and $R\times S$,
as well as the definition $t\triangleq u\boxtimes v$, we get:
\begin{align*}
 & \text{when}\quad(x_{1}\triangleright f^{\uparrow P^{A,\bullet}})\times(y_{1}\triangleright f^{\uparrow Q^{A,\bullet}})=(x_{2}\triangleright f^{\downarrow P^{\bullet,B}})\times(y_{2}\triangleright f^{\downarrow Q^{\bullet,B}})\\
 & \quad\text{then}\quad(x_{1}\triangleright u\bef f^{\uparrow R^{A,\bullet}})\times(y_{1}\triangleright v\bef f^{\uparrow S^{A,\bullet}})=(x_{2}\triangleright u\bef f^{\downarrow R^{\bullet,B}})\times(y_{2}\triangleright v\bef f^{\downarrow S^{\bullet,B}})\quad.
\end{align*}
An equality between pairs is the same as two equalities for the elements
of the pairs. So, the strong naturality law of $t$ is the same as
the following statement:
\begin{align*}
 & \text{when}\quad x_{1}^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=x_{1}^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ and }\quad y_{1}^{:Q^{A,A}}\triangleright f^{\uparrow Q^{A,\bullet}}=y_{2}^{:Q^{B,B}}\triangleright f^{\downarrow Q^{\bullet,B}}\\
 & \quad\text{then}\quad x_{1}\triangleright u\bef f^{\uparrow R^{A,\bullet}}=x_{2}\triangleright u\bef f^{\downarrow R^{\bullet,B}}\quad\text{ and }\quad y_{1}\triangleright v\bef f^{\uparrow S^{A,\bullet}}=y_{2}\triangleright v\bef f^{\downarrow S^{\bullet,B}}\quad.
\end{align*}
These are exactly the preconditions and the conclusions of the strong
naturality laws of $u$ and $v$.

\textbf{(b)} The strong dinaturality law of $t\triangleq u\boxplus v$
says that, for any $f^{:A\rightarrow B}$:
\begin{align*}
 & \text{when}\quad x^{:P^{A,A}+Q^{A,A}}\triangleright f^{\uparrow(P^{A,\bullet}+Q^{A,\bullet})}=y^{:P^{B,B}+Q^{B,B}}\triangleright f^{\downarrow(P^{\bullet,B}+Q^{\bullet,B})}\\
 & \quad\text{then}\quad x\triangleright t\triangleright f^{\uparrow(R^{A,\bullet}+S^{A,\bullet})}=y\triangleright t\triangleright f^{\downarrow(R^{\bullet,B}+S^{\bullet,B})}\quad.
\end{align*}
Substituting the definitions of liftings to $P+Q$ and $R+S$, as
well as the definition $t\triangleq u\boxplus v$, we get:
\begin{align*}
 & \text{when}\quad x^{:P^{A,A}+Q^{A,A}}\triangleright\,\begin{array}{|c||cc|}
 & P^{A,B} & Q^{A,B}\\
\hline P^{A,A} & f^{\uparrow P^{A,\bullet}} & \bbnum 0\\
Q^{A,A} & \bbnum 0 & f^{\uparrow Q^{A,\bullet}}
\end{array}\,=y^{:P^{B,B}+Q^{B,B}}\triangleright\,\begin{array}{|c||cc|}
 & P^{A,B} & Q^{A,B}\\
\hline P^{B,B} & f^{\downarrow P^{\bullet,B}} & \bbnum 0\\
Q^{B,B} & \bbnum 0 & f^{\downarrow Q^{\bullet,B}}
\end{array}\,\quad\text{ then}\\
 & x\triangleright\,\begin{array}{|c||cc|}
 & R^{A,A} & S^{A,A}\\
\hline P^{A,A} & u & \bbnum 0\\
Q^{A,A} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline R^{A,A} & f^{\uparrow R^{A,\bullet}} & \bbnum 0\\
S^{A,A} & \bbnum 0 & f^{\uparrow S^{A,\bullet}}
\end{array}\,=y\triangleright\,\begin{array}{|c||cc|}
 & R^{B,B} & S^{B,B}\\
\hline P^{B,B} & u & \bbnum 0\\
Q^{B,B} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline R^{B,B} & f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
S^{B,B} & \bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}
\end{align*}
or, simplifying the matrix composition:
\[
x\triangleright\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline P^{A,A} & u\bef f^{\uparrow R^{A,\bullet}} & \bbnum 0\\
Q^{A,A} & \bbnum 0 & v\bef f^{\uparrow S^{A,\bullet}}
\end{array}\,=y\triangleright\,\begin{array}{|c||cc|}
 & R^{A,B} & S^{A,B}\\
\hline P^{B,B} & u\bef f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
Q^{B,B} & \bbnum 0 & v\bef f^{\downarrow S^{\bullet,B}}
\end{array}\quad.
\]
The precondition of the strong dinaturality law of $t$ is an equality
between values of disjunctive type $P^{A,B}+Q^{A,B}$ computed by
applying some diagonal code matrices to $x$ and $y$. So, the precondition
can hold only if both $x$ and $y$ are in the same part of the disjunction.
We must have either $x=p_{1}^{:P^{A,A}}+\bbnum 0$ and $y=p_{2}^{:P^{B,B}}+\bbnum 0$,
or $x=\bbnum 0+q_{1}^{:Q^{A,A}}$ and $y=\bbnum 0+q_{2}^{:Q^{B,B}}$.
In the first case, we can simplify the strong dinaturality law of
$t$ to:
\[
\text{when }\quad p_{1}^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=p_{2}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then }\quad p_{1}\triangleright u\bef f^{\uparrow R^{A,\bullet}}=p_{2}\triangleright u\bef f^{\downarrow R^{\bullet,B}}\quad,
\]
and in the second case to:
\[
\text{when }\quad q_{1}^{:P^{A,A}}\triangleright f^{\uparrow Q^{A,\bullet}}=q_{2}\triangleright f^{\downarrow Q^{\bullet,B}}\quad\text{ then }\quad q_{1}\triangleright v\bef f^{\uparrow S^{A,\bullet}}=q_{2}\triangleright v\bef f^{\downarrow S^{\bullet,B}}\quad.
\]
These are exactly the statements of the strong dinaturality laws of
$u$ and $v$. $\square$

\subsubsection{Statement \label{subsec:Statement-strongly-dinatural-product-of-functions-1}\ref{subsec:Statement-strongly-dinatural-product-of-functions-1}}

\textbf{(a)} If both $u:P^{A,A}\rightarrow Q^{A,A}$ and $v:P^{A,A}\rightarrow R^{A,A}$
are strongly dinatural then:
\[
t:P^{A,A}\rightarrow Q^{A,A}\times R^{A,A}\quad,\quad\quad t\triangleq p^{:P^{A,A}}\rightarrow u(p)\times v(p)
\]
is also strongly dinatural. 

\textbf{(b)} If both $u:P^{A,A}\rightarrow R^{A,A}$ and $v:Q^{A,A}\rightarrow R^{A,A}$
are strongly dinatural then:
\[
t:P^{A,A}+Q^{A,A}\rightarrow R^{A,A}\quad,\quad\quad t\triangleq\,\begin{array}{|c||c|}
 & R^{A,A}\\
\hline P^{A,A} & u\\
Q^{A,A} & v
\end{array}
\]
is also strongly dinatural.

\subparagraph{Proof}

\textbf{(a)} The function $t$ can be expressed as:
\[
t=(p^{:P^{A,A}}\rightarrow p\times p)\bef\big(p^{:P^{A,A}}\times p^{:P^{A,A}}\rightarrow u(p)\times v(p)\big)=\Delta^{P^{A,A}}\bef(u\boxtimes v)\quad.
\]
Note that $\Delta^{A}:A\rightarrow A\times A$ is a natural transformation
(see Section~\ref{subsec:Deriving-laws-for-functions-}). By Statement~\ref{subsec:Statement-strong-dinatural-substitute-functor-in-natural-1},
setting the type parameter of $\Delta$ to $P^{A,A}$ yields a strongly
dinatural transformation ($\Delta^{P^{A,A}}$). The pair product $u\boxtimes v$
is strongly dinatural by Statement~\ref{subsec:Statement-pair-product-coproduct-dinatural}(a).
Finally, the composition $\Delta\bef(u\boxtimes v)$ is strongly dinatural
by Statement~\ref{subsec:Statement-strongly-dinatural-transformation-composition-1}.

\textbf{(b)} The function $t$ can be expressed via the natural transformation
\lstinline!merge! (see Section~\ref{subsec:Working-with-disjunctive-functions}):
\[
t=\,\begin{array}{|c||cc|}
 & R^{A,A} & R^{A,A}\\
\hline P^{A,A} & u & \bbnum 0\\
Q^{A,A} & \bbnum 0 & v
\end{array}\,\bef\,\begin{array}{|c||c|}
 & R^{A,A}\\
\hline R^{A,A} & \text{id}\\
R^{A,A} & \text{id}
\end{array}\,=(u\boxplus v)\bef\text{merge}^{R^{A,A}}\quad.
\]
The pair co-product ($u\boxplus v$) is strongly dinatural by Statement~\ref{subsec:Statement-pair-product-coproduct-dinatural}(b).
The function \lstinline!merge! with a substituted type parameter
($R^{A,A}$) is strongly dinatural by Statement~\ref{subsec:Statement-strong-dinatural-substitute-functor-in-natural-1}.
Finally, the composition $(u\boxplus v)\bef\text{merge}$ is strongly
dinatural by Statement~\ref{subsec:Statement-strongly-dinatural-transformation-composition-1}.
$\square$

\subsubsection{Statement \label{subsec:Statement-strong-dinaturality-of-function-application-1}\ref{subsec:Statement-strong-dinaturality-of-function-application-1}}

Consider the (fully parametric) function $w\triangleq q\times z\rightarrow q(z)$.

\textbf{(a)} The most general type signature for $w$ is $w^{Q,Z}:(Z\rightarrow Q)\times Z\rightarrow Q$
with two type parameters ($Q$, $Z$). With this type signature, $w$
is strongly dinatural with respect to both $Q$ and $Z$.

\textbf{(b)} If we substitute the types $Q^{A,A}$ and $Z^{A,A}$
instead of $Q$ and $Z$, where $Q^{X,Y}$ and $Z^{X,Y}$ are some
profunctors obeying their commutativity laws, we obtain the function:
\[
w:\forall A.\,(Z^{A,A}\rightarrow Q^{A,A})\times Z^{A,A}\rightarrow Q^{A,A}\quad,\quad\quad w^{A}\triangleq q^{:Z^{A,A}\rightarrow Q^{A,A}}\times z^{:Z^{A,A}}\rightarrow q(z)\quad.
\]
The function $w$ is a dinatural transformation.

\textbf{(c)} Under the same assumptions as in \textbf{(b)}, the function
$w$ is strongly dinatural if the profunctor$Z^{X,Y}$ has the \textsf{``}pushout
property\textsf{''} (see Definition~\ref{subsec:Definition-profunctor-pushout-property}).
\begin{comment}
Otherwise, $w$ is \emph{not} necessarily strongly dinatural. \textemdash{}
not clear if we can show a counterexample
\end{comment}


\subparagraph{Proof}

\textbf{(a)} The type signature $\forall(Q,Z).\,(Z\rightarrow Q)\times Z\rightarrow Q$
has the form of a natural transformation with respect to the parameter
$Q$ (but not with respect to $Z$). By Statement~\ref{subsec:Statement-strong-dinaturality-entails-dinaturality}(b),
strong dinaturality holds with respect to $Q$. 

The strong dinaturality law of $w$ with respect to $Z$ needs to
be checked directly. For convenience, define the profunctors $P^{X,Y}\triangleq(X\rightarrow Q)\times Y$
and $R^{X,Y}\triangleq Q$, so that $w$ has the type signature $P^{Z,Z}\rightarrow R^{Z,Z}$.
We need to prove that, for any $f^{:A\rightarrow B}$,
\[
\text{when}\quad x^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright w\triangleright f^{\uparrow R}\overset{?}{=}y\triangleright w\triangleright f^{\downarrow R}\quad.
\]
Since $R^{X,Y}$ is a constant profunctor, we have $f^{\uparrow R}=\text{id}$
and $f^{\downarrow R}=\text{id}$. Defining $g^{:A\rightarrow Q}\times a^{:A}\triangleq x^{:P^{A,A}}$
and $h^{:B\rightarrow Q}\times b^{:B}\triangleq y^{:P^{B,B}}$, and
using the liftings:
\[
f^{\uparrow P^{A,\bullet}}=\text{id}^{A\rightarrow Q}\boxtimes f\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=(g^{:B\rightarrow Q}\rightarrow f\bef g)\boxtimes\text{id}^{B}\quad,
\]
we can rewrite the law as:
\[
\text{when}\quad g^{:A\rightarrow Q}\times f(a^{:A})=(f\bef h^{:B\rightarrow Q})\times b^{:B}\quad\text{ then}\quad g(a)\overset{?}{=}h(b)\quad.
\]
Since we must have $b=f(a)$ and $g=f\bef h$, the law holds:
\[
g(a)=h(f(a))=h(b).
\]

\textbf{(b)} Define the profunctor $P^{X,Y}\triangleq(Z^{Y,X}\rightarrow Q^{X,Y})\times Z^{X,Y}$
(note the reverse order of type parameters in $Z^{Y,X}$). Then $w^{A}$
has type signature $P^{A,A}\rightarrow Q^{A,A}$, and the corresponding
dinaturality law is:
\[
f^{\downarrow P}\bef w\bef f^{\uparrow Q}\overset{?}{=}f^{\uparrow P}\bef w\bef f^{\downarrow Q}\quad.
\]
It helps to write out the code for the liftings to $P$. For arbitrary
$f^{:A\rightarrow B}$:
\begin{align*}
 & (g^{:Z^{Y,B}\rightarrow Q^{B,Y}}\times a^{:Z^{B,Y}})\triangleright f^{\downarrow P^{\bullet,Y}}=\big(f^{\uparrow Z^{Y,\bullet}}\bef g\bef f^{\downarrow Q^{\bullet,Y}}\big)\times(a\triangleright f^{\downarrow Z^{\bullet,Y}})\quad,\\
 & (g^{:Z^{A,X}\rightarrow Q^{X,A}}\times a^{:Z^{X,A}})\triangleright f^{\uparrow P^{X,\bullet}}=\big(f^{\downarrow Z^{\bullet,X}}\bef g\bef f^{\uparrow Q^{X,\bullet}}\big)\times(a\triangleright f^{\uparrow Z^{X,\bullet}})\quad.
\end{align*}

The naturality law of $w$ is written as an equation between functions
of type $P^{B,A}\rightarrow Q^{A,B}$:
\[
f^{\downarrow P^{\bullet,A}}\bef w^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{?}{=}f^{\uparrow P^{B,\bullet}}\bef w^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\]
Apply both sides of the law to an arbitrary value $g\times a:P^{B,A}$:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (g^{:Z^{A,B}\rightarrow Q^{B,A}}\times a^{:Z^{B,A}})\,\gunderline{\triangleright f^{\downarrow P}}\bef w\bef f^{\uparrow Q}=\big((f^{\uparrow Z}\bef g\bef f^{\downarrow Q})\times(a\triangleright f^{\downarrow Z})\big)\triangleright w\triangleright f^{\uparrow Q}\\
{\color{greenunder}\text{definition of }w:}\quad & \quad=(a\triangleright f^{\downarrow Z})\triangleright(f^{\uparrow Z}\bef g\bef f^{\downarrow Q})\triangleright f^{\uparrow Q}=a\triangleright f^{\downarrow Z}\bef f^{\uparrow Z}\bef g\bef f^{\downarrow Q}\bef f^{\uparrow Q}\\
{\color{greenunder}\text{right-hand side}:}\quad & \overset{?}{=}(g\times a)\,\gunderline{\triangleright f^{\uparrow P}}\bef w\bef f^{\downarrow Q}=\big((f^{\downarrow Z}\bef g\bef f^{\uparrow Q})\times(a\triangleright f^{\uparrow Z})\big)\triangleright w\triangleright f^{\downarrow Q}\\
{\color{greenunder}\text{definition of }w:}\quad & \quad=(a\triangleright f^{\uparrow Z})\triangleright(f^{\downarrow Z}\bef g\bef f^{\uparrow Q})\triangleright f^{\downarrow Q}=a\triangleright f^{\uparrow Z}\bef f^{\downarrow Z}\bef g\bef f^{\uparrow Q}\bef f^{\downarrow Q}\quad.
\end{align*}
The remaining difference between two sides disappears due to the commutativity
laws of $Q$ and $Z$ (namely $f^{\uparrow Q}\bef f^{\downarrow Q}=f^{\downarrow Q}\bef f^{\uparrow Q}$
and $f^{\uparrow Z}\bef f^{\downarrow Z}=f^{\downarrow Z}\bef f^{\uparrow Z}$).

\textbf{(c)} The strong dinaturality of $w$ says that, for arbitrary
$f^{:A\rightarrow B}$,
\[
\text{when}\quad x^{:G^{A,A}\times Z^{A,A}}\triangleright f^{\uparrow(G\times Z)}=y^{:G^{B,B}\times Z^{B,B}}\triangleright f^{\downarrow(G\times Z)}\quad\text{ then}\quad x\triangleright w\triangleright f^{\uparrow Q}\overset{?}{=}y\triangleright w\triangleright f^{\downarrow Q}\quad.
\]
Since $f^{\uparrow(G\times Z)}=f^{\uparrow G}\boxtimes f^{\uparrow Z}$,
the precondition of the law splits into two equations:
\begin{align*}
{\color{greenunder}\text{defining }g_{1},z_{1},g_{2},z_{2}:}\quad & g_{1}^{:G^{A,A}}\times z_{1}^{:Z^{A,A}}\triangleq x\quad,\quad\quad g_{2}^{:G^{B,B}}\times z_{2}^{:Z^{B,B}}\triangleq y\quad,\\
{\color{greenunder}\text{the precondition is equivalent to}:}\quad & g_{1}\triangleright f^{\uparrow G}=g_{2}\triangleright f^{\downarrow G}\quad\text{ and }\quad z_{1}\triangleright f^{\uparrow Z}=z_{2}\triangleright f^{\downarrow Z}\quad.
\end{align*}
The precondition $g_{1}\triangleright f^{\uparrow G}=g_{2}\triangleright f^{\downarrow G}$
is equivalent to:
\begin{equation}
f^{\downarrow Z}\bef g_{1}\bef f^{\uparrow Q}=f^{\uparrow Z}\bef g_{2}\bef f^{\downarrow Q}\quad.\label{eq:strong-dinaturality-precondition-derivation1-1}
\end{equation}
Now we express the conclusion of the law via the new variables:
\begin{equation}
x\triangleright w\triangleright f^{\uparrow Q}=z_{1}\triangleright g_{1}\bef f^{\uparrow Q}\overset{?}{=}y\triangleright w\triangleright f^{\downarrow Q}=z_{2}\triangleright g_{2}\bef f^{\downarrow Q}\quad.\label{eq:strong-dinaturality-conclusion-derivation1-1}
\end{equation}
From here, the proof cannot proceed without more information. We need
to show that $z_{1}\triangleright g_{1}\bef f^{\uparrow Q}\overset{?}{=}z_{2}\triangleright g_{2}\bef f^{\downarrow Q}$,
but we do not have any equations relating $g_{1}\bef f^{\uparrow Q}$
to $g_{2}\bef f^{\downarrow Q}$. We cannot use Eq.~(\ref{eq:strong-dinaturality-precondition-derivation1-1})
because it contains additional lifted functions $f^{\downarrow Z}$
and $f^{\uparrow Z}$ that we cannot insert into the law~(\ref{eq:strong-dinaturality-conclusion-derivation1-1}),
given that $z_{1}$ and $z_{2}$ are unknown. 

If the profunctor $Z$ has the pushout property, the $\left(Z,f\right)$-wedge
relation $z_{1}\triangleright f^{\uparrow Z}=z_{2}\triangleright f^{\downarrow Z}$
gives us a value $u^{:Z^{B,A}}$ such that $z_{1}=u\triangleright f^{\downarrow Z}$
and $z_{2}=u\triangleright f^{\uparrow Z}$. Then the law~(\ref{eq:strong-dinaturality-conclusion-derivation1-1})
becomes:
\[
z_{1}\triangleright g_{1}\bef f^{\uparrow Q}=u\triangleright f^{\downarrow Z}\bef g_{1}\bef f^{\uparrow Q}\overset{?}{=}z_{2}\triangleright g_{2}\bef f^{\downarrow Q}=u\triangleright f^{\uparrow Z}\bef g_{2}\bef f^{\downarrow Q}\quad.
\]
Both sides are now equal due to Eq.~(\ref{eq:strong-dinaturality-precondition-derivation1-1}).
$\square$

Let us look at some examples of profunctors to see which ones have
the pushout property.

\subsubsection{Example \label{subsec:Example-weak-pullback-property-1}\ref{subsec:Example-weak-pullback-property-1}}

\textbf{(a)} Suppose a profunctor $P^{X,Y}$ does not depend on the
type parameter $X$ (so, $P^{X,Y}\triangleq G^{Y}$ with some functor
$G$). Then $P$ has the pushout property. 

\textbf{(b)} The pushout property holds for profunctors $P^{X,Y}\triangleq H^{X}$,
where $H$ is a contrafunctor.

\subparagraph{Proof}

\textbf{(a)} With the choice $P^{X,Y}\triangleq G^{Y}$, we have the
liftings $f^{\uparrow P}=f^{\uparrow G}$ and $f^{\downarrow P}=f$.
The pushout property of $P^{X,Y}$ says that, for any $f^{:A\rightarrow B}$,
$x^{:G^{A}}$, $y^{:G^{B}}$:
\[
\text{when}\quad x\triangleright f^{\uparrow G}=y\quad\text{ then }\quad\exists p^{:G^{A}}\text{ such that }x=p\text{ and }y=p\triangleright f^{\uparrow G}\quad.
\]
This property is satisfied by choosing $p\triangleq x$.

\textbf{(b)} With the choice $P^{X,Y}\triangleq H^{X}$, we have the
liftings $f^{\uparrow P}=f$ and $f^{\downarrow P}=f^{\downarrow H}$.
The pushout property of $P^{X,Y}$ says that, for any $f^{:A\rightarrow B}$,
$x^{:H^{A}}$, $y^{:H^{B}}$:
\[
\text{when}\quad x=y\triangleright f^{\downarrow H}\quad\text{ then }\quad\exists p^{:H^{A}}\text{ such that }x=p\triangleright f^{\downarrow H}\text{ and }y=p\quad.
\]
This property is satisfied by choosing $p\triangleq y$.

\subsubsection{Example \label{subsec:Example-weak-pullback-property}\ref{subsec:Example-weak-pullback-property}}

The profunctor $P^{X,Y}\triangleq X\rightarrow Y$ does \emph{not}
have the pushout property.

\subparagraph{Proof}

With $P^{X,Y}\triangleq X\rightarrow Y$, we rewrite the $\left(P,f\right)$-wedge
relation ($x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$)
for arbitrary $f^{:A\rightarrow B}$, $x^{:A\rightarrow A}$, and
$y^{:B\rightarrow B}$ as:
\[
x\bef f=f\bef y\quad.
\]
The pushout property requires us to find a value $p^{:B\rightarrow A}$
such that $x=f\bef p$ and $y=p\bef f$. Choose $f$ as a constant
function ($f\triangleq\_\rightarrow b_{0}$ with a fixed value $b_{0}^{:B}$).
The $\left(P,f\right)$-wedge relation applied to an arbitrary value
$a^{:A}$ gives:
\[
a\triangleright x\bef f=b_{0}\overset{!}{=}a\triangleright f\bef y=y(b_{0})\quad.
\]
So, the wedge relation will hold for any $x^{:A\rightarrow A}$ and
for any $y^{:B\rightarrow B}$ such that $y(b_{0})=b_{0}$. In particular,
$y$ is not necessarily a constant function. But the condition $y=p\bef f=\_\rightarrow b_{0}$
can be satisfied only if $y$ is a constant function. So, there exists
no suitable value $p^{:P^{B,A}}$. $\square$

Structural analysis allows us to discover profunctors that have the
pushout property:

\subsubsection{Statement \label{subsec:Statement-weak-pullback-property}\ref{subsec:Statement-weak-pullback-property}}

A profunctor $P^{X,Y}$ has the pushout property if:

\textbf{(a)} $P^{X,Y}\triangleq F^{Y}$ with some (covariant) functor
$F$.

\textbf{(b)} $P^{X,Y}\triangleq G^{X}$ with some contrafunctor $G$.

\textbf{(c)} $P^{X,Y}\triangleq Z\rightarrow Q^{X,Y}$ with a fixed
type $Z$ and a profunctor $Q$ that has the pushout property.

\textbf{(d)} $P^{X,Y}\triangleq Q^{X,Y}\times R^{X,Y}$ with profunctors
$Q$ and $R$ that both have the pushout property.

\textbf{(e)} $P^{X,Y}\triangleq Q^{X,Y}+R^{X,Y}$ with profunctors
$Q$ and $R$ that both have the pushout property.

\subparagraph{Proof}

Consider some values $f^{:A\rightarrow B}$, $x^{:P^{A,A}}$, and
$y^{:P^{B,B}}$, for which the $\left(P,f\right)$-wedge relation
holds:
\[
x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad.
\]

\textbf{(a)} If $P^{X,Y}=F^{Y}$ with a functor $F$, the wedge relation
is simplified to $x\triangleright f^{\uparrow F}=y$ with $x^{:F^{A}}$
and $y^{:F^{B}}$. We need to find $p^{:F^{A}}$ such that $x=p$
and $y=x\triangleright f^{\uparrow F}$. So, we define $p\triangleq x$
and complete the commuting square.

\textbf{(b)} If $P^{X,Y}=G^{X}$ with a contrafunctor $G$, the wedge
relation is simplified to $x=y\triangleright f^{\downarrow G}$ with
$x^{:G^{A}}$ and $y^{:G^{B}}$. We need to find $p^{:G^{B}}$ such
that $x=p\triangleright f^{\downarrow G}$ and $y=p$. So, we define
$p\triangleq y$ and complete the commuting square.

\textbf{(c)} Write the $\left(P,f\right)$-wedge relation for $x^{:Z\rightarrow Q^{A,A}}$
and $y^{:Z\rightarrow Q^{B,B}}$, applied to an arbitrary $z^{:Z}$:
\[
z\triangleright x\triangleright f^{\uparrow Q^{A,\bullet}}=z\triangleright y\triangleright f^{\downarrow Q^{\bullet,B}}\quad.
\]
Note that this is the same as the $\left(Q,f\right)$-wedge relation
for the values $z\triangleright x$ and $z\triangleright y$. By assumption,
$Q^{X,Y}$ has the pushout property. So, we may apply that property
to $z\triangleright x$ and $z\triangleright y$ and obtain a value
$q^{:Q^{B,A}}$ that satisfies the following two equations:
\begin{equation}
q\triangleright f^{\uparrow Q^{B,\bullet}}=z\triangleright y\quad,\quad\quad q\triangleright f^{\downarrow Q^{\bullet,A}}=z\triangleright x\quad.\label{eq:weak-pullback-c-derivation1}
\end{equation}
We need to find $p^{:Z\rightarrow Q^{B,A}}$ such that $x=p\bef f^{\downarrow Q^{\bullet,A}}$
and $y=p\bef f^{\uparrow Q^{B,\bullet}}$. These equations are the
same as Eq.~(\ref{eq:weak-pullback-c-derivation1}) if we define
$p(z)\triangleq q$. We have found a value $p$ that completes the
square diagram.

\textbf{(d)} Write the wedge relation for $x^{:Q^{A,A}\times R^{A,A}}=x_{1}^{:Q^{A,A}}\times x_{2}^{:R^{A,A}}$
and $y^{:Q^{B,B}\times R^{B,B}}=y_{1}^{:Q^{B,B}}\times y_{2}^{:R^{B,B}}$
as:
\[
(x_{1}\times x_{2})\triangleright f^{\uparrow(Q\times R)}=(x_{1}\triangleright f^{\uparrow Q})\times(x_{2}\triangleright f^{\uparrow R})\overset{!}{=}(y_{1}\times y_{2})\triangleright f^{\downarrow(Q\times R)}=(y_{1}\triangleright f^{\downarrow Q})\times(y_{2}\triangleright f^{\downarrow R})\quad.
\]
This equation is equivalent to the two equations:
\[
x_{1}\triangleright f^{\uparrow Q}\overset{!}{=}y_{1}\triangleright f^{\downarrow Q}\quad\text{ and }\quad x_{2}\triangleright f^{\uparrow R}\overset{!}{=}y_{2}\triangleright f^{\downarrow R}\quad,
\]
which are the $\left(Q,f\right)$- and $\left(R,f\right)$-wedge relations.
By assumption, $Q$ and $R$ have the pushout property. So, we may
compute values $p_{1}^{:Q^{B,A}}$ and $p_{2}^{:R^{B,A}}$ such that:
\[
p_{1}\triangleright f^{\downarrow Q}=x_{1}\quad,\quad\quad p_{1}\triangleright f^{\uparrow Q}=y_{1}\quad,\quad\quad p_{2}\triangleright f^{\downarrow R}=x_{2}\quad,\quad\quad p_{2}\triangleright f^{\uparrow R}=y_{2}\quad.
\]
If we define $p\triangleq p_{1}\times p_{2}$, we complete the square
diagram for $\left(Q\times R,f\right)$-wedge relation because:
\[
p\triangleright f^{\downarrow(Q\times R)}=(p_{1}\triangleright f^{\downarrow Q})\times(p_{2}\triangleright f^{\downarrow R})=x_{1}\times x_{2}\quad,\quad\quad p\triangleright f^{\uparrow(Q\times R)}=(p_{1}\triangleright f^{\uparrow Q})\times(p_{2}\triangleright f^{\uparrow R})=y_{1}\times y_{2}\quad.
\]

\textbf{(e)} Write the wedge relation for $x^{:Q^{A,A}+R^{A,A}}$
and $y^{:Q^{B,B}+R^{B,B}}$ as:
\[
x\triangleright\,\begin{array}{|c||cc|}
 & Q^{A,B} & R^{A,B}\\
\hline Q^{A,A} & f^{\uparrow Q^{A,\bullet}} & \bbnum 0\\
R^{A,A} & \bbnum 0 & f^{\uparrow R^{A,\bullet}}
\end{array}\,=y\triangleright\,\begin{array}{|c||cc|}
 & Q^{A,B} & R^{A,B}\\
\hline Q^{B,B} & f^{\downarrow Q^{\bullet,B}} & \bbnum 0\\
R^{B,B} & \bbnum 0 & f^{\downarrow R^{\bullet,B}}
\end{array}\quad.
\]
This equation can be satisfied only if both sides are either of type
$Q^{A,B}+\bbnum 0$ or of type $\bbnum 0+R^{A,B}$. Since the lifting
matrices are diagonal, this can happen only if $x$ has type $Q^{A,A}+\bbnum 0$
and $y$ has type $Q^{B,B}+\bbnum 0$, of if $x$ has type $\bbnum 0+R^{A,A}$
and $y$ has type $\bbnum 0+R^{B,B}$. In the first case, the property
becomes equivalent to that of the profunctor $Q$; in the second case,
to that of the profunctor $R$.

To see this in detail, consider two cases: $x\triangleq x_{1}^{:Q^{A,A}}+\bbnum 0$
and $x\triangleq\bbnum 0+x_{2}^{:R^{A,A}}$. In the first case, $x\triangleright f^{\uparrow P}=(x_{1}\triangleright f^{\uparrow Q})+\bbnum 0$.
This can be equal to $y\triangleright f^{\downarrow P}$ only if $y\triangleright f^{\downarrow P}$
is in the left part of the disjunction type $Q^{A,B}+R^{A,B}$. This
happens only when $y=y_{1}^{:Q^{B,B}}+\bbnum 0$ with some $y_{1}$.
So, the $\left(P,f\right)$-wedge relation implies $x_{1}\triangleright f^{\uparrow Q}=y_{1}\triangleright f^{\downarrow Q}$.
This is the $\left(Q,f\right)$-wedge relation for $(x_{1},y_{1})$.
By assumption, $Q$ has the pushout property. So, we can compute some
$p_{1}^{:Q^{B,A}}$ such that $x_{1}=p_{1}\triangleright f^{\downarrow Q}$
and $y_{1}=p_{1}\triangleright f^{\uparrow Q}$. If we now define
$p\triangleq p_{1}+\bbnum 0$, we will have $p\triangleright f^{\downarrow P}=x$
and $p\triangleright f^{\uparrow P}=y$, so the pushout property of
$P$ holds.

The case $x\triangleq\bbnum 0+x_{2}^{:R^{A,A}}$ is proved similarly
by using the pushout property of $R$. %
\begin{comment}
\textbf{(f)} Rewrite the wedge relation for $x^{:S^{A,A,P^{A,A}}}$
and $y^{:S^{B,B,P^{B,B}}}$ by using the explicit liftings to $S$:
\[
x\triangleright f^{\uparrow S^{A,\bullet,P^{A,A}}}\bef\big(\overline{f^{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,B,\bullet}}=y\triangleright f^{\downarrow S^{\bullet,B,P^{B,B}}}\bef\big(\overline{f^{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\quad.
\]
Due to the commutativity law of $S$, we may exchange the order of
compositions here:
\[
f^{\uparrow S^{A,\bullet,P^{A,B}}}\big(x\triangleright(f^{\uparrow P^{A,\bullet}})^{\uparrow S^{A,A,\bullet}}\big)=y\triangleright\big(\overline{f^{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{B,B,\bullet}}\triangleright f^{\downarrow S^{\bullet,B,P^{A,B}}}\quad.
\]
Now we can use the pushout property of $S$ to obtain some $z:S^{B,A,P^{A,B}}$
such that:
\[
x\triangleright\big(\overline{f^{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,A,\bullet}}=z\triangleright f^{\downarrow S^{\bullet,A,P^{A,B}}}\text{ and }y\triangleright\big(\overline{f^{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{B,B,\bullet}}=z\triangleright f^{\uparrow S^{B,\bullet,P^{A,B}}}\quad.
\]
We need to produce a value $t:S^{B,A,P^{B,A}}$ such that: 
\[
x=t\triangleright f^{\downarrow S^{\bullet,A,P^{B,A}}}\bef\big(\overline{f^{\downarrow P^{\bullet,A}}}\big)^{\uparrow S^{A,A,\bullet}}\text{ and }y=t\triangleright f^{\uparrow S^{B,\bullet,P^{B,A}}}\bef\big(\overline{f^{\uparrow P^{B,\bullet}}}\big)^{\uparrow S^{B,B,\bullet}}\quad.
\]
\end{comment}
$\square$

The list of constructions in Statement~\ref{subsec:Statement-weak-pullback-property}
does not include the recursive type construction. It remains an open
question whether, say, a suitably limited form of the recursive type
construction would produce new profunctors having the pushout property.

However, profunctors $P$ with the pushout property are not the only
ones that produce strongly dinatural transformations. This is because
the pushout property is too restrictive. It is sufficient if the lifted
relation $\left<f\right>^{\updownarrow P}$ is a \emph{consequence}
of the $\left(P,f\right)$-wedge relation. We call this the \textsf{``}post-wedge\textsf{''}
property\index{profunctor!post-wedge property} of the profunctor
$P$.

Here and below, we will frequently need to use liftings $r^{\updownarrow T}$
to a type constructor $T$ defined by $T^{A}\triangleq P^{A,A}$ with
some profunctor $P^{X,Y}$. Statement~\ref{subsec:Statement-relational-lifting-consistency-PAA}
shows that $r^{\updownarrow T}=(r,r)^{\updownarrow P}$. So, we will
write the simultaneous lifting $(r,r)^{\updownarrow P}$ simply as
$r^{\updownarrow P}$ when this does not cause confusion.

\subsubsection{Definition \label{subsec:Definition-pre-post-wedge-property}\ref{subsec:Definition-pre-post-wedge-property}}

A profunctor $P$ has the \textbf{post-wedge property} if for any
$f^{:A\rightarrow B}$, $x^{:P^{A,A}}$, and $y^{:P^{B,B}}$:
\[
\text{if }\quad x\triangleright f^{\uparrow P}=x\triangleright f^{\downarrow P}\quad\text{ then }\quad(x,y)\in\left<f\right>^{\updownarrow P}\quad.
\]
In other words, the lifted relation $\left<f\right>^{\updownarrow P}$
always follows from the $\left(P,f\right)$-wedge relation. $\square$

By Statement~\ref{subsec:Statement-wedge-law-from-parametricity}(a),
the $\left(P,f\right)$-wedge relation is always a consequence of
the lifted graph relation $\left<f\right>^{\updownarrow P}$. So,
the post-wedge property of $P$ means that $\left<f\right>^{\updownarrow P}$
is \emph{equivalent} to the $\left(P,f\right)$-wedge relation.

\subsubsection{Statement \label{subsec:Statement-post-wedge-entails-strong-dinaturality}\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}}

If $P$ is a profunctor with the post-wedge property and $Q$ is any
profunctor then any fully parametric function $t:\forall A.\,P^{A,A}\rightarrow Q^{A,A}$
is strongly dinatural.

\subparagraph{Proof}

The post-wedge property of $P$ means:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(x,y)\in\left<f\right>^{\updownarrow P}\quad.
\]
Since $t$ is fully parametric, it satisfies the relational naturality
law:
\[
\text{if}\quad(x,y)\in\left<f\right>^{\updownarrow P}\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\left<f\right>^{\updownarrow Q}\quad.
\]
By Statement~\ref{subsec:Statement-wedge-law-from-parametricity}(a),
the wedge law follows from the relational naturality law of $t$:
\[
\text{if}\quad(t^{A}(x),t^{B}(y))\in\left<f\right>^{\updownarrow Q}\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
Chaining the implications, we find:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
This is the strong dinaturality law of $t$. $\square$

We will now do structural analysis to describe the profunctors with
the post-wedge property.\footnote{The following derivations are based on the talk slides: \texttt{\href{https://www.ioc.ee/~tarmo/tday-voore/vene-slides.pdf}{https://www.ioc.ee/$\sim$tarmo/tday-voore/vene-slides.pdf}}} 

\subsubsection{Statement \label{subsec:Statement-post-wedge}\ref{subsec:Statement-post-wedge}}

A profunctor $P$ will have the post-wedge property if:

\textbf{(a)} The type expression $P^{X,Y}$ does not depend either
on $X$ or on $Y$. That is, either $P^{X,Y}\triangleq Q^{Y}$ where
$Q$ is a functor or $P^{X,Y}\triangleq R^{X}$ where $R$ is a contrafunctor. 

\textbf{(b)} We have $P^{X,Y}\triangleq K^{X,Y}\times L^{X,Y}$, where
the profunctors $K$ and $L$ have the post-wedge property.

\textbf{(c)} We have $P^{X,Y}\triangleq K^{X,Y}+L^{X,Y}$, where the
profunctors $K$ and $L$ have the post-wedge property.

\textbf{(d)} We have $P^{X,Y}\triangleq K^{Y,X}\rightarrow L^{X,Y}$,
where the profunctor $K$ has the pushout property and the profunctor
$L$ has the post-wedge property.%
\begin{comment}
\textbf{(e)} We have a recursive type $P^{X,Y}\triangleq S^{X,Y,P^{X,Y}}$,
where $S^{X,Y,R}$ is contravariant in $X$ and covariant in $Y$
and $R$, and has the post-wedge property when viewed as a profunctor
with respect to $X$ and $Y$. Does the post-wedge really hold for
$P$?
\end{comment}


\subparagraph{Proof}

In each case, assuming the $\left(P,f\right)$-wedge relation for
$(x,y)$, we will show that $(x,y)\in\left<f\right>^{\updownarrow P}$. 

\textbf{(a)} If $P^{X,Y}$ does not depend on one of its type parameters
then we have either $P^{X,Y}\triangleq Q^{Y}$ or $P^{X,Y}\triangleq R^{X}$.
We know from Statement~\ref{subsec:Statement-weak-pullback-property}(a,
b) that $P$ will then have the pushout property. So, if any values
$x$ and $y$ are in the $\left(P,f\right)$-wedge relation then $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$.
By Statement~\ref{subsec:Statement-profunctor-pushout-entails-lifted-f},
we will also have $(x,y)\in\left<f\right>^{\uparrow P}$.

\textbf{(b)} We need to show that $P$ has the post-wedge property:
\[
\text{if }\quad(k_{1}^{:K^{A,A}}\times l_{1}^{:L^{A,A}})\triangleright f^{\uparrow P}=(k_{2}^{:K^{B,B}}\times l_{2}^{:L^{B,B}})\triangleright f^{\downarrow P}\quad\text{ then }\quad(k_{1}\times l_{1},k_{2}\times l_{2})\in\left<f\right>^{\updownarrow P}\quad.
\]
Using the definitions of the liftings $^{\updownarrow P}$, $^{\uparrow P}$,
and $^{\downarrow P}$, we rewrite the above condition as:
\[
\text{if }\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\text{ and }l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright f^{\downarrow L}\quad\text{ then }\quad(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\text{ and }(l_{1},l_{2})\in\left<f\right>^{\updownarrow L}\quad.
\]
This is the same as the conjunction of the post-wedge properties of
$K$ and $L$. 

\textbf{(c)} We need to show that $P$ has the post-wedge property:
\[
\text{if }\quad p_{1}^{:K^{A,A}+L^{A,A}}\triangleright f^{\uparrow P}=p_{2}^{:K^{B,B}+L^{B,B}}\triangleright f^{\downarrow P}\quad\text{ then }\quad(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}\quad.
\]
The liftings $f^{\uparrow P}$ and $f^{\downarrow P}$ are defined
via the standard pattern-matching code for disjunctive types:
\[
f^{\uparrow P^{A,\bullet}}\triangleq\,\begin{array}{|c||cc|}
 & K^{A,B} & L^{A,B}\\
\hline K^{A,A} & f^{\uparrow K^{A,\bullet}} & \bbnum 0\\
L^{A,A} & \bbnum 0 & f^{\uparrow L^{A,\bullet}}
\end{array}\quad,\quad\quad f^{\downarrow P^{\bullet,B}}\triangleq\,\begin{array}{|c||cc|}
 & K^{A,B} & L^{A,B}\\
\hline K^{B,B} & f^{\downarrow K^{\bullet,B}} & \bbnum 0\\
L^{B,B} & \bbnum 0 & f^{\downarrow L^{\bullet,B}}
\end{array}\quad.
\]
Since both code matrices are diagonal, the two parts of the disjunctive
type $K+L$ do not mix. It follows that $p_{1}\triangleright f^{\uparrow P}=p_{2}\triangleright f^{\downarrow P}$
only if both $p_{1}$ and $p_{2}$ are in the same part of the disjunction
$K+L$. If both $p_{1}$ and $p_{2}$ are in the left part of the
disjunction, we have $p_{1}\triangleq k_{1}^{:K^{A,A}}+\bbnum 0$
and $p_{2}\triangleq k_{2}^{:K^{B,B}}+\bbnum 0$, and the $\left(P,f\right)$-wedge
relation for $p_{1}$ and $p_{2}$ reduces to the $\left(K,f\right)$-wedge
relation for $k_{1}$ and $k_{2}$:
\[
k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\quad.
\]
By Definition~\ref{subsec:Definition-relational-lifting}(d), the
values $p_{1}$ and $p_{2}$ will be in the relation $\left<f\right>^{\updownarrow P}$
only if $(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}$. Then the
post-wedge property of $P$ becomes:
\[
\text{if }\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\quad\text{ then }\quad(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\quad.
\]
This holds because it is just the post-wedge property of $K$. Similarly,
we prove that if both $p_{1}$ and $p_{2}$ are in the right part
of the disjunction then the post-wedge property of $P$ is reduced
to the post-wedge property of $L$.

\textbf{(d)} Express the $\left(P,f\right)$-wedge relation and the
relation $\left<f\right>^{\updownarrow P}$ for $(x,y)$ through liftings
to $K$ and $L$:
\begin{align}
 & x^{:K^{A,A}\rightarrow L^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:K^{B,B}\rightarrow L^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{or equivalently}:\quad f^{\downarrow K^{\bullet,A}}\bef x\bef f^{\uparrow L^{A,\bullet}}=f^{\uparrow K^{B,\bullet}}\bef y\bef f^{\downarrow L^{\bullet,B}}\quad,\label{eq:p-f-wedge-relation-x-y-derivation1}\\
 & (x^{:K^{A,A}\rightarrow L^{A,A}},y^{:K^{B,B}\rightarrow L^{B,B}})\in\left<f\right>^{\updownarrow P}\text{ means if }(k_{1}^{:K^{A,A}},k_{2}^{:K^{B,B}})\in\left<f\right>^{\updownarrow K}\text{ then }(x(k_{1}),y(k_{2}))\in\left<f\right>^{\updownarrow L}\quad.\nonumber 
\end{align}
Fix any $k_{1}^{:K^{A,A}}$ and $k_{2}^{:K^{B,B}}$ such that $(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}$.
We need to prove that $(x(k_{1}),y(k_{2}))\in\left<f\right>^{\updownarrow L}$
assuming Eq.~(\ref{eq:p-f-wedge-relation-x-y-derivation1}).

The pushout property of $K$ gives:
\[
\text{if }\quad k_{1}^{:K^{A,A}}\triangleright f^{\uparrow K}=k_{2}^{:K^{B,B}}\triangleright f^{\downarrow K}\quad\text{ then }\quad\exists k_{0}^{:K^{B,A}}\text{ such that }k_{1}=k_{0}\triangleright f^{\downarrow K^{\bullet,A}}\text{ and }k_{2}=k_{0}\triangleright f^{\uparrow K^{B,\bullet}}\quad.
\]
So, there exists a suitable value $k_{0}^{:K^{B,A}}$.%
\begin{comment}
By Statement~\ref{subsec:Statement-wedge-law-from-parametricity}(a),
the values $k_{1}$, $k_{2}$ are in the $\left(P,f\right)$-wedge
relation: $k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}$.
\end{comment}
{} Apply both sides of Eq.~(\ref{eq:p-f-wedge-relation-x-y-derivation1})
to that $k_{0}$:
\[
k_{0}\triangleright f^{\downarrow K^{\bullet,A}}\bef x\bef f^{\uparrow L^{A,\bullet}}=k_{0}\triangleright f^{\uparrow K^{B,\bullet}}\bef y\bef f^{\downarrow L^{\bullet,B}}\quad\text{or equivalently}:\quad k_{1}\triangleright x\triangleright f^{\uparrow L}=k_{2}\triangleright y\triangleright f^{\downarrow L}\quad.
\]
 It is also given that $L$ has the post-wedge property:
\[
\text{if }\quad l_{1}^{:L^{A,A}}\triangleright f^{\uparrow L}=l_{2}^{:L^{B,B}}\triangleright f^{\downarrow L}\quad\text{ then }\quad(l_{1},l_{2})\in\left<f\right>^{\updownarrow L}\quad.
\]
We now set $l_{1}\triangleq k_{1}\triangleright x$ and $l_{2}\triangleq k_{2}\triangleright y$
to obtain $(x(k_{1}),y(k_{2}))\in\left<f\right>^{\updownarrow L}$
as required. $\square$

As a consequence of Statement~\ref{subsec:Statement-post-wedge},
we can quickly prove (without structural analysis) that a function
graph relation lifted to functors or contrafunctors will yield another
function graph relation:

\subsubsection{Statement \label{subsec:Statement-lifting-function-relation-covariant-1}\ref{subsec:Statement-lifting-function-relation-covariant-1}}

Lifting a function $f^{:A\rightarrow B}$ to a fully parametric functor
or a contrafunctor $G$ agrees with lifting the function graph relation
$\left<f\right>$ to $G$. In detail: 

\textbf{(a)} $\left<f\right>^{\updownarrow G}=\langle f^{\uparrow G}\rangle$
if $G$ is a functor.

\textbf{(b)} $\left<f\right>^{\updownarrow G}=\text{rev}\langle f^{\downarrow G}\rangle$
if $G$ is a contrafunctor.

\subparagraph{Proof}

Whether $G$ is a functor or a contrafunctor, Statement~\ref{subsec:Statement-post-wedge}(a)
shows that it has the post-wedge property. So, the relation $(\left<f\right>,\left<f\right>)^{\updownarrow P}$
is \emph{equivalent} to the $\left(P,f\right)$-wedge relation:
\[
(x,y)\in(\left<f\right>,\left<f\right>)^{\updownarrow P}\quad\text{is equivalent to}:\quad x\triangleright f^{\uparrow P}=y\triangleright f^{\downarrow P}\quad.
\]

\textbf{(a)} If $G$ is a functor, define $P^{X,Y}\triangleq G^{Y}$.
Simplifying $(\left<f\right>,\left<f\right>)^{\updownarrow P}=\left<f\right>^{\updownarrow G}$
and using the liftings $f^{\uparrow P}=f^{\uparrow G}$ and $f^{\downarrow P}=\text{id}$,
we get:
\[
(x,y)\in\left<f\right>^{\updownarrow G}\quad\text{is equivalent to}:\quad x\triangleright f^{\uparrow G}=y\quad\text{or equivalently}:\quad(x,y)\in\langle f^{\uparrow G}\rangle\quad.
\]
So, we find $\left<f\right>^{\updownarrow G}=\langle f^{\uparrow G}\rangle$
as required.

\textbf{(b)} If $G$ is a contrafunctor, define $P^{X,Y}\triangleq G^{X}$.
Simplifying $(\left<f\right>,\left<f\right>)^{\updownarrow P}=\left<f\right>^{\updownarrow G}$
and using the liftings $f^{\uparrow P}=\text{id}$ and $f^{\downarrow P}=f^{\downarrow G}$,
we get:
\[
(x,y)\in\left<f\right>^{\updownarrow G}\quad\text{is equivalent to}:\quad x=y\triangleright f^{\downarrow G}\quad\text{or equivalently}:\quad(x,y)\in\text{rev}\langle f^{\downarrow G}\rangle\quad.
\]
 So, we find $\left<f\right>^{\updownarrow G}=\text{rev}\langle f^{\downarrow G}\rangle$
as required. $\square$

Strong dinaturality holds only for type signatures $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
where the profunctor $K$ has a certain structure. Nevertheless, a
broad range of practically encountered functions have type signatures
of that form. Here are some examples.

\subsubsection{Example \label{subsec:Example-strong-dinaturality-for-some-type-signatures}\ref{subsec:Example-strong-dinaturality-for-some-type-signatures}\index{examples}}

Let $F$ and $G$ be either a functor or a contrafunctor, independently
of each other, and let $L^{X,Y}$ be any profunctor. Use Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}
to show that strong dinaturality holds for all fully parametric functions
with the following type signatures:

\textbf{(a)} $\forall A.\,F^{A}\rightarrow L^{A,A}\quad.$\textbf{$\quad$(b)}
$\forall A.\,(F^{A}\rightarrow G^{A})\rightarrow L^{A,A}\quad.$

\subparagraph{Solution}

\textbf{(a)} We can represent the type signature as $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
with some profunctor $K$. Then we will need to consider two cases
where $F$ is either covariant or contravariant. If $F$ is covariant,
we define $K^{X,Y}\triangleq F^{Y}$. If $F$ is contravariant, we
define $K^{X,Y}\triangleq F^{X}$. In every case, $K$ depends on
only one of its type parameters. By Statement~\ref{subsec:Statement-post-wedge}(a),
$K$ will have the post-wedge property. Strong dinaturality will then
follow from Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}.

\textbf{(b)} The type signature $\forall A.\,(F^{A}\rightarrow G^{A})\rightarrow L^{A,A}$
needs to be expressed as $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
with some profunctor $K$. We define $K^{X,Y}\triangleq M^{Y,X}\rightarrow N^{X,Y}$
with suitably chosen profunctors $M$ and $N$. Reasoning as before,
we find that the profunctors $M$ and $N$ will depend only on one
of their type parameters. So, they will have the post-wedge property.
In addition, Example~\ref{subsec:Example-weak-pullback-property-1}(a)
shows that $M$ has the pushout property. The post-wedge property
of $K$ is then established via Statement~\ref{subsec:Statement-post-wedge}(d).
So, the profunctor $K$ satisfies the conditions of Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}.
$\square$

Example~\ref{subsec:Example-strong-dinaturality-for-some-type-signatures}(b)
is used in Statement~\ref{subsec:Statement-Church-encoding-recursive-type-covariant}
with the Church encoding of recursive types.

The following example is another illustration of using the laws of
strong dinaturality for deriving specific properties more directly
than via the general laws of relational parametricity.

\subsubsection{Example \label{subsec:Example-strong-dinaturality-show-void}\ref{subsec:Example-strong-dinaturality-show-void}}

\textbf{(a)} For any (covariant) functor $F$, show that the type
of fully parametric functions with type signature $\forall A.\,\left(A\rightarrow A\right)\rightarrow F^{A}$
is equivalent to the type $F^{\bbnum 0}$.

\textbf{(b)} For any contrafunctor $H$, show that the type of fully
parametric functions with type signature $\forall A.\,\left(A\rightarrow A\right)\rightarrow H^{A}$
is equivalent to the type $H^{\bbnum 1}$.

\subparagraph{Solution}

\textbf{(a)} We need to define a one-to-one correspondence between
all values of type $F^{\bbnum 0}$ and all fully parametric functions
of type $\forall A.\,\left(A\rightarrow A\right)\rightarrow F^{A}$.

Note that the Yoneda lemma does not apply to type signatures of that
form. The Yoneda identity:
\[
\forall A.\,\left(T\rightarrow A\right)\rightarrow F^{A}\cong F^{T}
\]
may be used only if the type $T$ is independent of the bound type
parameter $A$.

However, we can use that Yoneda identity with $T\triangleq\bbnum 0$
to obtain the type equivalence $F^{\bbnum 0}\cong\forall A.\,F^{A}$:
\[
\forall A.\,F^{A}\cong\forall A.\,\bbnum 1\rightarrow F^{A}\cong\forall A.\,(\bbnum 0\rightarrow A)\rightarrow F^{A}\cong F^{\bbnum 0}\quad.
\]

By Example~\ref{subsec:Example-strong-dinaturality-for-some-type-signatures}(c),
any fully parametric function $k$ of type $\forall A.\,\left(A\rightarrow A\right)\rightarrow F^{A}$
obeys the strong dinaturality law. That law gives for any types $A$,
$B$ and for any $f^{:A\rightarrow B}$, $p^{:A\rightarrow A}$, and
$q^{:B\rightarrow B}$:
\begin{equation}
\text{if}\quad p\bef f=f\bef q\quad\text{then}\quad k(p)\triangleright f^{\uparrow F}=k(q)\quad.\label{eq:strong-dinaturality-example-void-type}
\end{equation}
Choose $A\triangleq\bbnum 0$, $p\triangleq\text{id}^{:\bbnum 0\rightarrow\bbnum 0}$,
and $f\triangleq\text{absurd}^{:\bbnum 0\rightarrow B}$ (the function
\lstinline!absurd! is defined in Example~\ref{subsec:ch-Example-type-identity-0-to-A}).
Then the precondition of the law~(\ref{eq:strong-dinaturality-example-void-type})
is satisfied for arbitrary $q^{:B\rightarrow B}$. Indeed, both sides
of the precondition ($p\bef f=f\bef q$) are functions of type $\bbnum 0\rightarrow B$,
and there exists only one distinct function of that type (Example~\ref{subsec:ch-Example-type-identity-0-to-A}).
So, the conclusion of the law~(\ref{eq:strong-dinaturality-example-void-type})
holds for any $q$. It means that the value $k(q)$ must be independent
of $q$. In other words, any fully parametric function $k$ of type
$\forall A.\,\left(A\rightarrow A\right)\rightarrow F^{A}$ must ignore
its argument of type $A\rightarrow A$. By Example~\ref{subsec:ch-Example-type-identity-6-1},
functions of type $\left(A\rightarrow A\right)\rightarrow F^{A}$
that ignore their argument are equivalent to values of type $F^{A}$.
So, we obtain the type equivalence:
\[
\forall A.\,\left(A\rightarrow A\right)\rightarrow F^{A}\cong\forall A.\,(\_^{:A\rightarrow A}\rightarrow F^{A})\cong\forall A.\,F^{A}\cong F^{\bbnum 0}.
\]

\textbf{(b)} Any fully parametric function $k$ of type $\forall A.\,\left(A\rightarrow A\right)\rightarrow H^{A}$
obeys the strong dinaturality law:
\begin{equation}
\forall f^{:A\rightarrow B},p^{:A\rightarrow A},q^{:B\rightarrow B}:\quad\text{if}\quad p\bef f=f\bef q\quad\text{then}\quad k(p)=k(q)\triangleright f^{\downarrow H}\quad.\label{eq:strong-dinaturality-example-contrafunctor}
\end{equation}
Choose $B\triangleq\bbnum 1$, $q\triangleq\text{id}^{:\bbnum 1\rightarrow\bbnum 1}$,
and $f\triangleq\_^{:A}\rightarrow1$. Then the precondition of the
law~(\ref{eq:strong-dinaturality-example-contrafunctor}) is satisfied
for arbitrary $p^{:A\rightarrow A}$ (both sides of the precondition
are functions of type $\_^{:A}\rightarrow\bbnum 1$, and there exists
only one distinct function of that type). So, the conclusion of the
law~(\ref{eq:strong-dinaturality-example-contrafunctor}) holds for
any $p$. It means that $k(p)$ must be independent of $p$. In other
words, any fully parametric function $k$ of type $\forall A.\,\left(A\rightarrow A\right)\rightarrow H^{A}$
must ignore its argument of type $A\rightarrow A$. By Example~\ref{subsec:ch-Example-type-identity-6-1},
functions of type $\left(A\rightarrow A\right)\rightarrow H^{A}$
that ignore their argument are equivalent to values of type $H^{A}$.
So, we obtain the type equivalence:
\[
\forall A.\,\left(A\rightarrow A\right)\rightarrow H^{A}\cong\forall A.\,(\_^{:A\rightarrow A}\rightarrow H^{A})\cong\forall A.\,H^{A}\cong H^{\bbnum 1}.
\]
The last step is obtained via the contravariant Yoneda identity (Statement~\ref{subsec:Statement-contravariant-yoneda-identity-for-types}):
\[
\forall A.\,H^{A}\cong\forall A.\,\bbnum 1\rightarrow H^{A}\cong\forall A.\,(A\rightarrow\bbnum 1)\rightarrow H^{A}\cong H^{\bbnum 1}\quad.
\]


\subsection{Strong dinaturality of \texttt{foldFn}}

This section will show that the function \lstinline!foldFn! used
in Statement~\ref{subsec:Statement-foldleft-foldmap-equivalence}
is strongly dinatural. The type signature of \lstinline!foldFn!,
\[
\text{foldFn}_{L}:\forall B.\,L^{B\rightarrow B}\rightarrow B\rightarrow B\quad,
\]
is not immediately covered by Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}
because it contains the composition of an arbitrary functor $L$ and
a profunctor. To handle \lstinline!foldFn!, we will first need to
prove some additional properties.

\subsubsection{Statement \label{subsec:Statement-functor-post-pre-wedge}\ref{subsec:Statement-functor-post-pre-wedge}}

If $L$ is a polynomial functor and $K$ is a profunctor with the
post-wedge property then the profunctor $P^{X,Y}\triangleq L^{K^{X,Y}}$
also has the post-wedge property.

\subparagraph{Proof}

Assume any two values $x^{:L^{K^{A,A}}}$ and $y^{:L^{K^{B,B}}}$
that are in the $\left(P,f\right)$-wedge relation:
\[
(x,y)\in\text{pull}\,(f^{\uparrow K^{A,\bullet}\uparrow L},f^{\downarrow K^{\bullet,B}\uparrow L})\quad\text{or equivalently}:\quad x\triangleright f^{\uparrow K^{A,\bullet}\uparrow L}=y\triangleright f^{\downarrow K^{\bullet,B}\uparrow L}\quad.
\]
We need to show that $\left(x,y\right)\in\left<f\right>^{\updownarrow P}$.
As shown in Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
below, lifting a relation to $P$ means first lifting to $K$ and
then to $L$, so $\left<f\right>^{\updownarrow P}=\left<f\right>^{\updownarrow K\updownarrow L}$.
Since $K$ has the post-wedge property, the $\left(K,f\right)$-wedge
relation is equivalent to the relation $\left<f\right>^{\updownarrow K}$:
\[
(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\quad\text{is equivalent to}:\quad(k_{1},k_{2})\in\text{pull}\,(f^{\uparrow K^{A,\bullet}},f^{\downarrow K^{B,\bullet}})\quad.
\]
By Statement~\ref{subsec:Statement-pullback-lifted-to-functor} proved
below, lifting a pullback relation to $L$ gives again a pullback
relation:
\[
\left(x,y\right)\in\left<f\right>^{\updownarrow P}=\big(\text{pull}\,(f^{\uparrow K^{A,\bullet}},f^{\downarrow K^{B,\bullet}})\big)^{\updownarrow L}\quad\text{means}\quad(x,y)\in\text{pull}\,(f^{\uparrow K^{A,\bullet}\uparrow L},f^{\downarrow K^{\bullet,B}\uparrow L})\quad.
\]
So, $\left(x,y\right)$ are in the relation $\left<f\right>^{\updownarrow P}$.

\subsubsection{Statement \label{subsec:Statement-functor-composition-relational-lifting}\ref{subsec:Statement-functor-composition-relational-lifting}}

For any type constructors $G$ and $H$, define $F\triangleq G\circ H$,
equivalently denoted as $F^{A}\triangleq G^{H^{A}}$. Then the lifting
of any relation $r^{:A\leftrightarrow B}$ to $F$ can be expressed
as $r^{\updownarrow F}=(r^{\updownarrow H})^{\updownarrow G}$, which
we may write more concisely as $r^{\updownarrow F}=r^{\updownarrow H\updownarrow G}$.

\subparagraph{Proof}

For each case of Definition~\ref{subsec:Definition-relational-lifting}
for the type constructor $G$, we show that $r^{\updownarrow F}=(r^{\updownarrow H})^{\updownarrow G}$.

\paragraph{Constant type}

With $G^{A}\triangleq Z$ where $Z$ is a fixed type, we have $F^{A}=Z$,
so we write:
\[
r^{\updownarrow F}=\text{id}^{:Z\leftrightarrow Z}\quad\text{and}\quad(r^{\updownarrow H})^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}\quad.
\]


\paragraph{Type parameter}

With $G^{A}\triangleq A$, we have $F^{A}=H^{A}$, so we write:
\[
r^{\updownarrow F}=r^{\updownarrow H}\quad\text{and}\quad(r^{\updownarrow H})^{\updownarrow G}=(r^{\updownarrow H})^{\updownarrow\text{Id}}=r^{\updownarrow H}\quad.
\]


\paragraph{Products}

With $G^{A}\triangleq K^{A}\times L^{A}$, we have $F^{A}=K^{H^{A}}\times L^{H^{A}}$.
Assuming that Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
already holds for $K\circ H$ and $L\circ H$, we write:
\begin{align*}
 & r^{\updownarrow F}=r^{\updownarrow(K\circ H)}\boxtimes r^{\updownarrow(L\circ H)}=r^{\updownarrow H\updownarrow K}\boxtimes r^{\updownarrow H\updownarrow L}=(r^{\updownarrow H})^{\updownarrow K}\boxtimes(r^{\updownarrow H})^{\updownarrow L}\quad,\\
 & (r^{\updownarrow H})^{\updownarrow G}=(r^{\updownarrow H})^{\updownarrow(K\times L)}=(r^{\updownarrow H})^{\updownarrow K}\boxtimes(r^{\updownarrow H})^{\updownarrow L}\quad.
\end{align*}
The two relations are now equal.

\paragraph{Co-products and function types}

The proofs are similar to that for products if we replace the operation
$\boxtimes$ by $\boxplus$ or by $\ogreaterthan$ everywhere as appropriate.

\paragraph{Recursive types}

With $G^{A}\triangleq S^{A,G^{A}}$, we have $F^{A}=S^{H^{A},G^{H^{A}}}=S^{H^{A},F^{A}}$.
Denoting $Q^{A,B}\triangleq S^{H^{A},B}$, we can write $F^{A}=Q^{A,F^{A}}$.
One inductive assumption is that Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
already holds separately with respect to each type parameter of $S$
and, in particular, a simultaneous lifting to $Q$ satisfies:
\[
(r,s)^{\updownarrow P}=(r,s)^{\updownarrow S^{H^{\bullet},\bullet}}=(r^{\updownarrow H},s)^{\updownarrow S^{\bullet,\bullet}}\quad.
\]
Then we can finish the derivation:
\begin{align*}
{\color{greenunder}\text{expect to equal }(r^{\updownarrow H})^{\updownarrow G}:}\quad & r^{\updownarrow F}=(r,\overline{r^{\updownarrow F}})^{\updownarrow P}=(r^{\updownarrow H},\overline{r^{\updownarrow F}})^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\overline{r^{\updownarrow F}}=\overline{r^{\updownarrow H\updownarrow G}}:}\quad & =(r^{\updownarrow H},\overline{r^{\updownarrow H\updownarrow G}})^{\updownarrow S}=(r^{\updownarrow H})^{\updownarrow G}\quad.
\end{align*}


\paragraph{Quantified types}

With $G^{A}\triangleq\forall X.\,P^{X,A}$, we have $F^{A}=\forall X.\,P^{X,H^{A}}$.
We may assume that Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
already holds separately for liftings with respect to each type parameter
of $P$. In particular, if we denote $Q^{X,B}\triangleq P^{X,H^{B}}$
then:
\[
(s,r)^{\updownarrow Q}=(s,r)^{\updownarrow P^{\bullet,H^{\bullet}}}=(s,r^{\updownarrow H})^{\updownarrow P}\quad.
\]
For any types $A$, $B$, $X$, $Y$ and for any values $p^{:F^{A}}$
and $q^{:F^{B}}$, we write:
\begin{align*}
 & (p,q)\in r^{\updownarrow F}\quad\text{means}\quad\forall s^{:X\leftrightarrow Y}\,:\,(p^{X},q^{Y})\in(s,r)^{\updownarrow P^{\bullet,H^{\bullet}}}=(s,r^{\updownarrow H})^{\updownarrow P}\quad,\\
 & (p,q)\in(r^{\updownarrow H})^{\updownarrow G}\quad\text{means}\quad\forall s^{:X\leftrightarrow Y}\,:\,(p^{X},q^{Y})\in(s,r^{\updownarrow H})^{\updownarrow P^{\bullet,\bullet}}\quad.
\end{align*}
The two relations are now equal. 

\subsubsection{Statement \label{subsec:Statement-pullback-lifted-to-functor}\ref{subsec:Statement-pullback-lifted-to-functor}}

The lifting of a pullback relation to any polynomial functor $F$
is equivalent to a pullback relation with lifted functions:
\[
\text{for all }f^{:A\rightarrow C},g^{:B\rightarrow C}\quad:\quad\big(\text{pull}\,(f,g)\big)^{\updownarrow F}=\text{pull}\,(f^{\uparrow F},g^{\uparrow F})\quad.
\]


\subparagraph{Proof}

\begin{comment}
Most likely this is wrong for non-polynomial (although covariant)
functors $F$
\end{comment}
We enumerate the type constructions that $F$ is built from. Denote
$r^{:A\leftrightarrow B}\triangleq\text{pull}\,(f,g)$.

\paragraph{Constant types}

If $F^{A}\triangleq Z$ where $Z$ is a fixed type then $r^{\updownarrow F}=\text{id}^{:Z\leftrightarrow Z}$.
We write:
\[
\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(\text{id}^{:Z\leftrightarrow Z},\text{id}^{:Z\leftrightarrow Z})=\text{id}^{:Z\leftrightarrow Z}=r^{\updownarrow F}\quad.
\]


\paragraph{Type parameter}

If $F^{A}\triangleq A$ then $r^{\updownarrow F}=r$, $f^{\uparrow F}=f$,
and $g^{\uparrow F}=g$. We write:
\[
\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(f,g)=r=r^{\updownarrow F}\quad.
\]


\paragraph{Products}

If $F^{A}\triangleq K^{A}\times L^{A}$ then $r^{\updownarrow F}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}$,
$f^{\uparrow F}=f^{\uparrow K}\boxtimes f^{\uparrow L}$, and $g^{\uparrow F}=g^{\uparrow K}\boxtimes g^{\uparrow L}$.
For any values $k_{1}^{:K^{A}}$, $l_{1}^{:L^{A}}$, $k_{2}^{:K^{B}}$,
and $l_{2}^{:L^{B}}$, we write out the relation $r^{\updownarrow F}$:
\[
(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow F}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}\quad\text{means}\quad(k_{1},k_{2})\in r^{\updownarrow K}\text{ and }(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\]
The inductive assumptions for $K$ and $L$ allow us to rewrite the
last conditions as:
\[
(k_{1},k_{2})\in\text{pull}\,(f^{\uparrow K},g^{\uparrow K})\quad\text{ and }\quad(l_{1},l_{2})\in\text{pull}\,(f^{\uparrow L},g^{\uparrow L})\quad.
\]
Turning now to the pullback relation, $\text{pull}\,(f^{\uparrow F},g^{\uparrow F})$,
we write:
\begin{align*}
 & (k_{1}^{:K^{A}}\times l_{1}^{:L^{A}},k_{2}^{:K^{B}}\times l_{2}^{:L^{B}})\in\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(f^{\uparrow K}\boxtimes f^{\uparrow L},g^{\uparrow K}\boxtimes g^{\uparrow L})\\
 & \quad\text{means}\quad(k_{1}\times l_{1})\triangleright(f^{\uparrow K}\boxtimes f^{\uparrow L})=(k_{2}\times l_{2})\triangleright(g^{\uparrow K}\boxtimes g^{\uparrow L})\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright g^{\uparrow K}\quad\text{ and }\quad l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright g^{\uparrow L}\quad.
\end{align*}
The last conditions are now the same as for the relation $r^{\updownarrow F}$.

\paragraph{Co-products}

If $F^{A}\triangleq K^{A}+L^{A}$ then $r^{\updownarrow F}=r^{\updownarrow K}\boxplus r^{\updownarrow L}$,
$f^{\uparrow F}=f^{\uparrow K}\boxplus f^{\uparrow L}$, and $g^{\uparrow F}=g^{\uparrow K}\boxplus g^{\uparrow L}$.
For any values $k_{1}^{:K^{A}}$, $l_{1}^{:L^{A}}$, $k_{2}^{:K^{B}}$,
and $l_{2}^{:L^{B}}$, we write out the relation $r^{\updownarrow F}$:
\begin{align*}
{\color{greenunder}\text{either}:}\quad & (k_{1}+\bbnum 0,k_{2}+\bbnum 0)\in r^{\updownarrow K}\boxplus r^{\updownarrow L}\quad\text{when}\quad(k_{1},k_{2})\in r^{\updownarrow K}\quad,\\
{\color{greenunder}\text{or}:}\quad & (\bbnum 0+l_{1},\bbnum 0+l_{2})\in r^{\updownarrow K}\boxplus r^{\updownarrow L}\quad\text{when}\quad(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\end{align*}
The inductive assumptions for $K$ and $L$ allow us to rewrite the
last conditions as:
\begin{align*}
 & (k_{1},k_{2})\in r^{\updownarrow K}=\text{pull}\,(f^{\uparrow K},g^{\uparrow K})\quad\text{or equivalently}:\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright g^{\uparrow K}\quad,\\
 & (l_{1},l_{2})\in r^{\updownarrow L}=\text{pull}\,(f^{\uparrow L},g^{\uparrow L})\quad\text{or equivalently}:\quad l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright g^{\uparrow L}\quad.
\end{align*}
Turning now to the pullback relation, $\text{pull}\,(f^{\uparrow F},g^{\uparrow F})$,
we write:
\begin{align}
 & (p_{1}^{:K^{A}+L^{A}},p_{2}^{:K^{B}+L^{B}})\in\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(f^{\uparrow K}\boxplus f^{\uparrow L},g^{\uparrow K}\boxplus g^{\uparrow L})\nonumber \\
 & \quad\text{means}\quad p_{1}\triangleright(f^{\uparrow K}\boxplus f^{\uparrow L})=p_{2}\triangleright(g^{\uparrow K}\boxplus g^{\uparrow L})\quad.\label{eq:p1-p2-condition-derivation1}
\end{align}
The pair co-product (such as $f^{\uparrow K}\boxplus f^{\uparrow L}$)
preserves the left and right parts of the disjunctive type, so the
condition~(\ref{eq:p1-p2-condition-derivation1}) is satisfied only
when $p_{1}$ and $p_{2}$ are both in the same part of the disjunction:
\begin{align*}
 & p_{1}\triangleright(f^{\uparrow K}\boxplus f^{\uparrow L})=p_{2}\triangleright(g^{\uparrow K}\boxplus g^{\uparrow L})\quad\text{means}\quad:\\
{\color{greenunder}\text{either}:}\quad & p_{1}=k_{1}+\bbnum 0\quad,\quad p_{2}=k_{2}+\bbnum 0\quad,\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright g^{\uparrow K}\quad;\\
{\color{greenunder}\text{or}:}\quad & p_{1}=\bbnum 0+l_{1}\quad,\quad p_{2}=\bbnum 0+l_{2}\quad,\quad l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright g^{\uparrow L}\quad.
\end{align*}
The last conditions are now the same as for the relation $r^{\updownarrow F}$.

\paragraph{Function types}

We may not use this construction since $F$ is assumed to be a polynomial
functor.

\paragraph{Recursive types}

If $F^{A}\triangleq S^{A,F^{A}}$ where $S$ is a polynomial bifunctor
then:
\[
r^{\updownarrow F}=\big(r,\overline{r^{\updownarrow F}}\big)^{\updownarrow S}\quad,\quad\quad f^{\uparrow F}=f^{\uparrow S^{\bullet,F^{A}}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\quad,\quad\quad g^{\uparrow F}=g^{\uparrow S^{\bullet,F^{B}}}\bef\big(\overline{g^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\quad.
\]
The inductive assumptions are that Statement~\ref{subsec:Statement-pullback-lifted-to-functor}
already holds for the recursively used lifting $\overline{r^{\updownarrow F}}$
and for simultaneous liftings of \emph{two} pullback relations to
$S^{\bullet,\bullet}$. Write those assumptions as:
\begin{align*}
{\color{greenunder}\text{for }\overline{r^{\updownarrow F}}:}\quad & \overline{r^{\updownarrow F}}\overset{!}{=}\text{pull}\,\big(\overline{f^{\uparrow F}},\overline{g^{\uparrow F}}\big)\quad,\\
{\color{greenunder}\text{for }S:}\quad & \big(\text{pull}\,(f^{:A\rightarrow C},g^{:B\rightarrow C}),\,\,\text{pull}\,(h^{:X\rightarrow Z},k^{:Y\rightarrow Z})\big)^{\updownarrow S}\overset{!}{=}\text{pull}\,(f^{\uparrow S^{\bullet,X}}\bef h^{\uparrow S^{C,\bullet}},\,\,g^{\uparrow S^{\bullet,Y}}\bef k^{\uparrow S^{C,\bullet}})\quad,
\end{align*}
where the last pullback relation involves functions of types $S^{A,X}\rightarrow S^{C,Z}$
and $S^{B,Y}\rightarrow S^{C,Z}$. Then:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pull}\,(f^{\uparrow F},g^{\uparrow F}):}\quad & r^{\updownarrow F}=\big(r,\overline{r^{\updownarrow F}}\big)^{\updownarrow S}=\big(\text{pull}\,(f,g),\,\,\text{pull}\,\big(\overline{f^{\uparrow F}},\overline{g^{\uparrow F}}\big)\big)^{\updownarrow S}\\
{\color{greenunder}\text{assumption for }S:}\quad & =\text{pull}\,\big(f^{\uparrow S^{\bullet,F^{A}}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\,\,,g^{\uparrow S^{\bullet,F^{B}}}\bef\big(\overline{g^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\big)\\
{\color{greenunder}\text{definitions of }(...)^{\uparrow F}:}\quad & =\text{pull}\,(f^{\uparrow F},g^{\uparrow F})\quad.
\end{align*}
$\square$

The strong dinaturality property of \lstinline!foldFn! can be proved
by using Statement~\ref{subsec:Statement-functor-post-pre-wedge}:

\subsubsection{Example \label{subsec:Example-strong-dinaturality-proof-of-foldFn-law}\ref{subsec:Example-strong-dinaturality-proof-of-foldFn-law}\index{examples}}

Show that any fully parametric function $f:\forall A.\,L^{A\rightarrow A}\rightarrow A\rightarrow A$
is strongly dinatural when $L$ is any polynomial functor.

\subparagraph{Solution}

Define the profunctor $K^{X,Y}\triangleq X\rightarrow Y$ so that
the type signature of $f$ is written as:
\[
\forall A.\,L^{A\rightarrow A}\rightarrow A\rightarrow A=\forall A.\,L^{K^{A,A}}\rightarrow K^{A,A}\quad.
\]
By Statement~\ref{subsec:Statement-post-wedge}(a) and (d), the profunctor
$K$ has the post-wedge property. Statement~\ref{subsec:Statement-functor-post-pre-wedge}
then shows that the profunctor $L^{K^{X,Y}}$ also has the post-wedge
property. By Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality},
$f$ satisfies the strong dinaturality law. 

\subsection{Universal type quantifiers. Notation. Using Yoneda identities}

Throughout this book, we have been using type quantifiers to denote
type signatures of generic functions. For instance, the function \lstinline!pure!
written in Scala as:
\begin{lstlisting}
def pure[A](a: A): F[A] = ...
\end{lstlisting}
is denoted by $\text{pu}_{F}:\forall A.\,A\rightarrow F^{A}$. We
have also seen that the type of \lstinline!pure! is equivalent to
the type of \textsf{``}wrapped unit\textsf{''} ($\text{wu}_{F}:F^{\bbnum 1}$). This
equivalence:
\[
\forall A.\,A\rightarrow F^{A}\cong F^{\bbnum 1}
\]
is an example of a type equivalence where a type involving the universal
quantifier ($\forall$) is reduced to an equivalent but simpler type
that has no quantifiers. There exist general techniques that make
such simplifications possible in a number of cases.

Let us first clarify an important difference between the quantified
type $\forall X.\,F^{X}$ and the type constructor $F$ that may be
applied to a type parameter $X$ to give the type $F^{X}$. In both
cases, $X$ is a completely unknown type parameter. One difference
is that $F^{X}$ is a type that describes a specific chosen type $X$
wrapped in $F$. If $F=$ \lstinline!List! then $F^{X}=\text{List}^{X}$
is the type of lists with values of a type $X$ (and that type needs
to have been defined previously). On the other hand, $\forall X.\,F^{X}$
is a type describing code that works for all $X$ at once. Here is
an example of Scala code implementing a value of type $\forall X.\,\text{List}^{X}$:
\begin{lstlisting}
def f[X]: List[X] = List()
\end{lstlisting}
The same function \lstinline!f! may be used with any type \lstinline!X!,
as the code of \lstinline!f! does not assume anything about the properties
of \lstinline!X!. 

We say that the type parameter $X$ is \textbf{bound}\index{bound type parameter}
within the type expression $\forall X.\,F^{X}$. But the type parameter
$X$ is \emph{free} in the type expression $F^{X}$.

Note that the type $\forall X.\,F^{X}$ is also different from just
the type constructor $F$. To clarify this point, consider again the
example with $F=$ \lstinline!List!. The type constructor \lstinline!List!
does not itself have values; it describes how to make lists of various
types, such as \lstinline!List[Int]! or \lstinline!List[String]!.
We may have a value of type \lstinline!List[Int]! but \emph{not}
of type \lstinline!List! itself. By contrast, the type $\forall X.\,\text{List}^{X}$
has values (as shown by the code snippet above) and is not a type
constructor.

Another important detail about our usage of universally quantified
types like $\forall X.\,F^{X}$ is that we will normally expect all
values of such types to be implemented via fully parametric code.
The code of the function \lstinline!f[X]! should not make decisions
based on the actual type passed at run time as the type parameter
\lstinline!X! into the function. The assumption of full parametricity
enables us to reason about quantified types in a special way. This
and the following sections show some techniques used in that reasoning.

When writing code that has a universally quantified type, we use the
following notations:
\begin{align*}
{\color{greenunder}\text{value of a universally quantified type}:}\quad & f:\forall X.\,F^{X}\quad,\\
{\color{greenunder}\text{apply }f\text{ to type }Y:}\quad & f^{Y}:F^{Y}\quad,\\
{\color{greenunder}\text{define the code of }f:}\quad & f\triangleq\forall X.\,\text{code}\quad.
\end{align*}
In Scala, $f^{Y}$ corresponds to \lstinline!f[Y]! and $f\triangleq\forall X.\,\text{<code>}$
corresponds to:
\begin{lstlisting}
val f = new { def run[X] = code }  // Scala 2
val f = [X] => <code>              // Scala 3
\end{lstlisting}

To illustrate these notations, let us define a function with a type
that involves both an argument and a result with quantified types.
We will intentionally use Scala 3 syntax that is similar to the code
notation:
\begin{lstlisting}
val f: ([A] => ((A, A)) => (A, A)) => [B] => ((B, B)) => B   // Scala 3
  = { k => [B] => p => k[B](p)._1 }
\end{lstlisting}
\begin{align*}
 & f:(\forall A.\,A\times A\rightarrow A\times A)\rightarrow\forall B.\,B\times B\rightarrow B\quad,\\
 & f\triangleq k^{:\forall A.\,A\times A\rightarrow A\times A}\rightarrow\forall B.\,p^{:B\times B}\rightarrow p\triangleright k^{B}\triangleright\pi_{1}\quad.
\end{align*}
This example illustrates creating a function of quantified type:
\[
\forall B.\,p^{:B\times B}\rightarrow k^{B}(p)\triangleright\pi_{1}\quad,
\]
and assigning the type parameter of $k$ (that itself has a quantified
type) as $k^{B}$. This corresponds to the Scala syntax \lstinline!k[B]!.

To use the function $f$ just defined, we need to apply it to a function
of type $\forall A.\,A\times A\rightarrow A\times A$, to a type parameter
$B$, and to a value of type $B\times B$:
\begin{lstlisting}
scala> f([A] => p => p.swap)[String](("a", "b"))
val res0: String = b
\end{lstlisting}
To see how the evaluation goes, let us write out all steps of the
calculation and annotate all types. The full expression is:
\[
\big(f(\forall A.\,a^{:A}\times b^{:A}\rightarrow b\times a)\big)^{\text{String}}(\text{"a"}\times\text{"b"})\quad.
\]
The first step is to apply $f$ to its argument:
\begin{align*}
 & f(\forall A.\,a^{:A}\times b^{:A}\rightarrow b\times a)=\forall B.\,p^{:B\times B}\rightarrow p\triangleright\gunderline{\big(\forall A.\,a^{:A}\times b^{:A}\rightarrow b\times a\big)^{B}}\triangleright\pi_{1}\\
 & =\forall B.\,p^{:B\times B}\rightarrow p\triangleright\big(a^{:B}\times b^{:B}\rightarrow b\times a\big)\bef\pi_{1}=\forall B.\,p^{:B\times B}\rightarrow p\triangleright\pi_{2}\quad.
\end{align*}
The next step is to assign the type parameter $B=\text{String}$ in
the last function:
\[
\big(f(\forall A.\,a^{:A}\times b^{:A}\rightarrow b\times a)\big)^{\text{String}}=\big(\forall B.\,p^{:B\times B}\rightarrow p\triangleright\pi_{2}\big)^{\text{String}}=p^{:\text{String}\times\text{String}}\rightarrow p\triangleright\pi_{2}\quad.
\]
Finally, we apply this to the pair $\text{"a"}\times\text{"b"}$:
\begin{align*}
 & \big(f(\forall A.\,a^{:A}\times b^{:A}\rightarrow b\times a)\big)^{\text{String}}(\text{"a"}\times\text{"b"})\\
 & =\big(p^{:\text{String}\times\text{String}}\rightarrow p\triangleright\pi_{2}\big)(\text{"a"}\times\text{"b"})=(\text{"a"}\times\text{"b"})\triangleright\pi_{2}=\text{"b"}\quad.
\end{align*}


\paragraph{The Yoneda identities}

proved in Section~\ref{subsec:Yoneda-identities} are general type
equivalence patterns where a type with a quantifier is reduced to
a simpler type without a quantifier. The covariant and the contravariant
Yoneda identities are written as:
\begin{align*}
{\color{greenunder}\text{for any functor }F:}\quad & \forall A.\,(Z\rightarrow A)\rightarrow F^{A}\cong F^{Z}\quad,\\
{\color{greenunder}\text{for any contrafunctor }H:}\quad & \forall A.\,(A\rightarrow Z)\rightarrow H^{A}\cong H^{Z}\quad.
\end{align*}

The form of the types in the left-hand sides may appear to be too
specific. However, with appropriate choices of the fixed type $Z$
and the type constructors $F$ and $H$, the Yoneda identities lead
to many useful type equivalences. Here are some examples.

\subsubsection{Statement \label{subsec:Statement-simplify-forall-F}\ref{subsec:Statement-simplify-forall-F}}

The following type equivalences hold:
\begin{align*}
{\color{greenunder}\text{\textbf{(a)} for any functor }F:}\quad & \forall A.\,F^{A}\cong F^{\bbnum 0}\quad,\\
{\color{greenunder}\text{\textbf{(b)} for any contrafunctor }F:}\quad & \forall A.\,H^{A}\cong H^{\bbnum 1}\quad.
\end{align*}


\subparagraph{Proof}

For \textbf{(a)}, set $Z=\bbnum 0$ in the covariant Yoneda identity:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \forall A.\,(\gunderline{\bbnum 0\rightarrow A})\rightarrow F^{A}\cong\forall A.\,\gunderline{\bbnum 1\rightarrow F^{A}}\cong\forall A.\,F^{A}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & F^{\bbnum 0}\quad.
\end{align*}

For \textbf{(b)}, set $Z=\bbnum 1$ in the contravariant Yoneda identity:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \forall A.\,(\gunderline{A\rightarrow\bbnum 1})\rightarrow H^{A}\cong\forall A.\,\gunderline{\bbnum 1\rightarrow H^{A}}\cong\forall A.\,H^{A}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & H^{\bbnum 1}\quad.
\end{align*}
 $\square$

Here are some examples of type equivalences that follow from this:
\begin{align*}
{\color{greenunder}\text{set }F^{A}\triangleq C:}\quad & \forall A.\,C\cong C\quad,\\
{\color{greenunder}\text{set }F^{A}\triangleq A:}\quad & \forall A.\,A\cong\bbnum 0\quad,\\
{\color{greenunder}\text{set }F^{A}\triangleq\bbnum 1+A:}\quad & \forall A.\,\bbnum 1+A\cong\bbnum 1\quad,\\
{\color{greenunder}\text{set }F^{A}\triangleq C\rightarrow A:}\quad & \forall A.\,C\rightarrow A\cong\bbnum 0\quad,\\
{\color{greenunder}\text{set }F^{A}\triangleq(A\rightarrow C)\rightarrow D:}\quad & \forall A.\,(A\rightarrow C)\rightarrow D\cong D\quad,\\
{\color{greenunder}\text{set }H^{A}\triangleq A\rightarrow C:}\quad & \forall A.\,A\rightarrow C\cong C\quad.
\end{align*}

As a further example, set $Z=\bbnum 1$ in the covariant Yoneda identity.
The left-hand side becomes:
\[
\forall A.\,(\gunderline{\bbnum 1\rightarrow A})\rightarrow F^{A}\cong\forall A.\,A\rightarrow F^{A}\quad.
\]
The right-hand side is just $F^{\bbnum 1}$. So, $\forall A.\,A\rightarrow F^{A}\cong F^{\bbnum 1}$.
We have again derived the equivalence between the types of $\text{pu}_{F}$
and $\text{wu}_{F}$ for pointed functors that we first saw in Section~\ref{subsec:Pointed-functors-motivation-equivalence}.
This time, the proof goes as a direct consequence of a Yoneda identity.

If we set $F^{A}\triangleq A$ in the covariant Yoneda identity, we
get:
\[
\forall A.\,(Z\rightarrow A)\rightarrow A\cong Z\quad.
\]
If we now set $Z\triangleq\bbnum 1$ or $Z\triangleq\bbnum 2$ and
simplify the type $Z\rightarrow A$, we obtain:
\begin{align*}
{\color{greenunder}\text{set }Z\triangleq\bbnum 1:}\quad & \forall A.\,A\rightarrow A\cong\bbnum 1\quad,\\
{\color{greenunder}\text{set }Z\triangleq\bbnum 2:}\quad & \forall A.\,A\times A\rightarrow A\cong\bbnum 2\quad.
\end{align*}
This gives a quick proof that there is only one fully parametric function
of type $\forall A.\,A\rightarrow A$ and only two fully parametric
functions of type $\forall A.\,A\times A\rightarrow A$.

The Yoneda identities are used as intermediate steps in derivations
of type equivalence in more complicated cases. In the following examples,
$P$, $Q$, $R$, $S$ are fixed types.

\subsubsection{Example \label{subsec:Example-complicated-type-equivalence}\ref{subsec:Example-complicated-type-equivalence}\index{examples}}

Simplify the type $\forall A.\,(P\rightarrow A)\rightarrow Q\rightarrow A$.

\subparagraph{Solution}

Denoting $F^{A}\triangleq Q\rightarrow A$ brings the type to a Yoneda-like
form:
\[
\forall A.\,(P\rightarrow A)\rightarrow Q\rightarrow A=\forall A.\,(P\rightarrow A)\rightarrow F^{A}\cong F^{P}=Q\rightarrow P\quad.
\]


\subsubsection{Example \label{subsec:Example-complicated-type-equivalence-1}\ref{subsec:Example-complicated-type-equivalence-1}}

Simplify the type $\forall A.\,(A\rightarrow P)\rightarrow A\rightarrow Q$.

\subparagraph{Solution}

Denoting $H^{A}\triangleq A\rightarrow Q$ brings the type to a Yoneda-like
form:
\[
\forall A.\,(A\rightarrow P)\rightarrow A\rightarrow Q=\forall A.\,(A\rightarrow P)\rightarrow H^{A}\cong H^{P}=P\rightarrow Q\quad.
\]
 

\subsubsection{Example \label{subsec:Example-complicated-type-equivalence-2}\ref{subsec:Example-complicated-type-equivalence-2}}

Simplify the type $\forall A.\,((A\rightarrow P)\rightarrow Q)\rightarrow(A\rightarrow S)\rightarrow R$.

\subparagraph{Solution}

\footnote{See \texttt{\href{https://cstheory.stackexchange.com/questions/51932}{https://cstheory.stackexchange.com/questions/51932}}.
The author thanks Dan Doel\index{Dan Doel} for assistance with solving
this example.}Swap the curried arguments in the given type and get:
\begin{align*}
 & \forall A.\,((A\rightarrow P)\rightarrow Q)\rightarrow(A\rightarrow S)\rightarrow R\\
 & \cong\forall A.\,(A\rightarrow S)\rightarrow((A\rightarrow P)\rightarrow Q)\rightarrow R\\
 & =\forall A.\,(A\rightarrow S)\rightarrow H^{A}\quad,
\end{align*}
where we defined $H^{A}\triangleq((A\rightarrow P)\rightarrow Q)\rightarrow R$.
As $H$ is a contrafunctor, we may apply the contravariant Yoneda
identity:
\[
\forall A.\,(A\rightarrow S)\rightarrow H^{A}\cong H^{S}=((S\rightarrow P)\rightarrow Q)\rightarrow R\quad.
\]


\subsection{Encoding other types via universal quantifiers and functions}

It turns out that all fully parametric type expressions are equivalent
to some type expressions that use only two type constructions: the
function type ($A\rightarrow B$) and the universal quantifier ($\forall A.\,F^{A}$).
If a programming language supports only these two type constructions,
one can write a library that implements all other type constructions.

We will now show the required type expressions and prove their validity.
The main tools in those proofs are the Church encoding and the Yoneda
lemma.

\paragraph{Void type}

The void type ($\bbnum 0$) is equivalent to the type expression $\forall A.\,A$.
To prove that $\forall A.\,A\cong\bbnum 0$, we may use the Yoneda
lemma:
\[
\forall A.\,A\cong\forall A.\,\bbnum 1\rightarrow A\cong\forall A.\,(\bbnum 0\rightarrow A)\rightarrow A\cong\bbnum 0\quad.
\]


\paragraph{Unit type}

The unit type ($\bbnum 1$) is equivalent to $\forall A.\,A\rightarrow A$.
To prove that, we may use the Yoneda lemma:
\[
\forall A.\,A\rightarrow A\cong\forall A.\,(\bbnum 1\rightarrow A)\rightarrow A\cong\bbnum 1\quad.
\]


\paragraph{Products}

The type $A\times B$ is equivalent to $\forall T.\,(A\rightarrow B\rightarrow T)\rightarrow T$.
To prove that, we use uncurrying and the Yoneda lemma:
\[
\forall T.\,(A\rightarrow B\rightarrow T)\rightarrow T\cong\forall T.\,(A\times B\rightarrow T)\rightarrow T\cong A\times B\quad.
\]


\paragraph{Co-products}

The type $A+B$ is equivalent to $\forall T.\,(A\rightarrow T)\rightarrow(B\rightarrow T)\rightarrow T$.
To prove that, we use the Yoneda lemma:
\begin{align*}
 & \forall T.\,(A\rightarrow T)\rightarrow(B\rightarrow T)\rightarrow T\cong\forall T.\,(A\rightarrow T)\times(B\rightarrow T)\rightarrow T\\
 & \quad\cong\forall T.\,(A+B\rightarrow T)\rightarrow T\cong A+B\quad.
\end{align*}


\paragraph{Recursive types: least fixpoints}

Recursive types are often defined via the least fixpoint $T$ of the
type equation $T\triangleq F^{T}$, where $F$ is a covariant functor.
Then $T$ is equivalent to the following Church-encoded type:
\[
T\cong\forall A.\,(F^{A}\rightarrow A)\rightarrow A\quad.
\]
This is proved in Statement~\ref{subsec:Statement-Church-encoding-recursive-type-covariant}
($T$ is the least fixpoint\index{least fixpoint}, $\text{LFix}(F)$,
of the type equation $T=F^{T}$). By the inductive assumption, the
type $F^{A}$ is equivalent to some type expression containing only
function types and universally quantified type parameters. So, we
have now encoded $T$ in the same way. (Rigorously speaking, .) 

\paragraph{Existential types}

We have the equivalence given by Eq.~(\ref{eq:existential-via-universal-Yoneda}):
\[
\exists A.\,F^{A}\cong\forall T.\,(\forall A.\,F^{A}\rightarrow T)\rightarrow T\quad.
\]


\paragraph{Recursive types: greatest fixpoints}

If $T$ is the greatest fixpoint of the type equation $T\triangleq F^{T}$,
where $F$ is a covariant functor, then we can encode $T$ like this:
\[
T\cong\exists A.\,(A\rightarrow F^{A})\times A\quad.
\]
This is proved in Section~\ref{subsec:The-greatest-fixpoints-and-Church-co-Yoneda}.


\subsection{The Yoneda identities for type constructors\label{subsec:The-Yoneda-identities-for-type-constructors}}

The Yoneda identities can be extended to many other contexts. For
instance, a Yoneda identity holds for types parameterized by a type
constructor:

\subsubsection{Statement \label{subsec:Statement-covariant-yoneda-identity-for-type-constructors}\ref{subsec:Statement-covariant-yoneda-identity-for-type-constructors}
(covariant Yoneda identity for functors)\index{Yoneda identity!for functors}}

Assume that $P$ is any type constructor and $S$ is a higher-order
functor\index{functor!higher-order}\index{higher-order functor}.
That is, $S^{F}$ is a type that depends covariantly on an arbitrary
type constructor $F$. (An example of such $S$ is $S^{F}\triangleq F^{\text{Int}}\times F^{\text{String}}$.)
Then the type $S^{P}$ is equivalent to the function type $\forall F^{\bullet}.\,(P\leadsto F)\rightarrow S^{F}$,
where the function is required to be natural in the (type constructor)
parameter $F$. The corresponding naturality law for functions $\sigma$
of type $\forall F^{\bullet}.\,(P\leadsto F)\rightarrow S^{F}$ involves
arbitrary type constructors $Q$, $R$, and arbitrary functions $f:P\leadsto Q$
and $g:Q\leadsto R$, and may be written as
\begin{equation}
\sigma^{Q}(f)\bef g^{\uparrow S}=\sigma^{R}(f\bef g)\quad.\label{eq:assumed-naturality-of-argument-sigma}
\end{equation}
Here, $g^{\uparrow S}$ has type $S^{Q}\leadsto S^{R}$ and is a lifting
of the function $g:Q\leadsto R$ to the higher-order functor $S$.
(At the same time, the functions $f$ and $g$ do \emph{not} have
to be natural transformations, and the type constructors $F$, $P$,
$Q$, $R$ are \emph{not} required to be functors.)

\subparagraph{Proof}

{*}{*}{*}rewrite the proof in a simpler way like in chapter 10{*}{*}{*} 

For brevity, we will omit the bullet symbol in $\forall F^{\bullet}$
and will write simply $\forall F$; in this proof, $F$ always stands
for a type constructor.

The isomorphism is implemented via two functions \lstinline!toC!
and \lstinline!fromC!:
\begin{align*}
\text{toC}:S^{P}\rightarrow\forall F.\,(P\leadsto F)\rightarrow S^{F}\quad, & \quad\quad\text{toC}\triangleq s^{:S^{P}}\rightarrow\forall F.\,g^{:P\leadsto F}\rightarrow s\triangleright g^{\uparrow S}\quad,\\
\text{fromC}:(\forall F.\,(P\leadsto F)\rightarrow S^{F})\rightarrow S^{P}\quad, & \quad\quad\text{fromC}\triangleq\sigma^{:\forall F.\,(P\leadsto F)\rightarrow S^{F}}\rightarrow\sigma^{P}(\text{id}^{:P\leadsto P})\quad.
\end{align*}
In the last line, the function $\sigma$ is required to be natural
in its type parameter $Q$.

We need to show that $\text{fromC}\bef\text{toC}=\text{id}$ and $\text{toC}\bef\text{fromC}=\text{id}$.
To verify that $\text{fromC}\bef\text{toC}=\text{id}$, apply both
sides to an arbitrary function $\sigma^{:\forall F.\,(P\leadsto F)\rightarrow S^{F}}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\sigma:}\quad & \sigma^{:\forall F.\,(P\leadsto F)\rightarrow S^{F}}\triangleright\text{fromC}\bef\text{toC}=\sigma^{P}(\text{id})\triangleright\text{toC}=\forall F.\,g^{:P\leadsto F}\rightarrow\sigma^{P}(\text{id})\triangleright g^{\uparrow S}\quad.
\end{align*}
Since by assumption $\sigma$ satisfies the naturality law~(\ref{eq:assumed-naturality-of-argument-sigma}),
we may apply that law with $Q=P$, $R=F$, and $f=\text{id}$:
\[
\sigma^{P}(\text{id})\bef g^{\uparrow S}=\sigma^{F}(\text{id}\bef g)=F^{F}(g)\quad.
\]
It follows that the function $\sigma\triangleright\text{fromC}\bef\text{toC}$
is the same as $\sigma$:
\[
\sigma\triangleright\text{fromC}\bef\text{toC}=\forall F.\,g^{:P\leadsto F}\rightarrow\sigma^{F}(g)=\forall F.\,\sigma^{F}=\sigma\quad.
\]

To verify that $\text{toC}\bef\text{fromC}=\text{id}$, apply both
sides to an arbitrary $s^{:S^{P}}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }s:}\quad & s^{:S^{P}}\triangleright\text{toC}\bef\text{fromC}=s\triangleright\text{toC}\triangleright\text{fromC}=(\forall F.\,g^{:P\leadsto F}\rightarrow s\triangleright g^{\uparrow S})\triangleright\text{fromC}\\
 & =(g^{:P\leadsto P}\rightarrow s\triangleright g^{\uparrow S})(\text{id}^{:P\leadsto P})=s\triangleright\text{id}^{\uparrow S}=s\quad.
\end{align*}
It remains to check that the function $\sigma^{F}\triangleq g^{:P\leadsto F}\rightarrow s\triangleright g^{\uparrow S}$,
used as an argument of \lstinline!fromC!, is natural in $F$. To
verify the naturality law~(\ref{eq:assumed-naturality-of-argument-sigma}):
\begin{align*}
{\color{greenunder}\text{expect to equal }\sigma^{R}(f\bef g):}\quad & \sigma^{Q}(f)\bef g^{\uparrow S}=s\triangleright f^{\uparrow S}\bef g^{\uparrow S}=s\triangleright(f\bef g)^{\uparrow S}=\sigma^{R}(f\bef g)\quad.
\end{align*}

A similar identity holds for types $S^{F}$ that depend \emph{contravariantly}
on an arbitrary type constructor $F$:
\begin{equation}
\forall F^{\bullet}.\,(F\leadsto P)\rightarrow S^{F}\cong S^{P}\quad.\label{eq:contravariant-yoneda-identity-for-type-constructors}
\end{equation}
We omit the proof as it is analogous to that in Statement~\ref{subsec:Statement-covariant-yoneda-identity-for-type-constructors}.

\subsection{The Church-Yoneda identity and its applications}

We have seen in Section~{*}{*}{*} that the least fixpoint of a functor
$F$, which we denote by $\text{LFix}(F)$, is given by the Church-encoded
type:
\[
\text{LFix}(F)=\forall A.\ (F^{A}\rightarrow A)\rightarrow A\quad.
\]
This type is somewhat similar to that used in the Yoneda identity:
\[
G^{R}\cong\forall A.\ (R\rightarrow A)\rightarrow G^{A}\quad.
\]
It turns out that there is an identity that generalizes both of those
types:

\subsubsection{Statement \label{subsec:Statement-Church-Yoneda-identity}\ref{subsec:Statement-Church-Yoneda-identity}}

For any functors $F$ and $G$, the following types are equivalent:
\[
G^{\text{LFix}(F)}\cong\forall A.\ (F^{A}\rightarrow A)\rightarrow G^{A}\quad.
\]
We call this the \index{Church-Yoneda identity}\textbf{Church-Yoneda
identity}.\footnote{This identity has no widely accepted name and is mentioned in the
proceedings of the conference \textsf{``}Fixed Points in Computer Science
2010\textsf{''} on page 78 as \textsf{``}proposition 1\textsf{''} in the paper by T.~Uustalu,
see \texttt{\href{https://hal.science/hal-00512377/document}{https://hal.science/hal-00512377/document}}} In this type equivalence, it is assumed that all values of types
$\forall A.\ (F^{A}\rightarrow A)\rightarrow A$ and $\forall A.\ (F^{A}\rightarrow A)\rightarrow G^{A}$
satisfy the strong dinaturality law. (The previous section showed
that fully parametric code having those type signatures will automatically
satisfy the strong dinaturality law by virtue of the parametricity
theorem.)

\subparagraph{Proof}

a{*}{*}{*}

$\square$

One application of the Church-Yoneda identity is for establishing
the Church encoding formula for mutually recursive types. {*}{*}{*}
See the Dhall book\textsf{'}s appendix

\subsection{Non-disjunctive type constructors}

Generally, the type expression $P\rightarrow Q+R$ is not equivalent
to $(P\rightarrow Q)+(P\rightarrow R)$. However, the situation becomes
different once we assume full parametricity and impose a universal
quantifier. This section shows that one may simplify a function type
$\forall A.\,P^{A}\rightarrow Q^{A}+R^{A}$ to $(\forall A.\,P^{A}\rightarrow Q^{A})+(\forall A.\,P^{A}\rightarrow R^{A})$
for certain type constructors $P$. We call such $P$ \textsf{``}non-disjunctive
type constructors\textsf{''}.

As a first example, consider a fully parametric function $k$ of type:
\[
k:\forall A.\,A\rightarrow\bbnum 1+A\quad.
\]
The function $k$ must construct a value of type $\bbnum 1+A$ given
a value of type $A$. So, the code of $k$ must decide to return either
the first or the second part of the disjunctive type $\bbnum 1+A$.
That decision \emph{cannot} depend on the value of the input argument
(of type $A$) because nothing is known about the type $A$. In particular,
the code of $k$ cannot perform any pattern-matching on the input
argument. It follows that the decision about the disjunctive return
value must be hard-coded: for some functions $k$ the value $k(x)$
will be $1+\bbnum 0$ for all $x$, and for other functions $k$ the
value $k(x)$ will be $\bbnum 0+x$ for all $x$. So, the fully parametric
type $\forall A.\,A\rightarrow\bbnum 1+A$ splits into a disjunction
of $\forall A.\,A\rightarrow\bbnum 1$ and $\forall A.\,A\rightarrow A$.
Each of those types has only one possible implementation:
\begin{lstlisting}
def k1[A]: A => Option[A] = None
def k2[A]: A => Option[A] = a => Some(a)
\end{lstlisting}
The Yoneda identities show that the types $\forall A.\,A\rightarrow\bbnum 1$
and $\forall A.\,A\rightarrow A$ are both equivalent to $\bbnum 1$:
\begin{align*}
 & \forall A.\,A\rightarrow\bbnum 1\cong\forall A.\,(\bbnum 1\rightarrow A)\rightarrow\bbnum 1\cong\bbnum 1\quad,\\
 & \forall A.\,A\rightarrow A\cong\forall A.\,(\bbnum 1\rightarrow A)\rightarrow A\cong\bbnum 1\quad.
\end{align*}
In this way, we are able to simplify the given type:
\[
\forall A.\,A\rightarrow\bbnum 1+A\cong(\forall A.\,A\rightarrow\bbnum 1)+(\forall A.\,A\rightarrow A)\cong\bbnum 1+\bbnum 1\cong\bbnum 2\quad.
\]

An example of a type where we \emph{can} extract information from
an arbitrary input type is $\forall A.\,A+A\rightarrow\bbnum 1+A$.
Even though the type $A$ is unknown, we can perform pattern-matching
on the input value of type $A+A$ and determine whether the value
is in the left or in the right part of the disjunctive type.

So far, our arguments were not fully rigorous: we relied upon the
intuition that the input type ($A$) carries \textsf{``}no disjunctive information\textsf{''}
and cannot be used, say, in pattern matching. To make this argument
rigorous, we will define the property of being \textsf{``}non-disjunctive\textsf{''}
for type constructors. For such type constructors $P$, we will prove
that fully parametric functions of type $\forall A.\,P^{A}\rightarrow Q^{A}+R^{A}$
must hard-code the decision about the returned disjunctive value. 

\subsubsection{Definition \label{subsec:Definition-non-disjunctive-type-constructors}\ref{subsec:Definition-non-disjunctive-type-constructors}}

A type constructor $P$ is called \index{non-disjunctive type constructor}\textbf{non-disjunctive}\index{type constructor!non-disjunctive}
if for any type constructors $Q$ and $R$ the following type equivalence
holds (assuming that all functions are fully parametric):
\begin{equation}
\forall A.\,P^{A}\rightarrow Q^{A}+R^{A}\cong(\forall A.\,P^{A}\rightarrow Q^{A})+(\forall A.\,P^{A}\rightarrow R^{A})\quad.\label{eq:non-disjunctive-type-equivalence}
\end{equation}
$\square$

The rest of this section is focused on figuring out what type constructors
are non-disjunctive. The main technique will be to use the relational
parametricity theorem with relations that always hold (\textsf{``}full\textsf{''}
relations) and relations that never hold (\textsf{``}empty\textsf{''} relations).

\subsubsection{Definition \label{subsec:Definition-always-true-relation}\ref{subsec:Definition-always-true-relation}}

For any two types $A$ and $B$, we denote by $\Omega^{:A\leftrightarrow B}$
the \textbf{full} relation\index{full relation} of type $A\leftrightarrow B$:
\[
(x^{:A},y^{:B})\in\Omega^{:A\leftrightarrow B}\quad\text{for any }x^{:A}\text{ and }y^{:B}\quad.
\]
By definition, the full relation always holds. The \textbf{empty}
relation,\index{empty relation} denoted by $\emptyset^{:A\leftrightarrow B}$,
\emph{never} holds for any values $(x^{:A},y^{:B})$. $\square$

If one of the types is void (say $A=\bbnum 0$), we get a curious
situation that an empty relation $\emptyset^{:\bbnum 0\leftrightarrow B}$
is at the same time a full relation: $\emptyset^{:\bbnum 0\leftrightarrow B}=\Omega^{:\bbnum 0\leftrightarrow B}$.
This happens because the void type ($\bbnum 0$) has no values; so,
the set of pairs of values $(x^{:\bbnum 0},y^{:B})$ is empty. An
empty set trivially satisfies any \textsf{``}for all\textsf{''} property and any \textsf{``}for
none\textsf{''} property. One can say equally well that the relation $\Omega^{:\bbnum 0\leftrightarrow B}$
holds \textsf{``}for all\textsf{''} $(x^{:\bbnum 0},y^{:B})$ or that it holds \textsf{``}for
no $(x^{:\bbnum 0},y^{:B})$\textsf{''}. 

Here are some useful properties of full and empty relations:

\subsubsection{Statement \label{subsec:Statement-full-empty-combinators}\ref{subsec:Statement-full-empty-combinators}}

The following relational identities hold for any relation $r$:

\textbf{(a)} $\emptyset\boxtimes r=\emptyset$ and $r\boxtimes\emptyset=\emptyset$.

\textbf{(b)} $\Omega\boxtimes\Omega=\Omega$.

\textbf{(c)} $\emptyset\boxplus\emptyset=\emptyset$.

\textbf{(d)} $\Omega\boxplus\Omega\neq\Omega$.

\textbf{(e)} $\emptyset\ogreaterthan r=\Omega$.

\textbf{(f)} $r\ogreaterthan\emptyset=\emptyset$ when $r$ is non-empty.

\textbf{(g)} $r\ogreaterthan\Omega=\Omega$.

\subparagraph{Proof}

We will write out the types of some relations for clarity.

\textbf{(a)} To prove $\emptyset^{:P\leftrightarrow Q}\boxtimes r^{:A\leftrightarrow B}=\emptyset^{:P\times A\leftrightarrow Q\times B}$,
consider two arbitrary values $(p\times a)^{:P\times A}$ and $(q\times b)^{:Q\times B}$.
By definition of the pair product, we have $(p\times a,q\times b)\in\emptyset^{:P\leftrightarrow Q}\boxtimes r^{:A\leftrightarrow B}$
only when $(p,q)\in\emptyset^{:P\leftrightarrow Q}$ and $(a,b)\in r$.
But the relation $(p,q)\in\emptyset$ never holds. So, it is never
true that any values are in the relation $\emptyset^{:P\leftrightarrow Q}\boxtimes r^{:A\leftrightarrow B}$.
The relation $\emptyset\boxtimes r$ is empty. Similarly, we prove
that $r\boxtimes\emptyset=\emptyset$.

\textbf{(b)} To prove $\Omega^{:P\leftrightarrow Q}\boxtimes\Omega^{:A\leftrightarrow B}=\Omega^{:P\times A\leftrightarrow Q\times B}$,
consider two arbitrary values $(p\times a)^{:P\times A}$ and $(q\times b)^{:Q\times B}$.
We have $(p\times a,q\times b)\in\Omega^{:P\leftrightarrow Q}\boxtimes\Omega^{:A\leftrightarrow B}$
only when $(p,q)\in\Omega^{:P\leftrightarrow Q}$ and $(a,b)\in\Omega^{:A\leftrightarrow B}$.
Both relations always hold. So, the relation $\Omega^{:P\leftrightarrow Q}\boxtimes\Omega^{:A\leftrightarrow B}$
always holds; in other words, it is the full relation denoted by $\Omega^{:P\times A\leftrightarrow Q\times B}$.

\textbf{(c)} To prove $\emptyset^{:P\leftrightarrow Q}\boxplus\emptyset^{:A\leftrightarrow B}=\emptyset^{:P+A\leftrightarrow Q+B}$,
consider two values $x^{:P+A}$ and $y^{:Q+B}$. By definition of
the pair co-product, $(x,y)\in\emptyset\boxplus\emptyset$ if either
(1) $x=p^{:P}+\bbnum 0$, $y=q^{:Q}+\bbnum 0$, and $(p,q)\in\emptyset$;
or (2) $x=\bbnum 0+a^{:A}$, $y=\bbnum 0+b^{:B}$, and $(a,b)\in\emptyset$.
Neither of these conditions can hold because the it is never true
that $(p,q)\in\emptyset$ or $(a,b)\in\emptyset$. So, the relation
$\emptyset^{:P\leftrightarrow Q}\boxplus\emptyset^{:A\leftrightarrow B}$
never holds and is empty.

\textbf{(d)} To prove $\Omega^{:P\leftrightarrow Q}\boxplus\Omega^{:A\leftrightarrow B}\neq\Omega^{:P+A\leftrightarrow Q+B}$,
note that the pair co-product relation holds only when both values
are in the left parts of their disjunctive types, or when both values
are in the right parts. This can \emph{never} be a full relation.
A counter-example is found already with the unit types: the relation
$\Omega^{:\bbnum 1\leftrightarrow\bbnum 1}\boxplus\Omega^{:\bbnum 1\leftrightarrow\bbnum 1}$
is of type $\Omega^{:\bbnum 2\leftrightarrow\bbnum 2}$ (that is,
a relation between \lstinline!Boolean! values). That relation holds
only for equal \lstinline!Boolean! values and is not equal to a full
relation.

\textbf{(e)} To prove $\emptyset^{:P\leftrightarrow Q}\ogreaterthan r^{:A\leftrightarrow B}=\Omega^{:(P\rightarrow A)\leftrightarrow(Q\rightarrow B)}$,
write the definition of the relational pair mapper:
\[
(f^{:P\rightarrow A},g^{:Q\rightarrow B})\in\emptyset\ogreaterthan r\quad\text{means}:\quad\text{if}\quad(x^{:P},y^{:Q})\in\emptyset\quad\text{then}\quad(f(x),g(y))\in r\quad.
\]
The pre-condition, $(x,y)\in\emptyset$, is always false. So, the
conditional statement $(f,g)\in\emptyset\ogreaterthan r$ is always
true, meaning that $\emptyset\ogreaterthan r$ is a full relation. 

\textbf{(f)} To prove $r^{:P\leftrightarrow Q}\ogreaterthan\emptyset^{:A\leftrightarrow B}=\emptyset^{:(P\rightarrow A)\leftrightarrow(Q\rightarrow B)}$
when $r$ is non-empty, choose some values $x^{:P}$, $y^{:Q}$ such
that $(x,y)\in r$. Those values exist because $r$ is non-empty.
Then apply the relational pair mapper:
\[
(f^{:P\rightarrow A},g^{:Q\rightarrow B})\in r\ogreaterthan\emptyset\quad\text{means}:\quad\text{if}\quad(x,y)\in r\quad\text{then}\quad(f(x),g(y))\in\emptyset\quad.
\]
We note that $(x,y)\in r$ is true while $(f(x),g(y))\in\emptyset$
is always false. So, no functions $f$ and $g$ could ever be in the
relation $r\ogreaterthan\emptyset$. That relation is empty.

\textbf{(g)} To prove $r^{:P\leftrightarrow Q}\ogreaterthan\Omega^{:A\leftrightarrow B}=\Omega^{:(P\rightarrow A)\leftrightarrow(Q\rightarrow B)}$,
write the relational pair mapper condition:
\[
(f^{:P\rightarrow A},g^{:Q\rightarrow B})\in r\ogreaterthan\Omega\quad\text{means}:\quad\text{if}\quad(x,y)\in r\quad\text{then}\quad(f(x),g(y))\in\Omega\quad.
\]
The condition $(f(x),g(y))\in\Omega$ always holds; it follows that
$(f,g)\in r\ogreaterthan\Omega$ always holds. In other words, $r\ogreaterthan\Omega$
is a full relation. $\square$

Lifting a full or an empty relation to a type constructor will sometimes
(but not always) also produce a full or an empty relation. To describe
those situations, we introduce the following definitions:

\subsubsection{Definition \label{subsec:Definition-lifting-to-true-and-to-false-property}\ref{subsec:Definition-lifting-to-true-and-to-false-property}}

A type constructor $P$ is \index{type constructor!lifting-to-full property}\textsf{``}\textbf{lifting-to-full}\textsf{''}
if for any two types $A$ and $B$  there exists a relation $r^{:A\leftrightarrow B}$
such that $r^{\updownarrow P}=\Omega^{:P^{A}\leftrightarrow P^{B}}$.

A type constructor $P$ is \index{type constructor!lifting-to-empty property}\textsf{``}\textbf{lifting-to-empty}\textsf{''}
if for any two types $A$ and $B$ there exists a relation $r^{:A\leftrightarrow B}$
such that $r^{\updownarrow P}=\emptyset^{:P^{A}\leftrightarrow P^{B}}$.
$\square$

For example, $P^{A}\triangleq A\times A$ is lifting-to-full, because
lifting a full relation $r=\Omega^{:A\leftrightarrow B}$ to $P$
gives again a full relation ($\Omega\boxtimes\Omega=\Omega$). This
$P$ is also lifting-to-empty, because lifting an empty relation $r=\emptyset^{:A\leftrightarrow B}$
to $P$ gives again an empty relation ($\emptyset\boxtimes\emptyset=\emptyset$). 

As another example, consider $P^{A}\triangleq A\rightarrow A$. This
type constructor is lifting-to-full because we may set $r=\Omega$
and obtain $(\Omega^{:A\leftrightarrow B})^{\updownarrow P}=\Omega^{:P^{A}\leftrightarrow P^{B}}$.
It turns out that $P$ is \emph{not} lifting-to-empty: if we set $r=\emptyset^{:A\leftrightarrow B}$
and lift $r^{\updownarrow P}$, the result is again the full relation
(as $\emptyset\ogreaterthan\emptyset=\Omega$). For any non-empty
relation $r^{:A\leftrightarrow B}$ there will exist some values $(a^{:A},b^{:B})\in r$,
and the relation $r^{\updownarrow P}$ will hold for any pair of functions
$(f^{:A\rightarrow A},g^{:B\rightarrow B})$ such that $f(a)=a$ and
$g(b)=b$. So, the relation $r^{\updownarrow P}$ is non-empty for
any $r$.

Some type constructors are neither lifting-to-full nor lifting-to-empty.
A simple example is the disjunctive type constructor $P^{A}\triangleq\bbnum 1+A$.
No matter how we choose $r^{:A\leftrightarrow B}$, the relation $r^{\updownarrow P}$
will hold for a pair of unit values in the left part of $P$; that
is, a pair of values of the form $(1+\bbnum 0^{:A},1+\bbnum 0^{:B})$.
So, the relation $r^{\updownarrow P}$ is never empty. At the same
time, the relation $r^{\updownarrow P}$ will \emph{not} hold for
any pair of values that are in different parts of the disjunctive
type; that is, for pairs of the form $(1+\bbnum 0^{:A},\bbnum 0+b^{:B})$.
So, the lifted relation $r^{\updownarrow P}$ is never full regardless
of the choice of $r$. This is also illustrated by Statement~\ref{subsec:Statement-full-empty-combinators}(d):
even if we lift a full relation to a disjunctive type constructor,
the result is a (non-full) relation that holds only for values belonging
to the same part of the disjunctive type.

We see that lifting any relation to a disjunctive type constructor
cannot give a full relation. So, if we know that some lifted relation
$r^{\updownarrow P}$ is full, we may expect that the type constructor
$P$ does not contain a disjunctive type at the top level. The following
statement makes this intuition precise.

\subsubsection{Statement \label{subsec:Statement-undisjunctive-type-constructors-relational}\ref{subsec:Statement-undisjunctive-type-constructors-relational}}

If a type constructor $P$ is lifting-to-full and not identically
void ($P^{A}\neq\bbnum 0$ for some $A$) then $P$ is non-disjunctive.

\subparagraph{Proof}

Choose a type $A$ for which $P^{A}\neq\bbnum 0$, and a value $x_{0}:P^{A}$.
As $P$ is lifting-to-full, for any type $B$ there will exist a relation
$r^{:A\leftrightarrow B}$ such that $r^{\updownarrow P}=\Omega^{:P^{A}\leftrightarrow P^{B}}$.
Denote for brevity $p\triangleq f^{A}:P^{A}\rightarrow Q^{A}+R^{A}$
and $q\triangleq f^{B}:P^{B}\rightarrow Q^{B}+R^{B}$. Then the relational
parametricity law for functions $f:\forall A.\,P^{A}\rightarrow Q^{A}+R^{A}$
says that the functions $p$ and $q$ will satisfy the condition:
\[
\forall x^{:P^{A}},y^{:P^{B}}:\quad\text{if}\quad(x,y)\in r^{\updownarrow P}\quad\text{then}\quad(p(x),q(y))\in r^{\updownarrow Q}\boxplus r^{\updownarrow R}\quad.
\]
Substitute $x=x_{0}$ into this condition:
\[
\forall y^{:P^{B}}:\quad(p(x_{0}),q(y))\in r^{\updownarrow Q}\boxplus r^{\updownarrow R}\quad.
\]
By definition of the relational co-product $r^{\updownarrow Q}\boxplus r^{\updownarrow R}$,
the values $p(x_{0})$ and $q(y)$ must be in the same parts of the
disjunctive type $Q^{...}+R^{...}$. 

There are two possibilities: $p(x_{0})$ and $q(y)$ are in the first
or in the second part of that disjunctive type. Let us first suppose
they belong to the first part ($Q^{...}+\bbnum 0$). Then we must
have $p(x_{0})=s_{0}^{:Q^{A}}+\bbnum 0^{:R^{A}}$ and $q(y)=t(y)^{:Q^{B}}+\bbnum 0^{:R^{B}}$
with some values $s_{0}$ and $t(y)$. It follows that $q(y)$ is
in the first part of the disjunctive type, for \emph{any} $y:P^{B}$. 

It can happen that, for certain types $B$, the type $P^{B}=\bbnum 0$,
meaning that there are no values $y$ of type $P^{B}$, and there
is nothing we need to say about values $q(y)$. But for all other
types $B$ and for all $y:P^{B}$ the function $q$ must be such that
the value $q(y)$ belongs to the first part ($Q^{...}+\bbnum 0$)
of the disjunctive type $Q^{...}+R^{...}$.

By definition, $q$ is just $f^{B}$ (the polymorphic function $f$
used with the type parameter $B$). So, we have shown that $f^{B}$
is equivalent to a function of type $P^{B}\rightarrow Q^{B}+\bbnum 0^{:R^{B}}$.
It means that $f$ is equivalent to a function of type $\forall B.\,P^{B}\rightarrow Q^{B}$.

The other possibility is when the values $p(x_{0})$ and $q(y)$ are
in the second part of the disjunctive type $Q^{...}+R^{...}$. Then
a similar argument shows that $q(y)$ is of type $\bbnum 0+R^{...}$
for all $y$, which means that $f$ is equivalent to a function of
type $\forall B.\,P^{B}\rightarrow R^{B}$.

We conclude that full parametricity forces any function $f:\forall A.\,P^{A}\rightarrow Q^{A}+R^{A}$
to be either equivalent to a function of type $\forall A.\,P^{A}\rightarrow Q^{A}+\bbnum 0^{:R^{A}}$
or to a function of type $\forall A.\,P^{A}\rightarrow\bbnum 0^{:Q^{A}}+R^{A}$.
In this way, we have proved the type equivalence:
\begin{align*}
 & \forall A.\,P^{A}\rightarrow Q^{A}+R^{A}\cong\big(\forall A.\,P^{A}\rightarrow Q^{A}+\bbnum 0^{:R^{A}}\big)+\big(\forall A.\,P^{A}\rightarrow\bbnum 0^{:Q^{A}}+R^{A}\big)\\
 & \cong(\forall A.\,P^{A}\rightarrow Q^{A})+(\forall A.\,P^{A}\rightarrow R^{A})\quad.
\end{align*}

Our proof of this type equivalence is \emph{not} constructive. In
the proof, we have shown that $q(y)$ is either in the first or in
the second part of a disjunctive type, for all $y:P^{B}$. This is
true, but we cannot write code that substitutes some values of $y$
to find out in which part $q(y)$ is, because we do not have values
$y:P^{B}$ available for an arbitrary type $B$. Only one direction
of the type isomorphism is constructive: one can write a function
converting a value of type $(\forall A.\,P^{A}\rightarrow Q^{A})+(\forall A.\,P^{A}\rightarrow R^{A})$
into a value of type $\forall A.\,P^{A}\rightarrow Q^{A}+R^{A}$.
$\square$

We will now use structural analysis to discover which type constructors
are non-disjunctive.

\subsubsection{Statement \label{subsec:Statement-undisjunctive-type-constructors-structural}\ref{subsec:Statement-undisjunctive-type-constructors-structural}}

\textbf{(a)} It is \emph{not} true that a product of two non-disjunctive
type constructors is always non-disjunctive.

A type constructor $P$ is lifting-to-full when:

\textbf{(b)} $P^{A}\triangleq\bbnum 1$$\quad$.

\textbf{(c)} $P^{A}\triangleq A$$\quad$.

\textbf{(d)} $P^{A}\triangleq K^{A}\rightarrow L^{A}$ where $K$
is arbitrary and $L$ is lifting-to-full.

\textbf{(e)} $P^{A}\triangleq K^{A}\rightarrow L^{A}$ where $K$
is lifting-to-empty and $L$ is arbitrary.

A type constructor $P$ is lifting-to-empty when:

\textbf{(f)} $P^{A}\triangleq A$. (Compare with item \textbf{(b)}
to see that a type constructor can be lifting-to-full and lifting-to-empty
at the same time.)

\textbf{(g)} $P^{A}\triangleq K^{A}\times L^{A}$ where $K$ is lifting-to-empty
and $L$ is arbitrary.

\textbf{(h)} $P^{A}\triangleq K^{A}\rightarrow L^{A}$ where $K$
is \emph{not} lifting-to-empty and $L$ is lifting-to-empty.

\subparagraph{Proof}

\textbf{(a)} Consider $P^{A}\triangleq K^{A}\times L^{A}$ where $K^{A}\triangleq A$
and $L^{A}\triangleq A\rightarrow\bbnum 2$. Both $K$ and $L$ are
non-disjunctive by this statement\textsf{'}s items \textbf{(c)} and \textbf{(d)}.
However, the type $\forall A.\,A\times(A\rightarrow\bbnum 2)\rightarrow Q^{A}+R^{A}$
admits functions that do not always return a hard-coded value of type
either $Q^{A}+\bbnum 0$ or $\bbnum 0+R^{A}$. A counter-example is:
\begin{align*}
 & f:\forall A.\,A\times(A\rightarrow\bbnum 2)\rightarrow Q^{A}+R^{A}\quad,\\
 & f^{A}\triangleq a^{:A}\times b^{:A\rightarrow\bbnum 2}\rightarrow b(a)\triangleright\,\begin{array}{|c||cc|}
 & Q^{A} & R^{A}\\
\hline \bbnum 1 & \_\rightarrow q(a) & \bbnum 0\\
\bbnum 1 & \bbnum 0 & \_\rightarrow r(a)
\end{array}\quad,
\end{align*}
where $q:A\rightarrow Q^{A}$ and $r:A\rightarrow R^{A}$ are some
functions (that we could assume to exist, for the purpose of this
example). The function $f$ returns different parts of the disjunction
$Q^{A}+R^{A}$ depending on its input value (of type $P^{A}$). So,
the type expression $P^{A}$ appears to contain \textsf{``}disjunctive information\textsf{''};
that is, $P$ fails to be non-disjunctive.

\textbf{(b)} The unit type ($\bbnum 1$) has only one distinct value.
So, any relation $r^{:A\leftrightarrow B}$ lifted to $P^{A}\triangleq\bbnum 1$
will give an identity relation of type $\bbnum 1\leftrightarrow\bbnum 1$.
That relation is the same as the full relation $\Omega^{:\bbnum 1\leftrightarrow\bbnum 1}$.

\textbf{(c)} Lift a full relation $\Omega^{:A\leftrightarrow B}$
to $P^{A}\triangleq A$ and obtain again $\Omega^{:A\leftrightarrow B}$.

\textbf{(d)} Choose $r^{:A\leftrightarrow B}$ such that $r^{\updownarrow L}=\Omega^{:L^{A}\leftrightarrow L^{B}}$
and lift that $r$ to $P$. The result is:
\[
r^{\updownarrow P}=r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}=r^{\updownarrow K}\ogreaterthan\Omega\quad.
\]
By Statement~\ref{subsec:Statement-full-empty-combinators}(g), we
have $r^{\updownarrow K}\ogreaterthan\Omega=\Omega$.

\textbf{(e)} Choose $r^{:A\leftrightarrow B}$ such that $r^{\updownarrow K}=\emptyset^{:K^{A}\leftrightarrow K^{B}}$
and lift that $r$ to $P$. The result is:
\[
r^{\updownarrow P}=r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}=\emptyset\ogreaterthan r^{\updownarrow L}\quad.
\]
By Statement~\ref{subsec:Statement-full-empty-combinators}(e), we
have $\emptyset\ogreaterthan r^{\updownarrow L}=\Omega$.

\textbf{(f)} Lift an empty relation $\emptyset^{:A\leftrightarrow B}$
to $P^{A}\triangleq A$ and obtain again $\emptyset^{:A\leftrightarrow B}$.

\textbf{(g)} Choose $r^{:A\leftrightarrow B}$ such that $r^{\updownarrow K}=\emptyset^{:K^{A}\leftrightarrow K^{B}}$
and lift that $r$ to $P$. The result is:
\[
r^{\updownarrow P}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}=\emptyset\boxtimes r^{\updownarrow L}\quad.
\]
By Statement~\ref{subsec:Statement-full-empty-combinators}(a), we
have $\emptyset\boxtimes r^{\updownarrow L}=\emptyset$.

\textbf{(h)} By assumption, $K$ is \emph{not} lifting-to-empty, which
means that there exist types $A$, $B$ such that \emph{any} relation
$r^{:A\leftrightarrow B}$ is lifted to a relation $r^{\updownarrow K}$
that is non-empty. As $L$ is lifting-to-empty, we can choose $r^{:A\leftrightarrow B}$
such that $r^{\updownarrow L}=\emptyset^{:L^{A}\leftrightarrow L^{B}}$.
Now lift that relation $r$ to $P$ and obtain:
\[
r^{\updownarrow P}=r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}=r^{\updownarrow K}\ogreaterthan\emptyset\quad.
\]
By Statement~\ref{subsec:Statement-full-empty-combinators}(f), we
have $r^{\updownarrow K}\ogreaterthan\emptyset=\emptyset$. $\square$

The following examples will help build up more intuition.

\subsubsection{Example \label{subsec:Example-undisjunctive-type-constructors}\ref{subsec:Example-undisjunctive-type-constructors}\index{examples}}

\textbf{(a)} Show that $P^{A}\triangleq A\rightarrow A$ is lifting-to-full
but \emph{not} lifting-to-empty.

\textbf{(b)} Show that $P^{A}\triangleq\bbnum 1+A\rightarrow A$ is
both lifting-to-full and lifting-to-empty.

\textbf{(c)} Show that $P^{A}\triangleq F^{A}\rightarrow A$ is lifting-to-full
for any $F$.

\textbf{(d)} Show that $P^{A}\triangleq\underbrace{A\times...\times A}_{n\text{ times, }n\geq1}$
is both lifting-to-full and lifting-to-empty.

It follows from Statement~\ref{subsec:Statement-undisjunctive-type-constructors-relational}
that all those type constructors are non-disjunctive. In particular,
for any type constructors $F$, $G$ (not necessarily covariant or
contravariant), we have:

\textbf{(e)} $\forall A.\,F^{A}+G^{A}\cong(\forall A.\,F^{A})+(\forall A.\,G^{A})$.

\textbf{(f)} $\forall A.\,\underbrace{A\times...\times A}_{n\text{ times, }n\geq1}\rightarrow F^{A}+G^{A}\cong(\forall A.\,A\times...\times A\rightarrow F^{A})+(\forall A.\,A\times...\times A\rightarrow G^{A})$.

\subparagraph{Solution}

\textbf{(a)} We know from Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(c)
that $L^{A}\triangleq A$ is lifting-to-full. It follows from Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(d)
with $K^{A}\triangleq L^{A}\triangleq A$ that $P$ is also lifting-to-full.

To show that $P$ is not lifting-to-empty, it is sufficient to demonstrate
that for any relation $r^{:A\leftrightarrow B}$ there exist $x^{:P^{A}}$
and $y^{:P^{B}}$ such that $(x,y)\in r^{\updownarrow P}$. Write
out the condition $(x,y)\in r^{\updownarrow P}$:
\[
(x,y)\in r^{\updownarrow P}\quad\text{means}\quad\text{if}\quad(a^{:A},b^{:B})\in r\quad\text{then}\quad(x(a),y(b))\in r\quad.
\]
If we choose $x\triangleq\text{id}^{:A\rightarrow A}$ and $y\triangleq\text{id}^{:B\rightarrow B}$,
we will have $(x(a),y(b))=(a,b)$. Then the condition becomes: if
$(a,b)\in r$ then $(a,b)\in r$. This is true for any $r$. So, $(x,y)\in r^{\updownarrow P}$
holds.

\textbf{(b)} We know from Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(c,f)
that $L^{A}\triangleq A$ is both lifting-to-full and lifting-to-empty.
By Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(d)
with $K^{A}\triangleq\bbnum 1+A$ and $L^{A}\triangleq A$, we find
that $K^{A}\rightarrow L^{A}$ is lifting-to-full. To show that $K^{A}\rightarrow L^{A}$
is lifting-to-empty, we can use Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(h)
if we prove that $K^{A}$ is \emph{not} lifting-to-empty. Lifting
any relation $r^{:A\leftrightarrow B}$ to $K$, we find:
\[
r^{\updownarrow K}=\text{id}^{:\bbnum 1\leftrightarrow\bbnum 1}\boxplus r\quad.
\]
The pair of values $x^{:K^{A}}\triangleq1+\bbnum 0^{:A}$ and $y^{:K^{B}}\triangleq1+\bbnum 0^{:B}$
are always in the relation $\text{id}\boxplus r$. In this way, we
have shown that $r^{\updownarrow K}$ is not empty. 

By Statement~\ref{subsec:Statement-undisjunctive-type-constructors-relational}(h),
the type constructor $P$ is non-disjunctive. 

Note that the type expression $\bbnum 1+A\rightarrow A$ contains
a disjunctive type but can be rewritten equivalently as $P^{A}\cong(\bbnum 1\rightarrow A)\times(A\rightarrow A)$,
which no longer contains a disjunctive type.

\textbf{(c)} We have shown in Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(c)
$L^{A}\triangleq A$ is lifting-to-full. It remains to use Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(d)
with $K^{A}\triangleq F^{A}$ to conclude that $P^{A}=K^{A}\rightarrow L^{A}=F^{A}\rightarrow A$
is lifting-to-full.

\textbf{(d)} We rewrite $P$ as $P^{A}=R\rightarrow A$ where $R$
is a fixed type of the form $R=\bbnum 1+...+\bbnum 1$. By Statement~\ref{subsec:Statement-undisjunctive-type-constructors-relational}(c,d),
$P$ is lifting-to-full. Also, $P$ is lifting-to-empty by Statement~\ref{subsec:Statement-undisjunctive-type-constructors-relational}(f,g).

\textbf{(e)} The type $F^{A}+G^{A}$ is equivalent to $\bbnum 1\rightarrow F^{A}+G^{A}$.
By Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}(b),
the type constructor $P^{A}\triangleq\bbnum 1$ is lifting-to-full
and so it is non-disjunctive. The non-disjunctivity of the unit type
means that:
\begin{align*}
 & \forall A.\,\bbnum 1\rightarrow F^{A}+G^{A}\cong(\forall A.\,\bbnum 1\rightarrow F^{A})+(\forall A.\,\bbnum 1\rightarrow G^{A})\\
 & \cong(\forall A.\,F^{A})+(\forall A.\,G^{A})\quad.
\end{align*}

\textbf{(f)} The type constructor $P^{A}\triangleq\underbrace{A\times...\times A}_{n\text{ times, }n\geq1}$
is non-disjunctive because it is lifting-to-full, as we showed in
item (d). $\square$

We will now show some application of these techniques.

\subsubsection{Statement \label{subsec:Statement-application-full-relation}\ref{subsec:Statement-application-full-relation}}

Suppose $K$ is any fixed type and $P$ is any type constructor that
is lifting-to-full. Then we have the following type equivalence (assuming
full parametricity):
\[
\forall A.\,P^{A}\rightarrow K\cong K\quad.
\]


\subparagraph{Proof}

Consider a value $h:\forall A.\,P^{A}\rightarrow K$. We view $K$
as the result of applying a constant functor to $A$. Let us denote
that functor temporarily by $Q$:
\[
Q^{A}\triangleq K\quad,\quad\quad\forall A.\,P^{A}\rightarrow K=\forall A.\,P^{A}\rightarrow Q^{A}\quad.
\]
By assumption, $P$ is lifting-to-full, so for any types $A$, $B$
we may choose a relation $r^{:A\leftrightarrow B}$ such that $r^{\updownarrow P}=\Omega$.
Then the relational naturality law of $h$ says that for any $x^{:P^{A}}$and
$y^{:P^{B}}$:
\[
\text{when }(x,y)\in r^{\updownarrow P}\text{ then }(h(x),h(y))\in r^{\updownarrow Q}\quad.
\]
The precondition $(x,y)\in r^{\updownarrow P}$ holds for all $x$
and $y$ because $r^{\updownarrow P}=\Omega$. The lifting of any
relation to a constant functor ($r^{\updownarrow Q}$) is an identity
relation ($\text{id}^{:K\leftrightarrow K}$). We conclude that $h(x)=h(y)$
for all $x$ and $y$, which means that $h$ is a constant function
($h=\_\rightarrow k_{0}$) determined by a chosen value $k_{0}^{:K}$.
Values $k_{0}$ of type $K$ are in a one-to-one correspondence with
functions $h$ of type $\forall A.\,P^{A}\rightarrow K$ that satisfy
the relational naturality law. This proves the required type equivalence. 

\subsubsection{Statement \label{subsec:Example-simplify-quantifier-1-1}\ref{subsec:Example-simplify-quantifier-1-1}}

If $H$ is a contrafunctor then $\forall A.\,(H^{A}\rightarrow A)\rightarrow A\cong H^{\bbnum 1}$.

\subparagraph{Proof}

Consider the type constructor $F^{A,B}\triangleq(H^{B}\rightarrow A)\rightarrow A$;
our goal is to simplify $\forall A.\,F^{A,A}$. Since $F^{A,B}$ is
contravariant in $B$, we may use the contravariant Yoneda identity:
\[
F^{A,B}\cong\forall C.\,(C\rightarrow B)\rightarrow F^{A,C}=\forall C.\,(C\rightarrow B)\rightarrow(H^{C}\rightarrow A)\rightarrow A\quad.
\]
Now substitute $B=A$ and write:
\begin{align*}
 & \forall A.\,F^{A,A}=\gunderline{\forall A.\,\forall C.\,}(C\rightarrow A)\rightarrow(H^{C}\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{swap the order of quantifiers}:}\quad & \cong\forall C.\,\forall A.\,(\gunderline C\rightarrow A)\rightarrow(\gunderline{H^{C}}\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{uncurry arguments}:}\quad & \cong\forall C.\,\forall A.\,(C+H^{C}\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{covariant Yoneda identity}:}\quad & \cong\forall C.\,C+H^{C}\\
{\color{greenunder}\text{non-disjunctivity}:}\quad & \cong(\forall C.\,C)+(\forall C.\,H^{C})\\
{\color{greenunder}\text{simplify each part}:}\quad & \cong\bbnum 0+H^{\bbnum 1}\cong H^{\bbnum 1}\quad.
\end{align*}


\subsubsection{Statement \label{subsec:Statement-advanced-type-equivalence}\ref{subsec:Statement-advanced-type-equivalence}}

For fixed types $P$, $Q$, the following type equivalences hold under
assumptions of parametricity:

\textbf{(a)} $\forall A.\,((A\rightarrow A)\rightarrow P)\rightarrow Q\cong P\rightarrow Q\quad.$

\textbf{(b)} $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow A=T\cong\bbnum 1+\bbnum 2+\bbnum 3+...\quad.$
The \textsf{``}infinite\textsf{''} type in the right-hand side could be understood
as the type of pairs of natural numbers $\left(n,k\right)$ such that
$n\ge k\ge1$. A value of type $T$ corresponding to the pair $\left(n,k\right)$
and applied to the type parameter $A$ can be written as:
\[
t_{n,k}^{A}\triangleq p^{:(A\rightarrow A)\rightarrow A}\rightarrow p(a_{1}^{:A}\rightarrow p(a_{2}^{:A}\rightarrow...\rightarrow p(a_{n}^{:A}\rightarrow a_{k})...))\quad.
\]

\textbf{(c)} $\forall A.\,(((P\rightarrow A)\rightarrow A)\rightarrow A)\rightarrow A\cong P\times(\bbnum 1+\bbnum 2+\bbnum 3+...)\quad.$

\subparagraph{Proof}

\textbf{(a)} The given type is of the form $\forall A.\,F^{A\rightarrow A}$
with $F^{X}\triangleq(X\rightarrow P)\rightarrow Q$. Since $F$ is
a functor, we may use Example~\ref{subsec:Example-simplify-quantifier-1}
to obtain: 
\[
\forall A.\,F^{A\rightarrow A}\cong F^{\bbnum 1}=(\bbnum 1\rightarrow P)\rightarrow Q\cong P\rightarrow Q\quad.
\]
The isomorphism between $\forall A.\,((A\rightarrow A)\rightarrow P)\rightarrow Q$
and $P\rightarrow Q$ is implemented by the following code:
\begin{align*}
 & f:(P\rightarrow Q)\rightarrow\forall A.\,((A\rightarrow A)\rightarrow P)\rightarrow Q\quad,\quad f(x)^{A}\triangleq q^{:(A\rightarrow A)\rightarrow P}\rightarrow x(q(\text{id}))\quad,\\
 & g:(\forall A.\,((A\rightarrow A)\rightarrow P)\rightarrow Q)\rightarrow P\rightarrow Q\quad,\quad g(y)\triangleq p^{:P}\rightarrow y^{\bbnum 1}(\_^{:\bbnum 1\rightarrow\bbnum 1}\rightarrow p)\quad.
\end{align*}

\textbf{(b)} Rewrite{*}{*}{*}the given type using various type identities:
\begin{align*}
 & \forall A.\,((\gunderline A\rightarrow A)\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{Yoneda identity}:}\quad & \cong\forall A.\,\forall B.\,\gunderline{(B\rightarrow A)\rightarrow((B\rightarrow A)\rightarrow A)}\rightarrow A\\
{\color{greenunder}\text{uncurry}:}\quad & \cong\forall A.\,\forall B.\,(\gunderline B\rightarrow A)\times(\gunderline{(B\rightarrow A)}\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{distributive law of }(\times):}\quad & \cong\forall A.\,\forall B.\,(B+(B\rightarrow A)\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{define }F^{B,X}\triangleq B+(B\rightarrow X):}\quad & =\forall A.\,\forall B.\,(F^{B,A}\rightarrow A)\rightarrow A=\forall B.\,\forall A.\,(F^{B,A}\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{Church encoding}:}\quad & =\forall B.\,\text{LFix}(F^{B,\bullet})\quad.
\end{align*}
Denote for convenience the recursive type $T^{B}\triangleq\text{LFix}(F^{B,\bullet})$
and unroll the recursion a few times:
\begin{align*}
 & \forall B.\,T^{B}\cong\forall B.\,B+(B\rightarrow T^{B})\\
{\color{greenunder}\text{non-disjunctivity}:}\quad & \cong(\forall B.\,B)+(\forall B.\,B\rightarrow T^{B})\cong\bbnum 0+\forall B.\,B\rightarrow T^{B}\\
{\color{greenunder}\text{unroll again}:}\quad & \cong\forall B.\,B\rightarrow B+(B\rightarrow T^{B})\quad.
\end{align*}
Note that the identity functor ($\text{Id}^{B}\triangleq B$) is non-disjunctive,
so we have:
\[
\forall B.\,B\rightarrow P^{B}+Q^{B}\cong(\forall B.\,B\rightarrow P^{B})+(\forall B.\,B\rightarrow Q^{B})\quad.
\]
It follows that:
\begin{align*}
 & \forall B.\,B\rightarrow B+(B\rightarrow T^{B})\cong(\gunderline{\forall B.\,B\rightarrow B})+(\forall B.\,\gunderline{B\rightarrow B}\rightarrow T^{B})\\
{\color{greenunder}\text{simplify, uncurry}:}\quad & \cong\bbnum 1+\forall B.\,B\times B\rightarrow T^{B}\\
{\color{greenunder}\text{unroll again}:}\quad & \cong\bbnum 1+\forall B.\,B\times B\rightarrow B+(B\rightarrow T^{B})\quad.
\end{align*}
The functor $B\times B$ is non-disjunctive (see Example~\ref{subsec:Example-undisjunctive-type-constructors}d).
So, we may continue reducing the type as:
\begin{align*}
 & \bbnum 1+\forall B.\,B\times B\rightarrow B+(B\rightarrow T^{B})\cong\bbnum 1+(\gunderline{\forall B.\,B\times B\rightarrow B})+(\forall B.\,\gunderline{B\times B\rightarrow B}\rightarrow T^{B})\\
 & \cong\bbnum 1+\bbnum 2+\forall B.\,B\times B\times B\rightarrow T^{B}\quad.
\end{align*}
Continue using induction to show that $\forall B.\:T^{B}\cong\bbnum 1+\bbnum 2+\bbnum 3+...$,
where the infinite co-product implies a suitable recursively defined
type.

\textbf{(c)} Rewrite the given type using various type identities:
{*}{*}{*}
\begin{align*}
 & \forall A.\,((R\times(P\rightarrow A)\rightarrow Q\times A)\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{Yoneda identity}:}\quad & \cong\forall A.\,\forall B.\,\gunderline{(B\rightarrow A)\rightarrow((R\rightarrow(P\rightarrow B)\rightarrow Q\times A)\rightarrow A)}\rightarrow A\\
{\color{greenunder}\text{uncurry}:}\quad & \cong\forall A.\,\forall B.\,(\gunderline B\rightarrow A)\times(\gunderline{(R\rightarrow(P\rightarrow B)\rightarrow Q\times A)}\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{distributive law of }(\times):}\quad & \cong\forall A.\,\forall B.\,(B+(R\rightarrow(P\rightarrow B)\rightarrow Q\times A)\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{define }F^{B,X}\triangleq B+(R\rightarrow(P\rightarrow B)\rightarrow Q\times X):}\quad & =\forall A.\,\forall B.\,(F^{B,A}\rightarrow A)\rightarrow A=\forall B.\,\forall A.\,(F^{B,A}\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{Church encoding}:}\quad & =\forall B.\,\text{LFix}(F^{B,\bullet})\quad.
\end{align*}
\begin{align*}
 & \text{Let }\mu X.\,F^{B,X}=T^{B}\quad\text{and}\quad\forall B.\,T^{B}=U_{0}\quad.\quad\text{Then}:\quad U_{0}=\forall B.\,B+(R\rightarrow(P\rightarrow B)\rightarrow Q\times T^{B})\quad.\\
 & =\forall B.\,R\rightarrow(P\rightarrow B)\rightarrow Q\times T^{B}=\big(\forall B.\,R\rightarrow(P\rightarrow B)\rightarrow Q\big)\times\big(\gunderline{\forall B.\,R\rightarrow(P\rightarrow B)\rightarrow T^{B}}\big)\triangleq(R\rightarrow Q)\times U_{1}\\
 & =(R\rightarrow Q)\times\big(\forall B.\,R\rightarrow(P\rightarrow B)\rightarrow B+(R\rightarrow(P\rightarrow B)\rightarrow Q\times T^{B})\big)\\
 & =(R\rightarrow Q)\times(\forall B.\,R\rightarrow(P\rightarrow B)\rightarrow B)+(R\rightarrow Q)\times\big(\forall B.\,R\rightarrow(P\rightarrow B)\rightarrow(P\rightarrow B)\rightarrow Q\big)\times U_{2}\\
 & =(R\rightarrow Q)\times(R\rightarrow P)+(R\rightarrow Q)\times(R\rightarrow Q)\times U_{2}\quad,
\end{align*}
where we defined:
\[
U_{n}\triangleq\forall B.\,R\rightarrow\underbrace{(P\rightarrow B)\rightarrow...\rightarrow(P\rightarrow B)}_{n\text{ times}}\rightarrow T^{B}\quad.
\]
We can express each $U_{i}$ via $U_{i+1}$ like this:
\begin{align*}
 & U_{0}=(R\rightarrow Q)\times U_{1}\quad,\\
 & U_{1}=(R\rightarrow P)+(R\rightarrow Q)\times U_{2}\quad,\\
 & U_{2}=(R\rightarrow P)\times\bbnum 2+(R\rightarrow Q)\times U_{3}\quad,
\end{align*}
and so on. By induction, we obtain:
\[
U_{0}=(R\rightarrow P)\times\big((R\rightarrow Q)+\bbnum 2\times(\bbnum 2\rightarrow R\rightarrow Q)+\bbnum 3\times(\bbnum 3\rightarrow R\rightarrow Q)+...
\]

{*}{*}{*} $\square$

There exist complicated quantified types that cannot be simplified
by any of the techniques shown in this Appendix. An example is the
codensity monad\index{monads!codensity monad} on \lstinline!Option!:
\[
\text{Cod}_{\text{Opt}}^{A}\triangleq\forall R.\,(A\rightarrow\bbnum 1+R)\rightarrow\bbnum 1+R\quad.
\]
It can be proved using methods of dependent type theory\footnote{See \texttt{\href{https://stackoverflow.com/questions/75178350/}{https://stackoverflow.com/questions/75178350/}}}
that $\text{Cod}_{\text{Opt}}^{A}\cong(A\rightarrow\bbnum 2)\rightarrow\bbnum 1+A$
with the additional restriction that values $q:(A\rightarrow\bbnum 2)\rightarrow\bbnum 1+A$
must satisfy: $q(p^{:A\rightarrow\bbnum 2})=\bbnum 0+x^{:A}$ only
if $p(x)=True$. This restriction on values can be encoded in a type
signature only via dependent types.

So, $\text{Cod}_{\text{Opt}}^{A}$ is an example of a universally
quantified type that cannot be reduced to an ordinary (non-dependent,
non-quantified) type. There seems to be no simplification that could
apply to types of the form $\forall R.\,(A\rightarrow F^{R})\rightarrow G^{R}$
with arbitrary $F$ and $G$.

\subsection{Other properties of universal type quantifiers}

\subsubsection{Statement \label{subsec:Statement-isomorphism-under-type-constructor}\ref{subsec:Statement-isomorphism-under-type-constructor}}

\textbf{(a)} Suppose $F$ is a fully parametric type constructor (but
not necessarily covariant or contravariant), and $P$, $Q$ are two
types having an isomorphism $P\cong Q$. Then $F^{P}\cong F^{Q}$.

\textbf{(b)} Suppose $F$ and $G$ are type constructors such that
$F^{A}\cong G^{A}$ for all types $A$. Then:
\[
\forall A.\,F^{A}\cong\forall A.\,G^{A}\quad.
\]


\subparagraph{Proof}

\textbf{(a)} A fully parametric type constructor will have some type
parameter occurrences in a covariant position and others in a contravariant
position. So, it will have an \lstinline!xmap! method (see Section~\ref{subsec:f-Profunctors}):
\[
\text{xmap}_{F}:\forall A.\,\forall B.\,(A\rightarrow B)\rightarrow(B\rightarrow A)\rightarrow F^{A}\rightarrow F^{B}\quad.
\]
An isomorphism between $P$ and $Q$ means having two functions $f_{1}^{:P\rightarrow Q}$
and $f_{2}^{:Q\rightarrow P}$ such that $f_{1}\bef f_{2}=\text{id}$
and $f_{2}\bef f_{1}=\text{id}$. Applying \lstinline!xmap! to those
two functions in one or another order, we obtain two new functions
of the following types:
\begin{align*}
 & g_{12}:F^{P}\rightarrow F^{Q}\quad,\quad\quad g_{12}\triangleq\text{xmap}_{F}(f_{1})(f_{2})\quad,\\
 & g_{21}:F^{Q}\rightarrow F^{P}\quad,\quad\quad g_{21}\triangleq\text{xmap}_{F}(f_{2})(f_{1})\quad.
\end{align*}
Because of the laws of \lstinline!xmap!, we find that $g_{12}$ and
$g_{21}$ are mutual inverses:
\begin{align*}
 & g_{12}\bef g_{21}=\text{xmap}_{F}(f_{1})(f_{2})\bef\text{xmap}_{F}(f_{2})(f_{1})\\
 & \quad=\text{xmap}_{F}(f_{1}\bef f_{2})(f_{2}\bef f_{1})=\text{xmap}_{F}(\text{id})(\text{id})=\text{id}\quad,\\
 & g_{21}\bef g_{12}=\text{xmap}_{F}(f_{2})(f_{1})\bef\text{xmap}_{F}(f_{1})(f_{2})\\
 & \quad=\text{xmap}_{F}(f_{2}\bef f_{1})(f_{1}\bef f_{2})=\text{xmap}_{F}(\text{id})(\text{id})=\text{id}\quad.
\end{align*}
This demonstrates an isomorphism $F^{P}\cong F^{Q}$.

\textbf{(b)} An isomorphism $F^{A}\cong G^{A}$ means that there is
a pair of functions,
\begin{align*}
 & f_{1}^{A}:F^{A}\rightarrow G^{A}\quad,\quad\quad f_{2}^{A}:G^{A}\rightarrow F^{A}\quad,\\
{\color{greenunder}\text{such that for all }A:}\quad & f_{1}^{A}\bef f_{2}^{A}=\text{id}\quad\text{and}\quad f_{2}^{A}\bef f_{1}^{A}=\text{id}\quad.
\end{align*}
To implement an isomorphism $\forall A.\,F^{A}\cong\forall A.\,G^{A}$,
we define two functions:
\begin{align*}
 & g_{1}:(\forall A.\,F^{A})\rightarrow\forall B.\,G^{B}\quad,\quad\quad g_{2}:(\forall B.\,G^{B})\rightarrow\forall A.\,F^{A}\quad,\\
 & g_{1}\triangleq x^{:\forall A.\,F^{A}}\rightarrow\forall B.\,f_{1}^{B}(x^{B})\quad,\quad\quad g_{2}\triangleq y^{:\forall B.\,G^{B}}\rightarrow\forall A.\,f_{2}^{A}(y^{A})\quad.
\end{align*}
It remains to show that those functions are mutual inverses:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & g_{1}\bef g_{2}=x^{:\forall A.\,F^{A}}\rightarrow\forall A.\,\gunderline{f_{2}^{A}(f_{1}^{A}}(x^{A}))\\
{\color{greenunder}\text{use }f_{1}^{A}\bef f_{2}^{A}=\text{id}:}\quad & \quad=x^{:\forall A.\,F^{A}}\rightarrow\forall A.\,x^{A}=x^{:\forall A.\,F^{A}}\rightarrow x=\text{id}\quad,\\
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & g_{2}\bef g_{1}=y^{:\forall B.\,G^{B}}\rightarrow\forall B.\,\gunderline{f_{1}^{B}(f_{2}^{B}}(y^{B}))\\
{\color{greenunder}\text{use }f_{2}^{B}\bef f_{1}^{B}=\text{id}:}\quad & \quad=y^{:\forall B.\,G^{B}}\rightarrow\forall B.\,y^{B}=y^{:\forall B.\,G^{B}}\rightarrow y=\text{id}\quad.
\end{align*}


\subsubsection{Statement \label{subsec:Statement-general-identities-forall}\ref{subsec:Statement-general-identities-forall}}

For any type constructors $F$, $G$ (not necessarily covariant or
contravariant) and for any fixed type $R$, the following type isomorphisms
hold under assumptions of full parametricity:
\begin{align*}
{\color{greenunder}\text{(a)}:}\quad & \forall X.\,F^{X}+G^{X}\cong(\forall Y.\,F^{Y})+(\forall Z.\,G^{Z})\quad,\\
{\color{greenunder}\text{(b)}:}\quad & \forall X.\,F^{X}\times G^{X}\cong(\forall Y.\,F^{Y})\times(\forall Z.\,G^{Z})\quad,\\
{\color{greenunder}\text{(c)}:}\quad & \forall X.\,R\rightarrow F^{X}\cong R\rightarrow\forall Y.\,F^{Y}\quad.
\end{align*}


\subparagraph{Remarks}

We renamed the bound type parameters for clarity; the identities could
be also written using the same type parameter name (say, $X$):
\[
\forall X.\,F^{X}+G^{X}\cong(\forall X.\,F^{X})+(\forall X.\,G^{X})\quad,
\]
and so on.

To get some intuition for items \textbf{(b)} and \textbf{(c)}, consider
how those types are written in the syntax of Scala 3. The type corresponding
to $\forall X.\,F^{X}\times G^{X}$ is written as \lstinline![X] => (F[X], G[X])!.
If we imagine that {[}X{]} were an ordinary argument (not a type parameter),
we would apply the standard type identities:
\begin{align*}
 & A\rightarrow B\times C\cong(A\rightarrow B)\times(A\rightarrow C)\quad,\\
 & A\rightarrow R\rightarrow B\cong R\rightarrow A\rightarrow B\quad,
\end{align*}
written in Scala syntax as:
\begin{lstlisting}
A => (B, C)  ===  (A => B, A => C)
A => R => B  ===  R => A => B
\end{lstlisting}
Assigning \lstinline!A = [X]!, \lstinline!B = F[X]!, and \lstinline!C = G[X]!
in those identities, we get:
\begin{lstlisting}
[X] => (F[X], G[X])  ===  ([X] => F[X], [X] => G[X])
[X] => R => F[X]     ===   R => [X] => F[X]
\end{lstlisting}
These type formulas are exactly similar to the isomorphisms \textbf{(b)}
and \textbf{(c)}. However, \lstinline!X! is a type parameter, not
a value parameter, so it is invalid to use ordinary type identities
such as $A\rightarrow R\rightarrow B\cong R\rightarrow A\rightarrow B$
and assign $A=$ \lstinline![X]!. We need a new proof. 

\subparagraph{Proof}

\textbf{(a)} This isomorphism is shown in Example~\ref{subsec:Example-simple-existential-derivation-1-1}(a).
It is a \textsf{``}non-constructive\textsf{''} isomorphism, in the following sense.
We can define a function \lstinline!outS! that transforms the left-hand
side into the right-hand side:
\begin{align*}
 & \text{outS}:\big((\forall Y.\,F^{Y})+(\forall Z.\,G^{Z})\big)\rightarrow\forall X.\,F^{X}+G^{X}\quad,\\
 & \text{outS}\triangleq\,\begin{array}{|c||c|}
 & \forall X.\,F^{X}+G^{X}\\
\hline \forall Y.\,F^{Y} & f\rightarrow\forall X.\,f^{X}+\bbnum 0\\
\forall Z.\,G^{Z} & g\rightarrow\forall X.\,\bbnum 0+g^{X}
\end{array}\quad.
\end{align*}
This function implements one direction of the isomorphism. But one
cannot implement a fully parameteric function \lstinline!inS! with
the converse type signature:
\[
\text{inS}:\big(\forall X.\,F^{X}+G^{X}\big)\rightarrow(\forall Y.\,F^{Y})+(\forall Z.\,G^{Z})\quad,\quad\quad\text{inS}=???
\]
Example~\ref{subsec:Example-simple-existential-derivation-1-1}(a)
proves that there is a one-to-one correspondence between values of
types $\forall X.\,F^{X}+G^{X}$ and $(\forall Y.\,F^{Y})+(\forall Z.\,G^{Z})$
even though one cannot write fully parametric code for computing the
corresponding values.

\textbf{(b)} To prove the second isomorphism, define a pair of functions:
\begin{align*}
 & \text{inP}:(\forall X.\,F^{X}\times G^{X})\rightarrow(\forall Y.\,F^{Y})\times(\forall Z.\,G^{Z})\quad,\\
 & \text{inP}\triangleq r^{:\forall X.\,F^{X}\times G^{X}}\rightarrow(\forall Y.\,r^{Y}\triangleright\pi_{1})\times(\forall Z.\,r^{Z}\triangleright\pi_{2})\quad,\\
 & \text{outP}:(\forall Y.\,F^{Y})\times(\forall Z.\,G^{Z})\rightarrow\forall X.\,F^{X}\times G^{X}\quad,\\
 & \text{outP}\triangleq p^{:\forall Y.\,F^{Y}}\times q^{:\forall Z.\,G^{Z}}\rightarrow\forall X.\,p^{X}\times q^{X}\quad.
\end{align*}

Now we need to prove the two sides of the composition:

(1) For any $r$ of type $\forall X.\,F^{X}\times G^{X}$, applying
\lstinline!inP! to $r$ and then \lstinline!outP! should again give
the value $r$:
\begin{align*}
{\color{greenunder}\text{expect to equal }r:}\quad & r^{:\forall X.\,F^{X}\times G^{X}}\triangleright\text{inP}\triangleright\text{outP}\\
 & =\big((\forall Y.\,r^{Y}\triangleright\pi_{1})\times(\forall Z.\,r^{Z}\triangleright\pi_{2})\big)\triangleright\text{outP}\\
 & =\forall X.\,(r^{X}\triangleright\pi_{1})\times(r^{X}\triangleright\pi_{2})=\forall X.\,r^{X}=r\quad.
\end{align*}

(2) For any $p:\forall Y.\,F^{Y}$ and $q:\forall Z.\,G^{Z}$, applying
\lstinline!outP! to $p\times q$ and then \lstinline!inP! should
again give the value $p\times q$:
\begin{align*}
{\color{greenunder}\text{expect to equal }p\times q:}\quad & (p\times q)\triangleright\text{outP}\triangleright\text{inP}=(\forall X.\,p^{X}\times q^{X})\triangleright\text{inP}\\
 & =(\forall Y.\,(p^{Y}\times q^{Y})\triangleright\pi_{1})\times(\forall Z.\,(p^{Z}\times q^{Z})\triangleright\pi_{2})\\
 & =(\forall Y.\,p^{Y})\times(\forall Z.\,q^{Z})=p\times q\quad.
\end{align*}

\textbf{(c)} To prove the third isomorphism, define a pair of functions:
\begin{align*}
 & \text{inR}:(\forall X.\,R\rightarrow F^{X})\rightarrow R\rightarrow\forall Y.\,F^{Y}\quad,\\
 & \text{inR}\triangleq f^{:\forall X.\,R\rightarrow F^{X}}\rightarrow r^{:R}\rightarrow\forall Y.\,f^{Y}(r)\quad,\\
 & \text{outR}:(R\rightarrow\forall Y.\,F^{Y})\rightarrow\forall X.\,R\rightarrow F^{X}\quad,\\
 & \text{outR}\triangleq\big(g^{:R\rightarrow\forall Y.\,F^{Y}}\big)\rightarrow\forall X.\,r^{:R}\rightarrow(g(r))^{X}\quad.
\end{align*}

Now we need to prove the two sides of the composition:

(1) For any $f$ of type $\forall X.\,R\rightarrow F^{X}$, applying
\lstinline!inR! and then \lstinline!outR! should give $f$:
\begin{align*}
{\color{greenunder}\text{expect to equal }f:}\quad & f\triangleright\text{inR}\triangleright\text{outR}=\big(r^{:R}\rightarrow\forall Y.\,f^{Y}(r)\big)\triangleright\text{outR}\\
 & =\forall X.\,r^{:R}\rightarrow\big(\big(r^{:R}\rightarrow\forall Y.\,f^{Y}(r)\big)(r)\big)^{X}\\
 & =\forall X.\,r^{:R}\rightarrow f^{X}(r)=\forall X.\,f^{X}=f\quad.
\end{align*}

(2) For any $g$ of type $R\rightarrow\forall Y.\,F^{Y}$, applying
\lstinline!outR! and then \lstinline!inR! should give $g$:
\begin{align*}
{\color{greenunder}\text{expect to equal }g:}\quad & g\triangleright\text{outR}\triangleright\text{inR}=\big(\forall X.\,r^{:R}\rightarrow(g(r))^{X}\big)\triangleright\text{inR}\\
 & =r^{:R}\rightarrow\forall Y.\,\big(\forall X.\,r^{:R}\rightarrow(g(r))^{X}\big)^{Y}(r)\\
 & =r^{:R}\rightarrow\gunderline{\forall Y.\,(g(r))^{Y}}=r^{:R}\rightarrow g(r)=g\quad.
\end{align*}
$\square$

The three type constructions from Statement~\ref{subsec:Statement-general-identities-forall},
together with a recursive construction, produce functors whose type
parameter never appears to the left of a function arrow. Those functors
are known as \textsf{``}strictly positive\textsf{''} functors. Here is a formal inductive
definition:

\subsubsection{Definition \label{subsec:Definition-strictly-positive-functor}\ref{subsec:Definition-strictly-positive-functor}}

A functor $F$ is \index{functor!strictly positive} \textbf{strictly
positive} if $F$ is expressed in any of the following ways:

(1) $F^{A}\triangleq R$

(2) $F^{A}\triangleq A$

(3) $F^{A}\triangleq G^{A}+H^{A}$

(4) $F^{A}\triangleq G^{A}\times H^{A}$

(5) $F^{A}\triangleq R\rightarrow G^{A}$

(6) $F^{A}\triangleq S^{A,F^{A}}$

Here $G$, $H$ are any strictly positive functors; $R$ is any fixed
type; and the pattern bifunctor $S$ is any strictly positive \emph{bifunctor},
which we will define next:

A bifunctor $S$ is strictly positive if $S$ is expressed in any
of the following ways:

(1) $S^{A,B}\triangleq R$

(2) $S^{A,B}\triangleq A$ or $S^{A,B}=B$

(3) $S^{A,B}\triangleq P^{A,B}+Q^{A,B}$

(4) $S^{A,B}\triangleq P^{A,B}\times Q^{A,B}$

(5) $S^{A,B}\triangleq R\rightarrow P^{A,B}$

(6) $S^{A,B}\triangleq U^{A,B,S^{A,B}}$

Here $P$, $Q$ are any strictly positive bifunctors; $R$ is any
fixed type; and the pattern $3$-functor $U$ is any strictly positive
$3$-functor.

Similarly, we define strictly positive $3$-functors, $4$-functors,
etc., by induction. $\square$

Examples of strictly positive functors are all polynomial functors.
Examples of non-strictly positive functors are the continuation monad
$F^{A}\triangleq(A\rightarrow C)\rightarrow C$ and the selection
monad $F^{A}\triangleq(A\rightarrow C)\rightarrow A$. Those functors
are covariant and even non-recursive, but their type parameters ($A$)
appear to the \emph{left} of some function arrows, which is not allowed
for strictly positive functors.

\subsubsection{Statement \label{subsec:Statement-quantifier-across-functor}\ref{subsec:Statement-quantifier-across-functor}}

For any strictly positive functor $F$ and any type constructor $P$,
we have:
\[
\forall A.\,F^{P^{A}}\cong F^{\forall A.\,P^{A}}\quad.
\]
For any strictly positive bifunctor $S$ and any type constructors
$P$, $Q$, we have:
\[
\forall A.\,S^{P^{A},Q^{A}}\cong S^{\forall A.\,P^{A},\forall A.\,Q^{A}}\quad.
\]
Similar identities hold for strictly positive $3$-functors, $4$-functors,
etc.

\subparagraph{Proof}

The functor $F$ must be expressed in one of the six ways:

(1) $F^{A}=R$ with a fixed type $R$. Then we get:
\[
\forall A.\,F^{P^{A}}=\forall A.\,R\cong R\quad,\quad\quad F^{\forall A.\,P^{A}}=R\quad.
\]

(2) $F^{A}=A$. Then we get:
\[
\forall A.\,F^{P^{A}}=\forall A.\,P^{A}\quad,\quad\quad F^{\forall A.\,P^{A}}=\forall A.\,P^{A}\quad.
\]

(3) $F^{A}=G^{A}+H^{A}$, where the statement is already true for
$G$ and $H$ by the inductive assumptions. Then we get:
\begin{align*}
 & \forall A.\,F^{P^{A}}=\forall A.\,G^{P^{A}}+H^{P^{A}}\\
{\color{greenunder}\text{Statement\,\ref{subsec:Statement-general-identities-forall}(a)}:}\quad & =\big(\gunderline{\forall A.\,G^{P^{A}}}\big)+\big(\gunderline{\forall A.\,H^{P^{A}}}\big)\\
{\color{greenunder}\text{inductive assumptions}:}\quad & =G^{\forall A.\,P^{A}}+H^{\forall A.\,P^{A}}=F^{\forall A.\,P^{A}}\quad.
\end{align*}

(4) $F^{A}=G^{A}\times H^{A}$, where the statement is already true
for $G$ and $H$ by the inductive assumptions. Then we get:
\begin{align*}
 & \forall A.\,F^{P^{A}}=\forall A.\,G^{P^{A}}\times H^{P^{A}}\\
{\color{greenunder}\text{Statement\,\ref{subsec:Statement-general-identities-forall}(b)}:}\quad & =\big(\gunderline{\forall A.\,G^{P^{A}}}\big)\times\big(\gunderline{\forall A.\,H^{P^{A}}}\big)\\
{\color{greenunder}\text{inductive assumptions}:}\quad & =G^{\forall A.\,P^{A}}\times H^{\forall A.\,P^{A}}=F^{\forall A.\,P^{A}}\quad.
\end{align*}

(5) $F^{A}=R\rightarrow G^{A}$, where the statement is already true
for $G$ by the inductive assumption. Then we get:
\begin{align*}
 & \forall A.\,F^{P^{A}}=\forall A.\,R\rightarrow G^{P^{A}}\\
{\color{greenunder}\text{Statement\,\ref{subsec:Statement-general-identities-forall}(c)}:}\quad & =R\rightarrow\big(\gunderline{\forall A.\,G^{P^{A}}}\big)\\
{\color{greenunder}\text{inductive assumption}:}\quad & =R\rightarrow G^{\forall A.\,P^{A}}=F^{\forall A.\,P^{A}}\quad.
\end{align*}

(6) $F^{A}=S^{A,F^{A}}$, where the statement is already true for
$S$ by the inductive assumption. (Another inductive assumption is
that the statement is already true for recursive usages of $F$ under
$S$.) We get:
\begin{align*}
 & \forall A.\,F^{P^{A}}=\forall A.\,S^{P^{A},F^{P^{A}}}\\
{\color{greenunder}\text{inductive assumption}:}\quad & \cong S^{\forall A.\,P^{A},\gunderline{\forall A.\,F^{P^{A}}}}\\
{\color{greenunder}\text{inductive assumption}:}\quad & \cong S^{\forall A.\,P^{A},F^{\forall A.\,P^{A}}}=F^{\forall A.\,P^{A}}\quad.
\end{align*}

The identities for bifunctors, $3$-functors, etc., are proved in
a similar way. $\square$

We will now prove some statements showing miscellaneous additional
techniques for simplifying universally quantified types.

\subsubsection{Statement \label{subsec:Statement-Fubini-theorem-1}\ref{subsec:Statement-Fubini-theorem-1} }

If any type constructor $F$ is such that $F^{\bbnum 0}\cong\bbnum 0$
then:
\[
\forall A.\,F^{A}\cong\bbnum 0\quad.
\]


\subparagraph{Proof}

We need to show that there exist no values of type $\forall A.\,F^{A}$.
Suppose there existed such a value $f$; then we would be apply to
apply $f$ to the void type. The resulting value would be:
\[
x:F^{\bbnum 0}\quad,\quad\quad x\triangleq f^{\bbnum 0}\quad.
\]
But this contradicts the given assumption that the type $F^{\bbnum 0}$
is void. This contradiction proves the statement (non-constructively).

\subsubsection{Statement \label{subsec:Statement-Fubini-theorem}\ref{subsec:Statement-Fubini-theorem}
(Fubini theorem\index{Fubini theorem})}

For any type constructor $S$ with two type parameters, the following
type equivalence holds:
\[
\forall A.\,\forall B.\,S^{A,B}\cong\forall B.\,\forall A.\,S^{A,B}\quad.
\]


\subparagraph{Proof}

{*}{*}{*} $\square$ 

\subsubsection{Statement \label{subsec:Statement-merge-quantifiers}\ref{subsec:Statement-merge-quantifiers}}

For any type constructor $F$: (not sure any of this is true!){*}{*}{*}
\begin{align*}
{\color{greenunder}\text{(a)}:}\quad & \forall X.\,\forall Y.\,F^{X\times Y}\cong\forall Z.\,F^{Z}\quad,\\
{\color{greenunder}\text{(b)}:}\quad & \forall X.\,\forall Y.\,F^{X+Y}\cong\forall Z.\,F^{Z}\quad,\\
{\color{greenunder}\text{(c)}:}\quad & \forall X.\,\forall Y.\,F^{X\rightarrow Y}\cong\forall Z.\,F^{Z}\quad.
\end{align*}


\subparagraph{Proof}

{*}{*}{*} $\square$

With these techniques, together with the Yoneda and Church-Yoneda
identities, we can often reduce a type that contains a universal quantifier
to an equivalent simpler type without quantifiers.

\subsubsection{Example \label{subsec:Example-complicated-type-equivalence-2-1}\ref{subsec:Example-complicated-type-equivalence-2-1}\index{examples}}

Show that the type $\forall A.\,\bbnum 1+A\rightarrow A$ is void.

\subparagraph{Solution}

Transform the type using the Yoneda identities:
\begin{align*}
 & \forall A.\,\bbnum 1+A\rightarrow A\cong\forall A.\,(\bbnum 1\rightarrow A)\times(A\rightarrow A)\\
 & \cong(\forall A.\,\bbnum 1\rightarrow A)\times(\forall A.\,A\rightarrow A)\\
 & \cong\bbnum 0\times\bbnum 1=\bbnum 0\quad.
\end{align*}


\subsubsection{Example \label{subsec:Example-simplify-quantifier}\ref{subsec:Example-simplify-quantifier}}

Simplify all fully parametric types of the form $\forall A.\,T^{A}$
where $T^{A}$ is any type expression containing no recursion and
at most two type constructions (using Table~\ref{tab:six-pure-type-constructions}
without the recursive type). The type expression $T^{A}$ may contain
$A$ and other fixed types ($P,$$Q$).

\subparagraph{Solution}

Fully parametric types are built via the five type constructions So,
we can enumerate all type expressions $T^{A}$ of the specified form:
$\forall A.\,P$, $\forall A.\,A$, $\forall A.\,P\times A$, $\forall A.\,A\rightarrow P+A$,
and so on. For each of those expressions, we need to apply an appropriate
technique that will simplify the type.

We begin by noticing that many type expressions $T^{A}$ will be covariant
in $A$ or contravariant in $A$. Examples are:
\begin{align*}
{\color{greenunder}\text{covariant}:}\quad & A\quad,\quad P\rightarrow A\quad,\quad P+A\times A\quad,\quad(A\rightarrow P)\rightarrow Q\quad,\quad...\\
{\color{greenunder}\text{contravariant}:}\quad & A\rightarrow P\quad,\quad P+(A\rightarrow Q)\quad,\quad(P\rightarrow A)\rightarrow Q\quad,\quad...
\end{align*}
The Yoneda identities can simplify such type expressions:
\begin{align*}
{\color{greenunder}\text{if }T\text{ is covariant}:}\quad & \forall A.\,T^{A}\cong T^{\bbnum 0}\quad,\\
{\color{greenunder}\text{if }T\text{ is contravariant}:}\quad & \forall A.\,T^{A}\cong T^{\bbnum 1}\quad.
\end{align*}
This gives us the following results:
\begin{align*}
 & \forall A.\,P\cong P\quad,\quad\forall A.\,A\cong\bbnum 0\quad,\\
 & \forall A.\,A+P\cong P\quad,\quad\forall A.\,A\times P\cong\bbnum 0\quad,\quad\forall A.\,A\rightarrow P\cong P\quad,\quad\forall A.\,P\rightarrow A\cong\bbnum 0\quad,\\
 & \forall A.\,P\rightarrow A+Q\cong P\rightarrow Q\quad,\quad\forall A.\,(P\rightarrow A)\rightarrow Q\cong Q\quad,\quad\forall A.\,(A\rightarrow P)\rightarrow Q\cong Q\quad.
\end{align*}

Because of the known identities that hold for any type constructors
$U$, $V$:
\begin{align*}
 & \forall A.\,U^{A}+V^{A}=(\forall A.\,U^{A})+(\forall A.\,V^{A})\quad,\\
 & \forall A.\,U^{A}\times V^{A}=(\forall A.\,U^{A})\times(\forall A.\,V^{A})\quad,
\end{align*}
we may also use the Yoneda identity to simplify the type $\forall A.\,T^{A}$
where $T^{A}$ is equivalent to a product or a co-product of simpler
expressions:
\begin{align*}
 & \forall A.\,A+(P\rightarrow A)\cong(\forall A.\,A)+(\forall A.\,P\rightarrow A)\cong\bbnum 0+\bbnum 0\cong\bbnum 0\quad,\\
 & \forall A.\,A+P\rightarrow A\cong\forall A.\,(A\rightarrow A)\times(P\rightarrow A)\cong\bbnum 1\times\bbnum 0\cong\bbnum 0\quad,\\
 & \forall A.\,A+A\rightarrow A\cong\forall A.\,(A\rightarrow A)\times(A\rightarrow A)\cong\bbnum 1\quad,\\
 & \forall A.\,A\rightarrow P\times A\cong\forall A.\,(A\rightarrow P)\times(A\rightarrow A)\cong P\times\bbnum 1\cong P\quad.
\end{align*}

It remains to consider types of the form $\forall A.\,U^{A}\rightarrow V^{A}$
when $U^{A}$ is \emph{not} a co-product and $V^{A}$ is \emph{not}
a product. To simplify those types, we apply a suitable technique
as indicated:
\begin{align*}
{\color{greenunder}\text{use Yoneda identity}:}\quad & \forall A.\,A\rightarrow A\cong\bbnum 1\quad,\quad\forall A.\,A\times A\rightarrow A\cong\bbnum 2\quad,\\
{\color{greenunder}\text{uncurry and use Yoneda}:}\quad & \forall A.\,A\times P\rightarrow A\cong\forall A.\,A\rightarrow P\rightarrow A\cong P\rightarrow\bbnum 1\cong\bbnum 1\quad,\\
{\color{greenunder}\text{because }T^{\bbnum 0}\cong\bbnum 0:}\quad & \forall A.\,(A\rightarrow A)\rightarrow A\cong\bbnum 0\quad\text{and}\quad\forall A.\,(A\rightarrow P)\rightarrow A\cong\bbnum 0\quad,\\
{\color{greenunder}\text{use Yoneda identity}:}\quad & \forall A.\,(P\rightarrow A)\rightarrow A\cong P\quad,\quad\forall A.\,A\rightarrow P+A\cong P+\bbnum 1\quad,\\
{\color{greenunder}\text{use Church-Yoneda identity}:}\quad & \forall A.\,(A\rightarrow A)\rightarrow R\cong R\quad.
\end{align*}
(For the last line, use the Church-Yoneda identity from Statement~\ref{subsec:Statement-Church-Yoneda-identity}
with $F^{A}\triangleq A$ and $G^{A}\triangleq R$, and get $G^{\text{LFix}(F)}=R$.)

\subsubsection{Example \label{subsec:Example-complicated-type-equivalence-3}\ref{subsec:Example-complicated-type-equivalence-3}}

Simplify the type $\forall A.\,(P\rightarrow A\times Q)\rightarrow(A+R)\times S$.

\subparagraph{Solution}

First, perform some equivalence transformations on the type, trying
to transform some of its sub-expressions into a Yoneda-like form:
\begin{align*}
 & \forall A.\,(P\rightarrow A\times Q)\rightarrow(A+R)\times S\\
 & \cong\forall A.\,((P\rightarrow A\times Q)\rightarrow A+R)\times((P\rightarrow A\times Q)\rightarrow S)\\
 & =(\forall A.\,(P\rightarrow A)\rightarrow(P\rightarrow Q)\rightarrow A+R)\times(\forall A.\,H^{A})\\
 & =(\forall A.\,(P\rightarrow A)\rightarrow F^{A})\times(\forall A.\,H^{A})\quad.
\end{align*}
Here $F^{A}\triangleq(P\rightarrow Q)\rightarrow A+R$ is a functor
and $H^{A}\triangleq(A\rightarrow P\rightarrow Q)\rightarrow S$ is
a contrafunctor we introduced. The Yoneda identities give:
\begin{align*}
 & \forall A.\,(P\rightarrow A)\rightarrow F^{A}\cong F^{P}\quad,\\
 & \forall A.\,H^{A}\cong H^{\bbnum 1}\quad.
\end{align*}
Now we can finish the derivation:
\begin{align*}
 & \forall A.\,(P\rightarrow A\times Q)\rightarrow(A+R)\times S\cong F^{P}\times H^{\bbnum 1}\\
 & =((P\rightarrow Q)\rightarrow P+R)\times((P\rightarrow Q)\rightarrow S)\\
 & \cong(P\rightarrow Q)\rightarrow(P+R)\times S\quad.
\end{align*}


\subsubsection{Example \label{subsec:Example-simplify-quantifier-1}\ref{subsec:Example-simplify-quantifier-1}}

\textbf{(a)} Show that $\forall A.\,F^{A\rightarrow A}\cong F^{\bbnum 1}$
for any functor $F$.

\textbf{(b)} Show that $\forall A.\,F^{A\rightarrow A}\cong F^{\bbnum 1}$
for any contrafunctor $F$.

\textbf{(c)} Show that the equivalence no longer holds when $F$ is
neither covariant nor contravariant.

\subparagraph{Solution}

\textbf{(a)} Define the profunctor $P^{A,B}\triangleq F^{A\rightarrow B}$
and rewrite the given type as:
\[
\forall A.\,F^{A\rightarrow A}=\forall A.\,P^{A,A}\quad.
\]
Now, $P^{A,B}$ is contravariant in $A$ and covariant in $B$. So,
we may apply the contravariant Yoneda identity with respect to the
first type parameter in $P^{A,B}$:
\[
P^{A,B}\cong\forall C.\,(C\rightarrow A)\rightarrow P^{C,B}\quad.
\]
Then we set $B=A$ in the last formula and write:
\begin{align*}
 & \forall A.\,F^{A\rightarrow A}=\forall A.\,\gunderline{P^{A,A}}\\
{\color{greenunder}\text{use the contravariant Yoneda identity}:}\quad & \cong\forall A.\,\forall C.\,\left(C\rightarrow A\right)\rightarrow\gunderline{P^{C,A}}\\
{\color{greenunder}\text{use the definition of }P:}\quad & =\forall A.\,\forall C.\,\gunderline{\left(C\rightarrow A\right)}\rightarrow F^{\gunderline{C\rightarrow A}}\\
{\color{greenunder}\text{define }Q^{X}\triangleq X\rightarrow F^{X}:}\quad & =\gunderline{\forall A.\,\forall C.}\,Q^{\gunderline{C\rightarrow A}}\\
{\color{greenunder}\text{remove the double quantifier}:}\quad & =\forall X.\,Q^{X}=\forall X.\,\gunderline X\rightarrow F^{X}\\
{\color{greenunder}\text{type equivalence }X\cong\bbnum 1\rightarrow X:}\quad & \cong\forall X.\,(\bbnum 1\rightarrow X)\rightarrow F^{X}\\
{\color{greenunder}\text{covariant Yoneda identity}:}\quad & \cong F^{\bbnum 1}\quad.
\end{align*}

\textbf{(b)} Use the contravariant Yoneda identity, introducing another
quantifier ($\forall B$):
\begin{align*}
 & \forall A.\,F^{A\rightarrow A}\cong\forall A.\,\forall B.\,(\gunderline{B\rightarrow A\rightarrow}\,A)\rightarrow F^{B}\\
{\color{greenunder}\text{uncurry arguments}:}\quad & \cong\forall A.\,\forall B.\,(\gunderline{B\times A}\rightarrow A)\rightarrow F^{B}\\
{\color{greenunder}\text{define }G^{A}\triangleq B\times A:}\quad & \cong\forall A.\,\gunderline{\forall B.\,(G^{A}\rightarrow A)\rightarrow F^{B}}\\
{\color{greenunder}\text{contravariant Yoneda identity}:}\quad & \cong\forall A.\,(G^{A}\rightarrow A)\rightarrow F^{\bbnum 1}\\
{\color{greenunder}\text{contravariant Yoneda identity***}:}\quad & \cong F^{\bbnum 1}\quad.
\end{align*}
Here we used the Church-Yoneda identity:
\[
\forall A.\,(G^{A}\rightarrow A)\rightarrow H^{A}\cong H^{\text{LFix}(G)}\quad,
\]
where $H$ is a constant functor: $H^{X}\triangleq F^{B}$. The constant
functor $H$ ignores its type parameter, and the result is $F^{B}$.

\textbf{(c)} If we set $F^{X}=X\rightarrow X$ then the type $\forall A.\,F^{A\rightarrow A}$
becomes $\forall A.\,(A\rightarrow A)\rightarrow A\rightarrow A$,
which is equivalent to the type of natural numbers. That type is \emph{not}
equivalent to $F^{\bbnum 1}$. $\square$

\subsection{The Jaskelioff-O\textsf{'}Connor theorem for simple types}

The Jaskelioff-O\textsf{'}Connor theorem\footnote{See \texttt{\href{https://arxiv.org/abs/1402.1699}{https://arxiv.org/abs/1402.1699}}}
is a type equivalence between certain type constructors quantified
over a typeclass. This section proves a version of that theorem that
holds for simple types belonging to a $P$-typeclass. Then the theorem
gives a general type formula for the free construction of any $P$-typeclass.

\subsubsection{Statement \label{subsec:Statement-JOC-theorem-simple-types}\ref{subsec:Statement-JOC-theorem-simple-types}}

The free $P$-typeclass instance $E^{T}$ generated by a type $T$
is equivalent to the type defined by:
\begin{equation}
E^{T}\cong\forall(A\in P\text{-typeclass}).\,(T\rightarrow A)\rightarrow A\quad.\label{eq:free-typeclass-via-church-encoding}
\end{equation}
Here the quantifier goes only over the types $A$ that belong to the
$P$-typeclass. It is also assumed that the type in the right-hand
side of Eq.~(\ref{eq:free-typeclass-via-church-encoding}) admits
only functions that satisfy the naturality law with respect to $A$.

\subparagraph{Proof}

One of the defining properties of the free typeclass constructor $E$
is the one-to-one correspondence between functions of type $T\rightarrow A$
and $P$-typeclass morphisms of type $E^{T}\rightarrow A$. Denoting
by $E^{T}\overset{P}{\rightarrow}A$ the type of those morphisms,
we have:
\[
\forall(A\in P\text{-typeclass}).\,(T\rightarrow A)\rightarrow A\cong\forall(A\in P\text{-typeclass}).\,(E^{T}\overset{P}{\rightarrow}A)\rightarrow A\quad.
\]

All types $A$ belonging to the $P$-typeclass are $E$-monad algebras,
and those algebras form a category. Now we use the Yoneda identity
in that category:
\[
\forall(A\in P\text{-typeclass}).\,(X\overset{P}{\rightarrow}A)\rightarrow A\cong X\quad,
\]
where $X$ is any fixed type that also belongs to the $P$-typeclass.
We use this identity with $X=E^{T}$ and obtain:
\[
\forall(A\in P\text{-typeclass}).\,(E^{T}\overset{P}{\rightarrow}A)\rightarrow A\cong E^{T}\quad,
\]
as required. $\square$

As a first example of using Eq.~(\ref{eq:free-typeclass-via-church-encoding}),
consider a $P$-typeclass called \lstinline!TC! whose methods do
not have to obey any laws. The Scala code for the typeclass \lstinline!TC!
contains two methods:
\begin{lstlisting}
trait TC[A] {
  def method1(x: Int): A
  def method2(y: A, z: String): A
}
\end{lstlisting}
What is the free \lstinline!TC!-typeclass instance generated by an
arbitrary type \lstinline!T!? The theorem says that the free instance
is defined as:
\[
\forall(A:\text{TC}).\,(T\rightarrow A)\rightarrow A\quad.
\]
The Scala code for this type may be written as:
\begin{lstlisting}
trait FreeTC[T] {
  def run[A: TC](f: T => A): A
}
\end{lstlisting}
To see that the type \lstinline!FreeTC[T]! will always belong to
the typeclass \lstinline!TC!, let us implement \lstinline!TC!\textsf{'}s
methods for values of that type:
\begin{lstlisting}
implicit def instanceFreeTC[T]: TC[FreeTC[T]] = new TC[FreeTC[T]] {
  def method1(x: Int): FreeTC[T] = new FreeTC[T] {
    def run[A: TC](f: T => A): A = implicitly[TC[A]].method1(x)
  }
  def method2(y: FreeTC[T], z: String): FreeTC[T] = new FreeTC[T] {
    def run[A: TC](f: T => A): A = {
      val a: A = y.run[A](f)
      implicitly[TC[A]].method2(a, z)
    }
  }
}
\end{lstlisting}

The code of \lstinline!FreeTC[T]! and of \lstinline!instanceFreeTC!
uses the trait \lstinline!TC! parametrically. We expect that similar
code will work for any other $P$-typeclass to define a free instance.
To see that more clearly, rewrite the type signature of the function
\lstinline!run! showing the implicit parameter at the end:
\begin{lstlisting}
trait FreeTC[T] {
  def run[A](f: T => A)(implicit ev: TC[A]): A
}
\end{lstlisting}
It follows that the type \lstinline!FreeTC[T]! is equivalent to:
\[
\forall A.\,(T\rightarrow A)\rightarrow\text{TC}^{A}\rightarrow A\quad.
\]
To pass to any other $P$-typeclass, we need to replace the type $\text{TC}^{A}$
by the type $P^{A}\rightarrow A$ that describes all the methods of
the $P$-typeclass. Then the free $P$-typeclass instance constructor
is given by:
\[
\forall A.\,(T\rightarrow A)\rightarrow(P^{A}\rightarrow A)\rightarrow A\quad.
\]
This type can be transformed to $\forall A.\,(T+P^{A}\rightarrow A)\rightarrow A$,
which is the Church encoding of the recursive type $F\cong T+P^{F}$.
We recognize that $F$ is the free monad on the functor $P$, applied
to the type $T$. Indeed, we know from the theory of $P$-typeclasses
that the free monad on $P$ gives the raw tree encoding of the free
$P$-typeclass. If the $P$-typeclass has no laws then this is the
only available encoding.

Most typeclasses do require some laws to hold. This technique will
still give acceptable results even though Scala code cannot enforce
the laws. 

As an example, let us implement the free instance of the \lstinline!Monoid!
typeclass. The theorem gives:
\[
\text{FreeMonoid}^{T}\cong\forall(A:\text{Monoid}).\,(T\rightarrow A)\rightarrow A\quad.
\]
The corresponding Scala definition is:
\begin{lstlisting}
trait FreeMonoid[T] {
  def run[A: Monoid](f: T => A): A
}
\end{lstlisting}
{*}{*}{*}

{*}{*}{*} Example for a type constructor class: free functor

What happens if we apply the same technique to a typeclass that is
\emph{not} of the form of a $P$-typeclass? As it turns out, the construction
no longer works as expected. An example is the \lstinline!Eq! typeclass
(Section~\ref{subsec:The-Eq-typeclass}) whose evidence values have
type $T\times T\rightarrow\bbnum 2$, giving a comparison operation
for values of type $T$. The \lstinline!Eq! typeclass \emph{cannot}
have a free instance; in other words, no free typeclass encoding $E$
exists. If we apply the type formula~(\ref{eq:free-typeclass-via-church-encoding})
to that typeclass, we get the following type constructor $E$:
\begin{align*}
 & E^{T}\triangleq\forall(A:\text{Eq}).\,(T\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{evidence of \texttt{Eq}}:}\quad & =\forall A.\,(A\times A\rightarrow\bbnum 2)\rightarrow(T\rightarrow A)\rightarrow A\\
{\color{greenunder}\text{flip curried arguments}:}\quad & \cong\forall A.\,\gunderline{(T\rightarrow A)}\rightarrow\gunderline{(A\times A\rightarrow\bbnum 2)\rightarrow A}\\
{\color{greenunder}\text{Yoneda identity}:}\quad & \cong(T\times T\rightarrow\bbnum 2)\rightarrow T\quad.
\end{align*}
The type constructor $E$ is a monad because it is of the form $H^{T}\rightarrow T$
with a contravariant functor $H$ (see Statement~\ref{subsec:Statement-monad-construction-2}).
However, the construction fails to produce a useful free instance
for the type $E^{T}$. To see that, write the type signature for an
\lstinline!Eq! typeclass evidence that $E^{T}$ would have:
\[
\text{Eq}^{E^{T}}=E^{T}\times E^{T}\rightarrow\bbnum 2\quad.
\]
A value of this type must be implemented fully parametrically in $T$.
Since $E^{T}$ is covariant in $T$, we see that $\text{Eq}^{E^{T}}$
is contravariant in $T$. So, we can write the type equivalence:
\[
\forall T.\,\text{Eq}^{E^{T}}\cong\text{Eq}^{E^{\bbnum 1}}\cong\bbnum 2\quad.
\]
It follows that a fully parametric implementation of the \lstinline!Eq!
typeclass evidence is only possible as a constant function that returns
a fixed \lstinline!Boolean! value. At this point, we need to impose
the laws of the comparison operation. By the reflexivity law\index{reflexivity law},
the comparison of a value with itself should return \lstinline!true!.
So, the constant function must always return \lstinline!true!. This
is not a useful comparison function.

\subsection{The Jaskelioff-O\textsf{'}Connor theorem for type constructors}

The full formulation of the theorem involves functor typeclasses instead
of typeclasses for simple types. The theorem applies to all $P$-typeclasses
for functors. Those typeclasses have method signatures of the form
$\forall A.\,(P^{F})^{A}\rightarrow F^{A}$, where $P$ is a functor
on functors (the kind of $P$ is $(*\rightarrow*)\rightarrow*\rightarrow*$)
and functions of type $(P^{F})^{A}\rightarrow F^{A}$ are restricted
to natural transformations between functors $P^{F}$ and $F$. Examples
of well-known $P$-typeclasses of that form are pointed functors,
filterable functors, applicative functors, and monads.

\subsubsection{Statement \label{subsec:Statement-Jaskelioff-OConnor}\ref{subsec:Statement-Jaskelioff-OConnor}
(Jaskelioff-O\textsf{'}Connor)}

Given any fixed $P$-typeclass for functors, denote by $E$ the constructor
of free instances of that typeclass: if $T$ is any functor then the
functor $E^{T}$ is guaranteed to be an instance of the $P$-typeclass.
Suppose $A$, $B$, $C$ are some fixed types. Then the following
type equivalence holds:
\begin{align}
 & \forall(F\in P\text{-typeclass}).\,(A\rightarrow F^{B})\rightarrow F^{C}\cong(E^{R})^{C}\quad,\label{eq:jaskelioff-o-connor-theorem}\\
{\color{greenunder}\text{where }R\text{ is defined by}:}\quad & R^{T}\triangleq A\times(B\rightarrow T)\quad.\nonumber 
\end{align}
Here, it is assumed that the type $(A\rightarrow F^{B})\rightarrow F^{C}$
is restricted to functions satisfying the naturality law with respect
to $F$.

\subparagraph{Proof}

Denote by $K\overset{P}{\rightarrow}L$ the type of $P$-typeclass
morphisms between functors $K$ and $L$ that belong to the typeclass.
(The full type signature of a $P$-typeclass morphism is $\forall A.\,K^{A}\overset{P}{\rightarrow}L^{A}$.)

We will prove the type equivalence~(\ref{eq:jaskelioff-o-connor-theorem})
in three steps.

\textbf{(1)} Use the Yoneda identity to obtain this type equivalence:
\[
A\rightarrow F^{B}\cong\forall X.\,R^{X}\rightarrow F^{X}\quad.
\]
To derive this formula, write:
\begin{align*}
 & A\rightarrow F^{B}\\
{\color{greenunder}\text{covariant Yoneda identity}:}\quad & \cong A\rightarrow\forall X.\,(B\rightarrow X)\rightarrow F^{X}\\
{\color{greenunder}\text{move }\forall X\text{ to front}:}\quad & \cong\forall X.\,A\rightarrow(B\rightarrow X)\rightarrow F^{X}\\
{\color{greenunder}\text{uncurry the function}:}\quad & \cong\forall X.\,A\times(B\rightarrow X)\rightarrow F^{X}=\forall X.\,R^{X}\rightarrow F^{X}\quad.
\end{align*}
In the first line of this derivation, we have used the assumption
that $F$ is a (covariant) functor.

\textbf{(2)} By the universal property of the free $P$-typeclass
runner, for any functor $F$ that belongs to the $P$-typeclass and
for any functor $R$ (not necessarily a member of the $P$-typeclass)
there is a one-to-one correspondence between $P$-typeclass morphisms
$E^{R}\overset{P}{\rightarrow}F$ and natural transformations $R\leadsto F$.
In other words, there is a type equivalence between the following
types (where we wrote out the full type signatures): 
\[
\forall X.\,(E^{R})^{X}\overset{P}{\rightarrow}F^{X}\cong\forall X.\,R^{X}\rightarrow F^{X}\quad.
\]
Now we set $R^{T}\triangleq A\times(B\rightarrow T)$ and obtain:
\[
(A\rightarrow F^{B})\rightarrow F^{C}\cong(\forall X.\,R^{X}\rightarrow F^{X})\rightarrow F^{C}\cong(\forall X.\,(E^{R})^{X}\overset{P}{\rightarrow}F^{X})\rightarrow F^{C}\quad.
\]
So, the left-hand side of Eq.~(\ref{eq:jaskelioff-o-connor-theorem})
is equivalent to:
\[
\forall(F\in P\text{-typeclass}).\,(\forall X.\,(E^{R})^{X}\overset{P}{\rightarrow}F^{X})\rightarrow F^{C}\quad.
\]

\textbf{(3)} We use the covariant Yoneda identity in the category
of functors that belong to the $P$-typeclass. As we have found in
Section~\ref{subsec:Imposing-laws-of-P-typeclasses-via-monad-algebras},
all those functors are $E$-monad algebras, which form a category.
The $P$-typeclass morphisms are in one-to-one correspondence with
the $E$-monad algebra morphisms. Therefore, we may write the covariant
Yoneda identity for that category as:
\[
\forall(F\in P\text{-typeclass}).\,(\forall X.\,Q^{X}\overset{P}{\rightarrow}F^{X})\rightarrow S^{F}\cong S^{Q}\quad,
\]
where $Q$ is any fixed functor from the $P$-typeclass, $S^{F}$
is any type expression that is covariant in $F$, and the naturality
law with respect to $F$ is assumed to hold. We will use this Yoneda
identity with $Q=E^{R}$, and set $S^{F}$ to just $F^{C}$ (the application
of $F$ to the fixed type $C$). Then we get:
\[
\forall(F\in P\text{-typeclass}).\,(\forall X.\,(E^{R})^{X}\overset{P}{\rightarrow}F^{X})\rightarrow F^{C}\cong(E^{R})^{C}\quad.
\]
The last type is the right-hand side of Eq.~(\ref{eq:jaskelioff-o-connor-theorem}).
So, Eq.~(\ref{eq:jaskelioff-o-connor-theorem}) holds.

Let us now derive the code that implements the type equivalence~(\ref{eq:jaskelioff-o-connor-theorem})
in the direction of right-to-left. Suppose we are given a value $q$
of the type in the right-hand side of Eq.~(\ref{eq:jaskelioff-o-connor-theorem}):
\[
q:(E^{R})^{C}\quad.
\]
We need to retrace step \textbf{(3)} above and convert this $q$ to
a function $f$ of type:
\[
f:\forall(F\in P\text{-typeclass}).\,(\forall X.\,(E^{R})^{X}\overset{P}{\rightarrow}F^{X})\rightarrow F^{C}\quad.
\]
The required function $f$ is defined by:
\[
f^{F}\big(k^{:\forall X.\,(E^{R})^{X}\overset{P}{\rightarrow}F^{X}}\big)\triangleq k^{C}(q)\quad.
\]

Continue by retracing step \textbf{(2)}, converting $f$ to a function
$g$ of type:
\[
g:\forall(F\in P\text{-typeclass}).\,(\forall X.\,R^{X}\rightarrow F^{X})\rightarrow F^{C}\quad.
\]
The function $g$ is defined by:
\[
g^{F}\big(k^{:\forall X.\,R^{X}\rightarrow F^{X}}\big)\triangleq f^{F}\big(\forall Y.\,r^{:(E^{R})^{Y}}\rightarrow\text{run}_{E}^{R,Y}(k)(r)\big)\quad,
\]
where the universal runner ($\text{run}_{E}^{T,Y}$) has type:
\[
\text{run}_{E}^{T,Y}:(\forall X.\,T^{X}\rightarrow F^{X})\rightarrow(E^{T})^{Y}\rightarrow F^{Y}\quad.
\]

It remains to retrace step \textbf{(1)} and define a function $h$
of type:
\[
h:\forall(F\in P\text{-typeclass}).\,(A\rightarrow F^{B})\rightarrow F^{C}\quad.
\]
We implement $h$ via this code:
\[
h^{F}(k^{:A\rightarrow F^{B}})\triangleq g^{F}\big(\forall X.\,a^{:A}\times t^{:B\rightarrow X}\rightarrow k(a)\triangleright t^{\uparrow F}\big)\quad.
\]
This completes the code that transforms $q$ into $h$. $\square$

We will now apply the Jaskelioff-O\textsf{'}Connor theorem to prove some useful
type equivalences.

\subsubsection{Statement \label{subsec:Statement-identity-monad-morphism}\ref{subsec:Statement-identity-monad-morphism}}

Denote by $F\xrightarrow{\text{Monad}}G$ (more verbosely, $\forall X.\,F^{X}\xrightarrow{\text{Monad}}G^{X}$)
the type of monad morphisms between monads $F$ and $G$. Those are
natural transformations of type $\forall X.\,F^{X}\rightarrow G^{X}$
that additionally satisfy the laws of monad morphisms. Denote by $\text{Id}$
the identity monad ($\text{Id}^{A}\triangleq A$). 

\textbf{(a)} The standard monad method $\text{pu}_{M}:\forall A.\,A\rightarrow M^{A}$
is the only monad morphism of type $\text{Id}\xrightarrow{\text{Monad}}M$
that works in the same way for all monads $M$.\footnote{See \texttt{\href{https://cstheory.stackexchange.com/questions/53389/}{https://cstheory.stackexchange.com/questions/53389/}}}
We can express this as a type equivalence: 
\[
\forall M^{:\text{Monad}}.\,\text{Id}\xrightarrow{\text{Monad}}M\cong\bbnum 1\quad.
\]

\textbf{(b)} The identity function of type $\forall X.\,M^{X}\rightarrow M^{X}$
is the only monad morphism of type $M\xrightarrow{\text{Monad}}M$
that works in the same way for all monads $M$.\footnote{See \texttt{\href{https://stackoverflow.com/questions/61444425/}{https://stackoverflow.com/questions/61444425/}}}
We can express this as a type equivalence: 
\[
\forall M^{:\text{Monad}}.\,M\xrightarrow{\text{Monad}}M\cong\bbnum 1\quad.
\]


\subparagraph{Proof}

The \lstinline!Monad! typeclass has methods in the form of a $P$-typeclass
for functors $K$ if we define $P$ by $(P^{K})^{A}\triangleq A+K^{K^{A}}$.
Then the methods of the \lstinline!Monad! typeclass are represented
by a single value of type: 
\[
\forall A.\,(P^{K})^{A}\rightarrow K^{A}=\forall A.\,A+K^{K^{A}}\rightarrow K^{A}\cong(\forall A.\,A\rightarrow K^{A})\times(\forall A.\,K^{K^{A}}\rightarrow K^{A})\quad.
\]
This is a tuple type describing the type signatures of $K$\textsf{'}s \lstinline!pure!
and \lstinline!flatten! methods when $K$ is a monad. So, the Jaskelioff-O\textsf{'}Connor
theorem applies to the \lstinline!Monad! typeclass. The free monad
constructor ($E$) is defined recursively as $(E^{F})^{A}\triangleq A+F^{(E^{F})^{A}}$,
making $E^{F}$ a monad when $F$ is any functor. The free monad\textsf{'}s
universal runner is defined by:
\begin{align*}
 & \text{run}_{E}^{F,A}:(\forall X.\,F^{X}\rightarrow M^{X})\rightarrow(E^{F})^{A}\rightarrow M^{A}\quad,\\
 & \text{run}_{E}^{F,A}\big(k^{:\forall X.\,F^{X}\rightarrow M^{X}}\big)\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
F^{(E^{F})^{A}} & k^{(E^{F})^{A}}\bef\text{flm}_{M}\big(\overline{\text{run}}_{E}^{F,A}(k)\big)
\end{array}\quad.
\end{align*}

\textbf{(a)} Monad morphisms are natural transformations that satisfy
additional laws. We first consider the given type without restricting
the functions of type $A\rightarrow M^{A}$ to monad morphisms but
still assuming that they are natural transformations:
\[
\forall M^{:\text{Monad}}.\,\forall A.\,A\rightarrow M^{A}\quad.
\]
By the Yoneda identity, we get the type equivalence: 
\[
\forall A.\,A\rightarrow M^{A}\cong M^{\bbnum 1}\quad.
\]
So, we have reduced the type to $\forall M^{:\text{Monad}}.\,M^{\bbnum 1}$.
This type will be in the form suitable for the Jaskelioff-O\textsf{'}Connor
theorem~(\ref{eq:jaskelioff-o-connor-theorem}) if we set $F=M$,
$A=\bbnum 0$, $C=\bbnum 1$; the parameter $B$ remains unused since
$A\rightarrow M^{B}=\bbnum 0\rightarrow M^{B}\cong\bbnum 1$. Then
Eq.~(\ref{eq:jaskelioff-o-connor-theorem}) gives:
\[
\forall M^{:\text{Monad}}.\,M^{\bbnum 1}\cong\forall M^{:\text{Monad}}.\,(\bbnum 0\rightarrow M^{B})\rightarrow M^{\bbnum 1}\cong(E^{R})^{\bbnum 1}\quad,
\]
where we must define $R^{X}=A\times(B\rightarrow X)$. However, setting
$A=\bbnum 0$ gives also $R=\bbnum 0$. Then the free monad $E^{R}$
is the identity functor: 
\[
(E^{R})^{C}=C+R^{(E^{R})^{C}}=C+\bbnum 0\cong C\quad.
\]
Finally, we obtain $(E^{R})^{\bbnum 1}=\bbnum 1$, and so:
\[
\forall M^{:\text{Monad}}.\,\forall A.\,A\rightarrow M^{A}\cong\bbnum 1\quad.
\]

We conclude that \emph{without} restricting to monad morphisms there
is only a single function of the given type. It remains to derive
the code for that function and to verify that it is indeed a monad
morphism.

We begin with a unit value (that we denote by $1$) viewed as a value
of type $(E^{R})^{C}$ in the right-hand side of Eq.~(\ref{eq:jaskelioff-o-connor-theorem}).
We follow the proof of Statement~\ref{subsec:Statement-Jaskelioff-OConnor}.
The first step is to convert the value of type $(E^{R})^{C}$ into
a function $f$ of type:
\[
f:\forall M^{:\text{Monad}}.\,\big(\forall X.\,(E^{R})^{X}\xrightarrow{\text{Monad}}M^{X}\big)\rightarrow M^{C}\quad.
\]
In our case, this function is simplified to:
\begin{align*}
 & f:\forall M^{:\text{Monad}}.\,\big(\forall X.\,\text{Id}^{X}\xrightarrow{\text{Monad}}M^{X}\big)\rightarrow M^{\bbnum 1}\quad,\\
 & f^{M}\big(k^{:\forall X.\,\text{Id}^{X}\xrightarrow{\text{Monad}}M^{X}}\big)\triangleq k^{\bbnum 1}(1)\quad.
\end{align*}
The next step is to convert $f$ to a function $g$ of type:
\[
g:\forall M^{:\text{Monad}}.\,(\forall X.\,R^{X}\rightarrow M^{X})\rightarrow M^{C}\quad.
\]
In our case, $R^{X}=\bbnum 0$ and $R^{X}\rightarrow M^{X}\cong\bbnum 1$,
so this function is simplified to: 
\begin{align*}
 & g:\forall M^{:\text{Monad}}.\,\bbnum 1\rightarrow M^{\bbnum 1}\quad,\\
 & g^{M}(k^{:\bbnum 1})\triangleq f^{M}\big(\forall Y.\,r^{:(E^{R})^{Y}}\rightarrow\text{run}_{E}^{R,Y}(k)(r)\big)\\
 & \quad=f^{M}(\forall Y.\,r^{:Y}\rightarrow\text{pu}_{M}^{Y}(r))=\text{pu}_{M}^{\bbnum 1}(1)\quad.
\end{align*}
Finally, we convert $g$ to a function $h$ of type:
\begin{align*}
 & h:\forall M^{:\text{Monad}}.\,(A\rightarrow M^{B})\rightarrow M^{C}\\
 & =\forall M^{:\text{Monad}}.\,(\bbnum 0\rightarrow M^{B})\rightarrow M^{\bbnum 1}\quad.\\
 & \cong\forall M^{:\text{Monad}}.\,\bbnum 1\rightarrow M^{\bbnum 1}\cong\forall M^{:\text{Monad}}.\,M^{\bbnum 1}\quad.
\end{align*}
 There exists only one value of type $\forall M^{:\text{Monad}}.\,M^{\bbnum 1}$,
and that value is $\text{pu}_{M}(1)$. Converting that to the type
signature $\forall A.\:A\rightarrow M^{A}$, we recover just the standard
monad method $\text{pu}_{M}$. We know that $\text{pu}_{M}$ gives
a monad morphism between the identity monad and $M$ (see Statement~\ref{subsec:Statement-pure-M-is-monad-morphism}).
So, we have proved that there exists a unique monad morphism of type
$\forall M^{:\text{Monad}}.\,\text{Id}\xrightarrow{\text{Monad}}M$. 

\textbf{(b)} Again, we first consider the given type without restricting
the functions of type $M^{X}\rightarrow M^{X}$ to monad morphisms
(but still assuming that they are natural transformations):
\[
\forall M^{:\text{Monad}}.\,\forall X.\,M^{X}\rightarrow M^{X}\quad.
\]
This type will be in the form suitable for the Jaskelioff-O\textsf{'}Connor
theorem~(\ref{eq:jaskelioff-o-connor-theorem}) if we set $F=M$,
$A=\bbnum 1$, and $B=C=X$. The functor $R$ is then defined by:
\[
R^{T}\triangleq A\times(B\rightarrow T)\cong X\rightarrow T\quad,
\]
and the functor $E^{R}$ (the free monad on $R$) is defined recursively
by:
\[
(E^{R})^{T}\triangleq T+\big(X\rightarrow(E^{R})^{T}\big)\quad.
\]
 With these definitions, Eq.~(\ref{eq:jaskelioff-o-connor-theorem})
gives:
\[
\forall M^{:\text{Monad}}.\,\forall X.\,M^{X}\rightarrow M^{X}\cong\forall X.\,(E^{R})^{X}\quad.
\]
We are using the functor $(E^{R})^{T}$ with the type parameter $T=X$;
however, $E^{R}$ also contains $X$ through the definition of $R$.
To avoid confusion and to simplify notation, let us write $G^{X}$
instead of $(E^{R})^{X}$, where the type constructor $G$ is defined
recursively by:
\[
G^{X}\triangleq X+(X\rightarrow G^{X})\quad.
\]
(Note that $G$ is neither covariant nor contravariant.) With this
definition, we obtain:
\[
\forall M^{:\text{Monad}}.\,\forall X.\,M^{X}\rightarrow M^{X}\cong\forall X.\,G^{X}\quad.
\]

To simpify the type $\forall X.\,G^{X}$, begin by expanding the recursive
type $G^{X}$:
\begin{align*}
 & \forall X.\,G^{X}\cong\forall X.\,X+(X\rightarrow G^{X})\\
{\color{greenunder}\text{non-disjunctivity}:}\quad & \cong(\forall X.\,X)+(\forall X.\,X\rightarrow G^{X})\\
{\color{greenunder}\text{use }\forall X.\,X\cong\bbnum 0:}\quad & \cong\forall X.\,X\rightarrow G^{X}\quad.
\end{align*}
Here we used the non-disjunctivity property from Example~\ref{subsec:Example-undisjunctive-type-constructors}(e).

Continue expanding the recursive type:
\begin{align*}
 & \forall X.\,X\rightarrow G^{X}\cong\forall X.\,X\rightarrow(X+(X\rightarrow G^{X}))\\
{\color{greenunder}\text{non-disjunctivity}:}\quad & \cong(\gunderline{\forall X.\,X\rightarrow X})+\big(\forall X.\,X\rightarrow X\rightarrow G^{X}\big)\\
 & \cong\bbnum 1+\forall X.\,X\times X\rightarrow G^{X}\quad.
\end{align*}
The relevant non-disjunctivity property was shown in Example~\ref{subsec:Example-undisjunctive-type-constructors}(f).
Expand further, using the same non-disjunctivity property:
\begin{align*}
 & \forall X.\,G^{X}\cong\bbnum 1+\forall X.\,X\times X\rightarrow G^{X}\\
 & \cong\bbnum 1+\forall X.\,X\times X\rightarrow(X+(X\rightarrow G^{X}))\\
{\color{greenunder}\text{non-disjunctivity}:}\quad & \cong\bbnum 1+(\gunderline{\forall X.\,X\times X\rightarrow X})+\big(\forall X.\,X\times X\rightarrow X\rightarrow G^{X}\big)\\
 & \cong\bbnum 1+\bbnum 2+\forall X.\,X\times X\times X\rightarrow G^{X}\quad.
\end{align*}
Proceeding similarly, we obtain:
\[
\forall X.\,\underbrace{X\times...\times X}_{n\text{ times}}\rightarrow G^{X}\cong\underbrace{\bbnum 1+...+\bbnum 1}_{n\text{ times}}+\forall X.\,\underbrace{X\times...\times X}_{n+1\text{ times}}\rightarrow G^{X}\quad.
\]
It follows by induction that $\forall X.\,G^{X}$ is equivalent to
an \textsf{``}infinite\textsf{''} sum type:
\[
\forall X.\,G^{X}\cong\bbnum 1+\bbnum 2+\bbnum 3+...
\]
Values of that type may be described by pairs $\left(n,k\right)$
of natural numbers such that $1\le k\le n$. The number $n$ chooses
the part \textsf{``}$\bbnum n$\textsf{''} within the disjunctive type $\bbnum 1+\bbnum 2+\bbnum 3+...$,
where we denoted by \textsf{``}$\bbnum n$\textsf{''} the type $\underbrace{\bbnum 1+...+\bbnum 1}_{n\text{ times}}$.
The number $k$ chooses a specific unit value within $\underbrace{\bbnum 1+...+\bbnum 1}_{n\text{ times}}$.

The next step is to convert values $\left(n,k\right)$ of that type
into functions of type $M^{X}\rightarrow M^{X}$ that work in the
same way for all monads $M$ and all types $X$. We have to find out
whether any of those functions obey the laws of monad morphisms. For
that, we need to derive the specific code of those functions. We follow
the steps outlined in the proof of Statement~\ref{subsec:Statement-Jaskelioff-OConnor}.

First, we translate pairs $\left(n,k\right)$ into values of type
$\forall X.\,G^{X}$ that we will denote by $q_{n,k}$. To achieve
that, we need to retrace the way we expanded the recursive type $G^{X}$.
As an example, consider the pair $\left(n=2,k=1\right)$. The value
$n=2$ corresponds to the type $\bbnum 2$, which was obtained from
$\forall X.\,X\rightarrow X\rightarrow X$ during expansion of $\forall X.\,G^{X}$.
The type $\forall X.\,X\rightarrow X\rightarrow X$ has only two distinct
values, which are functions that return the first or the second argument
of type $X$. The index $k=1$ selects the first of those values,
which is a function whose code is written as $x_{1}^{:X}\rightarrow x_{2}^{:X}\rightarrow x_{1}$. 

To simplify notation, let us temporarily fix the type parameter $X$;
we will restore the quantifier $\forall X$ at the end of the derivation.

The type $X\rightarrow X\rightarrow X$ was found during expansion
of the recursive type $G^{X}$ as:
\[
G^{X}=X+(X\rightarrow(X+(X\rightarrow(X+...))))\quad.
\]
So, the pair $\left(n=2,k=1\right)$ corresponds to the function $q_{2,1}^{X}:G^{X}$
written as: 
\begin{align*}
 & q_{2,1}^{X}:X+(X\rightarrow(X+(X\rightarrow(X+(X\rightarrow G^{X})))))\quad,\\
 & q_{2,1}^{X}\triangleq\bbnum 0^{:X}+(x_{1}^{:X}\rightarrow(\bbnum 0^{:X}+(x_{2}^{:X}\rightarrow(x_{1}+\bbnum 0^{:X\rightarrow G^{X}}))))\quad.
\end{align*}
In a similar way, we define the functions $q_{n,k}$ for any $1\le k\le n$:
\[
q_{n,k}^{X}\triangleq\bbnum 0^{:X}+(x_{1}^{:X}\rightarrow(\bbnum 0^{:X}+(x_{2}^{:X}\rightarrow...\rightarrow(\bbnum 0^{:X}+(x_{n}^{:X}\rightarrow(x_{k}+\bbnum 0^{:X\rightarrow G^{X}})))...)))\quad.
\]
To make this code description rigorous, let us define $u_{i,n,k}$
and $v_{i,n}$ like this:
\begin{align*}
 & u_{i,n,k}\triangleq\bbnum 0^{:X}+(x_{i}^{:X}\rightarrow(\bbnum 0^{:X}+(x_{i+1}^{:X}\rightarrow...\rightarrow(x_{n}^{:X}\rightarrow(x_{k}+\bbnum 0^{:X\rightarrow G^{X}}))...))),\\
 & v_{i,n}(x_{0})\triangleq\bbnum 0^{:X}+(x_{i}^{:X}\rightarrow(\bbnum 0^{:X}+(x_{i+1}^{:X}\rightarrow...\rightarrow(x_{n}^{:X}\rightarrow(x_{0}+\bbnum 0^{:X\rightarrow G^{X}}))...))).
\end{align*}
These formulas hold for $1\le i\le k\le n$. An inductive definition
of $q_{n,k}^{X}$, $u_{i,n,k}$, and $v_{i,n}$ is:
\begin{align*}
 & q_{n,k}^{X}=u_{1,n,k}\quad,\quad\quad u_{i,n,k}:G^{X}\quad,\quad\quad v_{i,n}:X\rightarrow G^{X}\quad,\\
{\color{greenunder}\text{for }1\le i<k\le n:}\quad & u_{i,n,k}=\bbnum 0^{:X}+(x_{i}^{:X}\rightarrow u_{i+1,k,n})\quad,\\
{\color{greenunder}\text{for }1\le k<n:}\quad & u_{k,n,k}=\bbnum 0^{:X}+(x_{k}^{:X}\rightarrow v_{k+1,n}(x_{k}))\quad,\\
{\color{greenunder}\text{for }1\le i<n:}\quad & v_{i,n}(x^{:X})=\bbnum 0^{:X}+(x_{i}^{:X}\rightarrow v_{i+1,n}(x))\quad,\\
 & v_{n,n}(x^{:X})=x+\bbnum 0^{:X\rightarrow G^{X}}\quad.
\end{align*}

Next, we need to convert $q_{n,k}^{X}$ of type $G^{X}=(E^{R})^{X}$
into a function $f_{n,k}$ of type:
\[
f_{n,k}:\forall M^{:\text{Monad}}.\,\big(\forall T.\,(E^{R})^{T}\xrightarrow{\text{Monad}}M^{T}\big)\rightarrow M^{X}\quad.
\]
The code of $f_{n,k}$ is:
\[
f_{n,k}^{M}\big(p^{:\forall T.\,(E^{R})^{T}\xrightarrow{\text{Monad}}M^{T}}\big)\triangleq p^{X}(q_{n,k}^{X})\quad.
\]
At this point, $p$ is an arbitrary function, so we cannot simplify
this code any further. We proceed to converting $f_{n,k}$ into a
function $g_{n,k}$:
\begin{align*}
 & g_{n,k}:\forall M^{:\text{Monad}}.\,(\forall T.\,R^{T}\rightarrow M^{T})\rightarrow M^{X}\quad,\\
 & g_{n,k}^{M}\big(p^{:\forall T.\,R^{T}\rightarrow M^{T}}\big)\triangleq f_{n,k}^{M}\big(\forall T.\,r^{:(E^{R})^{T}}\rightarrow\text{run}_{E}^{R,T}(p)(r)\big)\\
 & \quad=\text{run}_{E}^{R,X}(p)(q_{n,k}^{X})\quad.
\end{align*}
In our case, $R^{T}=X\rightarrow T$, so the type of $p$ is equivalent
to just $M^{X}$:
\begin{align*}
 & \forall T.\,R^{T}\rightarrow M^{T}=\forall T.\,(X\rightarrow T)\rightarrow M^{T}\\
{\color{greenunder}\text{covariant Yoneda identity}:}\quad & \cong M^{X}\quad.
\end{align*}
Given a value $m:M^{X}$, the corresponding value $p:\forall T.\,R^{T}\rightarrow M^{T}$
is computed as:
\[
p:\forall T.\,(X\rightarrow T)\rightarrow M^{T}\quad,\quad\quad p^{T}(r^{:X\rightarrow T})\triangleq m\triangleright r^{\uparrow M}\quad.
\]
So, the last step is to convert $g_{n,k}^{M}$ into $h_{n,k}^{M}$
of type $M^{X}\rightarrow M^{X}$:
\begin{align*}
 & h_{n,k}:\forall M^{:\text{Monad}}.\,M^{X}\rightarrow M^{X}\quad,\\
 & h_{n,k}^{M}(m^{:M^{X}})\triangleq g_{n,k}^{M}(p)=\text{run}_{E}^{R,X}(p)(q_{n,k}^{X})\quad,\\
{\color{greenunder}\text{where we defined}:}\quad & p\triangleq\forall T.\,r^{:X\rightarrow T}\rightarrow m\triangleright r^{\uparrow M}\quad.
\end{align*}

At this point, we must use the definition of $\text{run}_{E}$ to
derive specific code for $h_{n,k}^{M}$. A first simplification is
to apply $\text{run}_{E}^{R,X}(p)$ substituting the required value
of $p$:
\begin{align*}
 & \text{run}_{E}^{R,X}(p)=\,\begin{array}{|c||c|}
 & M^{X}\\
\hline X & \text{pu}_{M}\\
X\rightarrow G^{X} & p^{G^{X}}\bef\text{flm}_{M}\big(\overline{\text{run}}_{E}^{R,X}(p)\big)
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & M^{X}\\
\hline X & \text{pu}_{M}\\
X\rightarrow G^{X} & r^{:X\rightarrow G^{X}}\rightarrow m\triangleright\gunderline{r^{\uparrow M}\bef\text{flm}_{M}}\big(\overline{\text{run}}_{E}^{R,X}(p)\big)
\end{array}\\
{\color{greenunder}\text{naturality law of }\text{flm}_{M}:}\quad & =\,\,\begin{array}{|c||c|}
 & M^{X}\\
\hline X & \text{pu}_{M}\\
X\rightarrow G^{X} & r^{:X\rightarrow G^{X}}\rightarrow m\triangleright\text{flm}_{M}\big(r\bef\overline{\text{run}}_{E}^{R,X}(p)\big)
\end{array}\quad.
\end{align*}

To get more intuition, let us compute $\text{run}_{E}^{R,X}(p)(q_{2,1})$
using the expression for $q_{2,1}$ derived earlier:
\begin{align*}
 & \text{run}_{E}^{R,X}(p)(q_{2,1}^{X})=q_{2,1}^{X}\triangleright\text{run}_{E}^{R,X}(p)\\
 & =\,\begin{array}{|cc|}
\bbnum 0 & x_{1}^{:X}\rightarrow\bbnum 0+(x_{2}^{:X}\rightarrow(x_{1}+\bbnum 0))\end{array}\,\triangleright\,\begin{array}{|c||c|}
 & M^{X}\\
\hline X & \text{pu}_{M}\\
X\rightarrow G^{X} & r^{:X\rightarrow G^{X}}\rightarrow m\triangleright\text{flm}_{M}\big(r\bef\overline{\text{run}}_{E}^{R,X}(p)\big)
\end{array}\\
 & =m\triangleright\text{flm}_{M}\big(x_{1}^{:X}\rightarrow\overline{\text{run}}_{E}^{R,X}(p)(\bbnum 0+(x_{2}^{:X}\rightarrow(x_{1}+\bbnum 0)))\big)\quad.
\end{align*}
Now we go through a similar calculation with a smaller sub-expression:
\begin{align*}
 & \overline{\text{run}}_{E}^{R,X}(p)(\bbnum 0+(x_{2}^{:X}\rightarrow(x_{1}+\bbnum 0)))\\
 & =\,\begin{array}{|cc|}
\bbnum 0 & x_{2}^{:X}\rightarrow(x_{1}+\bbnum 0)\end{array}\,\triangleright\,\begin{array}{|c||c|}
 & M^{X}\\
\hline X & \text{pu}_{M}\\
X\rightarrow G^{X} & r^{:X\rightarrow G^{X}}\rightarrow m\triangleright\text{flm}_{M}\big(r\bef\overline{\text{run}}_{E}^{R,X}(p)\big)
\end{array}\\
 & =m\triangleright\text{flm}_{M}(x_{2}^{:X}\rightarrow\overline{\text{run}}_{E}^{R,X}(p)(x_{1}+\bbnum 0))\quad.
\end{align*}
Finally, we calculate the last sub-expression:
\begin{align*}
 & \overline{\text{run}}_{E}^{R,X}(p)(x_{1}+\bbnum 0)\\
 & =\,\begin{array}{|cc|}
x_{1} & \bbnum 0\end{array}\,\triangleright\,\begin{array}{|c||c|}
 & M^{X}\\
\hline X & \text{pu}_{M}\\
X\rightarrow G^{X} & r^{:X\rightarrow G^{X}}\rightarrow m\triangleright\text{flm}_{M}\big(r\bef\overline{\text{run}}_{E}^{R,X}(p)\big)
\end{array}=\text{pu}_{M}(x_{1})\quad.
\end{align*}
Putting the sub-expressions together, we get:
\[
h_{2,1}^{M}(m)=\text{run}_{E}^{R,X}(p)(q_{2,1}^{X})=m\triangleright\text{flm}_{M}\big(x_{1}^{:X}\rightarrow m\triangleright\text{flm}_{M}(x_{2}^{:X}\rightarrow\text{pu}_{M}(x_{1}))\big)\quad.
\]
Written in the Scala syntax, the last expression looks like this:
\begin{lstlisting}
def h_2_1(m: M[X]): M[X] = m.flatMap { x_1 => m.flatMap { x_2 => pure(x_1) } }
\end{lstlisting}
This code can be rewritten as a functor block, making its logic more
visually clear:
\begin{lstlisting}
def h_2_1(m: M[X]): M[X] = for {
  x_1 <- m
  x_2 <- m
} yield x_1
\end{lstlisting}
The code runs two effects of \lstinline!m! but returns the first
value (\lstinline!x_1!), ignoring \lstinline!x_2!.

Now we can generalize the code pattern from $h_{2,1}$ to $h_{n,k}$
and write symbolically: 
\begin{lstlisting}
def h_n_k(m: M[X]): M[X] = for {
  x_1 <- m
  x_2 <- m
  ...
  x_n <- m
} yield x_k
\end{lstlisting}

To prove that this is indeed the correct code for $h_{n,k}^{M}(m)$,
we need to use induction in $n$. We rewrite $q_{n,k}^{X}=u_{1,n,k}$
and compute $\text{run}_{E}^{R,X}(p)(q_{n,k})=\text{run}_{E}^{R,X}(p)(u_{1,n,k})$.
Using the code of $\text{run}_{E}$, we obtain the following inductive
code definitions:
\begin{align*}
{\color{greenunder}\text{for }1\le i<k\le n:}\quad & \text{run}_{E}^{R,X}(p)(u_{i,n,k})=m\triangleright\text{flm}_{M}\big(x_{i}^{:X}\rightarrow\text{run}_{E}^{R,X}(p)(u_{i+1,n,k})\big)\quad,\\
{\color{greenunder}\text{for }1\le k<n:}\quad & \text{run}_{E}^{R,X}(p)(u_{k,n,k})=m\triangleright\text{flm}_{M}\big(x_{k}^{:X}\rightarrow\text{run}_{E}^{R,X}(p)(v_{k+1,n}(x_{k}))\big)\quad,\\
{\color{greenunder}\text{for }1\le i<n:}\quad & \text{run}_{E}^{R,X}(p)(v_{i,n}(x))=m\triangleright\text{flm}_{M}\big(x_{i}^{:X}\rightarrow\text{run}_{E}^{R,X}(p)(v_{i+1,n}(x))\big)\quad,\\
 & \text{run}_{E}^{R,X}(p)(v_{n,n}(x))=\text{pu}_{M}(x)\quad.
\end{align*}
It follows that $h_{n,k}(m)$ is indeed of the form:
\[
m\triangleright\text{flm}_{M}(x_{1}^{:X}\rightarrow m\triangleright\text{flm}_{M}(x_{2}^{:X}\rightarrow...\rightarrow m\triangleright\text{flm}_{M}(x_{n}^{:X}\rightarrow\text{pu}_{M}(x_{k}))...))\quad.
\]
This exactly corresponds to the schematic Scala code for \lstinline!h_n_k!
we just showed.

It remains to check whether the functions $h_{n,k}$ are monad morphisms.
We note that $h_{1,1}$ is an identity function, due to the monad
$M$\textsf{'}s identity law:
\[
h_{1,1}^{M}(m)=m\triangleright\text{flm}_{M}(\gunderline{x_{1}^{:X}\rightarrow\text{pu}_{M}(x_{1})})=m\triangleright\gunderline{\text{flm}_{M}(\text{pu}_{M})}=m\quad.
\]
So, $h_{1,1}$ is (trivially) a monad morphism. We will now show that
$h_{n,k}$ for $n\ge2$ are \emph{not} monad morphisms. It is sufficient
to choose a specific monad $M$ and to show that a specific monad
morphism law fails. We will check the monad morphism composition law:
for any value $q:M^{M^{X}}$, 
\[
h_{n,k}(\text{ftn}_{M}(q))\overset{?}{=}\text{ftn}_{M}(h_{n,k}(q\triangleright h_{n,k}^{\uparrow M}))\quad.
\]
We choose $M$ as the standard \lstinline!State! monad with the internal
state of type \lstinline!Int!. To show a counterexample that disproves
the composition law, we will use a specially chosen value $q$ of
type \lstinline!State[Int, State[Int, Unit]]!:
\begin{lstlisting}
type M[A] = Int => (A, Int)
val q: M[M[Unit]] = { s => ( { t => ((), s + 1) }, s) }
\end{lstlisting}
\[
M^{A}\triangleq\text{Int}\rightarrow A\times\text{Int}\quad,\quad\quad q:M^{M^{\bbnum 1}}\quad,\quad q\triangleq s^{:\text{Int}}\rightarrow(\_^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+1)^{:\text{Int}})\times s\quad.
\]
For more intuition, let us express \lstinline!q! via the \lstinline!State!
monad operations \lstinline!get! and \lstinline!set!:
\begin{lstlisting}
val get: M[Int] = s => (s, s)
val set: Int => M[Unit] = x => s => ((), x)
// Assuming that map and flatMap are defined for M:
val q: M[M[Unit]] = for {
  s <- get
} yield set(s + 1)
\end{lstlisting}
Now we compute the two sides of the composition law, step by step.
First, we will use Scala\textsf{'}s functor block syntax. The \lstinline!flatten!
method can be written as:
\begin{lstlisting}
def flatten[A](mm: M[M[A]]): M[A] = for {
  m <- mm
  x <- m
} yield x
\end{lstlisting}
Substituting the value \lstinline!q! defined above, we get:
\begin{lstlisting}
val flatten_q: M[Unit] = for {  // This is flatten(q).
  m <- for {
         s <- get
       } yield set(s + 1)
  x <- m
} yield x
\end{lstlisting}
Eliminate the nested \lstinline!for! and obtain:
\begin{lstlisting}
val flatten_q: M[Unit] = for {
  s <- get
  m = set(s + 1)
  x <- m
} yield x
\end{lstlisting}
Or equivalently (as the returned value is always a unit value):
\begin{lstlisting}
val flatten_q: M[Unit] = for {
  s <- get
  _ <- set(s + 1)
} yield ()
\end{lstlisting}
Applying \lstinline!h_n_k! to this value means writing code of the
form:
\begin{lstlisting}
val h_flatten_q: M[Unit] = for {
  x_1 <- flatten_q
  ...
  x_n <- flatten_q
} yield x_k
\end{lstlisting}
The returned value in \lstinline!x_k! is in any case the unit value,
so let us focus on the state updates. Each \lstinline!flatten_q!
has the effect of reading the state value \lstinline!s! and storing
the incremented value \lstinline!s + 1!. The function \lstinline!h_n_k!
repeats $n$ times the effect of \lstinline!flatten_q!. This increments
the internal state $n$ times. So, the left-hand side of the law is
equivalent to:
\begin{lstlisting}
val lhs: M[Unit] = for { // This is h_flatten_q === h_n_k(flatten(q)).
  s <- get
  _ <- set(s + n)
} yield ()
\end{lstlisting}

Turning now to the right-hand side of the law, we write the first
sub-expression ($q\triangleright h_{n,k}^{\uparrow M}$, or in Scala,
\lstinline!q.map(h_n_k)!) as the following Scala code:
\begin{lstlisting}
val q_map_h: M[M[Unit]] = for {
  m <- q
} yield h_n_k(m)
\end{lstlisting}
Substituting the code of \lstinline!q! (but not yet expanding \lstinline!h_n_k!),
we find:
\begin{lstlisting}
val q_map_h: M[M[Unit]] = for {
  s <- get
} yield h_n_k(set(s + 1))
\end{lstlisting}
The function call \lstinline!h_n_k(set(s + 1))! repeats $n$ times
the effect of \lstinline!set(s + 1)!, but \lstinline!s! is a fixed
value in that scope, so the result is equal to just a single effect:
\begin{lstlisting}
val q_map_h: M[M[Unit]] = for {
  s <- get
} yield set(s + 1)
\end{lstlisting}
This is the same value as \lstinline!q! itself.

The next sub-expression is \lstinline!h_n_k(q_map_h)!, which equals
\lstinline!h_n_k(q)!:
\begin{lstlisting}
val h_q_map_h: M[M[Unit]] = for {
  x_1 <- q
  ...
  x_n <- q
} yield x_k
\end{lstlisting}
Substituting the code for \lstinline!q!, we get:
\begin{lstlisting}
val h_q_map_h: M[M[Unit]] = for {
  x_1 <- for {
           s <- get
         } yield set(s + 1)
  ...
  x_n <- for {
           s <- get
         } yield set(s + 1)
} yield x_k
\end{lstlisting}
Eliminate the nested \lstinline!for! and obtain:
\begin{lstlisting}
val h_q_map_h: M[M[Unit]] = for {
  s <- get
  x_1 = set(s + 1)
  ...
  s <- get
  x_n = set(s + 1)
} yield x_k
\end{lstlisting}
The code runs $n$ times the effect of \lstinline!get! but actually
never runs the effect of \lstinline!set!; the unevaluated effectful
value \lstinline!set(s + 1)! is merely assigned to each \lstinline!x_i!
and then returned. So, the code is equivalent to:
\begin{lstlisting}
val h_q_map_h: M[M[Unit]] = for {
  s <- get
} yield set(s + 1)
\end{lstlisting}
This is again just equal to \lstinline!q!.

It remains to apply \lstinline!flatten! to \lstinline!h_q_map_h!,
which is the same as \lstinline!flatten(q)! and was already computed
as \lstinline!flatten_q! above:
\begin{lstlisting}
val rhs: M[Unit] = for { // This is flatten(h_q_map_h) === flatten(q).
  s <- get
  _ <- set(s + 1)
} yield ()
\end{lstlisting}

The left-hand side and the right-hand side of the law differ only
in the \lstinline!set! operation (\lstinline!set(s + n)! vs.~\lstinline!set(s + 1)!).
So, they are equal only when $n=1$ (that is, for \lstinline!h_1_1!).
It follows that, for all $n\ge2$ and for all $1\le k\le n$, the
function $h_{n,k}$ of type $M^{X}\rightarrow M^{X}$ violates the
composition law of monad morphisms when applied to the chosen value
$q:M^{M^{X}}$.

Let us now summarize this derivation in code notation. The left-hand
side of the composition law is: 
\begin{align*}
 & \text{ftn}_{M}(q)=s^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+1)^{:\text{Int}}\quad,\\
 & h_{n,k}(\text{ftn}_{M}(q))=s^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+n)^{:\text{Int}}\quad.
\end{align*}
Here we used the fact that $h_{n,k}(m)$ repeats $n$ times the effect
of $m$ (and that effect increments the value $s$). 

Turn to the right-hand side of the law and calculate:
\begin{align*}
 & q\triangleright h_{n,k}^{\uparrow M}=s^{:\text{Int}}\rightarrow(\_^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+1)^{:\text{Int}})\times s=q\quad,\\
 & h_{n,k}(q\triangleright h_{n,k}^{\uparrow M})=s^{:\text{Int}}\rightarrow(\_^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+1)^{:\text{Int}})\times s=q\quad,\\
 & \text{ftn}_{M}(q)=s^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+1)^{:\text{Int}}\quad.
\end{align*}
The condition for the two sides of the law to be equal is:
\[
s^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+n)^{:\text{Int}}\overset{?}{=}s^{:\text{Int}}\rightarrow1^{:\bbnum 1}\times(s+1)^{:\text{Int}}\quad.
\]
This holds only if $n=1$.

It follows that $h_{1,1}$ (which is an identity function of type
$M^{X}\rightarrow M^{X}$) is the only monad morphism that fits the
required type. $\square$

\subsection{Existential type quantifiers. Co-Yoneda and other identities}

The Yoneda identities allow us in many cases to simplify type expressions
with universal quantifiers. Similar identities hold for existentially
quantified types.

For the purposes of this and the following sections, we define the
existential quantifier via Eq.~(\ref{eq:existential-via-universal-Yoneda}):
\[
\exists C.\,F^{C}\cong\forall D.\,\big(\forall C.\,(F^{C}\rightarrow D)\big)\rightarrow D\quad.
\]
Here $F$ is any type constructor (not necessarily covariant or contravariant).

\subsubsection{Statement \label{subsec:Statement-co-Yoneda-two-identities}\ref{subsec:Statement-co-Yoneda-two-identities}}

For any functor $F$ and any contrafunctor $H$, the following identities
hold:
\begin{align*}
{\color{greenunder}\text{\textbf{(a)} }\text{covariant co-Yoneda identity}:}\quad & \exists A.\,(A\rightarrow R)\times F^{A}\cong F^{R}\quad,\\
{\color{greenunder}\text{\textbf{(b)} }\text{contravariant co-Yoneda identity}:}\quad & \exists A.\,(R\rightarrow A)\times H^{A}\cong H^{R}\quad.
\end{align*}


\subparagraph{Proof}

We use Eq.~(\ref{eq:existential-via-universal-Yoneda}) to express
$\exists A$ via $\forall A$. 

\textbf{(a)} We write:
\begin{align*}
{\color{greenunder}\text{expect to equal }F^{R}:}\quad & \exists A.\,(A\rightarrow R)\times F^{A}\\
{\color{greenunder}\text{definition of }\exists\text{ in Eq.~}(\ref{eq:existential-via-universal-Yoneda}):}\quad & \cong\forall B.\,\big(\forall A.\,\gunderline{(A\rightarrow R)\times F^{A}}\rightarrow B\big)\rightarrow B\\
{\color{greenunder}\text{uncurry arguments}:}\quad & \cong\forall B.\,\big(\gunderline{\forall A.\,(A\rightarrow R)\rightarrow F^{A}\rightarrow B}\big)\rightarrow B\\
{\color{greenunder}\text{contravariant Yoneda identity}:}\quad & \cong\gunderline{\forall B.\,\big(F^{R}\rightarrow B\big)\rightarrow B}\\
{\color{greenunder}\text{covariant Yoneda identity}:}\quad & \cong F^{R}\quad.
\end{align*}

\textbf{(b)} We write:
\begin{align*}
{\color{greenunder}\text{expect to equal }H^{R}:}\quad & \exists A.\,(R\rightarrow A)\times H^{A}\\
{\color{greenunder}\text{definition of }\exists\text{ in Eq.~}(\ref{eq:existential-via-universal-Yoneda}):}\quad & \cong\forall B.\,\big(\forall A.\,\gunderline{(R\rightarrow A)\times H^{A}}\rightarrow B\big)\rightarrow B\\
{\color{greenunder}\text{uncurry arguments}:}\quad & \cong\forall B.\,\big(\gunderline{\forall A.\,(R\rightarrow A)\rightarrow H^{A}\rightarrow B}\big)\rightarrow B\\
{\color{greenunder}\text{covariant Yoneda identity}:}\quad & \cong\gunderline{\forall B.\,\big(H^{R}\rightarrow B\big)\rightarrow B}\\
{\color{greenunder}\text{covariant Yoneda identity}:}\quad & \cong H^{R}\quad.
\end{align*}
$\square$

To build up intuition, let us substitute $R=\bbnum 0$ and $R=\bbnum 1$
into the co-Yoneda identities:

\subsubsection{Statement \label{subsec:Statement-co-Yoneda-two-identities-1}\ref{subsec:Statement-co-Yoneda-two-identities-1}}

The following type equivalences hold:
\begin{align*}
{\color{greenunder}\text{\textbf{(a)} for any functor }F:}\quad & \exists A.\,F^{A}\cong F^{\bbnum 1}\quad,\\
{\color{greenunder}\text{\textbf{(b)} for any contrafunctor }F:}\quad & \exists A.\,H^{A}\cong H^{\bbnum 0}\quad.
\end{align*}


\subparagraph{Proof}

For \textbf{(a)}, set $R=\bbnum 1$ in the covariant co-Yoneda identity:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \exists A.\,(\gunderline{A\rightarrow\bbnum 1})\times F^{A}\cong\exists A.\,\bbnum 1\times F^{A}\cong\exists A.\,F^{A}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & F^{\bbnum 1}\quad.
\end{align*}

For \textbf{(b)}, set $R=\bbnum 0$ in the contravariant co-Yoneda
identity:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \exists A.\,(\gunderline{\bbnum 0\rightarrow A})\times H^{A}\cong\exists A.\,\bbnum 1\times H^{A}\cong\exists A.\,H^{A}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & H^{\bbnum 0}\quad.
\end{align*}
 $\square$

With these properties, we get the following examples of type equivalences:
\begin{align*}
 & \exists A.\,A\cong\bbnum 1\quad,\quad\quad\exists A.\,A\rightarrow R\cong\bbnum 1\quad,\quad\quad\exists A.\,A+R\cong\bbnum 1+R\quad,\\
 & \exists A.\,(R\rightarrow A)\times(A\rightarrow S)\cong R\rightarrow S\quad,\quad\quad\exists A.\,(A\rightarrow R)\times A\times A\cong R\times R\quad.
\end{align*}


\paragraph{Remarks}

\textbf{(1)} The Scala type \lstinline!Any! closely corresponds to
the type $\exists X.\,X$, which is equivalent to \lstinline!Unit!.
The advantage of using \lstinline!Any! instead of \lstinline!Unit!
is that \lstinline!Any! is understood by the Scala compiler as a
supertype of \emph{all} Scala types (while \lstinline!Unit! is not).
Indeed, for any type $T$ there is an injective function $T\rightarrow\exists X.\,X$,
which corresponds to a function of type \lstinline!T => Any! in Scala:
\begin{lstlisting}
def toAny[T](t: T): Any = t
\end{lstlisting}
 This is just an identity function that relabels the types. So, this
function establishes the subtyping relation \lstinline!T <: Any!. 

\textbf{(2)} The type equivalence $\exists X.\,X\cong\bbnum 1$ may
appear counterintuitive. The unit type has only one distinct value;
but there are infinitely many ways of creating a value of type $\exists X.\,X$.
We may take any value $t:T$ of any type $T$ and \textsf{``}pack\textsf{''} that
value into a value of type $\exists X.\,X$ by hiding the type $T$,
similarly to the function \lstinline!toAny!.
\begin{lstlisting}[mathescape=true]
sealed trait ExistsX               // Implements the type $\color{dkgreen}\exists X.\,X$.
final case class ExistsX0[X](x: X)
def hide[T](t: T): ExistsX = ExistsX0[T](t)
val x1: ExistsX = hide(123)
val x2: ExistsX = hide(124)
val x3: ExistsX = hide("abc")
\end{lstlisting}
This code may suggest that we are able to create many different values
of type \lstinline!ExistsX!. How can it be that \lstinline!ExistsX!
is equivalent to a unit type with a single distinct value? The reason
is that no fully parametric functions will be able to detect any difference
between all those values. A fully parametric function may pattern-match
on \lstinline!ExistsX0(x)! but must treat the type of \lstinline!x!
as arbitrary and unknown, with no operations available for computing
anything out of \lstinline!x!. So, there will be no way to determine
the actual type and value of \lstinline!x! and to make any decisions
based on them. A computer\textsf{'}s memory will probably store different bit
patterns when representing \lstinline!hide(123)! and \lstinline!hide(124)!.
But that difference remains unobservable in fully parametric code.
$\square$

We may use Eq.~(\ref{eq:existential-via-universal-Yoneda}) to replace
the existential quantifier by the universal one when proving properties
of existentially quantified types.

\subsubsection{Example \label{subsec:Example-simple-existential-derivation}\ref{subsec:Example-simple-existential-derivation}\index{examples}}

Show that $\exists A.\,F^{A}\rightarrow A\cong\bbnum 1$ for any type
constructor $F$.

\subparagraph{Solution}

Use Eq.~(\ref{eq:existential-via-universal-Yoneda}) and write:
\[
\exists A.\,F^{A}\rightarrow A=\forall B.\,(\forall A.\,(F^{A}\rightarrow A)\rightarrow B)\rightarrow B\quad.
\]
Statement~\ref{subsec:Statement-application-full-relation} with
$P^{A}\triangleq F^{A}\rightarrow A$ and $K\triangleq B$ shows that
$\forall A.\,(F^{A}\rightarrow A)\rightarrow B\cong B$ (the type
constructor $F^{A}\rightarrow A$ is \textsf{``}lifting-to-full\textsf{''} by Statement~\ref{subsec:Statement-undisjunctive-type-constructors-structural}c,
d). So, we get:
\[
\exists A.\,F^{A}\rightarrow A=\forall B.\,B\rightarrow B\cong\bbnum 1\quad.
\]


\subsubsection{Example \label{subsec:Example-simple-existential-derivation-1-1}\ref{subsec:Example-simple-existential-derivation-1-1}}

Let $P$ and $Q$ be any type constructors.

\textbf{(a)} Show that the following equivalence holds: 
\[
\exists A.\,P^{A}+Q^{A}\cong(\exists A.\,P^{A})+(\exists A.\,Q^{A})\quad.
\]

\textbf{(b)} Show that there is \emph{no} analogous equivalence for
the product types:
\[
\exists A.\,P^{A}\times Q^{A}\not\cong(\exists A.\,P^{A})\times(\exists A.\,Q^{A})\quad.
\]


\subparagraph{Solution}

\textbf{(a)} Use Eq.~(\ref{eq:existential-via-universal-Yoneda})
and write:
\begin{align*}
 & \exists A.\,P^{A}+Q^{A}=\forall B.\,(\forall A.\,\gunderline{P^{A}+Q^{A}\rightarrow B})\rightarrow B\\
 & =\forall B.\,(\forall A.\,(P^{A}\rightarrow B)\times(Q^{A}\rightarrow B))\rightarrow B\\
 & =\forall B.\,(\gunderline{\forall A.\,P^{A}\rightarrow B})\times(\gunderline{\forall A.\,Q^{A}\rightarrow B})\rightarrow B\\
{\color{greenunder}\text{use Eq.\,(\ref{eq:existential-via-universal})}:}\quad & =\forall B.\,(\gunderline{(\exists A.\,P^{A})\rightarrow B)\times((\exists A.\,Q^{A})\rightarrow B})\rightarrow B\\
 & =\forall B.\,\big((\exists A.\,P^{A})+(\exists A.\,Q^{A})\,\gunderline{\rightarrow B\big)\rightarrow B}\\
{\color{greenunder}\text{Yoneda identity}:}\quad & =(\exists A.\,P^{A})+(\exists A.\,Q^{A})\quad.
\end{align*}

\textbf{(b)} A counter-example is found via the co-Yoneda identity
itself:
\[
\exists A.\,(A\rightarrow R)\times F^{A}\cong F^{R}\quad.
\]
Splitting the left-hand side into a product of two existential types,
we get:
\[
(\exists A.\,(A\rightarrow R))\times(\exists A.\,F^{A})\cong\bbnum 1\times F^{\bbnum 1}\cong F^{\bbnum 1}\quad.
\]
But the last type is not equivalent to $F^{R}$. $\square$

Finally, we will prove some more technical properties of existential
types.

In the next two statements, we consider the notation $\exists A.\,P^{A}$
as shorthand for the type $\forall B.\,(\forall A.\,P^{A}\rightarrow B)\rightarrow B$
according to Eq.~(\ref{eq:existential-via-universal-Yoneda}). We
work with a fixed type constructor $P$, which is not assumed to be
covariant or contravariant.

\subsubsection{Statement \label{subsec:Statement-identity-law-of-pack}\ref{subsec:Statement-identity-law-of-pack}}

Denote $E\triangleq\exists A.\,P^{A}$. Values of type $E$ are constructed
via the standard function \lstinline!pack! that has the following
type signature:
\begin{align*}
 & \text{pack}:\forall T.\,P^{T}\rightarrow E\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & \text{pack}:\forall T.\,P^{T}\rightarrow\forall B.\,(\forall A.\,P^{A}\rightarrow B)\rightarrow B\quad,\\
 & \text{pack}^{T}(p^{:P^{T}})\triangleq\forall B.\,\big(k^{:\forall A.\,P^{A}\rightarrow B}\big)\rightarrow k^{T}(p)\quad.
\end{align*}
Then the \textbf{identity law} of\index{identity laws!of pack@of \lstinline!pack!}
\lstinline!pack! holds: for any value $e:E$, 
\begin{equation}
e^{E}(\text{pack})=e\quad.\label{eq:identity-law-of-pack}
\end{equation}
It is assumed that parametricity holds, so all values $e^{:E}$ obey
the appropriate naturality law: for all $f^{:B\rightarrow C}$ and
$k^{:\forall A.\,P^{A}\rightarrow B}$,
\begin{equation}
f(e^{B}(k))=e^{C}(k\bef f)\quad.\label{eq:naturality-law-of-e-derivation1}
\end{equation}


\subparagraph{Proof\protect\footnote{The author thanks \index{Dan Doel}Dan Doel for assistance with the
proof of this statement. See the discussion at \texttt{\protect\href{https://cstheory.stackexchange.com/questions/54124}{https://cstheory.stackexchange.com/questions/54124}}}}

Both sides of Eq.~(\ref{eq:identity-law-of-pack}) have type $E$.
Since $E$ is a type of functions with a type parameter, the two sides
can be applied to an arbitrary type $U$ and an arbitrary value $u:\forall A.\,P^{A}\rightarrow U$
to get two values of type $U$:
\begin{align*}
{\color{greenunder}\text{both sides}:}\quad & e^{E}(\text{pack})\overset{?}{=}e\\
{\color{greenunder}\text{can be applied to }U\text{ and }u\text{ and give}:}\quad & \big(e^{E}(\text{pack})\big)^{U}(u)\overset{?}{=}e^{U}(u)\quad.
\end{align*}

So, let us prove that for all types $U$ and all values $u:\forall A.\,P^{A}\rightarrow U$,
\begin{equation}
\big(e^{E}(\text{pack})\big)^{U}(u)\overset{?}{=}e^{U}(u)\quad.\label{eq:identity-law-of-pack-derivation1}
\end{equation}
To prove the last equation, we will rewrite it in the form of the
naturality law~(\ref{eq:naturality-law-of-e-derivation1}) by finding
suitable parameters $B$, $C$, $f$, and $k$. Once we manage to
do that, the proof of Eq.~(\ref{eq:identity-law-of-pack}) will be
completed. 

The left-hand side of Eq.~(\ref{eq:identity-law-of-pack-derivation1})
will match the left-hand side of Eq.~(\ref{eq:naturality-law-of-e-derivation1})
if we assign $B=E$, $k=\text{pack}$, and $f(e)\triangleq e^{U}(u)$.
The type of $f$ must be $B\rightarrow C$; since $f(e)$ has type
$U$, we need to set $C=U$. With these assignments, the right-hand
side of Eq.~(\ref{eq:naturality-law-of-e-derivation1}) becomes:
\[
e^{C}(k\bef f)=e^{U}(\text{pack}\bef f)\quad.
\]
This will be equal to the right-hand side $e^{U}(u)$ of Eq.~(\ref{eq:identity-law-of-pack-derivation1})
if we show that:
\[
\text{pack}\bef f\overset{?}{=}u\quad.
\]
Substitute the definitions of \lstinline!pack! and $f$:
\[
\text{pack}\bef f=\forall T.\,p^{:P^{T}}\rightarrow f\big(\forall B.\,\big(q^{:\forall A.\,P^{A}\rightarrow B}\big)\rightarrow q^{T}(p)\big)\quad.
\]
The function $f$ substitutes $B=U$ and $q=u$ into its function
parameter:
\[
f\big(\forall B.\,\big(q^{:\forall A.\,P^{A}\rightarrow B}\big)\rightarrow q^{T}(p)\big)=\big(\forall B.\,\big(q^{:\forall A.\,P^{A}\rightarrow B}\big)\rightarrow q^{T}(p)\big)^{U}(u)=u^{T}(p)\quad.
\]
So, we find:
\[
\text{pack}\bef f=\forall T.\,p^{:P^{T}}\rightarrow u^{T}(p)=\forall T.\,u^{T}=u\quad.
\]
This completes the proof.

\subsubsection{Statement \label{subsec:Statement-function-extension-rule}\ref{subsec:Statement-function-extension-rule}}

The following type isomorphism holds (assuming parametricity):
\[
\big(\forall B.\,(\forall A.\,P^{A}\rightarrow B)\rightarrow B\big)\rightarrow R\cong\forall C.\,P^{C}\rightarrow R\quad,
\]
where $R$ is a fixed type. If we denote for brevity:
\[
E\triangleq\exists A.\,P^{A}=\forall B.\,(\forall A.\,P^{A}\rightarrow B)\rightarrow B\quad,
\]
then the claimed type isomorphism is written as:
\[
E\rightarrow R\cong\forall C.\,P^{C}\rightarrow R\quad.
\]
In this isomorphism, it is assumed that the type $E$ contains only
functions $e^{:E}$ that obey the naturality law~(\ref{eq:naturality-law-of-e-derivation1}).

\subparagraph{Proof}

The isomorphism is shown by defining two functions (\lstinline!inF!
and \lstinline!outF!):
\begin{align*}
 & \text{inF}:(\forall C.\,P^{C}\rightarrow R)\rightarrow E\rightarrow R\quad,\\
 & \text{inF}\triangleq k^{:\forall C.\,P^{C}\rightarrow R}\rightarrow e^{:E}\rightarrow e^{R}(k)\quad,\\
 & \text{outF}:(E\rightarrow R)\rightarrow\forall C.\,P^{C}\rightarrow R\quad,\\
 & \text{outF}\triangleq r^{:E\rightarrow R}\rightarrow\forall C.\,p^{:P^{C}}\rightarrow r\big(\text{pack}^{C}(p)\big)\quad,
\end{align*}
and by proving that those functions are inverses of each other. (The
function \lstinline!pack! was defined in Statement~\ref{subsec:Statement-identity-law-of-pack}.)

Without the type annotations, the code of \lstinline!inF! and \lstinline!outF!
is:
\[
\text{inF}=k\rightarrow q\rightarrow q(k)\quad,\quad\quad\text{outF}=r\rightarrow p\rightarrow r(k\rightarrow k(p))\quad.
\]
Now it is quick to prove one direction of isomorphism ($\text{inF}\bef\text{outF}\overset{?}{=}\text{id}$):
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & \text{inF}\bef\text{outF}=k\rightarrow\text{outF}\,(q\rightarrow q(k))\\
 & =k\rightarrow p\rightarrow(q\rightarrow q(k))(k\rightarrow k(p))\\
 & =k\rightarrow\gunderline{p\rightarrow k(p)}=k\rightarrow k=\text{id}\quad.
\end{align*}

The other direction ($\text{outF}\bef\text{inF}\overset{?}{=}\text{id}$)
requires more work. Note that the argument of the function $\text{outF}\bef\text{inF}$
has type $E\rightarrow R$, and we need to show that for any function
$r^{:E\rightarrow R}$ the following equation holds: 
\[
\text{inF}\,(\text{outF}\,(r))\overset{?}{=}r\quad,\quad\text{or equivalently}:\quad r\triangleright\text{outF}\triangleright\text{inF}\overset{?}{=}r\quad.
\]
The last equation is between functions of type $E\rightarrow R$;
we may apply both sides to an arbitrary value $e^{:E}$ and require
that the results (of type $R$) should be equal:
\[
\big(r\triangleright\text{outF}\triangleright\text{inF}\big)(e)\overset{?}{=}r(e)\quad.
\]
We begin by subtituting the definitions of \lstinline!inF! and \lstinline!outF!:
\begin{align*}
{\color{greenunder}\text{expect to equal }r(e):}\quad & e\triangleright\big(r\triangleright\text{outF}\triangleright\text{inF}\big)=e\triangleright\big((\forall C.\,p^{:P^{C}}\rightarrow r(\text{pack}^{C}(p)))\triangleright\text{inF}\big)\\
 & =e^{R}\big(\forall C.\,p^{:P^{C}}\rightarrow r(\text{pack}^{C}(p))\big)=e^{R}(\text{pack}\bef r)\quad.
\end{align*}
Since $e$ is unknown and arbitrary, we can make progress in the proof
only if we use the naturality law of $e$ as given by Eq.~(\ref{eq:naturality-law-of-e-derivation1}).
We assign $B=E$, $C=R$, $f=r$, $k=\text{pack}$ in that law and
obtain:
\[
r(e^{E}(\text{pack}))=e^{R}(\text{pack}\bef r)\quad.
\]
By the identity law of pack (Statement~\ref{subsec:Statement-identity-law-of-pack}),
$e^{E}(\text{pack})=e$. So, we conclude the derivation:
\begin{align*}
{\color{greenunder}\text{expect to equal }r(e):}\quad & e\triangleright\big(r\triangleright\text{outF}\triangleright\text{inF}\big)=\gunderline{e^{R}(\text{pack}\bef r)}\\
{\color{greenunder}\text{naturality law of }e:}\quad & =r(\gunderline{e^{E}(\text{pack})})\\
{\color{greenunder}\text{identity law of }\text{pack}:}\quad & =r(e)\quad.
\end{align*}


\subsection{The greatest fixpoints and the Church-co-Yoneda identity\label{subsec:The-greatest-fixpoints-and-Church-co-Yoneda}}

{*}{*}{*} See the Dhall book\textsf{'}s appendix
\[
H^{\text{GFix}(F)}\cong\exists A.\,(A\rightarrow F^{A})\times H^{A}\quad.
\]


\chapter{Solutions of some exercises}

\addsec{Chapter \ref{chap:1-Values,-types,-expressions,}}

\subsubsection*{Exercise \ref{subsec:ch1-aggr-Exercise-1}}

~
\begin{lstlisting}
def at(n: Double, maxN: Int) = (0 to maxN)
  .map { k => 1.0*(1 - k % 2 * 2) / (2 * k + 1) / math.pow(n, 2 * k + 1) }
  .sum
def p(n: Int) = 16 * at(5, n) - 4 * at(239, n)

scala> p(12)
res0: Double = 3.141592653589794
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch1-aggr-Example-6}}

~

\begin{lstlisting}
def euler_series(n: Int): Double = (1 to n).map(k => 1.0 / k / k).sum

scala> euler_series(100000)
res0: Double = 1.6449240668982423

scala> val pi = math.Pi
pi: Double = 3.141592653589793

scala> pi * pi / 6
res1: Double = 1.6449340668482264 
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch1-aggr-Exercise-2}}

~
\begin{lstlisting}
def isPrime(n: Int) = (2 to n - 1).takeWhile(k => k * k <= n).forall(k => n % k != 0)
def ep(n: Int): Double = (2 to n)
  .filter(isPrime)
  .map  { k => 1.0 / (1.0 - 1.0 / k / k / k /k) }
  .product
val pi = 3.1415926535897932

scala> ep(100); pi*pi*pi*pi/90
res0_0: Double = 1.0823231553280295
res0_1: Double = 1.082323233711138 
\end{lstlisting}


\addsec{Chapter \ref{chap:2-Mathematical-induction}}

\subsubsection*{Exercise \ref{tuples-Exercise-10}}

~
\begin{lstlisting}
numsLists.map(_.sortBy(- _).take(3))
\end{lstlisting}


\subsubsection*{Exercise \ref{tuples-Exercise-11}}

~
\begin{lstlisting}
a.flatMap(x => b.map(y => (x, y)))
\end{lstlisting}


\subsubsection*{Exercise \ref{tuples-Exercise-12}}

~
\begin{lstlisting}
def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person, Seq[Amount]] =
  data.flatMap(_.toSeq).groupBy(_._1).map { case (k, v) => (k, v.map(_._2)) }
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-2.2-foldleft-5}}

~
\begin{lstlisting}
def batching[A](xs: Seq[A], size: Int): Seq[Seq[A]] = {  
  type Acc = (Seq[Seq[A]], Seq[A], Int)
  val init: Acc = ((Seq(), Seq(), 0))
  val (result, rem, _) = xs.foldLeft(init){ case ((seq, rem, len), x) =>
    val newLen = len + 1
    if (newLen > size) (seq ++ Seq(rem), Seq(x), 1)
    else (seq, rem ++ Seq(x), newLen)
  }
  result ++ Seq(rem)
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-2.2-foldleft-5-1}}

~
\begin{lstlisting}
def weightBatching[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]] = {  
  type Acc = (Seq[Seq[A]], Seq[A], Double)
  val init: Acc = ((Seq(), Seq(), 0.0))
  val (result, rem, _) = xs.foldLeft(init) { case ((seq, rem, weight), x) =>
    val wx = w(x)
    if (wx > maxW) (seq ++ Seq(rem, Seq(x)), Seq(), 0.0)
    else {
      val newWeight = weight + wx
      if (newWeight > maxW) (seq ++ Seq(rem), Seq(x), wx)
      else (seq, rem ++ Seq(x), newWeight)
    }
  }
  result ++ Seq(rem)
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-2.2-foldleft-6}}

~
\begin{lstlisting}
def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = {  
  val init: Map[K, Seq[A]] = Map()
  xs.foldLeft(init) { (res, x) =>
    val key = by(x)
    val seq = res.getOrElse(key, Seq()) ++ Seq(x)
    res.updated(key, seq)
  }
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-3}}

~
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).toList
def cubeDigits(n: Int): Int = digitsOf(n).map(x => x*x*x).sum
def cubes(n: Int): Stream[Int] = Stream.iterate(n)(cubeDigits)

def stopRepeats[T](str: Stream[T]): Stream[T] = {
  val halfSpeed = str.flatMap(x => Seq(x, x))
  val result = halfSpeed.zip(str).drop(1).takeWhile{ case (h, s) => h != s }.map(_._2)
  if (result.isEmpty) str.take(1) else str
}
def cubesReach1(n: Int): Boolean = stopRepeats(cubes(n)).contains(1)
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-4}}

~
\begin{lstlisting}
def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] =
  a.flatMap(x => b.flatMap(y => c.map(z => Set(x, y, z))))
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-5}}

~
\begin{lstlisting}
def prodSet(sets: Set[Set[Int]]): Set[Set[Int]] =
    sets.foldLeft(Set[Set[Int]](Set())) {
      // Combine each of results so far with each element in current set
      case (accumSet: Set[Set[Int]], currSet: Set[Int]) =>
        for {
          s <- accumSet
          i <- currSet
        } yield s + i
      }
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-4-1}}

~
\begin{lstlisting}
@tailrec def pairs(goal: Int, xs: Array[Int])(
  res: Set[(Int, Int)] = Set(), left: Int = 0, right: Int = xs.length): Set[(Int, Int)] =
    if (left == right) res else {
      val sum = xs(left) + xs(right - 1)
      val (newLeft, newRight, newRes) = if (sum == goal) 
                  (left + 1, right, res + ((xs(left), xs(right - 1)))) 
                else if (sum < goal)
                  (left + 1, right, res)
                else (left, right - 1, res)
      pairs(goal, xs)(newRes, newLeft, newRight)
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-6}}

~
\begin{lstlisting}
def revSentence(sentence: String): String = sentence.split(" ").reverse.mkString(" ")
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2revdigits-Exercise-seq-7}}

~
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).toList
def revDigits(n: Int): Int = digitsOf(n).foldLeft(0){case (acc, d) => acc * 10 + d }
def isPalindrome(n: Int): Boolean = revDigits(n) == n
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-8}}

~
\begin{lstlisting}
def findPalindrome(n: Int): Int = 
  Stream.iterate(n) { x => x + revDigits(x) } .filter(isPalindrome).head
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-9-1}}

~
\begin{lstlisting}
def unfold2[A,B](init: A)(next: A => Option[(A,B)]): Stream[B] = next(init) match {
   case None           => Stream()
   case Some((a, b))   => Stream.cons(b, unfold2(a)(next))
}
\end{lstlisting}


\addsec{Chapter \ref{chap:Disjunctive-types}}

\subsubsection*{Exercise \ref{subsec:Disjunctive-Exercise-non-empty-list-1}}

~
\begin{lstlisting}
def toList[A](nel: NEL[A]): List[A] = nel match {
  case Last(x)         => List(x)
  case More(x, tail)   => x :: toList(tail)
} // Not tail-recursive.
def toList[A](nel: NEL[A]): List[A] = foldLeft(nel)(Nil:List[A]) {
  (prev, x) =>  x :: prev
}.reverse // Tail-recursive, but performs two traversals.
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Disjunctive-Exercise-non-empty-list-2}}

We use the method \lstinline!reverse! implemented in Example~\ref{subsec:Disjunctive-Example-non-empty-list}.
\begin{lstlisting}
def concat[A](xs: NEL[A], ys: NEL[A]): NEL[A] =
  foldLeft(reverse(xs))(ys)((p, x) => More(x, p))
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-disjunctive-EvenList}}

~
\begin{lstlisting}
sealed trait EvenList[A]
final case class Lempty[A]() extends EvenList[A]
final case class Lpair[A](x: A, y: A, tail: EvenList[A]) extends EvenList

def fmap[A, B](f: A => B): EvenList[A] => EvenList[B] = {
  case Lempty()            => Lempty[B]()
  case Lpair(x, y, tail)   => Lpair[B](f(x), f(y), fmap(f)(tail))
}
\end{lstlisting}


\addsec{Chapter \ref{chap:Higher-order-functions}}

\subsubsection*{Exercise \ref{subsec:Exercise-hof-simple-8}}

~
\begin{lstlisting}
@tailrec def convergeN[X](p: X => Boolean)(x:X)(m:Int)(f: X => X): Option[X] =  {
              if (m <= 0) None
              else if (p(x)) Some(x) else converge(p)(f(x))(m - 1)(f)             }
// Defining it as def convergeN[X]: (X => Boolean) => X => Int => (X => X) => Option[X] = ???
// will break tail recursion!
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-hof-simple-7-1}}

~
\begin{lstlisting}
def recover[E, A]: Option[Either[E, A]] => (E => A) => Option[A] = {
  case None             => _ => None
  case Some(Right(a))   => _ => Some(a)
  case Some(Left(e))    => f => Some(f(e))
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-hof-composition-1}}

\textbf{(a)} Choose $f^{:A\rightarrow A}\triangleq(\_\rightarrow z)$
and compute $(f\bef h)(x)=h(z)\overset{!}{=}h(x)$, for any $x$.
So, $h(x)$ equals a fixed value $h(z)$. It follows that $h(x)$
does not depend on $x$, i.e., $h$ is a constant function.

\textbf{(b)} Choose $f^{:A\rightarrow B}\triangleq\_\rightarrow b$
and compute $(f\bef h)(x)=h(b)\overset{!}{=}(g\bef f)(x)=f(g(x))=b$.
It follows that $h(b)=b$ for any $b^{:B}$, so $h$ is an identity
function. Substitute that into the law and get $f=g\bef f$ for any
function $f$. Substitute $f\triangleq\text{id}$ into that and derive
$\text{id}=g\bef\text{id}=g$. So, $g$ is the identity function.

\addsec{Chapter \ref{chap:5-Curry-Howard}}

\subsubsection*{Exercise \ref{subsec:Exercise-type-notation-2}}

The type expression is: $A\times\text{Int}+A\times\text{Char}+A\times\text{Float}$.

\addsec{Chapter \ref{chap:Reasoning-about-code}}

\subsubsection*{Exercise \ref{subsec:Exercise-reasoning-1-4-1}}

It is assumed that $\phi:\forall A.\,F^{A}\rightarrow G^{A}$ satisfies
its naturality law: for any $f^{:A\rightarrow B}$,
\[
f^{\uparrow F}\bef\phi=\phi\bef f^{\uparrow G}\quad.
\]

\textbf{(a)} To verify the naturality law of $\phi^{\uparrow K}$:
for any $f^{:A\rightarrow B}$,
\begin{align*}
 & f^{\uparrow F\uparrow K}\bef\phi^{\uparrow K}\overset{?}{=}\phi^{\uparrow K}\bef f^{\uparrow G\uparrow K}\quad,\\
{\color{greenunder}\text{composition under }^{\uparrow K}:}\quad & (f^{\uparrow F}\bef\phi)^{\uparrow K}\overset{?}{=}(\phi\bef f^{\uparrow G})^{\uparrow K}\quad.
\end{align*}
The last equation holds due to the naturality law of $\phi$.

\textbf{(b)} The naturality law of the pair product ($\phi\boxtimes\psi$)
says that for any $p^{:A\rightarrow B}$,
\[
p^{\uparrow(F\times K)}\bef(\phi\boxtimes\psi)\overset{?}{=}(\phi\boxtimes\psi)\bef p^{\uparrow(G\times L)}\quad.
\]
Begin with the left-hand side of this equation:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{\uparrow(F\times K)}\bef(\phi\boxtimes\psi)\\
{\color{greenunder}\text{definition of }^{\uparrow(F\times K)}:}\quad & =\big(f^{:F^{A}}\times k^{:K^{A}}\rightarrow(f\triangleright p^{\uparrow F})\times(k\triangleright p^{\uparrow K})\big)\bef(\phi\boxtimes\psi)\\
{\color{greenunder}\text{definition of }\phi\boxtimes\psi:}\quad & =f\times k\rightarrow\phi(f\triangleright p^{\uparrow F})\times\psi(k\triangleright p^{\uparrow K})=f\times k\rightarrow(f\triangleright p^{\uparrow F}\bef\phi)\times(k\triangleright p^{\uparrow K}\bef\psi)\quad.
\end{align*}
To rewrite the right-hand side, introduce the function argument into
$\phi\boxtimes\psi$:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & (\phi\boxtimes\psi)\bef p^{\uparrow(G\times L)}=\big(f^{:F^{A}}\times k^{:K^{A}}\rightarrow(f\triangleright\phi)\times(k\triangleright\psi)\big)\bef p^{\uparrow(G\times L)}\\
{\color{greenunder}\text{definition of }^{\uparrow(G\times L)}:}\quad & =f\times k\rightarrow(f\triangleright\gunderline{\phi\triangleright p^{\uparrow G}})\times(k\triangleright\gunderline{\psi\triangleright p^{\uparrow L}})=f\times k\rightarrow(f\triangleright\phi\bef p^{\uparrow G})\times(k\triangleright\psi\bef p^{\uparrow L})\quad.
\end{align*}
The remaining differences between the two sides disappear due to the
naturality laws of $\phi$ and $\psi$:
\[
p^{\uparrow F}\bef\phi=\phi\bef p^{\uparrow G}\quad,\quad\quad p^{\uparrow K}\bef\psi=\psi\bef p^{\uparrow L}\quad.
\]

The naturality law of the pair co-product ($\phi\boxplus\psi$) says
that for any $p^{:A\rightarrow B}$,
\[
p^{\uparrow(F+K)}\bef(\phi\boxplus\psi)\overset{?}{=}(\phi\boxplus\psi)\bef p^{\uparrow(G+L)}\quad.
\]
Begin with the left-hand side of this equation:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{\uparrow(F+K)}\bef(\phi\boxplus\psi)\\
{\color{greenunder}\text{definitions of }^{\uparrow(F+K)}\text{ and of }\phi\boxplus\psi:}\quad & =\,\begin{array}{|c||cc|}
 & F^{B} & K^{B}\\
\hline F^{A} & p^{\uparrow F} & \bbnum 0\\
K^{A} & \bbnum 0 & p^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{B} & \phi & \bbnum 0\\
K^{B} & \bbnum 0 & \psi
\end{array}\\
{\color{greenunder}\text{matrix composition}:}\quad & =\,\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{A} & p^{\uparrow F}\bef\phi & \bbnum 0\\
K^{A} & \bbnum 0 & p^{\uparrow K}\bef\psi
\end{array}\quad.
\end{align*}
The right-hand side is rewritten in a similar way:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & (\phi\boxplus\psi)\bef p^{\uparrow(G+L)}\\
 & =\,\begin{array}{|c||cc|}
 & G^{A} & L^{A}\\
\hline F^{A} & \phi & \bbnum 0\\
K^{A} & \bbnum 0 & \psi
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline G^{A} & p^{\uparrow G} & \bbnum 0\\
L^{A} & \bbnum 0 & p^{\uparrow L}
\end{array}\,=\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{A} & \phi\bef p^{\uparrow G} & \bbnum 0\\
K^{A} & \bbnum 0 & \psi\bef p^{\uparrow L}
\end{array}\quad.
\end{align*}
The remaining differences between the two sides disappear due to the
naturality laws of $\phi$ and $\psi$. 

\addsec{Chapter \ref{chap:Typeclasses-and-functions}}

\subsubsection*{Exercise \ref{subsec:tc-Exercise-3}}

\textbf{(a)}
\begin{lstlisting}
def monoidFunc[A: Monoid, R] = Monoid[R => A](
  { (x, y) => r => x(r) |+| y(r) }, _ => implicitly[Monoid[A]].empty
)
\end{lstlisting}

In the code notation:
\[
f^{:R\rightarrow A}\oplus g^{:R\rightarrow A}\triangleq a\rightarrow f(a)\oplus_{A}g(a)\quad,\quad\quad e\triangleq(\_\rightarrow e_{A})\quad.
\]
Proof of monoid laws:
\begin{align*}
 & a\triangleright\left(\left(f\oplus g\right)\oplus h\right)=\left(a\triangleright(f\oplus g)\right)\oplus_{A}h(a)=f(a)\oplus_{A}g(a)\oplus_{A}h(a)\quad.\\
 & a\triangleright\left(f\oplus\left(g\oplus h\right)\right)=f(a)\oplus_{A}\left(a\triangleright(g\oplus h)\right)=f(a)\oplus_{A}g(a)\oplus_{A}h(a)\quad.\\
 & a\triangleright\left(e\oplus f\right)=e(a)\oplus_{A}f(a)=e_{A}\oplus_{A}f(a)=f(a)=a\triangleright f\quad.\\
 & a\triangleright(f\oplus e)=f(a)\oplus_{A}e(a)=f(a)\oplus_{A}e_{A}=f(a)=a\triangleright f\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:tc-Exercise-9-1} }

\textbf{(a)} A counterexample is the functor $F^{A}\triangleq R\rightarrow A$,
where $R$ is a fixed type.

\textbf{(b)} The function $C^{A}\times C^{B}\rightarrow C^{A+B}$
cannot be implemented for $C^{A}\triangleq\left(A\rightarrow P\right)+\left(A\rightarrow Q\right)$.
This more complicated contrafunctor $C$ is necessary because the
simpler contrafunctor $C^{A}\triangleq A\rightarrow P$ does not provide
a counterexample.

\subsubsection*{Exercise \ref{subsec:tc-Exercise-9-1-1-1}}

Define the method $\text{ex}_{F}$ as:
\[
\text{ex}_{F}\triangleq x^{:F^{A}}\rightarrow x\triangleright(a^{:A}\rightarrow a\times1)^{\uparrow F}\triangleright q^{A,\bbnum 1}\triangleright\pi_{1}\quad\text{ or equivalently: }\quad\text{ex}_{F}\triangleq(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\pi_{1}\quad.
\]
To show that the naturality law ($f^{\uparrow F}\bef\text{ex}_{F}=\text{ex}_{F}\bef f$)
holds, use the identity $(f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f$:
\begin{align*}
 & f^{\uparrow F}\bef\text{ex}_{F}=\gunderline{f^{\uparrow F}\bef(a^{:A}\rightarrow a\times1)^{\uparrow F}}\bef q^{A,\bbnum 1}\bef\pi_{1}=(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef\gunderline{(f\boxtimes\text{id})^{\uparrow F}\bef q^{A,\bbnum 1}}\bef\pi_{1}\\
 & =(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\gunderline{(f\boxtimes\text{id}^{\uparrow F})\bef\pi_{1}}=\gunderline{(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\pi_{1}}\bef f=\text{ex}_{F}\bef f\quad.
\end{align*}

Given a method $\text{ex}_{F}$, define $q$ as:
\[
q^{A,B}\triangleq f^{:F^{A\times B}}\rightarrow(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright\pi_{2}^{\uparrow F})\quad\text{ or equivalently: }\quad q^{A,B}\triangleq\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id})\quad.
\]
Show that the required laws hold for $q$. Identity law: 
\[
f\triangleright q^{\bbnum 1,B}=(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{\bbnum 1})\times(f\triangleright\pi_{2}^{\uparrow F})=1\times(f\triangleright\pi_{2}^{\uparrow F})
\]
because $\text{ex}_{F}^{\bbnum 1}$ produces a value of type $\bbnum 1$,
which can only be $1$.

To prove the naturality law:
\begin{align*}
(f^{:A\rightarrow C}\boxtimes g^{:B\rightarrow D})^{\uparrow F}\bef\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id}) & =\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id})\bef f\boxtimes(g^{\uparrow F})\\
\Delta\bef((f\boxtimes g)^{\uparrow F}\boxtimes(f\boxtimes g)^{\uparrow F})\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id}) & =\Delta\bef(\pi_{1}^{\uparrow F}\bef\text{ex}_{F}\bef f)\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F})\\
\Delta\bef(\pi_{1}^{\uparrow F}\bef\,\gunderline{f^{\uparrow F}\bef\text{ex}_{F}})\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F}) & =\Delta\bef(\pi_{1}^{\uparrow F}\bef\,\gunderline{\text{ex}_{F}\bef f})\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F})
\end{align*}
To prove the associativity law, write the left-hand side as:
\begin{align*}
 & f^{:F^{A\times B\times C}}\triangleright q^{A,B\times C}\bef(\text{id}^{A}\boxtimes q^{B,C})=(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright q^{B,C})\\
 & =(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{B})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright\pi_{2}^{\uparrow F})\\
 & =\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a)\right)\times\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow b)\right)\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\quad.
\end{align*}
The right-hand side is then simplified to the same expression:
\begin{align*}
 & f^{:F^{A\times B\times C}}\triangleright q^{A\times B,C}=(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a\times b))\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\\
 & =\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a)\right)\times\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow b)\right)\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\quad.
\end{align*}


\addsec{Chapter \ref{chap:Filterable-functors}}

\subsubsection*{Exercise \ref{subsec:filt-exercise-derive-liftOpt-equivalence-1}}

Starting from \lstinline!liftOpt!\textsf{'}s law, derive the naturality law:
\[
\text{liftOpt}\left(g\right)\bef\text{liftOpt}\,(f\bef\text{pu}_{\text{Opt}})=\text{liftOpt}(f\bef\text{pu}_{\text{Opt}}\diamond_{_{\text{Opt}}}g)=\text{liftOpt}(f\bef g)\quad.
\]
Now use the naturality-identity law and get $\text{liftOpt}\,(f\bef\text{pu}_{\text{Opt}})=f^{\downarrow C}$.
The result is the naturality law $\text{liftOpt}\left(f\bef g\right)=\text{liftOpt}\left(g\right)\bef f^{\downarrow C}$.

\subsubsection*{Exercise \ref{subsec:Exercise-filterable-laws-4}}

A counterexample is the functor $F^{A}\triangleq\bbnum 1+A\times\left(Z\rightarrow A\right)$.
For this functor, one can implement \lstinline!deflate!\textsf{'}s type signature,
but the code cannot obey the identity law because it must always return
$1+\bbnum 0$.

\addsec{Chapter \ref{chap:Semimonads-and-monads}}

\subsubsection*{Exercise \ref{subsec:Exercise-1-monads-3}}

As a counterexample, choose $S=$ \lstinline!Option! and define $g$
as: 
\begin{lstlisting}
def g: Option[Int] => Option[Int] = { _ => Some(123) }
\end{lstlisting}
\[
g:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}\quad,\quad\quad g\triangleq\_\rightarrow\bbnum 0+123^{:\text{Int}}\quad.
\]
Then apply the functions $g^{\uparrow S}\bef\text{ftn}_{S}$ and $\text{ftn}_{S}\bef g$
to the value \lstinline!x = None! of type \lstinline!Option[Option[Int]]!
(in the code notation, $x\triangleq\bbnum 1+\bbnum 0^{:\bbnum 1+\text{Int}}$):
\begin{lstlisting}
val x: Option[Option[Int]] = None
assert(x.map(g).flatten == None)
assert(g(x.flatten) == Some(123))
\end{lstlisting}
\begin{align*}
 & x\triangleright g^{\uparrow S}\bef\text{ftn}_{S}=(\bbnum 1+\bbnum 0^{:\bbnum 1+\text{Int}})\triangleright\text{ftn}_{S}=\bbnum 1+\bbnum 0^{:\text{Int}}\quad,\\
 & x\triangleright\text{ftn}_{S}\bef g=(\bbnum 1+\bbnum 0^{:\text{Int}})\triangleright g=\bbnum 0+123^{:\text{Int}}\quad.
\end{align*}
We find that $g^{\uparrow S}\bef\text{ftn}_{S}\neq\text{ftn}_{S}\bef g$. 

\subsubsection*{Exercise \ref{subsec:Exercise-1-monads-3-1}}

\index{monads!List monad with empty sub-lists@\texttt{List} monad with empty sub-lists}The
given non-standard implementation of \lstinline!flatten! will return
the same results as the standard \lstinline!flatten! method of the
\lstinline!List! type constructor, except if one of the nested sub-lists
is empty. In that case, the \lstinline!flatten! function returns
an empty list (unlike \lstinline!List!\textsf{'}s standard \lstinline!flatten!
method). The \lstinline!pure! method remains unchanged. The code
is:
\begin{lstlisting}[mathescape=true]
def pure[A](x: A): List[A] = List(x) // $\color{dkgreen}\textrm{pu}_L$
def flatten[A](p: List[List[A]]): List[A] = if (p.exists(_.isEmpty)) Nil else p.flatten  // $\color{dkgreen}\textrm{ftn}_L$
\end{lstlisting}

To verify the monad laws, we use the known fact that the standard
\lstinline!List! monad obeys the laws. So, we only need to check
the laws in the cases when the new \lstinline!flatten! function is
applied to a value of type \lstinline!List[List[A]]! having an empty
nested sub-list. That case cannot arise in the identity laws since
neither $\text{pu}_{L}(x^{:A})$ nor $\text{pu}_{L}^{\uparrow L}(x^{:\text{List}^{A}})$
ever returns a value with a nested empty sub-list:
\begin{lstlisting}
pure(List(a, b, c)) == List(List(a, b, c))
List(a, b, c).map(pure) == List(List(a), List(b), List(c))
\end{lstlisting}
Applying \lstinline!flatten! to these values gives the initial list
\lstinline!List(a, b, c)!. So, both identity laws hold.

It remains to check the associativity law, which is an equality between
functions $\text{ftn}_{L}\bef\text{ftn}_{L}$ and $\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}$
of type \lstinline!List[List[List[A]]] => List[A]!. A value $p$
of type \lstinline!List[List[List[A]]]! could contain a nested empty
list at the first and/or the second nesting depth, for instance:
\begin{lstlisting}
val p1: List[List[List[Int]]] = List(List[List[Int]](), List(List(123), List(456)))
val p2: List[List[List[Int]]] = List(List(List[Int](), List(123)), List(List(456)))
\end{lstlisting}
Whenever $p$ contains an empty sub-list at the first nesting depth,
we will have $p\triangleright\text{ftn}_{L}=\text{Nil}$ because $\text{ftn}_{L}$
explicitly checks for the existence of an empty sub-list. So, $p\triangleright\text{ftn}_{L}\bef\text{ftn}_{L}=\text{Nil}$.
On the other hand, $p\triangleright\text{ftn}_{L}^{\uparrow L}$ will
be again a list containing an empty sub-list, for example:
\begin{lstlisting}
scala> p1.map(flatten)
res0: List[List[Int]] = List(List(), List(123, 456))
\end{lstlisting}
We will then have $p\triangleright\text{ftn}_{L}^{\uparrow L}\triangleright\text{ftn}_{L}=\text{Nil}$,
and the law holds. If $p$ contains an empty sub-list at the \emph{second}
nesting depth, $p\triangleright\text{ftn}_{L}$ will contain an empty
sub-list at the first nesting depth, for example:
\begin{lstlisting}
scala> flatten(p2)
res1: List[List[Int]] = List(List(), List(123), List(456)) 
\end{lstlisting}
So $p\triangleright\text{ftn}_{L}\bef\text{ftn}_{L}=\text{Nil}$.
On the other hand, $p\triangleright\text{ftn}_{L}^{\uparrow L}$ will
also be a list with an empty sub-list at the first nesting depth,
for example:
\begin{lstlisting}
scala> p2.map(flatten)
res2: List[List[Int]] = List(List(), List(456))
\end{lstlisting}
Applying $\text{ftn}_{L}$ to the last result, we will get an empty
list. Thus, $p\triangleright\text{ftn}_{L}\triangleright\text{ftn}_{L}=\text{Nil}$,
and the law again holds. So, we have shown that the associativity
law holds for the non-standard \lstinline!List! monad.

\subsubsection*{Exercise \ref{subsec:Exercise-flatten-concat-distributive-law}}

The values $p$ and $q$ must have type $\text{List}^{\text{List}^{A}}$.
There are two possibilities: $p$ is an empty list ($p=1+\bbnum 0$),
and $p=\bbnum 0+h\times t$. If $p$ is empty, so is $p\triangleright\text{ftn}$
and the law holds. In the other case, we have (due to the code of
$\pplus$) that:
\[
\left(\bbnum 0+h\times t\right)\pplus q=\bbnum 0+h\times\left(t\pplus q\right)\quad,
\]
and so:
\begin{align*}
 & \left(p\pplus q\right)\triangleright\text{ftn}=\left(\bbnum 0+h\times\left(t\pplus q\right)\right)\triangleright\text{ftn}=h\pplus\gunderline{\left(t\pplus q\right)\triangleright\overline{\text{ftn}}}\\
{\color{greenunder}\text{inductive assumption}:}\quad & =\gunderline{h\pplus(t\triangleright\overline{\text{ftn}})}\pplus(q\triangleright\overline{\text{ftn}})\\
{\color{greenunder}\text{code of }\text{ftn}:}\quad & =\left(\bbnum 0+h\times t\right)\triangleright\overline{\text{ftn}}\pplus(q\triangleright\overline{\text{ftn}})=\left(p\triangleright\text{ftn}\right)\pplus\left(q\triangleright\text{ftn}\right)\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-monad-of-monoid-is-monoid}}

Define the empty element ($e_{M}$) of the monoid $M^{W}$ as:
\[
e_{M}\triangleq\text{pu}_{M}(e_{W})\quad.
\]
The binary operation $\oplus_{M}$ of the monoid $M^{W}$ may be implemented
through $\oplus_{W}$ as:
\[
p\oplus_{M}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow q\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\quad.
\]
To check the left identity law of $M^{W}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }p:}\quad & e_{M}\oplus_{M}p=e_{W}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}\big(u^{:W}\rightarrow p\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\\
 & =e_{W}\triangleright\big(u^{:W}\rightarrow p\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)=p\triangleright(v\rightarrow\gunderline{e_{W}\oplus_{W}v})^{\uparrow M}\\
{\color{greenunder}\text{left identity law of }W:}\quad & =p\triangleright(v\rightarrow v)^{\uparrow M}=p\triangleright\text{id}^{\uparrow M}=p\quad.
\end{align*}
To check the right identity law of $M^{W}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }p:}\quad & p\oplus_{M}e_{M}=p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow e_{W}\triangleright\gunderline{\text{pu}_{M}\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}}\big)\\
{\color{greenunder}\text{naturality of }\text{pu}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow\gunderline{e_{W}\triangleright(v^{:W}}\rightarrow u\oplus_{W}v)\triangleright\text{pu}_{M}\big)\\
{\color{greenunder}\text{apply function}:}\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow(\gunderline{u\oplus_{W}e_{W}})\triangleright\text{pu}_{M}\big)\\
{\color{greenunder}\text{right identity law of }W:}\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow u\triangleright\text{pu}_{M}\big)=p\triangleright\text{id}=p\quad.
\end{align*}
To check the associativity law of $M^{W}$, we use the associativity
law of $\text{flm}_{M}$:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (p\oplus_{M}q)\oplus_{M}r\\
 & =p\triangleright\gunderline{\text{flm}_{M}}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\,\gunderline{\triangleright\text{flm}_{M}}\big(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M}\big)\\
{\color{greenunder}\text{associativity of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(\gunderline (u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v)^{\uparrow M}\gunderline{)\bef}\,\text{flm}_{M}(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M})\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v\gunderline{)^{\uparrow M}\triangleright\text{flm}_{M}}(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M})\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow\gunderline{u\oplus_{W}v})\,\gunderline{\bef(t}\rightarrow r\triangleright(w\rightarrow\gunderline t\oplus_{W}w)^{\uparrow M}))\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow(u\oplus_{W}v)\oplus_{W}w)^{\uparrow M})\big)\quad.
\end{align*}
Now write the right-hand side of the law:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & p\oplus_{M}(q\oplus_{M}r)=p\triangleright\text{flm}_{M}\big(u\rightarrow(q\oplus r)\triangleright(t\rightarrow u\oplus_{W}t)^{\uparrow M}\big)\\
{\color{greenunder}\text{substitute }q\oplus r:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow v\oplus_{W}w)^{\uparrow M})\,\gunderline{\triangleright\,(}t\rightarrow u\oplus_{W}t\gunderline{)^{\uparrow M}}\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow u\oplus_{W}w\gunderline{)^{\uparrow M}\bef}\,(t\rightarrow u\oplus_{W}t\gunderline{)^{\uparrow M}})\big)\\
{\color{greenunder}\text{composition under }^{\uparrow M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow u\oplus_{W}(v\oplus_{W}w))^{\uparrow M})\big)\quad.
\end{align*}
 The difference between the two sides now vanishes due to the assumed
associativity law of $W$:
\[
(u\oplus_{W}v)\oplus_{W}w\overset{!}{=}u\oplus_{W}(v\oplus_{W}w)\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-1-monads-9-1}}

\textbf{(b)} The code is converted into monad methods like this:
\begin{align*}
 & r_{1}=p\triangleright\text{flm}_{M}(x\rightarrow q\triangleright(y\rightarrow f(x,y))^{\uparrow M})\quad,\\
 & r_{2}=q\triangleright\text{flm}_{M}(y\rightarrow p\triangleright(x\rightarrow f(x,y))^{\uparrow M})\quad.
\end{align*}
For a commutative monad $M$, we have $r_{1}=r_{2}$. The monoid operation
$\oplus_{M}$ is defined by:
\[
p^{:M^{\bbnum 1}}\oplus_{M}q^{:M^{\bbnum 1}}\triangleq p\triangleright\text{flm}_{M}(1\rightarrow q)\quad.
\]
Commutativity of $\oplus_{M}$ means that:
\[
p\triangleright\text{flm}_{M}(1\rightarrow q)=p\oplus_{M}q\overset{?}{=}q\oplus_{M}p=q\triangleright\text{flm}_{M}(1\rightarrow p)\quad.
\]
Use $f(x,y)\triangleq1$ in the definitions of $r_{1}$ and $r_{2}$;
then the above equation is equivalent to $r_{1}=r_{2}$.

\subsubsection*{Exercise \ref{subsec:Exercise-1-monads-12}}

The second definition, $\text{pu}_{L}\triangleq a\rightarrow\bbnum 0+\text{pu}_{F}(a)$,
fails the right identity law:
\begin{align*}
 & \text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\,\begin{array}{|c||ccc|}
 & A & F^{A} & F^{L^{A}}\\
\hline A & \bbnum 0 & \text{pu}_{F} & \bbnum 0\\
F^{A} & \bbnum 0 & \bbnum 0 & \text{pu}_{L}^{\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & F^{A}\\
\hline A & \text{id} & \bbnum 0\\
F^{A} & \bbnum 0 & \text{id}\\
F^{L^{A}} & \bbnum 0 & \gamma^{\uparrow F}\bef\text{ftn}_{F}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & F^{A}\\
\hline A & \bbnum 0 & \text{pu}_{F}\\
F^{A} & \bbnum 0 & ...
\end{array}\,\neq\text{id}\quad.
\end{align*}
This matrix cannot be equal to the identity function because it has
a missing diagonal element.

\subsubsection*{Exercise \ref{subsec:Exercise-monad-composition-mm}}

If $M$ is a semimonad, we have the Kleisli composition $\diamond_{_{M}}$
that satisfies the associativity law. Define $\diamond_{_{L}}$ by:
\[
f^{:A\rightarrow M^{M^{B}}}\diamond_{_{L}}g^{:B\rightarrow M^{M^{C}}}\triangleq f\bef\text{ftn}_{M}\diamond_{_{M}}g\quad.
\]
Here, the expression of the form $f\bef h\diamond_{_{M}}g$ does not
need parentheses (see Statement~\ref{subsec:Statement-equivalence-kleisli-composition-and-flatMap}).

It is inconvenient to mix the Kleisli composition and the \lstinline!flatten!
method, so we express \lstinline!flatten! as:
\[
\text{ftn}_{M}^{:M^{M^{A}}\rightarrow M^{A}}=\text{flm}_{M}(\text{id}^{:M^{A}\rightarrow M^{A}})=\text{id}^{:M^{M^{A}}\rightarrow M^{M^{A}}}\diamond_{_{M}}\text{id}^{:M^{A}\rightarrow M^{A}}\quad.
\]
For brevity, we will omit type annotations from now on. So, we can
express the Kleisli composition $\diamond_{_{L}}$ through $\diamond_{_{M}}$
by:
\[
f\diamond_{_{L}}g\triangleq f\bef\gunderline{\left(\text{id}\diamond_{_{M}}\text{id}\right)\diamond_{_{M}}g}=f\bef\left(\text{id}\diamond_{_{M}}\left(\text{id}\diamond_{_{M}}g\right)\right)=\left(f\bef\text{id}\right)\diamond_{_{M}}\left(\text{id}\diamond_{_{M}}g\right)=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\quad.
\]

Associativity of $\diamond_{_{L}}$ then follows from associativity
of $\diamond_{_{M}}$ as:
\begin{align*}
\left(f\diamond_{_{L}}g\right)\diamond_{_{L}}h & =\left(f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\right)\diamond_{_{M}}\text{id}\diamond_{_{M}}h=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\quad,\\
f\diamond_{_{L}}\left(g\diamond_{_{L}}h\right) & =f\diamond_{_{M}}\text{id}\diamond_{_{M}}\left(g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\right)=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\quad.
\end{align*}

This definition of $\diamond_{_{L}}$ corresponds to a definition
of $\text{ftn}_{L}$ that flattens the \emph{first} three layers of
$M$ in $M\circ M\circ M\circ M$:
\[
\text{ftn}_{L}\triangleq\text{ftn}_{M}\bef\text{ftn}_{M}\quad.
\]

An alternative definition will flatten the \emph{last} three layers:
\[
\text{ftn}_{L}\triangleq(\text{ftn}_{M}\bef\text{ftn}_{M})^{\uparrow M}\quad.
\]
Both definitions satisfy the associativity law and so define a semimonad
$L$,
\[
\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\text{ftn}_{L}\bef\text{ftn}_{L}\quad.
\]
Let us verify that directly. For the first definition:
\begin{align*}
 & \gunderline{(\text{ftn}_{M}\bef\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\big(\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{associativity of }M:}\quad & =\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}^{\uparrow M\uparrow M}}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}=\gunderline{\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\bef\gunderline{\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{associativity of }M:}\quad & =\text{ftn}_{M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\quad.
\end{align*}
For the second definition, we just apply $^{\uparrow M}$ to the preceding
derivation.

A definition of \lstinline!flatten! that flattens separately the
first two and the last two layers of $M$ ($\text{ftn}_{L}\triangleq\text{ftn}_{M}\bef\text{ftn}_{M}^{\uparrow M}$)
will fail the associativity law when $M$ is chosen in a suitable
way.

If $M$ is a full monad, we have $\text{pu}_{M}$ that satisfies the
identity laws. Define $\text{pu}_{L}$ by:
\[
\text{pu}_{L}\triangleq\text{pu}_{M}\bef\text{pu}_{M}\quad.
\]
There is no other way of defining $\text{pu}_{L}$ since we cannot
obtain a value of type $M^{A}$ other than via $\text{pu}_{M}$.

With any of the two possible definitions of $\text{ftn}_{L}$, at
least one of the identity laws for $\diamond_{_{L}}$ fails.

For the definition of $\text{ftn}_{L}$ that flattens the first three
layers, the right identity law will fail:
\[
\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\gunderline{(\text{pu}_{M}\bef\text{pu}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{pu}_{M}^{\uparrow M}\bef\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}=\text{ftn}_{M}\bef\text{pu}_{M}^{\uparrow M}\quad.
\]
In general, this function is not equal to an identity function, because
\lstinline!flatten! merges the two monadic layers of $M$ and in
that way loses information about a value of type $M^{M^{A}}$.

For the definition of $\text{ftn}_{L}$ that flattens the last three
layers, the left identity law will fail:
\[
\text{pu}_{L}\bef\text{ftn}_{L}=\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef(\text{ftn}_{M}}\bef\text{ftn}_{M})^{\uparrow M}=\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\bef\text{pu}_{M}\bef\text{ftn}_{M}^{\uparrow M}=\text{pu}_{M}\bef\text{ftn}_{M}^{\uparrow M}=\text{ftn}_{M}\bef\text{pu}_{M}\quad.
\]
In general, this function is not equal to an identity function.

\addsec{Chapter \ref{chap:8-Applicative-functors,-contrafunctors}}

\subsubsection*{Exercise \ref{subsec:Exercise-simplify-law-omit-lifted-function}}

We may choose $f=\text{id}$ and derive $u=v$ from the given law.
Conversely, if $u=v$ then $u\bef f^{\uparrow F}=v\bef f^{\uparrow F}$
for any function $f$.

\subsubsection*{Exercise \ref{subsec:Exercise-applicative-II-4-1}}

To verify the law, write:
\begin{align*}
 & \text{ap}\,(r)(\text{pu}_{L}(a))=\text{zip}\big(r\times\text{pu}_{L}(a)\big)\triangleright\text{eval}^{\uparrow L}\\
{\color{greenunder}\text{right identity law of }\text{zip}:}\quad & =r\triangleright\left(f\rightarrow f\times a\right)^{\uparrow L}\bef\text{eval}^{\uparrow L}\\
{\color{greenunder}\text{composition under }^{\uparrow L}:}\quad & =r\triangleright(f\rightarrow f(a))\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-function-type-construction-not-applicative}}

\textbf{(a)} We cannot implement \lstinline!zip! as a fully parametric
function having this type:
\[
\text{zip}_{F}(p^{:(A\rightarrow P)\rightarrow Q}\times q^{:(B\rightarrow P)\rightarrow Q})\triangleq h^{:A\times B\rightarrow P}\rightarrow\text{???}^{:Q}\quad.
\]
\begin{lstlisting}
import io.chymyst.ch._
type S[A] = (A => P) => Q

scala> def zip[A, B](p: S[A], q: S[B]): S[(A, B)] = implement
type ((A => P) => Q) => ((B => P) => Q) => (Tuple2[A,B] => P) => Q cannot be implemented
\end{lstlisting}

The reason it cannot be implemented is that the only way of getting
a value of type $Q$ is to call the given functions $p$ or $q$.
But we cannot call $p$ or $q$ since we cannot supply their arguments:
we have a function of type $A\times B\rightarrow P$, and we cannot
produce a function of type $A\rightarrow P$ or $B\rightarrow P$
out of it.

The only solution is for \lstinline!zip! to ignore its arguments
and always return the empty value $e_{Q}$. However, that implementation
loses information and would fail the identity laws.

\textbf{(b)} We \emph{can} implement the type signature of \lstinline!zip!,
but only in a trivial way:
\[
\text{zip}_{F}(p^{:(A\rightarrow P)\rightarrow\bbnum 1+A}\times q^{:(B\rightarrow P)\rightarrow\bbnum 1+B})\triangleq h^{:A\times B\rightarrow P}\rightarrow\text{???}^{:\bbnum 1+A\times B}\quad.
\]
The functions $p$ and $q$ cannot be called since we cannot supply
their arguments, just as in part \textbf{(a)}. The only solution is
that \lstinline!zip! should ignore its arguments and always return
$1+\bbnum 0^{:A\times B}$. However, that implementation loses information
and would fail the identity laws.

\subsubsection*{Exercise \ref{subsec:Exercise-additional-law-of-ap}}

We define $\text{ex}_{F}(h\times g)\triangleq\text{ex}_{H}(h)$ and
obtain:
\begin{align*}
 & \text{ex}_{F}(\text{zip}_{F}(h_{1}\times g_{1}\times h_{2}\times g_{2}))=\text{ex}_{F}(\text{zip}_{H}(h_{1}\times h_{2})\times\text{zip}_{G}(g_{1}\times g_{2}))\\
 & \quad=\text{ex}_{H}(\text{zip}_{H}(h_{1}\times h_{2}))\quad,\\
 & \text{ex}_{F}(h_{1}\times g_{1})\times\text{ex}_{F}(h_{2}\times g_{2})=\text{ex}_{H}(h_{1})\times\text{ex}_{H}(h_{2})\quad.
\end{align*}
The two sides are now equal due to the compatibility law of $\text{zip}_{H}$
and $\text{ex}_{H}$.

\subsubsection*{Exercise \ref{subsec:Exercise-applicative-II-4-1-1}}

\textbf{(a)} The proof is similar to that of Statement~\ref{subsec:Statement-co-product-with-co-pointed-applicative}
except we are using an arbitrary applicative morphism $c$ instead
of the function $\text{ex}_{H}\bef\text{pu}_{F}$ (which is also an
applicative morphism).

As $F^{A}=G^{A}+H^{A}$, values of type $F^{A}$ are either of the
form $g^{:G^{A}}+\bbnum 0$ or of the form $\bbnum 0+h^{:H}$. We
will verify the laws by subsituting one of these two possibilities
as needed.

The lifting to the functor $F$ is given by $f^{\uparrow F}=f^{\uparrow G}\boxplus f^{\uparrow H}$.

Given an applicative morphism $c^{A}:G^{A}\rightarrow H^{A}$ as well
as the applicative methods for $G$ and $H$, we define the methods
$\text{zip}_{F}$ and $\text{wu}_{F}$ by:
\begin{align*}
 & \text{zip}_{F}:(G^{A}+H^{A})\times(G^{B}+H^{B})\rightarrow G^{A\times B}+H^{A\times B}\quad,\\
 & \text{zip}_{F}\triangleq\,\begin{array}{|c||cc|}
 & G^{A\times B} & H^{A\times B}\\
\hline G^{A}\times G^{B} & \text{zip}_{G} & \bbnum 0\\
G^{A}\times H^{B} & \bbnum 0 & g_{1}\times h_{2}\rightarrow\text{zip}_{H}(c^{A}(g_{1})\times h_{2})\\
H^{A}\times G^{B} & \bbnum 0 & h_{1}\times g_{2}\rightarrow\text{zip}_{H}(h_{1}\times c^{B}(g_{2}))\\
H^{A}\times H^{B} & \bbnum 0 & \text{zip}_{H}
\end{array}\,=\,\begin{array}{|c||cc|}
 & G^{A\times B} & H^{A\times B}\\
\hline G^{A}\times G^{B} & \text{zip}_{G} & \bbnum 0\\
G^{A}\times H^{B} & \bbnum 0 & (c^{A}\boxtimes\text{id})\bef\text{zip}_{H}\\
H^{A}\times G^{B} & \bbnum 0 & (\text{id}\boxtimes c^{B})\bef\text{zip}_{H}\\
H^{A}\times H^{B} & \bbnum 0 & \text{zip}_{H}
\end{array}\quad,\\
 & \text{wu}_{F}:G^{\bbnum 1}+H^{\bbnum 1}\quad,\quad\quad\text{wu}_{F}\triangleq\text{wu}_{G}+\bbnum 0^{:H^{\bbnum 1}}\quad.
\end{align*}

We begin by verifying the left identity law. For values of the form
$g^{:G^{A}}+\bbnum 0$:
\begin{align*}
 & \text{zip}_{F}(\text{wu}_{F}\times(g^{:G^{A}}+\bbnum 0))=\text{zip}_{F}((\text{wu}_{G}+\bbnum 0)\times(g^{:G^{A}}+\bbnum 0))=\text{zip}_{G}(\text{wu}_{G}\times g)+\bbnum 0\quad,\\
 & (g^{:G^{A}}+\bbnum 0)\triangleright(b\rightarrow1\times b)^{\uparrow F}=g\triangleright(b\rightarrow1\times b)^{\uparrow G}+\bbnum 0\quad.
\end{align*}
The two sides are now equal due to the left identity law of $G$.

To verify the left identity law with values of the form $\bbnum 0+h^{:H}$,
we use the applicative morphism\textsf{'}s identity law:
\[
c^{\bbnum 1}(\text{wu}_{G})=\text{wu}_{H}\quad.
\]
Then we write:
\begin{align*}
 & \text{zip}_{F}(\text{wu}_{F}\times(\bbnum 0+h^{:H}))=\bbnum 0+\text{zip}_{H}(\gunderline{c^{\bbnum 1}(\text{wu}_{G})}\times h)\\
{\color{greenunder}\text{applicative morphism law}:}\quad & \quad=\bbnum 0+\text{zip}_{H}(\text{wu}_{H}\times h)\quad,\\
 & (\bbnum 0+h^{:H})\triangleright(b\rightarrow1\times b)^{\uparrow F}=\bbnum 0+h\triangleright(b\rightarrow1\times b)^{\uparrow H}\quad.
\end{align*}
The two sides are now equal due to the left identity law of $H$.

The right identity law is verified similarly.

To verify the associativity law:
\[
\text{zip}_{F}(r^{:F^{A}}\times\text{zip}_{F}(s^{:F^{B}}\times t^{:F^{C}}))\triangleright(a\times(b\times c)\rightarrow(a\times b)\times c)^{\uparrow F}\overset{?}{=}\text{zip}_{F}(\text{zip}_{F}(r\times s)\times t)\quad,
\]
we need to consider 8 possible cases where $r$, $s$, and $t$ are
either in the first part or in the second part of the disjunctive
types $G^{...}+H^{...}$. We will write out the proof for three of
those  cases; other cases are proved similarly. Note that $\text{zip}_{F}(r\times s)$
produces a result of type $G^{A\times B}+\bbnum 0$ only when both
$r^{:F^{A}}$ and $s^{:F^{B}}$ have types $G^{...}+\bbnum 0$; otherwise
the result has type $\bbnum 0+H^{A\times B}$.

Case 1: $r=g_{1}+\bbnum 0$, $s=g_{2}+\bbnum 0$, $t=g_{3}+\bbnum 0$.
We have:
\begin{align*}
 & \text{zip}_{F}(r\times\text{zip}_{F}(s\times t))=\text{zip}_{G}(g_{1}\times\text{zip}_{G}(g_{2}\times g_{3}))+\bbnum 0\quad,\\
 & \text{zip}_{F}(\text{zip}_{F}(r\times s)\times t)=\text{zip}_{G}(\text{zip}_{G}(g_{1}\times g_{2})\times g_{3})+\bbnum 0\quad.
\end{align*}
The two expressions are equal because $\text{zip}_{G}$ already obeys
that law.

Case 2: $r=\bbnum 0+h_{1}$, $s=g_{2}+\bbnum 0$, $t=g_{3}+\bbnum 0$.
For this case, we need to use the applicative morphism\textsf{'}s composition
law:
\[
\text{for any }p^{:G^{A}},q^{:G^{B}}:\quad c^{A\times B}(\text{zip}_{G}(p\times q))=\text{zip}_{H}(c^{A}(p)\times c^{B}(q))\quad.
\]
 We write:
\begin{align*}
 & \text{zip}_{F}(r\times\text{zip}_{F}(s\times t))=\text{zip}_{F}((\bbnum 0+h_{1})\times(\text{zip}_{G}(g_{2}\times g_{3})+\bbnum 0))\\
 & \quad=\bbnum 0+\text{zip}_{H}(h_{1}\times\gunderline{c(\text{zip}_{G}(g_{2}\times g_{3})})\\
{\color{greenunder}\text{applicative morphism law}:}\quad & \quad=\bbnum 0+\text{zip}_{H}(h_{1}\times\text{zip}_{H}(c(g_{2})\times c(g_{3})))\quad,\\
 & \text{zip}_{F}(\text{zip}_{F}(r\times s)\times t)=\bbnum 0+\text{zip}_{H}(\text{zip}_{H}(h_{1}\times c(g_{2}))\times c(g_{3}))\quad.
\end{align*}
The two expressions are equal because $\text{zip}_{H}$ already obeys
that law.

Case 3: $r=\bbnum 0+h_{1}$, $s=\bbnum 0+h_{2}$, $t=g_{3}+\bbnum 0$.
We have:
\begin{align*}
 & \text{zip}_{F}(r\times\text{zip}_{F}(s\times t))=\text{zip}_{F}((\bbnum 0+h_{1})\times(\bbnum 0+\text{zip}_{H}(h_{2}\times c(g_{3}))))\\
 & \quad=\bbnum 0+\text{zip}_{H}(h_{1}\times\text{zip}_{H}(h_{2}\times c(g_{3})))\quad,\\
 & \text{zip}_{F}(\text{zip}_{F}(r\times s)\times t)=\bbnum 0+\text{zip}_{H}(\text{zip}_{H}(h_{1}\times h_{2})\times c(g_{3}))\quad.
\end{align*}

The two expressions are equal because $\text{zip}_{H}$ already obeys
that law.

The proofs for the remaining cases are similar; sometimes the applicative
morphism\textsf{'}s composition law will be used and sometimes it will not
be needed.

To verify the commutativity law when $G$ and $H$ are commutative:
\begin{equation}
\text{swap}\bef\text{zip}_{F}\overset{?}{=}\text{zip}_{F}\bef\text{swap}^{\uparrow F}\quad.\label{eq:commutativity-applicative-law-for-F-derivation1}
\end{equation}
Use the definition of $\text{zip}_{F}$ and compare the code at both
sides of the law:
\begin{align*}
 & \text{swap}\bef\text{zip}_{F}=\,\begin{array}{|c||cc|}
 & G^{B\times A} & H^{B\times A}\\
\hline G^{A}\times G^{B} & \text{swap}\bef\text{zip}_{G} & \bbnum 0\\
G^{A}\times H^{B} & \bbnum 0 & \text{swap}\bef(\text{id}\boxtimes c^{A})\bef\text{zip}_{H}\\
H^{A}\times G^{B} & \bbnum 0 & \text{swap}\bef(c^{B}\boxtimes\text{id})\bef\text{zip}_{H}\\
H^{A}\times H^{B} & \bbnum 0 & \text{swap}\bef\text{zip}_{H}
\end{array}\quad,\\
 & \text{zip}_{F}\bef\text{swap}^{\uparrow F}\\
 & =\,\begin{array}{|c||cc|}
 & G^{B\times A} & H^{B\times A}\\
\hline G^{A}\times G^{B} & \text{zip}_{G}\bef\text{swap}^{\uparrow G} & \bbnum 0\\
G^{A}\times H^{B} & \bbnum 0 & (c^{A}\boxtimes\text{id})\bef\text{zip}_{H}\bef\text{swap}^{\uparrow H}\\
H^{A}\times G^{B} & \bbnum 0 & (\text{id}\boxtimes c^{B})\bef\text{zip}_{H}\bef\text{swap}^{\uparrow H}\\
H^{A}\times H^{B} & \bbnum 0 & \text{zip}_{H}\bef\text{swap}^{\uparrow H}
\end{array}\quad.
\end{align*}
We use the commutativity laws for $G$ and $H$:
\[
\text{swap}\bef\text{zip}_{G}=\text{zip}_{G}\bef\text{swap}^{\uparrow G}\quad,\quad\quad\text{swap}\bef\text{zip}_{H}=\text{zip}_{H}\bef\text{swap}^{\uparrow H}\quad,
\]
and the general property of the pair product:
\[
\text{swap}\bef(f\boxtimes g)=(g\boxtimes f)\bef\text{swap}\quad,
\]
to find that the matrix elements in the two sides of the law are equal:
\begin{align*}
 & \gunderline{\text{swap}\bef(\text{id}\boxtimes c^{A})}\bef\text{zip}_{H}=(c^{A}\boxtimes\text{id})\bef\text{swap}\bef\text{zip}_{H}\quad,\\
 & (c^{A}\boxtimes\text{id})\bef\gunderline{\text{zip}_{H}\bef\text{swap}^{\uparrow H}}=(c^{A}\boxtimes\text{id})\bef\text{swap}\bef\text{zip}_{H}\quad,\\
 & \text{swap}\bef(c^{B}\boxtimes\text{id})\bef\text{zip}_{H}=(\text{id}\boxtimes c^{B})\bef\text{swap}\bef\text{zip}_{H}\quad,\\
 & (\text{id}\boxtimes c^{B})\bef\gunderline{\text{zip}_{H}\bef\text{swap}^{\uparrow H}}=(\text{id}\boxtimes c^{B})\bef\text{swap}\bef\text{zip}_{H}\quad.
\end{align*}
This shows that Eq.~(\ref{eq:commutativity-applicative-law-for-F-derivation1})
holds.

\textbf{(b)} To use part \textbf{(a)}, we rewrite $F^{A}=(P\rightarrow A)+(Q\rightarrow A)$
as $G^{A}+H^{A}$, note that $G$ and $H$ are commutative applicative
functors, and look for an applicative morphism $H^{A}\rightarrow G^{A}$.
Example~\ref{subsec:Example-applicative-morphism-1} showed that
a function of type $P\rightarrow Q$ gives an applicative morphism
$c^{A}:(Q\rightarrow A)\rightarrow(P\rightarrow A)$. It follows that
$F$ is a commutative applicative functor via the construction shown
in part \textbf{(a)}.

\subsubsection*{Exercise \ref{subsec:Exercise-profunctor-example}}

The first and the third occurrences of $A$ in $Q^{A}$ are contravariant
while the others are covariant. So, we define a profunctor $P^{X,Y}$
and get:
\[
P^{X,Y}\triangleq\left(X\rightarrow\text{Int}\right)\times Y\times\left(X\rightarrow Y\right)\quad,\quad\quad Q^{A}=P^{A,A}\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-applicative-II-11}(b)}

Hint: Use $P^{A}\triangleq A\rightarrow Z$ as a counterexample.

\addsec{Chapter \ref{chap:9-Traversable-functors-and}}

\subsubsection*{Exercise \ref{subsec:Exercise-traversables-7-1}(c)}

We use the definitions of \lstinline!NEL[A]! and of the function
\lstinline!foldLeft! shown in Example~\ref{subsec:Disjunctive-Example-non-empty-list-foldLeft}.
\begin{lstlisting}
def foldMap[A, M: Monoid](f: A => M)(t: NEL[A]): M =
  foldLeft(t)(Monoid[M].empty)((m, a) => f(a) |+| m)
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-traversables-1}}

Begin by expressing \lstinline!consume! via \lstinline!sequence!
and back:
\begin{align}
 & \text{consume}_{L}(f^{:L^{A}\rightarrow B})(p^{:L^{F^{A}}})=p\triangleright\text{seq}_{L}\triangleright f^{\uparrow F}\quad,\quad\text{or equivalently}:\quad\text{consume}_{L}(f)=\text{seq}_{L}\bef f^{\uparrow F}\quad,\label{eq:consume-via-seq}\\
 & \text{seq}_{L}=\text{consume}_{L}(\text{id}^{:L^{A}\rightarrow L^{A}})\quad.\label{eq:seq-via-consume}
\end{align}
The pattern is similar to that in the equivalence of \lstinline!sequence!
and \lstinline!traverse!. We could use the Yoneda identity directly,
as we did in the proof of Statement~\ref{subsec:Statement-tr-equivalent-to-ftr}.
Nevertheless, let us write out the derivation in detail.

We need to derive the equivalence between \lstinline!consume! and
\lstinline!sequence! in both directions. To figure out the necessary
naturality law, we begin with the direction that restores \lstinline!consume!
from \lstinline!sequence! because \lstinline!consume! is the more
complicated function (having two type parameters).

\textbf{(a)} Given a function \lstinline!consume!, we define \lstinline!sequence!
via Eq.~(\ref{eq:seq-via-consume}) and then define a new function
\lstinline!consume!$^{\prime}$ via Eq.~(\ref{eq:consume-via-seq}).
Then we need to show that \lstinline!consume!$^{\prime}$ equals
\lstinline!consume!. For an arbitrary $f^{:L^{A}\rightarrow B}$,
we write:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{consume}_{L}(f):}\quad & \text{consume}_{L}^{\prime}(f)=\text{seq}_{L}\bef f^{\uparrow F}=\text{consume}_{L}(\text{id})\bef f^{\uparrow F}=???
\end{align*}
If we know nothing about \lstinline!consume!, we cannot conclude
that $\text{consume}_{L}(f)\overset{?}{=}\text{consume}_{L}(\text{id})\bef f^{\uparrow F}$
because the function $f$ is arbitrary and the value $\text{consume}_{L}(f)$
does not need to be related in any way to $\text{consume}_{L}(\text{id})$.
We must use a naturality law involving a lifted function applied after
\lstinline!consume!:
\begin{equation}
\text{consume}_{L}(f^{:L^{A}\rightarrow B})\bef(g^{:B\rightarrow C})^{\uparrow F}=\text{consume}_{L}(f\bef g)\quad.\label{eq:consume-naturality-law}
\end{equation}
If this law holds, we can derive the required equation:
\[
\text{consume}_{L}^{\prime}(f)=\text{consume}_{L}(\text{id})\bef f^{\uparrow F}=\text{consume}_{L}(\text{id}\bef f)=\text{consume}_{L}(f)\quad.
\]

\textbf{(b)} Given a function \lstinline!sequence!, we first define
\lstinline!consume! via Eq.~(\ref{eq:consume-via-seq}) and then
define a new function \lstinline!sequence!$^{\prime}$ via Eq.~(\ref{eq:seq-via-consume}).
We then show that \lstinline!sequence!$^{\prime}$ equals \lstinline!sequence!:
\[
\text{seq}_{L}^{\prime}=\text{consume}_{L}(\text{id})=\text{seq}_{L}\bef\gunderline{\text{id}^{\uparrow F}}=\text{seq}\quad.
\]

If a function \lstinline!consume! is defined via \lstinline!sequence!,
the naturality law~(\ref{eq:consume-naturality-law}) will hold automatically:
\[
\text{consume}_{L}(f)\bef g^{\uparrow F}=\text{seq}_{L}\bef\gunderline{f^{\uparrow F}\bef g^{\uparrow F}}=\text{seq}_{L}\bef(f\bef g)^{\uparrow F}=\text{consume}_{L}\left(f\bef g\right)\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-traversables-laws-1}}

The naturality law of \lstinline!ftr! with respect to the type parameter
$B$ is:
\begin{equation}
\text{ftr}\,(f^{:A\rightarrow G^{B}})\bef(g^{:B\rightarrow C})^{\uparrow H}=\text{ftr}\,(f\bef g^{\uparrow G})\quad.\label{eq:ftr-right-naturality-law}
\end{equation}
The type signature of \lstinline!tr! has only one type parameter,
so \lstinline!tr! has only one naturality law:
\begin{equation}
(f^{:A\rightarrow B})^{\uparrow G\uparrow F}\bef\text{tr}=\text{tr}\bef f^{\uparrow H}\quad.\label{eq:tr-naturality-law}
\end{equation}

1) We show that the naturality law~(\ref{eq:tr-naturality-law})
of \lstinline!tr! follows from the two naturality laws of \lstinline!ftr!.
Express \lstinline!tr! as $\text{ftr}\left(\text{id}\right)$ and
substitute into the two sides of \lstinline!tr!\textsf{'}s naturality law:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & f^{\uparrow G\uparrow F}\bef\text{tr}=f^{\uparrow G\uparrow F}\bef\text{ftr}\left(\text{id}\right)\\
{\color{greenunder}\text{naturality law~(\ref{eq:ftr-left-naturality-law})}:}\quad & \quad=\text{ftr}\,(f^{\uparrow G}\bef\text{id})=\text{ftr}\,(f^{\uparrow G})\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{tr}\bef f^{\uparrow H}=\text{ftr}\left(\text{id}\right)\bef f^{\uparrow H}\\
{\color{greenunder}\text{naturality law~(\ref{eq:ftr-right-naturality-law})}:}\quad & \quad=\text{ftr}\,(\text{id}\bef f^{\uparrow G})=\text{ftr}\,(f^{\uparrow G})\quad.
\end{align*}
The two sides of the law are now equal.

2) We show that the second naturality law of \lstinline!ftr! follows
from the naturality law of \lstinline!tr!. Express \lstinline!ftr!
through \lstinline!tr! as $\text{ftr}\,(f)=f^{\uparrow F}\bef\text{tr}$,
and substitute into the two sides of \lstinline!ftr!\textsf{'}s naturality
law~(\ref{eq:ftr-right-naturality-law}): 
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \text{ftr}\,(f\big)\bef g^{\uparrow H}=f^{\uparrow F}\bef\gunderline{\text{tr}\bef g^{\uparrow H}}\\
{\color{greenunder}\text{naturality law~(\ref{eq:tr-naturality-law}) of }\text{tr}:}\quad & =f^{\uparrow F}\bef g^{\uparrow G\uparrow F}\bef\text{tr}=(f\bef g^{\uparrow G})^{\uparrow F}\bef\text{tr}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{ftr}\,(f\bef g^{\uparrow G})=(f\bef g^{\uparrow G})^{\uparrow F}\bef\text{tr}\quad.
\end{align*}
The two sides of the law are now equal.

\subsubsection*{Exercise \ref{subsec:Exercise-traversables-5}}

To verify the identity law~(\ref{eq:identity-law-of-sequence}),
set $F=\text{Id}$ in the definition~(\ref{eq:def-sequence-for-functor-composition})
of $\text{seq}_{L}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & \text{seq}_{L}^{\text{Id},A}=(\text{seq}_{N}^{\text{Id},A})^{\uparrow M}\bef\text{seq}_{M}^{\text{Id},N^{A}}\\
{\color{greenunder}\text{identity laws of }\text{seq}_{M}\text{ and }\text{seq}_{N}:}\quad & =\text{id}^{\uparrow M}\bef\text{id}=\text{id}\quad.
\end{align*}

To verify the composition law~(\ref{eq:composition-law-of-sequence}),
begin with the left-hand side:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{seq}_{L}^{F\circ G,A}:}\quad & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}\\
 & \quad=(\text{seq}_{N}^{F,G^{A}})^{\uparrow M}\bef\gunderline{\text{seq}_{M}^{F,N^{G^{A}}}\bef\big((\text{seq}_{N}^{G,A})^{\uparrow M}}\bef\text{seq}_{M}^{G,N^{A}}\big)^{\uparrow F}\\
{\color{greenunder}\text{naturality law of }\text{seq}_{M}:}\quad & \quad=(\text{seq}_{N}^{F,G^{A}})^{\uparrow M}\bef(\text{seq}_{N}^{G,A})^{\uparrow F\uparrow M}\bef\text{seq}_{M}^{F,G^{N^{A}}}\bef(\text{seq}_{M}^{G,N^{A}})^{\uparrow F}\\
{\color{greenunder}\text{composition laws of }\text{seq}_{M}\text{ and }\text{seq}_{N}:}\quad & \quad=(\text{seq}_{N}^{F\circ G,A})^{\uparrow M}\bef\text{seq}_{M}^{F\circ G,N^{A}}=\text{seq}_{L}^{F\circ G,A}\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-traversables-10}}

The empty elements of the monoids $M^{R}$ and $M^{S}$ are, by definition,
$\text{pu}_{M}(e_{R})$ and $\text{pu}_{M}(e_{S})$ respectively.
The binary operations of $M^{R}$ and $M^{S}$ are:
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{M^{S}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:S}\rightarrow q\triangleright(v^{:S}\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\quad.
\end{align*}
To verify the properties of the monoid morphism, begin with the identity
law:
\begin{align*}
{\color{greenunder}\text{expect to equal }e_{M^{S}}:}\quad & \gunderline{e_{M^{R}}}\triangleright\phi^{\uparrow M}=e_{R}\triangleright\gunderline{\text{pu}_{M}\triangleright\phi^{\uparrow M}}=\gunderline{e_{R}\triangleright\phi}\triangleright\text{pu}_{M}=e_{S}\triangleright\text{pu}_{M}=e_{M^{S}}\quad.
\end{align*}
Now check the composition law. For any $p^{:M^{R}}$ and $q^{:M^{R}}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}:}\quad & (p\triangleright\phi^{\uparrow M})\underset{M^{S}}{\oplus}(q\triangleright\phi^{\uparrow M})\\
 & =(p\triangleright\gunderline{\phi^{\uparrow M})\triangleright\text{flm}_{M}}\big(u\rightarrow q\triangleright\phi^{\uparrow M}\triangleright(v\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(\gunderline{\phi\bef(}v\rightarrow\phi(u)\oplus_{S}v))^{\uparrow M}\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\gunderline{\phi(u)\oplus_{S}\phi(v)}))^{\uparrow M}\big)\\
{\color{greenunder}\text{composition law of }\phi:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\phi(u\oplus_{R}v))^{\uparrow M}\big)\\
{\color{greenunder}\text{move }\phi^{\uparrow M}\text{ outside}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi^{\uparrow M}\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =\gunderline{p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)}\bef\phi^{\uparrow M}\\
 & =(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-traversables-10-1}}

The empty elements of the monoids $M^{R}$ and $N^{R}$ are, by definition,
are $\text{pu}_{M}(e_{R})$ and $\text{pu}_{N}(e_{R})$ respectively.
The binary operations of $M^{R}$ and $N^{R}$ are:
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{N^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{N}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow N}\big)\quad.
\end{align*}
To verify the properties of the monoid morphism, begin with the identity
law:
\begin{align*}
{\color{greenunder}\text{expect to equal }e_{N^{R}}:}\quad & \gunderline{e_{M^{R}}}\triangleright\phi=\gunderline{e_{R}\triangleright\text{pu}_{M}}\triangleright\phi=e_{R}\triangleright\text{pu}_{N}=e_{N^{R}}\quad.
\end{align*}
Now check the composition law. For any $p^{:M^{R}}$ and $q^{:M^{R}}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi:}\quad & (p\triangleright\phi)\underset{N^{R}}{\oplus}(q\triangleright\phi)=(p\triangleright\phi)\triangleright\text{flm}_{N}\big(u\rightarrow q\triangleright\gunderline{\phi\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow N}}\big)\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =p\triangleright\gunderline{\phi\bef\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi\big)^{\uparrow N}}\bef\text{ftn}_{N}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)^{\uparrow M}\bef\gunderline{\phi\bef\phi^{\uparrow N}\bef\text{ftn}_{N}}\\
{\color{greenunder}\text{composition law of }\phi:}\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\gunderline{\big)^{\uparrow M}\bef\text{ftn}_{M}}\bef\phi\\
{\color{greenunder}\text{definition of }\text{ftn}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\bef\phi=(p\underset{M^{R}}{\oplus}q)\triangleright\phi\quad.
\end{align*}


\addsec{Chapter \ref{chap:Free-type-constructions}}

\subsubsection*{Exercise \ref{subsec:Exercise-P-algebras-monad-algebras}}

\textbf{(a)} The $P$-algebra structure maps are defined by:
\[
p_{C}\triangleq\text{pu}_{E}^{\uparrow P}\bef p_{E}^{C}\bef s_{C}\quad,\quad\quad p_{D}\triangleq\text{pu}_{E}^{\uparrow P}\bef p_{E}^{D}\bef s_{D}\quad.
\]
The assumption is that $f$ is an $E$-algebra morphism:
\[
f^{\uparrow E}\bef s_{D}=s_{C}\bef f\quad.
\]
Also, an $E$-monad algebra property is:
\[
\text{pu}_{E}\bef s_{C}=\text{id}\quad,\quad\quad\text{pu}_{E}\bef s_{D}=\text{id}\quad.
\]

To verify the $P$-algebra morphism law of $f$:
\begin{align*}
{\color{greenunder}\text{expect to equal }p_{C}\bef f:}\quad & f^{\uparrow P}\bef p_{D}=\gunderline{f^{\uparrow P}\bef\text{pu}_{E}^{\uparrow P}}\bef p_{E}^{D}\bef s_{D}\\
{\color{greenunder}\text{naturality law of }\text{pu}_{E}:}\quad & =\text{pu}_{E}^{\uparrow P}\bef\gunderline{f^{\uparrow E\uparrow P}\bef p_{E}^{D}}\bef s_{D}\\
{\color{greenunder}\text{naturality law of }p_{E}:}\quad & =\text{pu}_{E}^{\uparrow P}\bef p_{E}^{C}\bef\gunderline{f^{\uparrow E}\bef s_{D}}\\
{\color{greenunder}E\text{-algebra morphism law of }f:}\quad & =\gunderline{\text{pu}_{E}^{\uparrow P}\bef p_{E}^{C}\bef s_{C}}\bef f=p_{C}\bef f\quad.
\end{align*}

\textbf{(b)} The $E$-monad algebra structure maps are defined by:
\[
s_{C}\triangleq\text{eval}_{E}^{C}(p_{C})\quad,\quad\quad s_{D}\triangleq\text{eval}_{E}^{D}(p_{D})\quad.
\]
The assumption is that $f$ is a $P$-algebra morphism. To verify
the $E$-algebra morphism law of $f$:
\begin{align*}
{\color{greenunder}\text{expect to equal }s_{C}\bef f:}\quad & f^{\uparrow E}\bef s_{D}=f^{\uparrow E}\bef\text{eval}_{E}^{D}\\
{\color{greenunder}P\text{-algebra naturality law~(\ref{eq:free-typeclass-encoding-P-algebra-naturality-law}) of }\text{eval}_{E}:}\quad & =\text{eval}_{E}^{C}\bef f=s_{C}\bef f\quad.
\end{align*}


\addsec{Chapter \ref{chap:monad-transformers}}

\subsubsection*{Exercise \ref{subsec:Exercise-monad-transformer-extra-layer}}

The identity law of monad morphisms is:
\[
\text{pu}_{\text{Id}}\bef\phi=\text{pu}_{M}\quad.
\]
Since $\text{pu}_{\text{Id}}=\text{id}$, we get $\phi=\text{pu}_{M}$.
So, there can be no other monad morphisms $\text{Id}\leadsto M$.

\subsubsection*{Exercise \ref{subsec:Exercise-monad-transformer-extra-layer-5}}

The identity law of monad morphisms says that $\text{pu}_{\bbnum 1}\bef\phi=\text{pu}_{M}$.
However, $\text{pu}_{\bbnum 1}=\_^{:A}\rightarrow1$ and ignores its
argument. So, $\text{pu}_{M}$ is also a function that ignores its
argument. By the monad $M$\textsf{'}s left identity law, $\text{pu}_{M}\bef\text{ftn}_{M}=\text{id}^{:M^{A}\rightarrow M^{A}}$.
So, the identity function $\text{id}:M^{A}\rightarrow M^{A}$ ignores
its argument. It always returns the same value of type $M^{A}$, say
$m_{0}$. It follows that the type $M^{A}$ has only one distinct
value, namely $m_{0}$. So $M^{A}\cong\bbnum 1$. This argument holds
for each type $A$. 

\subsubsection*{Exercise \ref{subsec:Exercise-monad-transformer-extra-layer-3}}

\textbf{(a)} For any monad morphism $\phi:M\leadsto N$, the monadic
naturality law must hold:
\[
\text{dbl}\bef\phi\overset{?}{=}\phi\bef\text{dbl}\quad.
\]
The left-hand side applied to an arbitrary value $m^{:M^{A}}$ is:
\begin{align*}
 & m\triangleright\text{dbl}\bef\phi=m\triangleright(\_\rightarrow m)^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\phi}\\
{\color{greenunder}\text{monad morphism law of }\phi:}\quad & =m\triangleright\gunderline{(\_\rightarrow m)^{\uparrow M}\bef\phi^{\uparrow M}}\bef\phi\bef\text{ftn}_{M}\\
{\color{greenunder}\text{compute composition}:}\quad & =m\triangleright\gunderline{(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\phi}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =m\triangleright\phi\bef(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}
The right-hand side applied to $m$ is:
\begin{align*}
 & m\triangleright\phi\bef\text{dbl}=m\triangleright\phi\triangleright\text{dbl}=m\triangleright\phi\triangleright(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =m\triangleright\phi\bef(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}
Both sides are now equal.

\textbf{(b)} The identity law holds:
\[
a\triangleright\text{pu}_{M}\bef\text{dbl}=a\triangleright\text{pu}_{M}\triangleright\text{flm}_{M}(\_\rightarrow a\triangleright\text{pu}_{M})=a\triangleright(\_\rightarrow a\triangleright\text{pu}_{M})=a\triangleright\text{pu}_{M}\quad.
\]
The composition law:
\[
\text{dbl}^{\uparrow M}\bef\text{dbl}\bef\text{ftn}_{M}\overset{?}{=}\text{ftn}_{M}\bef\text{dbl}\quad.
\]
Simplify the left-hand side, applying to an arbitrary value $p:M^{M^{A}}$.
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p\triangleright\text{dbl}^{\uparrow M}\bef\text{dbl}\bef\text{ftn}_{M}=p\triangleright\text{dbl}^{\uparrow M}\triangleright(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{associativity law of }M:}\quad & =p\triangleright\text{dbl}^{\uparrow M}\bef(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})^{\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\big(\text{dbl}\bef(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})\bef\text{ftn})\big)^{\uparrow M}\bef\text{ftn}_{M}=p\triangleright\big(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M}\bef\text{ftn}_{M})\big)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\text{flm}_{M}\big(\_\rightarrow p\triangleright\text{flm}_{M}(\text{dbl})\big)\quad.
\end{align*}
The right-hand side:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & p\triangleright\text{ftn}_{M}\bef\text{dbl}=p\triangleright\gunderline{\text{ftn}_{M}\bef(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M}}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{M}:}\quad & =p\triangleright(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{associativity law of }M:}\quad & =p\triangleright(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\big((\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\text{flm}_{M}\big(\text{flm}_{M}(\_\rightarrow p\triangleright\text{ftn}_{M})\big)\quad.
\end{align*}
The simplification is stuck \textemdash{} we cannot make the two sides
coincide; no law can be applied to simplify further.

Choosing specific values $p=\text{pu}_{M}(m)$ or $p=\text{pu}_{M}^{\uparrow M}(m)$
does not help to obtain a counter-example: the laws hold for those
specific choices.

To obtain a counter-example, consider a specific non-commutative monad,
such as \lstinline!List!. For the \lstinline!List! monad, the \lstinline!double!
function repeats the entire list as many times as elements in the
list:
\begin{lstlisting}
scala> double(List(1, 2))
res0: List[Int] = List(1, 2, 1, 2)

scala> val ll = List(List(1, 2), List(3))
ll: List[List[Int]] = List(List(1, 2), List(3))

scala> double(ll.flatten)
res1: List[Int] = List(1, 2, 3, 1, 2, 3, 1, 2, 3)

scala> double(ll.map(double))
res2: List[List[Int]] = List(List(1, 2, 1, 2), List(3), List(1, 2, 1, 2), List(3)) 

scala> double(ll.map(double)).flatten
res3: List[Int] = List(1, 2, 1, 2, 3, 1, 2, 1, 2, 3)
\end{lstlisting}
The composition law does not hold.

\subsubsection*{Exercise \ref{subsec:Statement-search-and-selector-monads}}

The identity law does not hold:
\begin{align*}
{\color{greenunder}\text{expect to equal }a\triangleright\text{pu}_{\text{Search}}:}\quad & a\triangleright\text{pu}_{\text{Sel}}\bef\text{finder}=(\_^{:A\rightarrow\bbnum 1+P}\rightarrow a)\triangleright\text{finder}\\
 & =p\rightarrow p(a)\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
P & \bbnum 0 & a
\end{array}\,=p\rightarrow a\triangleright p\bef(\_\rightarrow a)^{\uparrow\text{Opt}}\neq p\rightarrow\bbnum 0+a\quad.
\end{align*}
The result should have been $\text{pu}_{\text{Search}}(a)=\_\rightarrow\text{pu}_{\text{Opt}}(a)=\_\rightarrow\bbnum 0+a$.

\subsubsection*{Exercise \ref{subsec:Exercise-selector-and-continuation-monads}}

To verify the identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }a\triangleright\text{pu}_{\text{Cont}}:}\quad & a\triangleright\text{pu}_{\text{Sel}}\bef\text{scc}=f\rightarrow f(f\triangleright(\gunderline{a\triangleright\text{pu}_{\text{Sel}}}))\\
{\color{greenunder}\text{use definition of }\text{pu}_{\text{Sel}}:}\quad & =f\rightarrow f(f\triangleright(\_\rightarrow a))=f\rightarrow f(a)=a\triangleright\text{pu}_{\text{Cont}}\quad.
\end{align*}
To verify the composition law, we begin with the flipped Kleisli formulation
of the two monads. The flipped Kleisli functions have types $\left(B\rightarrow P\right)\rightarrow A\rightarrow P$
(for \lstinline!Cont!) and $\left(B\rightarrow P\right)\rightarrow A\rightarrow B$
(for \lstinline!Sel!).
\begin{align*}
 & f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow P}\tilde{\diamond}_{_{\text{Cont}}}g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow P}\triangleq h^{:C\rightarrow P}\rightarrow h\triangleright g\triangleright f=g\bef f\quad,\\
 & f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow B}\tilde{\diamond}_{_{\text{Sel}}}g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow C}\triangleq h^{:C\rightarrow P}\rightarrow f(g(h)\bef h)\bef g(h)\quad.
\end{align*}
We need to check that \lstinline!Sel!\textsf{'}s Kleisli composition ($\tilde{\diamond}_{_{\text{Sel}}}$)
is mapped to \lstinline!Cont!\textsf{'}s Kleisli composition ($\tilde{\diamond}_{_{\text{Cont}}}$).
First, we need to modify \lstinline!scc! so that it works on the
flipped Kleisli functions:
\[
\tilde{\text{scc}}^{A,B}:\left(\left(B\rightarrow P\right)\rightarrow A\rightarrow B\right)\rightarrow\left(B\rightarrow P\right)\rightarrow A\rightarrow P\quad,\quad\tilde{\text{scc}}=c^{:\left(\left(B\rightarrow P\right)\rightarrow A\rightarrow B\right)}\rightarrow k^{:B\rightarrow P}\rightarrow c(k)\bef k\quad.
\]

Note that the implementation of \lstinline!scc! is uniquely determined
by its type signature, and so is the implementation of $\tilde{\text{scc}}$.
So, we can spare ourselves the effort of translating $\text{scc}$
into $\tilde{\text{scc}}$.

Now it remains to show that for any $f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow B}$
and $g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow C}$
the law holds:
\[
(f\triangleright\tilde{\text{scc}}^{A,B})\tilde{\diamond}_{_{\text{Cont}}}(g\triangleright\tilde{\text{scc}}^{B,C})=(f\tilde{\diamond}_{_{\text{Sel}}}g)\triangleright\tilde{\text{scc}}^{A,C}\quad.
\]
Rewrite the two sides of the law separately:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (f\triangleright\tilde{\text{scc}})\tilde{\diamond}_{_{\text{Cont}}}(g\triangleright\tilde{\text{scc}})=(g\triangleright\tilde{\text{scc}})\bef(f\triangleright\tilde{\text{scc}})=(k\rightarrow g(k)\bef k)\bef(h\rightarrow f(h)\bef h)\\
 & \quad=k\rightarrow f(g(k)\bef k)\bef g(k)\bef k\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & (f\tilde{\diamond}_{_{\text{Sel}}}g)\triangleright\tilde{\text{scc}}=\big(h\rightarrow f(g(h)\bef h)\bef g(h)\big)\triangleright\tilde{\text{scc}}=k\rightarrow\big(h\rightarrow f(g(h)\bef h)\bef g(h)\big)(k)\bef k\\
 & \quad=k\rightarrow f(g(k)\bef k)\bef g(k)\bef k\quad.
\end{align*}
Both sides are now equal.

\subsubsection*{Exercise \ref{par:Exercise-mt-3-1}}

The operations $\text{pu}_{N}$ and $\text{ftn}_{N}$ are defined
by:
\[
\text{pu}_{N}\triangleq\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\quad,\quad\quad\text{ftn}_{N}\triangleq\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\]

To verify the identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{M}:}\quad & \text{pu}_{N}\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\text{pu}_{M}\quad.
\end{align*}
To verify the composition law, transform separately the two sides
of the law:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \gamma_{M}\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{N^{A}}\\
\hline N^{A} & \text{pu}_{M}\\
M^{N^{A}} & \text{id}
\end{array}\,\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline N^{A} & \gunderline{\text{pu}_{M}\bef\gamma_{M}^{\uparrow M}}\bef\text{ftn}_{M}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\\
 & \quad=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline N^{A} & \gamma_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{ftn}_{N}\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\end{align*}
The two sides are now equal.

\subsubsection*{Exercise \ref{par:Exercise-mt-3}}

The operations $\text{ftn}_{L}$ and $\text{ftn}_{N}$ are defined
as usual for a free pointed monad:
\begin{align*}
 & \text{ftn}_{L}\triangleq\,\begin{array}{|c||c|}
 & L^{A}\\
\hline L^{A} & \text{id}\\
K^{L^{A}} & k\rightarrow\bbnum 0+k\triangleright\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\quad,\\
 & \text{ftn}_{N}\triangleq\,\begin{array}{|c||c|}
 & N^{A}\\
\hline N^{A} & \text{id}\\
M^{N^{A}} & m\rightarrow\bbnum 0+m\triangleright\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\end{align*}

We define $\psi$ by:
\[
\psi=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\quad.
\]

To verify the identity law for $\psi$:
\[
\text{pu}_{L}\bef\psi=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,=\text{pu}_{N}\quad.
\]

To verify the composition law for $\psi$, write both sides of the
law separately:
\begin{align*}
\psi^{\uparrow L}\bef\psi\bef\text{ftn}_{N} & =\,\begin{array}{|c||ccc|}
 & A & M^{A} & K^{N^{A}}\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
K^{A} & \bbnum 0 & \phi & \bbnum 0\\
K^{L^{A}} & \bbnum 0 & \bbnum 0 & \psi^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||ccc|}
 & A & M^{A} & M^{N^{A}}\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id} & \bbnum 0\\
K^{N^{A}} & \bbnum 0 & \bbnum 0 & \phi
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\\
 & =\,\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi\\
K^{L^{A}} & \bbnum 0 & \psi^{\uparrow K}\bef\phi\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad,\\
\text{ftn}_{L}\bef\psi & =\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi
\end{array}\quad.
\end{align*}
It remains to show that:
\[
\psi^{\uparrow K}\bef\phi\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi\quad.
\]
The monad morphism law for $\phi$ gives:
\[
\phi\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{K}\bef\phi\quad.
\]
It remains to show that:
\begin{align*}
 & \gunderline{\psi^{\uparrow K}\bef\phi}\bef\gamma_{M}^{\uparrow M}\overset{?}{=}\gunderline{\gamma_{K}^{\uparrow K}\bef\phi}\bef\phi^{\uparrow M}\quad.\\
 & \phi\bef\psi^{\uparrow M}\bef\gamma_{M}^{\uparrow M}=\phi\bef(\psi\bef\gamma_{M})^{\uparrow M}\overset{?}{=}\phi\bef\gamma_{K}^{\uparrow M}\bef\phi^{\uparrow M}=\phi\bef(\gamma_{K}\bef\phi)^{\uparrow M}\quad.
\end{align*}
It remains to show that $\psi\bef\gamma_{M}=\gamma_{K}\bef\phi$.
For that, we use the identity law of $\phi$:
\begin{align*}
 & \psi\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \phi
\end{array}\quad,\\
 & \gamma_{K}\bef\phi=\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\,\bef\phi=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \gunderline{\text{pu}_{K}\bef\phi}\\
K^{A} & \phi
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \phi
\end{array}\quad.
\end{align*}


\subsubsection*{Exercise \ref{par:Exercise-mt-3-3}}

\textbf{(a)} Verify the naturality law of $\psi$, assuming the naturality
laws of $\phi$ and $\chi$:
\begin{align*}
 & (f^{:A\rightarrow B})^{\uparrow(K+L)}\bef\psi=\,\begin{array}{|c||cc|}
 & K^{B} & L^{B}\\
\hline K^{A} & f^{\uparrow K} & \bbnum 0\\
L^{A} & \bbnum 0 & f^{\uparrow L}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{B} & \phi\\
L^{B} & \chi
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \gunderline{f^{\uparrow K}\bef\phi}\\
L^{A} & \gunderline{f^{\uparrow L}\bef\chi}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \phi\bef f^{\uparrow M}\\
L^{A} & \chi\bef f^{\uparrow M}
\end{array}\quad,\\
 & \psi\bef f^{\uparrow M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline K^{A} & \phi\\
L^{A} & \chi
\end{array}\,\bef f^{\uparrow M}=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \phi\bef f^{\uparrow M}\\
L^{A} & \chi\bef f^{\uparrow M}
\end{array}\quad.
\end{align*}

\textbf{(b)} Given the definitions of $\phi$ and $\chi$, we can
write $\psi$ as:
\[
\psi=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline K^{A} & \phi\\
L^{A} & \chi
\end{array}\quad.
\]
Assuming the naturality law of $\psi$, verify the naturality law
of $\phi$ by applying to an arbitrary value $k^{:K^{A}}$ and expressing
$f^{\uparrow K}$ through $f^{\uparrow(K+L)}$: 
\begin{align*}
{\color{greenunder}\text{expect to equal }k\triangleright\phi\bef f^{\uparrow M}:}\quad & k\triangleright f^{\uparrow K}\bef\phi=k\triangleright f^{\uparrow K}\triangleright(k\rightarrow k+\bbnum 0)\triangleright\psi=\big((k\triangleright f^{\uparrow K})+\bbnum 0\big)\triangleright\psi\\
 & =(k+\bbnum 0)\triangleright\,\begin{array}{|c||cc|}
 & K^{B} & L^{B}\\
\hline K^{A} & f^{\uparrow K} & \bbnum 0\\
L^{A} & \bbnum 0 & f^{\uparrow L}
\end{array}\,\bef\psi=(k+\bbnum 0)\triangleright\gunderline{f^{\uparrow(K+L)}\bef\psi}\\
{\color{greenunder}\text{naturality law of }\psi:}\quad & =(\gunderline{k+\bbnum 0})\triangleright\psi\bef f^{\uparrow M}=k\triangleright\gunderline{(x\rightarrow x+\bbnum 0)\bef\psi}\bef f^{\uparrow M}=k\triangleright\phi\bef f^{\uparrow M}\quad.
\end{align*}

The proof of the naturality law of $\chi$ is analogous.

\subsubsection*{Exercise \ref{par:Exercise-mt-3-2-1}}

\textbf{(a)} Choose the monads $K^{A}\triangleq R\rightarrow A$ and
$M^{A}\triangleq S\rightarrow A$, where $R$, $S$ are fixed (but
arbitrary) types. Define $P^{A}\triangleq A+T_{K}^{M,A}$ and show
that there exist no monad morphisms $\phi:M^{A}\rightarrow P^{A}$.
If such $\phi$ exists, it must satisfy the identity law, $\text{pu}_{M}\bef\phi=\text{pu}_{P}$.
The type signature of $\phi$ is:
\[
\phi:(R\rightarrow A)\rightarrow A+(S\rightarrow R\rightarrow A)\quad.
\]
The only fully parametric implementation is:
\[
\phi:f^{:R\rightarrow A}\rightarrow\bbnum 0+(\_^{:S}\rightarrow f)\quad,
\]
because we cannot produce values of type $A+\bbnum 0$ since we cannot
create values of the unknown type $R$. However, this implementation
of $\phi$ does not satisfy the identity law since $\text{pu}_{P}$
must return values of type $A+\bbnum 0$.

\textbf{(b)} Given $\theta_{K}:K^{A}\rightarrow M^{A}$, we define:
\[
\theta_{L}:L^{A}\rightarrow M^{A}\quad,\quad\quad\theta_{L}\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \theta_{K}
\end{array}\quad.
\]
The proof becomes shorter if we express $\theta_{L}$ as:
\[
\theta_{L}=\gamma_{K}\bef\theta_{K}\quad,\quad\quad\gamma_{K}\triangleq\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\quad.
\]
We already know that $\gamma_{K}:L\leadsto K$ is a monad morphism
(Exercise~\ref{par:Exercise-mt-3-1}). So, $\theta_{L}$ is a composition
of monad morphisms.

\textbf{(c)} Choose $K^{A}\triangleq\bbnum 1$ (the unit monad) and
note that $L^{A}=A+\bbnum 1$ is the standard \lstinline!Option!
monad (there are no other lawful monad implementations for the type
constructor $L^{A}\triangleq A+\bbnum 1$). Choose $M\triangleq L$,
so that a monad morphism $\theta_{L}\triangleq\text{id}^{:L\leadsto M}$
exists. If it were possible to define a monad morphism $K\leadsto M$,
we would have a monad morphism $\bbnum 1\rightarrow\bbnum 1+A$, but
this is impossible: the only natural transformation of type $\bbnum 1\rightarrow\bbnum 1+A$
is $1\rightarrow1+\bbnum 0$, which does not satisfy the identity
law of monad morphisms, $\text{pu}_{K}\bef\theta_{K}=\text{pu}_{M}$,
since it never returns any values of type $\bbnum 0+A$. (Generally,
the existence of a monad morphism $\bbnum 1\leadsto M$ means that
$M=\bbnum 1$.)

\textbf{(d)} By Exercise~\ref{par:Exercise-mt-3-3}, we have a natural
transformation $\theta_{K}:K^{A}\rightarrow A$ defined by:
\[
\theta_{K}\triangleq(k\rightarrow\bbnum 0+k)\bef\theta_{L}\quad.
\]
The given runner $\theta_{L}$ is then expressed through $\theta_{K}$
as:
\[
\theta_{L}=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\quad,
\]
because the natural transformation in the upper row of the matrix
has the type signature $A\rightarrow A$ and so must be an identity
function.

It remains to verify the monad morphism laws of $\theta_{K}:K\leadsto\text{Id}$.
The identity law is:
\[
\text{pu}_{K}\bef\theta_{K}\overset{?}{=}\text{pu}_{\text{Id}}=\text{id}\quad.
\]
 Since the function $p\triangleq\text{pu}_{K}\bef\theta_{K}$ has
type signature $A\rightarrow A$ and is a natural transformation (as
a composition of two natural transformations), that function must
satisfy $p\bef f=f\bef p$ for any function $f^{:A\rightarrow B}$,
and so $p$ must be equal to the identity function.

The composition law of $\theta_{K}$ is an equation for functions
of type $K^{K^{A}}\rightarrow A$:
\[
\text{ftn}_{K}\bef\theta_{K}\overset{?}{=}\theta_{K}^{\uparrow K}\bef\theta_{K}\bef\text{ftn}_{\text{Id}}=\theta_{K}\bef\theta_{K}\quad.
\]
Applied to an arbitrary value $k:K^{K^{A}}$, this law becomes:
\[
k\triangleright\text{ftn}_{K}\bef\theta_{K}\overset{?}{=}k\triangleright\theta_{K}^{\uparrow K}\bef\theta_{K}\quad.
\]
Since $\theta_{K}$ is defined via $\theta_{L}$, we need to use the
composition law of $\theta_{L}$:
\[
\text{ftn}_{L}\bef\theta_{L}\overset{!}{=}\theta_{L}^{\uparrow L}\bef\theta_{L}\bef\text{ftn}_{\text{Id}}=\theta_{L}^{\uparrow K}\bef\theta_{L}\quad.
\]
Rewrite this law as:
\begin{align*}
 & \text{ftn}_{L}\bef\theta_{L}=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}\\
K^{L^{A}} & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}
\end{array}\quad,\\
 & \theta_{L}^{\uparrow L}\bef\theta_{L}=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \theta_{L}^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}\\
K^{L^{A}} & \theta_{L}^{\uparrow K}\bef\theta_{K}
\end{array}\quad.
\end{align*}
The third rows of the matrices give the equation for functions of
type $K^{L^{A}}\rightarrow A$:
\[
\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}\theta_{L}^{\uparrow K}\bef\theta_{K}\quad.
\]
Apply both sides of this equation to an arbitrary value $p$ of type
$K^{\bbnum 0+K^{A}}$, defined via an arbitrary value $k^{:K^{K^{A}}}$
as $p\triangleq k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}$:
\begin{align*}
 & p\triangleright\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}p\triangleright\theta_{L}^{\uparrow K}\bef\theta_{K}\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}\bef\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}\bef\theta_{L}^{\uparrow K}\bef\theta_{K}\quad.
\end{align*}
We compute some sub-expressions separately:
\begin{align*}
 & (x\rightarrow\bbnum 0+x)\bef\gamma_{K}=(x\rightarrow\bbnum 0+x)\bef\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\,=x\rightarrow x=\text{id}\quad,\\
 & (x\rightarrow\bbnum 0+x)\bef\theta_{L}=\theta_{K}\quad.
\end{align*}
After these simplifications, the composition law of $\theta_{L}$
gives:
\[
k\triangleright\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}k\triangleright\theta_{K}^{\uparrow K}\bef\theta_{K}\quad.
\]
This is exactly the composition law of $\theta_{K}$ that we still
needed to prove.

\subsubsection*{Exercise \ref{par:Exercise-mt-3-2}}

Consider the monad morphism $\varepsilon:K\leadsto\bbnum 1$ defined
by $\varepsilon\triangleq\_\rightarrow1$. (This is a monad morphism
because all its laws reduce to the equation $1=1$.) By Exercise~\ref{par:Exercise-mt-3},
we can implement a corresponding monad morphism between free pointed
monads $\text{Id}+K\leadsto\text{Id}+\bbnum 1$. Define $\delta$
as that monad morphism. The monad $\text{Id}+\bbnum 1$ (the free
pointed monad on $\bbnum 1$) is the standard \lstinline!Option!
monad. So, we have implemented a monad morphism $\delta:A+K^{A}\rightarrow\text{Opt}^{A}$.

\subsubsection*{Exercise \ref{subsec:Exercise-effectful-list-not-monad}}

\textbf{(a)} Consider the requirement of mapping $L^{L^{A}}\rightarrow L^{A}$
via a \lstinline!flatten! function:
\[
\text{ftn}_{L}:\bbnum 1+L^{A}\times M^{L^{L^{A}}}\rightarrow\bbnum 1+A\times M^{L^{A}}\quad,\quad\quad\text{ftn}_{L}=\text{???}
\]
The result value of this function cannot always be $1$, or else it
will fail the monad laws. This function must sometimes return a pair
of type $A\times M^{L^{A}}$. Let us rewrite the type signature of
\lstinline!flatten! as:
\[
\text{ftn}_{L}:\bbnum 1+(\bbnum 1+A\times M^{L^{A}})\times M^{L^{L^{A}}}\rightarrow\bbnum 1+A\times M^{L^{A}}\quad.
\]
Consider input values of the form:
\[
x\triangleq\bbnum 0^{:\bbnum 1}+(1+\bbnum 0^{:A\times M^{L^{A}}})\times m^{:M^{L^{L^{A}}}}\quad.
\]
the result of evaluating $\text{ftn}_{L}(x)$ must be $1+\bbnum 0$:
a fully parametric function cannot extract values of type $A$ from
a value of type $M^{A}$ with an unknown monad $M$. Note that the
value $(1+\bbnum 0^{:A\times M^{L^{A}}})$ represents an empty list;
let us denote that value by $\text{Nil}^{:L^{A}}$. So, we must have:
\[
\text{ftn}_{L}(\bbnum 0+\text{Nil}\times(...))=\text{Nil}\quad.
\]
Since the only way to extract list values is to run the $M$-effects,
the implementation of $\text{ftn}_{L}$ must proceed recursively,
extracting list elements left to right. Now consider $M=\text{Id}$
(so we can simply omit the functor layers of $M$) and the nested
list value:
\[
z\triangleq\left[p,q,\text{Nil},r,s,...\right]\quad,
\]
 where $p$, $q$, $r$, $s$ are some sub-lists of type $L^{A}$
with some type $A$. Then the value $z$ has the form:
\[
z=\bbnum 0+p\times(\bbnum 0+q\times(\bbnum 0+\text{Nil}\times(\bbnum 0+r\times(\bbnum 0+s\times(1+\bbnum 0)))))\quad.
\]
As we must have $\text{ftn}_{L}(\bbnum 0+\text{Nil}\times t)=\text{Nil}$
for any $t^{:M^{L^{L^{A}}}}$, the recursive evaluation of $\text{ftn}_{L}(z)$
will give:
\[
\text{ftn}_{L}(z)=...\text{ftn}_{L}(\bbnum 0+\text{Nil}\times(\bbnum 0+r\times(\bbnum 0+s\times(1+\bbnum 0))))=...\text{Nil}\quad.
\]
So, the result may be some function of $p$ and $q$ (which could
be $p\pplus q$) but cannot depend on $r$ and $s$. We have shown
that $\text{ftn}_{L}$ must ignore all sub-lists that follow an empty
sub-list. A possible behavior of $\text{ftn}_{L}$ is:
\[
\text{ftn}_{L}(\left[\left[1,2\right],\left[3,4\right],\left[\right],\left[5,6,7,8\right]\right])=\left[1,2,3,4\right]\quad,
\]
instead of the full flattened list $\left[1,2,3,4,5,6,7,8\right]$.
Regardless of how we implement $\text{ftn}_{L}$ (and whether it satisfies
the monad laws), the result of evaluating $\text{ftn}_{L}(z)$ cannot
be the full concatenation $p\pplus q\pplus r\pplus s$ because the
computation must ignore the sub-lists $r$ and $s$.

\textbf{(b)} The code for the non-standard \lstinline!flatten! function
is:
\begin{lstlisting}[mathescape=true]
def flatten[A](p: List[List[A]]): List[A] = p.takeWhile(_.nonEmpty).flatten  // $\color{dkgreen}\textrm{ftn}_L$
\end{lstlisting}
The new \lstinline!flatten! function gives  the same results as \lstinline!List!\textsf{'}s
standard \lstinline!flatten! method, except if one of the nested
sub-lists is empty. Then the \lstinline!flatten! function truncates
the result after the first empty sub-list.

It turns out that this code fails the monad\textsf{'}s associativity law of
\lstinline!flatten!. That law is an equality of functions $\text{ftn}_{L}\bef\text{ftn}_{L}$
and $\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}$ of type \lstinline!List[List[List[A]]] => List[A]!.
The failure is found when a value $p$ of type \lstinline!List[List[List[A]]]!
contains a nested empty list at the \emph{second} nesting depth, following
some non-empty lists. Here is an example that triggers the failure
of the law:
\begin{lstlisting}
val p: List[List[List[Int]]] = List(List(List(1, 2, 3)), List(List(4), Nil), List(List(5, 6)))
\end{lstlisting}
Here the nested list \lstinline!List(List(4), Nil)! contains an empty
list (\lstinline!Nil!) after a non-empty list. Applying both sides
of the law to \lstinline!p!, we find that the two sides of the law
are not equal:
\begin{lstlisting}
scala> flatten(flatten(p))
res0: List[List[Int]] = List(1, 2, 3, 4)

scala> flatten(p.map(flatten))
res1: List[List[Int]] = List(1, 2, 3, 4, 5, 6)
\end{lstlisting}

\textbf{(c)} Try implementing the method $\text{flift}:M^{A}\rightarrow L^{A}$.
The function \lstinline!flift! must produce a value of type $L^{A}\cong\bbnum 1+A\times M^{L^{A}}$.
Since $M$ is an arbitrary monad, we cannot extract a value of type
$A$ out of $M^{A}$ while keeping the code fully parametric. So,
we can implement \lstinline!flift! only by defining $\text{flift}\triangleq\_^{:M^{A}}\rightarrow\text{Nil}^{:L^{A}}$.
However, that implementation loses information and fails the identity
law:
\[
\text{pu}_{M}\bef\text{flift}=(\_\rightarrow\text{Nil})\neq\text{pu}_{L}\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-combined-codensity-monad}}

\textbf{(a)} Denote for brevity $\text{Cod}_{F}^{M,A}\triangleq C^{A}$.
The naturality law for functions $c^{:C^{A}}$ says that for any $k^{:A\rightarrow F^{X}}$
and $q^{:X\rightarrow Y}$, we have:
\[
(k^{:A\rightarrow F^{X}}\bef q^{\uparrow F})\triangleright c^{Y}=k\triangleright c^{X}\bef q^{\uparrow M\uparrow F}\quad.
\]

The flipped Kleisli method $\tilde{\text{pu}}_{C}$ is defined by:
\[
\tilde{\text{pu}}_{C}:\forall X.\,(A\rightarrow F^{X})\rightarrow A\rightarrow F^{M^{X}}\quad,\quad\quad\tilde{\text{pu}}_{C}\triangleq\forall X.\,k^{:A\rightarrow F^{X}}\rightarrow k\bef\text{pu}_{M}^{\uparrow F}\quad.
\]

To verify the left identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }g:}\quad & \tilde{\text{pu}}_{C}\tilde{\diamond}\,g^{:\forall Y.\,(B\rightarrow F^{Y})\rightarrow A\rightarrow F^{M^{Y}}}=\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{k\triangleright g^{Z}\triangleright\tilde{\text{pu}}_{C}^{M^{Z}}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & =\forall Z.\,k^{:C\rightarrow F^{Z}}\rightarrow\big(g^{Z}(k)\bef\gunderline{\text{pu}_{M}^{\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}}\\
{\color{greenunder}\text{left identity law of }M:}\quad & =\forall Z.\,k^{:C\rightarrow F^{Z}}\rightarrow g^{Z}(k)=g\quad.
\end{align*}

To verify the right identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }f:}\quad & f^{:\forall X.\,(B\rightarrow F^{X})\rightarrow A\rightarrow F^{M^{X}}}\tilde{\diamond}\,\tilde{\text{pu}}_{C}=\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{k\triangleright\tilde{\text{pu}}_{C}^{Z}}\triangleright f^{M^{Z}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{(k\bef\text{pu}_{M}^{\uparrow F})\triangleright f^{M^{Z}}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
{\color{greenunder}\text{naturality law of }f:}\quad & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(k\triangleright f^{Z}\bef\gunderline{\text{pu}_{M}^{\uparrow M\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}}\\
{\color{greenunder}\text{right identity law of }M:}\quad & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow k\triangleright f^{Z}=f\quad.
\end{align*}

To verify the associativity law, write its two sides separately; omit
all types for brevity:
\begin{align*}
 & (f\,\tilde{\diamond}\,g)\,\tilde{\diamond}\,h=l\rightarrow\big(l\triangleright h\triangleright(\gunderline{f\,\tilde{\diamond}\,g})\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow\big(\gunderline{l\triangleright h\triangleright(k}\rightarrow(k\triangleright g\triangleright f)\bef\text{ftn}_{M}^{\uparrow F})\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & \quad=l\rightarrow\big((l\triangleright h\triangleright g\triangleright f)\bef\text{ftn}_{M}^{\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow l\triangleright h\bef g\bef f\bef\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad,\\
 & f\,\tilde{\diamond}\,(g\,\tilde{\diamond}\,h)=l\rightarrow\big(l\triangleright(g\,\tilde{\diamond}\,h)\triangleright f\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow\big(l\triangleright(k\rightarrow(k\triangleright h\triangleright g)\bef\text{ftn}_{M}^{\uparrow F})\triangleright f\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & \quad=l\rightarrow\big(\big((l\triangleright h\triangleright g)\bef\gunderline{\text{ftn}_{M}^{\uparrow F}\big)\triangleright f}\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow l\triangleright h\triangleright g\triangleright f\bef\text{ftn}_{M}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad.
\end{align*}
In the last line, we have used the naturality law of $f$. The remaining
difference between the two sides is:
\[
\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\overset{?}{=}\text{ftn}_{M}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad,
\]
which follows from the associativity law of $\text{ftn}_{M}$.

\textbf{(b)} The \lstinline!flatMap! method must have the type signature:
\[
\text{flm}_{L}:\big((A\rightarrow X)\rightarrow M^{X}\big)\rightarrow(A\rightarrow(B\rightarrow X)\rightarrow M^{X})\rightarrow(B\rightarrow X)\rightarrow M^{X}\quad.
\]
Choose $M^{A}\triangleq\bbnum 1+A$; now we need to implement the
type signature:
\begin{align*}
 & \text{flm}_{L}:\big((A\rightarrow X)\rightarrow\bbnum 1+X\big)\rightarrow\left(A\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\right)\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\quad,\\
 & \text{flm}_{L}\triangleq p^{:(A\rightarrow X)\rightarrow\bbnum 1+X}\rightarrow q^{:\left(A\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\right)}\rightarrow r^{:B\rightarrow X}\rightarrow\text{???}^{:\bbnum 1+X}\quad.
\end{align*}
Can this function ever return a value of type $\bbnum 0+X$? When
we try filling out the typed hole $\text{???}^{:\bbnum 1+X}$, we
cannot apply the function $r$ since we have no available values of
type $B$. We could substitute $r$ into the second curried argument
of $q$, obtaining a function of type $A\rightarrow\bbnum 1+X$. But
we have no available values of type $A$. We also cannot apply the
function $p$ since its argument is of type $A\rightarrow X$, but
we only have $A\rightarrow\bbnum 1+X$, which is not guaranteed to
return nonempty values. So, the only way of implementing \lstinline!flatMap!
via fully parametric code is to return the constant value $1+\bbnum 0^{:X}$.
This would lose information and violate an identity law of monads.

\addsec{Chapter \ref{chap:Summary-of-the}}

\subsubsection*{Exercise \ref{par:Exercise-additional-1-9}}

\textbf{(a)} We will show in part \textbf{(b)} that \lstinline!leaf!
cannot be implemented fully parametrically for arbitrary functors
$F$. To be able to to implement \lstinline!leaf!, we have to impose
some additional requirements on $F$. It turns out to be sufficient
to assume that the functor $F$ has the form $F^{A}=C+A\times G^{A}$,
where $C$ is a fixed type and $G$ is another functor. Any polynomial
functor $F$ can be rewritten in that form.

We get $F^{\bbnum 0}\cong C$ and $F^{F^{\bbnum 0}}=F^{C}=C+C\times G^{C}$.
Then we define \lstinline!leaf! by:
\[
\text{leaf}_{F}:F^{C}\rightarrow C\quad,\quad\quad\text{leaf}_{F}\triangleq\,\begin{array}{|c||c|}
 & C\\
\hline C & \text{id}\\
C\times G^{C} & \pi_{1}
\end{array}\quad.
\]

It remains to show that $\text{absurd}^{\uparrow F}\bef\text{leaf}_{F}=\text{id}$.
We define the lifting to $F$:
\[
(f^{:A\rightarrow B})^{\uparrow F}=\,\begin{array}{|c||cc|}
 & C & B\times G^{B}\\
\hline C & \text{id} & \bbnum 0\\
A\times G^{A} & \bbnum 0 & f\boxtimes f^{\uparrow G}
\end{array}\quad.
\]
Then we write:
\begin{align*}
 & \text{absurd}^{\uparrow F}\bef\text{leaf}_{F}=\,\begin{array}{|c||cc|}
 & C & C\times G^{C}\\
\hline C & \text{id} & \bbnum 0\\
\bbnum 0\times G^{\bbnum 0} & \bbnum 0 & \text{absurd}\boxtimes\text{absurd}^{\uparrow G}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & C\\
\hline C & \text{id}\\
C\times G^{C} & \pi_{1}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & C\\
\hline C & \text{id}\\
\bbnum 0\times G^{\bbnum 0} & \pi_{1}\bef\text{absurd}^{:\bbnum 0\rightarrow C}
\end{array}\quad.
\end{align*}

When this function is applied to values of type $C+\bbnum 0\times G^{\bbnum 0}\cong C$
then only the first line in the code matrix will be used. That line
contains only the identity function ($\text{id}$). It follows that,
for any $z^{:C}$, we will have:
\[
z\triangleright\text{absurd}^{\uparrow F}\bef\text{leaf}=z\quad.
\]

\textbf{(b)} A counterexample is given by $F^{A}\triangleq(A\rightarrow\bbnum 0)\rightarrow A+S$,
where $S$ is an arbitrary fixed type about which nothing is known
except that $S$ is not void and not a unit type. 

We have $F^{\bbnum 0}=S$ and $F^{F^{\bbnum 0}}=(S\rightarrow\bbnum 0)\rightarrow S+S$.
Then we get:
\[
F^{F^{\bbnum 0}}\rightarrow F^{\bbnum 0}=((S\rightarrow\bbnum 0)\rightarrow S+S)\rightarrow S\quad.
\]
Can we implement a function $h$ of this type fully parametrically
in $S$? All such functions $h$ must satisfy the relational naturality
law corresponding to the type signature $F^{F^{\bbnum 0}}\rightarrow F^{\bbnum 0}$.
The law says that for any relation $r:S\leftrightarrow S$,
\[
\text{when}\quad(p^{:G^{S}},q^{:G^{S}})\in r^{\updownarrow G}\quad\text{then}\quad(h(p),h(q))\in r\quad,
\]
where we defined the type constructor $G$ as:
\[
G^{A}\triangleq(A\rightarrow\bbnum 0)\rightarrow A+A\quad.
\]
Lifting \emph{any} non-empty relation $r$ to $G$ gives a full relation
because we will then have $r\ogreaterthan\emptyset=\emptyset$ and
then:
\[
r^{\updownarrow S}=(r\ogreaterthan\emptyset)\ogreaterthan r\boxplus r=\emptyset\ogreaterthan r\boxplus r=\Omega\quad.
\]
 So, $r^{\updownarrow G}=\Omega$ as long as $r$ is non-empty. Choose
$r$ as the relation that holds only for specific values $s_{1}$
and $s_{2}$ (we assume that $s_{1}\neq s_{2}$):
\[
(x^{:S},y^{:S})\in r\quad\text{only if}\quad x=s_{1}\text{ and }y=s_{2}\quad.
\]
Then the relational naturality law of $h$ gives:
\begin{align*}
 & \text{when}\quad(p^{:G^{S}},q^{:G^{S}})\in r^{\updownarrow G}\quad\text{then}\quad(h(p),h(q))\in r\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & \text{for all }p^{:G^{S}},q^{:G^{S}}\quad:\quad h(p)=s_{1}\text{ and }h(q)=s_{2}\quad.
\end{align*}
This is a contradiction: $h$ must be a constant function that always
returns $s_{1}$, and at the same time $h$ must always return a different
value $s_{2}$. So, a fully parametric function $h$ cannot exist.

\subsubsection*{Exercise \ref{par:Exercise-additional-1-10}}

\subparagraph{Solution}

\textbf{(a)} A function of type $F^{\bbnum 0}\rightarrow T$ is impemented
as:
\[
\text{inT}:F^{\bbnum 0}\rightarrow T\quad,\quad\quad\text{inT}\,(z^{:F^{\bbnum 0}})\triangleq\forall A.\,g^{:F^{A}\rightarrow A}\rightarrow g(z\triangleright\text{absurd}^{\uparrow F})\quad.
\]
Here the function \lstinline!absurd! is used with type signature
$\bbnum 0\rightarrow A$.

\textbf{(b)} To implement \lstinline!outT!, we begin by writing:
\[
\text{outT}:T\rightarrow F^{\bbnum 0}\quad,\quad\quad\text{outT}\,(t^{:T})\triangleq t^{F^{\bbnum 0}}(h^{:F^{F^{\bbnum 0}}\rightarrow F^{\bbnum 0}})\quad,\quad\text{where }h=???\quad.
\]
To fill the typed hole ($h$), we need to provide a function of type
$F^{F^{\bbnum 0}}\rightarrow F^{\bbnum 0}$. Such a function is provided
by Exercise~\ref{par:Exercise-additional-1-9}(a) as $h=\text{leaf}_{F}$.
So, we define \lstinline!outT! by:
\[
\text{out}T\,(t^{:T})\triangleq t^{F^{\bbnum 0}}(\text{leaf}_{F})\quad.
\]

To show that $\text{inT}\bef\text{outT}=\text{id}$, we write:
\begin{align*}
{\color{greenunder}\text{expect to equal }z:}\quad & z^{:F^{\bbnum 0}}\triangleright\text{inT}\bef\text{outT}=\big(g\rightarrow g(z\triangleright\text{absurd}^{\uparrow F})\big)(\text{leaf}_{F})\\
 & =z\triangleright\text{absurd}^{\uparrow F}\bef\text{leaf}_{F}\quad.
\end{align*}
Here the function \lstinline!absurd! must be used with type signature
$\bbnum 0\rightarrow F^{\bbnum 0}$. With that type, we may use the
law $\text{absurd}^{\uparrow F}\bef\text{leaf}_{F}=\text{id}$ that
was proved in Exercise~\ref{par:Exercise-additional-1-9}(a). So,
we obtain:
\[
z^{:F^{\bbnum 0}}\triangleright\text{inT}\bef\text{outT}=z\triangleright\text{absurd}^{\uparrow F}\bef\text{leaf}_{F}=z\quad.
\]


\chapter{A humorous disclaimer}

\index{jokes}\emph{The following text is quoted in part from an anonymous
online source (\textsf{``}Project Guten Tag\textsf{''}) dating back at least to 1997.
The original text is no longer available on the Internet.}

\medskip{}

\noun{Warranto Limitensis; Disclamatantus Damagensis}

Solus exceptus \textsf{``}Rectum Replacator Refundiens\textsf{''} describitus ecci,
\begin{enumerate}
\item Projectus (etque nunquam partum quis hic etext remitibus cum \noun{Project
Guten Tag}$^{\text{TM}}$ identificator) disclamabat omni liabilitus
tuus damagensis, pecuniensisque, includibantus pecunia legalitus,
et 
\item \noun{Remedia Negligentitia Non Habet Tuus, Warrantus Destructi\-bus
Contractus Nullibus Ni Liabilitus Sumus, Inclutatibus Non Limitatus
Destructio Directibus, Consequentius, Punitio, O Incidentus, Non Sunt
Si Nos Notificat Vobis}. 
\end{enumerate}
Sit discubriatus defectus en etextum sic entram diariam noventam recibidio,
pecuniam tuum refundatorium receptorus posset, sic scribatis vendor.
Sit veniabat medium physicalis, vobis idem reternat et replacator
possit copius. Sit venitabat electronicabilis, sic viri datus chansus
segundibus. 

\noun{Hic Etext Venid \textsf{``}Como-asi\textsf{''}. Nihil Warranti Nunquam Classum,
Expressito Ni Implicato, Le Macchen Como Si Etexto Bene Sit O Il Medio
Bene Sit, Inclutat Et Non Limitat Warranti Mercatensis, Appropriatensis
Purposem. }

Statuen varias non permitatent disclamabaris ni warranti implicatoren
ni exclusioni limitatio damagaren consequentialis, ecco lo qua disclamatori
exclusato\-rique non vobis applicant, et potat optia alia legali.

\twocolumn

\chapter{GNU Free Documentation License\label{sec:GFDL} }

{\scriptsize{}Version 1.2, November 2002}{\scriptsize\par}

{\tiny{}Copyright (c) 2000,2001,2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA}{\tiny\par}

{\tiny{}Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.}{\tiny\par}

{\tiny{}\setcounter{subsection}{-1}}{\tiny\par}

\subsection*{{\tiny{}Preamble}}

{\tiny{}The purpose of this License is to make a manual, textbook,
or other functional and useful document free in the sense of freedom:
to assure everyone the effective freedom to copy and redistribute
it, with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a
way to get credit for their work, while not being considered responsible
for modifications made by others.}{\tiny\par}

{\tiny{}This License is a kind of \textquotedblleft copyleft\textsf{''}, which
means that derivative works of the document must themselves be free
in the same sense. It complements the GNU General Public License,
which is a copyleft license designed for free software.}{\tiny\par}

{\tiny{}We have designed this License in order to use it for manuals
for free software, because free software needs free documentation:
a free program should come with manuals providing the same freedoms
that the software does. But this License is not limited to software
manuals; it can be used for any textual work, regardless of subject
matter or whether it is published as a printed book. We recommend
this License principally for works whose purpose is instruction or
reference.}{\tiny\par}

\subsection{Applicability and definitions\label{subsec:1Applicability-and-definitions}}

{\tiny{}This License applies to any manual or other work, in any medium,
that contains a notice placed by the copyright holder saying it can
be distributed under the terms of this License. Such a notice grants
a world-wide, royalty-free license, unlimited in duration, to use
that work under the conditions stated herein. The \textquotedblleft Document\textsf{''},
below, refers to any such manual or work. Any member of the public
is a licensee, and is addressed as \textquotedblleft you\textsf{''}. You accept
the license if you copy, modify or distribute the work in a way requiring
permission under copyright law.}{\tiny\par}

{\tiny{}A \textquotedblleft Modified Version\textsf{''} of the Document means
any work containing the Document or a portion of it, either copied
verbatim, or with modifications and/or translated into another language.}{\tiny\par}

{\tiny{}A \textquotedblleft Secondary Section\textsf{''} is a named appendix
or a front-matter section of the Document that deals exclusively with
the relationship of the publishers or authors of the Document to the
Document\textsf{'}s overall subject (or to related matters) and contains nothing
that could fall directly within that overall subject. (Thus, if the
Document is in part a textbook of mathematics, a Secondary Section
may not explain any mathematics.) The relationship could be a matter
of historical connection with the subject or with related matters,
or of legal, commercial, philosophical, ethical or political position
regarding them.}{\tiny\par}

{\tiny{}The \textquotedblleft Invariant Sections\textsf{''} are certain Secondary
Sections whose titles are designated, as being those of Invariant
Sections, in the notice that says that the Document is released under
this License. If a section does not fit the above definition of Secondary
then it is not allowed to be designated as Invariant. The Document
may contain zero Invariant Sections. If the Document does not identify
any Invariant Sections then there are none.}{\tiny\par}

{\tiny{}The \textquotedblleft Cover Texts\textsf{''} are certain short passages
of text that are listed, as Front-Cover Texts or Back-Cover Texts,
in the notice that says that the Document is released under this License.
A Front-Cover Text may be at most 5 words, and a Back-Cover Text may
be at most 25 words.}{\tiny\par}

{\tiny{}A \textquotedblleft Transparent\textsf{''} copy of the Document means
a machine-readable copy, represented in a format whose specification
is available to the general public, that is suitable for revising
the document straightforwardly with generic text editors or (for images
composed of pixels) generic paint programs or (for drawings) some
widely available drawing editor, and that is suitable for input to
text formatters or for automatic translation to a variety of formats
suitable for input to text formatters. A copy made in an otherwise
Transparent file format whose markup, or absence of markup, has been
arranged to thwart or discourage subsequent modification by readers
is not Transparent. An image format is not Transparent if used for
any substantial amount of text. A copy that is not \textquotedblleft Transparent\textsf{''}
is called \textquotedblleft Opaque\textsf{''}.}{\tiny\par}

{\tiny{}Examples of suitable formats for Transparent copies include
plain ASCII without markup, Texinfo input format, \LaTeX{} input format,
SGML or XML using a publicly available DTD, and standard-conforming
simple HTML, PostScript or PDF designed for human modification. Examples
of transparent image formats include PNG, XCF and JPG. Opaque formats
include proprietary formats that can be read and edited only by proprietary
word processors, SGML or XML for which the DTD and/or processing tools
are not generally available, and the machine-generated HTML, PostScript
or PDF produced by some word processors for output purposes only.}{\tiny\par}

{\tiny{}The \textsf{``}Title Page\textsf{''} means, for a printed book, the title
page itself, plus such following pages as are needed to hold, legibly,
the material this License requires to appear in the title page. For
works in formats which do not have any title page as such, \textquotedblleft Title
Page\textquotedblright{} means the text near the most prominent appearance
of the work\textsf{'}s title, preceding the beginning of the body of the text.}{\tiny\par}

{\tiny{}A section \textsf{``}Entitled XYZ\textsf{''} means a named subunit of the
Document whose title either is precisely XYZ or contains XYZ in parentheses
following text that translates XYZ in another language. (Here XYZ
stands for a specific section name mentioned below, such as \textquotedblleft Acknowledgements\textquotedblright ,
\textquotedblleft Dedications\textquotedblright , \textquotedblleft Endorsements\textquotedblright ,
or \textquotedblleft History\textquotedblright .) To \textquotedblleft Preserve
the Title\textquotedblright{} of such a section when you modify the
Document means that it remains a section \textquotedblleft Entitled
XYZ\textquotedblright{} according to this definition.}{\tiny\par}

{\tiny{}The Document may include Warranty Disclaimers next to the
notice which states that this License applies to the Document. These
Warranty Disclaimers are considered to be included by reference in
this License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.}{\tiny\par}

\subsection{Verbatim copying\label{subsec:2Verbatim-copying}}

{\tiny{}You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the copyright
notices, and the license notice saying this License applies to the
Document are reproduced in all copies, and that you add no other conditions
whatsoever to those of this License. You may not use technical measures
to obstruct or control the reading or further copying of the copies
you make or distribute. However, you may accept compensation in exchange
for copies. If you distribute a large enough number of copies you
must also follow the conditions in section~\ref{subsec:3Copying-in-quantity}.}{\tiny\par}

{\tiny{}You may also lend copies, under the same conditions stated
above, and you may publicly display copies.}{\tiny\par}

\subsection{Copying in quantity\label{subsec:3Copying-in-quantity}}

{\tiny{}If you publish printed copies (or copies in media that commonly
have printed covers) of the Document, numbering more than 100, and
the Document\textsf{'}s license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts
on the back cover. Both covers must also clearly and legibly identify
you as the publisher of these copies. The front cover must present
the full title with all words of the title equally prominent and visible.
You may add other material on the covers in addition. Copying with
changes limited to the covers, as long as they preserve the title
of the Document and satisfy these conditions, can be treated as verbatim
copying in other respects.}{\tiny\par}

{\tiny{}If the required texts for either cover are too voluminous
to fit legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.}{\tiny\par}

{\tiny{}If you publish or distribute Opaque copies of the Document
numbering more than 100, you must either include a machine-readable
Transparent copy along with each Opaque copy, or state in or with
each Opaque copy a computer-network location from which the general
network-using public has access to download using public-standard
network protocols a complete Transparent copy of the Document, free
of added material. If you use the latter option, you must take reasonably
prudent steps, when you begin distribution of Opaque copies in quantity,
to ensure that this Transparent copy will remain thus accessible at
the stated location until at least one year after the last time you
distribute an Opaque copy (directly or through your agents or retailers)
of that edition to the public.}{\tiny\par}

{\tiny{}It is requested, but not required, that you contact the authors
of the Document well before redistributing any large number of copies,
to give them a chance to provide you with an updated version of the
Document.}{\tiny\par}

\subsection{Modifications\label{subsec:4Modifications}}

{\tiny{}You may copy and distribute a Modified Version of the Document
under the conditions of sections~\ref{subsec:2Verbatim-copying}
and \ref{subsec:3Copying-in-quantity} above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it. In addition, you must do these things in the Modified Version:}{\tiny\par}

{\tiny{}A. Use in the Title Page (and on the covers, if any) a title
distinct from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document). You may use the same title as a previous version
if the original publisher of that version gives permission.}{\tiny\par}

{\tiny{}B. List on the Title Page, as authors, one or more persons
or entities responsible for authorship of the modifications in the
Modified Version, together with at least five of the principal authors
of the Document (all of its principal authors, if it has fewer than
five), unless they release you from this requirement.}{\tiny\par}

{\tiny{}C. State on the Title page the name of the publisher of the
Modified Version, as the publisher.}{\tiny\par}

{\tiny{}D. Preserve all the copyright notices of the Document.}{\tiny\par}

{\tiny{}E. Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.}{\tiny\par}

{\tiny{}F. Include, immediately after the copyright notices, a license
notice giving the public permission to use the Modified Version under
the terms of this License, in the form shown in the Addendum below.}{\tiny\par}

{\tiny{}G. Preserve in that license notice the full lists of Invariant
Sections and required Cover Texts given in the Document\textsf{'}s license
notice.}{\tiny\par}

{\tiny{}H. Include an unaltered copy of this License.}{\tiny\par}

{\tiny{}I. Preserve the section Entitled \textsf{``}History\textsf{''}, Preserve its
Title, and add to it an item stating at least the title, year, new
authors, and publisher of the Modified Version as given on the Title
Page. If there is no section Entitled \textquotedblleft History\textquotedblright{}
in the Document, create one stating the title, year, authors, and
publisher of the Document as given on its Title Page, then add an
item describing the Modified Version as stated in the previous sentence.}{\tiny\par}

{\tiny{}J. Preserve the network location, if any, given in the Document
for public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on. These may be placed in the \textsf{``}History\textsf{''} section.
You may omit a network location for a work that was published at least
four years before the Document itself, or if the original publisher
of the version it refers to gives permission.}{\tiny\par}

{\tiny{}K. For any section Entitled \textsf{``}Acknowledgements\textsf{''} or \textsf{``}Dedications\textsf{''},
Preserve the Title of the section, and preserve in the section all
the substance and tone of each of the contributor acknowledgements
and/or dedications given therein.}{\tiny\par}

{\tiny{}L. Preserve all the Invariant Sections of the Document, unaltered
in their text and in their titles. Section numbers or the equivalent
are not considered part of the section titles.}{\tiny\par}

{\tiny{}M. Delete any section Entitled \textsf{``}Endorsements\textsf{''}. Such a
section may not be included in the Modified Version.}{\tiny\par}

{\tiny{}N. Do not retitle any existing section to be Entitled \textsf{``}Endorsements\textsf{''}
or to conflict in title with any Invariant Section.}{\tiny\par}

{\tiny{}O. Preserve any Warranty Disclaimers.}{\tiny\par}

{\tiny{}If the Modified Version includes new front-matter sections
or appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or
all of these sections as invariant. To do this, add their titles to
the list of Invariant Sections in the Modified Version\textsf{'}s license notice.
These titles must be distinct from any other section titles.}{\tiny\par}

{\tiny{}You may add a section Entitled \textsf{``}Endorsements\textsf{''}, provided
it contains nothing but endorsements of your Modified Version by various
parties \textemdash{} for example, statements of peer review or that
the text has been approved by an organization as the authoritative
definition of a standard.}{\tiny\par}

{\tiny{}You may add a passage of up to five words as a Front-Cover
Text, and a passage of up to 25 words as a Back-Cover Text, to the
end of the list of Cover Texts in the Modified Version. Only one passage
of Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity. If the Document already
includes a cover text for the same cover, previously added by you
or by arrangement made by the same entity you are acting on behalf
of, you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.}{\tiny\par}

{\tiny{}The author(s) and publisher(s) of the Document do not by this
License give permission to use their names for publicity for or to
assert or imply endorsement of any Modified Version.}{\tiny\par}

\subsection*{{\tiny{}Combining documents}}

{\tiny{}You may combine the Document with other documents released
under this License, under the terms defined in section 4 above for
modified versions, provided that you include in the combination all
of the Invariant Sections of all of the original documents, unmodified,
and list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.}{\tiny\par}

{\tiny{}The combined work need only contain one copy of this License,
and multiple identical Invariant Sections may be replaced with a single
copy. If there are multiple Invariant Sections with the same name
but different contents, make the title of each such section unique
by adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of Invariant
Sections in the license notice of the combined work.}{\tiny\par}

{\tiny{}In the combination, you must combine any sections Entitled
\textquotedblleft History\textquotedblright{} in the various original
documents, forming one section Entitled \textquotedblleft History\textquotedblright ;
likewise combine any sections Entitled \textquotedblleft Acknowledgements\textquotedblright ,
and any sections Entitled \textquotedblleft Dedications\textquotedblright .
You must delete all sections Entitled \textquotedblleft Endorsements.\textquotedblright{}}{\tiny\par}

\subsection*{{\tiny{}Collections of documents}}

{\tiny{}You may make a collection consisting of the Document and other
documents released under this License, and replace the individual
copies of this License in the various documents with a single copy
that is included in the collection, provided that you follow the rules
of this License for verbatim copying of each of the documents in all
other respects.}{\tiny\par}

{\tiny{}You may extract a single document from such a collection,
and distribute it individually under this License, provided you insert
a copy of this License into the extracted document, and follow this
License in all other respects regarding verbatim copying of that document.}{\tiny\par}

\subsection*{{\tiny{}Aggregation with independent works}}

{\tiny{}A compilation of the Document or its derivatives with other
separate and independent documents or works, in or on a volume of
a storage or distribution medium, is called an \textquotedblleft aggregate\textquotedblright{}
if the copyright resulting from the compilation is not used to limit
the legal rights of the compilation\textsf{'}s users beyond what the individual
works permit. When the Document is included an aggregate, this License
does not apply to the other works in the aggregate which are not themselves
derivative works of the Document.}{\tiny\par}

{\tiny{}If the Cover Text requirement of section~\ref{subsec:3Copying-in-quantity}
is applicable to these copies of the Document, then if the Document
is less than one half of the entire aggregate, the Document\textsf{'}s Cover
Texts may be placed on covers that bracket the Document within the
aggregate, or the electronic equivalent of covers if the Document
is in electronic form. Otherwise they must appear on printed covers
that bracket the whole aggregate.}{\tiny\par}

\subsection*{{\tiny{}Translation}}

{\tiny{}Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section~\ref{subsec:4Modifications}.
Replacing Invariant Sections with translations requires special permission
from their copyright holders, but you may include translations of
some or all Invariant Sections in addition to the original versions
of these Invariant Sections. You may include a translation of this
License, and all the license notices in the Document, and any Warranty
Disclaimers, provided that you also include the original English version
of this License and the original versions of those notices and disclaimers.
In case of a disagreement between the translation and the original
version of this License or a notice or disclaimer, the original version
will prevail.}{\tiny\par}

{\tiny{}If a section in the Document is Entitled \textquotedblleft Acknowledgements\textquotedblright ,
\textquotedblleft Dedications\textquotedblright , or \textquotedblleft History\textquotedblright ,
the requirement (section~\ref{subsec:4Modifications}) to Preserve
its Title (section~\ref{subsec:1Applicability-and-definitions})
will typically require changing the actual title.}{\tiny\par}

\subsection*{{\tiny{}Termination}}

{\tiny{}You may not copy, modify, sublicense, or distribute the Document
except as expressly provided for under this License. Any other attempt
to copy, modify, sublicense or distribute the Document is void, and
will automatically terminate your rights under this License. However,
parties who have received copies, or rights, from you under this License
will not have their licenses terminated so long as such parties remain
in full compliance.}{\tiny\par}

\subsection*{{\tiny{}Future revisions of this license}}

{\tiny{}The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns. See \url{http://www.gnu.org/copyleft/}.}{\tiny\par}

{\tiny{}Each version of the License is given a distinguishing version
number. If the Document specifies that a particular numbered version
of this License \textquotedblleft or any later version\textquotedblright{}
applies to it, you have the option of following the terms and conditions
either of that specified version or of any later version that has
been published (not as a draft) by the Free Software Foundation. If
the Document does not specify a version number of this License, you
may choose any version ever published (not as a draft) by the Free
Software Foundation.}{\tiny\par}

\subsection*{\noun{\tiny{}Addendum}{\tiny{}: How to use this License for your
documents}}

{\tiny{}To use this License in a document you have written, include
a copy of the License in the document and put the following copyright
and license notices just after the title page:}{\tiny\par}

{\tiny{}Copyright (c) <year> <your name>. Permission is granted to
copy, distribute and/or modify this document under the terms of the
GNU Free Documentation License, Version 1.2 or any later version published
by the Free Software Foundation; with no Invariant Sections, no Front-Cover
Texts, and no Back-Cover Texts. A copy of the license is included
in the section entitled \textquotedblleft GNU Free Documentation License\textquotedblright .}{\tiny\par}

{\tiny{}If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the \textquotedblleft with...Texts.\textquotedblright{}
line with this:}{\tiny\par}

{\tiny{}with the Invariant Sections being <list their titles>, with
the Front-Cover Texts being <list>, and with the Back-Cover Texts
being <list>.}{\tiny\par}

{\tiny{}If you have Invariant Sections without Cover Texts, or some
other combination of the three, merge those two alternatives to suit
the situation.}{\tiny\par}

{\tiny{}If your document contains nontrivial examples of program code,
we recommend releasing these examples in parallel under your choice
of free software license, such as the GNU General Public License,
to permit their use in free software.}{\tiny\par}

\subsection*{{\tiny{}Copyright }}

{\tiny{}Copyright (c) 2000, 2001, 2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA}{\tiny\par}

{\tiny{}Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.}{\tiny\par}
