%% LyX 2.3.6.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amstext}
\usepackage{graphicx}
\usepackage[all]{xy}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}
\newenvironment{lyxcode}
  {\par\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \setlength{\listparindent}{0pt}% needed for AMS classes
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \normalfont\ttfamily}%
   \def\{{\char`\{}
   \def\}{\char`\}}
   \def\textasciitilde{\char`\~}
   \item[]}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Relational parametricity proofs]{Proving "theorems for free" via relational parametricity}
\subtitle{A tutorial using the syntax of Scala code}
\author{Sergei Winitzki}
\date{2023-01-01}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\usepackage[nocenter]{qtree}
\usepackage{relsize}
\renewcommand\arraystretch{1.4}

\makeatother

\usepackage{listings}
\lstset{language=Scala,
morekeywords={{scala}},
otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},
keywordstyle={\color{scalakeyword}},
morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},
keywordstyle={[2]{\color{scalatype}}},
frame=tb,
aboveskip={1.5mm},
belowskip={0.5mm},
showstringspaces=false,
columns=fullflexible,
keepspaces=true,
basicstyle={\smaller\ttfamily},
extendedchars=true,
numbers=none,
numberstyle={\tiny\color{gray}},
commentstyle={\color{dkgreen}},
stringstyle={\color{mauve}},
frame=single,
framerule={0.0mm},
breaklines=true,
breakatwhitespace=true,
tabsize=3,
framexleftmargin={0.5mm},
framexrightmargin={0.5mm},
xleftmargin={1.5mm},
xrightmargin={1.5mm},
framextopmargin={0.5mm},
framexbottommargin={0.5mm},
fillcolor={\color{aqua}},
rulecolor={\color{aqua}},
rulesepcolor={\color{aqua}},
backgroundcolor={\color{aqua}},
mathescape=false,
extendedchars=true}
\renewcommand{\lstlistingname}{Listing}

\begin{document}
\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%
\frame{\titlepage}
\begin{frame}{Outline of the tutorial}
\begin{itemize}
\item Motivation: practical applications of the parametricity theorem
\item What is ``fully parametric code''
\item Naturality laws and their uses
\begin{itemize}
\item Example: Covariant and contravariant Yoneda identities
\end{itemize}
\item A complete proof of ``theorems for free'' in 6 steps
\begin{itemize}
\item Step 1: Deriving \texttt{\textcolor{blue}{\small{}fmap}} and \texttt{\textcolor{blue}{\small{}cmap}}
methods from types
\item Step 2: Motivation for the relational approach to naturality laws
\item Step 3: Definition and examples of relations
\item Step 4: Definition and properties of the relational lifting (\texttt{\textcolor{blue}{\small{}rmap}})
\item Step 5: Proof of the relational naturality law
\item Step 6: Deriving the wedge law from the relational naturality law
\end{itemize}
\item Advanced applications of the parametricity theorem: beyond Yoneda
\begin{itemize}
\item Church encodings of recursive types
\item Simplifying universally quantified types where Yoneda fails
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Applications of parametricity. ``Theorems for free''}

\textbf{Parametricity theorem}: any fully parametric function obeys
a certain law

Some applications:

Naturality laws for code that works in the same way for all types
\begin{lyxcode}
\textcolor{blue}{\small{}def~headOption{[}A{]}:~List{[}A{]}~=>~Option{[}A{]}~=~\{}{\small\par}

\textcolor{blue}{\small{}~~case~Nil~~~~~~~~~~~~=>~None}{\small\par}

\textcolor{blue}{\small{}~~case~head~::~tail~~~=>~Some(head)}{\small\par}

\textcolor{blue}{\small{}\}}{\small\par}
\end{lyxcode}
\begin{itemize}
\item Naturality law for \texttt{\textcolor{blue}{\small{}headOption}}:
for all \texttt{\textcolor{blue}{\small{}x:~List{[}A{]}}} and \texttt{\textcolor{blue}{\small{}f:~A
=> B}},
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\small{}x.headOption.map(f)~==~x.map(f).headOption}{\small\par}
\end{lyxcode}
Uniqueness properties for fully parametric functions
\begin{itemize}
\item The \texttt{\textcolor{blue}{\small{}map}} and \texttt{\textcolor{blue}{\small{}contramap}}
methods uniquely follow from types
\item There is only one function \texttt{\textcolor{blue}{\small{}f}} with
type signature \texttt{\textcolor{blue}{\small{}f{[}A{]}: A => (A,
A)}}{\small\par}
\end{itemize}
Type equivalence for universally quantified types
\begin{itemize}
\item The type of functions \texttt{\textcolor{blue}{\small{}pure{[}A{]}: A
=> F{[}A{]}}} is equivalent to \texttt{\textcolor{blue}{\small{}F{[}Unit{]}}}{\small\par}
\begin{itemize}
\item In Scala 3, this type is written as \texttt{\textcolor{blue}{\small{}{[}A{]}
=> A => F{[}A{]}}}{\small\par}
\end{itemize}
\item The type \texttt{\textcolor{blue}{\small{}{[}A{]} => (A, (K, A) =>
A) => A}} is equivalent to \texttt{\textcolor{blue}{\small{}List{[}K{]}}}{\small\par}
\item The type \texttt{\textcolor{blue}{\small{}{[}A{]} => ((A => K) =>
A) => A}} is equivalent to \texttt{\textcolor{blue}{\small{}K}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Requirements for parametricity. Fully parametric code}

Parametricity theorem works only if the code is ``fully parametric''
\begin{itemize}
\item \textbf{``Fully parametric''} code: use only type parameters and
\texttt{\textcolor{blue}{\small{}Unit}}, no run-time type reflection,
no external libraries or built-in types
\begin{itemize}
\item For instance, no \texttt{\textcolor{blue}{\small{}IO}}-like monads
\end{itemize}
\item ``Fully parametric'' is a stronger restriction than ``purely functional''
\end{itemize}
Parametricity theorem applies only to a subset of a programming language
\begin{itemize}
\item Usually, it is a certain flavor of typed lambda calculus
\end{itemize}
\end{frame}

\begin{frame}{Examples of code that is not fully parametric}

Explicit matching on type parameters using type reflection:
\begin{lyxcode}
\textcolor{blue}{\small{}def~badHeadOpt{[}A{]}:~List{[}A{]}~=>~Option{[}A{]}~=~\{}{\small\par}

\textcolor{blue}{\small{}~~case~Nil~~~~~~~~~~~~~~~~~=>~None}{\small\par}

\textcolor{blue}{\small{}~~case~(head:~Int)~::~tail~=>~None~//~Run-time~type~match!}{\small\par}

\textcolor{blue}{\small{}~~case~head~::~tail~~~~~~~~=>~Some(head)}{\small\par}

\textcolor{blue}{\small{}\}}{\small\par}
\end{lyxcode}
Using typeclasses: define a typeclass \textcolor{blue}{\small{}NotInt{[}A{]}}
with the method \textcolor{blue}{\small{}notInt{[}A{]}} that returns
\textcolor{blue}{\small{}true} unless \textcolor{blue}{\small{}A =
Int} 
\begin{lyxcode}
\textcolor{blue}{\small{}def~badHeadOpt{[}A:~NotInt{]}:~List{[}A{]}~=>~Option{[}A{]}~=~\{}{\small\par}

\textcolor{blue}{\small{}~~case~h~::~tail~if~notInt{[}A{]}~~~=>~Some(h)}{\small\par}

\textcolor{blue}{\small{}~~case~\_~=>~None}{\small\par}

\textcolor{blue}{\small{}\}}{\small\par}
\end{lyxcode}
Failure of naturality law:
\begin{lyxcode}
\textcolor{blue}{\small{}scala>~badHeadOpt(List(10,~20,~30).map(x~=>~s\textquotedbl x~=~\$x\textquotedbl ))}{\small\par}

\textcolor{blue}{\small{}res0:~Option{[}String{]}~=~Some(x~=~10)}{\small\par}

~

\textcolor{blue}{\small{}scala>~badHeadOpt(List(10,~20,~30)).map(x~=>~s\textquotedbl x~=~\$x\textquotedbl )}{\small\par}

\textcolor{blue}{\small{}res1:~Option{[}String{]}~=~None}{\small\par}
\end{lyxcode}
\end{frame}
\vspace{1\baselineskip}
~

Fully parametric programs are written using the 9 code constructions:
\begin{lstlisting}
def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = { // 3
   case Nil            => Nil
//   8   1                1,7 
   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
//   8       6             2 4     6  5 2 4     6    7   9
}           // This code uses each of the nine allowed constructions.
\end{lstlisting}
\vspace{-0.2\baselineskip}

\begin{enumerate}
\item Use \lstinline!Unit! value (or equivalent type), e.g.~\lstinline!()!,
\lstinline!Nil!, \lstinline!None!
\item Use bound variable (a given argument of the function)
\item Create a function: \lstinline!{ x => expr(x) }!
\item Use a function: \lstinline!f(x)!
\item Create a product: \lstinline!(a, b)!
\item Use a product: \lstinline!p._1! (or via pattern matching)
\item Create a co-product: \lstinline!Left[A, B](x)!
\item Use a co-product: \lstinline!{ case ... => ... }! (pattern matching)
\item Use a recursive call: e.g., \lstinline!fmap(f)(tail)! within the
code of \lstinline!fmap!\medskip{}
\end{enumerate}

\begin{frame}{Naturality laws require \texttt{map}}

Naturality law: applying \texttt{\textcolor{blue}{\small{}t{[}A{]}:~F{[}A{]}
=> G{[}A{]}}} \emph{before} \texttt{\textcolor{blue}{\small{}\_.map(f)}}
equals applying \texttt{\textcolor{blue}{\small{}t{[}B{]}:~F{[}B{]}
=> G{[}B{]}}} \emph{after} \texttt{\textcolor{blue}{\small{}\_.map(f)}}
for any function \texttt{\textcolor{blue}{\small{}f:~A => B}}{\small\par}

\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar[d]\sb(0.5){~\mathtt{\_.map(f)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar[d]\sp(0.5){\mathtt{\_.map(f)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\begin{itemize}
\item Example: \texttt{\textcolor{blue}{\small{}F = List}}, \texttt{\textcolor{blue}{\small{}G
= Option}}, \texttt{\textcolor{blue}{\small{}t = headOption}}\\
The naturality law of \texttt{\textcolor{blue}{\small{}headOption}}:
for all \texttt{\textcolor{blue}{\small{}x:~List{[}A{]}}} and \texttt{\textcolor{blue}{\small{}f:~A
=> B}},\\
 \texttt{\textcolor{blue}{\small{}x.headOption.map(f) = x.map(f).headOption}}{\small\par}
\end{itemize}
Naturality laws are formulated using \texttt{\textcolor{blue}{\small{}\_.map}}
for \texttt{\textcolor{blue}{\small{}F}} and \texttt{\textcolor{blue}{\small{}G}}{\small\par}

What is the code of \texttt{\textcolor{blue}{\small{}map}} for a given
\texttt{\textcolor{blue}{\small{}F{[}\_{]}}}?
\begin{itemize}
\item Equivalently, the code of \texttt{\textcolor{blue}{\small{}fmap{[}A,
B{]}:~(A => B) => F{[}A{]} => F{[}B{]}}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Using naturality laws: the Yoneda identities}

For covariant \texttt{\textcolor{blue}{\small{}F{[}A{]}}}, the type
\texttt{\textcolor{blue}{\small{}F{[}R{]}}} is equivalent to the type
of functions \texttt{\textcolor{blue}{\small{}p{[}A{]}:~(R => A)
=> F{[}A{]}}} satisfying the naturality law:

\texttt{\textcolor{blue}{\small{}p{[}A{]}(k).map(f) == p{[}B{]}(k
andThen f)}} for all \texttt{\textcolor{blue}{\small{}f:~A => B}}{\small\par}

Isomorphism maps:

\texttt{\textcolor{blue}{\small{}inY{[}A{]}:~F{[}R{]} => (R => A)
=> F{[}A{]} = fr => k => fr.map{[}A{]}(k)}}{\small\par}

\texttt{\textcolor{blue}{\small{}outY:~({[}A{]} => (R => A) => F{[}A{]})
=> F{[}R{]} = p => p{[}R{]}(identity{[}R{]})}}{\small\par}

Proofs of isomorphism:

\texttt{\textcolor{blue}{\small{}outY(inY(fr)) == outY(k => fr.map(k))
== fr.map(identity) == fr}}{\small\par}

The other direction:

\texttt{\textcolor{blue}{\small{}inY(outY(p)) == k => outY(p).map(k)
== k => p(identity).map(k)}}{\small\par}

Use the naturality law: \texttt{\textcolor{blue}{\small{}p(identity).map(k)
== p(identity andThen k)}}{\small\par}

So: \texttt{\textcolor{blue}{\small{}inY(outY(p)) == k => p(k) ==
p}}{\small\par}
\begin{itemize}
\item The naturality law and the code of \texttt{\textcolor{blue}{\small{}inY}}
must use \emph{the same} \texttt{\textcolor{blue}{\small{}\_.map}}{\small\par}
\end{itemize}
For contravariant \texttt{\textcolor{blue}{\small{}G{[}A{]}}}, the
type \texttt{\textcolor{blue}{\small{}G{[}R{]}}} is equivalent to
the type of functions \texttt{\textcolor{blue}{\small{}q{[}A{]}:~(A
=> R) => G{[}A{]}}} satisfying the appropriate naturality law
\end{frame}

\begin{frame}{Example applications of the Yoneda identities}

Many types can be converted to the form \texttt{\textcolor{blue}{\small{}{[}A{]}
=> (R => A) => F{[}A{]}}} with a covariant \texttt{\textcolor{blue}{\small{}F}}
or to \texttt{\textcolor{blue}{\small{}{[}A{]} => (A => R) => G{[}A{]}}}
with a contravariant \texttt{\textcolor{blue}{\small{}G}}{\small\par}

Some examples (assume covariant \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}
and contravariant \texttt{\textcolor{blue}{\small{}G{[}\_{]}}}):
\begin{itemize}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => A}} is equivalent to \texttt{\textcolor{blue}{\small{}Nothing}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => F{[}A{]}}} is equivalent
to \texttt{\textcolor{blue}{\small{}F{[}Nothing{]}}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => G{[}A{]}}} is equivalent
to \texttt{\textcolor{blue}{\small{}G{[}Unit{]}}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => A => A}} is equivalent
to \texttt{\textcolor{blue}{\small{}Unit}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => A => F{[}A{]}}} is equivalent
to \texttt{\textcolor{blue}{\small{}F{[}Unit{]}}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => (A, A) => A}} is equivalent
to \texttt{\textcolor{blue}{\small{}Boolean}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => (A, A) => F{[}A{]}}} is
equivalent to \texttt{\textcolor{blue}{\small{}F{[}Boolean{]}}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => (P => A) => Q => A}} is
equivalent to \texttt{\textcolor{blue}{\small{}Q => P}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => (A => P) => A => Q}} is
equivalent to \texttt{\textcolor{blue}{\small{}P => Q}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}{[}A{]} => F{[}A{]} => (A => P) =>
Q}} is equivalent to \texttt{\textcolor{blue}{\small{}F{[}P{]} =>
Q}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}flatMap}} is equivalent to \texttt{\textcolor{blue}{\small{}flatten}}:
(use Yoneda w.r.t.~\texttt{\textcolor{blue}{\small{}A}})\texttt{\textcolor{blue}{\small{}}}~\\
\texttt{\textcolor{blue}{\small{}def flatMap{[}A, B{]}: F{[}A{]} =>
(A => F{[}B{]}) => F{[}B{]}}}~\\
\texttt{\textcolor{blue}{\small{}def flatten{[}B{]}: F{[}F{[}B{]}{]}
=> F{[}B{]}}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Fully parametric type constructors}

What is the \texttt{\textcolor{blue}{\small{}fmap}} function for a
given type constructor \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}?
\begin{itemize}
\item If the code of \texttt{\textcolor{blue}{\small{}t{[}A{]}:~F{[}A{]}
=> G{[}A{]}}} is fully parametric, then there are only a few ways
to build the type constructors \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}
and \texttt{\textcolor{blue}{\small{}G{[}\_{]}}}{\small\par}
\item Such ``fully parametric'' type constructors \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}
are built as: 
\begin{enumerate}
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = Unit}} or \texttt{\textcolor{blue}{\small{}F{[}A{]}
= B}} where \texttt{\textcolor{blue}{\small{}B}} is another type parameter
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = A}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = (G{[}A{]}, H{[}A{]})}}
--- product types
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = Either{[}G{[}A{]}, H{[}A{]}{]}}}
--- co-product types
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}A{]} => H{[}A{]}}}
--- function types
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}F{[}A{]}, A{]}}} ---
recursive types
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = {[}X{]} => G{[}A, X{]}}}
--- universally quantified types
\end{enumerate}
The recursive type construction (\texttt{\textcolor{blue}{\small{}Fix}})
can be defined as:\\
\texttt{\textcolor{blue}{\small{}case class Fix{[}G{[}\_, \_{]}, A{]}(unfix:~G{[}Fix{[}G{[}\_,
\_{]}, A{]}, A{]})}}{\small\par}

\texttt{\textcolor{blue}{\small{}F{[}A{]} = Fix{[}G, A{]}}} satisfies
the type equation \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}F{[}A{]},
A{]}}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Deriving \texttt{fmap} from types}

\begin{itemize}
\item \vspace{-0.25\baselineskip}
What is the \texttt{\textcolor{blue}{\small{}fmap}} function for a
covariant type constructor \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}?\\
\texttt{\textcolor{blue}{\small{}fmap\_F{[}A, B{]}:~(A => B) => F{[}A{]}
=> F{[}B{]}}}{\small\par}
\begin{enumerate}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = Unit}} or \texttt{\textcolor{blue}{\small{}F{[}A{]}
= B}} then \texttt{\textcolor{blue}{\small{}fmap\_F(f) = identity}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = A}} then \texttt{\textcolor{blue}{\small{}fmap\_F(f)
= f}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = (G{[}A{]}, H{[}A{]})}}
then we need \texttt{\textcolor{blue}{\small{}fmap\_G}} and \texttt{\textcolor{blue}{\small{}fmap\_H}}\\
\texttt{\textcolor{blue}{\small{}fmap\_F(f) = \{ case (ga, ha) =>
(fmap\_G(f)(ga), fmap\_H(f)(ha)) \}}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = Either{[}G{[}A{]},
H{[}A{]}{]}}} then \texttt{\textcolor{blue}{\small{}fmap\_F(f) = \{}}~\\
\texttt{\textcolor{blue}{\small{}~~case Left(ga)~ => Left(fmap\_G(f)(ga))}}~\\
\texttt{\textcolor{blue}{\small{}~~case Right(ha) => Right(fmap\_H(f)(ha))}}~\\
\texttt{\textcolor{blue}{\small{}\}}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}A{]} => H{[}A{]}}}
then we need \texttt{\textcolor{blue}{\small{}cmap\_G}} and \texttt{\textcolor{blue}{\small{}fmap\_H}}~\\
\texttt{\textcolor{blue}{\small{}cmap\_G{[}A, B{]}:~(A => B) => G{[}B{]}
=> G{[}A{]}}}~\\
We define \texttt{\textcolor{blue}{\small{}fmap\_F(f)(p:~G{[}A{]}
=> H{[}A{]}) =}}~\\
\texttt{\textcolor{blue}{\small{} cmap\_G(f) andThen p andThen fmap\_H(f)}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}F{[}A{]}, A{]}}}
then we need \texttt{\textcolor{blue}{\small{}fmap\_G1}} and \texttt{\textcolor{blue}{\small{}fmap\_G2}}~\\
\texttt{\textcolor{blue}{\small{}fmap\_F(f) = fmap\_G1(fmap\_F(f))
andThen fmap\_G2(f)}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = {[}X{]} => G{[}A, X{]}}}
then we need \texttt{\textcolor{blue}{\small{}fmap\_G1}}\\
\texttt{\textcolor{blue}{\small{}fmap\_F(f) = p => {[}X{]} => fmap\_G1(f)(p{[}X{]}))}} 
\end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Deriving \texttt{cmap} from types}

\begin{itemize}
\item \vspace{-0.25\baselineskip}
When \texttt{\textcolor{blue}{\small{}F{[}\_{]}}} is contravariant,
we need the \texttt{\textcolor{blue}{\small{}cmap}} function\\
\texttt{\textcolor{blue}{\small{}cmap\_G{[}A, B{]}:~(A => B) => G{[}B{]}
=> G{[}A{]}}}{\small\par}
\item Use structural induction on the type of \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}:
\begin{enumerate}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = Unit}} or \texttt{\textcolor{blue}{\small{}F{[}A{]}
= B}} then \texttt{\textcolor{blue}{\small{}cmap\_F(f) = identity}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = A}} then \texttt{\textcolor{blue}{\small{}F}}
is \emph{not} contravariant!
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = (G{[}A{]}, H{[}A{]})}}
then we need \texttt{\textcolor{blue}{\small{}cmap\_G}} and \texttt{\textcolor{blue}{\small{}cmap\_H}}\\
\texttt{\textcolor{blue}{\small{}cmap\_F(f) = \{ case (gb, hb) =>
(cmap\_G(f)(gb), cmap\_H(f)(hb)) \}}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = Either{[}G{[}A{]},
H{[}A{]}{]}}} then \texttt{\textcolor{blue}{\small{}cmap\_F(f) = \{}}~\\
\texttt{\textcolor{blue}{\small{}~~case Left(gb)~ => Left(cmap\_G(f)(gb))}}~\\
\texttt{\textcolor{blue}{\small{}~~case Right(hb) => Right(cmap\_H(f)(hb))}}~\\
\texttt{\textcolor{blue}{\small{}\}}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}A{]} => H{[}A{]}}}
then we need \texttt{\textcolor{blue}{\small{}fmap\_G}} and \texttt{\textcolor{blue}{\small{}cmap\_H}}~\\
We define \texttt{\textcolor{blue}{\small{}cmap\_F(f)(k:~G{[}B{]}
=> H{[}B{]}) =}}~\\
\texttt{\textcolor{blue}{\small{} fmap\_G(f) andThen k andThen cmap\_H(f)}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}F{[}A{]}, A{]}}}
then we need \texttt{\textcolor{blue}{\small{}fmap\_G1}} and \texttt{\textcolor{blue}{\small{}cmap\_G2}}~\\
\texttt{\textcolor{blue}{\small{}cmap\_F(f) = fmap\_G1(cmap\_F(f))
andThen cmap\_G2(f)}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]} = {[}X{]} => G{[}A, X{]}}}
then we need \texttt{\textcolor{blue}{\small{}cmap\_G1}}\\
\texttt{\textcolor{blue}{\small{}cmap\_F(f) = k => {[}X{]} => cmap\_G1(f)(k{[}X{]}))}} 
\end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Detect covariance and contravariance from types}

\begin{itemize}
\item The same constructions for \texttt{\textcolor{blue}{\small{}fmap}}
and \texttt{\textcolor{blue}{\small{}cmap}} except for function types
\item The function arrow (\texttt{\textcolor{blue}{\small{}=>}}) swaps covariant
and contravariant positions
\item In any fully parametric type expression, each type parameter is either
in a covariant position or in a contravariant position
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\small{}type~F{[}A,~B{]}~=~(A~=>~Either{[}A,~B{]},~A~=>~(B~=>~A)~=>~(A,~B))}{\small\par}

\textcolor{blue}{\small{}~~~~~~~~~~~~~~~~-~~~~~~~~~~~+~~+~~~-~~~~~+~~~~-~~~~~~+~~+}{\small\par}
\end{lyxcode}
\begin{itemize}
\item \texttt{\textcolor{blue}{\small{}F{[}A, B{]}}} is covariant w.r.t.~\texttt{\textcolor{blue}{\small{}B}}
since \texttt{\textcolor{blue}{\small{}B}} is always in covariant
positions
\begin{itemize}
\item But \texttt{\textcolor{blue}{\small{}F{[}A, B{]}}} is neither covariant
nor contravariant w.r.t.~\texttt{\textcolor{blue}{\small{}A}}{\small\par}
\item We can recognize co(ntra)variance by counting nested function arrows
\end{itemize}
\item Defined in this way, co(ntra)variance is independent of subtyping
\item We can generate the code for \texttt{\textcolor{blue}{\small{}fmap}}
or \texttt{\textcolor{blue}{\small{}cmap}} mechanically, from types
\item A type expression \texttt{\textcolor{blue}{\small{}F{[}A, B, ...{]}}}
can be analyzed with respect to each of the type parameters separately,
and found to be covariant, contravariant, or neither (``invariant'') 
\item We can write the naturality law for any type signature \texttt{\textcolor{blue}{\small{}F{[}A{]}
=> G{[}A{]}}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. ``Invariant'' type constructors. Profunctors}

For ``invariant'' types, we use a trick: rename contravariant positions
\begin{itemize}
\item Example: \texttt{\textcolor{blue}{\small{}type F{[}A{]} = Either{[}A
=> (A, A), (A, A) => A{]}}}{\small\par}
\item Define \texttt{\textcolor{blue}{\small{}type P{[}X, A{]} = Either{[}X
=> (A, A), (X, X) => A{]}}}{\small\par}
\item Then \texttt{\textcolor{blue}{\small{}F{[}A{]} = P{[}A, A{]}}} while
\texttt{\textcolor{blue}{\small{}P{[}X, A{]}}} is contravariant in
\texttt{\textcolor{blue}{\small{}X}} and covariant in \texttt{\textcolor{blue}{\small{}A}}.
Such \texttt{\textcolor{blue}{\small{}P{[}X, A{]}}} are called \textbf{profunctors}
\item We can implement \texttt{\textcolor{blue}{\small{}cmap}} with respect
to \texttt{\textcolor{blue}{\small{}X}} and \texttt{\textcolor{blue}{\small{}fmap}}
with respect to \texttt{\textcolor{blue}{\small{}A}}{\small\par}
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\small{}def~fmapP{[}X,~A,~B{]}:~(A~=>~B)~=>~P{[}X,~A{]}~=>~P{[}X,~B{]}}{\small\par}

\textcolor{blue}{\small{}def~cmapP{[}X,~Y,~A{]}:~(X~=>~Y)~=>~P{[}Y,~A{]}~=>~P{[}X,~A{]}}{\small\par}
\end{lyxcode}
\begin{itemize}
\item Then we can compose \texttt{\textcolor{blue}{\small{}cmapP}} and \texttt{\textcolor{blue}{\small{}fmapP}}
to get \texttt{\textcolor{blue}{\small{}xmapF}}:

\texttt{\textcolor{blue}{\small{}def xmapF{[}A, B{]}: (A => B, B =>
A) => P{[}A, A{]} => P{[}B, B{]} =}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ (f, g) => cmapP{[}A, B, A{]}(g)
andThen fmapP{[}B, A, B{]}(f)}}{\small\par}
\item What if we compose in another order? A commutativity law holds:
\end{itemize}
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{P[A,A]}\ar[d]\sb(0.5){~\mathtt{fmapP(f)}}\ar[r]\sp(0.5){\mathtt{~\mathtt{cmapP(g)}}}\ar[rd]\sp(0.5){\mathtt{~\mathtt{xmapF(f,g)}}} & \mathtt{P[B,A]}\ar[d]\sp(0.5){\mathtt{~\mathtt{fmapP(f)}}}\\
\mathtt{P[A,B]}\ar[r]\sp(0.5){~\mathtt{cmapP(g)}} & \mathtt{P[B,B]}
}
\]

\end{frame}

\begin{frame}{Step 1. Verifying the functor laws}

\texttt{\textcolor{blue}{\small{}fmap}} and \texttt{\textcolor{blue}{\small{}cmap}}
need to satisfy two functor laws
\begin{itemize}
\item Identity law:\\
 \texttt{\textcolor{blue}{\small{}fmap(identity) = identity}}\\
 \texttt{\textcolor{blue}{\small{}cmap(identity) = identity}}{\small\par}
\item Composition law: for any \texttt{\textcolor{blue}{\small{}f:~A =>
B}} and \texttt{\textcolor{blue}{\small{}g:~B => C}},\\
 \texttt{\textcolor{blue}{\small{}fmap(f) andThen fmap(g) = fmap(f
andThen g)}}~\\
 \texttt{\textcolor{blue}{\small{}cmap(g) andThen cmap(f) = cmap(f
andThen g)}}{\small\par}
\item Go through each case and prove that the laws hold
\begin{itemize}
\item Proofs by induction on the type structure
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Functor laws: composition law for tuples}

\begin{itemize}
\item \vspace{-0.25\baselineskip}
We will prove the composition law for \texttt{\textcolor{blue}{\small{}fmap}}
in case 3
\end{itemize}
\texttt{\textcolor{blue}{\small{}fmap\_F(f) = \{ case (ga, ha) =>
(fmap\_G(f)(ga), fmap\_H(f)(ha)) \}}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}

For any \texttt{\textcolor{blue}{\small{}f:~A => B}} and \texttt{\textcolor{blue}{\small{}g:~B
=> C}} and values \texttt{\textcolor{blue}{\small{}ga:~G{[}A{]},
ha:~H{[}A{]}}}:
\begin{itemize}
\item Apply \texttt{\textcolor{blue}{\small{}fmap\_F(f) andThen fmap\_F(g)}}
to the tuple \texttt{\textcolor{blue}{\small{}(ga, ha)}}:
\end{itemize}
\texttt{\textcolor{blue}{\small{}fmap\_F(f)((ga, ha)) == ( fmap\_G(f)(ga),
fmap\_H(f)(ha) )}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}

\texttt{\textcolor{blue}{\small{}fmap\_F(g)((fmap\_G(f)(ga), fmap\_H(f)(ha)))}}{\small\par}

\texttt{\textcolor{blue}{\small{}== (fmap\_G(g)(fmap\_G(f)(ga)), fmap\_H(g)(fmap\_H(f)(ha)))}}{\small\par}

\texttt{\textcolor{blue}{\small{}== ( (fmap\_G(f) andThen fmap\_G(g))(ga),
(fmap\_H(f) andThen fmap\_H(f))(ha) )}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}
\begin{itemize}
\item Apply \texttt{\textcolor{blue}{\small{}fmap\_F(f andThen g)}} to the
tuple \texttt{\textcolor{blue}{\small{}(ga, ha)}}:
\end{itemize}
\texttt{\textcolor{blue}{\small{}fmap\_F(f andThen g)((ga, ha)) ==
( fmap\_G(f andThen g)(ga), fmap\_H(f andThen g)(ha) )}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}
\begin{itemize}
\item The law holds for \texttt{\textcolor{blue}{\small{}fmap\_F}} if it
already holds for \texttt{\textcolor{blue}{\small{}fmap\_G}} and \texttt{\textcolor{blue}{\small{}fmap\_H}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Functor laws: composition law for function types}

\begin{itemize}
\item We will prove the composition law for \texttt{\textcolor{blue}{\small{}cmap}}
in case 5
\end{itemize}
\texttt{\textcolor{blue}{\small{}cmap\_F(f)(k) == fmap\_G(f) andThen
k andThen cmap\_H(f)}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}

For any \texttt{\textcolor{blue}{\small{}f:~A => B}} and \texttt{\textcolor{blue}{\small{}g:~B
=> C}} and \texttt{\textcolor{blue}{\small{}kc:~G{[}C{]} => H{[}C{]}}}:\\
~

Apply \texttt{\textcolor{blue}{\small{}cmap\_F(g) andThen cmap\_F(f)}}
to \texttt{\textcolor{blue}{\small{}kc}}:

\texttt{\textcolor{blue}{\small{}cmap\_F(g)(kc) == fmap\_G(g) andThen
kc andThen cmap\_H(g) }}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}

\texttt{\textcolor{blue}{\small{}cmap\_F(f)(fmap\_G(g) andThen kc
andThen cmap\_H(g))}}{\small\par}

\texttt{\textcolor{blue}{\small{}== fmap\_G(f) andThen fmap\_G(g)
andThen kc andThen cmap\_H(g) andThen cmap\_H(f)}}{\small\par}

\texttt{\textcolor{blue}{\small{}== fmap\_G(f andThen g) andThen kc
andThen cmap\_H(f andThen g)}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}

This is the same as \texttt{\textcolor{blue}{\small{}cmap\_F(f andThen
g)(kc)}}by inductive assumption\texttt{\textcolor{blue}{\small{}}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}
\begin{itemize}
\item The law holds for \texttt{\textcolor{blue}{\small{}cmap\_F}} if it
already holds for \texttt{\textcolor{blue}{\small{}fmap\_G}} and \texttt{\textcolor{blue}{\small{}cmap\_H}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Functor laws: composition law for recursive types}

\begin{itemize}
\item We will prove the composition law for \texttt{\textcolor{blue}{\small{}fmap}}
in case 6
\end{itemize}
\texttt{\textcolor{blue}{\small{}fmap\_F(f) = fmap\_G1(fmap\_F(f))
andThen fmap\_G2(f)}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}

For any \texttt{\textcolor{blue}{\small{}f:~A => B}} and \texttt{\textcolor{blue}{\small{}g:~B
=> C}}:\\
~

LHS: \texttt{\textcolor{blue}{\small{}fmap\_F(f) andThen fmap\_F(g)
== fmap\_G1(fmap\_F(f)) andThen fmap\_G2(f) andThen fmap\_G1(fmap\_F(g))
andThen fmap\_G2(g)}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}

RHS: \texttt{\textcolor{blue}{\small{}fmap\_F(f andThen g) == fmap\_G1(fmap\_F(f
andThen g)) andThen fmap\_G2(f andThen g) == fmap\_G1(fmap\_F(f) andThen
fmap\_F(g)) andThen fmap\_G2(f) andThen fmap\_G2(g) == fmap\_G1(fmap\_F(f))
andThen fmap\_G1(fmap\_F(g)) andThen fmap\_G2(f) andThen fmap\_G2(g)}}~\\
\texttt{\textcolor{blue}{\small{}~}}{\small\par}
\begin{itemize}
\item LHS equals RHS if the commutativity law holds for \texttt{\textcolor{blue}{\small{}G}}{\small\par}
\item The law holds for \texttt{\textcolor{blue}{\small{}fmap\_F}} if the
composition laws and the commutativity law already hold for \texttt{\textcolor{blue}{\small{}fmap\_G1}}
and \texttt{\textcolor{blue}{\small{}fmap\_G2}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 1. Summary}

\begin{itemize}
\item \texttt{\textcolor{blue}{\small{}fmap}} or \texttt{\textcolor{blue}{\small{}cmap}}
or \texttt{\textcolor{blue}{\small{}xmap}} follow from a given type
expression \texttt{\textcolor{blue}{\small{}F{[}A{]}}}{\small\par}
\item The code of \texttt{\textcolor{blue}{\small{}fmap}}, \texttt{\textcolor{blue}{\small{}cmap}},
\texttt{\textcolor{blue}{\small{}xmap}} is always fully parametric
and lawful
\begin{itemize}
\item That is the ``standard'' code used by all naturality laws
\end{itemize}
\item Consistency of the definition of \texttt{\textcolor{blue}{\small{}xmap}}
requires a commutativity law
\item Functor laws for recursive types require a commutativity law
\begin{itemize}
\item Those commutativity laws are naturality laws and will be proved later
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Step 2. Motivation for relational parametricity. I. Papers}

Parametricity theorem: any fully parametric function satisfies a certain
law

``Relational parametricity'' is a powerful method for proving the
parametricity theorem and for using it to prove other laws
\begin{itemize}
\item Main papers: \href{https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf}{Reynolds (1983)}
and Wadler \href{https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf}{\textquotedblleft Theorems for free\textquotedblright}
(1989)
\begin{itemize}
\item Those papers are limited in scope and hard to understand
\end{itemize}
\item There are \emph{few} pedagogical tutorials on relational parametricity
\begin{itemize}
\item ``\href{https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions}{On a relation of functions}''
by R.~Backhouse (1990) 
\item ``\href{https://themattchan.com/docs/algprog.pdf}{The algebra of programming}''
by R.~Bird and O.~de Moor (1997)
\item Parametricity tutorial \href{https://www.well-typed.com/blog/2015/05/parametricity/}{part 1},
\href{https://www.well-typed.com/blog/2015/08/parametricity-part2/}{part 2},
\href{https://www.well-typed.com/blog/preview/parametricity-contravariant/}{part 3}
by E.~de Vries (2015)
\end{itemize}
\item Here I derive the main results \emph{not} following any of the above
\item I will only explain the minimum necessary knowledge and notation
\end{itemize}
\end{frame}

\begin{frame}{Step 2. Motivating relational parametricity. II. The difficulty}

Naturality laws are formulated via liftings (\texttt{\textcolor{blue}{\small{}fmap}},
\texttt{\textcolor{blue}{\small{}cmap}}), for example:
\begin{lyxcode}
\textcolor{blue}{\small{}fmap(f)~andThen~t~==~t~andThen~fmap(f)}{\small\par}
\end{lyxcode}
Cannot lift \texttt{\textcolor{blue}{\small{}f:~A => B}} to \texttt{\textcolor{blue}{\small{}F{[}A{]}
=> F{[}B{]}}} when \texttt{\textcolor{blue}{\small{}F{[}\_{]}}} is
not covariant!
\begin{itemize}
\item For covariant \texttt{\textcolor{blue}{\small{}F{[}\_{]}}} we lift
\texttt{\textcolor{blue}{\small{}f:~A => B}} to \texttt{\textcolor{blue}{\small{}fmap(f):~F{[}A{]}
=> F{[}B{]}}} 
\item For contravariant \texttt{\textcolor{blue}{\small{}F{[}\_{]}}} we
lift \texttt{\textcolor{blue}{\small{}f:~A => B}} to \texttt{\textcolor{blue}{\small{}cmap(f):~F{[}B{]}
=> F{[}A{]}}} 
\end{itemize}
In general, \texttt{\textcolor{blue}{\small{}F{[}\_{]}}} will be neither
covariant nor contravariant
\begin{itemize}
\item Example: \texttt{\textcolor{blue}{\small{}foldLeft}} with respect
to type parameter \texttt{\textcolor{blue}{\small{}A}} 
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\small{}def~foldLeft{[}T,~A{]}:~List{[}T{]}~=>~(T~=>~A~=>~A)~=>~A~=>~A}{\small\par}
\end{lyxcode}
\begin{itemize}
\item This is \emph{not} of the form \texttt{\textcolor{blue}{\small{}F{[}A{]}
=> G{[}A{]}}} with \texttt{\textcolor{blue}{\small{}F{[}\_{]}}} and
\texttt{\textcolor{blue}{\small{}G{[}\_{]}}} being both covariant
or both contravariant
\begin{itemize}
\item Because some occurrences of \texttt{\textcolor{blue}{\small{}A}} are
in covariant and contravariant positions together in function arguments,
e.g., \texttt{\textcolor{blue}{\small{}(T => A => A) =>...}}{\small\par}
\end{itemize}
\item What law (similar to a naturality law) does \texttt{\textcolor{blue}{\small{}foldLeft}}
obey with respect to the type parameter \texttt{\textcolor{blue}{\small{}A}}?
\item We need to formulate a more general naturality law that applies to
all type constructors \texttt{\textcolor{blue}{\small{}F{[}A{]}}},
not necessarily covariant nor contravariant
\end{itemize}
\end{frame}

\begin{frame}{Step 2. Motivating relational parametricity. III. The solution}

The difficulty is resolved using three nontrivial ideas:
\begin{enumerate}
\item Generalize functions \texttt{\textcolor{blue}{\small{}f:~A => B}}
to binary relations \texttt{\textcolor{blue}{\small{}r:~A <=> B}} 
\begin{itemize}
\item The\textbf{ graph} relation: \texttt{\textcolor{blue}{\small{}(a,
b) in graph(f)}} means \texttt{\textcolor{blue}{\small{}f(a) == b}}{\small\par}
\item Relations are more general than functions, can be many-to-many
\item Instead of \texttt{\textcolor{blue}{\small{}f(a) == b}}, we will write
\texttt{\textcolor{blue}{\small{}(a, b) in r}}{\small\par}
\end{itemize}
\item It is \emph{always} possible to lift \texttt{\textcolor{blue}{\small{}r:~A
<=> B}} to \texttt{\textcolor{blue}{\small{}rmap(r):~F{[}A{]} <=>
F{[}B{]}}}{\small\par}
\item Reformulate the naturality law of \texttt{\textcolor{blue}{\small{}t}}
via relations: for any \texttt{\textcolor{blue}{\small{}r:~A <=>
B}},
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar@{<->}[d]\sb(0.5){~\mathtt{rmap(r)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar@{<->}[d]\sp(0.5){\mathtt{rmap(r)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]
To read the diagram: the starting values are on the left\\
For any \texttt{\textcolor{blue}{\small{}r:~A <=> B}}, for any \texttt{\textcolor{blue}{\small{}fa:~F{[}A{]}}}
and \texttt{\textcolor{blue}{\small{}fb:~F{[}B{]}}} such that\\
\texttt{\textcolor{blue}{\small{}(fa, fb) in rmap\_F(r)}}, we require
\texttt{\textcolor{blue}{\small{}(t(fa), t(fb)) in rmap\_G(r)}} 
\end{enumerate}
The relational naturality law will reduce to the ordinary naturality
laws when \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}, \texttt{\textcolor{blue}{\small{}G{[}\_{]}}}
are both co(ntra)variant and \texttt{\textcolor{blue}{\small{}r =
graph(f)}} for any \texttt{\textcolor{blue}{\small{}f:~A => B}}{\small\par}
\end{frame}

\begin{frame}{Step 2. Formulating naturality laws via relations}

\vspace{-0.25\baselineskip}
Ordinary naturality law of \texttt{\textcolor{blue}{\small{}t{[}A{]}:~F{[}A{]}
=> G{[}A{]}}}
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar[d]\sb(0.5){~\mathtt{fmap\_F(f)}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar[d]\sp(0.5){\mathtt{fmap\_G(f)}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]
$\forall$ \texttt{\textcolor{blue}{\small{}fa:~F{[}A{]}}}, \texttt{\textcolor{blue}{\small{}fb:~F{[}B{]}}}
if \texttt{\textcolor{blue}{\small{}fa.map(f) == fb}} then \texttt{\textcolor{blue}{\small{}t(fa).map(f)
== t(fb)}}{\small\par}

Rewrite this via relations: For all \texttt{\textcolor{blue}{\small{}fa:~F{[}A{]}}},
\texttt{\textcolor{blue}{\small{}fb:~F{[}B{]}}}, when \texttt{\textcolor{blue}{\small{}(fa,
fb) in graph(fmap\_F(f))}} then \texttt{\textcolor{blue}{\small{}(t(fa),
t(fb)) in graph(fmap\_G(f))}}{\small\par}

We expect: \texttt{\textcolor{blue}{\small{}graph(fmap(f)) == rmap(graph(f))}},
replace \texttt{\textcolor{blue}{\small{}graph(f)}} by \texttt{\textcolor{blue}{\small{}r}}:

when \texttt{\textcolor{blue}{\small{}(fa, fb) in rmap\_F(graph(f))}}
then \texttt{\textcolor{blue}{\small{}(t(fa), t(fb)) in rmap\_G(graph(f))}}{\small\par}

when \texttt{\textcolor{blue}{\small{}(fa, fb) in rmap\_F(r)}} then
\texttt{\textcolor{blue}{\small{}(t(fa), t(fb)) in rmap\_G(r)}}
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar@{<->}[d]\sb(0.5){~\mathtt{rmap\_F(r)}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar@{<->}[d]\sp(0.5){\mathtt{rmap\_G(r)}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end{frame}

\begin{frame}{Step 3. Definition of relations. Examples}

In the terminology of relational databases: 
\begin{itemize}
\item A relation \texttt{\textcolor{blue}{\small{}r:~A <=> B}} is a table
with 2 columns (\texttt{\textcolor{blue}{\small{}A}} and \texttt{\textcolor{blue}{\small{}B}})
\item A row \texttt{\textcolor{blue}{\small{}(a:~A, b:~B)}} means that
the value \texttt{\textcolor{blue}{\small{}a}} is related to the value
\texttt{\textcolor{blue}{\small{}b}} 
\end{itemize}
Mathematically speaking: a relation \texttt{\textcolor{blue}{\small{}r:~A
<=> B}} is a subset $r\subset A\times B$ 
\begin{itemize}
\item We write \texttt{\textcolor{blue}{\small{}(a, b) in r}} to mean $a\times b\in r$
where $a\in A$ and $b\in B$
\end{itemize}
Relations can be many-to-many while functions \texttt{\textcolor{blue}{\small{}A
=> B}} are many-to-one

A function \texttt{\textcolor{blue}{\small{}f:~A => B}} generates
the\textbf{ graph} relation \texttt{\textcolor{blue}{\small{}graph(f):~A
<=> B}}{\small\par}
\begin{itemize}
\item Two values \texttt{\textcolor{blue}{\small{}a:~A}}, \texttt{\textcolor{blue}{\small{}b:~B}}
are in \texttt{\textcolor{blue}{\small{}graph(f)}} if \texttt{\textcolor{blue}{\small{}f(a)
== b}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}graph(identity:~A => A)}} gives
an \textbf{identity} \textbf{relation} \texttt{\textcolor{blue}{\small{}id:~A
<=> A}} 
\end{itemize}
Example of a relation that can be many-to-many: given any \texttt{\textcolor{blue}{\small{}f:~A
=> C}} and \texttt{\textcolor{blue}{\small{}g:~B => C}}, define the
\textbf{pullback relation}: \texttt{\textcolor{blue}{\small{}pull(f,
g):~A <=> B}};\texttt{\textcolor{blue}{\small{}}}~\\
\texttt{\textcolor{blue}{\small{}~ ~(a:~A, b:~B) in pull(f, g)
}}means\texttt{\textcolor{blue}{\small{} f(a) == g(b)}}{\small\par}
\begin{itemize}
\item The pullback relation is \emph{not} the graph of a function \texttt{\textcolor{blue}{\small{}A
=> B}} or \texttt{\textcolor{blue}{\small{}B => A}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 3. Relational combinators: \texttt{pprod}, \texttt{psum}, \texttt{pfun},
\texttt{rev}}

Given two relations \texttt{\textcolor{blue}{\small{}r:~A <=> B}}
and \texttt{\textcolor{blue}{\small{}s:~X <=> Y}}, we define new
relations:
\begin{itemize}
\item Pair product: \texttt{\textcolor{blue}{\small{}pprod(r, s)}} of type
\texttt{\textcolor{blue}{\small{}(A, X) <=> (B, Y)}}{\small\par}
\end{itemize}
\texttt{\textcolor{blue}{\small{}((a, x), (b, y)) in pprod(r, s)}}
means \texttt{\textcolor{blue}{\small{}(a, b) in r}} and \texttt{\textcolor{blue}{\small{}(x,
y) in s}}{\small\par}
\begin{itemize}
\item Pair co-product: \texttt{\textcolor{blue}{\small{}psum(r, s)}} of
type \texttt{\textcolor{blue}{\small{}Either{[}A, X{]} <=> Either{[}B,
Y{]}}}{\small\par}
\end{itemize}
\texttt{\textcolor{blue}{\small{}(Left(a), Left(b)) in psum(r, s)}}
if \texttt{\textcolor{blue}{\small{}(a, b) in r}}{\small\par}

\texttt{\textcolor{blue}{\small{}(Right(x), Right(y)) in psum(r, s)}}
if \texttt{\textcolor{blue}{\small{}(x, y) in s}}{\small\par}
\begin{itemize}
\item Pair function mapper: \texttt{\textcolor{blue}{\small{}pfun(r, s)}}
of type \texttt{\textcolor{blue}{\small{}(A => X) <=> (B => Y)}}{\small\par}
\end{itemize}
\texttt{\textcolor{blue}{\small{}(f, g) in pfun(r, s)}} means when
\texttt{\textcolor{blue}{\small{}(a, b) in r}} then \texttt{\textcolor{blue}{\small{}(f(a),
g(b)) in s}}
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.5pc}\mathtt{A}\ar@{<->}[d]\sb(0.5){~\mathtt{r}}\ar[rr]\sp(0.5){\mathtt{f}} & \ar@{<->}[d]\sb(0.5){\mathtt{pfun(r,~s)}} & \mathtt{X}\ar@{<->}[d]\sp(0.5){\mathtt{s}}\\
\mathtt{B}\ar[rr]\sb(0.5){\mathtt{g}} &  & \mathtt{Y}
}
\]

\begin{itemize}
\item Reverse: \texttt{\textcolor{blue}{\small{}rev(r)}} has type \texttt{\textcolor{blue}{\small{}B
<=> A}}{\small\par}
\end{itemize}
\texttt{\textcolor{blue}{\small{}(b, a) in rev(r)}} means the same
as \texttt{\textcolor{blue}{\small{}(a, b) in r}}{\small\par}
\end{frame}

\begin{frame}{Step 4. The relational lifting (\texttt{rmap})}

For a type constructor \texttt{\textcolor{blue}{\small{}F}} and \texttt{\textcolor{blue}{\small{}r:~A
<=> B}}, need \texttt{\textcolor{blue}{\small{}rmap\_F(r):~F{[}A{]}
<=> F{[}B{]}}}{\small\par}

Define \texttt{\textcolor{blue}{\small{}rmap\_F}} for \texttt{\textcolor{blue}{\small{}F{[}A{]}}}
by induction on the \emph{type expression} of \texttt{\textcolor{blue}{\small{}F{[}A{]}}} 

A fully parametric type \texttt{\textcolor{blue}{\small{}F{[}A{]}}}
must be built up via these seven cases:
\begin{enumerate}
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = Unit}} or \texttt{\textcolor{blue}{\small{}F{[}A{]}
= K}} (a fixed type): \texttt{\textcolor{blue}{\small{}rmap\_F(r)
= id}} 
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = A}}: define \texttt{\textcolor{blue}{\small{}rmap\_F(r)
= r}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = (G{[}A{]}, H{[}A{]})}}:
\texttt{\textcolor{blue}{\small{}rmap\_F(r) = pprod(rmap\_G(r), rmap\_H(r))}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = Either{[}G{[}A{]}, H{[}A{]}{]}}}:\\
 \texttt{\textcolor{blue}{\small{}rmap\_F(r) = psum(rmap\_G(r), rmap\_H(r))}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}A{]} => H{[}A{]}}}:
\texttt{\textcolor{blue}{\small{}rmap\_F(r) = pfun(rmap\_G(r), rmap\_H(r))}}{\small\par}
\item Recursive type: \texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}A,
F{[}A{]}{]}}}:\\
 \texttt{\textcolor{blue}{\small{}rmap\_F(r) = rmap2\_G(r, rmap\_F(r))}}
-- recursive definition of \texttt{\textcolor{blue}{\small{}rmap\_F}}{\small\par}
\item Universally quantified type: \texttt{\textcolor{blue}{\small{}F{[}A{]}
= {[}X{]} => G{[}A, X{]}}}:\\
 \texttt{\textcolor{blue}{\small{}rmap\_F(r) = $\forall$(X, Y). $\forall$(s:~X
<=> Y). rmap2\_G(r, s)}}{\small\par}
\end{enumerate}
\begin{itemize}
\item The inductive assumption is that liftings to \texttt{\textcolor{blue}{\small{}G}}
and \texttt{\textcolor{blue}{\small{}H}} are already defined
\item \texttt{\textcolor{blue}{\small{}rmap\_F}} translates the type expression
\texttt{\textcolor{blue}{\small{}F{[}A{]}}} into relational combinators
\end{itemize}
We will define \texttt{\textcolor{blue}{\small{}rmap2}} in a similar
way
\end{frame}

\begin{frame}{Step 4. Simultaneous relational lifting (\texttt{rmap2})}

\vspace{-0.35\baselineskip}
For a type constructor \texttt{\textcolor{blue}{\small{}F{[}\_, \_{]}}}
and \texttt{\textcolor{blue}{\small{}r:~A <=> B}}, \texttt{\textcolor{blue}{\small{}s:~P
<=> Q}}, we define \texttt{\textcolor{blue}{\small{}rmap2\_F(r, s):~F{[}A,
P{]} <=> F{[}B, Q{]} }}by induction on the type \texttt{\textcolor{blue}{\small{}F{[}A,
P{]}}}{\small\par}
\begin{enumerate}
\item \texttt{\textcolor{blue}{\small{}F{[}A, P{]} = K}} (a fixed type):
\texttt{\textcolor{blue}{\small{}rmap2\_F(r, s) = id}} 
\item If \texttt{\textcolor{blue}{\small{}F{[}A, P{]} = A}} then \texttt{\textcolor{blue}{\small{}rmap2\_F(r,
s) = r}}\\
If \texttt{\textcolor{blue}{\small{}F{[}A, P{]} = P}} then \texttt{\textcolor{blue}{\small{}rmap2\_F(r,
s) = s }}{\small\par}
\item \texttt{\textcolor{blue}{\small{}F{[}A, P{]} = (G{[}A, P{]}, H{[}A,
P{]})}}:\\
 \texttt{\textcolor{blue}{\small{}rmap2\_F(r, s) = pprod(rmap2\_G(r,
s), rmap2\_H(r, s))}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}F{[}A, P{]} = Either{[}G{[}A, P{]},
H{[}A, P{]}{]}}}:\\
 \texttt{\textcolor{blue}{\small{}rmap2\_F(r, s) = psum(rmap2\_G(r,
s), rmap2\_H(r, s))}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}F{[}A, P{]} = G{[}A, P{]} => H{[}A,
P{]}}}:\\
 \texttt{\textcolor{blue}{\small{}rmap2\_F(r, s) = pfun(rmap2\_G(r,
s), rmap2\_H(r, s))}}{\small\par}
\item Recursive type: \texttt{\textcolor{blue}{\small{}F{[}A, P{]} = G{[}A,
P, F{[}A, P{]}{]}}}:\\
 \texttt{\textcolor{blue}{\small{}rmap2\_F(r, s) = rmap3\_G(r, s,
rmap2\_F(r, s))}}{\small\par}
\item Universally quantified type: \texttt{\textcolor{blue}{\small{}F{[}A,
P{]} = {[}X{]} => G{[}A, P, X{]}}}:\\
 \texttt{\textcolor{blue}{\small{}rmap2\_F(r, s) = $\forall$(X, Y). $\forall$(t:~X
<=> Y). rmap3\_G(r, s, t)}}{\small\par}
\end{enumerate}
\begin{itemize}
\item The inductive assumption is that liftings to \texttt{\textcolor{blue}{\small{}G}}
and \texttt{\textcolor{blue}{\small{}H}} are already defined
\end{itemize}
Actually, we need to define \texttt{\textcolor{blue}{\small{}rmap}},
\texttt{\textcolor{blue}{\small{}rmap2}}, \texttt{\textcolor{blue}{\small{}rmap3}},
\texttt{\textcolor{blue}{\small{}rmap4}}, ..., all at once

This is not a problem: \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}
is finitely long, so the induction will stop
\end{frame}

\begin{frame}{Step 4. Example: \texttt{rmap} for a covariant type constructor}

Consider \texttt{\textcolor{blue}{\small{}P{[}A{]} = R => (A, A)}}
where \texttt{\textcolor{blue}{\small{}R}} is a fixed type

Compare \texttt{\textcolor{blue}{\small{}fmap\_P}} and \texttt{\textcolor{blue}{\small{}rmap\_P}}
defined via the inductive definitions

Case 5: \texttt{\textcolor{blue}{\small{}P{[}A{]} = G{[}A{]} => H{[}A{]}}}
with \texttt{\textcolor{blue}{\small{}G{[}A{]} = R}} (case 1), \texttt{\textcolor{blue}{\small{}H{[}A{]}
= (A, A)}}{\small\par}

Case 3: \texttt{\textcolor{blue}{\small{}H{[}A{]} = (K{[}A{]}, L{[}A{]})}}
with \texttt{\textcolor{blue}{\small{}K{[}A{]} = A}}, \texttt{\textcolor{blue}{\small{}L{[}A{]}
= A}} (case 2)

For \texttt{\textcolor{blue}{\small{}fmap\_P}}:

\texttt{\textcolor{blue}{\small{}fmap\_P(f)(p) = cmap\_G(f) andThen
p andThen fmap\_H(f)}}{\small\par}

\texttt{\textcolor{blue}{\small{}fmap\_H(f) = \{ case (k, l) => (fmap\_K(f)(k),
fmap\_L(f)(l)) \}}}{\small\par}

\texttt{\textcolor{blue}{\small{}cmap\_G(f) = identity}}; \texttt{\textcolor{blue}{\small{}fmap\_K(f)
= f}}; \texttt{\textcolor{blue}{\small{}fmap\_L(f) = f}}{\small\par}

\texttt{\textcolor{blue}{\small{}fmap\_P(f)(p) = p andThen \{ case
(k, l) => (f(k), f(l)) \}}}{\small\par}

For \texttt{\textcolor{blue}{\small{}rmap\_P}}:

\texttt{\textcolor{blue}{\small{}rmap\_P(r) = pmap(rmap\_G(r), rmap\_H(r))
= pmap(id, rmap\_H(r))}}{\small\par}

\texttt{\textcolor{blue}{\small{}~= pmap(id, pprod(rmap\_K(r), rmap\_L(r)))
= pmap(id, pprod(r, r))}}{\small\par}

Two values \texttt{\textcolor{blue}{\small{}(p:~P{[}A{]}}}, \texttt{\textcolor{blue}{\small{}q:~P{[}B{]})}}
are in \texttt{\textcolor{blue}{\small{}rmapP\_(r)}} if for \texttt{\textcolor{blue}{\small{}$\forall$}}
\texttt{\textcolor{blue}{\small{}x:~R}}, \texttt{\textcolor{blue}{\small{}y:~R}},
when \texttt{\textcolor{blue}{\small{}(x, y) in id}} then \texttt{\textcolor{blue}{\small{}(p(x),
q(x)) in pprod(r, r)}} or equivalently:

for any \texttt{\textcolor{blue}{\small{}x:~R}}, \texttt{\textcolor{blue}{\small{}(p(x).\_1,
q(x).\_1) in r}} and \texttt{\textcolor{blue}{\small{}(p(x).\_2, q(x).\_2)
in r}}{\small\par}

Choose \texttt{\textcolor{blue}{\small{}r = graph(f)}} and get for
any \texttt{\textcolor{blue}{\small{}x:~R}}: \texttt{\textcolor{blue}{\small{}f(p(x).\_1)
== q(x).\_1}} and \texttt{\textcolor{blue}{\small{}f(p(x).\_2) ==
q(x).\_2}}{\small\par}

This is the same as \texttt{\textcolor{blue}{\small{}q == fmap\_P(f)(p)}}
or \texttt{\textcolor{blue}{\small{}(p, q) in graph(fmap\_P(f))}}{\small\par}
\end{frame}

\begin{frame}{Step 4. Example: \texttt{rmap} for function types}

Compare \texttt{\textcolor{blue}{\small{}fmap}} and \texttt{\textcolor{blue}{\small{}rmap}}
for function types: (\texttt{\textcolor{blue}{\small{}F{[}A{]} = G{[}A{]}
=> H{[}A{]}}})

To rewrite \texttt{\textcolor{blue}{\small{}fmap\_F}} via relations,
introduce intermediate arguments

Choose any values \texttt{\textcolor{blue}{\small{}p:~G{[}A{]} =>
H{[}A{]}}} and \texttt{\textcolor{blue}{\small{}f:~A => B}}{\small\par}

Define \texttt{\textcolor{blue}{\small{}q = fmap\_F(f)(p) = (gb:~G{[}B{]})
=> fmap\_H(f)(p(cmap\_G(f)(gb))}}{\small\par}

Rewrite this via relations: \texttt{\textcolor{blue}{\small{}(p, q)
in graph(fmap\_F(f))}} means:\\
for all \texttt{\textcolor{blue}{\small{}gb:~G{[}B{]}}} we must have
\texttt{\textcolor{blue}{\small{}q(gb) = fmap\_H(f)(p(cmap\_G(f)(gb))}}{\small\par}

Define \texttt{\textcolor{blue}{\small{}ga:~G{[}A{]} = cmap\_G(f)(gb)}},
then: \texttt{\textcolor{blue}{\small{}q(gb) = fmap\_H(f)(p(ga))}}{\small\par}

But \texttt{\textcolor{blue}{\small{}ga = cmap\_G(f)(gb)}} means \texttt{\textcolor{blue}{\small{}(ga,
gb) in rev(graph(cmap\_G(f)))}}{\small\par}

So, the relational formulation of \texttt{\textcolor{blue}{\small{}fmap\_F}}
is:

\texttt{\textcolor{blue}{\small{}(p, q) in graph(fmap\_F(f))}} means
for all \texttt{\textcolor{blue}{\small{}ga:~G{[}A{]}}}, \texttt{\textcolor{blue}{\small{}gb:~G{[}B{]}}}
when\texttt{\textcolor{blue}{\small{}}}~\\
\texttt{\textcolor{blue}{\small{}(ga, gb) in rev(graph(cmap\_G(f)))}}
then:\\
\texttt{\textcolor{blue}{\small{}(p(ga), q(gb)) in graph(fmap\_H(f))}}{\small\par}

Replace \texttt{\textcolor{blue}{\small{}graph(f)}} by an arbitrary
relation \texttt{\textcolor{blue}{\small{}r:~A <=> B}}; replace

\texttt{\textcolor{blue}{\small{}graph(fmap\_F(f))}} by \texttt{\textcolor{blue}{\small{}rmap\_F(r)}};
\texttt{\textcolor{blue}{\small{}rev(graph(cmap\_G(f)))}} by \texttt{\textcolor{blue}{\small{}rmap\_G(r)}}{\small\par}

Then we get: \texttt{\textcolor{blue}{\small{}(p, q) in rmap(r)}}
means for all \texttt{\textcolor{blue}{\small{}ga:~G{[}A{]}}}, \texttt{\textcolor{blue}{\small{}gb:~G{[}B{]}}}
when\texttt{\textcolor{blue}{\small{}}}~\\
\texttt{\textcolor{blue}{\small{}(ga, gb) in rmap\_G(r)}} then \texttt{\textcolor{blue}{\small{}(p(ga),
q(gb)) in rmap\_H(r)}}{\small\par}

This is the same as \texttt{\textcolor{blue}{\small{}(p, q) in pfun(rmap\_G(r),
rmap\_H(r))}}{\small\par}
\end{frame}

\begin{frame}{Step 4. Example: \texttt{rmap} for non-covariant type constructors}

Consider some type constructors of different complexity:
\begin{itemize}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]}}} is covariant:\texttt{\textcolor{blue}{\small{} rmap(graph(f))
== graph(fmap(f))}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}F{[}A{]}}} is contravariant:\texttt{\textcolor{blue}{\small{} rmap(graph(f))
== rev(graph(cmap(f)))}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}G{[}A{]} = A => A}} then \texttt{\textcolor{blue}{\small{}(ga,
gb) in rmap(graph(f))}} means:
\end{itemize}
when \texttt{\textcolor{blue}{\small{}(a, b) in graph(f)}} then \texttt{\textcolor{blue}{\small{}(ga(a),
gb(b)) in graph(f)}}\\
or: \texttt{\textcolor{blue}{\small{}f(ga(a)) == gb(f(a))}} or: \texttt{\textcolor{blue}{\small{}ga
andThen f == f andThen gb}}~\\
This relation between \texttt{\textcolor{blue}{\small{}ga}} and \texttt{\textcolor{blue}{\small{}gb}}
has the form of a pullback
\begin{itemize}
\item If \texttt{\textcolor{blue}{\small{}H{[}A{]} = (A => A) => A}} then
\texttt{\textcolor{blue}{\small{}(ha, hb) in rmap\_H(graph(f))}} is:
\end{itemize}
when \texttt{\textcolor{blue}{\small{}(p, q) in rmap\_G(graph(f))}}
then \texttt{\textcolor{blue}{\small{}(ha(p), hb(q)) in graph(f)}}{\small\par}

equivalently: if \texttt{\textcolor{blue}{\small{}p andThen f == f
andThen q}} then \texttt{\textcolor{blue}{\small{}f(ha(p)) == hb(q)}}{\small\par}

This is \emph{not} in the form of a pullback relation: cannot express
\texttt{\textcolor{blue}{\small{}p}} through \texttt{\textcolor{blue}{\small{}q}}{\small\par}
\begin{itemize}
\item This happens for sufficiently complicated type constructors
\item It is hard to use relations that are neither a graph nor a pullback
\end{itemize}
\end{frame}

\begin{frame}{Example: applying relational naturality to \texttt{{[}A{]} => A =>
A}}

Example: \texttt{\textcolor{blue}{\small{}def t{[}A{]}: A => A = ... //
Fully parametric.}}{\small\par}
\begin{itemize}
\item The value \texttt{\textcolor{blue}{\small{}t}} has type \texttt{\textcolor{blue}{\small{}{[}A{]}
=> A => A}}{\small\par}
\item Denote \texttt{\textcolor{blue}{\small{}P{[}A{]} = A => A}}{\small\par}
\end{itemize}
The relational naturality law says:
\begin{itemize}
\item For any types \texttt{\textcolor{blue}{\small{}A}} and \texttt{\textcolor{blue}{\small{}B,}}
and for any relation \texttt{\textcolor{blue}{\small{}r:~A <=> B,}}
we have:
\end{itemize}
\texttt{\textcolor{blue}{\small{}(t{[}A{]}, t{[}B{]}) in rmap\_P(r)}}{\small\par}

For the type \texttt{\textcolor{blue}{\small{}P{[}A{]} = A => A}}
we have:

\texttt{\textcolor{blue}{\small{}rmap\_P(r):~(A => A) <=> (B => B)}}{\small\par}

\texttt{\textcolor{blue}{\small{}rmap\_P(r) = pfun(r, r)}}{\small\par}
\begin{itemize}
\item \texttt{\textcolor{blue}{\small{}(t{[}A{]}, t{[}B{]}) in pfun(r, r)}}
means: \\
for any \texttt{\textcolor{blue}{\small{}a:~A}}, \texttt{\textcolor{blue}{\small{}b:~B}},
if \texttt{\textcolor{blue}{\small{}(a, b) in r}} then \texttt{\textcolor{blue}{\small{}(t(a),
t(b)) in r}}{\small\par}
\end{itemize}
Trick: choose \texttt{\textcolor{blue}{\small{}r:~A <=> A}} such
that \texttt{\textcolor{blue}{\small{}(a, b) in r}} only if \texttt{\textcolor{blue}{\small{}a
== b == a0}}{\small\par}
\begin{itemize}
\item Whenever \texttt{\textcolor{blue}{\small{}a == b == a0}} then \texttt{\textcolor{blue}{\small{}t(a)
== t(b) == a0}}{\small\par}
\item So, \texttt{\textcolor{blue}{\small{}t(a0) == a0}} for any fixed \texttt{\textcolor{blue}{\small{}a0:~A}}{\small\par}
\begin{itemize}
\item It means that \texttt{\textcolor{blue}{\small{}t}} must be an identity
function
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Step 5. Preparing to prove the relational naturality law}

Instead of proving relational properties for \texttt{\textcolor{blue}{\small{}t{[}A{]}:~P{[}A{]}
=> Q{[}A{]}}}, use the function type and the quantified type constructions
and get:
\begin{itemize}
\item Any fully parametric \texttt{\textcolor{blue}{\small{}t{[}A{]}:~F{[}A{]}}}
satisfies for any \texttt{\textcolor{blue}{\small{}r:~A <=> B}} the
relation \texttt{\textcolor{blue}{\small{}(t{[}A{]}, t{[}B{]}) in
rmap\_F(r)}}{\small\par}
\end{itemize}
It is convenient to prove the relational law when \texttt{\textcolor{blue}{\small{}t}}
has a free variable:
\begin{itemize}
\item Any fully parametric expression \texttt{\textcolor{blue}{\small{}t{[}A{]}(z):~Q{[}A{]}}}
with \texttt{\textcolor{blue}{\small{}z:~P{[}A{]}}} satisfies, for
any relation \texttt{\textcolor{blue}{\small{}r:~A <=> B}} and for
any \texttt{\textcolor{blue}{\small{}z1:~P{[}A{]}}}, \texttt{\textcolor{blue}{\small{}z2:~P{[}B{]}}},
the law:\\
if \texttt{\textcolor{blue}{\small{}(z1, z2) in rmap\_P(r)}} then
\texttt{\textcolor{blue}{\small{}(t{[}A{]}(z1), t{[}B{]}(z2)) in rmap\_Q(r)}}{\small\par}
\item Equivalently: \texttt{\textcolor{blue}{\small{}(t{[}A{]}, t{[}B{]})
in pfun(rmap\_P(r), rmap\_Q(r))}}{\small\par}
\end{itemize}
This applies to expressions containing \emph{one} free variable (\texttt{\textcolor{blue}{\small{}z}})
\begin{itemize}
\item Any number of free variables can be grouped into a tuple
\end{itemize}
\end{frame}

\begin{frame}{Step 5. Outline of the proof of the relational naturality law}

The theorem says that \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)}}
satisfies its relational naturality law

Proof goes by induction on the structure of the code of \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)}}{\small\par}

At the top level, \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)}} must
have one of the 9 code constructions

Each construction decomposes the code of \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)}}into
sub-expressions

The inductive assumption is that the theorem holds for all sub-expressions
and for the free variable \texttt{\textcolor{blue}{\small{}z}}{\small\par}

In each inductive case, we choose arbitrary \texttt{\textcolor{blue}{\small{}z1:~P{[}A{]}}},
\texttt{\textcolor{blue}{\small{}z2:~P{[}B{]}}} such that \texttt{\textcolor{blue}{\small{}(z1,
z2) in rmap\_P(r)}}{\small\par}
\end{frame}

\begin{frame}{Step 5. The first four cases of the proof}

\textcolor{blue}{1} Constant type: \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)
= c}} where \texttt{\textcolor{blue}{\small{}c:~C}} has a fixed type
\texttt{\textcolor{blue}{\small{}C}}:
\begin{itemize}
\item We have \texttt{\textcolor{blue}{\small{}rmap\_P(r) == id}} and \texttt{\textcolor{blue}{\small{}(c,
c) in id}} holds
\end{itemize}
\textcolor{blue}{2} Use argument: \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)
= z}} where \texttt{\textcolor{blue}{\small{}z}} and \texttt{\textcolor{blue}{\small{}t{[}A{]}}}
have type \texttt{\textcolor{blue}{\small{}P{[}A{]}}}:
\begin{itemize}
\item If \texttt{\textcolor{blue}{\small{}(z1, z2) in rmap\_P(r)}} then
\texttt{\textcolor{blue}{\small{}(t(z1), t(z2)) in rmap\_P(r)}}{\small\par}
\end{itemize}
\textcolor{blue}{3} Create function: \texttt{\textcolor{blue}{\small{}t(z)
= h => s(z, h)}} where we assume \texttt{\textcolor{blue}{\small{}h:~H{[}A{]}}}
and \texttt{\textcolor{blue}{\small{}s(z, h):~S{[}A{]}}}{\small\par}
\begin{itemize}
\item If \texttt{\textcolor{blue}{\small{}(z1, z2) in rmap\_P(r)}} and \texttt{\textcolor{blue}{\small{}(h1,
h2) in rmap\_H(r)}} then \texttt{\textcolor{blue}{\small{}(s(z1, h1),
s(z2, h2)) in rmap\_S(r)}}{\small\par}
\begin{itemize}
\item This is the same as the inductive assumption for \texttt{\textcolor{blue}{\small{}s(z,
h) }}{\small\par}
\end{itemize}
\end{itemize}
\textcolor{blue}{4} Use function: \texttt{\textcolor{blue}{\small{}t(z)
= g(z)(h(z))}} where \texttt{\textcolor{blue}{\small{}g(z):~H{[}A{]}
=> Q{[}A{]}}} and \texttt{\textcolor{blue}{\small{}h(z):~H{[}A{]}}}
are sub-expressions:
\begin{itemize}
\item If \texttt{\textcolor{blue}{\small{}(z1, z2) in rmap\_P(r)}} then
the inductive assumption says:\\
 \texttt{\textcolor{blue}{\small{}(h(z1), h(z2)) in rmap\_H(r)}}{\small\par}
\item If \texttt{\textcolor{blue}{\small{}(h1, h2) in rmap\_H(r)}} then
the inductive assumption says:\\
 \texttt{\textcolor{blue}{\small{}(g(h1), g(h2)) in rmap\_Q(r)}}{\small\par}
\item Therefore \texttt{\textcolor{blue}{\small{}(t{[}A{]}(z1), t{[}B{]}(z2))
in rmap\_Q(r)}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 5. The next three cases of the proof}

\textcolor{blue}{5} Create tuple: \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)
= (u(z), v(z))}} where \texttt{\textcolor{blue}{\small{}u(z):~U{[}A{]}}},
\texttt{\textcolor{blue}{\small{}v(z):~V{[}A{]}}}{\small\par}

Need \texttt{\textcolor{blue}{\small{}(t{[}A{]}(z1), t{[}B{]}(z2))
in rmap\_Q(r)}}where \texttt{\textcolor{blue}{\small{}Q{[}A{]} = (U{[}A{]},
V{[}A{]})}}{\small\par}
\begin{itemize}
\item As \texttt{\textcolor{blue}{\small{}rmap\_Q(r) = pprod(rmap\_U(r),
rmap\_V(r))}}, we have \texttt{\textcolor{blue}{\small{}(t{[}A{]}(z1),
t{[}B{]}(z2)) in rmap\_Q(r)}} when \texttt{\textcolor{blue}{\small{}(u(z1),
u(z2)) in rmap\_U(r)}} and \texttt{\textcolor{blue}{\small{}(v(z1),
v(z2)) in rmap\_V(r)}}, which hold by inductive assumptions
\end{itemize}
\textcolor{blue}{6} Use tuple: \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)
= g{[}A{]}(z).\_1}} with \texttt{\textcolor{blue}{\small{}g{[}A{]}(z):~G{[}A{]}
= (Q{[}A{]}, R{[}A{]})}}{\small\par}
\begin{itemize}
\item By inductive assumption, \texttt{\textcolor{blue}{\small{}(g(z1),
g(z2)) in rmap\_G(r)}} while we have \texttt{\textcolor{blue}{\small{}rmap\_G(r)
= pprod(rmap\_Q(r), rmap\_R(r))}}, so we get \texttt{\textcolor{blue}{\small{}(g(z1).\_1,
g(z2).\_1) in rmap\_Q(r)}} as required
\item The case \texttt{\textcolor{blue}{\small{}t{[}A{]}(z) = g{[}A{]}(z).\_2}}
is proved similarly
\end{itemize}
\textcolor{blue}{7} Create a co-product: \texttt{\textcolor{blue}{\small{}t{[}A{]}(z)
= Left{[}G{[}A{]}, H{[}A{]}{]}(g{[}A{]}(z))}}{\small\par}

Here we set \texttt{\textcolor{blue}{\small{}Q{[}A{]} = Either{[}G{[}A{]},
H{[}A{]}{]}}} and \texttt{\textcolor{blue}{\small{}g{[}A{]}(z):~G{[}A{]}}}{\small\par}

By the inductive assumption, \texttt{\textcolor{blue}{\small{}(g(z1),
g(z2)) in rmap\_G(r)}} and then: \texttt{\textcolor{blue}{\small{}(Left(g(z1)),
Left(g(z2))) in rmap\_Q(r)}}{\small\par}
\begin{itemize}
\item The case \texttt{\textcolor{blue}{\small{}t{[}A{]}(z) = Left{[}G{[}A{]},
H{[}A{]}{]}(g{[}A{]}(z))}} is proved similarly
\end{itemize}
\end{frame}

\begin{frame}{Step 5. The last two cases of the proof}

\textcolor{blue}{8} Use a co-product (pattern-matching):

\texttt{\textcolor{blue}{\small{}t(z) = s(z) match \{}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ ~ case Left(x) => u(z)(x)}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ ~ case Right(y) => v(z)(y)}}{\small\par}

\texttt{\textcolor{blue}{\small{}\}}}{\small\par}
\begin{itemize}
\item We set \texttt{\textcolor{blue}{\small{}S{[}A{]} = Either{[}G{[}A{]},
H{[}A{]}{]}}}, \texttt{\textcolor{blue}{\small{}s(z):~S{[}A{]}}},
\texttt{\textcolor{blue}{\small{}x:~G{[}A{]}}}, \texttt{\textcolor{blue}{\small{}y:~H{[}A{]}}},
\texttt{\textcolor{blue}{\small{}u(z):~G{[}A{]} => Q{[}A{]}}}, and
\texttt{\textcolor{blue}{\small{}v(z):~H{[}A{]} => Q{[}A{]}}}{\small\par}
\item Inductive assumptions: \texttt{\textcolor{blue}{\small{}s(z)}}, \texttt{\textcolor{blue}{\small{}u(z)}},
\texttt{\textcolor{blue}{\small{}v(z)}} already satisfy the law
\item if \texttt{\textcolor{blue}{\small{}(z1:~P{[}A{]}, z2:~P{[}B{]})
in rmap\_P(r)}} and \texttt{\textcolor{blue}{\small{}(x1:~G{[}A{]},
x2:~G{[}B{]}) in rmap\_G(r)}} then \texttt{\textcolor{blue}{\small{}u(z1)(x1),
u(z2)(x2)) in rmap\_Q(r)}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}(s{[}A{]}(z1), s{[}B{]}(z2)) in rmap\_S(r)
= psum(rmap\_G(r), rmap\_H(r))}} means \texttt{\textcolor{blue}{\small{}s(z1),
s(z2)}} are both in \texttt{\textcolor{blue}{\small{}Left}} or both
in \texttt{\textcolor{blue}{\small{}Right}}{\small\par}
\end{itemize}
If \texttt{\textcolor{blue}{\small{}s(z1) = Left(x1)}}, \texttt{\textcolor{blue}{\small{}s(z2)
= Left(x2)}} then \texttt{\textcolor{blue}{\small{}(x1, x2) in rmap\_G(r)}}
and \texttt{\textcolor{blue}{\small{}(u(z1)(x1), u(z2)(x2)) in rmap\_Q(r)}}{\small\par}
\begin{itemize}
\item The case when both \texttt{\textcolor{blue}{\small{}s(z1), s(z2)}}
are in \texttt{\textcolor{blue}{\small{}Right}} is proved similarly
\end{itemize}
\textcolor{blue}{9} Recursive call: \texttt{\textcolor{blue}{\small{}t(z)
= f(z)(t(z)) where f(z): Q{[}A{]} => Q{[}A{]}}}{\small\par}

Inductive assumptions: the law holds for \texttt{\textcolor{blue}{\small{}f(z)}}
and for the recursive \texttt{\textcolor{blue}{\small{}t(z)}}{\small\par}
\begin{itemize}
\item Then \texttt{\textcolor{blue}{\small{}t(z)}} satisfies the law because
of the ``use function'' rule
\end{itemize}
\end{frame}

\begin{frame}{Step 6. From relational naturality to the wedge law}

Based on Bartosz Milewski's blog post: \href{https://bartoszmilewski.com/2017/04/11/}{The Free Theorem for Ends}
(2017)

Given:
\begin{itemize}
\item a function \texttt{\textcolor{blue}{\small{}f:~A => B}}{\small\par}
\item a fully parametric profunctor \texttt{\textcolor{blue}{\small{}P{[}X,
Y{]}}} with methods \texttt{\textcolor{blue}{\small{}cmapP}} and \texttt{\textcolor{blue}{\small{}fmapP}}:
\begin{itemize}
\item \texttt{\textcolor{blue}{\small{}cmapP{[}X, Y, B{]}:~(X => Y) =>
P{[}Y, B{]} => P{[}X, B{]}}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}fmapP{[}X, A, B{]}:~(A => B) =>
P{[}X, A{]} => P{[}X, B{]}}}{\small\par}
\end{itemize}
\item a fully parametric value (without free variables) \texttt{\textcolor{blue}{\small{}t:~{[}A{]}
=> P{[}A, A{]}}}{\small\par}
\end{itemize}
Then we will prove that the wedge law holds:
\begin{itemize}
\item \texttt{\textcolor{blue}{\small{}fmapP{[}A, A, B{]}(f)(t{[}A{]}) ==
cmapP{[}A, B, B{]}(f)(t{[}B{]})}}
\[
\xymatrix{\mathtt{P[A,A]}\ar[rd]\sb(0.45){\mathtt{fmapP(f)}} &  & \mathtt{P[B,B]}\ar[ld]\sp(0.45){\mathtt{cmapP(f)}}\\
\xyScaleY{1.5pc}\xyScaleX{3.5pc} & \mathtt{\mathtt{P[A,B]}}
}
\]
\item Expressed via \texttt{\textcolor{blue}{\small{}xmapP(f, g) = cmapP(g)
andThen fmapP(f)}}:

\texttt{\textcolor{blue}{\small{}xmapP(f, id)(t{[}A{]}) == xmapP(id,
f)(t{[}B{]})}}{\small\par}
\begin{itemize}
\item We do \emph{not} need to assume the commutativity law for \texttt{\textcolor{blue}{\small{}xmapP}}{\small\par}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Step 6. From relational naturality to the wedge law}

The relational naturality law holds for \texttt{\textcolor{blue}{\small{}xmapP}}:

\texttt{\textcolor{blue}{\small{}xmapP{[}A, B, X, Y{]}:~(A => B,
X => Y) => P{[}Y, A{]} => P{[}X, B{]}}}{\small\par}

For any types \texttt{\textcolor{blue}{\small{}A}}, \texttt{\textcolor{blue}{\small{}A'}},
\texttt{\textcolor{blue}{\small{}B}}, \texttt{\textcolor{blue}{\small{}B'}},
\texttt{\textcolor{blue}{\small{}X}}, \texttt{\textcolor{blue}{\small{}X'}},
\texttt{\textcolor{blue}{\small{}Y}}, \texttt{\textcolor{blue}{\small{}Y'}},
and for any relations \texttt{\textcolor{blue}{\small{}p:~A <=> A'}},
\texttt{\textcolor{blue}{\small{}q:~B <=> B'}}, \texttt{\textcolor{blue}{\small{}r:~X
<=> X'}}, \texttt{\textcolor{blue}{\small{}s:~Y <=> Y'}} and for
any values \texttt{\textcolor{blue}{\small{}f:~A => B}}, \texttt{\textcolor{blue}{\small{}f':~A'
=> B'}}, \texttt{\textcolor{blue}{\small{}g:~X => Y}}, \texttt{\textcolor{blue}{\small{}g':~X'
=> Y'}}, \texttt{\textcolor{blue}{\small{}v:~P{[}Y, A{]}}}, \texttt{\textcolor{blue}{\small{}v':~P{[}Y',
A'{]}}} such that \texttt{\textcolor{blue}{\small{}(f, f') in pfun(p,
q)}} and \texttt{\textcolor{blue}{\small{}(g, g') in pfun(r, s)}}
and

\texttt{\textcolor{blue}{\small{}(v, v') in rmap2\_P(s, p)}} we will
have:

\texttt{\textcolor{blue}{\small{}(xmapP(f, g)(v), xmapP(f', g')(v'))
in rmap2\_P(r, q)}}{\small\par}

We need to get the equation \texttt{\textcolor{blue}{\small{}xmapP(f,
id)(t{[}A{]}) == xmapP(id, f)(t{[}B{]})}}{\small\par}

This means we need \texttt{\textcolor{blue}{\small{}rmap2\_P(r, q)}}
to be an \emph{identity} relation

Choose \texttt{\textcolor{blue}{\small{}r = id:~X <=> X}} and \texttt{\textcolor{blue}{\small{}q
= id:~B <=> B}} (here \texttt{\textcolor{blue}{\small{}X' = X}},
\texttt{\textcolor{blue}{\small{}B' = B}}) and obtain \texttt{\textcolor{blue}{\small{}rmap2\_P(r,
q) = id}} (of type \texttt{\textcolor{blue}{\small{}P{[}X, B{]} <=>
P{[}X, B{]}}})
\begin{itemize}
\item This is a version of the ``identity extension lemma'' of Reynolds
\begin{itemize}
\item Prove it by induction over the cases in the definition of \texttt{\textcolor{blue}{\small{}rmap2}}{\small\par}
\item Also need to prove that \texttt{\textcolor{blue}{\small{}rmap2\_F(r,
id) = rmap\_G(r)}} etc.
\end{itemize}
\item For the case \texttt{\textcolor{blue}{\small{}P{[}X, A{]} = {[}Y{]}
=> Q{[}X, A, Y{]}}}we need to assume full parametricity for values
in the relation \texttt{\textcolor{blue}{\small{}rmap2\_P(id, id)}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Step 6. From relational naturality to the wedge law}

\texttt{\textcolor{blue}{\small{}xmapP{[}A, B, X, Y{]}:~(A => B,
X => Y) => P{[}Y, A{]} => P{[}X, B{]}}}{\small\par}

We have: \texttt{\textcolor{blue}{\small{}xmapP(f, g )(v ~) ~==
xmapP(f', g')(v' )}}{\small\par}

We need: \texttt{\textcolor{blue}{\small{}xmapP(f, id)(t{[}A{]}) ==
xmapP(id, f )(t{[}B{]})}}{\small\par}

Choose values as \texttt{\textcolor{blue}{\small{}f' = id}}, \texttt{\textcolor{blue}{\small{}g
= id}}, \texttt{\textcolor{blue}{\small{}g' = f}}, \texttt{\textcolor{blue}{\small{}v
= t{[}A{]}}}, \texttt{\textcolor{blue}{\small{}v' = t{[}B{]}}}{\small\par}

Choose types as \texttt{\textcolor{blue}{\small{}A' = B = B' = Y'}},
\texttt{\textcolor{blue}{\small{}A = X = X' = Y}}{\small\par}

The relational naturality law of \texttt{\textcolor{blue}{\small{}xmapP}}
also requires us to have:
\begin{itemize}
\item \texttt{\textcolor{blue}{\small{}(f, f') in pfun(p, q)}} -- this
is \texttt{\textcolor{blue}{\small{}(f, id) in pfun(p, id)}} -- for
any \texttt{\textcolor{blue}{\small{}(x:~A, y:~B) in p}} we need
\texttt{\textcolor{blue}{\small{}f(x) == y }}-- this holds if \texttt{\textcolor{blue}{\small{}p
= graph(f)}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}(g, g') in pfun(r, s)}} -- this
is \texttt{\textcolor{blue}{\small{}(id, f) in pfun(id, s)}} -- for
any \texttt{\textcolor{blue}{\small{}x:~A}} we need \texttt{\textcolor{blue}{\small{}(x,
f(x)) in s}} -- this holds if \texttt{\textcolor{blue}{\small{}s
= graph(f)}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}(v, v') in rmap2\_P(s, p)}} -- this
is \texttt{\textcolor{blue}{\small{}(t{[}A{]}, t{[}B{]}) in rmap2\_P(s,
p)}} -- when \texttt{\textcolor{blue}{\small{}s = p}}, this is the
relational naturality law of \texttt{\textcolor{blue}{\small{}t}}
if formulated for the type signature \texttt{\textcolor{blue}{\small{}t{[}A{]}:~P{[}A,
A{]}}}{\small\par}
\item Need to prove: \texttt{\textcolor{blue}{\small{}rmap2\_P(p, p) = rmap\_F(p)}}
where \texttt{\textcolor{blue}{\small{}F{[}A{]} = P{[}A, A{]}}}{\small\par}
\begin{itemize}
\item Prove it by induction over the cases in the definition of \texttt{\textcolor{blue}{\small{}rmap2}}{\small\par}
\item Also need to prove that \texttt{\textcolor{blue}{\small{}rmap3(p,
p, r) = rmap2(p, r)}} etc.
\end{itemize}
\end{itemize}
With these choices, the relational naturality law reduces to the wedge
law
\end{frame}

\begin{frame}{Step 6. From the wedge law to naturality laws}

\begin{itemize}
\item For type signatures \texttt{\textcolor{blue}{\small{}G{[}A{]} => H{[}A{]}}}
where both \texttt{\textcolor{blue}{\small{}G}} and \texttt{\textcolor{blue}{\small{}H}}
are covariant:
\end{itemize}
Define \texttt{\textcolor{blue}{\small{}P{[}X, Y{]} = G{[}X{]} =>
H{[}Y{]}}}, take any fully parametric \texttt{\textcolor{blue}{\small{}t{[}A{]}:~P{[}A,
A{]}}}{\small\par}

The wedge law of \texttt{\textcolor{blue}{\small{}t}} is: \texttt{\textcolor{blue}{\small{}fmapP(f)(t{[}A{]})
== cmapP(f)(t{[}B{]})}}{\small\par}

For any \texttt{\textcolor{blue}{\small{}f:~A => B}}, we have: \texttt{\textcolor{blue}{\small{}fmapP(f)(t{[}A{]})
= t{[}A{]} andThen fmapH(f)}} and \texttt{\textcolor{blue}{\small{}cmapP(f)(t{[}B{]})
= fmapG(f) andThen t{[}B{]}}}{\small\par}

The wedge law gives: \texttt{\textcolor{blue}{\small{}t{[}A{]} andThen
fmapH(f) == fmapG(f) andThen t{[}B{]}}}{\small\par}
\begin{itemize}
\item This is exactly the naturality law of \texttt{\textcolor{blue}{\small{}t}}{\small\par}
\end{itemize}
Similarly, the naturality law follows when \texttt{\textcolor{blue}{\small{}G}}
and \texttt{\textcolor{blue}{\small{}H}} are both contravariant
\end{frame}

\begin{frame}{Advanced applications. I. Beyond Yoneda}
\begin{itemize}
\item \vspace{-0.3\baselineskip}
Consider the type \texttt{\textcolor{blue}{\small{}{[}A{]} => (A =>
A) => Either{[}E, A{]}}}{\small\par}
\begin{itemize}
\item The Yoneda identities do not apply to that type signature
\item \texttt{\textcolor{blue}{\small{}P{[}A{]} = (A => A) => Either{[}E,
A{]}}} does not have naturality laws
\item The wedge law holds but does not give enough information
\end{itemize}
\item Write the relational naturality law of \texttt{\textcolor{blue}{\small{}p{[}A{]}:~P{[}A{]}}}{\small\par}
\item For any relation \texttt{\textcolor{blue}{\small{}r:~A <=> B}}, for
any \texttt{\textcolor{blue}{\small{}p:~P{[}A{]}}} and \texttt{\textcolor{blue}{\small{}q:~P{[}B{]}}},
we must have \texttt{\textcolor{blue}{\small{}(p, q) in rmap\_P(r)}}{\small\par}
\item The relational lifting: \texttt{\textcolor{blue}{\small{}rmap\_P(r)
= rfun(rfun(r, r), rsum(id, r))}}{\small\par}
\item For any \texttt{\textcolor{blue}{\small{}k:~A => A}}, \texttt{\textcolor{blue}{\small{}l:~B
=> B}}, if \texttt{\textcolor{blue}{\small{}(k, l) in rfun(r, r)}}
then we must have \texttt{\textcolor{blue}{\small{}(p(k), q(l)) in
rsum(id, r)}}{\small\par}
\item Compute the liftings for \texttt{\textcolor{blue}{\small{}r = $\emptyset$}}
(an \textbf{empty} \textbf{relation} of type \texttt{\textcolor{blue}{\small{}A
<=> B}})
\item \texttt{\textcolor{blue}{\small{}(k, l) in rfun($\emptyset$, $\emptyset$)}}
means: for any \texttt{\textcolor{blue}{\small{}a:~A}}, \texttt{\textcolor{blue}{\small{}b:~B}},
if \texttt{\textcolor{blue}{\small{}(a, b) in $\emptyset$}} then
\texttt{\textcolor{blue}{\small{}(k(a), k(b)) in $\emptyset$}}{\small\par}
\item This holds for \emph{all} \texttt{\textcolor{blue}{\small{}k}} and
\texttt{\textcolor{blue}{\small{}l}} because there are no \texttt{\textcolor{blue}{\small{}(a,
b) in $\emptyset$}}{\small\par}
\item The law becomes: for any \texttt{\textcolor{blue}{\small{}k:~A =>
A}}, \texttt{\textcolor{blue}{\small{}l:~B => B}}, we must have either
\texttt{\textcolor{blue}{\small{}p(k) == q(l) == Left(e)}} with some
\texttt{\textcolor{blue}{\small{}e:~E}}, or \texttt{\textcolor{blue}{\small{}p(k)
== Right(x)}}, \texttt{\textcolor{blue}{\small{}k(l) == Right(y)}}
and \texttt{\textcolor{blue}{\small{}(x, y) in $\emptyset$}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}p}} and \texttt{\textcolor{blue}{\small{}q}}
must be equal constant functions returning \texttt{\textcolor{blue}{\small{}Left(e)}}{\small\par}
\end{itemize}
We have proved: \texttt{\textcolor{blue}{\small{}E $\cong$ {[}A{]}
=> (A => A) => Either{[}E, A{]}}}{\small\par}
\end{frame}

\begin{frame}{Advanced applications. II. Church encoding}
\begin{itemize}
\item Define recursive types by induction: \texttt{\textcolor{blue}{\small{}T
$\cong$ S{[}T{]}}} with \emph{covariant} \texttt{\textcolor{blue}{\small{}S{[}\_{]}}}{\small\par}
\item The isomorphism is given by \texttt{\textcolor{blue}{\small{}fix:~S{[}T{]}
=> T}} and \texttt{\textcolor{blue}{\small{}unfix:~T => S{[}T{]}}}{\small\par}
\item \texttt{\textcolor{blue}{\small{}fix andThen unfix == identity}};
\texttt{\textcolor{blue}{\small{}unfix andThen fix == identity}}{\small\par}
\item Example: \texttt{\textcolor{blue}{\small{}T = List{[}R{]}}}, so \texttt{\textcolor{blue}{\small{}T
$\cong$ S{[}T{]}}} with \texttt{\textcolor{blue}{\small{}S{[}A{]}
= Option{[}(R, A){]}}}{\small\par}
\item Church encoding: \texttt{\textcolor{blue}{\small{}CT = {[}A{]} =>
(S{[}A{]} => A) => A}} (fully parametric)
\item With Scala 2 traits: \texttt{\textcolor{blue}{\small{}trait CT \{
def fold{[}A{]}(fix:~S{[}A{]} => A):~A \}}}{\small\par}
\end{itemize}
Intuition about the types \texttt{\textcolor{blue}{\small{}CT}} and
\texttt{\textcolor{blue}{\small{}S{[}A{]} => A}}: consider \texttt{\textcolor{blue}{\small{}T
= List{[}R{]}}}{\small\par}
\begin{itemize}
\item A function of type \texttt{\textcolor{blue}{\small{}S{[}A{]} => A}}
is equivalent to: \texttt{\textcolor{blue}{\small{}\{}}{\small\par}

\texttt{\textcolor{blue}{\small{}case None => (aFixedValue:~A)}}{\small\par}

\texttt{\textcolor{blue}{\small{}case Some((r, a)) => (computeNext(r,
a):~A)}}{\small\par}
\end{itemize}
\texttt{\textcolor{blue}{\small{}\}}} 
\begin{itemize}
\item The data in \texttt{\textcolor{blue}{\small{}S{[}A{]} => A}} is equivalent
to the type \texttt{\textcolor{blue}{\small{}(A, (R, A) => A)}}{\small\par}
\item These are exactly the \emph{argument data} of the \texttt{\textcolor{blue}{\small{}List}}'s
\texttt{\textcolor{blue}{\small{}foldLeft}} function

\texttt{\textcolor{blue}{\small{}foldLeft{[}A{]}:~(S{[}A{]} => A)
=> A}}{\small\par}
\end{itemize}
Intuition: we can create a value of type \texttt{\textcolor{blue}{\small{}CT}}
only if we have a list (of type \texttt{\textcolor{blue}{\small{}List{[}R{]}}})
that we can then fold using any ``fold data'' \texttt{\textcolor{blue}{\small{}(A,
(R, A) => A)}}{\small\par}
\end{frame}

\begin{frame}{Advanced applications. II. Church encoding}

\vspace{-0.3\baselineskip}
The type\texttt{\textcolor{blue}{\small{} CT}} is the least fixpoint
of the equation \texttt{\textcolor{blue}{\small{}CT $\cong$ S{[}CT{]}}} 
\begin{itemize}
\item See Wadler's paper ``\href{https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt}{Recursive types for free}''
(1990)
\end{itemize}
\texttt{\textcolor{blue}{\small{}def fix(sct:~S{[}CT{]}):~{[}A{]}
=> (S{[}A{]} => A) => A = }}{\small\par}

\texttt{\textcolor{blue}{\small{}~ ~ {[}A{]} => saa => saa(sct.map(ct
=> ct{[}A{]}(saa)))}}{\small\par}

\texttt{\textcolor{blue}{\small{}def unfix(ct:~CT):~S{[}CT{]} =
ct{[}S{[}CT{]}{]}(fmap\_S(fix))}}{\small\par}
\begin{itemize}
\item Relational law of \texttt{\textcolor{blue}{\small{}ct:~CT}} is: for
any \texttt{\textcolor{blue}{\small{}r:~A <=> B}}, \texttt{\textcolor{blue}{\small{}p:~S{[}A{]}
=> A}}, \texttt{\textcolor{blue}{\small{}q:~S{[}B{]} => B}} such
that (for any \texttt{\textcolor{blue}{\small{}sa:~S{[}A{]}, sb:~S{[}B{]}}}
if \texttt{\textcolor{blue}{\small{}(sa, sb) in rmap\_S(r)}} then
\texttt{\textcolor{blue}{\small{}(p(sa), q(sb)) in r}}) we will have
\texttt{\textcolor{blue}{\small{}(ct{[}A{]}(p), ct{[}B{]}(q)) in r}}{\small\par}
\begin{itemize}
\item Choose \texttt{\textcolor{blue}{\small{}r = graph(f)}} with an arbitrarily
chosen \texttt{\textcolor{blue}{\small{}f:~A => B}}{\small\par}
\item Then the relational law says: for any \texttt{\textcolor{blue}{\small{}p:~S{[}A{]}
=> A}}, \texttt{\textcolor{blue}{\small{}q:~S{[}B{]} => B}}, when
\texttt{\textcolor{blue}{\small{}p andThen f == fmap\_S(f) andThen
q}} then we will have \texttt{\textcolor{blue}{\small{}f(ct{[}A{]}(p))
== ct{[}B{]}(q)}}
\[
\xymatrix{\xyScaleY{1.3pc}\xyScaleX{4.5pc}\mathtt{S[A]}\ar[d]\sb(0.5){\mathtt{fmap\_S(f)}}\ar[r]\sp(0.5){\mathtt{p}} & \mathtt{A}\ar[d]\sp(0.5){\mathtt{f}}\\
\mathtt{S[B]}\ar[r]\sp(0.5){\mathtt{q}} & \mathtt{B}
}
\]
\end{itemize}
\item Can prove the isomorphism directly via that law; instead use a trick 
\end{itemize}
\end{frame}

\begin{frame}{Advanced applications. II. Church encoding}

\vspace{-0.3\baselineskip}

The trick is first to prove the ``initial algebra'' property:

For any ``fold data'' \texttt{\textcolor{blue}{\small{}q:~S{[}B{]}
=> B}} there is a \emph{unique} \texttt{\textcolor{blue}{\small{}c(q):~CT
=> B}} such that \texttt{\textcolor{blue}{\small{}fix andThen c(q)
== fmap\_S(c(q)) andThen q}} 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.5pc}\mathtt{S[CT]}\ar[d]\sb(0.5){\mathtt{fmap\_S(c(q))}}\ar[r]\sp(0.5){\mathtt{fix}} & \mathtt{CT}\ar[d]\sp(0.5){\mathtt{c(q)}}\\
\mathtt{S[B]}\ar[r]\sp(0.5){\mathtt{q}} & \mathtt{B}
}
\]

The code: \texttt{\textcolor{blue}{\small{}def c{[}B{]}(q:~S{[}B{]}
=> B)(ct:~CT):~B = ct{[}B{]}(q)}}{\small\par}
\begin{itemize}
\item With that code, \texttt{\textcolor{blue}{\small{}c(q)}} satisfies
the diagram: for any \texttt{\textcolor{blue}{\small{}sct:~S{[}CT{]}}},

\texttt{\textcolor{blue}{\small{}c(q)(fix(sct)) == q(sct.map(c(q)))
?}}{\small\par}

\texttt{\textcolor{blue}{\small{}fix(sct)(q) == q(sct.map(ct => ct(q)))}}
by definition of \texttt{\textcolor{blue}{\small{}fix}}{\small\par}
\item Use the law with \texttt{\textcolor{blue}{\small{}p = fix}}, \texttt{\textcolor{blue}{\small{}f
= c(q)}} to get \texttt{\textcolor{blue}{\small{}c(q)(ct(fix)) ==
ct(q)}}{\small\par}
\begin{itemize}
\item Equivalently \texttt{\textcolor{blue}{\small{}ct(fix)(q) == ct(q)}}
for any \texttt{\textcolor{blue}{\small{}q}}, so \texttt{\textcolor{blue}{\small{}ct(fix)
== ct}}{\small\par}
\end{itemize}
\item Use the law with \texttt{\textcolor{blue}{\small{}p = fix}} and \emph{any}
\texttt{\textcolor{blue}{\small{}f}} to get \texttt{\textcolor{blue}{\small{}f(ct(fix))
== ct(q)}}{\small\par}
\begin{itemize}
\item So, any \texttt{\textcolor{blue}{\small{}f:~CT => B}} satisfies \texttt{\textcolor{blue}{\small{}f(ct)
== ct(q)}}, so \texttt{\textcolor{blue}{\small{}f == c(q)}}{\small\par}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Advanced applications. II. Church encoding}

\vspace{-0.3\baselineskip}

\begin{itemize}
\item To prove the isomorphism properties, use another trick:

Consider \texttt{\textcolor{blue}{\small{}fmap\_S(fix):~S{[}S{[}CT{]}{]}
=> S{[}CT{]}}} as ``fold data'' for \texttt{\textcolor{blue}{\small{}S{[}CT{]}}}{\small\par}
\end{itemize}
The corresponding unique function \texttt{\textcolor{blue}{\small{}u:~CT
=> S{[}CT{]}}} is \texttt{\textcolor{blue}{\small{}u(ct) = ct(fmap\_S(fix))
= unfix(ct)}} and so \texttt{\textcolor{blue}{\small{}unfix}} satisfies
\texttt{\textcolor{blue}{\small{}fix andThen unfix == fmap\_S(unfix)
andThen fmap\_S(fix) == fmap\_S(unfix andThen fix)}}{\small\par}

Then consider \texttt{\textcolor{blue}{\small{}fix:~S{[}CT{]} =>
CT}} as ``fold data''; the corresponding unique function of type
\texttt{\textcolor{blue}{\small{}CT => CT}} is identity since\texttt{\textcolor{blue}{\small{}
ct(fix) == ct}}{\small\par}

But we also have a function \texttt{\textcolor{blue}{\small{}i = unfix
andThen fix}} of type \texttt{\textcolor{blue}{\small{}CT => CT}}
satisfying \texttt{\textcolor{blue}{\small{}fix andThen i == fmap\_S(i)
andThen fix}} because:

\texttt{\textcolor{blue}{\small{}~ fix andThen unfix andThen fix
==}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ ~ fmap\_S(unfix andThen fix)
andThen fix}}{\small\par}

By uniqueness, we must have \texttt{\textcolor{blue}{\small{}i ==
identity}}{\small\par}

It follows that \texttt{\textcolor{blue}{\small{}unfix andThen fix
== identity}} and

\texttt{\textcolor{blue}{\small{}fix andThen unfix = fmap\_S(i) =
identity}}{\small\par}
\begin{itemize}
\item We proved the isomorphism \texttt{\textcolor{blue}{\small{}CT $\cong$
S{[}CT{]}}}, so \texttt{\textcolor{blue}{\small{}CT}} is a fixpoint 
\item \texttt{\textcolor{blue}{\small{}CT}} is the ``least fixpoint'':
for any other fixpoint \texttt{\textcolor{blue}{\small{}T $\cong$
S{[}T{]}}} there is a unique map \texttt{\textcolor{blue}{\small{}CT
=> T}} that preserves the fixpoint structures of \texttt{\textcolor{blue}{\small{}CT}}
and \texttt{\textcolor{blue}{\small{}T}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Advanced applications. III. A third-order function}
\begin{itemize}
\item Define \texttt{\textcolor{blue}{\small{}type F{[}K{]} = {[}A{]} =>
((A => Option{[}K{]}) => A) => A}}{\small\par}
\begin{itemize}
\item This is an attempt to apply the Church encoding to the recursive type
definition \texttt{\textcolor{blue}{\small{}T $\cong$ T => Option{[}K{]}}}{\small\par}
\item That recursive type has the form \texttt{\textcolor{blue}{\small{}T
$\cong$ F{[}T{]}}} with a \emph{contravariant} \texttt{\textcolor{blue}{\small{}F{[}\_{]}}}{\small\par}
\end{itemize}
\item We will prove that \texttt{\textcolor{blue}{\small{}F{[}K{]} $\cong$
Option{[}K{]}}}{\small\par}
\item Define isomorphisms \texttt{\textcolor{blue}{\small{}in}} and \texttt{\textcolor{blue}{\small{}out}}: 

\texttt{\textcolor{blue}{\small{}def in{[}A{]}(optK:~Option{[}K{]}):~((A
=> Option{[}K{]}) => A) => A =}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ (p:~(A => Option{[}K{]}) => A)
=> p(\_ => optK)}}{\small\par}

\texttt{\textcolor{blue}{\small{}def out(h:~{[}A{]} => ((A => Option{[}K{]})
=> A) => A):~Option{[}K{]} =}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ h{[}Option{[}K{]}{]} \{ t:~(Option{[}K{]}
=> Option{[}K{]}) => t(None) \}}}{\small\par}
\item We need to prove that \texttt{\textcolor{blue}{\small{}out(in(optK))
== optK}} and \texttt{\textcolor{blue}{\small{}in(out(h)) == h}}{\small\par}

First: \texttt{\textcolor{blue}{\small{}out(in(optK) == out(p => p(\_
=> optK)) ==}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ (t => t(None))(\_ => optK) ==
(\_ => optK)(None) == optK}}{\small\par}

Second: \texttt{\textcolor{blue}{\small{}in(out(h)) == in(h{[}Option{[}K{]}{]}(t
=> t(None))) ==}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ \{ p => p(\_ => h{[}Option{[}K{]}{]}(t
=> t(None))) \}}}{\small\par}

But we expected \texttt{\textcolor{blue}{\small{}in(out(h)) == h ==
\{ p => h(p) \}}} instead of that!
\item Need a law for \texttt{\textcolor{blue}{\small{}h}} saying that \texttt{\textcolor{blue}{\small{}h(p)}}
\emph{must} apply \texttt{\textcolor{blue}{\small{}p}} to a constant
function:

\texttt{\textcolor{blue}{\small{}~ ~ h{[}A{]}(p) == p(\_ => h{[}Option{[}K{]}{]}(t
=> t(None)))}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Advanced applications. III. A third-order function}
\begin{itemize}
\item Use the \emph{naturality} \emph{law} for functions \texttt{\textcolor{blue}{\small{}h{[}A{]}:~F{[}A{]}
=> A}} where \texttt{\textcolor{blue}{\small{}F{[}A{]}}} is defined
by \texttt{\textcolor{blue}{\small{}F{[}A{]} = (A => Option{[}K{]})
=> A}} and is covariant in \texttt{\textcolor{blue}{\small{}A}}:

for any \texttt{\textcolor{blue}{\small{}f:~X => Y}} and \texttt{\textcolor{blue}{\small{}fx:~F{[}X{]}}}:~
\texttt{\textcolor{blue}{\small{}h{[}Y{]}(fx.map(f)) == f(h{[}X{]}(fx))}}{\small\par}
\item Here \texttt{\textcolor{blue}{\small{}fx.map(f) == (k:~Y => Option{[}K{]})
=> f(fx(f andThen k))}}{\small\par}
\item Naturality law: \texttt{\textcolor{blue}{\small{}h{[}Y{]}(k => f(fx(f
andThen k))) == f(h{[}X{]}(fx))}}{\small\par}
\item We need a law of the form: \texttt{\textcolor{blue}{\small{}h{[}A{]}(p)
== p(\_ => h{[}Option{[}K{]}{]}(}}...\texttt{\textcolor{blue}{\small{}))}}{\small\par}
\item Choose \texttt{\textcolor{blue}{\small{}X = Option{[}K{]}}}; \texttt{\textcolor{blue}{\small{}Y
= A}}; \texttt{\textcolor{blue}{\small{}f = optK => p(\_ => optK)}};
and

\texttt{\textcolor{blue}{\small{}fx:~F{[}Option{[}K{]} = (t:~Option{[}K{]}
=> Option{[}K{]}) => t(None)}}{\small\par}
\item Then LHS: \texttt{\textcolor{blue}{\small{}f(h{[}X{]}(fx)) == p(\_
=> h{[}Option{[}K{]}{]}(t => t(None)))}}{\small\par}
\item The LHS is exactly what we need (with arbitrary \texttt{\textcolor{blue}{\small{}p:~F{[}A{]}}})
\item But the RHS is: \texttt{\textcolor{blue}{\small{}h{[}Y{]}(k => f(fx(f
andThen k))) ==}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ h{[}A{]}(k => f((f andThen k)(None)))
==}}{\small\par}

\texttt{\textcolor{blue}{\small{}~ h{[}A{]}(k => p(\_ => k(p(\_ =>
None))))}}{\small\par}
\item Instead of that, we need \texttt{\textcolor{blue}{\small{}h{[}A{]}(p)
== h{[}A{]}(k => p(k))}}{\small\par}
\end{itemize}
We must find a more powerful law of \texttt{\textcolor{blue}{\small{}h}}
than the naturality law
\end{frame}

\begin{frame}{Advanced applications. III. A third-order function}
\begin{itemize}
\item Intuition: a function \texttt{\textcolor{blue}{\small{}h:~((A =>
Option{[}K{]}) => A) => A}} must apply its argument \texttt{\textcolor{blue}{\small{}p:~(A
=> Option{[}K{]}) => A}} to a \emph{constant} function of type \texttt{\textcolor{blue}{\small{}A
=> Option{[}K{]}}}. So, we expect \texttt{\textcolor{blue}{\small{}h(p)
== h(q)}} whenever \texttt{\textcolor{blue}{\small{}p(k) == q(k)}}
for all constant functions \texttt{\textcolor{blue}{\small{}k}}. It
will follow that \texttt{\textcolor{blue}{\small{}h(p) = p(k)}} for
some constant function \texttt{\textcolor{blue}{\small{}k = \_ =>
optK}}{\small\par}
\item To express this intuition via relations, apply the relational naturality
law to an ``almost-identity'' relation \texttt{\textcolor{blue}{\small{}r(a):~A
<=> A}} defined for a fixed \texttt{\textcolor{blue}{\small{}a:~A}}
by:\texttt{\textcolor{blue}{\small{} (x:~A, y:~A) in r(a)}} means
\texttt{\textcolor{blue}{\small{}x == y}} or \texttt{\textcolor{blue}{\small{}x
== a}}{\small\par}
\item Lift \texttt{\textcolor{blue}{\small{}r(a)}} to the type constructor
\texttt{\textcolor{blue}{\small{}((A => Option{[}K{]}) => A) => A}}{\small\par}
\item This gives the relational naturality law of \texttt{\textcolor{blue}{\small{}h}}:

(\texttt{\textcolor{blue}{\small{}h(p) == h(q)}} or \texttt{\textcolor{blue}{\small{}h(p)
== a}}) for all \texttt{\textcolor{blue}{\small{}p}}, \texttt{\textcolor{blue}{\small{}q}}
such that (\texttt{\textcolor{blue}{\small{}p(k) == q(l)}} or \texttt{\textcolor{blue}{\small{}p(k)
== a}}) for all \texttt{\textcolor{blue}{\small{}k}}, \texttt{\textcolor{blue}{\small{}l}}
such that \{ \texttt{\textcolor{blue}{\small{}k(x) == l(y)}} for all
\texttt{\textcolor{blue}{\small{}x}}, \texttt{\textcolor{blue}{\small{}y}}
such that \texttt{\textcolor{blue}{\small{}x == y}} or \texttt{\textcolor{blue}{\small{}x
== a}} \}
\begin{itemize}
\item Suppose \texttt{\textcolor{blue}{\small{}k(x) == l(y)}} for all \texttt{\textcolor{blue}{\small{}x}},
\texttt{\textcolor{blue}{\small{}y}} such that \texttt{\textcolor{blue}{\small{}x
== y}} or \texttt{\textcolor{blue}{\small{}x == a}}{\small\par}
\item It means that \texttt{\textcolor{blue}{\small{}k(a) == l(y)}} for
all \texttt{\textcolor{blue}{\small{}y:~A}}, so \texttt{\textcolor{blue}{\small{}l}}
is a \emph{constant} function
\item And \texttt{\textcolor{blue}{\small{}k(y) == l(y)}} for all \texttt{\textcolor{blue}{\small{}y
!= a}}, so \texttt{\textcolor{blue}{\small{}k}} and \texttt{\textcolor{blue}{\small{}l}}
are the same function
\end{itemize}
\item The relational law of \texttt{\textcolor{blue}{\small{}h}} is: (\texttt{\textcolor{blue}{\small{}h(p)
== h(q)}} or \texttt{\textcolor{blue}{\small{}h(p) == a}}) for all
\texttt{\textcolor{blue}{\small{}p}}, \texttt{\textcolor{blue}{\small{}q}}
such that (\texttt{\textcolor{blue}{\small{}p(k) == q(k)}} or \texttt{\textcolor{blue}{\small{}p(k)
== a}}) for all constant functions \texttt{\textcolor{blue}{\small{}k}}{\small\par}
\end{itemize}
\end{frame}

\begin{frame}{Advanced applications. III. A third-order function}
\begin{itemize}
\item Use the relational law of \texttt{\textcolor{blue}{\small{}h}} to
prove that, for any \texttt{\textcolor{blue}{\small{}p:~F{[}A{]}}},
we have:

\texttt{\textcolor{blue}{\small{}h{[}A{]}(p) == h{[}A{]}(k => p(\_
=> k(p(\_ => None))))}}{\small\par}
\item The relational law says: \texttt{\textcolor{blue}{\small{}h{[}A{]}(p)
== h{[}A{]}(q)}} for all \texttt{\textcolor{blue}{\small{}p}}, \texttt{\textcolor{blue}{\small{}q}}
such that (...)
\item Choose \texttt{\textcolor{blue}{\small{}q = (k:~A => Option{[}K{]})
=> p(\_ => k(p(\_ => None)))}}{\small\par}
\item We find that the precondition holds for these \texttt{\textcolor{blue}{\small{}p}}
and \texttt{\textcolor{blue}{\small{}q}}: For any \emph{constant}
function \texttt{\textcolor{blue}{\small{}k:~A => Option{[}K{]}}}
we actually have \texttt{\textcolor{blue}{\small{}p(k) == q(k)}}{\small\par}
\begin{itemize}
\item To verify that: Suppose \texttt{\textcolor{blue}{\small{}k = \{ \_
=> optK \}}}, then:

\texttt{\textcolor{blue}{\small{}q(k) == p(\_ => k(p(\_ => None)))
== p(\_ => optK) == p(k)}}{\small\par}
\end{itemize}
\item Since the precondition holds, we obtain \texttt{\textcolor{blue}{\small{}h(p)
== h(q)}} or \texttt{\textcolor{blue}{\small{}h(p) == a}}{\small\par}
\item This holds for any chosen \texttt{\textcolor{blue}{\small{}a:~A}}
but the definition of \texttt{\textcolor{blue}{\small{}q}} does not
depend on \texttt{\textcolor{blue}{\small{}a}}, so we can rewrite
the law as $\forall h\forall p\forall a$ instead of $\forall h\forall a\forall p$
\item When the type \texttt{\textcolor{blue}{\small{}A}} has at least two
different values, choose \texttt{\textcolor{blue}{\small{}a != h(p)}}{\small\par}
\item The result is \texttt{\textcolor{blue}{\small{}h(p) == h(q)}} as required
\end{itemize}
This completes the proof of \texttt{\textcolor{blue}{\small{}in(out(h))
== h}} and of the type isomorphism 

\texttt{\textcolor{blue}{\small{}~ Option{[}K{]} $\cong$ {[}A{]}
=> ((A => Option{[}K{]}) => A) => A}}{\small\par}
\end{frame}

\begin{frame}{Summary}
\begin{itemize}
\item ``Theorems for free'' are laws always satisfied by fully parametric
code
\item Relational parametricity is a powerful proof technique
\item Relational parametricity has a steep learning curve
\begin{itemize}
\item The result may be a relation that is difficult to interpret as code
\item Cannot directly write code that manipulates relations
\item All calculations need to be done symbolically or with proof assistants
\end{itemize}
\item Naturality laws and the wedge law are shortcuts to ``theorems for
free''
\begin{itemize}
\item A few proofs in FP do require the relational naturality law
\end{itemize}
\item More details in the free book --- {\small{}\href{https://github.com/winitzki/sofp}{https://github.com/winitzki/sofp}}{\small\par}
\end{itemize}
\begin{center}
{\small{}}%
\begin{minipage}[t][1\totalheight][c]{0.27\columnwidth}%
\includegraphics[width=2.5cm]{book-draft-cover}%
\end{minipage}{\small\par}
\par\end{center}

\end{frame}

\end{document}
