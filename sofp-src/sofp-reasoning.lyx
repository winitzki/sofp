#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Reasoning about code.
 Techniques of symbolic derivation
\begin_inset CommandInset label
LatexCommand label
name "chap:Reasoning-about-code"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{{\color{teal}#1}}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\end_layout

\begin_layout Standard
In previous chapters, we have performed symbolic derivations of some laws.
 To make those derivations more manageable, we gradually developed special
 notations and techniques of reasoning.
 This short chapter is a summary of these notations and techniques.
\end_layout

\begin_layout Section
Mathematical code notation
\end_layout

\begin_layout Subsection
The nine constructions of fully parametric code
\end_layout

\begin_layout Standard
The eight basic constructions
\begin_inset Index idx
status open

\begin_layout Plain Layout
eight code constructions
\end_layout

\end_inset

 introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

, together with recursion, serve as a foundation for 
\series bold
fully parametric
\series default
 coding style.
 All major techniques and design patterns of functional programming can
 be implemented using only these constructions, i.e., by fully parametric
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code
\end_layout

\end_inset

 code.
 We will now define the code notation (summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Mathematical-notation-for-basic-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for each of the nine constructions.
\begin_inset Index idx
status open

\begin_layout Plain Layout
nine code constructions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Constructions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala examples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use a constant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $\text{true}$
\end_inset

, 
\begin_inset Formula $\text{"abc"}$
\end_inset

, 
\begin_inset Formula $123$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use a given argument
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x: A) = { ...
 x ...
 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x^{:A})\triangleq...~x~...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create a function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: A) => expr(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}\rightarrow\text{expr}\left(x\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use a function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 (Scala 2.13)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)$
\end_inset

 or 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create a tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val p: (A, B) = (a, b)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p^{:A\times B}\triangleq a\times b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use a tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p\triangleright\pi_{1}$
\end_inset

 or 
\begin_inset Formula $p\triangleright\pi_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create a disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[A, B](y)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use a disjunctive value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset space \hspace*{}
\length -1.3line%
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 14baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val p: Either[A, B] = ...
 
\end_layout

\begin_layout Plain Layout

val q: C = p match {
\end_layout

\begin_layout Plain Layout

    case Left(x)   => f(x)
\end_layout

\begin_layout Plain Layout

    case Right(y)  => g(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset

 
\begin_inset space \hspace*{}
\length -0.9line%
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $q^{:C}\triangleq p^{:A+B}\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & x^{:A}\rightarrow f(x)\\
B & y^{:B}\rightarrow g(y)
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use a recursive call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x) = { ...
 f(y) ...
 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)\triangleq...~\overline{f}(y)~...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Mathematical notation for the nine basic code constructions.
\begin_inset CommandInset label
LatexCommand label
name "tab:Mathematical-notation-for-basic-code-constructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
1) Use a constant
\end_layout

\begin_layout Standard
At any place in the code, we may use a fixed constant value of a primitive
 type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 We may also use a 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 for any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 All named unit values are denoted by 
\begin_inset Formula $1$
\end_inset

 and are viewed as having type 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 
\end_layout

\begin_layout Standard
With this construction, we can create 
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset


\series bold
constant functions
\series default
 (functions that ignore their argument):
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def c_1(x: String): Int = 123
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
c_{1}(x^{:\text{String}})\triangleq123\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
2) Use a given argument
\end_layout

\begin_layout Standard
In any expression that has a bound variable (e.g., an argument within a function's
 body), we may use the bound variable at any place, as many times as we
 need.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def c_2[A](x: String, y: Int): Int = 123 + y + y
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
c_{2}(x^{:\text{String}},y^{:\text{Int}})\triangleq123+y+y\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
3) Create a function
\end_layout

\begin_layout Standard
We can always make a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr }
\end_layout

\end_inset

 out of a variable, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, and any expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 that may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a free variable
\begin_inset Index idx
status open

\begin_layout Plain Layout
free variable
\end_layout

\end_inset

 (i.e., a variable that should be defined outside that expression).
 E.g., the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123 + x + x
\end_layout

\end_inset

 uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a free variable because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123 + x + x
\end_layout

\end_inset

 only makes sense if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is already defined.
 So, we can create a nameless function:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ x: Int => 123 + x + x }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
x^{:\text{Int}}\rightarrow123+x+x\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Standard
If the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 already contains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a bound variable, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr }
\end_layout

\end_inset

 will have a name clash.
 As an example, consider an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr == { x => x }
\end_layout

\end_inset

 that already contains a nameless function with bound variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 If we want to make a function out of that expression, we could write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => { x => x }
\end_layout

\end_inset

, but such code is confusing.
 It is helpful to avoid the name clash by renaming the bound variables inside
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr == { z => z }
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f = { x: Int => { z: Int => z } }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
f\triangleq x^{:\text{Int}}\rightarrow z^{:\text{Int}}\rightarrow z\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
4) Use a function
\end_layout

\begin_layout Standard
If a function is already defined, we can use it by applying it to an argument.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f = { x: Int => 123 + x + x }
\end_layout

\begin_layout Plain Layout

f(100)  // Evaluates to 323.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset Formula 
\[
f\triangleq x^{:\text{Int}}\rightarrow123+x+x\quad,\quad\quad f(100)=323\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Paragraph
5) Create a tuple
\end_layout

\begin_layout Standard
Given two values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

, we can create the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

 as well as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(b, a)
\end_layout

\end_inset

.
 In the code notation, those tuples are written as 
\begin_inset Formula $a\times b$
\end_inset

 and 
\begin_inset Formula $b\times a$
\end_inset

.
\end_layout

\begin_layout Paragraph
6) Use a tuple
\end_layout

\begin_layout Standard
Given a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p == (a, b)
\end_layout

\end_inset

, we can extract each of the values via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset

.
 The corresponding code notation is 
\begin_inset Formula $p\triangleright\pi_{1}$
\end_inset

 and 
\begin_inset Formula $p\triangleright\pi_{2}$
\end_inset

.
 The auxiliary functions 
\begin_inset Formula $\pi_{i}$
\end_inset

 (where 
\begin_inset Formula $i=1,2,...$
\end_inset

) may be used for tuples of any size.
 Example code defining these functions:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pi_1[A, B]: ((A, B)) => A = {
\end_layout

\begin_layout Plain Layout

    case (a, b) => a
\end_layout

\begin_layout Plain Layout

} // Same as `_._1`
\end_layout

\begin_layout Plain Layout

def pi_2[A, B]: ((A, B)) => B = {
\end_layout

\begin_layout Plain Layout

    case (a, b) => b
\end_layout

\begin_layout Plain Layout

} // Same as `_._2`
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset Formula 
\begin{align*}
\pi_{1}^{A,B} & \triangleq a^{:A}\times b^{:B}\rightarrow a\quad,\\
\pi_{2}^{A,B} & \triangleq a^{:A}\times b^{:B}\rightarrow b\quad.
\end{align*}

\end_inset

The notation 
\begin_inset Formula $a\times b$
\end_inset

 is used in an 
\emph on
argument
\emph default
 of a function to destructure a tuple.
\end_layout

\begin_layout Paragraph
7) Create a disjunctive value
\end_layout

\begin_layout Standard
Once a disjunctive type such as 
\begin_inset Formula $A+B+C$
\end_inset

 has been defined in Scala, its named 
\begin_inset Quotes eld
\end_inset

constructors
\begin_inset Quotes erd
\end_inset

 (i.e., case classes) are used to create values of that type:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait S
\end_layout

\begin_layout Plain Layout

final case class P(w: Int, x: Int)  extends S
\end_layout

\begin_layout Plain Layout

final case class Q(y: String)       extends S
\end_layout

\begin_layout Plain Layout

final case class R(z: Int)          extends S
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val s: S = P(10, 20) // Create a value of type S.
\end_layout

\begin_layout Plain Layout

val t: S = R(30)     // Another value of type S.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace 35baselineskip%
\end_inset


\begin_inset Formula 
\[
S\triangleq\text{Int}\times\text{Int}+\text{String}+\text{Int}\quad,
\]

\end_inset


\begin_inset Formula 
\begin{align*}
s^{:S} & \triangleq10\times20+\bbnum 0^{:\text{String}}+\bbnum 0^{:\text{Int}}\quad,\\
t^{:S} & \triangleq\bbnum 0^{:\text{Int}\times\text{Int}}+\bbnum 0^{:\text{String}}+30\quad.
\end{align*}

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
The code notation for disjunctive values, e.g., 
\begin_inset Formula $\bbnum 0+\bbnum 0+x$
\end_inset

, is more verbose than the Scala syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R(x)
\end_layout

\end_inset

.
 The advantage is that we may explicitly annotate all types and show clearly
 the part of the disjunction that we are creating.
 Another advantage is that the notation 
\begin_inset Formula $\bbnum 0+\bbnum 0+x$
\end_inset

 is similar to a row vector, 
\begin_inset Formula $\,\begin{array}{|ccc|}
\bbnum 0 & \bbnum 0 & x\end{array}$
\end_inset


\begin_inset space ~
\end_inset

, which is well adapted to the matrix notation for functions.
\end_layout

\begin_layout Paragraph
8) Use a disjunctive value
\end_layout

\begin_layout Standard
Once created, disjunctive values can be used as arguments of a pattern-matching
 expression (Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 syntax).
 Recall that functions that take a disjunctive value as an argument (
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive functions
\end_layout

\end_inset


\series bold
disjunctive functions
\series default

\begin_inset Quotes erd
\end_inset

) may be also written 
\emph on
without
\emph default
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 keyword:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val compute: Option[Int] => Option[Int] = {
\end_layout

\begin_layout Plain Layout

    case None      => Some(100)
\end_layout

\begin_layout Plain Layout

    case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -165baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -145baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{compute}^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
We will use this example to explain how disjunctive functions are written
 in the matrix notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
matrix notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type!in matrix notation
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Each row of a matrix corresponds to a part of the disjunctive type matched
 by one of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 In this example, the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

 has two parts: the named unit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

) and the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[Int]
\end_layout

\end_inset

, which is equivalent to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 So, the matrix has two rows labeled 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\text{Int}$
\end_inset

, showing that the function's argument type is 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

.
\end_layout

\begin_layout Standard
The columns of the matrix correspond to the parts of the disjunctive type
 
\emph on
returned
\emph default
 by the function.
 In this example, the return type is also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

, that is, 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

, so the matrix has two columns labeled 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\text{Int}$
\end_inset

.
 If the return type is not disjunctive, the matrix will have one column.
\end_layout

\begin_layout Standard
What are the matrix elements? The idea of the matrix notation is to translate
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions line by line from the Scala code.
 Look at the first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 line as if it were a standalone partial function,
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case None => Some(100) }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 is a named unit, this function is written in the code notation as 
\begin_inset Formula $1\rightarrow\bbnum 0^{:\bbnum 1}+100^{:\text{Int}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The second line is written in the form of a partial function as
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case Some(x) => Some(x / 2) }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The pattern variable on the left side is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, so we can denote that function by 
\begin_inset Formula $x^{:\text{Int}}\rightarrow\bbnum 0^{:\bbnum 1}+(x/2)^{:\text{Int}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
To obtain the matrix notation, we may simply write the two partial functions
 in the two rows:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val compute: Option[Int] => Option[Int] = {
\end_layout

\begin_layout Plain Layout

    case None      => Some(100)
\end_layout

\begin_layout Plain Layout

    case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -135baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{compute}^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\,\begin{array}{|c||c|}
 & \bbnum 1+\text{Int}\\
\hline \bbnum 1 & 1\rightarrow\bbnum 0+100\\
\text{Int} & x\rightarrow\bbnum 0+\frac{x}{2}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
This is already a valid matrix notation for the function 
\begin_inset Formula $f$
\end_inset

.
 So far, the matrix has two rows and one column.
 However, we notice that each row's return value is 
\emph on
known
\emph default
 to be in a specific part of the disjunctive type 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

 (in this example, both rows return values of type 
\begin_inset Formula $\bbnum 0+\text{Int}$
\end_inset

).
 So, we can split the column into two and obtain a clearer and more useful
 notation for this function:
\begin_inset Formula 
\[
\text{compute}^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset

The void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type!in matrix notation
\end_layout

\end_inset

 
\begin_inset Formula $\bbnum 0$
\end_inset

 is written symbolically to indicate that the disjunctive part in that column
 is not returned.
 In this way, the matrix shows the parts of disjunctive types that are being
 returned.
 
\end_layout

\begin_layout Standard
Partial functions are expressed in the matrix notation by writing 
\begin_inset Formula $\bbnum 0$
\end_inset

 in the missing rows:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def get[A]: Option[A] => A = {
\end_layout

\begin_layout Plain Layout

    case Some(x) => x
\end_layout

\begin_layout Plain Layout

} // Partial function; fails on `None`.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -135baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{get}^{:\bbnum 1+A\rightarrow A}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & x^{:A}\rightarrow x
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression is equivalent to an application of a disjunctive function:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val p: Option[Int] = Some(64)
\end_layout

\begin_layout Plain Layout

val q: Option[Int] = p match {
\end_layout

\begin_layout Plain Layout

    case None      => Some(100)
\end_layout

\begin_layout Plain Layout

    case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}    // The value of q equals Some(32).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -275baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset Formula 
\[
p\triangleq\bbnum 0^{:\bbnum 1}+64^{:\text{Int}}\quad,\quad q\triangleq p\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset

It is convenient to put the argument 
\begin_inset Formula $p$
\end_inset

 to the 
\emph on
left
\emph default
 of the disjunctive function, as in the Scala code.
\end_layout

\begin_layout Standard
Because only one part of a disjunctive type can ever be returned, a row
 can have at most one non-void value.
 That value will be in the column corresponding to the part being returned.
 
\end_layout

\begin_layout Standard
The matrix notation allows us to compute such function applications directly.
 We view the disjunctive value 
\begin_inset Formula $\bbnum 0+64^{:\text{Int}}$
\end_inset

 as a 
\begin_inset Quotes eld
\end_inset

row vector
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\,\begin{array}{|cc|}
\bbnum 0 & 64\end{array}$
\end_inset


\begin_inset space ~
\end_inset

, written with a single left line to distinguish it from a function matrix.
 Calculations use the standard rules of a vector-matrix product:
\begin_inset Formula 
\[
(\bbnum 0+64)\triangleright\,\begin{array}{||cc|}
\bbnum 0 & 1\rightarrow100\\
\bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 64\end{array}\,\triangleright\,\begin{array}{||cc|}
\bbnum 0 & 1\rightarrow100\\
\bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 64\triangleright(x\rightarrow\frac{x}{2})\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 32\end{array}\,=(\bbnum 0+32)\quad.
\]

\end_inset

The pipe (
\begin_inset Formula $\triangleright$
\end_inset

) operation plays the role of the 
\begin_inset Quotes eld
\end_inset

multiplication
\begin_inset Quotes erd
\end_inset

 of matrix elements, and we drop any terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 We omitted type annotations since we already checked that the types match.
\end_layout

\begin_layout Paragraph
9) Use a recursive call
\end_layout

\begin_layout Standard
The last construction is to call a function recursively within its own definitio
n.
 This construction was not shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 because the constructive propositional logic (which was the main focus
 in that chapter) cannot represent a recursively defined value.
 However, this limitation of propositional logic means only that we do not
 have an algorithm for 
\emph on
automatic
\emph default
 derivation of recursive code.
 Similarly, no algorithm can automatically derive code that involves type
 constructors with known methods.
 Nevertheless, those derivations can be performed by hand.
 
\end_layout

\begin_layout Standard
Recursive code is used often, and we need to get some experience reasoning
 about it.
 In derivations, this book denotes recursive calls by an overline.
 For example, the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor is defined as
\begin_inset Formula 
\[
\text{fmap}_{\text{List}}(f)\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times\text{List}^{A}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times\text{List}^{A} & \bbnum 0 & h^{:A}\times t^{:\text{List}^{A}}\rightarrow f(h)\times\big(t\triangleright\overline{\text{fmap}_{\text{List}}}(f)\big)
\end{array}\quad.
\]

\end_inset

The recursive call to 
\begin_inset Formula $\text{fmap}_{\text{List}}$
\end_inset

 is applied to a list's tail (the value 
\begin_inset Formula $t$
\end_inset

).
\end_layout

\begin_layout Standard
In proofs of laws for recursive functions, it is necessary to use induction
 in the number of recursive self-calls.
 However, the proof does not need to separate the base case (no recursive
 calls) from the inductive step.
 In the proof, we write a symbolic calculation as usual, except that we
 may assume that the law already holds for any recursive calls to the same
 function.
\end_layout

\begin_layout Standard
For example, a proof of the identity law of 
\begin_inset Formula $\text{fmap}_{\text{List}}$
\end_inset

, which says 
\begin_inset Formula $\text{fmap}_{\text{List}}(\text{id})=\text{id}$
\end_inset

, may proceed by replacing the recursive call 
\begin_inset Formula $\overline{\text{fmap}_{\text{List}}}(\text{id})$
\end_inset

 by 
\begin_inset Formula $\text{id}$
\end_inset

 during the calculations:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{\text{List}}(\text{id})=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h^{:A}\times t^{:\text{List}^{A}}\rightarrow\text{id}(h)\times\big(\gunderline{t\triangleright\overline{\text{fmap}_{\text{List}}}(\text{id})}\big)
\end{array}\\
\text{inductive assumption}:\quad & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow\gunderline{\text{id}(h)\times(t\triangleright\text{id})}
\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \gunderline{h\times t\rightarrow h\times t}
\end{array}\\
\text{identity matrix}:\quad & =\,\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Function composition and the pipe notation
\end_layout

\begin_layout Standard
In addition to the basic code constructions, our derivations will often
 need to work with function compositions and lifted functions.
 It is often faster to perform calculations with functions when we do not
 write all of their arguments explicitly; e.g., writing the right identity
 law as 
\begin_inset Formula $f\bef\text{id}=f$
\end_inset

 instead of 
\begin_inset Formula $\text{id}\left(f(x)\right)=f(x)$
\end_inset

.
 This is known as calculating in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
point-free calculations
\end_layout

\end_inset


\series bold
point-free
\series default
 style (meaning 
\begin_inset Quotes eld
\end_inset

argument-free
\begin_inset Quotes erd
\end_inset

).
 Many laws can be formulated and used more easily in the point-free form.
 
\end_layout

\begin_layout Standard
Calculations in point-free style almost always involve composing functions.
 This book prefers to use the 
\emph on
forward
\emph default
 function composition 
\begin_inset Formula $(f\bef g$
\end_inset

) defined for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

 by
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f andThen g == { x => g(f(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
f\bef g\triangleq x\rightarrow g(f(x))\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Standard
A useful tool for calculations is the 
\series bold
pipe
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
$@
\begin_inset Formula $\triangleright$
\end_inset

-notation!see 
\begin_inset Quotes eld
\end_inset

pipe notation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 operation, 
\begin_inset Formula $x\triangleright f$
\end_inset

, which places the argument (
\begin_inset Formula $x$
\end_inset

) to the 
\emph on
left
\emph default
 of a function (
\begin_inset Formula $f$
\end_inset

).
 It is then natural to apply further functions at 
\emph on
right
\emph default
, for example 
\begin_inset Formula $(x\triangleright f)\triangleright g$
\end_inset

 meaning 
\begin_inset Formula $g(f(x))$
\end_inset

.
 In Scala, methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 are often combined in this way:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x.map(f).filter(p)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
x\triangleright\text{fmap}\,(f)\triangleright\text{filt}\,(p)\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Standard
To enable this common usage, the 
\begin_inset Formula $\triangleright$
\end_inset

 operation is defined to group towards the left.
 So, the parentheses in 
\begin_inset Formula $(x\triangleright f)\triangleright g$
\end_inset

 are not needed, and we write 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation!operator precedence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $x\triangleright f\triangleright g=g(f(x))$
\end_inset

 by definition, it follows that the composition 
\begin_inset Formula $f\bef g$
\end_inset

 satisfies
\begin_inset Formula 
\[
x\triangleright f\triangleright g=x\triangleright(f\bef g)\quad.
\]

\end_inset

Such formulas are needed often, so we follow the convention that the pipe
 operation (
\begin_inset Formula $\triangleright$
\end_inset

) groups weaker than the composition operation (
\begin_inset Formula $\bef$
\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation!operator precedence
\end_layout

\end_inset

 We can then omit parentheses: 
\begin_inset Formula $x\triangleright(f\bef g)=x\triangleright f\bef g$
\end_inset

.
 
\end_layout

\begin_layout Standard
Another common simplification occurs with function compositions of the form
\begin_inset Formula 
\[
(x\rightarrow t\triangleright f)\bef g=x\rightarrow g(t\triangleright f)=x\rightarrow(t\triangleright f\triangleright g)=x\rightarrow t\triangleright f\bef g\quad.
\]

\end_inset

The function arrow groups weaker than the pipe operator: 
\begin_inset Formula $x\rightarrow t\triangleright f\bef g=x\rightarrow(t\triangleright f\bef g)$
\end_inset

.
\end_layout

\begin_layout Standard
How can we verify this and other similar computations where the operations
 
\begin_inset Formula $\triangleright$
\end_inset

 and 
\begin_inset Formula $\bef$
\end_inset

 are combined in some way? Instead of memorizing a large set of identities,
 we can rely on knowing only one rule that says how arguments are symbolically
 substituted as parameters into functions, for example:
\begin_inset Formula 
\begin{align*}
\text{substitute }x\text{ instead of }a:\quad & \gunderline x\triangleright(\gunderline a\rightarrow f(\gunderline a))=f(x)\quad.\\
\text{substitute }f(x)\text{ instead of }y:\quad & (x\rightarrow\gunderline{f(x)})\bef(\gunderline y\rightarrow g(\gunderline y))=x\rightarrow g(f(x))\quad.
\end{align*}

\end_inset

Whenever there is a doubt (is 
\begin_inset Formula $x\triangleright(f\triangleright g)$
\end_inset

 or 
\begin_inset Formula $(x\bef f)\triangleright g$
\end_inset

 the correct formula..?), one can always write functions in an expanded form,
 
\begin_inset Formula $x\rightarrow f(x)$
\end_inset

 instead of 
\begin_inset Formula $f$
\end_inset

, and perform calculations more verbosely.
 After getting some experience with the 
\begin_inset Formula $\triangleright$
\end_inset

 and 
\begin_inset Formula $\bef$
\end_inset

 operations, the reader will start using them more freely without writing
 functions in expanded form.
\end_layout

\begin_layout Standard
The matrix notation is adapted to the pipe operation and the forward function
 composition.
 As an example, let us write the composition of the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compute
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get[Int]
\end_layout

\end_inset

 shown above: 
\begin_inset Formula 
\[
\text{compute}\bef\text{get}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0\\
\text{Int} & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & \text{Int}\\
\hline \bbnum 1 & (1\rightarrow100)\bef\text{id}\\
\text{Int} & (x\rightarrow\frac{x}{2})\bef\text{id}
\end{array}=\,\begin{array}{|c||c|}
 & \text{Int}\\
\hline \bbnum 1 & 1\rightarrow100\\
\text{Int} & x\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset

In this computation, we used the composition (
\begin_inset Formula $\bef$
\end_inset

) instead of the 
\begin_inset Quotes eld
\end_inset

multiplication
\begin_inset Quotes erd
\end_inset

 of matrix elements.
\end_layout

\begin_layout Standard
Why does the rule for matrix multiplication work for function compositions?
 The reason is the equivalence 
\begin_inset Formula $x\triangleright f\triangleright g=x\triangleright f\bef g$
\end_inset

.
 We have defined the matrix form of functions to work with the 
\begin_inset Quotes eld
\end_inset

row-vector
\begin_inset Quotes erd
\end_inset

 form of disjunctive types, i.e., for the computation 
\begin_inset Formula $x\triangleright f$
\end_inset

 (where 
\begin_inset Formula $x$
\end_inset

 is a row vector representing a value of a disjunctive type).
 The result of computing 
\begin_inset Formula $x\triangleright f$
\end_inset

 is again a row vector, which we can pipe into another matrix 
\begin_inset Formula $g$
\end_inset

 as 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

.
 The standard rules of matrix multiplication make it associative; so, the
 result of 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

 is the same as the result of piping 
\begin_inset Formula $x$
\end_inset

 into the matrix product of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 Therefore, the matrix product of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 must yield the function 
\begin_inset Formula $f\bef g$
\end_inset

.
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

non-disjunctive
\begin_inset Quotes erd
\end_inset

 function (i.e., one not taking or returning disjunctive types) may be written
 as a 
\begin_inset Formula $1\times1$
\end_inset

 matrix, so its composition with disjunctive functions can be computed via
 the same rules.
 
\end_layout

\begin_layout Subsection
Functor and contrafunctor liftings
\end_layout

\begin_layout Standard
Functions and function compositions lifted to a functor (or to a contrafunctor)
 are used in derivations so often that the notation 
\begin_inset Formula $x\triangleright\text{fmap}_{F}(f)$
\end_inset

 and its Scala analog 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f)
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 are not short enough.
 This book uses the notation 
\begin_inset Formula $x\triangleright f^{\uparrow F}$
\end_inset

 for functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $x\triangleright f^{\downarrow C}$
\end_inset

 for contrafunctors 
\begin_inset Formula $C$
\end_inset

.
 This notation graphically emphasizes the function 
\begin_inset Formula $f$
\end_inset

 being lifted and also shows the name of the relevant functors or contrafunctors.
 Compositions of lifted functions are visually easy to recognize, for example:
\begin_inset Formula 
\[
f^{\downarrow H}\bef g^{\downarrow H}=\left(g\bef f\right)^{\downarrow H}\quad,\quad\quad f^{\uparrow L}\bef g^{\uparrow L}\bef h^{\uparrow L}=\left(f\bef g\bef h\right)^{\uparrow L}\quad.
\]

\end_inset

In these formulas, the labels 
\begin_inset Formula $^{\downarrow H}$
\end_inset

 and 
\begin_inset Formula $^{\uparrow L}$
\end_inset

 clearly suggest that we may pull several functions under a single lifting.
 We may also split a lifted composition into a composition of liftings.
 
\end_layout

\begin_layout Standard
The lifting notation helps us recognize that these steps are possible just
 by looking at the formula.
 Of course, we still need to find a useful sequence of steps in a given
 derivation or proof.
\end_layout

\begin_layout Section
Derivation techniques
\end_layout

\begin_layout Subsection
Auxiliary functions for handling products
\end_layout

\begin_layout Standard
The functions denoted by 
\begin_inset Formula $\pi_{1}$
\end_inset

, 
\begin_inset Formula $\pi_{2}$
\end_inset

, 
\begin_inset Formula $\Delta$
\end_inset

, and 
\begin_inset Formula $\boxtimes$
\end_inset

 proved to be helpful in derivations that involve tuples.
 (However, the last two functions are unlikely to be frequently used in
 practical programming.) 
\end_layout

\begin_layout Standard
We already saw the definition and the implementation of the functions 
\begin_inset Formula $\pi_{1}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function 
\begin_inset Formula $\Delta$
\end_inset

 is a right inverse for 
\begin_inset Formula $\pi_{1}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A]: A => (A, A) = { x => (x, x) }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -115baselineskip%
\end_inset


\begin_inset Formula 
\[
\Delta^{A}:A\rightarrow A\times A\quad,\quad\quad\Delta\triangleq a^{:A}\rightarrow a\times a\quad.
\]

\end_inset


\begin_inset VSpace -115baselineskip%
\end_inset


\end_layout

\begin_layout Standard
It is clear that extracting any part of a pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta(x) == (x, x)
\end_layout

\end_inset

 will give back the original 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 This property can be written as an equation or a 
\begin_inset Quotes eld
\end_inset

law
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

delta(x)._1 == x
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset


\begin_inset Formula 
\[
\pi_{1}(\Delta(x))=x\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Standard
We can transform this law into a point-free equation by first using the
 pipe notation,
\begin_inset Formula 
\[
\pi_{1}(\Delta(x))=(\Delta(x))\triangleright\pi_{1}=x\triangleright\Delta\triangleright\pi_{1}=x\triangleright\Delta\bef\pi_{1}\quad,
\]

\end_inset

which gives the equation 
\begin_inset Formula $x\triangleright\Delta\bef\pi_{1}=x=x\triangleright\text{id}$
\end_inset

.
 Now we omit 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x\,\triangleright$
\end_inset


\begin_inset Quotes erd
\end_inset

 and obtain a point-free equation: 
\begin_inset Formula 
\begin{align}
\Delta\text{ is a right inverse of }\pi_{1}:\quad & \Delta\bef\pi_{1}=\text{id}\quad.\label{eq:pair-identity-law-left}
\end{align}

\end_inset

The same property holds for 
\begin_inset Formula $\pi_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pair product of functions|textit
\end_layout

\end_inset


\series bold
pair product
\series default
 operation 
\begin_inset Formula $f\boxtimes g$
\end_inset

 is defined for any functions 
\begin_inset Formula $f^{:A\rightarrow P}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow Q}$
\end_inset

 by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pairProduct[A,B,P,Q](f: A => P, g: B => Q): ((A, B)) => (P, Q) = {
\end_layout

\begin_layout Plain Layout

    case (a, b) => (f(a), g(b))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
f\boxtimes g:A\times B\rightarrow P\times Q\quad,\quad\quad f\boxtimes g\triangleq a\times b\rightarrow f(a)\times g(b)\quad.
\]

\end_inset

Two properties of this operation follow directly from its definition:
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of pair product
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of pair product
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
\text{composition law}:\quad & (f^{:A\rightarrow P}\boxtimes g^{:B\rightarrow Q})\bef(m^{:P\rightarrow X}\boxtimes n^{:Q\rightarrow Y})=(f\bef m)\boxtimes(g\bef n)\quad,\label{eq:pair-product-composition-law}\\
\text{left and right projection laws}:\quad & (f^{:A\rightarrow P}\boxtimes g^{:B\rightarrow Q})\bef\pi_{1}=\pi_{1}\bef f\quad,\quad\quad(f\boxtimes g)\bef\pi_{2}=\pi_{2}\bef g\quad,\label{eq:pair-product-projection-laws}\\
\text{identity law}:\quad & \text{id}^{A}\boxtimes\text{id}^{B}=\text{id}^{A\times B}\quad.\nonumber 
\end{align}

\end_inset

An equivalent way of defining 
\begin_inset Formula $f\boxtimes g$
\end_inset

 is via this Scala code,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pairProduct[A,B,P,Q](f: A => P, g: B => Q)(p: (A, B)): (P, Q)  =  (f(p._1),
 g(p._2))
\end_layout

\end_inset


\begin_inset Formula 
\[
f\boxtimes g=p^{:A\times B}\rightarrow f(p\triangleright\pi_{1})\times g(p\triangleright\pi_{2})=p\rightarrow(p\triangleright\pi_{1}\triangleright f)\times(p\triangleright\pi_{2}\triangleright g)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The pair product notation can shorten calculations with functors that involve
 product types (tuples).
 For example, the lifting for the functor 
\begin_inset Formula $F^{A}\triangleq A\times A\times Z$
\end_inset

 can be shortened to
\begin_inset Formula 
\[
f^{\uparrow F}\triangleq\big(a_{1}^{:A}\times a_{2}^{:A}\times z^{:Z}\rightarrow f(a_{1})\times f(a_{2})\times z\big)=f\boxtimes f\boxtimes\text{id}\quad.
\]

\end_inset

The last formula is often more convenient in symbolic derivations.
 
\end_layout

\begin_layout Subsection
Deriving laws for functions with known implementations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Deriving-laws-for-functions-"

\end_inset


\end_layout

\begin_layout Standard
The task is to prove a given law (an equation) for a function whose code
 is known.
 An example of such an equation is the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of the function 
\begin_inset Formula $\Delta$
\end_inset


\end_layout

\end_inset

naturality law of 
\begin_inset Formula $\Delta$
\end_inset

, which states that for any function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 we have
\begin_inset Formula 
\begin{equation}
f\bef\Delta=\Delta\bef(f\boxtimes f)\quad.\label{eq:naturality-law-of-Delta}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Laws for fully parametric functions are often written without type annotations.
 However, it is important to check that types match.
 So we begin by finding suitable type parameters for Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-Delta"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Since it is given that 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $A\rightarrow B$
\end_inset

, the function 
\begin_inset Formula $\Delta$
\end_inset

 in the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-Delta"
plural "false"
caps "false"
noprefix "false"

\end_inset

) must take arguments of type 
\begin_inset Formula $B$
\end_inset

 and thus returns a value of type 
\begin_inset Formula $B\times B$
\end_inset

.
 We see that the left-hand side must be a function of type 
\begin_inset Formula $A\rightarrow B\times B$
\end_inset

.
 So, the 
\begin_inset Formula $\Delta$
\end_inset

 in the right-hand side must take arguments of type 
\begin_inset Formula $A$
\end_inset

.
 It then returns a value of type 
\begin_inset Formula $A\times A$
\end_inset

, which is consumed by 
\begin_inset Formula $f\boxtimes f$
\end_inset

.
 In this way, we see that all types match.
 We can put the resulting types into a type diagram and write the law with
 type annotations:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "25col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.6pc}\xyScaleX{4.0pc}A\ar[d]\sb(0.45){f}\ar[r]\sb(0.45){\Delta^{A}} & A\times A\ar[d]\sp(0.45){f\boxtimes f}\\
B\ar[r]\sp(0.45){\Delta^{B}} & B\times B
}
\]

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -30baselineskip%
\end_inset


\begin_inset Formula 
\[
f^{:A\rightarrow B}\bef\Delta^{:B\rightarrow B\times B}=\Delta^{:A\rightarrow A\times A}\bef(f\boxtimes f)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
To prove the law, we need to use the known code of the function 
\begin_inset Formula $\Delta$
\end_inset

.
 We substitute that code into the left-hand side of the law and into the
 right-hand side of the law, hoping to transform these two expressions until
 they are the same.
\end_layout

\begin_layout Standard
We will now perform this computation in the Scala syntax and in the code
 notation.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x.pipe(f andThen delta)
\end_layout

\begin_layout Plain Layout

  == (f(x)).pipe { a => (a, a) }
\end_layout

\begin_layout Plain Layout

  == (f(x), f(x)) // Left-hand side.
\end_layout

\begin_layout Plain Layout

x.pipe(delta andThen { case (a, b) => (f(a), f(b)) })
\end_layout

\begin_layout Plain Layout

  == (x, x).pipe { case (a, b) => (f(a), f(b)) }
\end_layout

\begin_layout Plain Layout

  == (f(x), f(x)) // Right-hand side.
\end_layout

\end_inset


\begin_inset VSpace -300baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -140baselineskip%
\end_inset


\begin_inset Formula 
\begin{align*}
 & x\triangleright f\bef\Delta=f(x)\,\gunderline{\triangleright\,(b}\rightarrow b\times b)\\
 & \quad=f(x)\times f(x)\quad.\\
 & \gunderline{x\triangleright\Delta}\,\bef(f\boxtimes f)\\
 & \quad=(x\times x)\gunderline{\,\triangleright\,(a\times b}\rightarrow f(a)\times f(b))\\
 & \quad=f(x)\times f(x)\quad.
\end{align*}

\end_inset


\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\begin_layout Standard
At each step of the derivation, typically there is only one symbolic transformat
ion we can perform.
 In the example above, each step either substitutes a definition of a known
 function or applies some function to an argument and computes the result.
 To help us remember what was done, we use a green underline as a hint indicatin
g a sub-expression to be modified in that step.
 
\end_layout

\begin_layout Standard
We will prefer to derive laws in the code notation rather than in Scala
 syntax.
 The code notation covers all fully parametric code, i.e., all programs that
 use only the nine basic code constructions.
\end_layout

\begin_layout Subsection
Working with disjunctive types in matrix notation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Working-with-disjunctive-functions"

\end_inset


\end_layout

\begin_layout Standard
The matrix notation provides a general way of performing symbolic derivations
 with disjunctive types in point-free style (the matrix elements are 
\emph on
functions
\emph default
).
 Writing all code matrices with type annotations makes it easier to translate
 between matrices and Scala code.
\end_layout

\begin_layout Standard
In many cases, the rules of matrix multiplication and function composition
 are sufficient for calculating with disjunctive types.
 For example, consider the following functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge[A]
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "46col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap[A]: Either[A, A] => Either[A, A] = {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => Right(a)
\end_layout

\begin_layout Plain Layout

    case Right(a)   => Left(a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def merge[A]: Either[A, A] => A = {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => a
\end_layout

\begin_layout Plain Layout

    case Right(a)   => a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -120baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{swap}^{A}\triangleq\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & \bbnum 0 & \text{id}\\
A & \text{id} & \bbnum 0
\end{array}\quad,~\quad\text{merge}^{A}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -40baselineskip%
\end_inset


\end_layout

\begin_layout Standard
We can quickly prove by matrix composition that 
\begin_inset Formula $\text{swap}\bef\text{swap}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{swap}\bef\text{merge}=\text{merge}$
\end_inset

:
\begin_inset VSpace 0baselineskip%
\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{swap}\bef\text{swap}=\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\\
\text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\\
\text{id} & \bbnum 0
\end{array}\,=\,\begin{array}{||cc|}
\text{id}\bef\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\bef\text{id}
\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\,=\text{id}\quad,\\
 & \text{swap}\bef\text{merge}=\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\\
\text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,=\,\begin{array}{||c|}
\text{id}\bef\text{id}\\
\text{id}\bef\text{id}
\end{array}\,=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,=\text{merge}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The identity function for any disjunctive type, e.g., 
\begin_inset Formula $A+B+C$
\end_inset

, is the 
\begin_inset Quotes eld
\end_inset

identity diagonal
\begin_inset Quotes erd
\end_inset

 matrix:
\begin_inset Formula 
\[
\text{id}^{:A+B+C\rightarrow A+B+C}=\,\begin{array}{|c||ccc|}
 & A & B & C\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
B & \bbnum 0 & \text{id} & \bbnum 0\\
C & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
As another example, consider the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for the functor 
\begin_inset Formula $E^{A}\triangleq A+A$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "60col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Either[A, A] => Either[B, B] = {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => Left(f(a))
\end_layout

\begin_layout Plain Layout

    case Right(a)   => Right(f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -165baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -145baselineskip%
\end_inset


\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow E}\triangleq\,\begin{array}{|c||cc|}
 & B & B\\
\hline A & f & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -70baselineskip%
\end_inset


\end_layout

\begin_layout Standard
With this definition, we can formulate a law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

, called the 
\begin_inset Quotes eld
\end_inset

naturality law
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
merge
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "30col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.6pc}\xyScaleX{4.0pc}A+A\ar[d]\sb(0.45){f^{\uparrow E}}\ar[r]\sb(0.55){\text{merge}^{A}} & A\ar[d]\sp(0.45){f}\\
B+B\ar[r]\sp(0.55){\text{merge}^{B}} & B
}
\]

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -30baselineskip%
\end_inset


\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow E}\bef\text{merge}^{B}=\text{merge}^{A}\bef f^{:A\rightarrow B}\quad.
\]

\end_inset

Proving this law is a simple matrix calculation:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & f^{\uparrow E}\bef\text{merge}=\,\begin{array}{||cc|}
f & \bbnum 0\\
\bbnum 0 & f
\end{array}\,\bef\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,=\,\begin{array}{||c|}
f\bef\text{id}\\
f\bef\text{id}
\end{array}\,=\,\begin{array}{||c|}
f\\
f
\end{array}\quad,\\
\text{right-hand side}:\quad & \text{merge}\bef f=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,\bef\gunderline f=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,\bef\,\begin{array}{||c|}
f\end{array}\,=\,\begin{array}{||c|}
\text{id}\bef f\\
\text{id}\bef f
\end{array}\,=\,\begin{array}{||c|}
f\\
f
\end{array}\quad.
\end{align*}

\end_inset

In the last line we replaced 
\begin_inset Formula $f$
\end_inset

 by a 
\begin_inset Formula $1\times1$
\end_inset

 matrix, 
\begin_inset Formula $\,\begin{array}{||c|}
f\end{array}$
\end_inset


\begin_inset space ~
\end_inset

, in order to apply matrix composition.
\end_layout

\begin_layout Standard
Matrix rows and columns can be split or merged when necessary to accommodate
 various disjunctive types.
 As an example, let us verify the 
\begin_inset Quotes eld
\end_inset

associativity law
\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of 
\family typewriter
merge
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "30col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -180baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{4.5pc}E^{A+A}\ar[d]\sp(0.45){\text{merge}^{\uparrow E}}\ar[r]\sp(0.55){\text{merge}^{A+A}} & A+A\ar[d]\sb(0.5){\text{merge}^{A}}\\
E^{A}\ar[r]\sb(0.55){\text{merge}^{A}} & A
}
\]

\end_inset


\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -30baselineskip%
\end_inset


\begin_inset Formula 
\[
(\text{merge}^{A})^{\uparrow E}\bef\text{merge}^{A}=\text{merge}^{A+A}\bef\text{merge}^{A}\quad.
\]

\end_inset

Both sides of this law are functions of type 
\begin_inset Formula $A+A+A+A\rightarrow A$
\end_inset

.
 To transform the left-hand side, we use the definition of 
\begin_inset Formula $^{\uparrow E}$
\end_inset

 and write:
\begin_inset Formula 
\[
\text{merge}^{\uparrow E}\bef\text{merge}=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A+A & \text{merge} & \bbnum 0\\
A+A & \bbnum 0 & \text{merge}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A+A & \text{merge}\\
A+A & \text{merge}
\end{array}\quad.
\]

\end_inset

However, we have not yet substituted the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 into the matrix.
 To do that, add more rows to the matrix in order to accommodate the disjunctive
 type 
\begin_inset Formula $(A+A)+(A+A)$
\end_inset

:
\begin_inset Formula 
\[
\text{merge}^{\uparrow E}\bef\text{merge}=\,\begin{array}{|c||c|}
 & A\\
\hline A+A & \text{merge}\\
A+A & \text{merge}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}\\
A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset

Now we compute the right-hand side of the law by substituting the code of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{merge}^{A+A}\bef\text{merge}^{A}=\,\begin{array}{|c||c|}
 & A+A\\
\hline A+A & \text{id}\\
A+A & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset

We cannot proceed with matrix composition because the dimensions of the
 matrices do not match.
 To compute further, we need to expand the rows and the columns of the first
 matrix:
\begin_inset Formula 
\[
\begin{array}{|c||c|}
 & A+A\\
\hline A+A & \text{id}\\
A+A & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}\\
A & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}\\
A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset

This proves the law (and also helps visualize how the transformations work
 with various types).
\end_layout

\begin_layout Standard
In some cases, we cannot fully split the rows or the columns of a matrix.
 For instance, if we are calculating with an arbitrary function 
\begin_inset Formula $f^{:\bbnum 1+A\rightarrow\bbnum 1+B}$
\end_inset

, we cannot write that function in a form of a 
\begin_inset Formula $2\times2$
\end_inset

 matrix because we do not know which parts of the disjunction are returned
 (the code of the function 
\begin_inset Formula $f$
\end_inset

 is arbitrary and unknown).
 At most, we could split the 
\emph on
rows
\emph default
 by expressing the function 
\begin_inset Formula $f$
\end_inset

 through two unknown functions 
\begin_inset Formula $g^{:\bbnum 1\rightarrow\bbnum 1+B}$
\end_inset

 and 
\begin_inset Formula $h^{:A\rightarrow\bbnum 1+B}$
\end_inset

:
\begin_inset Formula 
\[
f=\,\begin{array}{|c||c|}
 & \bbnum 1+B\\
\hline \bbnum 1 & g\\
A & h
\end{array}\quad.
\]

\end_inset

The single column of this matrix remains unsplit.
 Either that column will remain unsplit throughout the derivation, or additional
 information about 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, or 
\begin_inset Formula $h$
\end_inset

 will allow us to split the column.
\end_layout

\begin_layout Standard
Finally, there are two tricks that complement the matrix intuition and may
 sometimes simplify a disjunctive function.
\begin_inset Foot
status open

\begin_layout Plain Layout
These tricks are adapted from Section
\begin_inset space ~
\end_inset

2.8 of the book 
\begin_inset Quotes eld
\end_inset

Program design by calculation
\begin_inset Quotes erd
\end_inset

 (draft version of October 2019), see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://www4.di.uminho.pt/~jno/ps/pdbc.pdf"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ignored arguments
\end_layout

\begin_layout Standard
If all rows of the disjunctive function ignore their arguments and always
 return the same results, we may collapse all rows into one, as shown in
 this example:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -20baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def same[A]: Either[A, Option[A]] => Option[A] = {
\end_layout

\begin_layout Plain Layout

    case Left(a)          => None
\end_layout

\begin_layout Plain Layout

    case Right(None)      => None
\end_layout

\begin_layout Plain Layout

    case Right(Some(a))   => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -300baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -140baselineskip%
\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{same}^{:A+\bbnum 1+A\rightarrow\bbnum 1+A}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline A & \_\rightarrow1 & \bbnum 0\\
\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
A & \_\rightarrow1 & \bbnum 0
\end{array}\\
 & =\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline A+\bbnum 1+A & \_\rightarrow1 & \bbnum 0
\end{array}\quad.
\end{align*}

\end_inset


\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\begin_layout Standard
A more general formula for arbitrary functions 
\begin_inset Formula $f^{:X\rightarrow C}$
\end_inset

 is
\begin_inset Formula 
\[
x^{:X}\rightarrow p^{:A+B}\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & \_\rightarrow f(x)\\
B & \_\rightarrow f(x)
\end{array}\,=x^{:X}\rightarrow f(x)=f\quad.
\]

\end_inset

In this case, we can completely collapse the matrix, getting an ordinary
 (non-disjunctive) function.
\end_layout

\begin_layout Paragraph
Simplification of diagonal pair products
\end_layout

\begin_layout Standard
Consider the pair product of two disjunctive functions such as 
\begin_inset Formula $f^{:A+B\rightarrow R}$
\end_inset

 and 
\begin_inset Formula $g^{:P+Q\rightarrow S}$
\end_inset

.
 Computing 
\begin_inset Formula $f\boxtimes g$
\end_inset

 in the matrix notation requires, in general, to split the rows and the
 columns of the matrices because the type of 
\begin_inset Formula $f\boxtimes g$
\end_inset

 is 
\begin_inset Formula 
\begin{align*}
f\boxtimes g & :(A+B)\times(P+Q)\rightarrow R\times S\\
 & \cong A\times P+A\times Q+B\times P+B\times Q\rightarrow R\times S\quad.
\end{align*}

\end_inset

So, the pair product of two 
\begin_inset Formula $2\times1$
\end_inset

 matrices must be written 
\emph on
in general
\emph default
 as a 
\begin_inset Formula $4\times1$
\end_inset

 matrix:
\begin_inset Formula 
\[
\text{for any }f\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline A & f_{1}\\
B & f_{2}
\end{array}\quad\text{and}\quad g\triangleq\,\begin{array}{|c||c|}
 & S\\
\hline P & g_{1}\\
Q & g_{2}
\end{array}\quad,\quad\text{we have }\quad f\boxtimes g=\,\begin{array}{|c||c|}
 & R\times S\\
\hline A\times P & f_{1}\boxtimes g_{1}\\
A\times Q & f_{1}\boxtimes g_{2}\\
B\times P & f_{2}\boxtimes g_{1}\\
B\times Q & f_{2}\boxtimes g_{2}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
A simplification trick exists when the pair product is composed with the
 diagonal function 
\begin_inset Formula $\Delta$
\end_inset

:
\begin_inset Formula 
\[
\Delta\bef(f\boxtimes g)=\Delta^{:A+B\rightarrow(A+B)\times(A+B)}\bef(f^{:A+B\rightarrow R}\boxtimes g^{:A+B\rightarrow S})=p\rightarrow f(p)\times g(p)\quad.
\]

\end_inset

This 
\begin_inset Quotes eld
\end_inset

diagonal pair product
\begin_inset Quotes erd
\end_inset

 is well-typed only if 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 have the same argument types (so, 
\begin_inset Formula $A=P$
\end_inset

 and 
\begin_inset Formula $B=Q$
\end_inset

).
 It turns out that the function 
\begin_inset Formula $\Delta\bef(f\boxtimes g)$
\end_inset

 can be written as a 
\begin_inset Formula $2\times1$
\end_inset

 matrix, i.e., we do not need to split the rows:
\begin_inset Formula 
\[
\text{for any }f\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline A & f_{1}\\
B & f_{2}
\end{array}\quad\text{and}\quad g\triangleq\,\begin{array}{|c||c|}
 & S\\
\hline A & g_{1}\\
B & g_{2}
\end{array}\quad,\quad\text{we have }\quad\Delta\bef(f\boxtimes g)=\,\begin{array}{|c||c|}
 & R\times S\\
\hline A & \Delta\bef(f_{1}\boxtimes g_{1})\\
B & \Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\quad.
\]

\end_inset

The rules of matrix multiplication do not help in deriving this law.
 So, we use a more basic approach: show that both sides are equal when applied
 to arbitrary values 
\begin_inset Formula $p$
\end_inset

 of type 
\begin_inset Formula $A+B$
\end_inset

,
\begin_inset Formula 
\[
p^{:A+B}\triangleright\Delta\bef(f\boxtimes g)=f(p)\times g(p)\overset{?}{=}p\triangleright\,\begin{array}{|c||c|}
 & R\times S\\
\hline A & \Delta\bef(f_{1}\boxtimes g_{1})\\
B & \Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\quad.
\]

\end_inset

The type 
\begin_inset Formula $A+B$
\end_inset

 has two cases.
 Applying the left-hand side to 
\begin_inset Formula $p\triangleq a^{:A}+\bbnum 0^{:B}$
\end_inset

, we get
\begin_inset Formula 
\begin{align*}
 & f(p)\times g(p)=\big((a^{:A}+\bbnum 0^{:B})\triangleright f\big)\times\big((a^{:A}+\bbnum 0^{:B})\triangleright g\big)\\
 & \quad=\big(\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
f_{1}\\
f_{2}
\end{array}\,\big)\times\big(\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
g_{1}\\
g_{2}
\end{array}\,\big)=\big(a\triangleright f_{1}\big)\times\big(a\triangleright g_{1}\big)=f_{1}(a)\times g_{1}(a)\quad.
\end{align*}

\end_inset

Applying the right-hand side to the same 
\begin_inset Formula $p$
\end_inset

, we find
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f_{1}(a)\times g_{1}(a):\quad & \gunderline p\triangleright\,\begin{array}{||c|}
\Delta\bef(f_{1}\boxtimes g_{1})\\
\Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\,=\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
\Delta\bef(f_{1}\boxtimes g_{1})\\
\Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\,=\gunderline{a\triangleright\Delta}\,\bef(f_{1}\boxtimes g_{1})\\
\text{definition of }\Delta:\quad & \quad=(a\times a)\triangleright(f_{1}\boxtimes g_{1})=f_{1}(a)\times g_{1}(a)\quad.
\end{align*}

\end_inset

A similar calculation with 
\begin_inset Formula $p\triangleq\bbnum 0^{:A}+b^{:B}$
\end_inset

 shows that both sides of the law are equal to 
\begin_inset Formula $f_{2}(b)\times g_{2}(b)$
\end_inset

.
\end_layout

\begin_layout Subsection
Derivations involving unknown functions with laws
\end_layout

\begin_layout Standard
A more challenging task is to derive an equation that uses arbitrary functions
 about which we only know that they satisfy certain given laws.
 Such derivations usually proceed by trying to transform the code until
 the given laws can be applied.
\end_layout

\begin_layout Standard
As an example, let us derive the property that 
\begin_inset Formula $L^{A}\triangleq A\times F^{A}$
\end_inset

 is a functor if 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is known to be a functor.
 We are in the situation where we only know that the function 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 exists and satisfies the functor law, but we do not know the code of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

.
 Let us discover the derivation step by step.
\end_layout

\begin_layout Standard
First, we need to define 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

.
 We use the lifting notation 
\begin_inset Formula $^{\uparrow F}$
\end_inset

 and write, for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_L[A, B](f: A => B): ((A, F[A])) => (B, F[B]) = { case (a, p) =>
 (f(a), p.map(f)) }
\end_layout

\end_inset


\begin_inset Formula 
\[
f^{\uparrow L}\triangleq a^{:A}\times p^{:F^{A}}\rightarrow f(a)\times(p\triangleright f^{\uparrow F})\quad.
\]

\end_inset

To verify the identity law of 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{id}^{\uparrow L}=a^{:A}\times p^{:F^{A}}\rightarrow\text{id}\,(a)\times(p\triangleright\text{id}^{\uparrow F})=\text{???}
\end{align*}

\end_inset

At this point, the only things we can simplify are the identity functions
 applied to arguments.
 We know that 
\begin_inset Formula $F$
\end_inset

 is a lawful functor; therefore, 
\begin_inset Formula $\text{id}^{\uparrow F}=\text{id}$
\end_inset

.
 So we continue the derivation, omitting types:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{id}^{\uparrow L}=a\times p\rightarrow\gunderline{\text{id}\,(a)}\times(p\triangleright\gunderline{\text{id}^{\uparrow F}})\\
\text{identity law of }F:\quad & =a\times p\rightarrow a\times(\gunderline{p\triangleright\text{id}})\\
\text{apply function}:\quad & =a\times p\rightarrow a\times p=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law of 
\begin_inset Formula $L$
\end_inset

, we assume two arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(f\bef g)^{\uparrow L}:\quad & f^{\uparrow L}\bef g^{\uparrow L}=\big(a\times p\rightarrow f(a)\times f^{\uparrow F}(p)\big)\bef\big(b\times q\rightarrow g(b)\times g^{\uparrow F}(q)\big)\quad.
\end{align*}

\end_inset

At this point, we pause and try to see how we might proceed.
 We do not know anything about 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

, so we cannot evaluate 
\begin_inset Formula $f(a)$
\end_inset

 or 
\begin_inset Formula $f^{\uparrow F}(p)$
\end_inset

.
 We also do not have the code of 
\begin_inset Formula $^{\uparrow F}$
\end_inset

 (i.e., of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

).
 The only information we have about these functions is that 
\begin_inset Formula $F$
\end_inset

's composition law holds,
\begin_inset Formula 
\begin{equation}
f^{\uparrow F}\bef g^{\uparrow F}=(f\bef g)^{\uparrow F}\quad.\label{eq:composition-law-F-derivation1}
\end{equation}

\end_inset

We could use this law only if we somehow bring 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 and 
\begin_inset Formula $g^{\uparrow F}$
\end_inset

 together in the formula.
 The only way forward is to compute the function composition of the two
 functions whose code we 
\emph on
do
\emph default
 have:
\begin_inset Formula 
\begin{align*}
 & \big(a\times p\rightarrow f(a)\times f^{\uparrow F}(p)\big)\bef\big(b\times q\rightarrow g(b)\times g^{\uparrow F}(q)\big)\\
 & =a\times p\rightarrow g(f(a))\times g^{\uparrow F}(f^{\uparrow F}(p))\quad.
\end{align*}

\end_inset

In order to use the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-F-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to rewrite this code via the composition 
\begin_inset Formula $f\bef g$
\end_inset

.
 We notice that the formula contains exactly those function compositions:
\begin_inset Formula 
\[
g(f(a))\times g^{\uparrow F}(f^{\uparrow F}(p))=(a\triangleright f\bef g)\times(p\triangleright f^{\uparrow F}\bef g^{\uparrow F})\quad.
\]

\end_inset

So, we can now apply the composition law of 
\begin_inset Formula $F$
\end_inset

 and write up the complete derivation, adding hints:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(f\bef g)^{\uparrow L}:\quad & f^{\uparrow L}\bef g^{\uparrow L}=\big(a\times p\rightarrow f(a)\times f^{\uparrow F}(p)\big)\bef\big(b\times q\rightarrow g(b)\times g^{\uparrow F}(q)\big)\\
\text{compute composition}:\quad & =a\times p\rightarrow\gunderline{g(f(a))}\times\gunderline{g^{\uparrow F}(f^{\uparrow F}(p))}\\
\triangleright\text{-notation}:\quad & =a\times p\rightarrow(a\triangleright f\bef g)\times\big(p\triangleright\gunderline{f^{\uparrow F}\bef g^{\uparrow F}}\big)\\
\text{composition law of }F:\quad & =a\times p\rightarrow(a\triangleright\gunderline{f\bef g})\times\big(p\triangleright(\gunderline{f\bef g})^{\uparrow F}\big)\\
\text{definition of }^{\uparrow L}:\quad & =(f\bef g)^{\uparrow L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The derivation becomes significantly shorter if we use the pair product
 (
\begin_inset Formula $\boxtimes$
\end_inset

) to define 
\begin_inset Formula $^{\uparrow L}$
\end_inset

:
\begin_inset Formula 
\[
f^{\uparrow L}\triangleq\text{id}\boxtimes f^{\uparrow F}\quad.
\]

\end_inset

For instance, verifying the identity law then looks like this:
\begin_inset Formula 
\[
\text{id}^{\uparrow L}=\text{id}\boxtimes\text{id}^{\uparrow F}=\text{id}\boxtimes\text{id}=\text{id}\quad.
\]

\end_inset

This technique was used in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The cost of having a shorter proof is the need to remember the properties
 of the pair product (
\begin_inset Formula $\boxtimes$
\end_inset

), which is not often used in derivations.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume given functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

 and a natural transformation 
\begin_inset Formula $\phi:F^{A}\rightarrow G^{A}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Prove that 
\begin_inset Formula $\phi^{\uparrow K}:K^{F^{A}}\rightarrow K^{G^{A}}$
\end_inset

 is also a natural transformation.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Given another natural transformation 
\begin_inset Formula $\psi:K^{A}\rightarrow L^{A}$
\end_inset

, prove that the pair product of 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

, that is, 
\begin_inset Formula $\phi\boxtimes\psi:F^{A}\times K^{A}\rightarrow G^{A}\times L^{A}$
\end_inset

, as well as the pair co-product 
\begin_inset Formula $\phi\boxplus\psi:F^{A}+K^{A}\rightarrow G^{A}+L^{A}$
\end_inset

, are also natural transformations.
 The 
\series bold
pair co-product
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pair co-product of functions|textit
\end_layout

\end_inset

 of two functions 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

 is defined by
\begin_inset Formula 
\[
(\phi\boxplus\psi):F^{A}+K^{A}\rightarrow G^{A}+L^{A}\quad,\quad\quad\phi\boxplus\psi\triangleq\,\begin{array}{|c||cc|}
 & G^{A} & L^{A}\\
\hline F^{A} & \phi & \bbnum 0\\
K^{A} & \bbnum 0 & \psi
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show using matrix calculations that 
\begin_inset Formula $\text{swap}\bef\text{swap}=\text{id}$
\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is the function defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Working-with-disjunctive-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Now consider a different function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap[A, B]
\end_layout

\end_inset

 defined as
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "63col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap[A, B]: ((A, B)) => (B, A) = { case (a, b) => (b, a) }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -125baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{swap}^{A,B}\triangleq a^{:A}\times b^{:B}\rightarrow b\times a\quad.
\]

\end_inset


\begin_inset VSpace -15baselineskip%
\end_inset

Show that 
\begin_inset Formula $\Delta\bef\text{swap}=\Delta$
\end_inset

.
 Write out all types in this law and draw a type diagram.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given an arbitrary functor 
\begin_inset Formula $F$
\end_inset

, define the functor 
\begin_inset Formula $L^{A}\triangleq F^{A}\times F^{A}$
\end_inset

 and prove, for an arbitrary function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, the 
\begin_inset Quotes eld
\end_inset

lifted naturality
\begin_inset Quotes erd
\end_inset

 law
\begin_inset Formula 
\[
f^{\uparrow F}\bef\Delta=\Delta\bef f^{\uparrow L}\quad.
\]

\end_inset

Write out all types in this law and draw a type diagram.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the types 
\begin_inset Formula $(\bbnum 1+\bbnum 1)\times A$
\end_inset

 and 
\begin_inset Formula $A+A$
\end_inset

 are equivalent.
 One direction of this equivalence is given by a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

two[A]
\end_layout

\end_inset

 with the type signature
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "63col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def two[A]: ((Either[Unit, Unit], A)) => Either[A, A] = ???
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace -115baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{two}^{A}:(\bbnum 1+\bbnum 1)\times A\rightarrow A+A\quad.
\]

\end_inset


\begin_inset VSpace -35baselineskip%
\end_inset

Implement that function and prove that it satisfies the 
\begin_inset Quotes eld
\end_inset

naturality law
\begin_inset Quotes erd
\end_inset

: for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
(\text{id}\boxtimes f)\bef\text{two}=\text{two}\bef f^{\uparrow E}\quad,
\]

\end_inset

where 
\begin_inset Formula $E^{A}\triangleq A+A$
\end_inset

 is the functor whose lifting 
\begin_inset Formula $^{\uparrow E}$
\end_inset

 was defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Working-with-disjunctive-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Write out the types in this law and draw a type diagram.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove that the following laws hold for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:C\rightarrow D}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left projection law}:\quad & (f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f\quad,\\
\text{right projection law}:\quad & (f\boxtimes g)\bef\pi_{2}=\pi_{2}\bef g\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given arbitrary functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, define the functor 
\begin_inset Formula $L^{A}\triangleq F^{A}\times G^{A}$
\end_inset

 and prove that for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow L}\bef\pi_{1}=\pi_{1}\bef f^{\uparrow F}\quad.
\]

\end_inset

Write out the types in this naturality law and draw a type diagram.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the functor 
\begin_inset Formula $L^{A}$
\end_inset

 defined as 
\begin_inset Formula 
\[
L^{A}\triangleq\text{Int}\times\text{Int}+A\quad.
\]

\end_inset

Implement the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

) and write their code in matrix notation:
\begin_inset Formula 
\begin{align*}
(f^{:A\rightarrow B})^{\uparrow L} & :\text{Int}\times\text{Int}+A\rightarrow\text{Int}\times\text{Int}+B\quad,\\
\text{ftn}_{L} & :\text{Int}\times\text{Int}+\text{Int}\times\text{Int}+A\rightarrow\text{Int}\times\text{Int}+A\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

) from Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 satisfies the naturality law: for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, we have 
\begin_inset Formula $f^{\uparrow L\uparrow L}\bef\text{ftn}_{L}=\text{ftn}_{L}\bef f^{\uparrow L}$
\end_inset

.
\end_layout

\end_body
\end_document
