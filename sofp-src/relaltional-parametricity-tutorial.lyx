#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Relational parametricity]{Relational parametricity and "theorems for free"}
\subtitle{A tutorial, with example code in Scala}
\author{Sergei Winitzki}
\date{2021-09-04}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\usepackage[nocenter]{qtree}
\usepackage{relsize}
\renewcommand\arraystretch{1.4}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for parametricity.
 
\begin_inset Quotes eld
\end_inset

Theorems for free
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Parametricity
\series default
: all fully parametric functions satisfy their naturality laws
\end_layout

\begin_layout Itemize
Naturality law: code must work in the same way for all types
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def headOption[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case Nil            => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case head :: tail   => Some(head)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Quotes eld
\end_inset

Fully parametric
\begin_inset Quotes erd
\end_inset


\series default
 code: use only type parameters, no JVM reflection 
\end_layout

\begin_deeper
\begin_layout Itemize
Naturality laws are 
\begin_inset Quotes eld
\end_inset

for free
\begin_inset Quotes erd
\end_inset

 only if all code is fully parametric
\end_layout

\end_deeper
\begin_layout Itemize
Naturality law for 
\family typewriter
\size small
\color blue
headOption
\family default
\size default
\color inherit
: for any 
\family typewriter
\size small
\color blue
x:
\begin_inset space ~
\end_inset

List[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
,
\end_layout

\begin_layout LyX-Code

\size small
\color blue
headOption(x).map(f) == headOption(x.map(f))
\end_layout

\begin_layout Standard
Parametricity theorems work only if the code is 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Parametricity theorems apply only to a subset of a programming language
\end_layout

\begin_layout Itemize
Usually, it is a certain flavor of typed lambda calculus
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of code that fails parametricity 
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Explicit matching on type parameters using JVM reflection:
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def badHeadOpt[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case Nil                 => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case (head: Int) :: tail => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case head :: tail        => Some(head)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Standard
Using typeclasses: define typeclass 
\size small
\color blue
NotInt[A]
\size default
\color inherit
 returning 
\size small
\color blue
true
\size default
\color inherit
 unless 
\size small
\color blue
A = Int
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def badHeadOpt[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case h :: tail if implicitly[NotInt[A]]()   => Some(h)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case _ => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Standard
Failure of naturality law:
\end_layout

\begin_layout LyX-Code

\size small
\color blue
scala> badHeadOpt(List(10, 20, 30).map(x => s"x = $x"))
\end_layout

\begin_layout LyX-Code

\size small
\color blue
res0: Option[String] = Some(x = 10)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size small
\color blue
scala> badHeadOpt(List(10, 20, 30)).map(x => s"x = $x")
\end_layout

\begin_layout LyX-Code

\size small
\color blue
res1: Option[String] = None
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace 100baselineskip%
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Fully parametric programs are written using the 9 code constructions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = { // 3
\end_layout

\begin_layout Plain Layout

   case Nil            => Nil
\end_layout

\begin_layout Plain Layout

//   8   1                1,7 
\end_layout

\begin_layout Plain Layout

   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

//   8       6             2 4     6  5 2 4     6    7   9
\end_layout

\begin_layout Plain Layout

}           // This code uses each of the nine allowed constructions.
\end_layout

\end_inset


\begin_inset VSpace -20baselineskip%
\end_inset


\end_layout

\begin_layout Enumerate
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value (or equivalent type), e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use bound variable (a given argument of the function)
\end_layout

\begin_layout Enumerate
Create a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr(x) }
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create a product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create a co-product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a co-product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...
 => ...
 }
\end_layout

\end_inset

 (pattern-matching)
\end_layout

\begin_layout Enumerate
Use a recursive call: e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

 within the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why we need relational parametricity
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Relational parametricity
\begin_inset Quotes erd
\end_inset

 is a method for proving parametricity theorems
\end_layout

\begin_layout Itemize
Main papers: 
\begin_inset CommandInset href
LatexCommand href
name "Reynolds (1983)"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

 and Wadler 
\begin_inset CommandInset href
LatexCommand href
name "“Theorems for free”"
target "https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf"
literal "false"

\end_inset

 (1989)
\end_layout

\begin_deeper
\begin_layout Itemize
Those papers are a bit outdated and also quite hard to understand 
\end_layout

\end_deeper
\begin_layout Itemize
There are very few pedagogical tutorials on relational parametricity
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "On a relation of functions"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Backhouse (1990) 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "The algebra of programming"
target "https://themattchan.com/docs/algprog.pdf"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Bird and O.
\begin_inset space ~
\end_inset

de Moor (1997)
\end_layout

\end_deeper
\begin_layout Standard
This tutorial does 
\emph on
not
\emph default
 follow Reynolds-Wadler but derives equivalent results
\end_layout

\begin_layout Itemize
Alternative approach: prove 
\begin_inset Quotes eld
\end_inset

dinaturality
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "de Lataillade"
target "https://www.irif.fr/~delatail/dinat.pdf"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Voigtl\\\"ander"
target "https://arxiv.org/pdf/1908.07776"
literal "true"

\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
In practice, dinaturality laws are sufficient in most cases
\end_layout

\begin_layout Itemize
But some proofs still need full relational parametricity
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivating relational parametricity.
 I.
 Naturality laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Naturality law: applying 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

F[A] => G[A]
\family default
\size default
\color inherit
 
\emph on
before
\emph default
 
\family typewriter
\size small
\color blue
_.map(f)
\family default
\size default
\color inherit
 equals applying 
\family typewriter
\size small
\color blue
t[B]:
\begin_inset space ~
\end_inset

F[B] => G[B]
\family default
\size default
\color inherit
 
\emph on
after
\emph default
 
\family typewriter
\size small
\color blue
_.map(f)
\family default
\size default
\color inherit
 for any function 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\end_layout

\begin_layout Standard
Naturality laws need 
\emph on
lifting
\emph default
 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
F[A] => F[B]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[A] => G[B
\family default
\size default
\color inherit
] 
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar[d]\sb(0.5){~\mathtt{\_.map(f)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar[d]\sp(0.5){\mathtt{\_.map(f)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset


\end_layout

\begin_layout Itemize
Proof of the naturality law requires induction on the code of 
\family typewriter
\size small
\color blue
t[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
This code is built up by combining the 9 code constructions
\end_layout

\begin_layout Itemize
This code may include sub-expressions of types not covariant in 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivating relational parametricity.
 II.
 The difficulty
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Cannot lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
F[A] => F[B]
\family default
\size default
\color inherit
 when 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 is not covariant!
\end_layout

\begin_layout Itemize
For covariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 we lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
fmap(f):
\begin_inset space ~
\end_inset

F[A] => F[B]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
For contravariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 we lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

B => A
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
cmap(f):
\begin_inset space ~
\end_inset

F[A] => F[B]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
In general, 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 will be neither covariant nor contravariant
\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size small
\color blue
foldLeft
\family default
\size default
\color inherit
 with respect to type parameter 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
def foldLeft[T, A]: List[T] => (T => A => A) => A => A
\end_layout

\begin_layout Itemize
This is 
\emph on
not
\emph default
 of the form 
\family typewriter
\size small
\color blue
F[A] => G[A]
\family default
\size default
\color inherit
 with covariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[_]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Some occurrences of 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 are in covariant positions but other occurrences are in contravariant positions
, all mixed up
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivating relational parametricity.
 III.
 Profunctor liftings
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The solution involves four nontrivial steps:
\end_layout

\begin_layout Enumerate
Introduce profunctors 
\family typewriter
\size small
\color blue
P[-X, +Y]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
Q[-X, +Y]
\family default
\size default
\color inherit
 instead of 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[A]
\family default
\size default
\color inherit
 so that 
\family typewriter
\size small
\color blue
F[A] = P[A, A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[A] = Q[A, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Every type parameter is in a covariant or in a contravariant position
\end_layout

\begin_layout Itemize
Rename contravariant positions to 
\family typewriter
\size small
\color blue
X
\family default
\size default
\color inherit
 and contravariant ones to 
\family typewriter
\size small
\color blue
Y
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Enumerate
Replace functions 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 by relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Instead of 
\family typewriter
\size small
\color blue
b == f(a)
\family default
\size default
\color inherit
 we will write 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 (i.e., 
\begin_inset Formula $a\times b\in r$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Enumerate
Turns out, we can lift 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
rmap(r):
\begin_inset space ~
\end_inset

P[A, A] <=> P[B, B]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Enumerate
Reformulate the naturality law of 
\family typewriter
\size small
\color blue
t
\family default
\size default
\color inherit
 via relations: for any 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
,
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{P[A,~A]}\ar@{<->}[d]\sb(0.5){~\mathtt{rmap(r)}\text{ for }\mathtt{P}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{Q[A,~A]}\ar@{<->}[d]\sp(0.5){\mathtt{rmap(r)}\text{ for }\mathtt{Q}}\\
\mathtt{P[B,~B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{Q[B,~B]}
}
\]

\end_inset

To read the diagram: the starting values are on the left
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 I.
 Examples of relations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A function 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

X => Y
\family default
\size default
\color inherit
 can be viewed as a relation 
\family typewriter
\size small
\color blue
rel(f):
\begin_inset space ~
\end_inset

X <=> Y
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
rel(identity:
\begin_inset space ~
\end_inset

X => X)
\family default
\size default
\color inherit
 defines an 
\series bold
identity
\series default
 relation 
\family typewriter
\size small
\color blue
id:
\begin_inset space ~
\end_inset

X <=> X
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Given two functions 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

X => Z
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

Y => Z
\family default
\size default
\color inherit
, define a relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

X <=> Y
\family default
\size default
\color inherit
 as:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
(x: X, y: Y) in r 
\family default
\size default
\color inherit
means
\family typewriter
\size small
\color blue
 f(x) == g(y)
\end_layout

\begin_layout Itemize
This relation 
\family typewriter
\size small
\color blue
r
\family default
\size default
\color inherit
 is 
\emph on
not
\emph default
 equivalent to any function 
\family typewriter
\size small
\color blue
X => Y
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
Y => X
\end_layout

\begin_layout Standard
Relation combinators:
\end_layout

\begin_layout Itemize
For any relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

X <=> Y
\family default
\size default
\color inherit
, the 
\series bold
inverse
\series default
 relation is 
\family typewriter
\size small
\color blue
inv(r):
\begin_inset space ~
\end_inset

Y <=> X
\end_layout

\begin_deeper
\begin_layout Itemize
The inverse operation is its own inverse: 
\family typewriter
\size small
\color blue
inv(inv(r)) == r
\end_layout

\end_deeper
\begin_layout Itemize
For any relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

X <=> Y
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s:
\begin_inset space ~
\end_inset

Y <=> Z
\family default
\size default
\color inherit
 define the 
\series bold
composition
\series default
 (
\family typewriter
\size small
\color blue
r compose s
\family default
\size default
\color inherit
) as a relation 
\family typewriter
\size small
\color blue
u:
\begin_inset space ~
\end_inset

X <=> Z
\family default
\size default
\color inherit
 by 
\family typewriter
\size small
\color blue
(x:
\begin_inset space ~
\end_inset

X, z:
\begin_inset space ~
\end_inset

Z) in u
\family default
\size default
\color inherit
 when there exists 
\family typewriter
\size small
\color blue
y:
\begin_inset space ~
\end_inset

Y
\family default
\size default
\color inherit
 such that 
\family typewriter
\size small
\color blue
(x, y) in r 
\family default
\size default
\color inherit
and 
\family typewriter
\size small
\color blue
(y, z) in s
\end_layout

\begin_deeper
\begin_layout Itemize
Directionality law: 
\family typewriter
\size small
\color blue
inv(r compose s) == inv(s) compose inv(r)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Associativity and identity laws with respect to 
\family typewriter
\size small
\color blue
id:
\begin_inset space ~
\end_inset

X <=> X
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Itemize
For any relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

X <=> Y
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s:
\begin_inset space ~
\end_inset

X <=> Y
\family default
\size default
\color inherit
, get the union (
\family typewriter
\size small
\color blue
r or s
\family default
\size default
\color inherit
) and the intersection (
\family typewriter
\size small
\color blue
r and s
\family default
\size default
\color inherit
):
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
(x, y) in (r and s) 
\family default
\size default
\color inherit
means
\family typewriter
\size small
\color blue
 (x, y) in r
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(x, y) in s
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
(x, y) in (r or s) 
\family default
\size default
\color inherit
means
\family typewriter
\size small
\color blue
 (x, y) in r
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
(x, y) in s
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 II.
 Definition of 
\family typewriter
rmap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 for 
\family typewriter
\size small
\color blue
P[X, Y]
\family default
\size default
\color inherit
 by induction over the 
\emph on
type expression
\emph default
 of 
\family typewriter
\size small
\color blue
P[X, Y]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
There are seven possibilities (given that the code is fully parametric):
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
P[X, Y] = Unit
\family default
\size default
\color inherit
 or another fixed type
\end_layout

\begin_layout Enumerate
The identity functor: 
\family typewriter
\size small
\color blue
P[X, Y] = Y
\family default
\size default
\color inherit
 (so we have 
\family typewriter
\size small
\color blue
P[A, A] = A
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Enumerate
Product type: 
\family typewriter
\size small
\color blue
P[X, Y] = (F[X, Y], G[X, Y])
\end_layout

\begin_layout Enumerate
Co-product type: 
\family typewriter
\size small
\color blue
P[X, Y] = Either[F[X, Y], G[X, Y]]
\end_layout

\begin_layout Enumerate
Function type: 
\family typewriter
\size small
\color blue
P[X, Y] = F[X, Y] => G[X, Y]
\end_layout

\begin_layout Enumerate
Recursive type: 
\family typewriter
\size small
\color blue
P[X, Y] = F[X, Y, P[X, Y]]
\end_layout

\begin_layout Enumerate
Universally quantified type: 
\family typewriter
\size small
\color blue
P[X, Y] = [Z] => F[X, Y, Z]
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 similarly to how the functor's 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 is defined in these cases
\end_layout

\begin_layout Standard
The inductive assumption is that liftings to 
\family typewriter
\size small
\color blue
F
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G
\family default
\size default
\color inherit
 are already defined
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 II.
 Definition of 
\family typewriter
rmap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Need to define 
\family typewriter
\size small
\color blue
rmap(r):
\begin_inset space ~
\end_inset

P[A, A] <=> P[B, B]
\family default
\size default
\color inherit
 in these cases:
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
P[X, Y] = T
\family default
\size default
\color inherit
 (a fixed type): define 
\family typewriter
\size small
\color blue
rmap(r) = id: T <=> T
\end_layout

\begin_layout Enumerate
The identity functor, 
\family typewriter
\size small
\color blue
P[X, Y] = Y
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
rmap(r) = r: A <=> B
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
P[X, Y] = (F[X, Y], G[X, Y])
\family default
\size default
\color inherit
: define
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
((f1, f2), (g1, g2)) in rmap_P(r)
\family default
\size default
\color inherit
 to mean
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
(f1, f2) in rmap_F(r)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(g1, g2) in rmap_G(r)
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
P[X, Y] = Either[F[X, Y], G[X, Y]]
\family default
\size default
\color inherit
: either 
\family typewriter
\size small
\color blue
(Left(f1), Left(f2)) in rmap(r)
\family default
\size default
\color inherit
 when 
\family typewriter
\size small
\color blue
(f1, f2) in rmap_F(r)
\family default
\size default
\color inherit
 or
\size small
\color blue
 
\family typewriter
(Right(g1), Right(g2)) in rmap(r)
\family default
\size default
\color inherit
 when 
\family typewriter
\size small
\color blue
(g1, g2) in rmap_G(r)
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
P[X, Y] = F[Y, X] => G[X, Y]
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
(p1, p2) in rmap(r)
\family default
\size default
\color inherit
 to mean 
\family typewriter
\size small
\color blue
(p1(f1), p2(f2)) in rmap_G(r)
\family default
\size default
\color inherit
 for any 
\family typewriter
\size small
\color blue
f1: F[A, A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
f2: F[B, B]
\family default
\size default
\color inherit
 such that 
\family typewriter
\size small
\color blue
(f1, f2) in rmap_F(r)
\end_layout

\begin_layout Enumerate
When 
\end_layout

\begin_layout Enumerate
***
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 III.
 Examples of using 
\family typewriter
rmap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Most resources for modern FP are either too academic or too limited to questions
 of practical usage 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Relational parametricity is a powerful technique
\end_layout

\begin_layout Itemize
It has been generalized to many different settings
\end_layout

\begin_deeper
\begin_layout Itemize
Gradual typing, higher-kinded types, dependent types, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Relational parametricity has a steep learning curve
\end_layout

\begin_deeper
\begin_layout Itemize
Cannot directly write code that manipulates relations
\end_layout

\begin_layout Itemize
All calculations need to be done symbolically or with proof assistants
\end_layout

\end_deeper
\begin_layout Itemize
The result may be a relation that is difficult to interpret as code
\end_layout

\begin_layout Itemize
A couple of results in FP do require the relational naturality law
\end_layout

\begin_layout Itemize
More details in the free book — 
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\begin_layout Standard

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "27col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename book-draft-cover.png
	lyxscale 20
	width 2.5cm

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
