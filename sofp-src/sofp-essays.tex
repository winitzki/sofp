
\chapter{``Applied functional type theory'': A proposal\label{chap:Applied-functional-type}}

What exactly is the extent of ``theory'' that a software engineer
must know in order to be a proficient functional programmer? This
book proposes an answer to that question by presenting a coherent
body of theoretical knowledge that, in the author's view, is the ``theory
that is practically useful for functional programming''. This body
of knowledge may be viewed as a new branch of computer science \textemdash{}\textbf{
\index{applied functional type theory}applied functional type theory}
(AFTT). This is the area of theoretical computer science serving the
practical needs of functional programmers working as software engineers.

It is for these practitioners, rather than for academic researchers,
that this book sets out to examine the functional programming inventions
over the last 30 years, \textendash{} such as the \textquotedblleft functional
pearls\textquotedblright{} papers\footnote{\texttt{\href{https://wiki.haskell.org/Research_papers/Functional_pearls}{https://wiki.haskell.org/Research\_papers/Functional\_pearls}}}
\textendash{} and to determine the scope of theoretical material that
has demonstrated its pragmatic usefulness and thus belongs to AFTT,
as opposed to material that is purely academic and may be tentatively
omitted. This book is a first step towards formulating AFTT.

In this book, code is written in Scala because the author is fluent
in that language. However, most of this material will work equally
well in Haskell, OCaml, and other FP languages. This is so because
the science of functional programming, call ed AFTT, is not a set
of tricks specific to Scala or Haskell. An advanced user of any other
functional programming language will have to face the same questions
and struggle with the same practical issues.

\section{AFTT is not covered by computer science curricula}

Traditional courses of theoretical computer science (algorithms and
data structures, complexity theory, distributed systems, databases,
network systems, compilers, operating systems) are largely not relevant
to AFTT. Courses in programming language theory are more relevant
but are not presented at an appropriate level. As an example: To an
academic computer scientist, the ``science behind Haskell'' is the
theory of lambda-calculus, the type-theoretic ``System $F\omega$'',
and formal semantics. These theories guided the design of the Haskell
language and define rigorously what a Haskell program ``means''
in a mathematical sense. Academic computer science curricula typically
present these theories at the graduate level. 

However, a practicing Haskell or Scala programmer is not concerned
with designing Haskell or Scala, or with proving any theoretical properties
of those languages. A practicing programmer is mainly concerned with
\emph{using} a chosen programming language to \emph{write code}. 

Neither the theory of lambda-calculus, nor proofs of type-theoretical
properties of ``System $F\omega$'', nor theories of formal semantics,
nor domain theory will actually help a programmer to write code. So
all these theories are not within the scope of AFTT. It appears that
functional programming does not require graduate-level theoretical
studies.

As an example of theoretical material that \emph{is} within the scope
of AFTT, consider applicative functors (see Chapter~\ref{chap:8-Applicative-functors,-contrafunc}).\index{applicative functor}
It is essential for a practicing functional programmer to be able
to recognize and use applicative functors. An applicative functor
is a data structure specifying declaratively a set of operations that
can run independently of each other. Programs may combine these operations,
for example, to execute them in parallel, or to refactor the program
for better maintainability.

To use this functionality, the programmer must begin by checking whether
a given data structure satisfies the laws of applicative functors.
In a given application, a data structure may be dictated in part by
the business logic rather than by a programmer's choice. The programmer
first writes down the type of that data structure and the code implementing
the required methods, and then checks that the laws hold. The data
structure may need to be adjusted in order to fit the definition of
an applicative functor or its laws.

So, before starting to write the actual code, the programmer needs
to perform a certain amount of symbolic reasoning and calculation.
That work is best done using pen and paper, writing equations in a
mathematical notation. Once the applicative laws are verified, the
programmer proceeds to write code using that data structure.

Because of the mathematical proofs, it is assured that the data structure
satisfies the properties of applicative functors, no matter how the
rest of the program is written. So, for example, it is assured that
the relevant effects can be automatically parallelized and will still
work correctly. In this way, AFTT directly guides the programmer and
helps to write correct code.

Applicative functors were discovered by practitioners who were using
Haskell in applications such as parser combinators, compilers, and
domain-specific languages for parallel computations. However, applicative
functors are not a feature of Haskell: they can be used in Scala or
any other functional programming language. And yet, no standard computer
science textbook defines applicative functors, motivates their laws,
explores their structure on examples, or shows data structures that
are \emph{not} applicative functors and explains why. Books on category
theory and type theory rarely ever mention applicative functors (known
in mathematics as ``lax monoidal'' functors\footnote{\texttt{\href{https://en.wikipedia.org/wiki/Monoidal_functor}{https://en.wikipedia.org/wiki/Monoidal\_functor}}}).

\section{AFTT is not category theory, type theory, or formal logic}

It appears that AFTT includes a selection of certain areas of category
theory, formal logic, and type theory. However, software engineers
would not benefit from traditional academic courses in these subjects,
because their presentation is too abstract and at the same time lacks
specific results necessary for practical programming. In other words,
the traditional academic courses answer questions that academic computer
scientists have, not questions that practicing software engineers
have.

There exist several books intended as presentations of category theory
``for computer scientists'' or ``for programmers''. However, those
books do not explain many concepts relevant to programming, such as
applicative or traversable functors. Instead, those books dwell on
concepts (e.g.~limits, enriched categories, topoi) that have no applications
in practical functional programming today.

Typical questions in academic books are ``Is $X$ an introduction
rule or an elimination rule'' and ``Does property $Y$ hold in non-small
categories or only in the category of sets''. Questions a Scala programmer
might have are ``Can we compute a value of type \lstinline!Either[Z, R => A]!
from a value of type \lstinline!R => Either[Z, A]!'' and ``Is the
type constructor \lstinline!F[A] = Option[(A,A,A)]! a monad or only
an applicative functor''. The scope of AFTT includes answering the
last two questions but \emph{not} the first two.

A software engineer hoping to understand the foundations of functional
programming will not find the concepts of filterable, applicative,
or traversable functors in any books on category theory, including
books intended for programmers. And yet, these concepts are necessary
to obtain a mathematically correct implementation of such foundationally
important operations as \lstinline!filter!, \lstinline!zip!, and
\lstinline!traverse! \textendash{} operations that functional programmers
often use in their code.

To compensate for the lack of AFTT textbooks, programmers have written
many online tutorials for each other, trying to explain the theoretical
concepts necessary for practical work. There are the infamous ``monad
tutorials'', but also tutorials about applicative functors, traversable
functors, free monads, and so on. These tutorials tend to be hands-on
(``run this code now and see what happens'') and narrow in scope,
limited to one or two specific questions and specific applications.
Such tutorials usually do not present sufficient mathematical insights.

For example, ``free monads'' became popular in the Scala community
around 2015. Many talks about free monads were presented at Scala
engineering conferences, each giving their own slightly different
implementation but never formulating rigorously the properties required
for a piece of code to be a valid implementation of the free monad.
Without knowing the required mathematical properties of free monads,
a programmer cannot make sure that a given implementation is correct.
However, books on category theory define free monads in a way that
is unsuitable for programming applications: a free monad is an adjoint
functor to a forgetful functor from a Kleisli category to the category
of sets. (``\emph{A monad is just a monoid in the category of endofunctors.
What's the problem?}'' as the joke\footnote{\texttt{\href{https://stackoverflow.com/questions/3870088/}{https://stackoverflow.com/questions/3870088/}}}
goes.) Such definitions are far too abstract for practical use: for
instance, they do not help at all if our task is to implement the
free monad in code and to verify its correctness.

Perhaps the best selection of AFTT tutorial material today can be
found in the Haskell Wikibooks.\footnote{\texttt{\href{https://en.wikibooks.org/wiki/Haskell}{https://en.wikibooks.org/wiki/Haskell}}}
However, those tutorials are incomplete and limited to explaining
the use of Haskell. Many of them are suitable neither as a first introduction
nor as a reference on AFTT. Also, the Haskell Wikibooks tutorials
rarely show any derivations of laws or explain the required techniques.

Apart from referring to some notions from category theory, AFTT also
uses concepts from type theory and formal logic. However, existing
textbooks on type theory and formal logic focus on domain theory and
proof theory \textendash{} which presents a lot of information that
will be difficult to learn for practicing programmers and yet will
never be applicable in their daily work. At the same time, those academic
books never mention practical techniques used in many functional programming
libraries today, such as reasoning about and implementing quantified
types, types parameterized by type constructors, or partial type-level
functions (known as ``typeclasses'').

The proper scope of AFFT is helping the programmer with practical
tasks such as:
\begin{itemize}
\item Deciding whether two data types are equivalent and implementing the
isomorphism transformations. For example, the Scala type \lstinline!(A, Either[B,C])!
is equivalent to \lstinline!Either[(A,B), (A,C)]!.
\item Checking whether a definition of a recursive type is ``reasonable'',
i.e.~does not lead to infinite loops. An example of an ``unreasonable''
recursive type definition is \lstinline!case class Bad(x: Bad)!.
\item Deciding whether a function with a given type signature can be implemented.
For example, 
\begin{lstlisting}
def f[Z,A,R]: (R => Either[Z, A]) => Either[Z, R => A] = ???   // Cannot be implemented.
def g[Z,A,R]: Either[Z, R => A] => (R => Either[Z, A]) = ???   // Can be implemented.
\end{lstlisting}
\item Deriving an implementation of a function from its type signature and
checking the required laws; for example, deriving the \lstinline!flatMap!
method and checking the laws for the \lstinline!Reader! monad,
\begin{lstlisting}
def flatMap[Z, A, B](r: Z => A)(f: A => Z => B): Z => B = ???
\end{lstlisting}
\end{itemize}
These are real-world applications of type theory and the Curry-Howard
correspondence, but existing books on type theory and logic do not
show practical recipes for performing these tasks.

Books such as \emph{Scala with Cats}\footnote{\texttt{\href{https://underscore.io/books/scala-with-cats/}{https://underscore.io/books/scala-with-cats/}}},
\emph{Functional programming simplified}\footnote{\texttt{\href{https://alvinalexander.com/scala/functional-programming-simplified-book}{https://alvinalexander.com/scala/functional-programming-simplified-book}}},
and \emph{Functional programming for mortals}\footnote{\texttt{\href{http://www.lulu.com/shop/search.ep?contributorId=1600066}{http://www.lulu.com/shop/search.ep?contributorId=1600066}}}
are primarily focused on explaining practical aspects of functional
programming and do not explain the mathematical principles and laws
for e.g.~applicative, monadic, or traversable functors.

The only Scala-based AFTT textbook is \emph{Functional Programming
in Scala}\footnote{\texttt{\href{https://www.manning.com/books/functional-programming-in-scala}{https://www.manning.com/books/functional-programming-in-scala}}},
which balances practical coding with theoretical developments and
equational laws. \emph{Program design by calculation}\footnote{\texttt{\href{http://www4.di.uminho.pt/~jno/ps/pdbc.pdf}{http://www4.di.uminho.pt/$\sim$jno/ps/pdbc.pdf}}}
is another (Haskell-based) AFTT book in progress. The present book,
\emph{Science of Functional Programming}\footnote{\texttt{\href{https://github.com/winitzki/sofp}{https://github.com/winitzki/sofp}}},
is written at about the same level but aims at better motivation for
mathematical concepts and a wider range of examples that help build
the necessary intuition and technique. 

\chapter{Essay: Software engineers and software artisans}

Let us look at the differences between the kind of activities we ordinarily
call engineering, as opposed to artisanship or craftsmanship. It will
then become apparent that today's computer programmers are better
understood as ``software artisans'' rather than software engineers.

\section{Engineering disciplines }

Consider what kinds of process a mechanical engineer, a chemical engineer,
or an electrical engineer follows in their work, and what kind of
studies they require for proficiency in their work.

A mechanical engineer studies\footnote{\texttt{\href{https://www.colorado.edu/mechanical/undergraduate-students/curriculum}{https://www.colorado.edu/mechanical/undergraduate-students/curriculum}}}
calculus, linear algebra, differential geometry, and several areas
of physics such as theoretical mechanics, thermodynamics, and elasticity
theory, and then uses calculations to guide the design of a bridge,
say. A chemical engineer studies\footnote{\texttt{\href{https://www.colorado.edu/engineering/sample-undergraduate-curriculum-chemical}{https://www.colorado.edu/engineering/sample-undergraduate-curriculum-chemical}}}
chemistry, thermodynamics, calculus, linear algebra, differential
equations, some areas of physics such as thermodynamics and kinetic
theory, and uses calculations to guide the design of a chemical process,
say. An electrical engineer studies\footnote{\texttt{\href{http://archive.is/XYLyE}{http://archive.is/XYLyE}}}
advanced calculus, linear algebra, and several areas of physics such
as electrodynamics and quantum theory, and uses calculations to design
an antenna or a microchip.

The pattern here is that an engineer uses mathematics and natural
sciences in order to design new devices. Mathematical calculations
and scientific reasoning are required \emph{before} drawing a design,
let alone building a real device or machine.

Some of the studies required for engineers include arcane abstract
concepts such as a ``rank-4 elasticity tensor''\footnote{\texttt{\href{https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral_physics/tensors.html}{https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral\_physics/tensors.html}}}
(used in calculations of elasticity of materials), ``Lagrangian with
non-holonomic constraints''\footnote{\texttt{\href{https://arxiv.org/abs/math/0008147}{https://arxiv.org/abs/math/0008147}}}
(used in robotics), the ``Gibbs free energy'' (for chemical reactor
design\footnote{\texttt{\href{https://www.amazon.com/Introduction-Chemical-Engineering-Kinetics-Reactor/dp/1118368258}{https://www.amazon.com/Introduction-Chemical-Engineering-Kinetics-Reactor/dp/1118368258}}}),
or the ``Fourier transform of the delta function''\footnote{\texttt{\href{https://www.youtube.com/watch?v=KAbqISZ6SHQ}{https://www.youtube.com/watch?v=KAbqISZ6SHQ}}}
and the ``inverse Z-transform''\footnote{\texttt{\href{http://archive.is/SsJqP}{http://archive.is/SsJqP}}}
(for digital signal processing).

To be sure, a significant part of what engineers do is not covered
by any theory: the \emph{know-how}, the informal reasoning, the traditional
knowledge passed on from expert to novice,  \textemdash{} all those
skills that are hard to formalize are important. Nevertheless, engineering
is crucially based on natural science and mathematics for some of
its decision-making about new designs.

\section{Artisanship: Trades and crafts }

Now consider what kinds of things shoemakers, plumbers, or home painters
do, and what they have to learn in order to become proficient in their
profession.

A novice shoemaker, for example, begins by copying some drawings\footnote{\texttt{\href{https://youtu.be/cY5MY0czMAk?t=141}{https://youtu.be/cY5MY0czMAk?t=141}}}
and goes on to cutting leather in a home workshop. Apprenticeships
proceed via learning by doing, with comments and instructions from
an expert. After a few years of apprenticeship (for example, a painter
apprenticeship in California\footnote{\texttt{\href{http://www.calapprenticeship.org/programs/painter_apprenticeship.php}{http://www.calapprenticeship.org/programs/painter\_apprenticeship.php}}}
can be as short as 2 years), a new specialist is ready to start productive
work. 

All these trades operate entirely from tradition and practical experience.
The trades do not require academic study because there is no formal
theory from which to proceed. Of course, there is \emph{a lot} to
learn in the crafts, and it takes prolonged effort to become a good
artisan in any profession. But there are no rank-4 tensors to calculate,
nor any differential equations to solve; no Fourier transforms to
apply to delta functions, and no Lagrangians to check for non-holonomic
constraints.

Artisans do not study any formal science or mathematics because their
professions do not make use of any \emph{formal computation} for guiding
their designs or processes.

\section{Programmers today are artisans, not engineers }

Programmers are \emph{not engineers} in the sense we normally see
the engineering professions.

\subsection{No requirement of formal study }

According to this recent Stack Overflow survey\footnote{\texttt{\href{https://thenextweb.com/insider/2016/04/23/dont-need-go-college-anymore-programmer/}{https://thenextweb.com/insider/2016/04/23/dont-need-go-college-anymore-programmer/}}},
about half of the programmers do not have a degree in Computer Science.
The author of this book is a self-taught programmer who has degrees
in physics but never formally studied computer science or taken any
academic courses in algorithms, data structures, computer networks,
compilers, programming languages, or other CS topics. 

A large fraction of successful programmers have no college degrees
and perhaps \emph{never} studied formally. They acquired all their
knowledge and skills through self-study and practical work. Robert
C.~Martin\index{Robert C.~Martin}\footnote{\texttt{\href{https://en.wikipedia.org/wiki/Robert_C._Martin}{https://en.wikipedia.org/wiki/Robert\_C.\_Martin}}}
is a prominent example; an outspoken guru in the arts of programming
who has seen it all, he routinely refers to programmers as artisans\footnote{\texttt{\href{https://blog.cleancoder.com/uncle-bob/2013/02/01/The-Humble-Craftsman.html}{https://blog.cleancoder.com/uncle-bob/2013/02/01/The-Humble-Craftsman.html}}}
and uses the appropriate imagery: novices, trade and craft, the ``honor
of the guild'', etc. He compares programmers to plumbers, electricians,
lawyers, and surgeons, but never to mathematicians, physicists, or
engineers of any kind. According to one of his blog posts\footnote{\texttt{\href{https://blog.cleancoder.com/uncle-bob/2013/11/25/Novices-Coda.html}{https://blog.cleancoder.com/uncle-bob/2013/11/25/Novices-Coda.html}}},
he started working at age 17 as a self-taught programmer, and then
went on to more jobs in the software industry; he never mentions going
to college. It is clear that R.~C.~Martin \emph{is} an expert craftsman,
and that he did \emph{not} need academic study to master his craft.

Here is another opinion\footnote{\texttt{\href{http://archive.is/tAKQ3}{http://archive.is/tAKQ3}}}
(emphasis is theirs):
\begin{quotation}
{\small{}Software Engineering is unique among the STEM careers in
that it absolutely does }\emph{\small{}not}{\small{} require a college
degree to be successful. It most certainly does not require licensing
or certification. }\emph{\small{}It requires experience}{\small{}.}{\small\par}
\end{quotation}
This description fits a career in crafts \textendash{} but certainly
not a career, say, in electrical engineering.

The high demand for software developers gave rise to ``developer
boot camps''\footnote{\texttt{\href{http://archive.is/GkOL9}{http://archive.is/GkOL9}}}
\textemdash{} vocational schools that educate new programmers in a
few months through purely practical training, with no formal theory
or mathematics involved. These vocational schools are successful\footnote{\texttt{\href{http://archive.is/E9FXP}{http://archive.is/E9FXP}}}
in job placement. But it is unimaginable that a 6-month crash course
or even a 2-year vocational school could prepare an engineer to work
successfully on say, quantum computers\footnote{\texttt{\href{https://www.dwavesys.com/quantum-computing}{https://www.dwavesys.com/quantum-computing}}}
without ever having studied quantum physics or calculus.

\subsection{No mathematical formalism guides software development}

Most books on software engineering contain no formulas or equations,
no mathematical derivations of any results, and no precise definitions
of the various technical terms they are using (such as ``object-oriented''
or ``software architecture''). Some of those books\footnote{E.g.~\texttt{\href{https://www.amazon.com/Object-Oriented-Software-Engineering-Unified-Methodology/dp/0073376256}{https://www.amazon.com/Object-Oriented-Software-Engineering-Unified-Methodology/dp/0073376256}}}
have almost no program code in them; instead they are filled with
words and illustrative diagrams. These books talk about how programmers
should approach their job, how to organize the work flow and the code
architecture, etc., in vague and general terms: ``code is about detail'',
``you must never abandon the big picture'', ``you should avoid
tight coupling in your modules'', ``a class must serve a single
responsibility'', and so on. Practitioners such as R.\ C.\ Martin
never studied any formalisms and do not think in terms of formalisms;
instead they think in vaguely formulated, heuristic \textquotedblleft principles\textquotedblright .\footnote{\texttt{\href{https://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html}{https://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html}}}

In contrast, textbooks on mechanical or electrical engineering include
a significant amount of mathematics. The design of a microwave antenna
is guided not by an ``open and closed module principle'' but by
solving the relevant differential equations\footnote{\texttt{\href{https://youtu.be/8KpfVsJ5Jw4?t=447}{https://youtu.be/8KpfVsJ5Jw4?t=447}}}
coming from electrodynamics.

Donald Knuth's classic textbook is called ``\emph{The Art of Programming}''.
It is full of tips and tricks about how to program; but it does not
provide any formal theory that could guide programmers in actually
\emph{writing} programs. There is nothing in that book that would
be similar to the way mathematical formalism guides designs in electrical
or mechanical engineering. If Knuth's books were based on such formalism,
they would have looked quite differently: some theory would be first
explained and then applied to help us write code.

Knuth's books provide many rigorously derived algorithms. But algorithms
are similar to patented inventions: they can be used immediately without
further study. Understanding an algorithm is not similar to understanding
a mathematical theory. Knowing one algorithm does not make it easier
to develop another algorithm in an unrelated domain. In comparison,
knowing how to solve differential equations will be applicable to
thousands of different areas of science and engineering.

A book exists\footnote{\texttt{\href{https://www.amazon.com/Science-Programming-Monographs-Computer/dp/0387964800}{https://www.amazon.com/Science-Programming-Monographs-Computer/dp/0387964800}}}
with the title ``Science of Programming'', but the title is misleading.
The author does not propose a science, similar to physics, at the
foundation of the process of designing programs, similarly to how
calculations in quantum physics predict the properties of a quantum
device. The book claims to give precise methods that guide programmers
in writing code, but the scope of proposed methods is narrow: the
design of simple algorithms for iterative manipulation of data. The
procedure suggested in that book is far from a formal mathematical
\emph{derivation} of programs from specifications. (A book with that
title\footnote{\texttt{\href{https://www.amazon.com/Program-Derivation-Development-Specifications-International/dp/0201416247}{https://www.amazon.com/Program-Derivation-Development-Specifications-International/dp/0201416247}}}
also exists, and similarly disappoints.) In any case, programmers
today are oblivious to these books and do not use the methods explained
there.

Standard computer science courses today do not teach a true \emph{engineering}
aproach to software construction. They do teach analysis of programs
using formal mathematical methods; the main such methods are complexity
analysis\footnote{\texttt{\href{https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic\%20Complexity/complexity.html}{https://www.cs.cmu.edu/$\sim$adamchik/15-121/lectures/Algorithmic\%20Complexity/complexity.html}}}
(the ``big-$O$ notation'') and formal verification\footnote{\texttt{\href{https://en.wikipedia.org/wiki/Formal_verification}{https://en.wikipedia.org/wiki/Formal\_verification}}}.
But programs are analyzed or verified only \emph{after} they are complete.
Theory does not guide the actual \emph{process} of writing code, does
not suggest good ways of organizing the code (e.g.~choosing which
classes or functions or modules should be defined), and does not tell
programmers which data structures or APIs would be best to implement.
Programmers make these design decisions purely on the basis of experience
and intuition, trial-and-error, copy-paste, and guesswork. 

The theory of program analysis and verification is somewhat analogous
to writing a mathematical equation for the surface of a shoe made
by a fashion designer. True, the ``shoe surface equations'' are
mathematically rigorous and can be ``analyzed'' or ``verified'';
but the equations are written after the fact and do not guide the
fashion designers in actually making shoes. It is understandable that
fashion designers do not study the mathematical theory of surfaces.

\subsection{Programmers avoid academic terminology }

Programmers jokingly grumble about terms such as ``functor'', ``monad'',
or ``lambda-functions'':
\begin{quote}
{\small{}Those fancy words used by functional programmers purists
really annoy me. Monads, functors... Nonsense!!! }\footnote{\texttt{\href{http://archive.is/65K3D}{http://archive.is/65K3D}}}
\end{quote}
Perhaps only a small minority of software developers actually complain
about this; the vast majority seems to remain unaware of ``functors''
and ``monads''.

However, chemical engineers accept the need for studying differential
equations and do not mind using the terms ``phase diagram'' or ``Gibbs
free energy''. Electrical engineers do not complain that the word
``Fourier'' is difficult to spell, or that ``delta-function''
is a weird thing to say. Mechanical engineers take it for granted
that they need to calculate with ``tensors'' and ``Lagrangians''
and ``non-holonomic constraints''. The arcane terminology seems
to be the least of their difficulties, as their textbooks are full
of complicated equations and long derivations.

Similarly, software engineers would not complain about the word ``functor'',
or about having to study the derivation of the algebraic laws for
``monads,'' \textemdash{} if they were true engineers. Textbooks
on true software engineering would have been full of equations and
derivations, in order to teach engineers how to perform certain calculations
that are required \emph{before} starting to write code.

\section{Towards software engineering }

It is now clear that we do not presently have true software engineering.
The people employed under that job title are actually artisans. They
work using artisanal methods, and their culture and processes are
that of a crafts guild.

One could point out that numerical simulations required for physics
or the matrix calculations required for machine learning are ``mathematical''.
True, these programming \emph{tasks} are mathematical in nature and
require formal theory to be \emph{formulated}. However, mathematical
\emph{subject matter} (aerospace control, physics or astronomy experiments,
mathematical statistics, etc.) does not mean that the process of programming
is a form of engineering. Data scientists, aerospace engineers, and
natural scientists all write code nowadays \textemdash{} and they
are all working as artisans when they write code.

True software engineering means having a theory that guides and informs
the process of creating programs, \textemdash{} not theory that describes
or analyzes programs after they are \emph{somehow} written.

We expect that software engineers' textbooks should be full of equations.
What theory should those equations represent?

I believe this theory already exists, and I call it \textbf{applied
functional type theory}\index{applied functional type theory}. It
is the algebraic foundation of the modern practice of functional programming,
as implemented in languages such as OCaml, Haskell, and Scala. This
theory is a blend of type theory, category theory, and logical proof
theory. It has been in development since late 1990s and is still being
actively worked on by a community of academic computer scientists
and advanced software practitioners.

To appreciate that functional programming, unlike any other programming
paradigm, \emph{has a theory that guides coding}, we can look at some
recent software engineering conferences such as ``Scala By the Bay''\footnote{\texttt{\href{http://2015.scala.bythebay.io/}{http://2015.scala.bythebay.io/}}}
or BayHac\footnote{\texttt{\href{http://bayhac.org/}{http://bayhac.org/}}},
or at the numerous FP-related online tutorials and blogs. We cannot
fail to notice that much time is devoted not to showing code but to
a peculiar kind of mathematical reasoning. Rather than focusing on
one or another API or algorithm, as it is often the case with other
software engineering blogs or presentations, an FP speaker describes
a \emph{mathematical structure} \textemdash{} such as the ``applicative
functor''\footnote{\texttt{\href{http://www.youtube.com/watch?v=bmIxIslimVY}{http://www.youtube.com/watch?v=bmIxIslimVY}}}
or the ``free monad''\footnote{\texttt{\href{http://www.youtube.com/watch?v=U0lK0hnbc4U}{http://www.youtube.com/watch?v=U0lK0hnbc4U}}}
\textemdash{} and illustrates its use for practical coding.

These people are not graduate students showing off their theoretical
research; they are practitioners, software engineers who use FP on
their jobs. It is just the nature of FP that certain mathematical
tools \textemdash{} coming from formal logic and category theory \textemdash{}
are now directly applicable to practical programming tasks.

These mathematical tools are not mere tricks for a specific programming
language; they apply equally to all FP languages. Before starting
to write code, the programmer can jot down certain calculations in
a mathematical notation (see Fig.\ \ref{fig:Example-calculation-in-type-theory}).
The results of those calculations will help design the code fragment
the programmer is about to write. This activity is similar to that
of an engineer who performs some mathematical calculations before
embarking on a design project.\begin{wrapfigure}{I}{0.5\textwidth}%
\begin{centering}
{\footnotesize{}\vspace{-0.5\baselineskip}
\includegraphics[width=1\linewidth]{ftt-example}\vspace{-0.5\baselineskip}
}{\footnotesize\par}
\par\end{centering}
{\footnotesize{}\caption{A programmer performs a derivation before writing Haskell code.\label{fig:Example-calculation-in-type-theory}}
}{\footnotesize\par}

\vspace{-0.5\baselineskip}
\end{wrapfigure}%
A recent example of the hand-in-hand development of the functional
type theory and its applications is seen in the ``free applicative
functor'' construction. It was first described in a 2014 paper\footnote{\texttt{\href{https://arxiv.org/pdf/1403.0749.pdf}{https://arxiv.org/pdf/1403.0749.pdf}}};
a couple of years later, a combined free applicative / free monad
data type was designed and its implementation proposed \footnote{\texttt{\href{https://github.com/typelevel/cats/issues/983}{https://github.com/typelevel/cats/issues/983}}}
as well as in Haskell\footnote{\texttt{\href{https://elvishjerricco.github.io/2016/04/08/applicative-effects-in-free-monads.html}{https://elvishjerricco.github.io/2016/04/08/applicative-effects-in-free-monads.html}}}.
This technique allows programmers to implement declarative side-effect
computations where some parts are sequential but other parts are computed
in parallel, and to achieve the parallelism \emph{automatically} while
maintaining the composability of the resulting programs. The new technique
has distinct advantages over using monad transformers, which was the
previous method of composing declarative side-effects.

The ``free applicative / free monad'' combination was designed and
implemented by true software engineers. They first wrote down the
types and derived the necessary algebraic properties; the obtained
results directly guided them about how to proceed writing the library
API.

Another example of a development in functional type theory is the
 ``tagless final'' encoding of data types, \href{http://okmij.org/ftp/tagless-final/index.html}{first described in 2009}.
This technique, developed from category theory and type theory motivations,
has several advantages over the free monad technique and can improve
upon it in a number of cases \textemdash{} just as the free monad
itself was designed to cure certain problems with monad transformers\footnote{\texttt{\href{http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/}{http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/}}}.
The new technique is also not a trick in a specific programming language;
rather, it is a theoretical development that is available to programmers
in any language (even in Java\footnote{\texttt{\href{http://archive.is/rLAh9}{http://archive.is/rLAh9}}}).

This example shows that we may need several more years of work before
the practical aspects of using ``functional type theory'' are sufficiently
well understood by the FP community. The theory is in active development,
and its design patterns \textemdash{} as well as the exact scope of
the requisite theoretical material \textemdash{} are still being figured
out. If the 40-year gap hypothesis\footnote{\texttt{\href{http://archive.is/rJc4A}{http://archive.is/rJc4A}}}
holds, we should expect functional type theory (perhaps under a different
name) to become mainstream by 2030. This book is a step towards a
clear designation of the scope of that theory.

\section{Does software need engineers, or are artisans good enough? }

The demand for programmers is growing. ``Software developer'' was
\#1 best job\footnote{\texttt{\href{http://archive.is/cGJ2T}{http://archive.is/cGJ2T}}}
in the US in 2018. But is there a demand for engineers or just for
artisans?

We do not seem to be able\footnote{\texttt{\href{http://archive.is/137b8}{http://archive.is/137b8}}}
to train enough software artisans. So, it is probably impossible to
train as many software engineers in the true sense of the word. Modern
computer science courses do not actually train engineers in that sense;
at best, they train academic researchers who write code as software
artisans. Recalling the situation in construction business, with a
few architects and hundreds of construction workers, we might also
conclude that, perhaps, only a few software engineers are required
per hundred software artisans.

What is the price of \emph{not} having engineers, of replacing them
with artisans?

Software practitioners have long bemoaned the mysterious difficulty
of software development. Code ``rots with time'', its complexity
grows ``out of control'', and operating systems have been notorious
for ever-appearing security flaws\footnote{\texttt{\href{http://archive.fo/HtQzw}{http://archive.fo/HtQzw}}}
despite many thousands of programmers and testers employed. Clearly,
we overestimated the capacity of the human brain for artisanal programming.

It is precisely in designing large and robust software systems that
we would benefit from true engineering. Artisans has been building
bridges and using chemical reactions by following tradition and by
trial and error, long before mechanical or chemical engineering disciplines
were developed and founded upon rigorous theory. But once the theory
became available, engineers proceeded to design unimaginably more
powerful and complicated structures and devices. It is clear that
trial, error, and adherence to tradition is inadequate for the software
development tasks in front of us. 

To build large and reliable software, such as new mobile or embedded
operating systems or distributed peer-to-peer trust architectures,
we will most likely need the qualitative increase in productivity
and reliability that can only come from replacing artisanal programming
by a true engineering discipline. Functional type theory and functional
programming are first steps in that direction.

\chapter{Essay: Towards functional data engineering with Scala}

Data engineering is among the most in-demand\footnote{\texttt{\href{http://archive.is/mK59h}{http://archive.is/mK59h}}}
novel occupations in the IT world today. Data engineers create software
pipelines that process large volumes of data efficiently. Why did
the Scala programming language emerge as a premier tool\footnote{\texttt{\href{https://www.slideshare.net/noootsab/scala-the-unpredicted-lingua-franca-for-data-science}{https://www.slideshare.net/noootsab/scala-the-unpredicted-lingua-franca-for-data-science}}}
for crafting the foundational data engineering technologies such as
Spark or Akka? Why is Scala in such demand\footnote{\texttt{\href{https://techcrunch.com/2016/06/14/scala-is-the-new-golden-child/}{https://techcrunch.com/2016/06/14/scala-is-the-new-golden-child/}}}
within the world of big data?

There are reasons to believe that the choice of Scala was not accidental.

\section{Data is math}

Humanity has been working with data at least since Babylonian tax
tables\footnote{\texttt{\href{https://www.nytimes.com/2017/08/29/science/trigonometry-babylonian-tablet.html}{https://www.nytimes.com/2017/08/29/science/trigonometry-babylonian-tablet.html}}}
and the ancient Chinese number books\footnote{\texttt{\href{http://quatr.us/china/science/chinamath.htm}{http://quatr.us/china/science/chinamath.htm}}}.
Mathematics summarizes several millennia's worth of data processing
experience in a few fundamental tenets:

\begin{wrapfigure}{I}{0.34\columnwidth}%
\begin{centering}
\vspace{-0.65\baselineskip}
\includegraphics[width=0.96\linewidth]{type-error}\vspace{-0.5\baselineskip}
\par\end{centering}
\caption{Mixing incompatible data types produces nonsensical results.\label{fig:A-nonsensical-calculation}}

\vspace{-3.5\baselineskip}
\end{wrapfigure}%

\begin{itemize}
\item Data is \emph{immutable}, because facts are immutable. 
\item Each \emph{type} of values (population count, land area, distances,
prices, times, etc.) needs to be handled separately; it is meaningless
to add a distance to a population count.
\item Data processing should be performed according to \emph{mathematical
formulas}. 
\end{itemize}
Violating these tenets produces nonsense (see Fig.\ \ref{fig:A-nonsensical-calculation}
for a real-life illustration).

The power of the principles of mathematics extends over all epochs
and all cultures; math is the same in San Francisco, in Rio de Janeiro,
in Kuala-Lumpur, and in Pyongyang (Fig.\ \ref{fig:The-Pyongyang-method-of-error-free-programming}).

\section{Functional programming is math}

The functional programming paradigm is based on mathematical principles:
values are immutable, data processing is coded through formula-like
expressions, and each type of data is required to match correctly
during the computations. The type-checking process automatically prevents
programmers from making many kinds of coding errors. In addition,
programming languages such as Scala and Haskell have a set of features
adapted to building powerful abstractions and domain-specific languages.
This power of abstraction is not accidental. Since mathematics is
the ultimate art of building abstractions, math-based functional programming
languages capitalize on the advantage of millennia of mathematical
experience.

A prominent example of how mathematics informs the design of programming
languages is the connection between constructive logic\footnote{\texttt{\href{https://en.wikipedia.org/wiki/Intuitionistic_logic}{https://en.wikipedia.org/wiki/Intuitionistic\_logic}}}
and the programming language's type system, called the Curry-Howard
(CH) correspondence\footnote{\texttt{\href{https://en.wikipedia.org/wiki/Curry\%E2\%80\%93Howard_correspondence}{https://en.wikipedia.org/wiki/Curry\%E2\%80\%93Howard\_correspondence}}}.
The main idea of the CH correspondence\index{Curry-Howard correspondence}
is to think of programs as mathematical formulas that compute a value
of a certain type $A$. The CH correspondence is between programs
and logical propositions: To any program that computes a value of
type $A$, there corresponds a proposition stating that ``a value
of type $A$ can be computed''.

This may sound rather theoretical so far. To see the real value of
the CH correspondence, recall that formal logic has operations ``\textbf{\emph{and}}'',
``\textbf{\emph{or}}'', and ``\textbf{\emph{implies}}''. For any
two propositions $A$, $B$, we can construct the propositions ``$A$
\textbf{\emph{and}} $B$'', ``$A$ \textbf{\emph{or}} $B$'', ``$A$
\textbf{\emph{implies}} $B$''. These three logical operations are
foundational; without one of them, the logic is \emph{incomplete}
(you cannot derive some theorems).

A programming language \textbf{obeys the CH correspondence}\index{Curry-Howard correspondence}
with the logic if for any types $A$, $B$, the language also contains
composite types corresponding to the logical formulas ``$A$ \textbf{\emph{or}}
$B$'', ``$A$ \textbf{\emph{and}} $B$'', ``$A$ \textbf{\emph{implies}}
$B$''. In Scala, these composite types are \texttt{Either{[}A,B{]}},
the tuple \texttt{(A,B)}, and the function type, \texttt{A$\rightarrow$B}.
All modern functional languages such as OCaml, Haskell, Scala, F\#,
Swift, Elm, and PureScript support these three type constructions
and thus are faithful to the CH correspondence. Having a \emph{complete}
logic in a language's type system enables declarative domain-driven
code design\footnote{\texttt{\href{https://fsharpforfunandprofit.com/ddd/}{https://fsharpforfunandprofit.com/ddd/}}}.

\begin{wrapfigure}{I}{0.5\columnwidth}%
\begin{centering}
\vspace{-0.5\baselineskip}
\includegraphics[width=1\linewidth]{no-bugs}\vspace{-0.5\baselineskip}
\par\end{centering}
\caption{The Pyongyang method of error-free software engineering.\label{fig:The-Pyongyang-method-of-error-free-programming}}
\vspace{-3\baselineskip}
\end{wrapfigure}%

It is interesting to note that most older programming languages (C/C++,
Java, JavaScript, Python) do not support some of these composite types.
In other words, these programming languages have type systems based
on an incomplete logic. As a result, users of these languages have
to implement burdensome workarounds that make for error-prone code.
Failure to follow mathematical principles has real costs (Figure~\ref{fig:The-Pyongyang-method-of-error-free-programming}).

\section{The power of abstraction}

Early adopters of Scala, such as Netflix, LinkedIn, and Twitter, were
implementing what is now called ``big data engineering''. The required
software needs to be highly concurrent, distributed, and resilient
to failure. These software companies used Scala as their main implementation
language and reaped the benefits of functional programming.

What makes Scala suitable for big data tasks? The only reliable way
of managing massively concurrent code is to use sufficiently high-level
abstractions that make application code declarative. The two most
important such abstractions are the ``resilient distributed dataset''
(RDD) of Apache Spark and the ``reactive stream'' used in systems
such as Kafka, Akka Streams, and Apache Flink. While these abstractions
are certainly implementable in Java or Python, a fully declarative
and type-safe usage is possible only in a programming language with
a sophisticated functional type system. Among the currently available
mature functional languages, only Scala and Haskell are technically
adequate for that task, due to their support for typeclasses and higher-order
types. The early adopters of Scala were able to reap the benefits
of the powerful abstractions Scala supports. In this way, Scala enabled
those businesses to engineer reliably and to scale up their massively
concurrent computations.

It remains to see why Scala and not, say, Haskell became the \emph{lingua
franca} of big data.

\section{Scala is Java on math }

The recently invented general-purpose functional programming languages
can be grouped into ``industrial'' (F\#, Scala, Swift) and ``academic''
(OCaml, Haskell).

The ``academic'' languages are clean-room implementations of well-researched
mathematical principles of programming language design (the CH correspondence
being one such principle). These languages are unencumbered by requirements
of compatibility with any existing platform or libraries. Because
of this, the ``academic'' languages are perfect playgrounds for
taking various mathematical ideas to their logical conclusion. At
the same time, software practitioners struggle to adopt these languages
due to a steep learning curve, a lack of enterprise-grade libraries
and tool support, and immature package management.

The languages from the ``industrial'' group are based on existing
and mature software ecosystems: F\# on .NET, Scala on JVM, and Swift
on the MacOS/iOS platform. One of the important design requirements
for these languages is 100\% binary compatibility with their ``parent''
platforms and languages (F\# with C\#, Scala with Java, and Swift
with Objective-C). Because of this, developers can immediately take
advantage of the existing tooling, package management, and industry-strength
libraries, while slowly ramping up the idiomatic usage of new language
features. However, the same compatibility requirements necessitated
certain limitations in the languages, making their design less than
fully satisfactory from the functional programming viewpoint.

It is now easy to see why the adoption rate of the ``industrial''
group of languages is much higher\footnote{\texttt{\href{https://www.tiobe.com/tiobe-index/}{https://www.tiobe.com/tiobe-index/}},
archived in 2019 at \texttt{\href{http://archive.is/RsNH8}{http://archive.is/RsNH8}}} than that of the ``academic'' languages. The transition to the
functional paradigm is also made smoother for software developers
because F\#, Scala, and Swift seamlessly support the familiar object-oriented
programming paradigm. At the same time, these new languages still
have logically complete type systems, which gives developers an important
benefit of type-safe domain modeling.

Nevertheless, the type systems of these languages are not equally
powerful. For instance, F\# and Swift are similar to OCaml in many
ways but omit OCaml's parameterized modules and some other features.
Of all mentioned languages, only Scala and Haskell directly support
typeclasses and higher-order types, which are helpful for expressing
abstractions such as automatically parallelized data sets or asynchronous
data streams.

To see the impact of these advanced features, consider LINQ, a domain-specific
language for database queries on .NET, implemented in C\# and F\#
through a special built-in syntax supported by Microsoft's compilers.
Analogous functionality is provided in Scala as a \emph{library},
without need to modify the Scala compiler, by several open-source
projects such as Slick, Squeryl, or Quill. Similar libraries exist
for Haskell \textendash{} but not in languages with less powerful
type systems.

\section{Summary}

The decisive advantages of Scala over other contenders (such as OCaml,
Haskell, F\#, or Swift) are:
\begin{enumerate}
\item Functional collections in the standard library.
\item A sophisticated type system with support for typeclasses and higher-order
types.
\item Seamless compatibility with a mature software ecosystem (JVM).
\end{enumerate}
Based on this assessment, we may be confident in Scala's great future
as a main implementation language for big data engineering. 
