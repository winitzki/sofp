\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%


\chapter{Summary of the book\label{chap:Summary-of-the}}

The book has been written in a tutorial format, motivating and deriving
the results gradually. This makes it easier to learn but harder to
navigate. In this summary chapter, the results are listed without
detailed explanations or proofs, referring to the places of the book
where more detail is found.

\section{Main points and results by chapter}

\setcounter{secnumdepth}{1}%
\begin{comment}
All the following subsections will appear in the TOC but will be unnumbered.
The koma-script package does not have addsubsec. Another solution
could be: 

\% Package 'hyperref' needed for command '\textbackslash nameref'

\textbackslash subsection{*}\{Introduction\} 

\textbackslash label\{subsec:intro\} 

\textbackslash addcontentsline\{toc\}\{subsection\}\{\textbackslash nameref\{subsec:intro\}\}
\end{comment}


\subsection{Chapter~\ref{chap:1-Values,-types,-expressions,}}

Standard mathematical notation such as $\sum_{n=1}^{100}(n^{2}+n)$
implicitly uses nameless functions. Functional programming improves
upon this kind of mathematical notation by using nameless functions
explicitly and consistently. For example, the computation $\sum_{n=1}^{100}(n^{2}+n)$
is implemented in Scala as \lstinline!(1 to 100).map(n => n*n + n).sum!.

The methods \lstinline!sum! and \lstinline!product! are examples
of \textsf{``}aggregations\textsf{''}. The method \lstinline!filter! selects some
elements from a sequence; \lstinline!takeWhile! truncates a sequence
once a certain condition is achieved. Those methods are examples of
\textsf{``}transformations\textsf{''}.

Functional programming means formulating the solution of a problem
as a mathematical expression and then translating the mathematical
formula into code. Mathematical formulas do not use loops and do not
modify variables. Instead, iteration is expressed using special operators
such as $\sum$. Functional programming encodes transformations and
aggregations by using standard library functions such as \lstinline!map!,
\lstinline!filter!, \lstinline!zip!, \lstinline!flatMap!, etc.,
instead of loops.

\subsection{Chapter~\ref{chap:2-Mathematical-induction}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Disjunctive-types}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Higher-order-functions}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:5-Curry-Howard}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Functors,-contrafunctors,-and}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Reasoning-about-code}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Typeclasses-and-functions}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Filterable-functors}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Semimonads-and-monads}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:8-Applicative-functors,-contrafunctors}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:9-Traversable-functors-and}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:Free-type-constructions}}

{*}{*}{*}

\subsection{Chapter~\ref{chap:monad-transformers}}

{*}{*}{*}

\subsection{Appendix~\ref{app:Proofs-of-naturality-parametricity}}

This appendix studies \textsf{``}parametricity\textsf{''} properties that apply to
all fully parametric code:

A given type constructor may have one fully parametric and lawful
implementation of the \lstinline!Functor! or \lstinline!Contrafunctor!
typeclass instance. (For most other typeclasses, such as \lstinline!Filterable!
or \lstinline!Monad!, type constructors often have several inequivalent
and lawful typeclass instances.) The unique implementations are defined
by the type constructions from Sections~\ref{subsec:f-Functor-constructions}
and~\ref{subsec:f-Contrafunctor-constructions}.

The lifting methods of any fully parametric bifunctor, profunctor,
or bi-contrafunctor obey the commutativity law such as Eq.~(\ref{eq:f-fmap-fmap-bifunctor-commutativity}). 

Any fully parametric expression $t:\forall A.\,Q^{A}$ satisfies the
relational naturality law~(\ref{eq:relational-naturality-law-1}).
In general, the relational naturality law expresses a property of
\emph{relations} rather than functions and is not equivalent to any
equation satisfied by $t$. The chapter explains how relations are
defined and what operations are available for relations, and shows
the proof of the relational naturality law.

All fully parametric functions of type $P^{A,A}\rightarrow Q^{A,A}$
(where $P$, $Q$ are profunctors) obey the dinaturality law~(\ref{eq:dinaturality-law-for-profunctors}).
The form of the law depends only on the function\textsf{'}s type signature
and applies to all fully parametric implementations of that type signature.

If the type signature of $t$ satisfies the conditions of Statements~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}
or~\ref{subsec:Statement-functor-post-pre-wedge}, the function $t$
satisfies the \textsf{``}strong dinaturality\textsf{''} law~(\ref{eq:strong-dinaturality-law}).
Strong dinaturality gives more information than the ordinary dinaturality
law and is simpler to use than the general relational naturality law~(\ref{eq:relational-naturality-law-1}).

\setcounter{secnumdepth}{3}%
\begin{comment}
Restore the normal numbering of subsections and subsubsections
\end{comment}


\section{Topics not covered in this book}

This book focuses on mathematical theory that has proven its relevance
to the functional programming practice. This section lists some topics
that were omitted from this edition of the book, and explains why.

\subsection{Trampolines and stack-safe recursion in functor blocks}

Recursion with applicative and monadic functors (say, a loop with
the free monad) can lead to stack overflows when the nesting of \lstinline!flatMap!
methods becomes too deep. There are certain tricks that can be used
to ensure stack safety. One of those tricks is known as \textsf{``}trampolines\textsf{''}.
Another trick is to use stack-safe implementations of various monads. 

This book does not discuss those tricks in detail. Trampolines are
already well described in the book \textsf{``}Functional programming in Scala\textsf{''}.
Stack-safe implementations of standard monads have better performance
but are mathematically equivalent to the same monads implemented via
simple, non-stack-safe code. There is no new theory to be developed
and no new laws to be proved about stack-safe code.

\subsection{Strictness and laziness}

Scala can define values via one of the three evaluation policies:
eager (also known as \textsf{``}strict\textsf{''}), lazy, or on-demand. Eager values
are computed immediately as they are defined; lazy values are computed
only on first use and then stored in memory; on-demand values are
computed every time they are used. 

In the functional programming paradigm, it is rare that an algorithm
or a data structure works correctly only when certain values are defined
as lazy. This book focuses on the properties of functional programs
and their types that do not use strictness or laziness in an essential
way. For instance, the laws of a functor are the same and need to
be verified via the same proof regardless of whether the program code
uses strict or lazy functor values. 

\subsection{Combined typeclasses and their laws}

Sequences and trees are perhaps the most frequently used data structures.
Those data structures have at once the properties of several typeclasses:
\lstinline!Functor!, \lstinline!Filterable!, \lstinline!Monad!,
\lstinline!Applicative!, and \lstinline!Traversable!. It turns out
that the methods of various typeclasses satisfy not only the laws
of their own typeclass but also additional laws that express a kind
of compatibility between different typeclasses. For example, the law~(\ref{eq:compatibility-law-deflate-flatten})
expresses compatibility between \lstinline!Filterable!\textsf{'}s \lstinline!deflate!
and \lstinline!Monad!\textsf{'}s \lstinline!flatten! methods.

This book does not systematically study the possible combinations
between the major typeclasses and the possible compatibility laws
that could be imposed. There does not seem to be a general way of
motivating and deriving the properties and laws of combined typeclasses.

\subsection{Lenses, prisms, and other \textquotedblleft functional optics\textquotedblright}

Lenses are a type constructor with methods that represent the operations
of reading and updating a part of a large data structure while keeping
all other parts unchanged. The theory of lenses is complicated and
does not seem to have been fully developed, while practical applications
are limited.

\subsection{Comonads and comonad transformers}

A comonad is a functor $F$ with two additional methods called \lstinline!extract!
and \lstinline!duplicate!:
\[
\text{ex}_{F}:\forall A.\,F^{A}\rightarrow A\quad,\quad\quad\text{dupl}_{F}:\forall A.\,F^{A}\rightarrow F^{F^{A}}\quad.
\]
The type signatures of those methods are similar to the type signatures
of the monads\textsf{'} methods \lstinline!pure! and \lstinline!flatten!
except that the function arrows point in the opposite direction:
\[
\text{pu}_{F}:\forall A.\,A\rightarrow F^{A}\quad,\quad\quad\text{ftn}_{F}:\forall A.\,F^{F^{A}}\rightarrow F^{A}\quad.
\]
The comonad\textsf{'}s methods must also satisfy the appropriate laws. Similarly
to monads, two comonads can be combined via \textsf{``}comonad transformers\textsf{''}
into a larger comonad. An example of a comonad is the non-empty list
(\lstinline!NEL!). 

Although comonads are in some sense analogous to monads, this book
does not develop the corresponding theory because comonads do not
appear to have a wide range of applications in practical programming.

\subsection{Dependent types}

Scala has limited support for dependent types\index{dependent type}
(or \textsf{``}value-to-type functions\textsf{''}). While there are occasional uses
for those types in some Scala libraries, most functional programming
practice today is formulated with traditional types that are fully
determined at compile time and do not depend on run-time values. This
book does not develop the theory of dependent types as that theory
is quite complicated and yet limited in practical applications.

\subsection{Linear types and other non-standard types}

Some programming languages include features that go beyond the type
system described in this book. For example, the Rust language has
special features of the type system that describe memory allocation
lifetimes. In that way, Rust programs can manage memory allocations
explicitly and verify at compile time that no data is deallocated
from memory at the wrong place.

Features of that kind are complicated and not widely used. This book
focuses on the type system features that are both widely used and
well-understood.

\section{Additional exercises and problems\label{chap:Exercises-in-AFTT}}

The following is a sample set of problems that can be solved using
techniques developed in this book.

\subsection{Exercises\index{exercises}}

\subsubsection{Exercise \label{par:Exercise-additional}\ref{par:Exercise-additional}}

Find the smallest integer expressible as a sum of two cubed integers
in more than one way.

\subsubsection{Exercise \label{par:Exercise-additional-18}\ref{par:Exercise-additional-18}}

Show that the following type signatures have \emph{no} fully parametric
implementations:

\begin{lstlisting}
def f[A]: Option[A] => A
def g[A, B]: (A => B) => A
def h[A, B]: (A => B) => (B => A)
def k[A, B, C]: (A => B) => (B => C) => (C => A)
\end{lstlisting}

Hint: set some type parameters to the void type (\lstinline!Nothing!).

\subsubsection{Exercise \label{par:Exercise-additional-1}\ref{par:Exercise-additional-1}}

Implement a function \lstinline!norepeat! that removes consecutive
repetitions from sequences:
\begin{lstlisting}
def norepeat[A]: Seq[A] => Seq[A] = ???

scala> norepeat(Seq(1,2,2,1,1,3,3,3,0,3))
res0: Seq[Int] = Seq(1,2,1,3,0,3)
\end{lstlisting}


\subsubsection{Exercise \label{par:Exercise-additional-2}\ref{par:Exercise-additional-2}}

Read a text file, split it by spaces into words, and print the word
counts in decreasing order.%
\begin{comment}
\begin{enumerate}
\item FPIS exercise 2.2: Check whether a sequence \lstinline!Seq[A]! is
sorted according to a given ordering function of type \lstinline!(A, A) => Boolean!.
\item FPIS exercise 3.24: Implement a function \lstinline!hasSubsequence!
that checks whether a \lstinline!List! contains another \lstinline!List!
as a subsequence. For instance, \lstinline!List(1,2,3,4)! would have
\lstinline!List(1,2)!, \lstinline!List(2,3)!, and \lstinline!List(4)!
as subsequences, among others. (Dynamic programming?)
\end{enumerate}
\end{comment}


\subsubsection{Exercise \label{par:Exercise-additional-3}\ref{par:Exercise-additional-3}}

(Exercise 4-1 from Hu Zhenjiang\textsf{'}s course \texttt{\href{http://www.prg.nii.ac.jp/course/2015/msp15/}{http://www.prg.nii.ac.jp/course/2015/msp15/}})
Express the \lstinline!filter! method for sequences via \lstinline!flatMap!:
\begin{lstlisting}
def filter[A](p: A => Boolean)(s: Seq[A]): Seq[A] = s.flatMap { a => ??? }
\end{lstlisting}


\subsubsection{Exercise \label{par:Exercise-additional-5}\ref{par:Exercise-additional-5}}

Define a monoid of partial functions with fixed types $P\rightarrow Q$:
\begin{lstlisting}
final case class PFM[P, Q](pf: PartialFunction[P, Q])
// After defining a monoid instance, the following code must work:
val p1 = PFM[Option[Int], String] { case Some(3) => "three" }
val p2 = PFM[Option[Int], String] {
  case Some(20)   => "twenty"
  case None       => "empty"
}
val p3 = p1 |+| p2 // Must be the same as the concatenation of all `case` clauses.
\end{lstlisting}


\subsubsection{Exercise \label{par:Exercise-additional-6-1-1}\ref{par:Exercise-additional-6-1-1}}

Find\footnote{This was posted in \texttt{\href{https://cstheory.stackexchange.com/questions/53294}{https://cstheory.stackexchange.com/questions/53294}}}
a general type signature for the expression $a\rightarrow a(y\rightarrow t\rightarrow t)(z(a))$. 

\subsubsection{Exercise \label{par:Exercise-additional-4}\ref{par:Exercise-additional-4}}

(Bird-de Moor, page 20) Derive the following identity between functions
$F^{A}\rightarrow F^{A}$, for any filterable functor $F$ and any
predicate $p^{:A\rightarrow\bbnum 2}$: 
\[
\text{filt}_{F}(p)=(\Delta\bef\text{id}\boxtimes p)^{\uparrow F}\bef\text{filt}_{F}(\pi_{2})\bef\pi_{1}^{\uparrow F}\quad.
\]


\subsubsection{Exercise \label{par:Exercise-additional-6}\ref{par:Exercise-additional-6}}

Consider a typeclass called \textsf{``}\lstinline!Splittable!\textsf{''} for functors\index{splittable functors}
$F$ that have an additional method:
\[
\text{split}^{A,B}:F^{A+B}\rightarrow F^{A}+B\quad,
\]
satisfying a \index{non-degeneracy law!of splittable functors}non-degeneracy
law:
\[
(x^{:A}\rightarrow x+\bbnum 0^{:B})^{\uparrow F}\bef\text{split}=y^{:F^{A}}\rightarrow y+\bbnum 0^{:B}\quad,
\]
and a special associativity law\index{associativity law!of splittable functors},
which is an equation for functions of type $F^{A+B+C}\rightarrow F^{A}+B+C$:
\[
\text{split}^{A+B,C}\bef\,\begin{array}{|c||cc|}
 & F^{A}+B & C\\
\hline F^{A+B} & \text{split}^{A,B} & \bbnum 0\\
C & \bbnum 0 & \text{id}
\end{array}\,=\text{split}^{A,B+C}\quad.
\]
Show that all polynomial functors $F^{\bullet}$ belong to this typeclass.
Show that exponential functors such as $F^{A}\triangleq Z\rightarrow A$
do not belong to this typeclass.

\subsubsection{Exercise \label{par:Exercise-additional-6-1}\ref{par:Exercise-additional-6-1}}

Consider the method \lstinline!sequence: L[F[A]] => F[L[A]]! (denoted
by $\text{seq}_{L}^{F}$) that assumes a traversable functor $L$
and an applicative functor $F$. If we set $F=\text{List}$ and also
$L=\text{List}$ then we obtain the type signature $\text{seq}_{\text{List}}^{\text{List}}:\text{List}^{\text{List}^{A}}\rightarrow\text{List}^{\text{List}^{A}}$.
A data structure of type $\text{List}^{\text{List}^{A}}$ may be used
to represent a rectangular matrix. Show that the function $\text{seq}_{\text{List}}^{\text{List}}$
transposes the rectangular matrix.

\subsubsection{Exercise \label{par:Exercise-additional-7}\ref{par:Exercise-additional-7}}

Given a monad $M$ and a fixed type $Z$, consider the functor $F^{A}\triangleq(A\rightarrow M^{Z})\rightarrow Z$.
Show that $F$ is a semimonad but not a full monad. Hint: use the
flipped Kleisli technique.

\subsubsection{Exercise \label{par:Exercise-additional-8}\ref{par:Exercise-additional-8}}

Given two fixed types $P$, $Q$ that are not known to be equivalent,
consider the contrafunctors $F^{A}\triangleq\left(\left(A\rightarrow P\right)\rightarrow P\right)\rightarrow Q$
and $G^{A}\triangleq A\rightarrow Q$. Show that there exist natural
transformations $F^{\bullet}\leadsto G^{\bullet}$ and $G^{\bullet}\leadsto F^{\bullet}$.
Show that these transformations are \emph{not} isomorphisms.

\subsubsection{Exercise \label{par:Exercise-additional-9}\ref{par:Exercise-additional-9}}

Given two fixed types $P$, $Q$ that are not known to be equivalent,
show that the functor $L^{A}\triangleq\left(\left(\left(A\rightarrow P\right)\rightarrow Q\right)\rightarrow Q\right)\rightarrow P$
is a semimonad but not a full monad. (When $P\cong Q$, the functor
$L$ is also not a full monad because $L$ is then equivalent to a
composition of the continuation monad with itself. See Exercise~\ref{subsec:Exercise-monad-composition-mm}.)

\subsubsection{Exercise \label{par:Exercise-additional-9-1}\ref{par:Exercise-additional-9-1}}

For any fully parametric contrafunctor $F^{A}$ that does not explicitly
use the void type\index{void type} ($\bbnum 0$) in its type expression,
show that the type of fully parametric functions $\forall A.\,F^{A}\rightarrow A$
is void. Show that the condition of not using the void type is necessary,
as the contrafunctor $F^{A}\triangleq(\bbnum 0\rightarrow A)\rightarrow\bbnum 0$
would be a counterexample:
\[
\forall A.\,F^{A}\rightarrow A=\forall A.\,((\bbnum 0\rightarrow A)\rightarrow\bbnum 0)\rightarrow A\cong((\bbnum 0\rightarrow\bbnum 0)\rightarrow\bbnum 0)\rightarrow\bbnum 0\cong\bbnum 1\quad.
\]
The type equivalence $\forall A.\,F^{A}\rightarrow A\cong\bbnum 0$
means that we cannot extract values of type $A$ from a value of type
$F^{A}$. This agrees with the intuition that a contrafunctor type
($F^{A}$) \textsf{``}does not contain\textsf{''} any values of type $A$.

\subsubsection{Exercise \label{par:Exercise-additional-11}\ref{par:Exercise-additional-11}}

If $M$ is any monad then $M^{A+M^{A}}$ is also a lawful monad.

\subsubsection{Exercise \label{par:Exercise-additional-10}\ref{par:Exercise-additional-10}}

If $M$ is a semimonad then $M\circ M\circ...\circ M$ (with finitely
many $M$) is also a lawful semimonad.

\subsubsection{Exercise \label{par:Exercise-additional-12}\ref{par:Exercise-additional-12}}

If $M$ is a commutative monad then $M\circ M$ is also a lawful commutative
monad.

\subsubsection{Exercise \label{par:Exercise-additional-13}\ref{par:Exercise-additional-13}}

If $M^{\bullet}$ is a commutative monad and $W$ is a commutative
monoid then the monoid $M^{W}$ is commutative.

\subsubsection{Exercise{*}{*} \label{par:Exercise-additional-14}\ref{par:Exercise-additional-14}}

Define a type constructor \lstinline!Triang[A]! representing \textsf{``}triangular
matrices\textsf{''} with elements of type \lstinline!A!. Example values $t_{1}$,
$t_{2}$, $t_{3}$ of type \lstinline!Triang[A]! are:
\[
t_{1}=\left|\begin{array}{c}
a_{1}\end{array}\right|\quad,\quad\quad t_{2}=\left|\begin{array}{cc}
a_{1}\\
a_{2} & a_{3}
\end{array}\right|\quad,\quad\quad t_{3}=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{4} & a_{5} & a_{6}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad.
\]
Unlike \lstinline!List[List[A]]!, it should \emph{not} be possible
to have a value of type \lstinline!Triang[A]! that has an unexpected
shape:
\[
t=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad\text{is not of type }\text{Triang}^{A}\quad.
\]
 Implement \lstinline!Functor!, \lstinline!Applicative!, and \lstinline!Traversable!
instances for \lstinline!Triang!.

\subsubsection{Exercise \label{par:Exercise-additional-15}\ref{par:Exercise-additional-15}}

Use the Curry-Howard correspondence\index{Curry-Howard correspondence}
and the algorithms LJ or LJT\index{LJT algorithm} to prove that there
exists only one fully parametric function with type signature $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow A$,
or in Scala:
\begin{lstlisting}
def f[A]: ((A => A) => A) => A
\end{lstlisting}
From that, prove the type equivalence $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow A\cong\bbnum 1$.

\subsubsection{Exercise{*}{*} \label{par:Problem-Peirce-law}\ref{par:Problem-Peirce-law}}

Consider the functor $F^{R}$ defined by:
\[
F^{R}\triangleq\forall A.\,((A\rightarrow R)\rightarrow A)\rightarrow A\quad,
\]
where all functions of type $F^{R}$ are assumed to be fully parametric.
Show that $F^{R}\cong R$.

Note that \index{Peirce\textsf{'}s law}Peirce\textsf{'}s law (see Eq.~(\ref{eq:ch-example-3-peirce-law}))
is expressed as the type $\forall R.\,F^{R}$. Peirce\textsf{'}s law does not
hold in the constructive logic. The Curry-Howard correspondence says
that the corresponding type $\forall R.\,F^{R}$ should be void, and
it is: $\forall R.\,F^{R}=\forall R.\,R=\bbnum 0$. 


\subsubsection{Exercise{*}{*} \label{par:Problem-Peirce-law-1}\ref{par:Problem-Peirce-law-1}}

Consider the profunctor $F^{R,S}$ defined by:
\[
F^{R,S}\triangleq\forall A.\,((A\rightarrow A)\rightarrow R)\rightarrow S\quad,
\]
where all functions of type $F^{R,S}$ are assumed to be fully parametric. 

An equivalent (but not actually simpler) type expression is:
\[
F^{R,S}\triangleq(\exists A.\,(A\rightarrow A)\rightarrow R)\rightarrow S\quad.
\]
So, we have $F^{R,S}=G^{R}\rightarrow S$, where the functor $G^{R}$
is defined by:
\[
G^{R}\triangleq\exists A.\,(A\rightarrow A)\rightarrow R\quad.
\]
Show that $G^{R}\cong R$ and $F^{R,S}\cong R\rightarrow S$.


\subsubsection{Exercise{*} \label{par:Problem-Peirce-law-2}\ref{par:Problem-Peirce-law-2}}

Prove the following type equivalences (assuming fixed types $P$,
$Q$, ...):

\begin{tabular}{|c|c|}
\hline 
\textbf{\footnotesize{}Quantified type} & \textbf{\footnotesize{}Equivalent type}\tabularnewline
\hline 
\hline 
$\forall A.\,(A\rightarrow A)\rightarrow P$ & $P$\tabularnewline
\hline 
$\forall A.\,(A\rightarrow A)\rightarrow A$ & $\bbnum 0$\tabularnewline
\hline 
$\forall A.\,(A\rightarrow A)\rightarrow A+P$ & $P$\tabularnewline
\hline 
$\forall A.\,(A\rightarrow A)\rightarrow A\rightarrow A$ & $\text{List}^{\bbnum 1}$\tabularnewline
\hline 
$\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow P$ & $P$?\tabularnewline
\hline 
\end{tabular}

\subsubsection{Exercise \label{par:Exercise-additional-16-2}\ref{par:Exercise-additional-16-2}}

Consider the type constructor $F^{R,S}$ defined by:
\[
F^{R,S}\triangleq\forall A.\,((R\rightarrow A)\rightarrow S)\rightarrow A\quad,
\]
where all functions of type $F^{R,S}$ are assumed to be fully parametric.
Show that $F^{R,S}\cong\bbnum 0$ unless we set $R=S=\bbnum 0$, in
which case $F^{\bbnum 0,\bbnum 0}\cong\bbnum 1$. 

\subsubsection{Exercise{*} \label{par:Exercise-additional-16}\ref{par:Exercise-additional-16}}

Define a monad transformer $T_{\text{Cod}_{F}^{L}}^{M,A}$ for the
composed codensity monad (Exercise~\ref{subsec:Exercise-combined-codensity-monad})
with type parameters $F$ (an arbitrary but fixed functor), $L$ (an
arbitrary but fixed monad), $M$ (a foreign monad), and $A$ (the
value type). Find out which laws hold for that transformer.

\subsubsection{Exercise{*}{*} \label{par:Exercise-additional-16-1}\ref{par:Exercise-additional-16-1}}

Consider the (non-covariant) type constructor $G^{A}\triangleq A\rightarrow A$.\footnote{See \texttt{\href{https://stackoverflow.com/questions/72490608/}{https://stackoverflow.com/questions/72490608/}}
for discussion about monads having multiple transformers.}

\textbf{(a)} Show that codensity monad on $G$ ($\text{Cod}^{G,\bullet}$)
is equivalent to $\text{List}^{\bullet}$ via monad morphisms.

\textbf{(b)} Show that the corresponding monad transformer: 
\[
T_{\text{Cod}^{G}}^{M,A}\triangleq\forall R.\,(A\rightarrow M^{G^{R}})\rightarrow M^{G^{R}}=\forall R.\,(A\rightarrow M^{R\rightarrow R})\rightarrow M^{R\rightarrow R}
\]
is \emph{not} equivalent to the \lstinline!List! monad\textsf{'}s standard
transformer (\lstinline!ListT!) shown in Section~\ref{subsec:Transformer-for-the-List-monad}.

\textbf{(c)} Show that the type constructor $U$ defined by:
\[
U^{M^{\bullet},A}\triangleq\forall R.\,(A\rightarrow G^{M^{R}})\rightarrow G^{M^{R}}=\forall R.\,(A\rightarrow M^{R}\rightarrow M^{R})\rightarrow M^{R}\rightarrow M^{R}
\]
is also a lawful monad transformer (with the foreign monad $M$) for
the \lstinline!List! monad. Show that the transformer $U$ (known
as the \textsf{``}\lstinline!LogicT! monad transformer\textsf{''}\footnote{See \texttt{\href{https://github.com/Bodigrim/logict}{https://github.com/Bodigrim/logict}}
for an example implementation in Haskell.}) is not equivalent to that defined in \textbf{(b)}. 

\textbf{(d)} Generalize \textbf{(c)} using an arbitrary (covariant)
functor $F$ and two fixed types $P$, $Q$:
\[
V^{F^{\bullet},P,Q,M^{\bullet},A}\triangleq\forall R.\,(A\rightarrow F^{M^{R}}\rightarrow P\times M^{R}+Q)\rightarrow F^{M^{R}}\rightarrow P\times M^{R}+Q\quad.
\]
Show that there exists a monad morphism $M^{A}\rightarrow V^{F^{\bullet},P,Q,M^{\bullet},A}$,
and that the converse function of type $V^{F^{\bullet},P,Q,M^{\bullet},A}\rightarrow M^{A}$
exists when $Q=\bbnum 0$ (but is \emph{not} a monad morphism).

\textbf{(e)} Show that the Church-encoded free monoid on $A$ (see
Section~\ref{subsec:Church-encodings-for-free-P-typeclasses}):
\[
\text{FM}^{A}\triangleq\forall X^{:\text{Monoid}}.\,(A\rightarrow X)\rightarrow X
\]
can be modified to the type constructor denoted by \lstinline!FMT!:
\[
\text{FMT}^{M^{\bullet},A}\triangleq\forall X^{:\text{Monoid}}.\,(A\rightarrow M^{X})\rightarrow M^{X}\quad,
\]
which is a lawful monad transformer (with the foreign monad $M$)
for the \lstinline!List! monad. Show that this transformer is not
equivalent to the transformers defined in \textbf{(b)}, \textbf{(c)}. 

\subsubsection{Exercise{*}{*} \label{par:Exercise-additional-17}\ref{par:Exercise-additional-17}}

\textbf{(a)} For any fixed type $Z$, functor $F$ and lawful monad
$P$, show that $L^{A}\triangleq F^{A\rightarrow P^{Z}}\rightarrow P^{A}$
is a lawful monad.

\textbf{(b)} Show that $L$\textsf{'}s monad transformer is $T_{L}^{M,A}\triangleq F^{A\rightarrow T_{P}^{M,Z}}\rightarrow T_{P}^{M,A}$,
where $T_{P}^{M,A}$ is $P$\textsf{'}s monad transformer.

\subsection{Open problems\index{open problems}}

The author of this book does not know how to answer the following
questions and also could not find any answers in existing books or
papers.

\subsubsection{Problem \label{par:Problem-monads-1}\ref{par:Problem-monads-1}}

Do all polynomial functors of the form $P_{n}^{A}\triangleq\bbnum 1+\overbrace{A\times A\times...\times A}^{n\text{ times, }n\ge2}$
fail to be monads? An example is the functor $P_{2}^{A}\triangleq\bbnum 1+A\times A$,
which is not a monad because all possible implementations of \lstinline!pure!
and \lstinline!flatMap! methods for $P_{2}$ fail the monad laws.\footnote{See discussion here: \texttt{\href{https://stackoverflow.com/questions/49742377}{https://stackoverflow.com/questions/49742377}}}

\subsubsection{Problem \label{par:Problem-monads}\ref{par:Problem-monads}}

Section~\ref{subsec:Constructions-of-polynomial-monads} shows four
constructions that make new monads:
\begin{enumerate}
\item The polynomial monad $F^{A}\triangleq Z+W\times A$, where $W$ is
a monoid and $Z$ is a fixed type.
\item The free pointed monad $L^{A}\triangleq A+F^{A}$, where $F$ is a
monad.
\item The product monad $L^{A}\triangleq F^{A}\times G^{A}$, where $F$
and $G$ are monads.
\item The monad $L^{A}\triangleq F^{Z+W\times A}$, where $F$ is a monad,
$W$ is a monoid, and $Z$ is a fixed type.
\end{enumerate}
If we do not assume any existing monads and just keep applying these
constructions, we will obtain a number of polynomial monads. But are
there any polynomial monads \emph{not} obtained by a chain of these
constructions?

\subsubsection{Problem \label{subsec:Problem-co-pointed-applicative}\ref{subsec:Problem-co-pointed-applicative}}

By Statement~\ref{subsec:Statement-co-pointed-applicative-example},
any co-pointed applicative functor of the form $L^{A}\triangleq A\times G^{A}$
satisfies the compatibility law~(\ref{eq:compatibility-law-of-extract-and-zip}).
Statement~\ref{subsec:Statement-co-pointed-applicative-example-failing-compatibility-law}
shows that $L^{A}\triangleq Z\times\left(Z\rightarrow A\right)$ is
applicative and co-pointed but fails the compatibility law. Does there
exist any co-pointed applicative functor that satisfies the law~(\ref{eq:compatibility-law-of-extract-and-zip})
but is \emph{not} of the form $A\times G^{A}$ with some applicative
functor $G^{\bullet}$? 

\subsubsection{Problem \label{par:Problem-traverse-law}\ref{par:Problem-traverse-law}}

\textbf{(a)} Show that the applicative naturality law~(\ref{eq:traverse-applicative-naturality-law}),
the identity law~(\ref{eq:traverse-identity-law}), and the composition
law~(\ref{eq:composition-law-of-traverse}) of \lstinline!traverse!
guarantee that \lstinline!traverse! collects each $F$-effect exactly
once, or find another law that is necessary to guarantee that. (Can
we use a composition of an applicative functor $F$ with a \lstinline!State!
monad to count the number of times $F$-effects were collected?)

\textbf{(b)} For any lawful traversable functor $L$, define the function
\lstinline!zipWithIndex! (denoted for brevity by $\text{zwi}_{L}$)
via Eq.~(\ref{eq:definition-of-zwi}). Show that there exists a \textsf{``}tabulating\textsf{''}
function (denoted by $\text{tab}_{L}^{A}$):
\[
\text{tab}_{L}^{A}:L^{A\times\text{Int}}\rightarrow(\text{Int}\rightarrow A)\times L^{\text{Int}}\quad,
\]
such that $\text{zwi}_{L}\bef\text{tab}_{L}\bef(f^{:\text{Int}\rightarrow A}\times q^{:L^{\text{Int}}}\rightarrow q\triangleright f^{\uparrow L})=\text{id}^{:L^{A}\rightarrow L^{A}}$.
So, the function $\text{zwi}_{L}\bef\text{tab}_{L}$ is an injective
map of type $L^{A}\rightarrow(\text{Int}\rightarrow A)\times L^{\text{Int}}$.

It appears that this property \emph{cannot} be proved via the three
laws of \lstinline!traverse!. One reason is that the function $\text{tab}_{L}$
produces an \textsf{``}indexing\textsf{''} function $f:\text{Int}\rightarrow A$,
which can be computed only by traversing the entire data structure
$L^{A}$. In other words, $f$ is a result of a traversal operation.
We want to prove a property of \lstinline!traverse! that combines
$f$ withanother traversal (\lstinline!zipWithIndex!). But there
are no laws of \lstinline!traverse! that involve reusing a result
of another traverse operation. What new law of \lstinline!traverse!
is necessary?

\subsubsection{Problem \label{par:Problem-monads-2}\ref{par:Problem-monads-2}}

Monad transformers are defined in different ways for different monads.
If someone comes up with a new monad, it is not certain that the new
monad\textsf{'}s transformer will be obtained through one of the known methods.
Can we prove that a monad transformer will exist for every monad whose
\lstinline!pure! and \lstinline!flatMap! methods are implemented
via fully parametric code? Given the code for an arbitrary monad,
can we derive an implementation of the corresponding monad transformer?

\subsubsection{Problem \label{par:Problem-monads-5-1}\ref{par:Problem-monads-5-1}}

For certain monads $L$, the monad transformers $T_{L}$ can be defined
using a suitable \lstinline!swap! function. Is this always the case
for any monad stacks built out of such monads? If each of the monads
$L_{1}$, $L_{2}$, ..., $L_{k}$ admits a transformer defined via
a lawful \lstinline!swap! function, will the monad $L_{1}\varangle L_{2}\varangle...\varangle L_{k}$
also admit a transformer with a \lstinline!swap! function? (See Section~\ref{subsec:Does-a-composition-have-swap}
for some partial results.)

\subsubsection{Problem \label{par:Problem-identity-natural-monad-morphism}\ref{par:Problem-identity-natural-monad-morphism}}

Are there any monadically natural monad morphisms $M\leadsto M$ that
are not identity functions? (Equivalently, any non-identical natural
transformations $\text{Id}^{\bullet}\leadsto\text{Id}^{\bullet}$
between identity functors in the category of monads?) If it were possible
to prove that any natural monad morphism $M\leadsto M$ equals an
identity function, there would be no need to verify the non-degeneracy
law for monad transformers\textsf{'} base runners (see page~\pageref{par:Open-question-monad-id-trans}).

We look for a monad morphism $\varepsilon^{M,A}:M^{A}\rightarrow M^{A}$
that is defined for all monads $M$ and is monadically natural in
the parameter $M$. So, the function $\varepsilon$ must satisfy the
following laws:
\begin{align*}
{\color{greenunder}\text{naturality law}:}\quad & \varepsilon^{M,A}\bef(f^{:A\rightarrow B})^{\uparrow M}=(f^{:A\rightarrow B})^{\uparrow M}\bef\varepsilon^{M,B}\quad,\\
{\color{greenunder}\text{monad morphism laws}:}\quad & \text{pu}_{M}\bef\varepsilon=\text{pu}_{M}\quad,\quad\quad\varepsilon^{\uparrow M}\bef\varepsilon\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\varepsilon\quad,\\
{\color{greenunder}\text{monadic naturality law}:}\quad & \varepsilon^{M,A}\bef\phi^{:M^{:A}\rightarrow N^{A}}=\phi^{:M^{A}\rightarrow N^{A}}\bef\varepsilon^{N,A}\quad,
\end{align*}
where $f^{:A\rightarrow B}$ is an arbitrary function, $M$ and $N$
are arbitrary monads, and $\phi:M\leadsto N$ is an arbitrary monad
morphism. We need to prove that any such $\varepsilon$ must be an
identity function, $\varepsilon=\text{id}^{:M^{A}\rightarrow M^{A}}$,
or to find an example of such $\varepsilon$ not equal to identity.\footnote{See discussion here: \texttt{\href{https://stackoverflow.com/questions/61444425/}{https://stackoverflow.com/questions/61444425/}}}

\subsubsection{Problem \label{par:Problem-monads-3}\ref{par:Problem-monads-3}}

\textsf{``}Rigid functors\textsf{''} are\index{rigid functors!open questions} defined
in Section~\ref{subsec:Rigid-functors}.

\textbf{(a)} Are there any rigid functors that are not monads? 

\textbf{(b)} Are there any rigid functors that are not applicative?

\textbf{(c)} Is it true that any applicative rigid functor is a monad?

\subsubsection{Problem \label{par:Problem-monads-3-1}\ref{par:Problem-monads-3-1}}

Let $L$ be a fixed monad and $H$ be an $L$-filterable contrafunctor.
Then the functor $F^{A}\triangleq H^{A}\rightarrow L^{A}$ is a lawful
monad (see Section~\ref{subsec:Constructions-of-M-filterables}).
What is a monad transformer for the monad $F$? 

Two nontrivial examples of $L$-filterable contrafunctors are $H^{A}\triangleq A\rightarrow L^{Z}$
and $H^{A}\triangleq L^{A}\rightarrow Z$ (where $Z$ is a fixed type).
For these cases, the monad transformers are defined by:
\begin{align*}
 & \text{monad: }(A\rightarrow L^{Z})\rightarrow L^{A}\quad,\quad\quad\text{transformer: }(A\rightarrow T_{L}^{M,Z})\rightarrow T_{L}^{M,A}\quad,\\
 & \text{monad: }(L^{A}\rightarrow Z)\rightarrow L^{A}\quad,\quad\quad\text{transformer: }(T_{L}^{M,A}\rightarrow Z)\rightarrow T_{L}^{M,A}\quad,
\end{align*}
where $T_{L}^{M}$ is the monad $L$\textsf{'}s transformer applied to the
foreign monad $M$.

The problem is to implement the monad $F$\textsf{'}s transformer for an arbitrary
$L$-filterable contrafunctor $H$ and to prove that the transformer
laws hold.

\subsubsection{Problem \label{par:Problem-monads-5-2}\ref{par:Problem-monads-5-2}}

Assume an arbitrary unknown monad $M$ and define recursively $L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}$.
Can one define a lawful monad instance for the functor $L$? (This
is the \lstinline!List! monad\textsf{'}s transformer without the outer layer
of $M$. See Exercise~\ref{subsec:Exercise-effectful-list-not-monad}.)

\subsubsection{Problem \label{par:Problem-monads-5-2-1}\ref{par:Problem-monads-5-2-1}}

These questions concern the monad transformer \lstinline!ListT! (here
denoted just by $T$): 
\[
T^{A}\triangleq M^{L^{A}}\quad,\quad\quad L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}\quad,
\]
where $M$ is an arbitrary foreign monad. Normally, we cannot implement
fully parametric base runner $T^{A}\rightarrow M^{A}$ because we
cannot have a fully parametric runner $\text{List}^{A}\rightarrow A$
operating on arbitrary types $A$. However, for a \emph{monoid} type
$R$ with binary operation $\oplus_{R}$ and empty element $e_{R}$,
the type signature $\text{List}^{R}\rightarrow R$ is implemented
by the standard \lstinline!reduce! operation: 
\[
\text{reduce}:\text{List}^{R}\rightarrow R\quad,\quad\quad\text{reduce}\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline \bbnum 1 & 1\rightarrow e_{R}\\
R\times\text{List}^{R} & h\times t\rightarrow h\oplus_{R}\overline{\text{reduce}}\,(t)
\end{array}\quad.
\]
We can similarly implement a base runner (\lstinline!brun!) for the
transformer $T_{\text{List}}$ if we restrict its usage to \emph{monoid}
types $R$. The function \lstinline!brun! with the type signature
$M^{L^{R}}\rightarrow M^{R}$ aggregates all elements of the effectful
list into a single value of type $M^{R}$ (which is also a monoid
type):
\[
\text{brun}:M^{L^{R}}\rightarrow M^{R}\quad,\quad\quad\text{brun}\triangleq\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{R}\\
\hline \bbnum 1 & 1\rightarrow\text{pu}_{M}(e_{R})\\
R\times M^{L^{R}} & h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\quad.
\]
Here, we use the binary operation $\oplus_{M}$ of the monoid $M^{R}$,
which is defined by:
\[
p^{:M^{R}}\oplus_{M}q^{:M^{R}}\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad.
\]

\textbf{(a)} Is \lstinline!brun! a monoid morphism $T^{A}\rightarrow A$?
(Note that $T^{A}$ is a monoid since $T$ is a lawful monad.) The
monoid morphism identity law holds for \lstinline!brun!. Does the
composition law hold?

\textbf{(b)} Do the monad morphism laws of \lstinline!brun! hold
when restricted to a monoid type $A$?
\begin{align*}
{\color{greenunder}\text{for all monoid types }A:}\quad & a^{:A}\triangleright\text{pu}_{T}\bef\text{brun}=a^{:A}\triangleright\text{pu}_{M}\quad,\\
{\color{greenunder}\text{composition law}:}\quad & p^{:T^{T^{A}}}\triangleright\text{ftn}_{T}\bef\text{brun }=p^{:T^{T^{A}}}\triangleright\text{brun}\bef\text{brun}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}
(If so, Exercise~\ref{subsec:Exercise-traversables-10-1} would show
that \lstinline!brun! is also a \emph{monoid} morphism $M^{L^{A}}\rightarrow M^{A}$.)
\begin{comment}
Failed attempts to verify the composition law:

Write its two sides separately:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \text{ftn}_{T}\bef\text{brun}=\text{flm}_{M}(\text{prod})\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
{\color{greenunder}\text{associativity of }\text{flm}_{M}:}\quad & \quad=\text{flm}_{M}\bigg(\text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\bigg)\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{brun}^{T^{R}}\bef\text{brun}^{\uparrow M}\bef\text{ftn}_{M}=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bigg)\bef\text{flm}_{M}(\text{brun})\\
{\color{greenunder}\text{associativity of }\text{flm}_{M}:}\quad & \quad=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\bigg)\quad.
\end{align*}
The remaining difference (under $\text{flm}_{M}$) is an equation
between functions of type $L^{M^{L^{R}}}\rightarrow M^{R}$:
\begin{align*}
 & \text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)=\text{prod}\bef\text{brun}\\
 & \quad\overset{?}{=}\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r^{:T^{R}}\times t^{:T^{T^{R}}}\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\quad.
\end{align*}
It is inconvenient to use matrices at this step because the code of
$\text{flm}_{M}$ is unknown. Instead, we will substitute into both
sides an arbitrary value of type $L^{M^{L^{R}}}$, which can be one
of two possibilities, $\text{Nil}$ or $\bbnum 0+h^{:T^{R}}\times t^{T^{T^{R}}}$.
Substituting $\text{Nil}$, we get:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \gunderline{\text{Nil}\triangleright\text{prod}}\bef\text{brun}=\text{Nil}\triangleright\text{pu}_{M}\bef\text{brun}\\
{\color{greenunder}\text{use Eq.~(\ref{eq:listt-brun-derivation1})}:}\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{Nil}\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=e_{T^{R}}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(\text{brun})=e_{R}\triangleright\gunderline{\text{pu}_{T}\bef\text{brun}}\\
{\color{greenunder}\text{identity law of }\text{brun}:}\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.
\end{align*}
The two sides are now equal. It remains to substitute the second possibility:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (\bbnum 0+h\times t)\triangleright\text{prod}\bef\text{brun}=\\
 & \quad=(\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\text{flm}_{M}(\overline{\text{prod}})
\end{array}\bef\text{brun}\\
 & \quad=\big(\text{comb}\,(h)(t\triangleright\text{flm}_{M}(\overline{\text{prod}}))\big)\triangleright\text{brun}\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\triangleright\xi\big)\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\xi\bef\text{brun}\big)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\big)\\
{\color{greenunder}\text{right-hand side}:}\quad & (\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=(\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t))\triangleright\text{flm}_{M}(\text{brun})\\
 & \quad=t\triangleright\overline{\text{brun}}\triangleright(v\rightarrow h\oplus_{R}v)^{\uparrow M}\triangleright\text{flm}_{M}(\text{brun})
\end{align*}
This is suspicious: we need to show that an expression $h\triangleright\text{flm}_{M}(t\triangleright...)$
is equal to $t\triangleright...$, and it seems impossible to convert
one into another, given that $h$ and $t$ are arbitrary values.

Note that
\[
\text{pu}_{M}(r^{:R})\oplus_{M}q^{:M^{R}}=r\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M})=q\triangleright(v\rightarrow r\oplus_{R}v)^{\uparrow M}\quad.
\]
In particular,
\[
\text{pu}_{M}(p)\oplus_{M}\text{pu}_{M}(q)=q\triangleright\text{pu}_{M}\triangleright(v\rightarrow p\oplus_{R}v)^{\uparrow M}=q\triangleright(v\rightarrow p\oplus_{R}v)\triangleright\text{pu}_{M}=\text{pu}_{M}(p\oplus_{R}q)\quad.
\]
We also have the property of \lstinline!comb!:
\begin{align*}
 & \big(\text{comb}\,(p)(q)\big)\triangleright\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}(q\triangleright\xi)\bef\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}((q\triangleright\xi)\bef\text{flm}_{M}(g))\\
 & =p\triangleright\text{flm}_{M}\bigg(\begin{array}{||c|}
1\rightarrow q\\
h\times t\rightarrow\text{pu}_{M}\big(\bbnum 0+h\times\overline{\text{comb}}\,(t)(q)
\end{array}\,\bef\text{flm}_{M}(g)\bigg)
\end{align*}
\end{comment}
{} 

\subsubsection{Problem \label{subsec:Problem-monatron-lift-reset-and-shift}\ref{subsec:Problem-monatron-lift-reset-and-shift}}

The continuation monad\textsf{'}s operations \lstinline!reset! and \lstinline!shift!
are defined by:
\begin{align*}
 & \text{reset}:\forall S.\,\text{Cont}^{R,R}\rightarrow\text{Cont}^{S,R}\quad,\quad\quad\text{reset}\triangleq c^{:\left(R\rightarrow R\right)\rightarrow R}\rightarrow k^{:R\rightarrow S}\rightarrow k(c(\text{id}))\quad,\\
 & \text{shift}:\forall A.\,((A\rightarrow R)\rightarrow\text{Cont}^{R,R})\rightarrow\text{Cont}^{R,A}\quad,\quad\quad\text{shift}\triangleq g^{:\left(A\rightarrow R\right)\rightarrow\text{Cont}^{R,R}}\rightarrow k^{:A\rightarrow R}\rightarrow g(k)(\text{id})\quad.
\end{align*}
How to lift these operations to an arbitrary monad stack $P$ that
contains a continuation monad?\footnote{See \texttt{\href{https://github.com/renormalist/pugs/blob/master/src/Pugs/AST/Eval.hs}{https://github.com/renormalist/pugs/blob/master/src/Pugs/AST/Eval.hs}}
for custom code (in Haskell) that lifts \lstinline!reset! and \lstinline!shift!
to the \lstinline!ContT! monad transformer.} What are the appropriate type signatures for the lifted operations?

\subsubsection{Problem \label{subsec:Problem-unique-functor-liftings}\ref{subsec:Problem-unique-functor-liftings}}

For any fully parametric type constructor $P^{A}$ covariant in $A$,
the lifting of a function $f^{:A\rightarrow B}$ to $P$ is performed
via the \lstinline!fmap! method of $P$, so that \lstinline!fmap(f)!
is a function of type $P^{A}\rightarrow P^{B}$ denoted by $f^{\uparrow F}$
in this book. The standard code of \lstinline!fmap! is defined by
induction on the type structure of $P$ and satisfies the functor
laws, as shown in Chapter~\ref{chap:Functors,-contrafunctors,-and}.
The question is to show that there is no non-standard, alternative
implementation \lstinline!fmap!$^{\prime}$ that still satisfies
the functor laws. If the code of \lstinline!fmap!$^{\prime}$ is
fully parametric, Section~\ref{sec:Uniqueness-of-functor-and-contrafunctor}
shows that \lstinline!fmap!$^{\prime}=$ \lstinline!fmap!. However,
parametricity (or naturality) does not seem to follow from functor
laws alone. Does there exist an implementation of \lstinline!fmap!$^{\prime}$
that satisfies the functor laws but is \emph{not} fully parametric?
