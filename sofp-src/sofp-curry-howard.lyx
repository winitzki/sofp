#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.1cm
\topmargin 0.95cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.4cm
\footskip 0.75cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The logic of types.
 III.
 The Curry-Howard correspondence
\begin_inset CommandInset label
LatexCommand label
name "chap:3-3-The-formal-logic-curry-howard"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset

Fully parametric functions (introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Fully-parametric-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) perform operations so general that their code does not depend on values
 of any specific data types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 An example of a fully parametric function is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { x => g(f(x)) }
\end_layout

\end_inset

We have also seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Deriving-a-function's"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that for certain functions of this kind, the code can be derived unambiguously
 from the type signature.
\end_layout

\begin_layout Standard
There exists a mathematical theory (called the 
\series bold
Curry-Howard correspondence
\series default
) that provides precise conditions for the possibility of deriving a function's
 code from its type and a systematic derivation algorithm.
 Technical details about the algorithm are found in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:The-Curry-Howard-correspondence"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This chapter describes the main results and applications of this theory
 to functional programming.
\end_layout

\begin_layout Section
Values computed by fully parametric functions
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
Consider the Scala code of a fully parametric function,
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B, ...]: ...
 = {
\end_layout

\begin_layout Plain Layout

  val x: Either[A, B] = ...
 // Some expression here.
\end_layout

\begin_layout Plain Layout

  ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
If this program compiles without type errors, it means that the types match
 and, in particular, that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is able to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is sometimes 
\emph on
impossible
\emph default
 to compute a value of a certain type within the body of a fully parametric
 function.
 For example, the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  val x: A = ??? // Cannot compute x here!
\end_layout

\begin_layout Plain Layout

  ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The reason is that a fully parametric function cannot compute values of
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 from scratch without using previously given values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and without applying a function that returns values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 are given as arguments; the given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 returns values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 must perform pattern matching on a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  case None       => 
\end_layout

\begin_layout Plain Layout

    val x: A = ??? // Cannot compute x here!
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

  case Some(a)    =>
\end_layout

\begin_layout Plain Layout

    val x: A = a   // Can compute x in this scope.
\end_layout

\begin_layout Plain Layout

    ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Since the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 has no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we are unable to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in that scope (as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 remains a fully parametric function).
 
\end_layout

\begin_layout Standard
Being able to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

within the body of a function
\begin_inset Quotes erd
\end_inset

 means that, if needed, the function should be able to 
\emph on
return
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a result value.
 This requires computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in all cases, not just within one part of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression.
 
\end_layout

\begin_layout Standard
The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 also cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Since no arguments of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are given, the only way of obtaining a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 would be to apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 to 
\emph on
some
\emph default
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

; but we just saw that the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Another example where one cannot compute a value of a certain type is in
 the following code:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -10baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = {
\end_layout

\begin_layout Plain Layout

  //  val h: C => A = ???   // Cannot compute h here!
\end_layout

\begin_layout Plain Layout

  a => g(f(a)) // Can compute a value of type A => C.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 may only use the arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

.
 We can compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

 by composing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

, but it is impossible to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => A
\end_layout

\end_inset

, no matter what code we try to write.
 The reason is that the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 has no given values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and no functions that return values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, so a nameless function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{c:C => ???}
\end_layout

\end_inset

 cannot compute its return value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Since a fully parametric function cannot create values of an arbitrary
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 from scratch, we see no possibility of computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 within the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Can we prove rigorously that a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => A
\end_layout

\end_inset

 cannot be computed within the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

? Or, perhaps, a clever trick 
\emph on
could
\emph default
 produce a value of that type? So far, we only saw informal arguments about
 whether values of certain types can be computed.
 To make the arguments rigorous, we need to translate statements such as
 
\begin_inset Quotes eld
\end_inset


\emph on
a fully parametric function
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 
\emph on
can compute a value of type
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => A
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 into mathematical formulas, with rigorous rules for proving them true or
 false.
\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctions-and-conjunctions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we denoted by 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 the proposition 
\begin_inset Quotes eld
\end_inset

the 
\begin_inset Formula ${\cal C}$
\end_inset

ode 
\begin_inset Formula ${\cal H}$
\end_inset

as a value of type 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 By 
\begin_inset Quotes eld
\end_inset

the code
\begin_inset Quotes erd
\end_inset

 we now mean the body of a given fully parametric function.
 So, the notation 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is not completely adequate because the validity of the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 depends not only on the choice of the type 
\begin_inset Formula $A$
\end_inset

 but also on the place in the code fragment where the value of type 
\begin_inset Formula $A$
\end_inset

 needs to be computed.
 What exactly is this additional dependency? In the above examples, we used
 the 
\emph on
types
\emph default
 of a function's arguments when reasoning about getting a value of a given
 type 
\begin_inset Formula $A$
\end_inset

.
 Thus, a precise description of the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is 
\begin_inset Formula 
\begin{align}
{\cal CH}\text{-proposition}:\quad & \text{a fully parametric function having arguments of types}\nonumber \\
 & X,Y,...,Z\text{ can compute a value of type }A\quad.\label{eq:ch-CH-proposition-def}
\end{align}

\end_inset

Here 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 may be either type parameters or more complicated type expressions such
 as 
\begin_inset Formula $B\Rightarrow C$
\end_inset

 or 
\begin_inset Formula $(C\Rightarrow D)\Rightarrow E$
\end_inset

, built from other type parameters.
\end_layout

\begin_layout Standard
If arguments of types 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 are given, it means we already have values of these types.
 So, the propositions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 will be true.
 Thus, proposition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-CH-proposition-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula ${\cal CH}(A)$
\end_inset

 assuming 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 In mathematical logic, a statement of this form is called a 
\series bold
sequent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent!example
\end_layout

\end_inset

 and is denoted by
\begin_inset Formula 
\begin{equation}
{\cal CH}(X),{\cal CH}(Y),...,{\cal CH}(Z)\vdash{\cal CH}(A)\quad.\label{eq:ch-example-sequent}
\end{equation}

\end_inset

The assumptions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 are called 
\series bold
premises
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent!premises
\end_layout

\end_inset

 and the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is called the 
\series bold
goal
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent!goal
\end_layout

\end_inset

.
 Showing rigorously the possibility of computing values in functions means
 proving sequents of the form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Our previous examples are denoted by the following sequents:
\begin_inset Formula 
\begin{align*}
\text{\texttt{fmap} for \texttt{Option}}:\quad & {\cal CH}(A\Rightarrow B)\vdash{\cal CH}(\text{\texttt{Option[A]}}\Rightarrow\text{\texttt{Option[B]}})\\
\text{the function \texttt{before}}:\quad & {\cal CH}(A\Rightarrow B),{\cal CH}(B\Rightarrow C)\vdash{\cal CH}(A\Rightarrow C)\\
\text{value of type }A\text{ within \texttt{fmap}}:\quad & {\cal CH}(A\Rightarrow B),{\cal CH}(\text{\texttt{Option[A]}})\vdash{\cal CH}(A)\\
\text{value of type }C\Rightarrow A\text{ within \texttt{before}}:\quad & {\cal CH}(A\Rightarrow B),{\cal CH}(B\Rightarrow C)\vdash{\cal CH}(C\Rightarrow A)
\end{align*}

\end_inset

Calculations in formal logic are called 
\series bold
proofs
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
proof
\end_layout

\end_inset

.
 So, in this section we gave informal arguments towards proving the first
 two sequents and disproving the last two.
 We will now develop tools for proving such sequents rigorously.
\end_layout

\begin_layout Standard
A proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 may be true for one set of premises such as 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 but false for another.
 Here and in the following sections, we will be reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions within the body of a 
\emph on
chosen
\emph default
 fully parametric function, i.e.
\begin_inset space ~
\end_inset

with a fixed set of premises.
 We will then temporarily omit the premises and use the shorter notation
 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

.
\end_layout

\begin_layout Subsection
Type notation and 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for standard type constructions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Type-notation-and-standard-type-constructions"

\end_inset


\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctions-and-conjunctions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we saw examples of reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for case classes and for disjunctive types.
 We will now extend this reasoning systematically to all type constructions
 that programs could use.
 A special 
\series bold
type notation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation
\end_layout

\end_inset

 explained in this section will help us write type expressions more concisely.
 (See Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Appendix-Notations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for reference on the type notation.)
\end_layout

\begin_layout Standard
There are six 
\series bold
standard type constructions
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
standard type constructions
\end_layout

\end_inset

 supported by all functional languages: primitive types (including 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type and the void type, called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 in Scala), product (tuple) types, co-product (disjunctive) types, function
 types, parameterized types, and recursive types.
 We will now derive the rules for writing 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for each of these type constructions (except recursive types).
\end_layout

\begin_layout Paragraph
1a) Rule for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has only a single value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, and this value (an 
\begin_inset Quotes eld
\end_inset

empty tuple
\begin_inset Quotes erd
\end_inset

) can be 
\emph on
always
\emph default
 computed since it does not need any previous data:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[...]: ...
 = {
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  val x: Unit = () // We can always compute a `Unit` value.
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\end_inset

So, the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always true.
 In the type notation, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Standard
Named unit types
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset

 also have a single value that is always possible to compute.
 For example,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class N1()
\end_layout

\end_inset

defines a named unit type; we can compute
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "44col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: N1 = N1()
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
So, the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N1
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always true.
 Named unit types are denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

, just as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type itself.
\end_layout

\begin_layout Paragraph
1b) Rule for the void type
\end_layout

\begin_layout Standard
The Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has no values, so the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always false.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\bbnum 0$
\end_inset

 in the type notation.
\end_layout

\begin_layout Paragraph
1c) Rule for primitive types
\end_layout

\begin_layout Standard
For a specific primitive (or library-defined) type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, the corresponding 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition is 
\emph on
always true
\emph default
 because we could use any constant value, e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[...]: ...
 {
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   val x: String = 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

 // We can always compute a `String` value.
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\end_inset

So, the rule for primitive types is the same as the rule for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Paragraph
2) Rule for tuple types
\end_layout

\begin_layout Standard
To compute a value of a tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 requires computing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 
\emph on
and
\emph default
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 This is expressed by the logic formula 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\begin_inset Formula $)={\cal CH}(A)\wedge{\cal CH}(B)$
\end_inset

.
 A similar formula holds for case classes, as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:curry-howard-example-case-class"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows.
 In the type notation, the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A\times B$
\end_inset

.
 Tuples and case classes with more than two parts are denoted similarly
 as 
\begin_inset Formula $A\times B\times...\times C$
\end_inset

.
 For example, the Scala definition
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Person(firstName: String, lastName: String, age: Int)
\end_layout

\end_inset

is written in the type notation as 
\begin_inset Formula $\text{String}\times\text{String}\times\text{Int}$
\end_inset

.
 So, the rule for tuple types is
\begin_inset Formula 
\[
{\cal CH}\left(A\times B\times...\times C\right)={\cal CH}(A)\wedge{\cal CH}(B)\wedge...\wedge{\cal CH}(C)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
3) Rule for disjunctive types
\end_layout

\begin_layout Standard
A disjunctive type may consist of several case classes.
 Having a value of a disjunctive type means to have a value of (at least)
 one of those case classes.
 An example of translating this relationship into a formula was shown by
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:curry-howard-example-disjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For the standard disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, we have the logical formula 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\begin_inset Formula $)={\cal CH}(A)\vee{\cal CH}(B)$
\end_inset

.
 In the type notation, the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A+B$
\end_inset

.
 A longer example: the Scala definition
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class NoRoots()                      extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class OneRoot(x: Double)             extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end_layout

\end_inset

is translated to the type notation as
\begin_inset Formula 
\[
\text{RootsOfQ}=1+\text{Double}+\text{Double}\times\text{Double}\quad.
\]

\end_inset

The type notation is significantly shorter because it omits all case class
 names and part names from the type definitions.
 In this notation, the rule for disjunctive types is
\begin_inset Formula 
\[
{\cal CH}\left(A+B+...+C\right)={\cal CH}(A)\vee{\cal CH}(B)\vee...\vee{\cal CH}(C)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
4) Rule for function types
\end_layout

\begin_layout Standard
Consider now a function type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 (This type is written in the type notation as 
\begin_inset Formula $A\Rightarrow B$
\end_inset

.) To compute a value of that type, we need to write code such as
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: A => B = { (a: A) =>
\end_layout

\begin_layout Plain Layout

  ??? // Compute a value of type B in this scope.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The inner scope of the function needs to compute a value of type 
\begin_inset Formula $B$
\end_inset

, and the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

 may be used for that.
 So, 
\begin_inset Formula ${\cal CH}(A\Rightarrow B)$
\end_inset

 is true if and only if we are able to compute a value of type 
\begin_inset Formula $B$
\end_inset

 when we are given a value of type 
\begin_inset Formula $A$
\end_inset

.
 To translate this statement into the language of logical propositions,
 we need to use the logical implication, 
\begin_inset Formula ${\cal CH}(A)\Rightarrow{\cal CH}(B)$
\end_inset

, which means that 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

 can be proved if 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 already holds.
 So the rule for function types is
\begin_inset Formula 
\[
{\cal CH}(A\Rightarrow B)={\cal CH}(A)\Rightarrow{\cal CH}(B)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
5) Rule for parameterized types
\end_layout

\begin_layout Standard
Consider a function with type parameters, e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (A => B) => B = { x => g => g(x) }
\end_layout

\end_inset

Being able to define the body of such a function is equivalent to being
 able to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A => B) => B
\end_layout

\end_inset

 for 
\emph on
all
\emph default
 possible types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 In the notation of formal logic, this is written as
\begin_inset Formula 
\[
{\cal CH}\left(\forall(A,B).\,A\Rightarrow(A\Rightarrow B)\Rightarrow B\right)
\]

\end_inset

and is equivalent to
\begin_inset Formula 
\[
\forall(A,B).\,{\cal CH}\left(A\Rightarrow(A\Rightarrow B)\Rightarrow B\right)\quad.
\]

\end_inset

The code notation for the parameterized function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is 
\begin_inset Formula 
\[
f^{A,B}:A\Rightarrow\left(A\Rightarrow B\right)\Rightarrow B\quad,
\]

\end_inset

and its type can be written as
\begin_inset Formula 
\[
\forall(A,B).\,A\Rightarrow\left(A\Rightarrow B\right)\Rightarrow B\quad.
\]

\end_inset

The symbol 
\begin_inset Formula $\forall$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

for all
\begin_inset Quotes erd
\end_inset

 and is known as the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
universal quantifier
\end_layout

\end_inset


\series bold
universal quantifier
\series default
 in logic.
\end_layout

\begin_layout Standard
In Scala, longer type expressions can be named and their names (called 
\series bold
type aliases
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

) can be used to make code shorter.
 Type aliases may also contain type parameters.
 Defining and using a type alias for the type of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 looks like this,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A, B] = A => (A => B) => B
\end_layout

\begin_layout Plain Layout

def f[A, B]: F[A, B] = { x => g => g(x) }
\end_layout

\end_inset

This is written in the type notation as
\begin_inset Formula 
\begin{align*}
F^{A,B} & \triangleq A\Rightarrow\left(A\Rightarrow B\right)\Rightarrow B\quad,\\
f^{A,B}:F^{A,B} & \triangleq x^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(x)\quad,
\end{align*}

\end_inset

or equivalently (although somewhat less readably)
\begin_inset Formula 
\[
f:\big(\forall(A,B).\,F^{A,B}\big)\triangleq\forall(A,B).\,x^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(x)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In Scala 3, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 can be written as a value via the syntax
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: [A, B] => A => (A => B) => B = {   // Valid only in Scala 3.
\end_layout

\begin_layout Plain Layout

  [A, B] => (x: A) => (g: A => B) => g(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This syntax corresponds more closely to the mathematical notation shown
 above.
\end_layout

\begin_layout Standard
So, the rule for parameterized types with the type notation 
\begin_inset Formula $F^{A}$
\end_inset

 is
\begin_inset Formula 
\[
{\cal CH}(\forall A.\:F^{A})=\forall A.\,{\cal CH}(F^{A})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Case classes and disjunctive types use 
\emph on
names
\emph default
 for the types and their parts.
 However, those names only add convenience for programmers and do not affect
 the computational properties of types.
 So, the type notation allows us to use nameless type expressions.
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes the type notation and also shows how to translate it into logic
 formulas with propositions of the form 
\begin_inset Formula ${\cal CH}(...)$
\end_inset

.
\end_layout

\begin_layout Standard
The precedence
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation!operator precedence
\end_layout

\end_inset

 of operators in the type notation is chosen to have fewer parentheses in
 the type expressions that are frequently used.
 Here are the rules of precedence:
\end_layout

\begin_layout Itemize
The type product operators (
\begin_inset Formula $\times$
\end_inset

) group stronger than the disjunctive operators (
\begin_inset Formula $+$
\end_inset

), so that type expressions such as 
\begin_inset Formula $A+B\times C$
\end_inset

 have the same operator precedence as in standard arithmetic.
 That is, 
\begin_inset Formula $A+B\times C$
\end_inset

 means 
\begin_inset Formula $A+\left(B\times C\right)$
\end_inset

.
 This convention makes type expressions easier to reason about (for people
 familiar with arithmetic).
\end_layout

\begin_layout Itemize
The function type arrows (
\begin_inset Formula $\Rightarrow$
\end_inset

) group weaker than the operators 
\begin_inset Formula $+$
\end_inset

 and 
\begin_inset Formula $\times$
\end_inset

, so that often-used types such as 
\begin_inset Formula $A\Rightarrow\bbnum 1+B$
\end_inset

 (representing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Option[B]
\end_layout

\end_inset

) or 
\begin_inset Formula $A\times B\Rightarrow C$
\end_inset

 (representing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B)) => C
\end_layout

\end_inset

) can be written without any parentheses.
 Type expressions such as 
\begin_inset Formula $\left(A\Rightarrow B\right)\times C$
\end_inset

 will require parentheses but are used less often.
\end_layout

\begin_layout Itemize
The type quantifiers group weaker than all other operators, so we can write
 types such as 
\begin_inset Formula $\forall A.\,A\Rightarrow A\Rightarrow A$
\end_inset

 without parentheses.
 Type quantifiers are most often placed outside a type expression.
 When this is not the case, parentheses are necessary, e.g.
\begin_inset space ~
\end_inset

in the type expression 
\begin_inset Formula $\left(\forall A.\,A\Rightarrow A\right)\Rightarrow\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
product type (tuple)
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\wedge$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
disjunctive type
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\vee$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
function type
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\Rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unit or a 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Quotes erd
\end_inset

 type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\bbnum 1)=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
primitive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Int}$
\end_inset

, 
\begin_inset Formula $\text{String}$
\end_inset

, ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\text{Int})=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
void type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\bbnum 0)=False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
value parameterized by type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A]: F[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{A}:F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,{\cal CH}(F^{A})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type with quantifier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[A] => F[A]
\end_layout

\end_inset


\size small
 (Scala 3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,{\cal CH}(F^{A})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The correspondence between type constructions and 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\begin_inset CommandInset label
LatexCommand label
name "tab:ch-correspondence-type-notation-CH-propositions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solved examples: Type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
From now on, we will prefer to write types in the type notation rather than
 in the Scala syntax.
 The type notation allows us to write nameless type expressions and, in
 particular, makes the structure of disjunctive types and their parts more
 transparent, compared with the Scala syntax.
 Names of types and parts of types are, of course, helpful for the programmer
 because they show the significance of data in the application.
 However, writing names for every part of every type is not helpful for
 reasoning about the properties of types.
 Type notation makes reasoning about types easier, as we will see throughout
 this chapter.
 Once the programmer has finished deriving the necessary types and verifying
 their properties, the type expressions can be straightforwardly translated
 from the type notation into Scala code.
\end_layout

\begin_layout Standard
Let us get some experience converting between type notation and Scala code.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-dupl-function"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-dupl-function"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 taking an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returning the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, x)
\end_layout

\end_inset

.
 Derive the most general type for this function.
 Write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 in the type notation, and translate it into a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition.
 Simplify the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition if possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the code of the function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta(x: ...) = (x, x)
\end_layout

\end_inset

To derive the most general type for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

, first assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is a type parameter; then the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, x)
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

.
 We do not see any constraints on the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So the type parameter represents an arbitrary type and needs to be added
 to the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A](x: A): (A, A) = (x, x)
\end_layout

\end_inset

We find that the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A, A)
\end_layout

\end_inset

.
 We also note that there is only one way of implementing a fully parametric
 function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A, A)
\end_layout

\end_inset

: the function must duplicate its given argument.
\end_layout

\begin_layout Standard
It is convenient to use the letter 
\begin_inset Formula $\Delta$
\end_inset

 for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

.
 In the type notation, the type signature of 
\begin_inset Formula $\Delta$
\end_inset

 is written as 
\begin_inset Formula 
\[
\Delta^{A}:A\Rightarrow A\times A\quad.
\]

\end_inset

So the proposition 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 (meaning 
\begin_inset Quotes eld
\end_inset

the function 
\begin_inset Formula $\Delta$
\end_inset

 can be implemented
\begin_inset Quotes erd
\end_inset

) is
\begin_inset Formula 
\[
{\cal CH}(\Delta)=\forall A.{\cal \,CH}\left(A\Rightarrow A\times A\right)\quad.
\]

\end_inset

In the type expression 
\begin_inset Formula $A\Rightarrow A\times A$
\end_inset

, the product symbol (
\begin_inset Formula $\times$
\end_inset

) binds stronger than the function arrow (
\begin_inset Formula $\Rightarrow$
\end_inset

), so the parentheses in 
\begin_inset Formula $A\Rightarrow\left(A\times A\right)$
\end_inset

 may be omitted.
\end_layout

\begin_layout Standard
Using the rules for transforming 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions, we rewrite
\begin_inset Formula 
\begin{align*}
 & {\cal CH}(A\Rightarrow A\times A)\\
\text{rule for function types}:\quad & ={\cal CH}(A)\Rightarrow{\cal CH}(A\times A)\\
\text{rule for tuple types}:\quad & ={\cal CH}(A)\Rightarrow\left({\cal CH}(A)\wedge{\cal CH}(A)\right)\quad.
\end{align*}

\end_inset

Thus the proposition 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 is equivalent to
\begin_inset Formula 
\[
{\cal CH}(\Delta)=\forall A.\,{\cal CH}(A)\Rightarrow({\cal CH}(A)\wedge{\cal CH}(A))\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The standard disjunctive types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 are written in the type notation as
\begin_inset Formula 
\[
\text{Either}^{A,B}\triangleq A+B\quad,\quad\quad\text{Opt}^{A}\triangleq\bbnum 1+A\quad.
\]

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A+B$
\end_inset

 by definition of the disjunctive type operator (
\begin_inset Formula $+$
\end_inset

).
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 has two disjoint cases, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

.
 The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 is a 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

 contains a single value of type 
\begin_inset Formula $A$
\end_inset

.
 So, the type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-1-a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-1-a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The Scala definition of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

UserAction
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait UserAction
\end_layout

\begin_layout Plain Layout

final case class SetName(first: String, last: String) extends UserAction
\end_layout

\begin_layout Plain Layout

final case class SetEmail(email: String)              extends UserAction
\end_layout

\begin_layout Plain Layout

final case class SetUserId(id: Long)                  extends UserAction
\end_layout

\end_inset

is written in the type notation as
\begin_inset Formula 
\begin{equation}
\text{UserAction}\triangleq\text{String}\times\text{String}+\text{String}+\text{Long}\quad.\label{eq:ch-example-case-class-type-notation}
\end{equation}

\end_inset

The type operation 
\begin_inset Formula $\times$
\end_inset

 groups stronger than 
\begin_inset Formula $+$
\end_inset

, as in arithmetic.
 To derive the type notation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-case-class-type-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we first drop all names from case classes and get three nameless tuples
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String, String)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Long)
\end_layout

\end_inset

.
 Each of these tuples is then converted into a product using the operator
 
\begin_inset Formula $\times$
\end_inset

, and all products are 
\begin_inset Quotes eld
\end_inset

summed
\begin_inset Quotes erd
\end_inset

 in the type notation using the operator 
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The parameterized disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either3
\end_layout

\end_inset

 is a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Left[A, B, C](x: A)   extends Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Middle[A, B, C](x: B) extends Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Right[A, B, C](x: C)  extends Either3[A, B, C]
\end_layout

\end_inset

This disjunctive type is written in the type notation as
\begin_inset Formula 
\[
\text{Either3}^{A,B,C}\triangleq A+B+C\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 corresponding to the type notation 
\begin_inset Formula 
\[
F^{A}\triangleq\bbnum 1+\text{Int}\times A\times A+\text{Int}\times\left(\text{Int}\Rightarrow A\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The formula for 
\begin_inset Formula $F^{A}$
\end_inset

 defines a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 with three parts.
 To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 in Scala, we need to choose names for each of the disjoint parts, which
 will become case classes.
 For the purposes of this example, let us choose names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F3
\end_layout

\end_inset

.
 Each of these case classes needs to have the same type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So we begin writing the code as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A](...) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F2[A](...) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F3[A](...) extends F[A]
\end_layout

\end_inset

Each of these case classes represents one part of the disjunctive type:
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F1
\end_layout

\end_inset

 represents 
\begin_inset Formula $\bbnum 1$
\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F2
\end_layout

\end_inset

 represents 
\begin_inset Formula $\text{Int}\times A\times A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F3
\end_layout

\end_inset

 represents 
\begin_inset Formula $\text{Int}\times\left(\text{Int}\Rightarrow A\right)$
\end_inset

.
 To define these case classes, we need to name their parts.
 The final code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A]()                     extends F[A]  // Named unit
 type.
\end_layout

\begin_layout Plain Layout

final case class F2[A](n: Int, x1: A, x2: A) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F3[A](n: Int, f: Int => A)  extends F[A]
\end_layout

\end_inset

The names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 are chosen purely for convenience.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the type signature of the function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B]
\end_layout

\end_inset

in the type notation.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
This is a curried function, so we first rewrite the type signature as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B]: (A => B) => Option[A] => Option[B]
\end_layout

\end_inset

The type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 Now we can write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 as
\begin_inset Formula 
\begin{align*}
 & \text{fmap}^{A,B}:\left(A\Rightarrow B\right)\Rightarrow\bbnum 1+A\Rightarrow\bbnum 1+B\quad,\\
\text{or equivalently}:\quad & \text{fmap}:\forall(A,B).\,\left(A\Rightarrow B\right)\Rightarrow\bbnum 1+A\Rightarrow\bbnum 1+B\quad.
\end{align*}

\end_inset

We do not put parentheses around 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $\bbnum 1+B$
\end_inset

 because the function arrows (
\begin_inset Formula $\Rightarrow$
\end_inset

) group weaker than the other type operations.
 Parentheses around 
\begin_inset Formula $\left(A\Rightarrow B\right)$
\end_inset

 are required.
\end_layout

\begin_layout Standard
We will usually prefer to write type parameters in superscripts rather than
 under type quantifiers.
 So, we will prefer to write 
\begin_inset Formula $\text{id}^{A}=x^{:A}\Rightarrow x$
\end_inset

 rather than 
\begin_inset Formula $\text{id}:(\forall A.\,A\Rightarrow A)=x^{:A}\Rightarrow x$
\end_inset

.
\end_layout

\begin_layout Subsection
Exercises: Type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[T,A]
\end_layout

\end_inset

 corresponding to the type notation
\begin_inset Formula 
\[
Q^{T,A}\triangleq\bbnum 1+T\times A+\text{Int}\times(T\Rightarrow T)+\text{String}\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Rewrite 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, Int), Either[(A, Char), (A, Float)]]
\end_layout

\end_inset

 in the type notation.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OptE[A, B]
\end_layout

\end_inset

 written in the type notation as 
\begin_inset Formula $\text{OptE}^{A,B}\triangleq\bbnum 1+A+B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write a Scala type signature for the fully parametric function 
\begin_inset Formula 
\[
\text{flatMap}^{A,B}:\bbnum 1+A\Rightarrow\left(A\Rightarrow\bbnum 1+B\right)\Rightarrow\bbnum 1+B
\]

\end_inset

and implement this function, preserving information as much as possible.
\end_layout

\begin_layout Section
The logic of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions
\end_layout

\begin_layout Subsection
Motivation and first examples
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Motivation-and-first-examples"

\end_inset


\end_layout

\begin_layout Standard
So far, we were able to convert statements such as 
\begin_inset Quotes eld
\end_inset


\emph on
a fully parametric function can compute values of type
\emph default
 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 into logical propositions of the form 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 that we called 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 The next step is to determine the proof rules suitable for reasoning about
 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\end_layout

\begin_layout Standard
Formal logic uses axioms and derivation rules for proving that certain formulas
 are true or false.
 A simple example of a true formula is 
\begin_inset Quotes eld
\end_inset

any proposition 
\begin_inset Formula $\alpha$
\end_inset

 is equivalent to itself
\begin_inset Quotes erd
\end_inset

,
\begin_inset Formula 
\[
\forall\alpha.\,\alpha=\alpha\quad.
\]

\end_inset

In logic, equivalence of propositions is usually understood as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
implication
\end_layout

\end_inset


\series bold
implication
\series default
 (
\begin_inset Formula $\Rightarrow$
\end_inset

) in both directions: 
\begin_inset Formula $\alpha=\beta$
\end_inset

 means 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)\wedge\left(\beta\Rightarrow\alpha\right)$
\end_inset

.
 So, the above formula is the same as
\begin_inset Formula 
\[
\forall\alpha.\,\alpha\Rightarrow\alpha\quad.
\]

\end_inset

If the proposition 
\begin_inset Formula $\alpha$
\end_inset

 is a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition, 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 for some type 
\begin_inset Formula $A$
\end_inset

, we obtain the formula
\begin_inset Formula 
\begin{equation}
\forall A.\,{\cal CH}(A)\Rightarrow{\cal CH}(A)\quad.\label{eq:ch-type-sig-1}
\end{equation}

\end_inset

We expect true 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions to correspond to types that 
\emph on
can
\emph default
 be computed in a fully parametric function.
 Let us see if this example fits our expectations.
 We can rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-type-sig-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as
\begin_inset Formula 
\begin{align*}
 & \forall A.\,\gunderline{{\cal CH}(A)\Rightarrow{\cal CH}(A)}\\
\text{rule for function types}:\quad & =\gunderline{\forall A}.\,{\cal CH}\left(A\Rightarrow A\right)\\
\text{rule for parameterized types}:\quad & ={\cal CH}\left(\forall A.\,A\Rightarrow A\right)\quad.
\end{align*}

\end_inset

The last line shows the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition that corresponds to the function type 
\begin_inset Formula $\forall A.\,A\Rightarrow A$
\end_inset

.
 Translating the type notation into a Scala type signature, we get
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => A
\end_layout

\end_inset

This type signature can be easily implemented,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => A = { x => x }
\end_layout

\end_inset

So, in this example we see how we converted a true formula in logic into
 the type of a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 that can be implemented.
\end_layout

\begin_layout Standard
While the formula 
\begin_inset Formula $\forall\alpha.\,\alpha=\alpha$
\end_inset

 may be self-evident, the point of using formal logic is to have a set of
 axioms and proof rules that allow us to deduce 
\emph on
all
\emph default
 correct formulas systematically, without need for intuition or guessing.
 What axioms and proof rules are suitable for proving 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions?
\end_layout

\begin_layout Standard
A well-known set of logical rules is called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Boolean logic
\end_layout

\end_inset

Boolean logic.
 In that logic, each proposition is either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

, and the implication operation (
\begin_inset Formula $\Rightarrow$
\end_inset

) is defined by 
\begin_inset Formula 
\begin{equation}
\left(\alpha\Rightarrow\beta\right)\triangleq\left((\neg\alpha)\vee\beta\right)\quad.\label{eq:ch-definition-of-implication-in-Boolean-logic}
\end{equation}

\end_inset

To verify a formula, substitute 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

 into every variable and check if the formula has the value 
\begin_inset Formula $True$
\end_inset

 in all possible cases.
 The result can be arranged into a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
truth table
\end_layout

\end_inset

truth table.
 The basic operations (disjunction, conjunction, negation, and implication)
 have the following truth tables:
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\vee\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\neg\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
So the formula 
\begin_inset Formula $\alpha\Rightarrow\alpha$
\end_inset

 has the value 
\begin_inset Formula $True$
\end_inset

 whether 
\begin_inset Formula $\alpha$
\end_inset

 itself is 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This check is sufficient to show that 
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset

 is true in Boolean logic.
\end_layout

\begin_layout Standard
Here is the truth table for the formula 
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset

; that formula is true in Boolean logic since all values in the last column
 are 
\begin_inset Formula $True$
\end_inset

:
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The formula 
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset

 is not true in Boolean logic, which we can see from the following truth
 table (one value in the last column is 
\begin_inset Formula $False$
\end_inset

):
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows more examples of logical formulas that are true in Boolean logic.
 Each formula is first given in terms of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions (we denoted 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

 for brevity) and then into a Scala type signature of a function that can
 be implemented.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,A\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def id[A](x: A): A = x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,A\Rightarrow\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def toUnit[A](x: A): Unit = ()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\vee\beta)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\Rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def toL[A, B](x: A): Either[A, B] = Left(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\times B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def first[A, B](p: (A, B)): A = p._1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\beta\Rightarrow\alpha)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\Rightarrow(B\Rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def const[A, B](x: A): B => A = (_ => x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of logical formulas that are true theorems in Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-formulas-Boolean-theorems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-not-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 some examples of formulas that are 
\emph on
not true
\emph default
 in Boolean logic.
 Translated into type formulas and then into Scala, these formulas yield
 type signatures that 
\emph on
cannot
\emph default
 be implemented by fully parametric functions.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala type signature
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,True\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,\bbnum 1\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A](x: Unit): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\vee\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A+B\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](x: Either[A, B])
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\Rightarrow A\times B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](p: A): (A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\Rightarrow\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,(A\Rightarrow B)\Rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](x: A => B): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of logical formulas that are 
\emph on
not
\emph default
 true in Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-formulas-not-Boolean-theorems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At first sight, it appears from these examples that whenever a logical formula
 is true in Boolean logic, the corresponding type signature can be implemented
 in code, and vice versa.
 However, this is 
\emph on
incorrect
\emph default
: the rules of Boolean logic are not suitable for reasoning about types
 in a functional language.
 Below we will see some examples of formulas that are true in Boolean logic
 but yield unimplementable type signatures.
\end_layout

\begin_layout Subsection
Example: Failure of Boolean logic for type reasoning
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example:-Failure-of-Boolean-logic"

\end_inset


\end_layout

\begin_layout Standard
To see an explicit example of obtaining an incorrect result when using Boolean
 logic to reason about values computed by fully parametric functions, consider
 the following type,
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\Rightarrow B+C\right)\Rightarrow\left(A\Rightarrow B\right)+\left(A\Rightarrow C\right)\quad,\label{eq:ch-example-boolean-bad-type}
\end{equation}

\end_inset

which corresponds to the Scala type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bad[A, B, C](g: A => Either[B, C]): Either[A => B, A => C] = ???
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 cannot be implemented as a fully parametric function.
 To see why, consider that the only available data is a function 
\begin_inset Formula $g^{:A\Rightarrow B+C}$
\end_inset

, which returns values of type 
\begin_inset Formula $B$
\end_inset

 or 
\begin_inset Formula $C$
\end_inset

 depending (in some unknown way) on the input value of type 
\begin_inset Formula $A$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 must return either a function of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 or a function of type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

.
 How can the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 make this decision? The only input data is the function 
\begin_inset Formula $g$
\end_inset

 that takes an argument of type 
\begin_inset Formula $A$
\end_inset

.
 We could imagine applying 
\begin_inset Formula $g$
\end_inset

 to various arguments of type 
\begin_inset Formula $A$
\end_inset

 and to see whether 
\begin_inset Formula $g$
\end_inset

 returns a 
\begin_inset Formula $B$
\end_inset

 or a 
\begin_inset Formula $C$
\end_inset

.
 However, the type 
\begin_inset Formula $A$
\end_inset

 is arbitrary, and a fully parametric function cannot produce a value of
 type 
\begin_inset Formula $A$
\end_inset

 in order to apply 
\begin_inset Formula $g$
\end_inset

 to it.
 So the decision about whether to return 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\Rightarrow C$
\end_inset

 must be independent of the function 
\begin_inset Formula $g$
\end_inset

; that decision must be hard-coded in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Suppose we hard-coded the decision to return a function of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

.
 How can we create a function of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 in the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

? Given a value 
\begin_inset Formula $x^{:A}$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

, we would need to compute some value of type 
\begin_inset Formula $B$
\end_inset

.
 Since the type 
\begin_inset Formula $B$
\end_inset

 is arbitrary (it is a type parameter), we cannot produce a value of type
 
\begin_inset Formula $B$
\end_inset

 from scratch.
 The only potential source of values of type 
\begin_inset Formula $B$
\end_inset

 is the given function 
\begin_inset Formula $g$
\end_inset

.
 The only way of using 
\begin_inset Formula $g$
\end_inset

 is to apply it to 
\begin_inset Formula $x^{:A}$
\end_inset

.
 However, for some 
\begin_inset Formula $x$
\end_inset

, the value 
\begin_inset Formula $g(x)$
\end_inset

 may have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 is of type 
\begin_inset Formula $C$
\end_inset

.
 In that case, we will have a value of type 
\begin_inset Formula $C$
\end_inset

, not 
\begin_inset Formula $B$
\end_inset

.
 So, in general, we cannot guarantee that we can always obtain a value of
 type 
\begin_inset Formula $B$
\end_inset

 from a given value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 This means we cannot build a function of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 out of the function 
\begin_inset Formula $g$
\end_inset

.
 Similarly, we cannot build a function of type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

 out of 
\begin_inset Formula $g$
\end_inset

.
 
\end_layout

\begin_layout Standard
Whether we decide to return 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\Rightarrow C$
\end_inset

, we will not be able to return a value of the required type, as we just
 saw.
 We must conclude that we cannot implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 as a fully parametric function.
\end_layout

\begin_layout Standard
We could try to switch between 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 and 
\begin_inset Formula $A\Rightarrow C$
\end_inset

 depending on a given value of type 
\begin_inset Formula $A$
\end_inset

.
 This idea, however, means that we are working with a different type signature:
 
\begin_inset Formula 
\[
\forall(A,B,C).\,\left(A\Rightarrow B+C\right)\Rightarrow A\Rightarrow\left(A\Rightarrow B\right)+\left(A\Rightarrow C\right)\quad.
\]

\end_inset

This type signature 
\emph on
can
\emph default
 be implemented, for instance, by this Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B, C](g: A => Either[B, C]): A => Either[A=>B, A=>C] = { a =>
\end_layout

\begin_layout Plain Layout

  g(a) match {
\end_layout

\begin_layout Plain Layout

    case Left(b) => Left(_ => b)
\end_layout

\begin_layout Plain Layout

    case Right(c) => Right(_ => c)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

But this is not the required type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-bad-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Now let us convert the type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-bad-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition:
\begin_inset Formula 
\begin{align}
 & \forall(\alpha,\beta,\gamma).\,\left(\alpha\Rightarrow\left(\beta\vee\gamma\right)\right)\Rightarrow\left(\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)\right)\quad,\label{eq:abc-example-classical-logic-bad}\\
\text{where}\quad & \alpha\triangleq{\cal CH}(A),\quad\beta\triangleq{\cal CH}(B),\quad\gamma\triangleq{\cal CH}(C)\quad.\nonumber 
\end{align}

\end_inset

It turns out that this formula is true 
\emph on
in Boolean logic
\emph default
.
 To prove this, we need to show that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equal to 
\begin_inset Formula $True$
\end_inset

 for any Boolean values of the variables 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, 
\begin_inset Formula $\gamma$
\end_inset

.
 One way is to rewrite the expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) using the rules of Boolean logic, such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \gunderline{\alpha\Rightarrow}\left(\beta\vee\gamma\right)\\
\text{definition of }\Rightarrow\text{ via Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=(\neg\alpha)\vee\beta\vee\gamma\quad,\\
 & \gunderline{\left(\alpha\Rightarrow\beta\right)}\vee\gunderline{\left(\alpha\Rightarrow\gamma\right)}\\
\text{definition of }\Rightarrow\text{ via Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=\gunderline{(\neg\alpha)}\vee\beta\vee\gunderline{(\neg\alpha)}\vee\gamma\\
\text{property }x\vee x=x\text{ in Boolean logic}:\quad & \quad=(\neg\alpha)\vee\beta\vee\gamma\quad,
\end{align*}

\end_inset

showing that 
\begin_inset Formula $\alpha\Rightarrow(\beta\vee\gamma)$
\end_inset

 is in fact 
\emph on
equal
\emph default
 to 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)$
\end_inset

 in Boolean logic.
\end_layout

\begin_layout Standard
Let us also give a proof via truth-value reasoning.
 The only possibility for an implication 
\begin_inset Formula $X\Rightarrow Y$
\end_inset

 to be 
\begin_inset Formula $False$
\end_inset

 is when 
\begin_inset Formula $X=True$
\end_inset

 and 
\begin_inset Formula $Y=False$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be 
\begin_inset Formula $False$
\end_inset

 only if 
\begin_inset Formula $\left(\alpha\Rightarrow(\beta\vee\gamma)\right)=True$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)=False$
\end_inset

.
 A disjunction can be false only when both parts are false; so we must have
 both 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=False$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\gamma\right)=False$
\end_inset

.
 This is only possible if 
\begin_inset Formula $\alpha=True$
\end_inset

 and 
\begin_inset Formula $\beta=\gamma=False$
\end_inset

.
 But, with these value assignments, we find 
\begin_inset Formula $\left(\alpha\Rightarrow(\beta\vee\gamma)\right)=False$
\end_inset

 rather than 
\begin_inset Formula $True$
\end_inset

 as we assumed.
 It follows that we cannot ever make Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) equal to 
\begin_inset Formula $False$
\end_inset

.
 This proves Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to be true in Boolean logic.
\end_layout

\begin_layout Subsection
The rules of proof for 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-rules-of-proof"

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example:-Failure-of-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that some true formulas in Boolean logic do not correspond to types
 of 
\emph on
implementable
\emph default
 fully parametric functions.
 However, we have also seen several other examples where Boolean logic does
 provide correct results: some true formulas correspond to implementable
 type signatures, while some false formulas correspond to non-implementable
 type signatures.
\end_layout

\begin_layout Standard
Instead of guessing whether the rules of Boolean logic are suitable, let
 us derive the suitable logical axioms and proof rules systematically.
\end_layout

\begin_layout Standard
The proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is true when a value of type 
\begin_inset Formula $A$
\end_inset

 can be computed by a fully parametric function with a given type signature.
 To describe all possible ways of computing a value of type 
\begin_inset Formula $A$
\end_inset

, we need to enumerate all possible ways of writing code within a fully
 parametric function.
 The requirement of parametricity means that we are not allowed to use any
 specific types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 We are only allowed to work with values of unknown types described by the
 given type parameters.
 We cannot use any concrete values such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, or any library functions that work with specific (non-parametric) types;
 however, we are permitted to use fully parametric types, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

.
 The allowed eight code constructs are illustrated in this code fragment:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B, ...](a: A, b: B)...
 = { // (A given type signature.)
\end_layout

\begin_layout Plain Layout

  val x1: Unit = ()            // 1) Create a value of type Unit.
\end_layout

\begin_layout Plain Layout

  val x2: A = a                // 2) Use a given argument.
\end_layout

\begin_layout Plain Layout

  val x3 = { x: A => ...
 }     // 3) Create a function.
\end_layout

\begin_layout Plain Layout

  val x4: D = x3(x2)           // 4) Use a function.
\end_layout

\begin_layout Plain Layout

  val x5: (A, B) = (a, b)      // 5) Create a tuple.
\end_layout

\begin_layout Plain Layout

  val x6: B = x5._2            // 6) Use a tuple.
\end_layout

\begin_layout Plain Layout

  val x7: Option[A] = Some(x2) // 7) Create values of a disjunctive type.
\end_layout

\begin_layout Plain Layout

  val x8 = x7 match { ...
 }    // 8) Use values of a disjunctive type.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A value of type 
\begin_inset Formula $X$
\end_inset

 can be computed (i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula ${\cal CH}(X)$
\end_inset

 is true) if and only if we can create a sequence of computed values such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x2
\end_layout

\end_inset

, ..., each being the result of one of these eight code constructs, ending
 with a value of type 
\begin_inset Formula $X$
\end_inset

.
 So, each of the eight code constructs should correspond to a logical rule
 for proving a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition.
\end_layout

\begin_layout Standard
A set of axioms and proof rules defines a 
\series bold
formal logic
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
formal logic
\end_layout

\end_inset

.
 So, we will now write the proof rules that will define 
\emph on
the
\emph default
 logic appropriate for reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\end_layout

\begin_layout Standard
Because each proof rule will be obtained from a specific code construct,
 any 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition such as 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

 proved by applying a sequence of these rules will automatically correspond
 to a code fragment that combines the relevant code constructs to compute
 a value of type 
\begin_inset Formula $X$
\end_inset

.
 Conversely, any code computing a value of type 
\begin_inset Formula $X$
\end_inset

 must be a combination of some of the eight code constructs, and that combinatio
n can be automatically translated into a sequence of applications of proof
 rules in the logic to produce a proof of the proposition 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

.
\end_layout

\begin_layout Standard
Let us now write down the proof rules that follow from the eight code constructs.
 We will need to consider the full formulation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-CH-proposition-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions and write them as sequents such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For brevity, we define 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

, 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

, etc.
 It is also customary to use the letter 
\begin_inset Formula $\Gamma$
\end_inset

 to denote a set of premises, such as 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we can write a shorter formula 
\begin_inset Formula $\Gamma\vdash\alpha$
\end_inset

 instead of the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
With these notations, we will now enumerate all the possible ways of proving
 that a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition is true.
 We assume that the set of premises 
\begin_inset Formula $\Gamma$
\end_inset

 is known.
\end_layout

\begin_layout Paragraph
1) Create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value
\end_layout

\begin_layout Standard
At any place in the code, we may write the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 This expression corresponds to a proof of the proposition 
\begin_inset Formula ${\cal CH}(\bbnum 1)$
\end_inset

 with any set 
\begin_inset Formula $\Gamma$
\end_inset

 of premises (even with an empty set of premises).
 So, the sequent 
\begin_inset Formula $\Gamma\vdash{\cal CH}(\bbnum 1)$
\end_inset

 is always true.
 The code corresponding to the proof of this sequent is an expression that
 creates a value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash{\cal CH}(\bbnum 1)\right)=1\quad,
\]

\end_inset

where we denoted by 
\begin_inset Formula $1$
\end_inset

 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In formal logic, a sequent that is found to be always true, such as our
 
\begin_inset Formula $\Gamma\vdash{\cal CH}(\bbnum 1)$
\end_inset

, is called an 
\series bold
axiom
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
logical axiom
\end_layout

\end_inset

 and is written in the following notation,
\begin_inset Formula 
\[
\frac{}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{create unit})\quad\quad.
\]

\end_inset

The 
\begin_inset Quotes eld
\end_inset

fraction with a label
\begin_inset Quotes erd
\end_inset

 represents a proof rule.
 The denominator of the 
\begin_inset Quotes eld
\end_inset

fraction
\begin_inset Quotes erd
\end_inset

 is the target sequent that we need to prove.
 The numerator of the 
\begin_inset Quotes eld
\end_inset

fraction
\begin_inset Quotes erd
\end_inset

 can have zero or more other sequents that need to be proved before the
 target sequent can be proved.
 In this case, the set of previous sequents is empty: the target sequent
 is an axiom and so requires no previous sequents for its proof.
 The label 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create unit}$
\end_inset


\begin_inset Quotes erd
\end_inset

 is an arbitrary name used to refer to the rule.
\end_layout

\begin_layout Paragraph
2) Use a given argument
\end_layout

\begin_layout Standard
At any place within the code of a fully parametric function, we may use
 one of the function's arguments, say 
\begin_inset Formula $x^{:A}$
\end_inset

.
 If some argument has type 
\begin_inset Formula $A$
\end_inset

, it means that 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 belongs to the set of premises of the sequent we are trying to prove.
 To indicate this, we write the set of premises as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\Gamma,\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The code construct 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 computes a value of type 
\begin_inset Formula $A$
\end_inset

, i.e.
\begin_inset space ~
\end_inset

show that 
\begin_inset Formula $\alpha$
\end_inset

 is true, given these premises.
 This is expressed by the sequent 
\begin_inset Formula $\Gamma,\alpha\vdash\alpha$
\end_inset

.
 The proof of this sequent corresponds to an expression that returns one
 of the given arguments (which we here called 
\begin_inset Formula $x^{:A}$
\end_inset

),
\begin_inset Formula 
\[
\text{Proof}\big(\Gamma,\alpha\vdash\alpha\big)=x^{:A}\quad.
\]

\end_inset

This sequent is an axiom since its proof requires no previous sequents,
 The formal logic notation for this axiom is
\begin_inset Formula 
\[
\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use arg})\quad\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
3) Create a function
\end_layout

\begin_layout Standard
At any place in the code, we may compute a nameless function of type, say,
 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, by writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:A) => expr
\end_layout

\end_inset

 as long as a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 of type 
\begin_inset Formula $B$
\end_inset

 can be computed in the inner scope of the function.
 The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 is also required to be fully parametric; it may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and/or other values visible in that scope.
 So we now need to answer the question of whether a fully parametric function
 can compute a value of type 
\begin_inset Formula $B$
\end_inset

, given an argument of type 
\begin_inset Formula $A$
\end_inset

 as well as all other arguments previously given to the parent function.
 This question is answered by a sequent whose premises contain one more
 proposition, 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, in addition to all previously available premises.
 Translating this into the language of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions, we find that we will prove the sequent 
\begin_inset Formula 
\[
\Gamma\vdash{\cal CH}(A\Rightarrow B)\quad=\quad\Gamma\vdash{\cal CH}(A)\Rightarrow{\cal CH}(B)\quad\triangleq\quad\Gamma\vdash\alpha\Rightarrow\beta
\]

\end_inset

if we can prove the sequent 
\begin_inset Formula $\Gamma,{\cal CH}(A)\vdash{\cal CH}(B)=\Gamma,\alpha\vdash\beta$
\end_inset

.
 In the notation of formal logic, this is a 
\series bold
derivation rule
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
derivation rule
\end_layout

\end_inset

 (rather than an axiom) and is written as
\begin_inset Formula 
\[
\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})\quad\quad.
\]

\end_inset

The 
\series bold
turnstile
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
turnstile
\end_layout

\end_inset

 symbol, 
\begin_inset Formula $\vdash$
\end_inset

, groups weaker than other operators.
 So, we can write sequents such as 
\begin_inset Formula $(\Gamma,\alpha)\vdash(\beta\Rightarrow\gamma)$
\end_inset

 with fewer parentheses: 
\begin_inset Formula $\Gamma,\alpha\vdash\beta\Rightarrow\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
What code corresponds to the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 rule? The proof of 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

 depends on a proof of another sequent.
 So, the corresponding code must be a 
\emph on
function
\emph default
 that takes a proof of the previous sequent as an argument and returns a
 proof of the new sequent.
 By the CH correspondence, a proof of a sequent corresponds to a code expression
 of the type given by the goal of the sequent; the expression may use arguments
 of types corresponding to the premises of the sequent.
 So, a proof of the sequent 
\begin_inset Formula $\Gamma,\alpha\vdash\beta$
\end_inset

 is an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exprB
\end_layout

\end_inset

 of type 
\begin_inset Formula $B$
\end_inset

 that may use a given value of type 
\begin_inset Formula $A$
\end_inset

 as well as any other arguments given previously.
 Then we can write the proof code for the sequent 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

 as the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:A) => exprB
\end_layout

\end_inset

.
 This function has type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 and requires us to already have a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exprB
\end_layout

\end_inset

.
 This exactly corresponds to the proof rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 We may write the corresponding code as
\begin_inset Formula 
\[
\text{Proof}(\Gamma\vdash{\cal CH}(A)\Rightarrow{\cal CH}(B))=x^{:A}\Rightarrow\text{Proof}(\Gamma,x^{:A}\vdash{\cal CH}(B))\quad.
\]

\end_inset

Here we wrote 
\begin_inset Formula $x^{:A}$
\end_inset

 instead of 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 since the value 
\begin_inset Formula $x^{:A}$
\end_inset

 is a proof of the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

.
 We will see in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example:-Proving-a-ch-proposition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 how premises such as 
\begin_inset Formula $\Gamma,x^{:A}$
\end_inset

 are implemented in code.
\end_layout

\begin_layout Paragraph
4) Use a function
\end_layout

\begin_layout Standard
At any place in the code, we may apply an already defined function of type
 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 to an already computed value of type 
\begin_inset Formula $A$
\end_inset

.
 The result will be a value of type 
\begin_inset Formula $B$
\end_inset

.
 This corresponds to assuming 
\begin_inset Formula ${\cal CH}(A\Rightarrow B)$
\end_inset

 and 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, and then deriving 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

.
 The formal logic notation for this proof rule is
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})\quad\quad.
\]

\end_inset

The code corresponding to this proof rule takes previously computed values
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f:A => B
\end_layout

\end_inset

, and writes the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 This can be written as a function application,
\begin_inset Formula 
\[
\text{Proof}(\Gamma\vdash\beta)=\text{Proof}\left(\Gamma\vdash\alpha\Rightarrow\beta\right)(\text{Proof}(\Gamma\vdash\alpha))\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
5) Create a tuple
\end_layout

\begin_layout Standard
If we have already computed some values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

, we may write the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 and so compute a value of the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

.
 The proof rule is
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})\quad\quad.
\]

\end_inset

We can write the corresponding code expression as
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)=\text{Proof}\left(\Gamma\vdash\alpha\right)\times\text{Proof}\left(\Gamma\vdash\beta\right)\quad,
\]

\end_inset

where we write 
\begin_inset Formula $a\times b$
\end_inset

 to represent a pair of two values.
\end_layout

\begin_layout Standard
This rule describes creating a pair of values.
 A larger tuple, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(w, x, y, z)
\end_layout

\end_inset

, can be expressed via nested pairs, e.g.
\begin_inset space ~
\end_inset

as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(w, (x, (y, z)))
\end_layout

\end_inset

.
 So it is sufficient to have a sequent rule for creating pairs; this rule
 can express the sequent rules for creating all other tuples, and we do
 not need to define separate rules for, say, 
\begin_inset Formula $\Gamma\vdash\alpha\wedge\beta\wedge\gamma$
\end_inset

.
\end_layout

\begin_layout Paragraph
6) Use a tuple
\end_layout

\begin_layout Standard
If we already have a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t:(A,B)
\end_layout

\end_inset

 of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

, we can extract one of the parts of the tuple and obtain a value of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The code is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t._2
\end_layout

\end_inset

 respectively, and the corresponding sequent proof rules are
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)\quad\quad\quad\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\beta}\quad(\text{use tuple-}2)\quad\quad.
\]

\end_inset

The code can be written as
\begin_inset Formula 
\begin{align*}
\text{Proof}\left(\Gamma\vdash\alpha\right) & =\nabla_{1}\left(\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)\right)\quad,\\
\text{Proof}\left(\Gamma\vdash\beta\right) & =\nabla_{2}\left(\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)\right)\quad,
\end{align*}

\end_inset

where we introduced the notation 
\begin_inset Formula $\nabla_{1}$
\end_inset

 and 
\begin_inset Formula $\nabla_{2}$
\end_inset

 to mean the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Since all tuples can be expressed through pairs, it is sufficient to have
 proof rules for pairs.
\end_layout

\begin_layout Paragraph
7) Create a disjunctive value
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 corresponding to the disjunction 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 can be used to define any other disjunctive type; e.g.
\begin_inset space ~
\end_inset

a disjunctive type with three parts can be expressed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Either[B, C]]
\end_layout

\end_inset

.
 So it is sufficient to have proof rules for a disjunction of 
\emph on
two
\emph default
 propositions.
\end_layout

\begin_layout Standard
There are two ways of creating a value of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

: the code expressions are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x:A)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y:B)
\end_layout

\end_inset

.
 The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

 must have been computed previously (and correspond to previously proved
 sequents).
 So, the sequent proof rules are
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Left})\quad\quad\quad\frac{\Gamma\vdash\beta}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Right})\quad\quad.
\]

\end_inset

The corresponding code can be written as 
\begin_inset Formula 
\begin{align*}
\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right) & =\text{Left}(\text{Proof}\left(\Gamma\vdash\alpha\right))\quad,\\
\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right) & =\text{Right}(\text{Proof}\left(\Gamma\vdash\beta\right))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
8) Use a disjunctive value
\end_layout

\begin_layout Standard
The only way we may use a value of disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is by pattern matching on it:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: C = (e: Either[A, B]) match {
\end_layout

\begin_layout Plain Layout

  case Left(x:A)    => expr1(x)
\end_layout

\begin_layout Plain Layout

  case Right(y:B)   => expr2(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr1(x)
\end_layout

\end_inset

 must be an expression of some type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, computed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and any previously available arguments (i.e.
\begin_inset space ~
\end_inset

the premises 
\begin_inset Formula $\Gamma$
\end_inset

).
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr2(y)
\end_layout

\end_inset

 must be an expression of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 computed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

 and previous arguments.
 It is clear that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr1(x)
\end_layout

\end_inset

 represents a proof of a sequent with an additional premise of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula $\Gamma,\alpha\vdash\gamma$
\end_inset

, where we denoted 
\begin_inset Formula $\gamma\triangleq{\cal CH}(C)$
\end_inset

.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr2(y)
\end_layout

\end_inset

 is a proof of the sequent 
\begin_inset Formula $\Gamma,\beta\vdash\gamma$
\end_inset

.
 So, we can write the proof rule corresponding to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

case
\end_layout

\end_inset

 expression as a rule with three previous sequents:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use Either})\quad\quad.
\]

\end_inset

The code can be written as 
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\gamma\right)=\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right)\text{ match }\begin{cases}
\text{have }x^{:A}: & \text{Proof}\left(\Gamma,x^{:A}\vdash\gamma\right)\\
\text{have }y^{:B}: & \text{Proof}(\Gamma,y^{:B}\vdash\gamma)
\end{cases}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes the eight proof rules derived in this section.
 These proof rules define a logic known as the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
intuitionistic propositional logic
\end_layout

\end_inset

intuitionistic propositional logic
\series default
 or 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
constructive propositional logic
\end_layout

\end_inset

constructive propositional logic
\series default
.
 We will call this logic 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

 for short.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset Formula 
\begin{align*}
\text{axioms}:\quad & \frac{~}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{create unit})\quad\quad\quad\quad\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use arg})\\
\text{derivation rules}:\quad & \frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})\\
 & \frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})\\
 & \frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})\\
 & \frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)\quad\quad\quad\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\beta}\quad(\text{use tuple-}2)\\
 & \frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create \texttt{Left}})\quad\quad\quad\frac{\Gamma\vdash\beta}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create \texttt{Right}})\\
 & \frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use \texttt{Either}})
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof rules for the constructive logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Proof-rules-for-constructive-logic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Example: Proving a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition and deriving code
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example:-Proving-a-ch-proposition"

\end_inset


\end_layout

\begin_layout Standard
The task is to implement a fully parametric function
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "52col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: ((A => A) => B) => B = ???
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Implementing this function is the same as being able to compute a value
 of type 
\begin_inset Formula 
\[
F\triangleq\forall(A,B).\,((A\Rightarrow A)\Rightarrow B)\Rightarrow B\quad.
\]

\end_inset

Since the type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are arbitrary, the body of the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 cannot use any previously defined values of types 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $B$
\end_inset

.
 So, the task is formulated as computing a value of type 
\begin_inset Formula $F$
\end_inset

 with no previously defined values.
 This is written as the sequent 
\begin_inset Formula $\Gamma\vdash{\cal CH}(F)$
\end_inset

, where the set 
\begin_inset Formula $\Gamma$
\end_inset

 of premises is empty, 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

.
 Rewriting this sequent using the rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we get
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).\;\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta\quad,\label{eq:ch-example-sequent-2}
\end{equation}

\end_inset

where we denoted 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

.
 
\end_layout

\begin_layout Standard
The next step is to prove the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) using the logic proof rules of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For brevity, we will omit the quantifier 
\begin_inset Formula $\forall(\alpha,\beta)$
\end_inset

 since it will be present in front of every sequent.
\end_layout

\begin_layout Standard
Begin by looking for a proof rule whose 
\begin_inset Quotes eld
\end_inset

denominator
\begin_inset Quotes erd
\end_inset

 has a sequent similar to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), i.e.
\begin_inset space ~
\end_inset

has an implication (
\begin_inset Formula $p\Rightarrow q$
\end_inset

) in the goal.
 We have only one rule that can prove a sequent of the form 
\begin_inset Formula $\Gamma\vdash(p\Rightarrow q$
\end_inset

); this is the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 That rule requires us to already have a proof of the sequent 
\begin_inset Formula $(\Gamma,p)\vdash q$
\end_inset

.
 So, we use this rule with 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

, 
\begin_inset Formula $p=(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

, and 
\begin_inset Formula $q=\beta$
\end_inset

: 
\begin_inset Formula 
\[
\frac{(\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta}{\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta}\quad.
\]

\end_inset

We now need to prove the sequent 
\begin_inset Formula $(\alpha\Rightarrow\alpha)\Rightarrow\beta)\vdash\beta$
\end_inset

, which we can write as 
\begin_inset Formula $\Gamma_{1}\vdash\beta$
\end_inset

 where we defined 
\begin_inset Formula $\Gamma_{1}\triangleq[(\alpha\Rightarrow\alpha)\Rightarrow\beta]$
\end_inset

 to be the set containing the single premise 
\begin_inset Formula $(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
 
\end_layout

\begin_layout Standard
There are no proof rules that derive a sequent with an explicit premise
 of the form of an implication 
\begin_inset Formula $p\Rightarrow q$
\end_inset

.
 However, we have a rule called 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 that derives a sequent by assuming another sequent containing an implication.
 We would be able to use that rule,
\begin_inset Formula 
\[
\frac{\Gamma_{1}\vdash\alpha\Rightarrow\alpha\quad\quad\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta}{\Gamma_{1}\vdash\beta}\quad,
\]

\end_inset

if we could prove the two sequents 
\begin_inset Formula $\Gamma_{1}\vdash\alpha\Rightarrow\alpha$
\end_inset

 and 
\begin_inset Formula $\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
 To prove these sequents, note that the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 applies to 
\begin_inset Formula $\Gamma_{1}\vdash\alpha\Rightarrow\alpha$
\end_inset

 as follows,
\begin_inset Formula 
\[
\frac{\Gamma_{1},\alpha\vdash\alpha}{\Gamma_{1}\vdash\alpha\Rightarrow\alpha}\quad.
\]

\end_inset

The sequent 
\begin_inset Formula $\Gamma_{1},\alpha\vdash\alpha$
\end_inset

 is proved directly by the axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The sequent 
\begin_inset Formula $\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

 is also proved by the axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

 because 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 already contains 
\begin_inset Formula $(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
\end_layout

\begin_layout Standard
The proof of the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is now complete and can be visualized as a tree (Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The next step is to derive the code from this proof.
 
\end_layout

\begin_layout Standard
To do that, we combine the code expressions that correspond to each of the
 proof rules we used.
 We need to retrace the proof backwards, starting from the leaves of the
 tree and going towards the root, and to assemble the 
\begin_inset Formula $\text{Proof}\left(...\right)$
\end_inset

 code expressions one by one.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Preview

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ .$
\backslash
emptyset
\backslash
vdash((
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta)
\backslash
Rightarrow
\backslash
beta $ [ .{rule ``$
\backslash
text{create function}$''} [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash
\backslash
beta$ [ .{rule ``$
\backslash
text{use function}$''} [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha$ [ .{rule ``$
\backslash
text{create function}$''} [ .$
\backslash
Gamma_1,
\backslash
alpha
\backslash
vdash
\backslash
alpha$ {axiom ``$
\backslash
text{use arg}$''} ] ] ] [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta$ {axiom ``$
\backslash
text{use arg}$''} ] ] ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof tree for the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset CommandInset label
LatexCommand label
name "fig:Proof-of-the-sequent-example-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Begin with the left-most leaf 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 This rule corresponds to the code 
\begin_inset Formula $x^{:A}$
\end_inset

,
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma_{1},\alpha\vdash\alpha\right)=x^{:A}\quad.
\]

\end_inset

Here 
\begin_inset Formula $x^{:A}$
\end_inset

 must be a proof of the premise 
\begin_inset Formula $\alpha$
\end_inset

 in the sequent 
\begin_inset Formula $\Gamma_{1},\alpha\vdash\alpha$
\end_inset

.
 So, we need to use the same 
\begin_inset Formula $x^{:A}$
\end_inset

 when we write the code for the previous rule, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma_{1}\vdash\alpha\Rightarrow\alpha\right)=(x^{:A}\Rightarrow\text{Proof}\left(\Gamma_{1},\alpha\vdash\alpha\right))=(x^{:A}\Rightarrow x)\quad.
\]

\end_inset

The right-most leaf 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

 corresponds to the code 
\begin_inset Formula $f^{:(A\Rightarrow A)\Rightarrow B}$
\end_inset

, where 
\begin_inset Formula $f$
\end_inset

 is the premise contained in 
\begin_inset Formula $\Gamma_{1}$
\end_inset

.
 So we can write
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta\right)=f^{:(A\Rightarrow A)\Rightarrow B}\quad.
\]

\end_inset

The previous rule, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

, combines the two preceding proofs:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\left((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta\right)\\
 & =\text{Proof}(\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta)\left(\text{Proof}(\Gamma_{1}\vdash\alpha\Rightarrow\alpha)\right)\\
 & =f(x^{:A}\Rightarrow x)\quad.
\end{align*}

\end_inset

Keep going backwards and find that the rule applied before 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 We need to provide the same 
\begin_inset Formula $f^{:\left(A\Rightarrow A\right)\Rightarrow B}$
\end_inset

 as in the premise above, and so we obtain the code
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\left(\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta\right)\\
 & =f^{:\left(A\Rightarrow A\right)\Rightarrow B}\Rightarrow\text{Proof}\left((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta\right)\\
 & =f^{:\left(A\Rightarrow A\right)\Rightarrow B}\Rightarrow f(x^{:A}\Rightarrow x)\quad.
\end{align*}

\end_inset

This is the final code expression that implements the type 
\begin_inset Formula $(\left(A\Rightarrow A\right)\Rightarrow B)\Rightarrow B$
\end_inset

.
 In this way, we have systematically derived the code from the type signature
 of a function.
 This function can be implemented in Scala as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: ((A => A) => B) => B = { f => f(x => x) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We found the proof tree in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by guessing how to combine various proof rules.
 If we 
\emph on
somehow
\emph default
 find a proof tree for a sequent, we can prove the sequent and derive the
 corresponding code.
 However, it is not always obvious how to combine the proof rules for a
 given initial sequent.
 This is so because the rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 do not provide an algorithm for finding a proof tree automatically for
 a given initial sequent.
 It turns out that such an algorithm exists (the 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
LJT algorithm
\end_layout

\end_inset

LJT algorithm
\begin_inset Quotes erd
\end_inset

, see Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:The-Curry-Howard-correspondence"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 That algorithm can find proofs and derive code from type signatures containing
 tuples, disjunctive types, and function types (if the given type signature
 can be implemented).
\end_layout

\begin_layout Standard
The library 
\family typewriter
curryhoward
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Chymyst/curryhoward"

\end_inset


\end_layout

\end_inset


\family default
 implements the LJT algorithm.
 Here are some examples of using this library.
 We will run the 
\family typewriter
ammonite
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://ammonite.io/#Ammonite-Shell"

\end_inset


\end_layout

\end_inset


\family default
 shell to load the library more easily.
\end_layout

\begin_layout Standard
Consider the type signature 
\begin_inset Formula 
\[
\forall(A,B).\,\left(\left(\left(\left(A\Rightarrow B\right)\Rightarrow A\right)\Rightarrow A\right)\Rightarrow B\right)\Rightarrow B\quad.
\]

\end_inset

It is not immediately clear whether it is even possible to implement a function
 with this type signature.
 It turns out that it 
\emph on
is
\emph default
 possible, and the code can be derived automatically with help of the LJT
 algorithm.
 The library does this via the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implement
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ import $ivy.`io.chymyst::curryhoward:0.3.7`, io.chymyst.ch._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ def f[A, B]: ((((A => B) => A) => A) => B) => B = implement
\end_layout

\begin_layout Plain Layout

defined function f
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ println(f.lambdaTerm.prettyPrint)
\end_layout

\begin_layout Plain Layout

a => a (b => b (c => a (d => c)))
\end_layout

\end_inset

The code 
\begin_inset Formula $a\Rightarrow a\left(b\Rightarrow b\left(c\Rightarrow a\left(d\Rightarrow c\right)\right)\right)$
\end_inset

 was derived automatically for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 was compiled and is ready to be used in any subsequent code.
\end_layout

\begin_layout Standard
A compile-time error occurs when trying to use a type signature that cannot
 be implemented as a fully parametric function:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "59.5col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def g[A, B]: ((A => B) => A) => A = implement
\end_layout

\begin_layout Plain Layout

cmd3.sc:1: type ((A => B) => A) => A cannot be implemented
\end_layout

\begin_layout Plain Layout

def g[A, B]: ((A => B) => A) => A = implement
\end_layout

\begin_layout Plain Layout

                                    ^
\end_layout

\begin_layout Plain Layout

Compilation Failed
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The logical formula corresponding to this type signature is 
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).\,\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\Rightarrow\beta\quad.\label{eq:ch-example-3-peirce-law}
\end{equation}

\end_inset

This formula is known as 
\begin_inset Quotes eld
\end_inset

Peirce's law
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Peirce%27s_law"
target "https://en.wikipedia.org/wiki/Peirce%27s_law"
literal "false"

\end_inset


\end_layout

\end_inset

 It is another example showing that the logic of types in functional programming
 languages is not Boolean.
 Peirce's law is a true theorem in Boolean logic but does not hold in the
 constructive logic (i.e.
\begin_inset space ~
\end_inset

it cannot be derived using the proof rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 If we try to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g[A, B]
\end_layout

\end_inset

 with the type signature shown above, we will fail to write fully parametric
 code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 that compiles without type errors.
 We will fail because no such code exists,  not because we are insufficiently
 clever.
 The LJT algorithm can 
\emph on
prove
\emph default
 that the given type signature cannot be implemented; the 
\family typewriter
curryhoward
\family default
 library will then print an error message, and compilation will fail.
\end_layout

\begin_layout Standard
As another example, let us verify that the type signature from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example:-Failure-of-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot be implemented as a fully parametric function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def bad[A, B, C](g: A => Either[B, C]): Either[A => B, A => C] = implement
\end_layout

\begin_layout Plain Layout

cmd4.sc:1: type (A => Either[B, C]) => Either[A => B, A => C] cannot be implement
ed
\end_layout

\begin_layout Plain Layout

def bad[A, B, C](g: A => Either[B, C]): Either[A => B, A => C] = implement
\end_layout

\begin_layout Plain Layout

                                                                 ^
\end_layout

\begin_layout Plain Layout

Compilation Failed
\end_layout

\end_inset


\end_layout

\begin_layout Section
Solved examples: Equivalence of types
\end_layout

\begin_layout Standard
We found a correspondence between types, code, logical propositions, and
 proofs, which is known as the 
\series bold
Curry-Howard correspondence
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

.
 An example of the CH correspondence is that a proof of the logical proposition
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).\,\alpha\Rightarrow\left(\beta\Rightarrow\alpha\right)\label{eq:ch-proposition-example-2}
\end{equation}

\end_inset

corresponds to the code of the function 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (B => A) = { x => _ => x }
\end_layout

\end_inset

With the CH correspondence in mind, we may say that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

's code 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 the proof of the proposition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-proposition-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In this sense, the 
\emph on
existence
\emph default
 of the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => _ => x
\end_layout

\end_inset

 with the type 
\begin_inset Formula $A\Rightarrow(B\Rightarrow A)$
\end_inset

 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 a proof of the logical formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-proposition-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The Curry-Howard correspondence maps logic formulas such as 
\begin_inset Formula $(\alpha\vee\beta)\wedge\gamma$
\end_inset

 into type expressions such as 
\begin_inset Formula $\left(A+B\right)\times C$
\end_inset

.
 We have seen that types behave similarly to logic formulas in one respect:
 A logic formula is a true theorem when the corresponding type signature
 can be implemented as a fully parametric function, and vice versa.
\end_layout

\begin_layout Standard
It turns out that the similarity ends here.
 In other respects, type expressions behave as 
\emph on
arithmetic
\emph default
 expressions and not as logic formulas.
 For this reason, the type notation used in this book denotes disjunctive
 types by 
\begin_inset Formula $A+B$
\end_inset

 and tuples by 
\begin_inset Formula $A\times B$
\end_inset

, which is designed to remind us of arithmetic expressions (such as 
\begin_inset Formula $1+2$
\end_inset

 and 
\begin_inset Formula $2\times3$
\end_inset

) rather than of logic formulas (such as 
\begin_inset Formula $A\vee B$
\end_inset

 and 
\begin_inset Formula $A\wedge B$
\end_inset

).
 
\end_layout

\begin_layout Standard
The most important use of the type notation is for writing equations with
 types.
 Can we write type equations using the arithmetic intuition, such as 
\begin_inset Formula 
\begin{equation}
\left(A+B\right)\times C=A\times C+B\times C\quad?\label{eq:ch-example-distributive}
\end{equation}

\end_inset

In this section, we will learn how to check whether one type expression
 is equivalent to another.
\end_layout

\begin_layout Subsection
Logical identity does not correspond to type equivalence
\begin_inset CommandInset label
LatexCommand label
name "subsec:Logical-identity-not-type-equivalence"

\end_inset


\end_layout

\begin_layout Standard
The CH correspondence maps Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the logic formula
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\vee B\right)\wedge C=\left(A\wedge C\right)\vee\left(B\wedge C\right)\quad.\label{eq:ch-example-distributive-1}
\end{equation}

\end_inset

This formula is the well-known 
\begin_inset Quotes eld
\end_inset

distributive law
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Distributive_property#Rule_of_replacement"

\end_inset


\end_layout

\end_inset

 valid in Boolean logic as well as in the constructive logic.
 Since a logical equation 
\begin_inset Formula $P=Q$
\end_inset

 means 
\begin_inset Formula $P\Rightarrow Q$
\end_inset

 and 
\begin_inset Formula $Q\Rightarrow P$
\end_inset

, the distributive law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) means that the two formulas hold,
\begin_inset Formula 
\begin{align}
 & \forall(A,B,C).\,\left(A\vee B\right)\wedge C\Rightarrow\left(A\wedge C\right)\vee\left(B\wedge C\right)\quad,\label{eq:ch-example-distributive-1a}\\
 & \forall(A,B,C).\,\left(A\wedge C\right)\vee\left(B\wedge C\right)\Rightarrow\left(A\vee B\right)\wedge C\quad.\label{eq:ch-example-distributive-1b}
\end{align}

\end_inset

The CH correspondence maps these logical formulas to fully parametric functions
 with types
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: ((Either[A, B], C))    => Either[(A, C), (B, C)] = ???
\end_layout

\begin_layout Plain Layout

def f2[A, B, C]: Either[(A, C), (B, C)] => (Either[A, B], C) = ???
\end_layout

\end_inset

In the type notation, these type signatures are written as
\begin_inset Formula 
\begin{align*}
 & f_{1}:\forall(A,B,C).\,\left(A+B\right)\times C\Rightarrow A\times C+B\times C\quad,\\
 & f_{2}:\forall(A,B,C).\;A\times C+B\times C\Rightarrow\left(A+B\right)\times C\quad.
\end{align*}

\end_inset

Since the two logical formulas (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

)(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1b"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are true theorems in constructive logic, we expect to be able to implement
 the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 It is not straightforward to guess how to combine the proof rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to obtain proofs of Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

)(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1b"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, instead of deriving the implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 from the CH correspondence, we will write the Scala code directly.
\end_layout

\begin_layout Standard
To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, we need to do pattern matching on the argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: ((Either[A, B], C)) => Either[(A, C), (B, C)] = {
\end_layout

\begin_layout Plain Layout

  case (Left(a), c)   => Left((a, c))  // No other choice here.
\end_layout

\begin_layout Plain Layout

  case (Right(b), c)  => Right((b, c)) // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In both cases, we have only one possible expression of the correct type.
\end_layout

\begin_layout Standard
Similarly, the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 leaves us no choices:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "65col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B, C]: Either[(A, C), (B, C)] => (Either[A, B], C) = {
\end_layout

\begin_layout Plain Layout

  case Left((a, c))   => (Left(a), c)  // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right((b, c))  => (Right(b), c) // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 never discards any given values; in other words, these functions appear
 to preserve information.
 We can formulate this property rigorously as a requirement that an arbitrary
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: (Either[A, B], C)
\end_layout

\end_inset

 is mapped by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 to some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: Either[(A, C), (B, C)]
\end_layout

\end_inset

 and then mapped by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 back to 
\emph on
the same
\emph default
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 Similarly, any value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

y
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, C), (B, C)]
\end_layout

\end_inset

 should be transformed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 and then by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 back to the 
\emph on
same value
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Let us write these conditions as equations,
\begin_inset Formula 
\[
\forall x^{:(A+B)\times C}.\,f_{2}(f_{1}(x))=x\quad,\quad\quad\forall y^{:A\times C+B\times C}.\,f_{1}\left(f_{2}(y)\right)=y\quad.
\]

\end_inset

If we show that these equations hold, it will follow that all the information
 in a value 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 is completely preserved inside the value 
\begin_inset Formula $y\triangleq f_{1}(x)$
\end_inset

; the original value 
\begin_inset Formula $x$
\end_inset

 can be recovered as 
\begin_inset Formula $x=f_{2}(y)$
\end_inset

.
 Conversely, all the information in a value 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

 is preserved inside 
\begin_inset Formula $x\triangleq f_{2}(y)$
\end_inset

 and can be recovered by applying 
\begin_inset Formula $f_{1}$
\end_inset

.
 Since the values 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 and 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

 are arbitrary, it will follow the 
\emph on
data types
\emph default
 themselves, 
\begin_inset Formula $\left(A+B\right)\times C$
\end_inset

 and 
\begin_inset Formula $A\times C+B\times C$
\end_inset

, carry equivalent information.
 Such types are called 
\series bold
equivalent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
types!equivalent
\end_layout

\end_inset

 or 
\series bold
isomorphic
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
types!isomorphic
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
isomorphic types
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Generally, we say that types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are 
\series bold
equivalent
\series default
 or 
\series bold
isomorphic
\series default
 (denoted 
\begin_inset Formula $P\cong Q$
\end_inset

) 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence
\end_layout

\end_inset

when there exist functions 
\begin_inset Formula $f_{1}^{:P\Rightarrow Q}$
\end_inset

 and 
\begin_inset Formula $f_{2}^{:Q\Rightarrow P}$
\end_inset

 that are inverses of each other.
 We can write these conditions using the notation 
\begin_inset Formula $(f_{1}\bef f_{2})(x)\triangleq f_{2}(f_{1}(x))$
\end_inset

 as
\begin_inset Formula 
\[
f_{1}\bef f_{2}=\text{id}\quad,\quad\quad f_{2}\bef f_{1}=\text{id}\quad.
\]

\end_inset

(We omit type annotations since we already checked that the types match.
 In Scala, the forward composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 is the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

.) If these conditions hold, there is a one-to-one correspondence between
 the values of types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 This is the same as to say that the data types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 
\begin_inset Quotes eld
\end_inset

carry equivalent information
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
To verify that the Scala functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 defined above are inverses of each other, we first check if 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

.
 Applying 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 means to apply 
\begin_inset Formula $f_{1}$
\end_inset

 and then to apply 
\begin_inset Formula $f_{2}$
\end_inset

 to the result.
 Begin by applying 
\begin_inset Formula $f_{1}$
\end_inset

 to an arbitrary value 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

.
 A value 
\begin_inset Formula $x$
\end_inset

 of that type can be in only one of the two disjoint cases: a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 or a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

, for some values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c:C
\end_layout

\end_inset

.
 The Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 maps these tuples to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 and to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

 respectively; we can see this directly from the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

.
 We then apply 
\begin_inset Formula $f_{2}$
\end_inset

 to those values, which maps them back to a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 or a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 respectively, according to the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 These tuples are exactly the value 
\begin_inset Formula $x$
\end_inset

 we started with.
 So, applying 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 to an arbitrary 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 does not change the value 
\begin_inset Formula $x$
\end_inset

; this is the same as to say that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To check whether 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

, we apply 
\begin_inset Formula $f_{2}$
\end_inset

 to an arbitrary value 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

, which must be one of the two disjoint cases, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 maps these two cases into tuples 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 respectively.
 Then we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and map these tuples back to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

 respectively.
 It follows that applying 
\begin_inset Formula $f_{2}$
\end_inset

 and then 
\begin_inset Formula $f_{1}$
\end_inset

 will always recover the initial value 
\begin_inset Formula $y$
\end_inset

.
 In other words, 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
By looking at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we can directly observe that these functions are inverses of each other:
 the tuple pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 is mapped to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

, and the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

, or vice versa.
 It is then visually clear that no information is lost and that the original
 values are restored by function compositions 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 or 
\begin_inset Formula $f_{2}\bef f_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
We find that the logical identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to an equivalence of the corresponding types,
\begin_inset Formula 
\begin{equation}
\left(A+B\right)\times C\cong A\times C+B\times C\quad.\label{eq:ch-distributive-law-types}
\end{equation}

\end_inset

To get Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-distributive-law-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we just need to mentally replace the disjunction operations 
\begin_inset Formula $\vee$
\end_inset

 by 
\begin_inset Formula $+$
\end_inset

 and the conjunctions 
\begin_inset Formula $\wedge$
\end_inset

 by 
\begin_inset Formula $\times$
\end_inset

, as if we were converting to an arithmetic expression.
\end_layout

\begin_layout Standard
Consider another example of a logical identity: the associativity law for
 conjunction,
\begin_inset Formula 
\begin{equation}
\left(\alpha\wedge\beta\right)\wedge\gamma=\alpha\wedge\left(\beta\wedge\gamma\right)\quad.\label{eq:ch-example-associativity-conjunction}
\end{equation}

\end_inset

The corresponding types are 
\begin_inset Formula $(A\times B)\times C$
\end_inset

 and 
\begin_inset Formula $A\times(B\times C)$
\end_inset

; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B), C)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, (B, C))
\end_layout

\end_inset

.
 We can define functions that convert between these types without information
 loss
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f3[A, B, C]: (((A, B), C)) => (A, (B, C)) = { case ((a, b), c) => (a,
 (b, c)) }
\end_layout

\begin_layout Plain Layout

def f4[A, B, C]: (A, (B, C)) => (((A, B), C)) = { case (a, (b, c)) => ((a,
 b), c) }
\end_layout

\end_inset

By applying these functions to arbitrary values of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B), C)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, (B, C))
\end_layout

\end_inset

, it is easy to see that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f4
\end_layout

\end_inset

 are inverses of each other.
 This is also directly visible in the code: the nested tuple pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((a, b), c)
\end_layout

\end_inset

 is mapped to the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, (b, c))
\end_layout

\end_inset

 and back.
 So, the types 
\begin_inset Formula $\left(A\times B\right)\times C$
\end_inset

 and 
\begin_inset Formula $A\times\left(B\times C\right)$
\end_inset

 are equivalent, and we can write 
\begin_inset Formula $A\times B\times C$
\end_inset

 without parentheses.
\end_layout

\begin_layout Standard
Does a logical identity always correspond to an equivalence of types? This
 turns out to be 
\emph on
not
\emph default
 so.
 A simple example of a logical identity that does not correspond to a type
 equivalence is
\begin_inset Formula 
\begin{equation}
True\vee\alpha=True\quad.\label{eq:ch-example-logic-identity-2}
\end{equation}

\end_inset

Since the CH correspondence maps the logical constant 
\begin_inset Formula $True$
\end_inset

 into the unit type 
\begin_inset Formula $\bbnum 1$
\end_inset

, the type equivalence corresponding to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-logic-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\begin_inset Formula $\bbnum 1+A\cong\bbnum 1$
\end_inset

.
 The type denoted by 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 in Scala, so the corresponding equivalence is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset


\begin_inset Formula $\cong$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 Intuitively, this type equivalence should not hold: an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 may carry a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, which cannot possibly be stored in a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 We can verify this intuition rigorously by proving that any fully parametric
 functions with type signatures 
\begin_inset Formula $g_{1}:\bbnum 1+A\Rightarrow\bbnum 1$
\end_inset

 and 
\begin_inset Formula $g_{2}:\bbnum 1\Rightarrow\bbnum 1+A$
\end_inset

 will not satisfy 
\begin_inset Formula $g_{1}\bef g_{2}=\text{id}$
\end_inset

.
 To verify this, we note that 
\begin_inset Formula $g_{2}:\bbnum 1\Rightarrow\bbnum 1+A$
\end_inset

 must have type signature
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g2[A]: Unit => Option[A] = ???
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Such a function must always return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, since a fully parametric function cannot produce values of an arbitrary
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 from scratch.
 Therefore, 
\begin_inset Formula $g_{1}\bef g_{2}$
\end_inset

 is also a function that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 The function 
\begin_inset Formula $g_{1}\bef g_{2}$
\end_inset

 has type signature 
\begin_inset Formula $\bbnum 1+A\Rightarrow\bbnum 1+A$
\end_inset

 or, in Scala syntax, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[A]
\end_layout

\end_inset

, and is not equal to the identity function, because the identity function
 does not 
\emph on
always
\emph default
 return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Another example of a logical identity without a type equivalence is the
 distributive law 
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\wedge B\right)\vee C=\left(A\vee C\right)\wedge\left(B\vee C\right)\quad,\label{eq:ch-example-distributive-2}
\end{equation}

\end_inset

which is 
\begin_inset Quotes eld
\end_inset

dual
\begin_inset Quotes erd
\end_inset

 to the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), i.e.
\begin_inset space ~
\end_inset

it is obtained from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by swapping all conjunctions (
\begin_inset Formula $\wedge$
\end_inset

) with disjunctions (
\begin_inset Formula $\vee$
\end_inset

).
 In logic, a dual formula to an identity is often also an identity.
 The CH correspondence maps Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the type equation
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\times B\right)+C=\left(A+C\right)\times\left(B+C\right)\quad.\label{eq:ch-example-incorrect-identity-2}
\end{equation}

\end_inset

However, the types 
\begin_inset Formula $A\times B+C$
\end_inset

 and 
\begin_inset Formula $\left(A+C\right)\times\left(B+C\right)$
\end_inset

 are 
\emph on
not
\emph default
 equivalent.
 To see why, look at the possible code of the function 
\begin_inset Formula $g_{3}:\left(A+C\right)\times\left(B+C\right)\Rightarrow A\times B+C$
\end_inset

:
\begin_inset listings
lstparams "numbers=left,numberstyle={\small}"
inline false
status open

\begin_layout Plain Layout

def g3[A,B,C]: ((Either[A, C], Either[B, C])) => Either[(A, B), C] = {
\end_layout

\begin_layout Plain Layout

  case (Left(a), Left(b))      => Left((a, b)) // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(c))     => Right(c)     // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Right(c), Left(b))     => Right(c)     // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Right(c1), Right(c2))  => Right(c1)    // Must discard c1 or c2
 here!
\end_layout

\begin_layout Plain Layout

}   // May return Right(c2) instead of Right(c1) in the last line.
\end_layout

\end_inset

In line 5, we have a choice of returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c1)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c2)
\end_layout

\end_inset

.
 Whichever we choose, we will lose information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 because we will have discarded one of the given values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c2
\end_layout

\end_inset

.
 After evaluating 
\begin_inset Formula $g_{3}$
\end_inset

, we will not be able to restore 
\emph on
both
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c2
\end_layout

\end_inset

  no matter what code we write for 
\begin_inset Formula $g_{4}$
\end_inset

.
 So, the composition 
\begin_inset Formula $g_{3}\bef g_{4}$
\end_inset

 cannot be equal to the identity function.
 The type equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-incorrect-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is incorrect.
\end_layout

\begin_layout Standard
We conclude that a logical identity 
\begin_inset Formula ${\cal CH}(P)={\cal CH}(Q)$
\end_inset

 guarantees, via the CH correspondence, that we can implement 
\emph on
some
\emph default
 fully parametric functions of types 
\begin_inset Formula $P\Rightarrow Q$
\end_inset

 and 
\begin_inset Formula $Q\Rightarrow P$
\end_inset

.
 However, it is not guaranteed that these functions are inverses of each
 other, i.e.
\begin_inset space ~
\end_inset

that the type conversions 
\begin_inset Formula $P\Rightarrow Q$
\end_inset

 or 
\begin_inset Formula $Q\Rightarrow P$
\end_inset

 have no information loss
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

.
 So, the type equivalence 
\begin_inset Formula $P\cong Q$
\end_inset

 does not automatically follow from the logical identity 
\begin_inset Formula ${\cal CH}(P)={\cal CH}(Q)$
\end_inset

.
\end_layout

\begin_layout Standard
The CH correspondence means that we can compute 
\emph on
some
\emph default
 value 
\begin_inset Formula $x^{:X}$
\end_inset

 of a given type 
\begin_inset Formula $X$
\end_inset

 when the proposition 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

 holds.
 However, the CH correspondence does not guarantee that the computed value
 
\begin_inset Formula $x^{:X}$
\end_inset

 will satisfy any additional properties or laws.
\end_layout

\begin_layout Subsection
Arithmetic identity corresponds to type equivalence
\end_layout

\begin_layout Standard
Looking at the examples of equivalent types, we notice that correct type
 equivalences correspond to 
\emph on
arithmetical
\emph default
 identities rather than 
\emph on
logical
\emph default
 identities.
 For instance, the logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to the type equivalence
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-distributive-law-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which looks like a standard identity of arithmetic, such as
\begin_inset Formula 
\[
(1+10)\times20=1\times20+10\times20\quad.
\]

\end_inset

The logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which does 
\emph on
not
\emph default
 yield a type equivalence, leads to an incorrect arithmetic equation
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-incorrect-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, e.g.
\begin_inset space ~
\end_inset


\begin_inset Formula $\left(1\times10\right)+20\neq\left(1+20\right)\times\left(10+20\right)$
\end_inset

.
 Similarly, the associativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-associativity-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to a type equivalence and to the arithmetic identity
\begin_inset Formula 
\[
\left(a\times b\right)\times c=a\times\left(b\times c\right)\quad,
\]

\end_inset

while the logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-logic-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which does not yield a type equivalence, leads to an incorrect arithmetic
 statement (
\begin_inset Formula $\forall a.\,1+a=1$
\end_inset

).
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes these and other examples of logical identities, with the correspondi
ng type equivalences.
 In all rows, quantifiers such as 
\begin_inset Formula $\forall\alpha$
\end_inset

 or 
\begin_inset Formula $\forall(A,B)$
\end_inset

 are implied when necessary.
\end_layout

\begin_layout Standard
Because we chose the type notation to be similar to the ordinary arithmetic
 notation, it is easy to translate a possible type equivalence into an arithmeti
c equation.
 In all cases, valid arithmetic identities correspond to type equivalences,
 and failures to obtain a type equivalence correspond to incorrect arithmetic
 identities.
 With regard to type equivalence, types such as 
\begin_inset Formula $A+B$
\end_inset

 and 
\begin_inset Formula $A\times B$
\end_inset

 behave similarly to arithmetic expressions such as 
\begin_inset Formula $10+20$
\end_inset

 and 
\begin_inset Formula $10\times20$
\end_inset

 and not similarly to logical formulas such as 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 and 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logical identity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type equivalence (if it holds)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True\vee\alpha=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+A\not\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True\wedge\alpha=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1\times A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False\vee\alpha=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False\wedge\alpha=False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\vee\beta=\beta\vee\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A+B\cong B+A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\wedge\beta=\beta\wedge\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times B\cong B\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\vee\gamma=\alpha\vee\left(\beta\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\wedge\beta\right)\wedge\gamma=\alpha\wedge\left(\beta\wedge\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A\times B\right)\times C\cong A\times\left(B\times C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\wedge\gamma=\left(\alpha\wedge\gamma\right)\vee\left(\beta\wedge\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A+B\right)\times C\cong A\times C+B\times C$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\wedge\beta\right)\vee\gamma=\left(\alpha\vee\gamma\right)\wedge\left(\beta\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A\times B\right)+C\not\cong\left(A+C\right)\times\left(B+C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logic identities with disjunction and conjunction, and the corresponding
 equivalences of types.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-identities-with-disjunction-and-conjunction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We already verified the first line and the last three lines of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Other identities are verified in a similar way.
 Let us begin with lines 3 and 4 of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which involve the proposition 
\begin_inset Formula $False$
\end_inset

 and the corresponding 
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

void type 
\begin_inset Formula $\bbnum 0$
\end_inset

, defined in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 Reasoning about the void type needs a special technique that we will now
 develop while verifying the type isomorphisms 
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset

 and 
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-0-times-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-0-times-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 0\times A$
\end_inset

 represents the Scala tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

.
 To demonstrate that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 is equivalent to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, we need to show that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 has 
\emph on
no
\emph default
 values.
 Indeed, how could we create a value of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, Int)
\end_layout

\end_inset

? We would need to fill both parts of the tuple.
 We have values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, but we can never get a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 So, regardless of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, it is impossible to create any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

.
 In other words, the set of values of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 is empty; but that is the definition of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 The types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 0\times A$
\end_inset

) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 0$
\end_inset

) are both void and therefore equivalent.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-0-plus-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-0-plus-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 represents the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

.
 We need to show that any value of that type can be mapped without loss
 of information to a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and vice versa.
 This means implementing functions 
\begin_inset Formula $f_{1}:\bbnum 0+A\Rightarrow A$
\end_inset

 and 
\begin_inset Formula $f_{2}:A\Rightarrow\bbnum 0+A$
\end_inset

 such that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
The argument of 
\begin_inset Formula $f_{1}$
\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

.
 How can we create a value of that type? Our only choices are to create
 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Nothing
\end_layout

\end_inset

, or to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:A
\end_layout

\end_inset

.
 However, we cannot create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 because the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has 
\emph on
no
\emph default
 values; so we cannot create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

.
 The only remaining possibility is to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, any values of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 must be of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

, and we can extract that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Either[Nothing, A] => A = {
\end_layout

\begin_layout Plain Layout

  case Right(y) => y
\end_layout

\begin_layout Plain Layout

// No need for case Left(x) => ...
 since no x can be given there.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

For the same reason, there is only one implementation of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A]: A => Either[Nothing, A] = { y => Right(y) }
\end_layout

\end_inset

It is clear from the code that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
\end_layout

\begin_layout Standard
We have just seen that a value of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 is always a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:A
\end_layout

\end_inset

.
 Similarly, a value of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 is always a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 So, we will use the notation 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 to 
\emph on
denote
\emph default
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 parts of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

.
 This notation agrees with the behavior of the Scala compiler, which will
 infer the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Nothing] 
\end_layout

\end_inset

or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

 for these parts:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "53col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toLeft[A, B]: A => Either[A, B] = x => Left(x)
\end_layout

\begin_layout Plain Layout

def toRight[A, B]: B => Either[A, B] = y => Right(y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toLeft(123)
\end_layout

\begin_layout Plain Layout

res0: Either[Int, Nothing] = Left(123)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toRight(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res1: Either[Nothing, String] = Right("abc")
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We can write the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toRight
\end_layout

\end_inset

 in a code notation as 
\begin_inset Formula 
\begin{align*}
 & \text{toLeft}^{A,B}=x^{:A}\Rightarrow x^{:A}+\bbnum 0^{:B}\quad,\\
 & \text{toRight}^{A,B}=y^{:B}\Rightarrow\bbnum 0^{:A}+y^{:B}\quad.
\end{align*}

\end_inset

In this notation, a value of the disjunctive type is shown without using
 Scala class names such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

.
 This shortens the writing and speeds up code reasoning.
\end_layout

\begin_layout Standard
The type annotation 
\begin_inset Formula $\bbnum 0^{:A}$
\end_inset

 is helpful to remind ourselves about the type parameter 
\begin_inset Formula $A$
\end_inset

 used e.g.
\begin_inset space ~
\end_inset

by the disjunctive value 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset

 in the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toRight[A, B]
\end_layout

\end_inset

.
 Without this type annotation, 
\begin_inset Formula $\bbnum 0+y^{:B}$
\end_inset

 means a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 where the parameter 
\begin_inset Formula $A$
\end_inset

 is left unspecified and should be determined by matching the types of other
 expressions.
\end_layout

\begin_layout Standard
In the notation 
\begin_inset Formula $\bbnum 0+y^{:B}$
\end_inset

, we use the symbol 
\begin_inset Formula $\bbnum 0$
\end_inset

 rather than an ordinary zero (
\begin_inset Formula $0$
\end_inset

), to avoid suggesting that 
\begin_inset Formula $0$
\end_inset

 is a value of type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 The void type 
\begin_inset Formula $\bbnum 0$
\end_inset

 has no values, unlike the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, 
\begin_inset Formula $\bbnum 1$
\end_inset

, which has a value denoted by 
\begin_inset Formula $1$
\end_inset

 in the code notation.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-1xA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-1xA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\times\bbnum 1\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The corresponding Scala types are the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, Unit)
\end_layout

\end_inset

 and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 We need to implement functions 
\begin_inset Formula $f_{1}:\forall A.\,A\times\bbnum 1\Rightarrow A$
\end_inset

 and 
\begin_inset Formula $f_{2}:\forall A.\,A\Rightarrow A\times\bbnum 1$
\end_inset

 and to demonstrate that they are inverses of each other.
 The Scala code for these functions is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: ((A, Unit)) => A = { case (a, ()) => a }
\end_layout

\begin_layout Plain Layout

def f2[A]: A => (A, Unit) = { a => (a, ()) }
\end_layout

\end_inset

Let us first write a proof by reasoning directly with Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(f1 andThen f2)((a,())) == f2(f1((a,())) == f2(a) == (a, ())
\end_layout

\begin_layout Plain Layout

(f2 andThen f1)(a) == f1(f2(a)) == f1((a, ())) = a
\end_layout

\end_inset

Now let us write a proof in the code notation.
 The codes of 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are
\begin_inset Formula 
\begin{align*}
f_{1} & =a^{:A}\times1\Rightarrow a\quad,\\
f_{2} & =a^{:A}\Rightarrow a\times1\quad,
\end{align*}

\end_inset

where we denoted by 
\begin_inset Formula $1$
\end_inset

 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
 We find
\begin_inset Formula 
\begin{align*}
(f_{1}\bef f_{2})(a^{:A}\times1) & =f_{2}\left(f_{1}(a\times1)\right)=f_{2}\left(a\right)=a\times1\quad,\\
(f_{2}\bef f_{1})(a^{:A}) & =f_{1}(f_{2}(a))=f_{1}(a\times1)=a\quad.
\end{align*}

\end_inset

This shows that both compositions are identity functions.
 Another way of writing the proof is by computing the function compositions
 symbolically, without applying to a value 
\begin_inset Formula $a^{:A}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(a\times1\Rightarrow a\right)\bef\left(a\Rightarrow a\times1\right)=\left(a\times1\Rightarrow a\times1\right)=\text{id}^{A\times\bbnum 1}\quad,\\
f_{2}\bef f_{1} & =\left(a\Rightarrow a\times1\right)\bef\left(a\times1\Rightarrow a\right)=\left(a\Rightarrow a\right)=\text{id}^{A}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-A+B"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-A+B"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A+B\cong B+A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The corresponding Scala types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[B, A]
\end_layout

\end_inset

.
 We use pattern matching to implement the functions required for the type
 equivalence:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "55col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -86baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Either[A, B] => Either[B, A] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Right(a) // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Left(b)  // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A, B]: Either[B, A] => Either[A, B] = f1[B, A]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\end_inset

The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are implemented by code that can be derived unambiguously from the type
 signatures.
 For instance, the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Left(a) => ...
\end_layout

\end_inset

 is required to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[B, A]
\end_layout

\end_inset

 by using only a given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 The only way of doing that is by returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is clear from the code that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 To verify that rigorously, we need show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

 is equal to an identity function.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

 applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 contains two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case ...
\end_layout

\end_inset

 lines, each returning a result.
 So, we need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 separately in each line.
 Evaluate the code symbolically:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(f1 andThen f2) == {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => f2(Right(a))
\end_layout

\begin_layout Plain Layout

  case Right(b)   => f2(Left(b))
\end_layout

\begin_layout Plain Layout

} == {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Left(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Right(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The result is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B] => Either[A, B]
\end_layout

\end_inset

 that does not change its argument; so it is equal to the identity function.
 
\end_layout

\begin_layout Standard
Let us now write the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 in the code notation and perform the same derivation.
 We will also develop a useful notation for functions operating on disjunctive
 types.
\end_layout

\begin_layout Standard
The pattern matching construction in the Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 contains a pair of functions with types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Either[B, A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => Either[B, A]
\end_layout

\end_inset

.
 One of these functions is chosen depending on whether the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 has type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+B$
\end_inset

.
 So, we may write the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 as
\begin_inset Formula 
\[
f_{1}\triangleq x^{:A+B}\Rightarrow\begin{cases}
\text{if }x=a^{:A}+\bbnum 0^{:B}\quad: & \bbnum 0^{:B}+a^{:A}\\
\text{if }x=\bbnum 0^{:A}+b^{:B}\quad: & b^{:B}+\bbnum 0^{:A}
\end{cases}
\]

\end_inset

Since both the argument and the result of 
\begin_inset Formula $f_{1}$
\end_inset

 are disjunctive types with 
\begin_inset Formula $2$
\end_inset

 parts each, it is convenient to write the code of 
\begin_inset Formula $f_{1}$
\end_inset

 as a 
\begin_inset Formula $2\times2$
\end_inset

 matrix that maps the input parts to the output parts:
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type!matrix notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
matrix notation
\end_layout

\end_inset


\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Either[A, B] => Either[B, A] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Right(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Left(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -200baselineskip%
\end_inset


\end_layout

\end_inset


\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset Formula 
\[
f_{1}\triangleq\begin{array}{|c||cc|}
 & B & A\\
\hline A~ & \bbnum 0 & a^{:A}\Rightarrow a\\
B~ & b^{:B}\Rightarrow b & \bbnum 0
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Standard
The rows of the matrix correspond to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 rows in the Scala code; there is one row for each part of the disjunctive
 type of the argument.
 The columns of the matrix correspond to the parts of the disjunctive type
 of the result.
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching!matrix notation
\end_layout

\end_inset

 The double line marks the input types of the functions.
\end_layout

\begin_layout Standard
The code of 
\begin_inset Formula $f_{2}$
\end_inset

 is written similarly; let us rename arguments for clarity:
\begin_inset space \hfill{}
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Wrap figure
lines 4
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: Either[B, A] => Either[A, B] = {
\end_layout

\begin_layout Plain Layout

  case Left(b)    => Right(b)
\end_layout

\begin_layout Plain Layout

  case Right(a)   => Left(a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace -150baselineskip%
\end_inset


\begin_inset Formula 
\[
f_{2}\triangleq\begin{array}{|c||cc|}
 & A & B\\
\hline B~ & \bbnum 0 & y^{:B}\Rightarrow y\\
A~ & x^{:A}\Rightarrow x & \bbnum 0
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
The forward composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 is computed by the standard rules of row-by-column matrix multiplication.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Matrix_multiplication"

\end_inset


\end_layout

\end_inset

 The 
\begin_inset Formula $\bbnum 0$
\end_inset

 terms are omitted, and the remaining expressions are composed:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\begin{array}{|c||cc|}
 & B & A\\
\hline A~ & \bbnum 0 & a^{:A}\Rightarrow a\\
B~ & b^{:B}\Rightarrow b & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & B\\
\hline B~ & \bbnum 0 & y^{:B}\Rightarrow y\\
A~ & x^{:A}\Rightarrow x & \bbnum 0
\end{array}\\
\text{use matrix multiplication}:\quad & =\begin{array}{|c||cc|}
 & A & B\\
\hline A~ & (a^{:A}\Rightarrow a)\bef(x^{:A}\Rightarrow x) & \bbnum 0\\
B~ & \bbnum 0 & (b^{:B}\Rightarrow b)\bef(y^{:B}\Rightarrow y)
\end{array}\\
\text{function composition}:\quad & =\begin{array}{|c||cc|}
 & A & B\\
\hline A~ & \text{id} & \bbnum 0\\
B~ & \bbnum 0 & \text{id}
\end{array}=\text{id}^{:A+B\Rightarrow A+B}\quad.
\end{align*}

\end_inset

Several features of the matrix notation are helpful in such calculations.
 The parts of the code of 
\begin_inset Formula $f_{1}$
\end_inset

 are automatically composed with the corresponding parts of the code of
 
\begin_inset Formula $f_{2}$
\end_inset

.
 To check that the types match in the function composition, we just need
 to compare the types in the output row 
\begin_inset Formula $\begin{array}{||cc|}
B & A\end{array}$
\end_inset

 of 
\begin_inset Formula $f_{1}$
\end_inset

 with the input column 
\begin_inset Formula $\begin{array}{|c||}
B\\
A
\end{array}$
\end_inset

 of 
\begin_inset Formula $f_{2}$
\end_inset

.
 Once we verified that all types match, we may omit the type annotations
 and write the derivation as
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\begin{array}{||cc|}
\bbnum 0 & a^{:A}\Rightarrow a\\
b^{:B}\Rightarrow b & \bbnum 0
\end{array}\,\bef\,\begin{array}{||cc|}
\bbnum 0 & y^{:B}\Rightarrow y\\
x^{:A}\Rightarrow x & \bbnum 0
\end{array}\\
\text{use matrix multiplication}:\quad & =\begin{array}{||cc|}
(a^{:A}\Rightarrow a)\bef(x^{:A}\Rightarrow x) & \bbnum 0\\
\bbnum 0 & (b^{:B}\Rightarrow b)\bef(y^{:B}\Rightarrow y)
\end{array}\\
\text{function composition}:\quad & =\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}=\text{id}\quad.
\end{align*}

\end_inset

The identity function is represented by the diagonal matrix 
\begin_inset Formula $\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\,$
\end_inset

, just as in standard matrix notation.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-AxB"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-AxB"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\times B\cong B\times A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-A+B+C"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-A+B+C"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset

.
 The equivalences 
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset

 and 
\begin_inset Formula $\left(A\times B\right)\times C\cong A\times\left(B\times C\right)$
\end_inset

, which was verified in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Logical-identity-not-type-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

, permit us to write the type notation as 
\begin_inset Formula $A+B+C$
\end_inset

 and 
\begin_inset Formula $A\times B\times C$
\end_inset

 without the parentheses.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-A+B2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-A+B2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula 
\[
\left(A+B\right)\times\left(A+B\right)=A\times A+\bbnum 2\times A\times B+B\times B\quad,
\]

\end_inset

where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Subsection
Type cardinalities and type equivalence
\end_layout

\begin_layout Standard
To understand why type equivalences are related to arithmetic identities,
 consider the question of how many different values a given type can have.
\end_layout

\begin_layout Standard
Begin by counting the number of distinct values for simple types.
 For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has only one distinct value; the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has zero values; the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type has two distinct values, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

; and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 has 
\begin_inset Formula $2^{32}$
\end_inset

 distinct values.
\end_layout

\begin_layout Standard
It is more difficult to count the number of distinct values in a type such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, which is equivalent to a list of unknown length, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Char]
\end_layout

\end_inset

.
 However, each computer's memory is limited, so there will exist a maximum
 length for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, and so the total number of possible different strings will be finite (at
 least, for any given computer).
\end_layout

\begin_layout Standard
For a given type 
\begin_inset Formula $A$
\end_inset

, let us denote by 
\begin_inset Formula $\left|A\right|$
\end_inset

 the number of distinct values of type 
\begin_inset Formula $A$
\end_inset

.
 The number 
\begin_inset Formula $\left|A\right|$
\end_inset

 is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
cardinality
\end_layout

\end_inset


\series bold
cardinality
\series default
 of type 
\begin_inset Formula $A$
\end_inset

; this is the same as the number of elements in the set of all values of
 type 
\begin_inset Formula $A$
\end_inset

.
 Since any computer's memory is finite, and since we may assume that we
 are already working with the largest possible computer, then there will
 be 
\emph on
finitely
\emph default
 many different values of a given type 
\begin_inset Formula $A$
\end_inset

 that can exist in the computer.
 So, we may assume that 
\begin_inset Formula $\left|A\right|$
\end_inset

 is always a finite integer value.
 This assumption will simplify our reasoning.
 We will not actually need to compute the precise number of, say, all the
 different possible strings; it is sufficient to know that the set of all
 strings is finite, so that we can denote its cardinality by 
\begin_inset Formula $\left|\text{String}\right|$
\end_inset

.
\end_layout

\begin_layout Standard
The next step is to consider the cardinality of types such as 
\begin_inset Formula $A\times B$
\end_inset

 and 
\begin_inset Formula $A+B$
\end_inset

.
 If the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have cardinalities 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

, it follows that the set of all distinct pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 has 
\begin_inset Formula $\left|A\right|\times\left|B\right|$
\end_inset

 elements.
 So the cardinality of the type 
\begin_inset Formula $A\times B$
\end_inset

 is equal to the (arithmetic) product of the cardinalities of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 The set of all pairs 
\begin_inset Formula 
\[
\left\{ (a,b):a\in A,b\in B\right\} 
\]

\end_inset

is also known as the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cartesian product
\end_layout

\end_inset


\series bold
Cartesian product
\series default
 of sets 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, and is denoted by 
\begin_inset Formula $A\times B$
\end_inset

.
 For this reason, the tuple type is also called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product type
\end_layout

\end_inset


\series bold
product type
\series default
.
 Accordingly, the type notation adopts the symbol 
\begin_inset Formula $\times$
\end_inset

 for the product type.
\end_layout

\begin_layout Standard
The set of all distinct values of the type 
\begin_inset Formula $A+B$
\end_inset

, i.e.
\begin_inset space ~
\end_inset

of the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, is a disjoint union of the set of values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 and the set of values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(b)
\end_layout

\end_inset

.
 It is clear that the cardinalities of these sets are equal to 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

 respectively.
 So the cardinality of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is equal to 
\begin_inset Formula $\left|A\right|+\left|B\right|$
\end_inset

.
 For this reason, disjunctive types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 are also called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
sum type
\end_layout

\end_inset


\series bold
sum types
\series default
, and the type notation adopts the symbol 
\begin_inset Formula $+$
\end_inset

 for these types.
\end_layout

\begin_layout Standard
We can write our conclusions as
\begin_inset Formula 
\begin{align*}
\left|A\times B\right| & =\left|A\right|\times\left|B\right|\quad,\\
\left|A+B\right| & =\left|A\right|+\left|B\right|\quad.
\end{align*}

\end_inset

The type notation, 
\begin_inset Formula $A\times B$
\end_inset

 for the pairs and 
\begin_inset Formula $A+B$
\end_inset

 for the disjunctive types, translates directly into type cardinalities.
\end_layout

\begin_layout Standard
The last step is to notice that two types can be equivalent, 
\begin_inset Formula $P\cong Q$
\end_inset

, only if their cardinalities are equal, 
\begin_inset Formula $\left|P\right|=\left|Q\right|$
\end_inset

.
 When the cardinalities are not equal, 
\begin_inset Formula $\left|P\right|\neq\left|Q\right|$
\end_inset

, it will be impossible to have a one-to-one correspondence between the
 sets of values of type 
\begin_inset Formula $P$
\end_inset

 and values of type 
\begin_inset Formula $Q$
\end_inset

.
 So it will be impossible to convert values from type 
\begin_inset Formula $P$
\end_inset

 to type 
\begin_inset Formula $Q$
\end_inset

 and back without loss of information.
\end_layout

\begin_layout Standard
We conclude that types are equivalent when a logical identity 
\emph on
and
\emph default
 an arithmetic identity hold.
\end_layout

\begin_layout Standard
The presence of both identities does not automatically guarantee a useful
 type equivalence.
 The fact that information in one type can be identically stored in another
 type does not necessarily mean that it is helpful to do so in a given applicati
on.
\end_layout

\begin_layout Standard
For example, the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[A]]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Boolean, A]
\end_layout

\end_inset

 are equivalent because both types contain 
\begin_inset Formula $2+\left|A\right|$
\end_inset

 distinct values.
 The short notation for these types is 
\begin_inset Formula $\bbnum 1+\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $\bbnum 2+A$
\end_inset

 respectively (the type Boolean is denoted by 
\begin_inset Formula $\bbnum 2$
\end_inset

 since it has only two distinct values).
 
\end_layout

\begin_layout Standard
One could easily write code to convert between these types without loss
 of information:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[Option[A]] => Either[Boolean, A] = {
\end_layout

\begin_layout Plain Layout

  case None           => Left(false) // Or maybe Left(true)?
\end_layout

\begin_layout Plain Layout

  case Some(None)     => Left(true)
\end_layout

\begin_layout Plain Layout

  case Some(Some(x))  => Right(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Boolean, A] => Option[Option[A]] = {
\end_layout

\begin_layout Plain Layout

  case Left(false)    => None
\end_layout

\begin_layout Plain Layout

  case Left(true)     => Some(None)
\end_layout

\begin_layout Plain Layout

  case Right(x)       => Some(Some(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A sign of trouble is the presence of an arbitrary choice in this code.
 In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, we could map 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(false)
\end_layout

\end_inset

 or to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(true)
\end_layout

\end_inset

, and adjust the rest of the code accordingly; the type equivalence would
 still hold.
 So, formally speaking, these types 
\emph on
are
\emph default
 equivalent, but there is no 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

 choice of the conversion functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 that will work correctly in all applications, because the meaning of these
 data types is application-dependent.
 This type equivalence is 
\begin_inset Quotes eld
\end_inset

accidental
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!accidental
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-cardinality-option-either"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-cardinality-option-either"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Are the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 equivalent? Check whether the corresponding logic identity and arithmetic
 identity hold.
\end_layout

\begin_layout Paragraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the given types in the type notation: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $\bbnum 1+A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 is written also as 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 This already indicates, by looking at the notation alone, that the types
 are equivalent.
 But let us verify explicitly that the type notation is not misleading here.
\end_layout

\begin_layout Standard
To establish type equivalence, we need to implement two fully parametric
 functions
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[A] => Either[Unit, A] = ???
\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Unit, A] => Option[A] = ???
\end_layout

\end_inset

such that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
 It is straightforward to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[A] => Either[Unit, A] = {
\end_layout

\begin_layout Plain Layout

  case None      => Left(())
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Right(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Unit, A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Left(())   => None
\end_layout

\begin_layout Plain Layout

  case Right(x)   => Some(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code clearly shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other; this verifies the type equivalence.
\end_layout

\begin_layout Standard
The logic identity is 
\begin_inset Formula $True\vee A=True\vee A$
\end_inset

 and holds trivially.
 It remains to check the arithmetic identity, which relates the number of
 distinct values of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

.
 Assume that the number of distinct values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is 
\begin_inset Formula $\left|A\right|$
\end_inset

.
 Any possible value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So the number of distinct values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $1+\left|A\right|$
\end_inset

.
 All possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 are of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(())
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So the number of distinct values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 is 
\begin_inset Formula $1+\left|A\right|$
\end_inset

.
 We see that the arithmetic identity holds: the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 have equally many distinct values.
\end_layout

\begin_layout Standard
This example shows that the type notation is helpful for reasoning about
 type equivalences.
 The solution was found immediately when we wrote the type notation, 
\begin_inset Formula $\bbnum 1+A$
\end_inset

, for the given types.
\end_layout

\begin_layout Subsection
Type equivalence involving function types
\end_layout

\begin_layout Standard
Until now, we have looked at product types and disjunctive types.
 Let us now consider type constructions involving function types.
\end_layout

\begin_layout Standard
Consider two types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, whose cardinalities are known as 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

.
 What is the cardinality of the set of all maps between given sets 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

? In other words, how many distinct values does the function type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 have? A function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 needs to select a value of type 
\begin_inset Formula $B$
\end_inset

 for each possible value of type 
\begin_inset Formula $A$
\end_inset

.
 Therefore, the number of different functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 is 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 (the arithmetic exponent
\begin_inset Index idx
status open

\begin_layout Plain Layout
exponent
\end_layout

\end_inset

, 
\begin_inset Formula $\left|B\right|$
\end_inset

 to the power 
\begin_inset Formula $\left|A\right|$
\end_inset

).
\end_layout

\begin_layout Standard
For the types 
\begin_inset Formula $A=B=\text{Int}$
\end_inset

, we have 
\begin_inset Formula $\left|A\right|=\left|B\right|=2^{32}$
\end_inset

, and so the estimate will give 
\begin_inset Formula 
\[
\left|A\Rightarrow B\right|=\left(2^{32}\right)^{\left(2^{32}\right)}=2^{32\times2^{32}}=2^{2^{37}}\approx10^{4.1\times10^{10}}\quad.
\]

\end_inset

In fact, most of these functions will map integers to integers in a complicated
 (and practically useless) way and will be impossible to implement on a
 realistic computer because their code will be much longer than the available
 memory.
 So, the number of practically implementable functions of type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 is often much smaller than 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

.
 Nevertheless, the estimate 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 is useful since it shows the number of distinct functions that are possible
 in principle.
\end_layout

\begin_layout Standard
Let us now see what logic identities and arithmetic identities are available
 for type expressions involving function types.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 lists the available identities and the corresponding type equivalences.
 (In the last column, we defined 
\begin_inset Formula $a\triangleq\left|A\right|$
\end_inset

, 
\begin_inset Formula $b\triangleq\left|B\right|$
\end_inset

, and 
\begin_inset Formula $c\triangleq\left|C\right|$
\end_inset

 for brevity.) 
\end_layout

\begin_layout Standard
It is notable that no logic identity is available for the formula 
\begin_inset Formula $\alpha\Rightarrow\left(\beta\vee\gamma\right)$
\end_inset

, and correspondingly no type equivalence is available for the type expression
 
\begin_inset Formula $A\Rightarrow B+C$
\end_inset

 (although there is an identity for 
\begin_inset Formula $A\Rightarrow B\times C$
\end_inset

).
 The presence of type expressions of the form 
\begin_inset Formula $A\Rightarrow B+C$
\end_inset

 makes type reasoning more complicated because they cannot be transformed
 into equivalent formulas with simpler parts.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logical identity (if holds)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type equivalence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Arithmetic identity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(True\Rightarrow\alpha\right)=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1\Rightarrow A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a^{1}=a$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(False\Rightarrow\alpha\right)=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0\Rightarrow A\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a^{0}=1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\Rightarrow True\right)=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\Rightarrow\bbnum 1\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1^{a}=1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\Rightarrow False\right)\neq False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\Rightarrow\bbnum 0\not\cong\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0^{a}\neq0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\Rightarrow\gamma=\left(\alpha\Rightarrow\gamma\right)\wedge\left(\beta\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A+B\Rightarrow C\cong\left(A\Rightarrow C\right)\times\left(B\Rightarrow C\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $c^{a+b}=c^{a}\times c^{b}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(\alpha\wedge\beta)\Rightarrow\gamma=\alpha\Rightarrow\left(\beta\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times B\Rightarrow C\cong A\Rightarrow B\Rightarrow C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $c^{a\times b}=\left(c^{b}\right)^{a}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\Rightarrow\left(\beta\wedge\gamma\right)=\left(\alpha\Rightarrow\beta\right)\wedge\left(\alpha\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\Rightarrow B\times C\cong\left(A\Rightarrow B\right)\times\left(A\Rightarrow C\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(b\times c\right)^{a}=b^{a}\times c^{a}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logical identities with implication, and the corresponding type equivalences
 and arithmetic identities.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-identities-with-function-types"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now prove some of the type identities in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-f"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-f"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 1\Rightarrow A\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 1\Rightarrow A$
\end_inset

 means the Scala function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

.
 There is only one value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, so the choice of a function of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

 is the same as the choice of a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Thus, the number of distinct values of the type 
\begin_inset Formula $\bbnum 1\Rightarrow A$
\end_inset

 is 
\begin_inset Formula $\left|A\right|$
\end_inset

, and the arithmetic identity holds.
\end_layout

\begin_layout Standard
To verify the type equivalence explicitly, we need to implement two functions
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: (Unit => A) => A = ???
\end_layout

\begin_layout Plain Layout

def f2[A]: A => Unit => A = ???
\end_layout

\end_inset

The first function needs to produce a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, given an argument of the function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

.
 The only possibility is to apply that function to the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

; we can always produce that value as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: (Unit => A) => A = (h: Unit => A) => h(())
\end_layout

\end_inset

Implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is straightforward; we can just discard the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A]: A => Unit => A = (x: A) => _ => x
\end_layout

\end_inset

It remains to show that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 Let us perform the proof using Scala code and then using the code notation.
\end_layout

\begin_layout Standard
Writing Scala code, compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(f2(x))
\end_layout

\end_inset

 for an arbitrary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 Substituting the code, we get
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f1(f2(x)) == f1(_ => x) == (_ => x)(()) == x
\end_layout

\end_inset

Now compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2(f1(h))
\end_layout

\end_inset

 for arbitrary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h: Unit => A
\end_layout

\end_inset

 in Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f2(f1(h)) == f2(h(())) == { _ => h(()) }
\end_layout

\end_inset

How can we show that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{_ => h(())}
\end_layout

\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

? Whenever we apply equal functions to equal arguments, they return equal
 results.
 In our case, the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, so we only need to verify that the result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 to the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 is the same as the result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{_ => h(())}
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 In other words, we need to apply both sides to an additional argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f2(f1(h))(()) == { _ => h(()) } (()) == h(())
\end_layout

\end_inset

This completes the proof.
\end_layout

\begin_layout Standard
For comparison, let us show the same proof in the code notation.
 The functions 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are 
\begin_inset Formula 
\begin{align*}
 & f_{1}\triangleq h^{:\bbnum 1\Rightarrow A}\Rightarrow h(1)\quad,\\
 & f_{2}\triangleq x^{:A}\Rightarrow1\Rightarrow x\quad.
\end{align*}

\end_inset

Now write the function compositions in both directions:
\begin_inset Formula 
\begin{align*}
 & f_{1}\bef f_{2}=(h^{:\bbnum 1\Rightarrow A}\Rightarrow h(1))\bef(x^{:A}\Rightarrow1\Rightarrow x)\\
\text{compute composition}:\quad & =\left(h\Rightarrow1\Rightarrow h(1)\right)\\
\text{note that }1\Rightarrow h(1)\text{ is the same as }h:\quad & =\left(h\Rightarrow h\right)=\text{id}\quad.\\
 & f_{2}\bef f_{1}=(x^{:A}\Rightarrow1\Rightarrow x)\bef(h^{:\bbnum 1\Rightarrow A}\Rightarrow h(1))\\
\text{compute composition}:\quad & =x\Rightarrow(1\Rightarrow x)(1)\\
\text{apply function}:\quad & =\left(x\Rightarrow x\right)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The type 
\begin_inset Formula $\bbnum 1\Rightarrow A$
\end_inset

 is equivalent to the type 
\begin_inset Formula $A$
\end_inset

, but these types are not the same.
 The most important difference between these types is that a value of type
 
\begin_inset Formula $A$
\end_inset

 is available immediately, while a value of type 
\begin_inset Formula $\bbnum 1\Rightarrow A$
\end_inset

 is a function that still needs to be applied to an argument (of type 
\begin_inset Formula $\bbnum 1$
\end_inset

) before a value of type 
\begin_inset Formula $A$
\end_inset

 is obtained.
 The type 
\begin_inset Formula $\bbnum 1\Rightarrow A$
\end_inset

 may represent an 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
on-call value
\end_layout

\end_inset

 value of type 
\begin_inset Formula $A$
\end_inset

; that is, a value computed on demand every time.
 (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Lazy-values-iterators-and-streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details about 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset

 values.)
\end_layout

\begin_layout Standard
The void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 
\begin_inset Formula $\bbnum 0$
\end_inset

 needs special reasoning.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-0-to-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0\Rightarrow A\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
What could be a function 
\begin_inset Formula $f^{:\bbnum 0\Rightarrow A}$
\end_inset

 from the type 
\begin_inset Formula $\bbnum 0$
\end_inset

 to a type 
\begin_inset Formula $A$
\end_inset

? Since there exist no values of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, the function 
\begin_inset Formula $f$
\end_inset

 will never be applied to any arguments and so 
\emph on
does not need
\emph default
 to compute any actual values of type 
\begin_inset Formula $A$
\end_inset

.
 So, 
\begin_inset Formula $f$
\end_inset

 is a function whose body may be empty; or at least it does not need to
 contain any expressions of type 
\begin_inset Formula $A$
\end_inset

.
 In Scala, such a function can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def absurd[A]: Nothing => A = { ??? }
\end_layout

\end_inset

This code will compile without type errors.
 An equivalent code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def absurd[A]: Nothing => A = { x => ??? }
\end_layout

\end_inset

The symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset

 is defined in the Scala library and represents code that is 
\begin_inset Quotes eld
\end_inset

not implemented
\begin_inset Quotes erd
\end_inset

.
 Trying to evaluate this symbol will produce an error:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ???
\end_layout

\begin_layout Plain Layout

scala.NotImplementedError: an implementation is missing
\end_layout

\begin_layout Plain Layout

  scala.Predef$.$qmark$qmark$qmark(Predef.scala:288) 
\end_layout

\end_inset

Since the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd
\end_layout

\end_inset

 is impossible to apply to an argument, this error will never happen.
 So, we can pretend that the result value (which will never be computed
 or returned) has any required type, e.g.
\begin_inset space ~
\end_inset

the type 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Let us now verify that there exists 
\emph on
only one
\emph default
 function of type 
\begin_inset Formula $\bbnum 0\Rightarrow A$
\end_inset

.
 Suppose there are two such functions, 
\begin_inset Formula $f^{:\bbnum 0\Rightarrow A}$
\end_inset

 and 
\begin_inset Formula $g^{:\bbnum 0\Rightarrow A}$
\end_inset

.
 Are 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 different functions? We would see that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are different only if we had a value 
\begin_inset Formula $x$
\end_inset

 such that 
\begin_inset Formula $f(x)\neq g(x)$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 However, there are 
\emph on
no
\emph default
 values of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, and so we will never be able to find such 
\begin_inset Formula $x$
\end_inset

.
 It follows that any two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $\bbnum 0\Rightarrow A$
\end_inset

 are equal.
 In other words, there exists only 
\emph on
one
\emph default
 distinct value of type 
\begin_inset Formula $\bbnum 0\Rightarrow A$
\end_inset

; i.e.
\begin_inset space ~
\end_inset

the cardinality of the type 
\begin_inset Formula $\bbnum 0\Rightarrow A$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

.
 So, the type 
\begin_inset Formula $\bbnum 0\Rightarrow A$
\end_inset

 is equivalent to the type 
\begin_inset Formula $\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-A-0"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $A\Rightarrow\bbnum 0\not\cong\bbnum 0$
\end_inset

 and 
\begin_inset Formula $A\Rightarrow\bbnum 0\not\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To prove that two types are 
\emph on
not
\emph default
 equivalent, it is sufficient to show that their type cardinalities are
 different.
 Let us determine the cardinality of the type 
\begin_inset Formula $A\Rightarrow\bbnum 0$
\end_inset

, assuming that the cardinality of 
\begin_inset Formula $A$
\end_inset

 is known.
 We note that a function of type, say, 
\begin_inset Formula $\text{Int}\Rightarrow\bbnum 0$
\end_inset

 is impossible to implement.
 (If we had such a function 
\begin_inset Formula $f^{:\text{Int}\Rightarrow\bbnum 0}$
\end_inset

, we could evaluate, say, 
\begin_inset Formula $x\triangleq f(123)$
\end_inset

 and obtain a value 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, which is impossible by definition of the type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 It follows that 
\begin_inset Formula $\left|\text{Int}\Rightarrow\bbnum 0\right|=0$
\end_inset

.
 However, Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\bbnum 0\Rightarrow\bbnum 0$
\end_inset

 has cardinality 
\begin_inset Formula $1$
\end_inset

.
 So, the cardinality 
\begin_inset Formula $\left|A\Rightarrow\bbnum 0\right|=1$
\end_inset

 if the type 
\begin_inset Formula $A$
\end_inset

 is itself 
\begin_inset Formula $\bbnum 0$
\end_inset

 but 
\begin_inset Formula $\left|A\Rightarrow\bbnum 0\right|=0$
\end_inset

 for all other types 
\begin_inset Formula $A$
\end_inset

.
 We conclude that the type 
\begin_inset Formula $A\Rightarrow\bbnum 0$
\end_inset

 is not equivalent to 
\begin_inset Formula $\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 1$
\end_inset

 for all 
\begin_inset Formula $A$
\end_inset

; it is equivalent to 
\begin_inset Formula $\bbnum 0$
\end_inset

 only for non-void types 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\Rightarrow\bbnum 1\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
There is only one fully parametric function that returns 
\begin_inset Formula $\bbnum 1$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => Unit = { _ => () }
\end_layout

\end_inset

The function 
\begin_inset Formula $f$
\end_inset

 cannot use its argument of type 
\begin_inset Formula $A$
\end_inset

 since nothing is known about that type.
 So the code of 
\begin_inset Formula $f$
\end_inset

 
\emph on
must
\emph default
 discard its argument and return the fixed value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 In the code notation, this function is written as
\begin_inset Formula 
\[
f^{:A\Rightarrow\bbnum 1}\triangleq\left(\_\Rightarrow1\right)\quad.
\]

\end_inset

We can show that there exist only 
\emph on
one
\emph default
 distinct function of type 
\begin_inset Formula $A\Rightarrow\bbnum 1$
\end_inset

 (that is, the type 
\begin_inset Formula $A\Rightarrow\bbnum 1$
\end_inset

 has cardinality 
\begin_inset Formula $1$
\end_inset

).
 Assume that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are two such functions, and try to find a value 
\begin_inset Formula $x^{:A}$
\end_inset

 such that 
\begin_inset Formula $f(x)\neq g(x)$
\end_inset

.
 We cannot find any such 
\begin_inset Formula $x$
\end_inset

 because 
\begin_inset Formula $f(x)=1$
\end_inset

 and 
\begin_inset Formula $g(x)=1$
\end_inset

 for all 
\begin_inset Formula $x$
\end_inset

.
 So, any two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $A\Rightarrow\bbnum 1$
\end_inset

 must be equal to each other.
 Any type having cardinality 
\begin_inset Formula $1$
\end_inset

 is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 So 
\begin_inset Formula $A\Rightarrow\bbnum 1\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula 
\[
A+B\Rightarrow C\cong(A\Rightarrow C)\times(B\Rightarrow C)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing two functions with type signatures
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (Either[A, B] => C) => (A => C, B => C) = ???
\end_layout

\begin_layout Plain Layout

def f2[A,B,C]: ((A => C, B => C)) => Either[A, B] => C = ???
\end_layout

\end_inset

The code can be derived unambiguously from the type signatures.
 For the first function, we need to produce a pair of functions of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => C, B => C)
\end_layout

\end_inset

.
 Can we produce the first part of that pair? Computing a function of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

 means that we need to produce a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 given an arbitrary value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 The available data is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B] => C
\end_layout

\end_inset

 called, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

.
 We can apply that function to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 and obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 as required.
 So, a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

 is computed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a => h(Left(a))
\end_layout

\end_inset

.
 Similarly, we produce a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

.
 The code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (Either[A, B] => C) => (A => C, B => C) =
\end_layout

\begin_layout Plain Layout

  (h: Either[A, B] => C) => (a => h(Left(a)), b => h(Right(b)))
\end_layout

\end_inset

A code notation for this function is
\begin_inset Formula 
\begin{align*}
 & f_{1}:\left(A+B\Rightarrow C\right)\Rightarrow\left(A\Rightarrow C\right)\times\left(B\Rightarrow C\right)\quad,\\
 & f_{1}\triangleq h^{:A+B\Rightarrow C}\Rightarrow\left(a^{:A}\Rightarrow h(a+\bbnum 0^{:B})\right)\times\left(b^{:B}\Rightarrow h(\bbnum 0^{:A}+b)\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
For the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we need to apply pattern matching to both curried arguments and then return
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 This can be achieved in only one way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A,B,C]: ((A => C, B => C)) => Either[A, B] => C = { case (f, g) =>
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => f(a)
\end_layout

\begin_layout Plain Layout

    case Right(b)   => g(b)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A code notation for this function can be written as
\begin_inset Formula 
\begin{align*}
 & f_{2}:\left(A\Rightarrow C\right)\times\left(B\Rightarrow C\right)\Rightarrow A+B\Rightarrow C\quad,\\
 & f_{2}\triangleq f^{:A\Rightarrow C}\times g^{:B\Rightarrow C}\Rightarrow\begin{array}{|c||c|}
 & C\\
\hline A & a\Rightarrow f(a)\\
B & b\Rightarrow g(b)
\end{array}\quad.
\end{align*}

\end_inset

The matrix in the last line has only one column because the result type,
 
\begin_inset Formula $C$
\end_inset

, is not known to be a disjunctive type.
 We may simplify the functions, e.g.
\begin_inset space ~
\end_inset


\begin_inset Formula $a\Rightarrow f(a)$
\end_inset

 into 
\begin_inset Formula $f$
\end_inset

, and write
\begin_inset Formula 
\[
f_{2}\triangleq f^{:A\Rightarrow C}\times g^{:B\Rightarrow C}\Rightarrow f^{:A\Rightarrow C}\times g^{:B\Rightarrow C}\Rightarrow\begin{array}{|c||c|}
 & C\\
\hline A & f\\
B & g
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
 To compute the composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

, we write (omitting types)
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(h\Rightarrow(a\Rightarrow h(a+\bbnum 0))\times(b\Rightarrow h(\bbnum 0+b))\right)\bef\bigg(f\times g\Rightarrow\begin{array}{||c|}
f\\
g
\end{array}\,\bigg)\\
\text{compute composition}:\quad & =h\Rightarrow\begin{array}{||c|}
a\Rightarrow h(a+\bbnum 0)\\
b\Rightarrow h(\bbnum 0+b)
\end{array}\quad.
\end{align*}

\end_inset

To proceed, we need to simplify the expressions 
\begin_inset Formula $h(a+\bbnum 0)$
\end_inset

 and 
\begin_inset Formula $h(\bbnum 0+b)$
\end_inset

.
 We rewrite the argument 
\begin_inset Formula $h$
\end_inset

 (an arbitrary function of type 
\begin_inset Formula $A+B\Rightarrow C$
\end_inset

) in the matrix notation:
\begin_inset Formula 
\[
h\triangleq\begin{array}{|c||c|}
 & C\\
\hline A & a\Rightarrow p(a)\\
B & b\Rightarrow q(b)
\end{array}=\begin{array}{|c||c|}
 & C\\
\hline A & p\\
B & q
\end{array}\quad,
\]

\end_inset

where 
\begin_inset Formula $p^{:A\Rightarrow C}$
\end_inset

 and 
\begin_inset Formula $q^{:B\Rightarrow C}$
\end_inset

 are new arbitrary functions.
 Since we already checked the types, we can omit all type annotations and
 express 
\begin_inset Formula $h$
\end_inset

 as
\begin_inset Formula 
\[
h\triangleq\begin{array}{||c|}
p\\
q
\end{array}\quad.
\]

\end_inset

To evaluate expressions such as 
\begin_inset Formula $h(a+\bbnum 0)$
\end_inset

 and 
\begin_inset Formula $h(\bbnum 0+b)$
\end_inset

, we need to use one of the rows of the column matrix 
\begin_inset Formula $h$
\end_inset

.
 The correct row will be selected 
\emph on
automatically
\emph default
 by the standard rules of matrix multiplication if we place a row vector
 to the left of the matrix, and if we use the convention of omitting any
 terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}=a\triangleright p\quad,\\
 & \begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}=b\triangleright q\quad.
\end{align*}

\end_inset

Here we used the symbol 
\begin_inset Formula $\triangleright$
\end_inset

 to separate an argument from a function when the argument is written to
 the 
\emph on
left
\emph default
 of the function.
 The symbol 
\begin_inset Formula $\triangleright$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset

) is defined by 
\begin_inset Formula $x\triangleright f\triangleq f(x)$
\end_inset

.
 In Scala, this operation is available as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 as of Scala 2.13.
\end_layout

\begin_layout Standard
We write values of disjunctive types, such as 
\begin_inset Formula $a+\bbnum 0$
\end_inset

, as if they were row vectors:
\begin_inset Formula 
\begin{equation}
h(a+\bbnum 0)=(a+\bbnum 0)\triangleright h=\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,h\quad.\label{eq:forward-notation-}
\end{equation}

\end_inset

With these notations, we can compute further:
\begin_inset Formula 
\begin{align*}
 & h(a+\bbnum 0)=\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}=a\triangleright p=p(a)\quad,\\
 & h(\bbnum 0+b)=\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}=b\triangleright q=q(b)\quad.
\end{align*}

\end_inset

Now we can complete the proof of 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =h\Rightarrow\begin{array}{||c|}
a\Rightarrow h(a+\bbnum 0)\\
b\Rightarrow h(\bbnum 0+b)
\end{array}\\
\text{previous equations}:\quad & =\begin{array}{||c|}
p\\
q
\end{array}\Rightarrow\begin{array}{||c|}
a\Rightarrow p(a)\\
b\Rightarrow q(b)
\end{array}\\
\text{simplify functions}:\quad & =\bigg(\begin{array}{||c|}
p\\
q
\end{array}\Rightarrow\begin{array}{||c|}
p\\
q
\end{array}\,\bigg)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To prove that 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

, use the notation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:forward-notation-"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
f_{2}\bef f_{1} & =\bigg(f\times g\Rightarrow\begin{array}{||c|}
f\\
g
\end{array}\,\bigg)\bef\left(h\Rightarrow(a\Rightarrow h(a+\bbnum 0))\times(b\Rightarrow h(\bbnum 0+b))\right)\\
\text{compute composition}:\quad & =f\times g\Rightarrow\big(a\Rightarrow\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
f\\
g
\end{array}\,\big)\times\big(b\Rightarrow\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,\begin{array}{||c|}
f\\
g
\end{array}\,\big)\\
\text{matrix notation}:\quad & =f\times g\Rightarrow(a\Rightarrow\gunderline{a\triangleright f})\times(b\Rightarrow\gunderline{b\triangleright g})\\
\text{definition of }\triangleright:\quad & =f\times g\Rightarrow\gunderline{\left(a\Rightarrow f(a)\right)}\times\gunderline{\left(b\Rightarrow g(b)\right)}\\
\text{simplify functions}:\quad & =\left(f\times g\Rightarrow f\times g\right)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In this way, we have proved that 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are mutual inverses.
 The proofs appear long because we took time to motivate and introduce new
 notation for applying matrices to row vectors.
 Given this notation, the proof for 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 can be written as
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(h\Rightarrow(a\Rightarrow(a+\bbnum 0)\triangleright h)\times(b\Rightarrow(\bbnum 0+b)\triangleright h)\right)\bef\bigg(f\times g\Rightarrow\begin{array}{||c|}
f\\
g
\end{array}\bigg)\\
\text{compute composition}:\quad & =h\Rightarrow\begin{array}{||c|}
\,a\,\Rightarrow\,\left|\begin{array}{cc}
a & \bbnum 0\end{array}\right|\triangleright h\\
b\Rightarrow\left|\begin{array}{cc}
\bbnum 0 & b\end{array}\right|\triangleright h
\end{array}=\begin{array}{||c|}
p\\
q
\end{array}\Rightarrow\begin{array}{||c|}
a\Rightarrow\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\\
b\,\Rightarrow\begin{array}{|cc|}
\bbnum 0 & b\,\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}
\end{array}\\
\text{matrix notation}:\quad & =\begin{array}{||c|}
p\\
q
\end{array}\Rightarrow\begin{array}{||c|}
a\Rightarrow a\triangleright p\\
b\Rightarrow b\triangleright q
\end{array}=\big(\begin{array}{||c|}
p\\
q
\end{array}\Rightarrow\begin{array}{||c|}
p\\
q
\end{array}\,\big)=\text{id}\quad.
\end{align*}

\end_inset

The code notation makes proofs shorter than they would be if we were manipulatin
g code in Scala syntax.
 From now on, we will prefer to use the code notation in the proofs, keeping
 in mind that Scala code can be unambiguously recovered from the code notation,
 and vice versa.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula 
\[
A\times B\Rightarrow C\cong A\Rightarrow B\Rightarrow C\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the two functions
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (((A, B)) => C) => A => B => C = ???
\end_layout

\begin_layout Plain Layout

def f2[A,B,C]: (A => B => C) => ((A, B)) => C = ???
\end_layout

\end_inset

The Scala code can be derived from the type signatures without ambiguity:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (((A, B)) => C) => A => B => C = g => a => b => g((a, b))
\end_layout

\begin_layout Plain Layout

def f2[A,B,C]: (A => B => C) => ((A, B)) => C = h => { case (a, b) => h(a)(b)
 }
\end_layout

\end_inset

Write these functions in the code notation:
\begin_inset Formula 
\begin{align*}
 & f_{1}=g^{:A\times B\Rightarrow C}\Rightarrow a^{:A}\Rightarrow b^{:B}\Rightarrow g(a\times b)\quad,\\
 & f_{2}=h^{:A\Rightarrow B\Rightarrow C}\Rightarrow\left(a\times b\right)^{:A\times B}\Rightarrow h(a)(b)\quad.
\end{align*}

\end_inset

We denote by 
\begin_inset Formula $\left(a\times b\right)^{:A\times B}$
\end_inset

 the argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 with pattern matching implied.
 This notation allows us to write shorter code notation involving tupled
 arguments.
\end_layout

\begin_layout Standard
Compute the function composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =(g\Rightarrow\gunderline{a\Rightarrow b\Rightarrow g(a\times b)})\bef\left(h\Rightarrow a\times b\Rightarrow h(a)(b)\right)\\
\text{substitute }h=a\Rightarrow b\Rightarrow g(a\times b):\quad & =g\Rightarrow\gunderline{a\times b\Rightarrow g(a\times b)}\\
\text{simplify function}:\quad & =\left(g\Rightarrow g\right)=\text{id}\quad.
\end{align*}

\end_inset

Compute the function composition 
\begin_inset Formula $f_{2}\bef f_{1}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{2}\bef f_{1} & =(h\Rightarrow\gunderline{a\times b\Rightarrow h(a)(b)})\bef\left(g\Rightarrow a\Rightarrow b\Rightarrow g(a\times b)\right)\\
\text{substitute }g=a\times b\Rightarrow h(a)(b):\quad & =h\Rightarrow a\Rightarrow\gunderline{b\Rightarrow h(a)(b)}\\
\text{simplify function }b\Rightarrow h(a)(b):\quad & =h\Rightarrow\gunderline{a\Rightarrow h(a)}\\
\text{simplify function }a\Rightarrow h(a)\text{ to }h:\quad & =\left(h\Rightarrow h\right)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence
\begin_inset Formula 
\[
\left(A\Rightarrow B\times C\right)\cong\left(A\Rightarrow B\right)\times\left(A\Rightarrow C\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What tasks can we perform now?
\end_layout

\begin_layout Itemize
Use the matrix notation and the pipe notation to write code that works on
 disjunctive types.
\end_layout

\begin_layout Itemize
Use the type notation (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for reasoning about types to:
\end_layout

\begin_deeper
\begin_layout Itemize
Decide type equivalence using the rules in Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Itemize
Simplify type expressions before writing code.
\end_layout

\end_deeper
\begin_layout Itemize
Convert a fully parametric type signature into a logical formula to:
\end_layout

\begin_deeper
\begin_layout Itemize
Decide whether the type signature can be implemented in code.
\end_layout

\begin_layout Itemize
If possible, derive the code using the CH correspondence.
\end_layout

\end_deeper
\begin_layout Standard
What tasks cannot be performed with these tools?
\end_layout

\begin_layout Itemize
Automatically generate code for a recursive function.
 (The CH correspondence is based on propositional logic, which cannot describe
 recursion.)
\end_layout

\begin_layout Itemize
Automatically generate code satisfying a property (e.g.
\begin_inset space \space{}
\end_inset

isomorphism).
 We may generate the code, but it is not guaranteed that properties will
 hold.
 The workaround is to verify the required properties manually, after deriving
 the code.
\end_layout

\begin_layout Itemize
Express complicated conditions (e.g.
\begin_inset space \space{}
\end_inset


\begin_inset Quotes eld
\end_inset

array is sorted
\begin_inset Quotes erd
\end_inset

) in a type signature.
 This can be done using 
\series bold
dependent types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent type
\end_layout

\end_inset

 (i.e.
\begin_inset space ~
\end_inset

types that depend on run-time values in an arbitrary way)  an advanced
 technique that Scala does not fully support.
 Programming languages such as Coq, Agda, and Idris support full dependent
 types, but cannot automatically generate code from dependent type signatures.
\end_layout

\begin_layout Itemize
Generate code using type constructors with known properties (e.g.
\begin_inset space \space{}
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
As an example of using type constructors with properties, consider this
 type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A]: Array[A] => (A => Option[B]) => Array[Option[B]]
\end_layout

\end_inset

Can we generate the code of this function from its type signature? We know
 that the Scala library defines a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 type constructor, so the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 is simple,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A]: Array[A] => (A => Option[B]) => Array[Option[B]] = { arr => f
 => arr.map(f) }
\end_layout

\end_inset

However, it is hard to create an 
\emph on
algorithm
\emph default
 that can derive this implementation automatically from the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 via the Curry-Howard correspondence.
 The algorithm would have to convert the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 into the logical formula 
\begin_inset Formula 
\begin{equation}
{\cal CH}(\text{Array}^{A})\Rightarrow{\cal CH}(A\Rightarrow\text{Opt}^{B})\Rightarrow{\cal CH}(\text{Array}^{\text{Opt}^{B}})\quad.\label{eq:ch-example-quantified-proposition}
\end{equation}

\end_inset

To derive an implementation, the algorithm would need to use the available
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

 method for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

.
 That method has a type signature such as
\begin_inset Formula 
\[
\text{map}:\forall(A,B).\,\text{Array}^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{Array}^{B}\quad.
\]

\end_inset

To derive the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the algorithm will need to assume that the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition 
\begin_inset Formula 
\begin{equation}
{\cal CH}\left(\forall(A,B).\,\text{Array}^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{Array}^{B}\right)\label{eq:ch-example-quantified-proposition-2}
\end{equation}

\end_inset

already holds, i.e.
\begin_inset space ~
\end_inset

that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is one of the premises of a sequent to be proved.
 Reasoning about propositions such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) requires 
\begin_inset Index idx
status open

\begin_layout Plain Layout
first-order logic
\end_layout

\end_inset


\series bold
first-order logic
\series default
  a logic whose proof rules can handle quantified types such as 
\begin_inset Formula $\forall(A,B)$
\end_inset


\emph on
 inside
\emph default
 premises.
 However, first-order logic is 
\series bold
undecidable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
undecidable logic
\end_layout

\end_inset

: no algorithm can guarantee finding a proof or showing the absence of a
 proof in all cases.
 
\end_layout

\begin_layout Standard
The constructive propositional logic (with the rules listed in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\series bold
decidable
\series default
 and has an algorithm that either finds a proof or disproves any given formula.
 However, that logic cannot handle premises containing type quantifiers
 such as 
\begin_inset Formula $\forall(A,B)$
\end_inset

 inside, because all the available rules have the quantifiers implicitly
 placed 
\emph on
outside
\emph default
 the premises.
 
\end_layout

\begin_layout Standard
So, code for functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 can only be derived by trial and error, informed by intuition.
 This book will help functional programmers to acquire the necessary intuition
 and technique.
\end_layout

\begin_layout Subsection
Solved examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the cardinality of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Option[Option[Boolean] => Boolean]
\end_layout

\end_inset

.
 Write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 in the type notation and simplify to an equivalent type.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin with the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

, which can be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

 with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Boolean
\end_layout

\end_inset

.
 Since the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 has 
\begin_inset Formula $2$
\end_inset

 possible values, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

 has 
\begin_inset Formula $3$
\end_inset

 values:
\begin_inset Formula 
\[
\left|\text{Opt}^{\text{Bool}}\right|=\left|\bbnum 1+\text{Bool}\right|=1+\left|\text{Bool}\right|=3\quad.
\]

\end_inset

In the type notation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 is denoted by the symbol 
\begin_inset Formula $\bbnum 2$
\end_inset

, and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

 by 
\begin_inset Formula $\bbnum 1+\bbnum 2$
\end_inset

.
 So, the type notation 
\begin_inset Formula $\bbnum 1+\bbnum 2$
\end_inset

 is consistent with the cardinality 
\begin_inset Formula $3$
\end_inset

 of that type,
\begin_inset Formula 
\[
\left|\bbnum 1+\text{Bool}\right|=\left|\bbnum 1+\bbnum 2\right|=1+2=3\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean] => Boolean
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\bbnum 1+\bbnum 2\Rightarrow\bbnum 2$
\end_inset

.
 Its cardinality is computed as the arithmetic power 
\begin_inset Formula 
\[
\left|\text{Opt}^{\text{Bool}}\Rightarrow\text{Bool}\right|=\left|\bbnum 1+\bbnum 2\Rightarrow\bbnum 2\right|=\left|\bbnum 2\right|^{\left|\bbnum 1+\bbnum 2\right|}=2^{3}=8\quad.
\]

\end_inset

Finally, the we write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 in the type notation as 
\begin_inset Formula 
\[
P=\bbnum 1+\left(\bbnum 1+\bbnum 2\Rightarrow\bbnum 2\right)
\]

\end_inset

and find 
\begin_inset Formula 
\[
\left|P\right|=\left|\bbnum 1+\left(\bbnum 1+\bbnum 2\Rightarrow\bbnum 2\right)\right|=1+\left|\bbnum 1+\bbnum 2\Rightarrow\bbnum 2\right|=1+8=9\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A]
\end_layout

\end_inset

 for the type notation 
\begin_inset Formula 
\[
P^{A}\triangleq1+A+\text{Int}\times A+(\text{String}\Rightarrow A)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To translate type notation into Scala code, begin by defining the disjunctive
 types as case classes (with names chosen for convenience).
 In this case, 
\begin_inset Formula $P^{A}$
\end_inset

 is a disjunctive type with four parts, so we will need four case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P4[A](???) extends P[A]
\end_layout

\end_inset

Each of the case classes represents one part of the disjunctive type.
 Now we write the contents for each of the case classes, in order to implement
 the data in each of the disjunctive parts:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A]()               extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](x: A)           extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](n: Int, x: A)   extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P4[A](f: String => A) extends P[A]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-2a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find an equivalent disjunctive type for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = (Either[A, B], Either[C, D])
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the given type in the type notation.
 The tuple becomes the product type, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 becomes the disjunctive or 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 type:
\begin_inset Formula 
\[
P\triangleq(A+B)\times(C+D)\quad.
\]

\end_inset

We can use the usual rules of arithmetic to expand brackets in this type
 expression and to obtain an equivalent type:
\begin_inset Formula 
\[
P\cong A\times C+A\times D+B\times C+B\times D\quad.
\]

\end_inset

This type is disjunctive, with 
\begin_inset Formula $4$
\end_inset

 parts.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following type equivalences do 
\emph on
not
\emph default
 hold: 
\begin_inset Formula $A+A\not\cong A$
\end_inset

 and 
\begin_inset Formula $A\times A\not\cong A$
\end_inset

, although the corresponding logical identities hold.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Note that the arithmetic equalities do not hold, 
\begin_inset Formula $A+A\neq A$
\end_inset

 and 
\begin_inset Formula $A\times A\ne A$
\end_inset

.
 This already indicates that the types are not equivalent.
 To build further intuition, consider that a value of type 
\begin_inset Formula $A+A$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

) is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 In the code notation, it is either 
\begin_inset Formula $a^{:A}+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+a^{:A}$
\end_inset

.
 So, a value of type 
\begin_inset Formula $A+A$
\end_inset

 contains a value of type 
\begin_inset Formula $A$
\end_inset

 with an additional information about whether it is the first or the second
 part of the disjunctive type.
 We cannot represent all that information in a single value of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
A value of type 
\begin_inset Formula $A\times A$
\end_inset

 contains two (possibly different) values of type 
\begin_inset Formula $A$
\end_inset

, which cannot be represented by a single value of type 
\begin_inset Formula $A$
\end_inset

 without loss of information.
\end_layout

\begin_layout Standard
However, the corresponding logical identities 
\begin_inset Formula $\alpha\vee\alpha=\alpha$
\end_inset

 and 
\begin_inset Formula $\alpha\wedge\alpha=\alpha$
\end_inset

 hold.
 To see that, we could derive the four formulas
\begin_inset Formula 
\begin{align*}
\alpha\vee\alpha\Rightarrow\alpha\quad, & \quad\quad\alpha\Rightarrow\alpha\vee\alpha\quad,\\
\alpha\wedge\alpha\Rightarrow\alpha\quad, & \quad\quad\alpha\Rightarrow\alpha\wedge\alpha\quad,
\end{align*}

\end_inset

using the proof rules of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Alternatively, we may use the CH correspondence and show that the type
 signatures
\begin_inset Formula 
\begin{align*}
\forall A.\,A+A\Rightarrow A\quad, & \quad\quad\forall A.\,A\Rightarrow A+A\quad,\\
\forall A.\,A\times A\Rightarrow A\quad, & \quad\quad\forall A.\,A\Rightarrow A\times A\quad
\end{align*}

\end_inset

can be implemented via fully parametric functions.
 For a programmer, it is easier to write code than to guess the correct
 sequence of proof rules.
 For the first pair of type signatures, we find
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Either[A, A] => A = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => a   // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right(a)   => a   // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A]: A => Either[A, A] = { a => Left(a) } // Can be also Right(a).
\end_layout

\end_inset

The presence of an arbitrary choice, to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

, is a warning sign showing that additional information is required to create
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

.
 This is precisely the information present in the type 
\begin_inset Formula $A+A$
\end_inset

 but missing in the type 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
The code notation for these functions is
\begin_inset Formula 
\begin{align*}
 & f_{1}\triangleq\begin{array}{|c||c|}
 & A\\
\hline A & a\Rightarrow a\\
A & a\Rightarrow a
\end{array}=\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\quad,\\
 & f_{2}\triangleq a^{:A}\Rightarrow a+\bbnum 0^{:A}=\begin{array}{|c||cc|}
 & A & A\\
\hline A & a\Rightarrow a & \bbnum 0
\end{array}=\begin{array}{|c||cc|}
 & A & A\\
\hline A & \text{id} & \bbnum 0
\end{array}\quad.
\end{align*}

\end_inset

The composition of these functions is not equal to identity:
\begin_inset Formula 
\[
f_{1}\bef f_{2}=\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\end{array}=\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\text{id} & \bbnum 0
\end{array}\neq\text{id}=\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
For the second pair of type signatures, the code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: ((A, A)) => A = { case (a1, a2) => a1 }   // Can be also `a2`.
\end_layout

\begin_layout Plain Layout

cef f2[A]:   A => (A, A) = { x => (x, x) }           // No other choice
 here.
\end_layout

\end_inset

It is clear that the first function loses information when it returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and discards 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

 (or vice versa).
\end_layout

\begin_layout Standard
The code notation for these functions is
\begin_inset Formula 
\begin{align*}
 & f_{1}\triangleq a_{1}^{:A}\times a_{2}^{:A}\Rightarrow a_{1}\quad,\\
 & f_{2}\triangleq a^{:A}\Rightarrow a\times a\quad.
\end{align*}

\end_inset

The composition of these functions is not equal to identity:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(a_{1}\times a_{2}\Rightarrow a_{1}\right)\bef\left(a\Rightarrow a\times a\right)\\
 & =\left(a_{1}\times a_{2}\Rightarrow a_{1}\times a_{1}\right)\neq\text{id}=\left(a_{1}\times a_{2}\Rightarrow a_{1}\times a_{2}\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We have implemented all four type signatures as fully parametric functions,
 which shows that the corresponding logical formulas are all true (i.e.
\begin_inset space ~
\end_inset

can be derived using the proof rules).
 However, the functions cannot be inverses of each other.
 So, the type equivalences do not hold.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $\left(\left(A\wedge B\right)\Rightarrow C\right)\neq(A\Rightarrow C)\vee(B\Rightarrow C)$
\end_inset

 in the constructive logic, although the equality holds in Boolean logic.
 This is another example of the failure of Boolean logic to provide correct
 reasoning for types.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by rewriting the logical equality as two implications,
\begin_inset Formula 
\begin{align*}
 & (A\wedge B\Rightarrow C)\Rightarrow(A\Rightarrow C)\vee(B\Rightarrow C)\quad,\\
 & \left((A\Rightarrow C)\vee(B\Rightarrow C)\right)\Rightarrow\left(\left(A\wedge B\right)\Rightarrow C\right)\quad.
\end{align*}

\end_inset

It is sufficient to show that one of these implications is incorrect.
 Rather than looking for a proof tree in the constructive logic (which would
 be difficult, since we would need to demonstrate that 
\emph on
no
\emph default
 proof tree exists), let us use the CH correspondence.
 So the task is to implement fully parametric functions with the type signatures
\begin_inset Formula 
\begin{align*}
 & (A\times B\Rightarrow C)\Rightarrow(A\Rightarrow C)+(B\Rightarrow C)\quad,\\
 & (A\Rightarrow C)+(B\Rightarrow C)\Rightarrow A\times B\Rightarrow C\quad.
\end{align*}

\end_inset

For the first type signature, the Scala code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (((A, B)) => C) => Either[A => C, B => C] = { k => ??? }
\end_layout

\end_inset

We are required to return either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(g)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: A => C
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(h)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h: B => C
\end_layout

\end_inset

.
 The only given data is a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 of type 
\begin_inset Formula $A\times B\Rightarrow C$
\end_inset

, so the decision of whether to return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 must be hard-coded in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 independently of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

.
 Can we produce a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

? Given a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we would need to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 The only way to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 to some arguments.
 But to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

, we need a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, which we do not have.
 So we cannot produce a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: A => C
\end_layout

\end_inset

.
 Similarly, we cannot produce a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To repeat the same argument in the type notation: Obtaining a value of type
 
\begin_inset Formula $(A\Rightarrow C)+(B\Rightarrow C)$
\end_inset

 means to compute either 
\begin_inset Formula $g^{:A\Rightarrow C}+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+h^{:B\Rightarrow C}$
\end_inset

.
 This decision must be hard-coded since the only data is a function 
\begin_inset Formula $k^{:A\times B\Rightarrow C}$
\end_inset

.
 We can compute a 
\begin_inset Formula $g^{:A\Rightarrow C}$
\end_inset

 only by partially applying 
\begin_inset Formula $k^{:A\times B\Rightarrow C}$
\end_inset

 to a value of type 
\begin_inset Formula $B$
\end_inset

.
 However, we cannot obtain any values of type 
\begin_inset Formula $B$
\end_inset

.
 Similarly, we cannot get an 
\begin_inset Formula $h^{:B\Rightarrow C}$
\end_inset

.
\end_layout

\begin_layout Standard
The inverse type signature is implementable:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "55col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace 60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A,B,C]: Either[A=>C, B=>C] => ((A,B)) => C = {
\end_layout

\begin_layout Plain Layout

  case Left(g)    =>   { case (a, b)    => g(a) }
\end_layout

\begin_layout Plain Layout

  case Right(h)   =>   { case (a, b)    => h(b) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -240baselineskip%
\end_inset


\end_layout

\end_inset


\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\[
f_{2}\triangleq\begin{array}{|c||c|}
 & A\times B\Rightarrow C\\
\hline A\Rightarrow C & g^{:A\Rightarrow C}\Rightarrow a\times b\Rightarrow g(a)\\
B\Rightarrow C & h^{:B\Rightarrow C}\Rightarrow a\times b\Rightarrow h(b)
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
Let us now show that the identity 
\begin_inset Formula 
\begin{equation}
((\alpha\wedge\beta)\Rightarrow\gamma)=((\alpha\Rightarrow\gamma)\vee(\beta\Rightarrow\gamma))\label{eq:ch-example-identity-boolean-not-constructive}
\end{equation}

\end_inset

holds in Boolean logic.
 A straightforward calculation is to simplify the Boolean expression using
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which only holds in Boolean logic (but not in the constructive logic).
 We find
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:ch-example-identity-boolean-not-constructive})}:\quad & \left(\alpha\wedge\beta\right)\gunderline{\Rightarrow}\,\gamma\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\gunderline{\neg(\alpha\wedge\beta)}\vee\gamma\\
\text{use de Morgan's law}:\quad & =\neg\alpha\vee\neg\beta\vee\gamma\quad.\\
\text{right-hand side of Eq.~(\ref{eq:ch-example-identity-boolean-not-constructive})}:\quad & (\gunderline{\alpha\Rightarrow\gamma})\vee(\gunderline{\beta\Rightarrow\gamma})\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\neg\alpha\vee\gunderline{\gamma}\vee\neg\beta\vee\gunderline{\gamma}\\
\text{use identity }\gamma\vee\gamma=\gamma:\quad & =\neg\alpha\vee\neg\beta\vee\gamma\quad.
\end{align*}

\end_inset

Both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are equal to the same formula, 
\begin_inset Formula $\neg\alpha\vee\neg\beta\vee\gamma$
\end_inset

, so the identity holds.
\end_layout

\begin_layout Standard
This proof does not work in the constructive logic because neither the Boolean
 formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) nor the law of de Morgan,
\begin_inset Formula 
\[
\neg(\alpha\wedge\beta)=\left(\neg\alpha\vee\neg\beta\right)\quad,
\]

\end_inset

can be derived via the proof rules of the constructive logic.
\end_layout

\begin_layout Standard
Another way of proving the Boolean identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is to enumerate all possible truth values for the variables 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

.
 The left-hand side, 
\begin_inset Formula $\left(\alpha\wedge\beta\right)\Rightarrow\gamma$
\end_inset

, can be 
\begin_inset Formula $False$
\end_inset

 only if 
\begin_inset Formula $\alpha\wedge\beta=True$
\end_inset

 (that is, both 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are 
\begin_inset Formula $True$
\end_inset

) and 
\begin_inset Formula $\gamma=False$
\end_inset

; for all other truth values of 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

, the formula 
\begin_inset Formula $\left(\alpha\wedge\beta\right)\Rightarrow\gamma$
\end_inset

 is 
\begin_inset Formula $True$
\end_inset

.
 Let us determine when the right-hand side, 
\begin_inset Formula $(\alpha\Rightarrow\gamma)\vee(\beta\Rightarrow\gamma)$
\end_inset

, can be 
\begin_inset Formula $False$
\end_inset

.
 This can happen only if both parts of the disjunction are 
\begin_inset Formula $False$
\end_inset

; that means 
\begin_inset Formula $\alpha=True$
\end_inset

, 
\begin_inset Formula $\beta=True$
\end_inset

, and 
\begin_inset Formula $\gamma=False$
\end_inset

.
 So, the two sides of the identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are both 
\begin_inset Formula $True$
\end_inset

 or both 
\begin_inset Formula $False$
\end_inset

 with any choice of truth values of 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

.
 In Boolean logic, this is sufficient to prove the identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
It is important to note that the proof rules of the constructive logic are
 not equivalent to checking whether some propositions are 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 A general form of this statement was proved by K.
\begin_inset space ~
\end_inset

G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\begin_inset Quotes erd
\end_inset

o
\end_layout

\end_inset

del in 1932.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "plato.stanford.edu/entries/intuitionistic-logic-development/"
target "https://plato.stanford.edu/entries/intuitionistic-logic-development/#SomeEarlResu"
literal "false"

\end_inset


\end_layout

\end_inset

 In this sense, constructive logic does not imply that every proposition
 is either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This is not intuitive and requires getting used to.
\end_layout

\begin_layout Standard
The following example shows how to use the identities from Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to derive type equivalence for complicated type expressions, without need
 for proofs.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known rules to verify the type equivalences:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $A\times\left(A+\bbnum 1\right)\times\left(A+\bbnum 1+\bbnum 1\right)\cong A\times\left(\bbnum 1+\bbnum 1+A\times\left(\bbnum 1+\bbnum 1+\bbnum 1+A\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\left(\bbnum 1+A+B\right)\Rightarrow\bbnum 1\times B\cong\left(B\Rightarrow B\right)\times\left(A\Rightarrow B\right)\times B$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We can expand brackets in the type expression as in arithmetic,
\begin_inset Formula 
\begin{align*}
A\times\left(A+\bbnum 1\right) & \cong A\times A+A\times\bbnum 1\cong A\times A+A\quad,\\
A\times\left(A+\bbnum 1\right)\times\left(A+\bbnum 1+\bbnum 1\right) & \cong\left(A\times A+A\right)\times\left(A+\bbnum 1+\bbnum 1\right)\\
 & \cong A\times A\times A+A\times A+A\times A\times\left(\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\\
 & \cong A\times A\times A+A\times A\times\left(\bbnum 1+\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\quad.
\end{align*}

\end_inset

The result looks like a polynomial in 
\begin_inset Formula $A$
\end_inset

, which we can now rearrange into the required form:
\begin_inset Formula 
\[
A\times A\times A+A\times A\times\left(\bbnum 1+\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\cong A\times\left(\bbnum 1+\bbnum 1+A\times\left(\bbnum 1+\bbnum 1+\bbnum 1+A\right)\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Keep in mind that the conventions of the type notation make the function
 arrow 
\begin_inset Formula $\left(\Rightarrow\right)$
\end_inset

 group weaker than other type operations.
 So, the type expression 
\begin_inset Formula $\left(\bbnum 1+A+B\right)\Rightarrow\bbnum 1\times B$
\end_inset

 means a function from 
\begin_inset Formula $\bbnum 1+A+B$
\end_inset

 to 
\begin_inset Formula $\bbnum 1\times B$
\end_inset

.
 
\end_layout

\begin_layout Standard
Begin by using the rule 
\begin_inset Formula $\bbnum 1\times B\cong B$
\end_inset

 to obtain 
\begin_inset Formula $\left(\bbnum 1+A+B\right)\Rightarrow B$
\end_inset

.
 Now we use the rule 
\begin_inset Formula 
\[
A+B\Rightarrow C\cong\left(A\Rightarrow C\right)\times\left(B\Rightarrow C\right)
\]

\end_inset

and derive the equivalence
\begin_inset Formula 
\[
\left(\bbnum 1+A+B\right)\Rightarrow B\cong\left(\bbnum 1\Rightarrow B\right)\times\left(A\Rightarrow B\right)\times\left(B\Rightarrow B\right)\quad.
\]

\end_inset

Finally, we note that 
\begin_inset Formula $\bbnum 1\Rightarrow B\cong B$
\end_inset

 and that the type product is commutative, so we can rearrange the last
 type expression into the required form:
\begin_inset Formula 
\[
B\times\left(A\Rightarrow B\right)\times\left(B\Rightarrow B\right)\cong\left(B\Rightarrow B\right)\times\left(A\Rightarrow B\right)\times B\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Read}^{E,T}\triangleq E\Rightarrow T$
\end_inset

 and implement fully parametric functions with types 
\begin_inset Formula $A\Rightarrow\text{Read}^{E,A}$
\end_inset

 and 
\begin_inset Formula $\text{Read}^{E,A}\Rightarrow(A\Rightarrow B)\Rightarrow\text{Read}^{E,B}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by defining a type alias for the type 
\begin_inset Formula $\text{Read}^{E,T}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Read[E, T] = E => T
\end_layout

\end_inset

The first type signature has only one implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[E, A]: A => Read[E, A] = { x => _ => x }
\end_layout

\end_inset

We 
\emph on
must
\emph default
 discard the argument of type 
\begin_inset Formula $E$
\end_inset

; we cannot use it for computing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The second type signature has three type parameters.
 It is the curried version of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: Read[E, A] => (A => B) => Read[E, B] = ???
\end_layout

\end_inset

Expanding the type alias, we see that the two curried arguments are functions
 of types 
\begin_inset Formula $E\Rightarrow A$
\end_inset

 and 
\begin_inset Formula $A\Rightarrow B$
\end_inset

.
 The forward composition of these functions is a function of type 
\begin_inset Formula $E\Rightarrow B$
\end_inset

, or 
\begin_inset Formula $\text{Read}^{E,B}$
\end_inset

, which is exactly what we are required to return.
 So the code can be written as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: (E => A) => (A => B) => E => B = { r => f => r andThen
 f }
\end_layout

\end_inset

If we did not notice this shortcut, we would reason differently: We are
 required to compute a value of type 
\begin_inset Formula $B$
\end_inset

 given 
\emph on
three
\emph default
 curried arguments 
\begin_inset Formula $r^{:E\Rightarrow A}$
\end_inset

, 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, and 
\begin_inset Formula $e^{:E}$
\end_inset

.
 Write this requirement as
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\Rightarrow A}\Rightarrow f^{:A\Rightarrow B}\Rightarrow e^{:E}\Rightarrow???^{:B}\quad,
\]

\end_inset

The symbol 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

 is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
typed hole
\end_layout

\end_inset


\series bold
typed hole
\series default
; it stands for a value that we are still figuring out how to compute, but
 whose type is already known.
 Typed holes are supported in Scala by an experimental compiler plugin.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/cb372/scala-typed-holes"
target "https://github.com/cb372/scala-typed-holes"
literal "false"

\end_inset


\end_layout

\end_inset

 The plugin will print the known information about the typed hole.
\end_layout

\begin_layout Standard
To fill the typed hole 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

, we need a value of type 
\begin_inset Formula $B$
\end_inset

.
 Since no arguments have type 
\begin_inset Formula $B$
\end_inset

, the only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

 to some value of type 
\begin_inset Formula $A$
\end_inset

.
 So we write
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\Rightarrow A}\Rightarrow f^{:A\Rightarrow B}\Rightarrow e^{:E}\Rightarrow f(???^{:A})\quad.
\]

\end_inset

The only way of getting an 
\begin_inset Formula $A$
\end_inset

 is to apply 
\begin_inset Formula $r$
\end_inset

 to a value of type 
\begin_inset Formula $E$
\end_inset

,
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\Rightarrow A}\Rightarrow f^{:A\Rightarrow B}\Rightarrow e^{:E}\Rightarrow f(r(???^{:E}))\quad.
\]

\end_inset

We have exactly one value of type 
\begin_inset Formula $E$
\end_inset

, namely 
\begin_inset Formula $e^{:E}$
\end_inset

.
 So the code must be 
\begin_inset Formula 
\[
\text{map}^{E,A,B}\triangleq r^{:E\Rightarrow A}\Rightarrow f^{:A\Rightarrow B}\Rightarrow e^{:E}\Rightarrow f(r(e))\quad.
\]

\end_inset

Translate this to the Scala syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: (E => A) => (A => B) => E => B = { r => f => e => f(r(e))
 }
\end_layout

\end_inset

We may now notice that the expression 
\begin_inset Formula $e\Rightarrow f(r(e))$
\end_inset

 is a function composition 
\begin_inset Formula $r\bef f$
\end_inset

 applied to 
\begin_inset Formula $e$
\end_inset

, and simplify the code accordingly.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Read[A, T] => (A => B) => Read[B, T]
\end_layout

\end_inset

 cannot be implemented as a fully parametric function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Expand the type signature and try to implement this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def m[A, B, T] : (A => T) => (A => B) => B => T = { r => f => b => ??? }
\end_layout

\end_inset

Given values 
\begin_inset Formula $r^{:A\Rightarrow T}$
\end_inset

, 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, and 
\begin_inset Formula $b^{:B}$
\end_inset

, we need to compute a value of type 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\[
m=r^{:A\Rightarrow T}\Rightarrow f^{:A\Rightarrow B}\Rightarrow b^{:B}\Rightarrow???^{:T}\quad.
\]

\end_inset

The only way of getting a 
\begin_inset Formula $T$
\end_inset

 is to apply 
\begin_inset Formula $r$
\end_inset

 to some value of type 
\begin_inset Formula $A$
\end_inset

,
\begin_inset Formula 
\[
m=r^{:A\Rightarrow T}\Rightarrow f^{:A\Rightarrow B}\Rightarrow b^{:B}\Rightarrow r(???^{:A})\quad.
\]

\end_inset

However, we do not have any values of type 
\begin_inset Formula $A$
\end_inset

.
 We have a function 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

 that 
\emph on
consumes
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

, and we cannot use 
\begin_inset Formula $f$
\end_inset

 to produce any values of type 
\begin_inset Formula $A$
\end_inset

.
 So we seem to be unable to fill the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

 and implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In order to verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 is unimplementable, we need to prove that the logical formula
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta,\tau).\,(\alpha\Rightarrow\tau)\Rightarrow(\alpha\Rightarrow\beta)\Rightarrow(\beta\Rightarrow\tau)\label{eq:ch-example-boolean-formula-3}
\end{equation}

\end_inset

is not true in the constructive logic.
 We could use the 
\family typewriter
curryhoward
\family default
 library for that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def m[A, B, T] : (A => T) => (A => B) => B => T = implement
\end_layout

\begin_layout Plain Layout

cmd1.sc:1: type (A => T) => (A => B) => B => T cannot be implemented
\end_layout

\begin_layout Plain Layout

def m[A, B, T] : (A => T) => (A => B) => B => T = implement
\end_layout

\begin_layout Plain Layout

                                                ^
\end_layout

\begin_layout Plain Layout

Compilation Failed
\end_layout

\end_inset

Another way is to check whether this formula is true in Boolean logic.
 A formula that holds in constructive logic will always hold in Boolean
 logic, because all rules shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 preserve Boolean truth values (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relationship-between-Boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details).
 It follows that any formula that fails to hold in Boolean logic will also
 not hold in constructive logic.
 
\end_layout

\begin_layout Standard
It is relatively easy to check whether a given Boolean formula is always
 equal to 
\begin_inset Formula $True$
\end_inset

.
 Simplifying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-formula-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with the rules of Boolean logic, we find
\begin_inset Formula 
\begin{align*}
 & (\alpha\Rightarrow\tau)\,\gunderline{\Rightarrow}\,(\alpha\Rightarrow\beta)\,\gunderline{\Rightarrow}\,(\beta\Rightarrow\tau)\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\neg(\gunderline{\alpha\Rightarrow\tau})\vee\neg(\gunderline{\alpha\Rightarrow\beta})\vee(\gunderline{\beta\Rightarrow\tau})\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\gunderline{\neg(\neg\alpha\vee\tau)}\vee\gunderline{\neg(\neg\alpha\vee\beta)}\vee(\neg\beta\vee\tau)\\
\text{use de Morgan's law}:\quad & =\left(\alpha\wedge\neg\tau\right)\vee\gunderline{\left(\alpha\wedge\neg\beta\right)\vee\neg\beta}\vee\tau\\
\text{use identity }(p\wedge q)\vee q=q:\quad & =\gunderline{\left(\alpha\wedge\neg\tau\right)}\vee\neg\beta\vee\gunderline{\tau}\\
\text{use identity }(p\wedge\neg q)\vee q=p\vee q:\quad & =\alpha\vee\neg\beta\vee\tau\quad.
\end{align*}

\end_inset

This formula is not identically 
\begin_inset Formula $True$
\end_inset

: it is 
\begin_inset Formula $False$
\end_inset

 when 
\begin_inset Formula $\alpha=\tau=False$
\end_inset

 and 
\begin_inset Formula $\beta=True$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-formula-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is not true in Boolean logic, and thus is not true in constructive logic.
 By the CH correspondence, we conclude that the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 cannot be implemented by a fully parametric function.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define the type constructor 
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A+A$
\end_inset

 and implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for it,
\begin_inset Formula 
\[
\text{map}^{A,B}:P^{A}\Rightarrow(A\Rightarrow B)\Rightarrow P^{B}\quad.
\]

\end_inset

To check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 preserves information, verify the law 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(p)(x => x) == p
\end_layout

\end_inset

 for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: P[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
It is implied that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 should be fully parametric and information-preserving.
 Begin by defining a Scala type for the notation 
\begin_inset Formula $\bbnum 1+A+A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A]()     extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](x: A) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](x: A) extends P[A]
\end_layout

\end_inset

Now implement the required type signature.
 Each time we find a choice in the implementation, we will choose to preserve
 information as much as possible.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: P[A] => (A => B) => P[B] = p => f => p match {
\end_layout

\begin_layout Plain Layout

  case P1() => P1()         // No other choice here.
\end_layout

\begin_layout Plain Layout

  case P2(x) => ???
\end_layout

\begin_layout Plain Layout

  case P3(x) => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(x)
\end_layout

\end_inset

, we are required to produce a value of type 
\begin_inset Formula $P^{B}$
\end_inset

 from a value 
\begin_inset Formula $x^{:A}$
\end_inset

 and a function 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

.
 Since 
\begin_inset Formula $P^{B}$
\end_inset

 is a disjunctive type with three parts, we can produce a value of type
 
\begin_inset Formula $P^{B}$
\end_inset

 in three different ways: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P1()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(...)
\end_layout

\end_inset

.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P1()
\end_layout

\end_inset

, we will lose the information about the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(...)
\end_layout

\end_inset

, we will preserve the information about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 but lose the information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 that the input value was a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2
\end_layout

\end_inset

 rather than a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3
\end_layout

\end_inset

.
 So we should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

 in that scope; in that way, we preserve the entire input information.
 
\end_layout

\begin_layout Standard
The value under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

 must be of type 
\begin_inset Formula $B$
\end_inset

, and the only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f$
\end_inset

 to 
\begin_inset Formula $x$
\end_inset

.
 So, we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(f(x))
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Similarly, in the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(x)
\end_layout

\end_inset

, we should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(f(x))
\end_layout

\end_inset

.
 The final code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: P[A] => (A => B) => P[B] = p => f => p match {
\end_layout

\begin_layout Plain Layout

  case P1() => P1()         // No other choice here.
\end_layout

\begin_layout Plain Layout

  case P2(x) => P2(f(x))    // Preserve information.
\end_layout

\begin_layout Plain Layout

  case P3(x) => P3(f(x))    // Preserve information.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify the given law, we first write a matrix notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{map}^{A,B}\triangleq p^{:\bbnum 1+A+A}\Rightarrow f^{:A\Rightarrow B}\Rightarrow p\triangleright\begin{array}{|c||ccc|}
 & \bbnum 1 & B & B\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & f & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & f
\end{array}\quad.
\]

\end_inset

The required law is written as an equation
\begin_inset Formula 
\[
\text{map}(p)(\text{id})=p\quad.
\]

\end_inset

Substituting the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we verify the law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p:\quad & \text{map}(p)(\text{id})\\
\text{apply map()() to arguments}:\quad & =p\triangleright\begin{array}{||ccc|}
\text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 0 & \text{id} & \bbnum 0\\
\bbnum 0 & \bbnum 0 & \text{id}
\end{array}\\
\text{identity in matrix notation}:\quad & =p\triangleright\text{id}\\
\triangleright\text{-notation}:\quad & =\text{id}(p)=p\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[L, R]
\end_layout

\end_inset

, applied to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For a type constructor, say, 
\begin_inset Formula $P^{A}$
\end_inset

, the standard type signatures for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 are
\begin_inset Formula 
\begin{align*}
\text{map} & :P^{A}\Rightarrow(A\Rightarrow B)\Rightarrow P^{B}\quad,\\
\text{flatMap} & :P^{A}\Rightarrow(A\Rightarrow P^{B})\Rightarrow P^{B}\quad.
\end{align*}

\end_inset

If a type constructor has more than one type parameter, e.g.
\begin_inset space ~
\end_inset


\begin_inset Formula $P^{A,S,T}$
\end_inset

, one can define the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 applied to a chosen parameter.
 For example, when applied to the type parameter 
\begin_inset Formula $A$
\end_inset

, the type signatures are 
\begin_inset Formula 
\begin{align*}
\text{map} & :P^{A,S,T}\Rightarrow(A\Rightarrow B)\Rightarrow P^{B,S,T}\quad,\\
\text{flatMap} & :P^{A,S,T}\Rightarrow(A\Rightarrow P^{B,S,T})\Rightarrow P^{B,S,T}\quad.
\end{align*}

\end_inset

Being 
\begin_inset Quotes eld
\end_inset

applied to the type parameter 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 means that the other type parameters 
\begin_inset Formula $S,T$
\end_inset

 in 
\begin_inset Formula $P^{A,S,T}$
\end_inset

 remain fixed while the type parameter 
\begin_inset Formula $A$
\end_inset

 is replaced by 
\begin_inset Formula $B$
\end_inset

 in the type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[L, R]
\end_layout

\end_inset

 (i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula $L+R$
\end_inset

), we keep the type parameter 
\begin_inset Formula $R$
\end_inset

 fixed while 
\begin_inset Formula $L$
\end_inset

 is replaced by 
\begin_inset Formula $M$
\end_inset

.
 So we obtain the type signatures
\begin_inset Formula 
\begin{align*}
\text{map} & :L+R\Rightarrow(L\Rightarrow M)\Rightarrow M+R\quad,\\
\text{flatMap} & :L+R\Rightarrow(L\Rightarrow M+R)\Rightarrow M+R\quad.
\end{align*}

\end_inset

Implementing these functions is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[L,M,R]: Either[L, R] => (L => M) => Either[M, R] = e => f => e match
 {
\end_layout

\begin_layout Plain Layout

  case Left(x)    => Left(f(x))
\end_layout

\begin_layout Plain Layout

  case Right(y)   => Right(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def flatMap[L,M,R]: Either[L, R] => (L => Either[M, R]) => Either[M, R]
 = e => f => e match {
\end_layout

\begin_layout Plain Layout

  case Left(x)    => f(x)
\end_layout

\begin_layout Plain Layout

  case Right(y)   => Right(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code notation for these functions is
\begin_inset Formula 
\begin{align*}
\text{map} & \triangleq e^{:L+R}\Rightarrow f^{:L\Rightarrow M}\Rightarrow e\triangleright\begin{array}{|c||cc|}
 & M & R\\
\hline L & f & \bbnum 0\\
R & \bbnum 0 & \text{id}
\end{array}\quad,\\
\text{flatMap} & \triangleq e^{:L+R}\Rightarrow f^{:L\Rightarrow M+R}\Rightarrow e\triangleright\begin{array}{|c||c|}
 & M+R\\
\hline L & f\\
R & y^{:R}\Rightarrow\bbnum 0^{:M}+y
\end{array}\quad.
\end{align*}

\end_inset

Note that we cannot split 
\begin_inset Formula $f$
\end_inset

 into the 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 columns since 
\begin_inset Formula $f(x^{:L})$
\end_inset

 could return either part of the disjunction 
\begin_inset Formula $M+R$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-9"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Define a type 
\begin_inset Formula $\text{State}^{S,A}\equiv S\Rightarrow A\times S$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{pure}^{S,A}:A\Rightarrow\text{State}^{S,A}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{map}^{S,A,B}:\text{State}^{S,A}\Rightarrow(A\Rightarrow B)\Rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\text{flatMap}^{S,A,B}:\text{State}^{S,A}\Rightarrow(A\Rightarrow\text{State}^{S,B})\Rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
It is assumed that all functions must be fully parametric and preserve as
 much information as possible.
 We define the type alias
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type State[S, A] = S => (A, S)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The type signature is 
\begin_inset Formula $A\Rightarrow S\Rightarrow A\times S$
\end_inset

, and there is only one implementation,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[S, A]: A => State[S, A] = a => s => (a, s)
\end_layout

\end_inset

In the code notation, this is written as
\begin_inset Formula 
\[
\text{pu}^{S,A}\triangleq a^{:A}\Rightarrow s^{:A}\Rightarrow a\times s\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The explicit type signature is 
\begin_inset Formula 
\[
\text{map}^{S,A,B}:(S\Rightarrow A\times S)\Rightarrow(A\Rightarrow B)\Rightarrow S\Rightarrow B\times S\quad.
\]

\end_inset

Begin writing a Scala implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[S, A, B]: State[S, A] => (A => B) => State[S, B] = { t => f => s
 => ??? }
\end_layout

\end_inset

We need to compute a value of 
\begin_inset Formula $B\times S$
\end_inset

 from the curried arguments 
\begin_inset Formula $t^{:S\Rightarrow A\times S}$
\end_inset

, 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, and 
\begin_inset Formula $s^{:S}$
\end_inset

.
 We begin writing the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as a typed hole,
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow B}\Rightarrow s^{:S}\Rightarrow\text{???}^{:B}\times\text{???}^{:S}\quad.
\]

\end_inset

The only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is by applying 
\begin_inset Formula $f$
\end_inset

 to a value of type 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow B}\Rightarrow s^{:S}\Rightarrow f(\text{???}^{:A})\times\text{???}^{:S}\quad.
\]

\end_inset

To fill the typed hole, we need a value of type 
\begin_inset Formula $A$
\end_inset

.
 The only possibility of obtaining a value of type 
\begin_inset Formula $A$
\end_inset

 is by applying 
\begin_inset Formula $t$
\end_inset

 to a value of type 
\begin_inset Formula $S$
\end_inset

; we already have such a value, 
\begin_inset Formula $s^{:S}$
\end_inset

.
 Computing 
\begin_inset Formula $t(s)$
\end_inset

 yields a pair of type 
\begin_inset Formula $A\times S$
\end_inset

, from which we may take the first part (of type 
\begin_inset Formula $A$
\end_inset

) to fill the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

.
 The second part of the pair is a value of type 
\begin_inset Formula $S$
\end_inset

 that we may use to fill the second typed hole, 
\begin_inset Formula $\text{???}^{:S}$
\end_inset

.
 So the Scala code is
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "62col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
lstparams "numbers=left,numberstyle={\small}"
inline false
status open

\begin_layout Plain Layout

def map[S, A, B]: State[S, A] => (A => B) => State[S, B] = {
\end_layout

\begin_layout Plain Layout

  t => f => s =>
\end_layout

\begin_layout Plain Layout

    val (a, s2) = t(s)
\end_layout

\begin_layout Plain Layout

    (f(a), s2)     // We could also return `(f(a), s)` here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -125baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Why not return the original value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 in the tuple 
\begin_inset Formula $B\times S$
\end_inset

, instead of the new value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

? The reason is that we would like to preserve information as much as possible.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f(a), s)
\end_layout

\end_inset

 in line 4, we will have discarded the computed value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

, which is a loss of information.
\end_layout

\begin_layout Standard
To write the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we need to destructure the pair that 
\begin_inset Formula $t(s)$
\end_inset

 returns.
 We can write explicit destructuring code like this:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow B}\Rightarrow s^{:S}\Rightarrow(a^{:A}\times s_{2}^{:S}\Rightarrow f(a)\times s_{2})(t(s))\quad.
\]

\end_inset

If we temporarily denote by 
\begin_inset Formula $q$
\end_inset

 the destructuring function 
\begin_inset Formula 
\[
q\triangleq(a^{:A}\times s_{2}^{:S}\Rightarrow f(a)\times s_{2})\quad,
\]

\end_inset

we will notice that the expression 
\begin_inset Formula $s\Rightarrow q(t(s))$
\end_inset

 is a function composition applied to 
\begin_inset Formula $s$
\end_inset

.
 So, we rewrite 
\begin_inset Formula $s\Rightarrow q(t(s))$
\end_inset

 as the composition 
\begin_inset Formula $t\bef q$
\end_inset

 and obtain shorter code, 
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow B}\Rightarrow t\bef(a^{:A}\times s^{:S}\Rightarrow f(a)\times s)\quad.
\]

\end_inset

Shorter formulas are often easier to reason about in derivations (although
 not necessarily easier to read when converted to program code).
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The required type signature is
\begin_inset Formula 
\[
\text{flatMap}^{S,A,B}:(S\Rightarrow A\times S)\Rightarrow(A\Rightarrow S\Rightarrow B\times S)\Rightarrow S\Rightarrow B\times S\quad.
\]

\end_inset

We perform t reasoning with typed holes:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow S\Rightarrow B\times S}\Rightarrow s^{:S}\Rightarrow\text{???}^{:B}\times???^{:S}\quad.
\]

\end_inset

To fill 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

, we need to apply 
\begin_inset Formula $f$
\end_inset

 to some arguments, since 
\begin_inset Formula $f$
\end_inset

 is the only function that returns any values of type 
\begin_inset Formula $B$
\end_inset

.
 A saturated application of 
\begin_inset Formula $f$
\end_inset

 will yield a value of type 
\begin_inset Formula $B\times S$
\end_inset

, which we can return without change:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow S\Rightarrow B\times S}\Rightarrow s^{:S}\Rightarrow f(\text{???}^{:A})(\text{???}^{:S})\quad.
\]

\end_inset

To fill the new typed holes, we need to apply 
\begin_inset Formula $t$
\end_inset

 to an argument of type 
\begin_inset Formula $S$
\end_inset

.
 We have only one given value 
\begin_inset Formula $s^{:S}$
\end_inset

 of type 
\begin_inset Formula $S$
\end_inset

, so we must compute 
\begin_inset Formula $t(s)$
\end_inset

 and destructure it:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow S\Rightarrow B\times S}\Rightarrow s^{:S}\Rightarrow\left(a\times s_{2}\Rightarrow f(a)(s_{2})\right)(t(s))\quad.
\]

\end_inset

Translating this notation into Scala code, we obtain
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[S,A,B]: State[S, A] => (A => State[S, B]) => State[S, B] = {
\end_layout

\begin_layout Plain Layout

  t => f => s =>
\end_layout

\begin_layout Plain Layout

    val (a, s2) = t(s)
\end_layout

\begin_layout Plain Layout

    f(a)(s2)            // We could also return `f(a)(s)` here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

As before, in order to preserve information, we choose not to discard the
 computed value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 can be simplified to
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\Rightarrow A\times S}\Rightarrow f^{:A\Rightarrow S\Rightarrow B\times S}\Rightarrow t\bef\left(a\times s\Rightarrow f(a)(s)\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-0"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-0"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the cardinality of the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean => Option[Boolean]]
\end_layout

\end_inset

.
 Show that this type is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean] => Boolean
\end_layout

\end_inset

, and argue that the equivalence is accidental
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!accidental
\end_layout

\end_inset

 and not 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-1-a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-1-a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalences 
\begin_inset Formula $A+A\cong\bbnum 2\times A$
\end_inset

 and 
\begin_inset Formula $A\times A\cong\bbnum 2\Rightarrow A$
\end_inset

, where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $A\Rightarrow(B\vee C)\neq(A\Rightarrow B)\wedge(A\Rightarrow C)$
\end_inset

 in logic.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-type-identity-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-type-identity-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known rules to verify the type equivalences:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\left(A+B\right)\times\left(A\Rightarrow B\right)\cong A\times\left(A\Rightarrow B\right)+\left(\bbnum 1+A\Rightarrow B\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\left(A\times(\bbnum 1+A)\Rightarrow B\right)\cong\left(A\Rightarrow B\right)\times\left(A\Rightarrow A\Rightarrow B\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $A\Rightarrow\left(\bbnum 1+B\right)\Rightarrow C\times D\cong\left(A\Rightarrow C\right)\times\left(A\Rightarrow D\right)\times\left(A\Rightarrow B\Rightarrow C\right)\times\left(A\Rightarrow B\Rightarrow D\right)\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, Int), Either[(A, Char), (A, Float)]]
\end_layout

\end_inset

.
 Transform this type into an equivalent type of the form 
\begin_inset Formula $A\times(...)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a type 
\begin_inset Formula $\text{OptE}^{T,A}\triangleq\bbnum 1+T+A$
\end_inset

 and implement information-preserving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for it, applied to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 Get the same result using the equivalent type 
\begin_inset Formula $(\bbnum 1+A)+T$
\end_inset

, i.e.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Option[A], T]
\end_layout

\end_inset

.
 The required type signatures are
\begin_inset Formula 
\begin{align*}
\text{map}^{A,B,T} & :\text{OptE}^{T,A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{OptE}^{T,B}\quad,\\
\text{flatMap}^{A,B,T} & :\text{OptE}^{T,A}\Rightarrow(A\Rightarrow\text{OptE}^{T,B})\Rightarrow\text{OptE}^{T,B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A]
\end_layout

\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The required type signature is 
\begin_inset Formula $P^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow P^{B}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the type constructor 
\begin_inset Formula $Q^{T,A}$
\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function with the type signature
\begin_inset Formula 
\[
\text{map}^{T,A,B}:Q^{T,A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow Q^{T,B}\quad.
\]

\end_inset

The implementation should preserve information as much as possible.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a recursive type constructor 
\begin_inset Formula $\text{Tr}_{3}$
\end_inset

 as 
\begin_inset Formula $\text{Tr}_{3}{}^{A}\triangleq\bbnum 1+A\times A\times A\times\text{Tr}_{3}{}^{A}$
\end_inset

 and implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for it, with the standard type signature
\begin_inset Formula 
\[
\text{map}^{A,B}:\text{Tr}_{3}{}^{A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{Tr}_{3}{}^{B}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement fully parametric functions with the following types:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $A+Z\Rightarrow(A\Rightarrow B)\Rightarrow B+Z\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $A+Z\Rightarrow B+Z\Rightarrow(A\Rightarrow B\Rightarrow C)\Rightarrow C+Z\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\text{flatMap}^{E,A,B}:\text{Read}^{E,A}\Rightarrow(A\Rightarrow\text{Read}^{E,B})\Rightarrow\text{Read}^{E,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $\text{State}^{S,A}\Rightarrow\left(S\times A\Rightarrow S\times B\right)\Rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Cont}^{R,T}\triangleq\left(T\Rightarrow R\right)\Rightarrow R$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{map}^{R,T,U}:\text{Cont}^{R,T}\Rightarrow(T\Rightarrow U)\Rightarrow\text{Cont}^{R,U}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{flatMap}^{R,T,U}:\text{Cont}^{R,T}\Rightarrow(T\Rightarrow\text{Cont}^{R,U})\Rightarrow\text{Cont}^{R,U}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-8"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Select}^{Z,T}\triangleq\left(T\Rightarrow Z\right)\Rightarrow T$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{map}^{Z,A,B}:\text{Select}^{Z,A}\Rightarrow\left(A\Rightarrow B\right)\Rightarrow\text{Select}^{Z,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{flatMap}^{Z,A,B}:\text{Select}^{Z,A}\Rightarrow(A\Rightarrow\text{Select}^{Z,B})\Rightarrow\text{Select}^{Z,B}\quad.$
\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Using the Curry-Howard correspondence for writing code
\end_layout

\begin_layout Standard
This chapter shows how the CH correspondence performs two practically important
 tasks of type-level reasoning: checking whether a type signature can be
 implemented as a fully parametric function, and determining whether two
 types are equivalent.
 The first task is accomplished by mapping type expressions into formulas
 in the constructive logic and by applying the proof rules of that logic.
 The second task is accomplished by mapping type expressions into 
\emph on
arithmetic
\emph default
 formulas and applying the ordinary rules of arithmetic.
\end_layout

\begin_layout Standard
Fully parametric functions can be often derived from their type signatures
 alone.
 It is useful for a programmer to know that certain type signatures, such
 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (A => B) => B
\end_layout

\end_inset

have only one possible implementation, while other type signatures, such
 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g[A, B]: A => (B => A) => B
\end_layout

\begin_layout Plain Layout

def h[A, B]: ((A => B) => A) => A
\end_layout

\end_inset

cannot be implemented as fully parametric functions.
\end_layout

\begin_layout Standard
Although tools such as the 
\family typewriter
curryhoward
\family default
 library could perform the code derivation, in most cases it is more beneficial
 if a programmer is able to derive an implementation by hand, or to see
 quickly that an implementation is impossible.
 Exercises in this chapter build up the required technique.
 The type notation introduced in this book is designed to help programmers
 to recognize patterns in type expressions and to reason about them more
 easily.
\end_layout

\begin_layout Standard
Throughout this chapter, we required all functions to be fully parametric.
 The reason is that the CH correspondence becomes informative only with
 parameterized types and with fully parametric functions.
 For concrete types, e.g.
\begin_inset space \space{}
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, one can always produce 
\emph on
some
\emph default
 value even with no previous data, so the proposition 
\begin_inset Formula $\mathcal{CH}(\text{Int})$
\end_inset

 is always true within any code.
\end_layout

\begin_layout Standard
Consider the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:Int) => x + 1
\end_layout

\end_inset

.
 Its type signature, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, is insufficient to specify the code of the function, because there are
 many different functions with the same type signature, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x - 1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x * 2
\end_layout

\end_inset

, etc.
 So, deriving code from the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 is not a meaningful task.
 Only a fully parametric type signature, such as 
\begin_inset Formula $A\Rightarrow\left(A\Rightarrow B\right)\Rightarrow B$
\end_inset

, gives enough information for possibly deriving the function's code.
 If we permit functions that are not fully parametric, we will not be able
 to reason about implementability of type signatures or about code derivation.
\end_layout

\begin_layout Standard
Information about the implementability of type signatures is given by logical
 formulas involving 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 The validity of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions means that we can compute 
\emph on
some
\emph default
 values of given types, but it does not give any information about the propertie
s of those values, such as whether they satisfy any additional laws.
 This is why type equivalence is not determined by an equivalence of logical
 formulas.
\end_layout

\begin_layout Standard
It is useful for programmers to be able to reason about types and transform
 type expressions to equivalent simpler types before starting to write code.
 We have shown that a type equivalence corresponds to 
\emph on
each
\emph default
 standard arithmetic identity such as 
\begin_inset Formula $\left(a+b\right)+c=a+\left(b+c\right)$
\end_inset

, 
\begin_inset Formula $\left(a\times b\right)\times c=a\times(b\times c)$
\end_inset

, 
\begin_inset Formula $1\times a=a$
\end_inset

, 
\begin_inset Formula $\left(a+b\right)\times c=a\times c+b\times c$
\end_inset

, etc.
 So, we are allowed to transform and simplify types as if they were arithmetic
 expressions, e.g.
\begin_inset space ~
\end_inset

to rewrite
\begin_inset Formula 
\[
\left(A+B\right)\times C+D\cong D+A\times C+B\times C\quad.
\]

\end_inset

The type notation makes this reasoning more intuitive (for people familiar
 with arithmetic).
 
\end_layout

\begin_layout Standard
These results apply to all type expressions built up using product types,
 disjunctive types (also called 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 types because they correspond to arithmetic sums), and function types (also
 called 
\begin_inset Quotes eld
\end_inset

exponential
\begin_inset Quotes erd
\end_inset

 types because they correspond to arithmetic exponentials).
 Type expressions that contain only products and sum types may be called
 
\series bold
polynomial
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!polynomial
\end_layout

\end_inset

.
 Type expressions that also contain function types may be called 
\series bold
exponential-polynomial
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!exponential-polynomial
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
Polynomial types are often called 
\begin_inset Quotes eld
\end_inset

algebraic
\begin_inset Quotes erd
\end_inset

, but we will use more specific terms 
\begin_inset Quotes eld
\end_inset

polynomial
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

exponential-polynomial
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 The set of exponential-polynomial types covers almost all data types and
 design patterns used in functional programming, and so this book focuses
 on these types.
\end_layout

\begin_layout Standard
There are no type constructions corresponding to subtraction or division,
 so equations such as 
\begin_inset Formula 
\begin{align*}
\left(1-t\right)\times\left(1+t\right) & =1-t\times t\quad\text{or }\quad\frac{t+t\times t}{t}=1+t
\end{align*}

\end_inset

do not directly yield any type equivalences.
 However, consider this well-known formula,
\begin_inset Formula 
\[
\frac{1}{1-t}=1+t+t^{2}+t^{3}+...+t^{n}+...\quad.
\]

\end_inset

At first sight, this formula appears to involve subtraction, division, and
 an infinite series, and thus cannot be directly translated into a type
 equivalence.
 However, the formula can be rewritten as
\begin_inset Formula 
\begin{equation}
\frac{1}{1-t}\triangleq L(t)=1+t+t^{2}+t^{3}+...+t^{n}\times L(t)\quad,\label{eq:ch-example-type-formula-list}
\end{equation}

\end_inset

which is finite and only contains additions and multiplications.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-type-formula-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be translated into a type equivalence:
\begin_inset Formula 
\begin{equation}
L^{A}\cong1+A+A\times A+A\times A\times A+...+\underbrace{A\times...\times A}_{n}\times L^{A}\quad.\label{eq:ch-example-type-expansion-list}
\end{equation}

\end_inset

This type formula (with 
\begin_inset Formula $n=1$
\end_inset

) is equivalent to a recursive definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type,
\begin_inset Formula 
\[
\text{List}^{A}\triangleq1+A\times\text{List}^{A}\quad.
\]

\end_inset

The type equivalence
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-type-expansion-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) suggests that we may view the recursive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 as an 
\begin_inset Quotes eld
\end_inset

infinite disjunction
\begin_inset Quotes erd
\end_inset

 describing lists of zero, one, etc.
\begin_inset space ~
\end_inset

elements.
\end_layout

\begin_layout Subsection
Implications for designing new programming languages
\end_layout

\begin_layout Standard
The functional programming paradigm assumes that programmers will use the
 six standard type constructions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-notation-and-standard-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the eight standard code constructions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 These constructions are foundational in the sense that they are used to
 express all design patterns of functional programming.
 A language that does not directly support some of these constructions cannot
 be considered a functional programming language.
\end_layout

\begin_layout Standard
A remarkable consequence of the CH correspondence is that the type system
 of any programming language (functional or not) is mapped into a 
\emph on
certain
\emph default
 
\emph on
logic
\emph default
, i.e.
\begin_inset space ~
\end_inset

a system of logical operations and proof rules.
 A logical operation will correspond to each of the type constructions available
 in the programming language; a proof rule will correspond to each of the
 available code constructions.
 Functional programming languages that support all the standard type and
 code constructions  for instance, OCaml, Haskell, F#, Scala, Swift, etc.,
  will be mapped into the constructive logic with all standard logical
 operations available (
\begin_inset Formula $True$
\end_inset

, 
\begin_inset Formula $False$
\end_inset

, disjunction, conjunction, and implication).
 Languages such as C, C++, Java, C# are mapped into logics that do not have
 the disjunction operation or the constants 
\begin_inset Formula $True$
\end_inset

 and 
\begin_inset Formula $False$
\end_inset

.
 In other words, these languages are mapped into 
\emph on
incomplete
\emph default
 logics where some theorems will not be provable.
 (If 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is true but not provable, a value of type 
\begin_inset Formula $A$
\end_inset

 is not directly computable by programs, although it could have been.) Languages
 such as Python, JavaScript, Ruby, Clojure have no type checking and so
 are mapped to 
\emph on
inconsistent
\emph default
 logics where any proposition can be derived  even propositions normally
 considered 
\begin_inset Formula $False$
\end_inset

.
 
\end_layout

\begin_layout Standard
Incompleteness of the logic of types will make a programming language unable
 to express certain computations, e.g.
\begin_inset space ~
\end_inset

directly handle data that belongs to a disjoint domain.
 Inconsistency of a logic means that the logic may derive 
\begin_inset Formula $False$
\end_inset

 from 
\begin_inset Formula $True$
\end_inset

.
 The CH correspondence will map such derivations to code that appears to
 compute a certain value although that value is not actually available.
 In practice, such code 
\emph on
crashes
\emph default
 (although all types match!) because the computed value has a wrong type,
 is 
\begin_inset Quotes eld
\end_inset

null
\begin_inset Quotes erd
\end_inset

, or is a pointer to an invalid memory location.
\end_layout

\begin_layout Standard
None of these errors will happen in a programming language whose logic of
 types is complete and consistent, provided that types are checked at compile
 time.
 
\end_layout

\begin_layout Standard
So, the CH correspondence gives a mathematically justified procedure for
 designing type systems in new programming languages.
 The procedure has the following steps:
\end_layout

\begin_layout Itemize
Choose a complete formal logic that is free of inconsistencies.
\end_layout

\begin_layout Itemize
For each logical operation, provide a type construction in the language.
\end_layout

\begin_layout Itemize
For each proof rule, provide a code construction in the language.
\end_layout

\begin_layout Standard
Mathematicians have studied different logics (e.g.
\begin_inset space ~
\end_inset

modal logic, temporal logic, or linear logic).
 Compared with the constructive logic, these other logics have some additional
 operations.
 (For instance, modal logic adds the operations 
\begin_inset Quotes eld
\end_inset

necessarily
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

possibly
\begin_inset Quotes erd
\end_inset

, and temporal logic adds the operation 
\begin_inset Quotes eld
\end_inset

until
\begin_inset Quotes erd
\end_inset

.) For each logic, mathematicians have determined the minimal complete sets
 of operations, axioms, and proof rules that do not lead to inconsistency.
 Programming language designers can choose a logic and translate it into
 a minimal programming language where the code is guaranteed 
\emph on
not to crash
\emph default
 as long as types match.
 This mathematical guarantee (known as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type safety
\end_layout

\end_inset


\series bold
type safety
\series default
) is a powerful help for programmers since it automatically prevents a large
 set of programming errors.
 So, programmers will benefit if their programming language is designed
 using the CH correspondence.
\end_layout

\begin_layout Standard
Practically useful programming languages will, of course, introduce many
 more features than the minimal, mathematically necessary constructions
 derived from the chosen logic.
 Programmers will still benefit from type safety as long as the program
 stays within the mathematically consistent subset of the language.
 For Scala, a 
\begin_inset Quotes eld
\end_inset

safe
\begin_inset Quotes erd
\end_inset

 subset is identified by the 
\family typewriter
scalazzi
\family default
 project.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/scalaz/scalazzi"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At the present time, it is not fully understood whether it would be better
 for a programming language to be based not on constructive logic but on,
 say, linear logic, temporal logic, or some other logic that adds more operation
s to the constructive logic.
 Practical experience suggests that at least the operations of the constructive
 logic should be available.
 So, it appears that the six type constructions and the eight code constructions
 will remain available in all future languages of functional programming.
 
\end_layout

\begin_layout Subsection
Uses of the void type
\end_layout

\begin_layout Standard
Scala's 
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

void type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

) corresponds to the logical constant 
\begin_inset Formula $False$
\end_inset

.
 The practical uses of 
\begin_inset Formula $False$
\end_inset

 are quite limited.
 One use case is for a branch of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression that does not return a value because it throws an 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset

exception.
 Such branches are considered formally to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, which can then be mapped to a value of any other type (through the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd[A]: Nothing => A
\end_layout

\end_inset

, see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
To see how this trick is used, consider this code defining a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: Double = if (t >= 0.0) math.sqrt(t) else { throw new Exception(
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 branch does not return a value, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is declared to be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 For this code to type-check, both branches must return values of the same
 type.
 So, the compiler needs to pretend that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 branch also returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 The compiler first assigns the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 to the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw ...
\end_layout

\end_inset

 and then implicitly uses the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd: Nothing => Double
\end_layout

\end_inset

 to convert that type to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 In this way, types will match in the definition of the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We will not use exceptions in this book.
 The functional programming paradigm avoids exceptions because their presence
 significantly complicates reasoning about code.
\end_layout

\begin_layout Standard
So far, none of our examples involved the logical 
\series bold
negation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
negation
\end_layout

\end_inset

 operation.
 It is defined as 
\begin_inset Formula 
\[
\neg A\triangleq A\Rightarrow False\quad,
\]

\end_inset

and its practical use is as limited as that of 
\begin_inset Formula $False$
\end_inset

 and the void type.
 However, logical negation plays an important role in Boolean logic, which
 we will discuss next.
\end_layout

\begin_layout Subsection
Relationship between Boolean logic and constructive logic
\begin_inset CommandInset label
LatexCommand label
name "subsec:Relationship-between-Boolean"

\end_inset

 
\end_layout

\begin_layout Standard
We have seen that some true theorems of Boolean logic are not true in constructi
ve logic.
 For example, the Boolean identities 
\begin_inset Formula $\neg\left(\neg\alpha\right)=\alpha$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=(\neg\alpha\vee\beta)$
\end_inset

 do not hold in the constructive logic.
 However, any theorem of constructive logic is also a theorem of Boolean
 logic.
 The reason is that all eight rules of constructive logic (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are also true in Boolean logic.
\end_layout

\begin_layout Standard
To verify that a formula is true in Boolean logic, we only need to check
 that the value of the formula is 
\begin_inset Formula $True$
\end_inset

 for all possible truth values (
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

) of its variables.
 A sequent such as 
\begin_inset Formula $\alpha,\beta\vdash\gamma$
\end_inset

 is true in Boolean logic if and only if 
\begin_inset Formula $\gamma=True$
\end_inset

 under the assumption that 
\begin_inset Formula $\alpha=\beta=True$
\end_inset

.
 So, the sequent 
\begin_inset Formula $\alpha,\beta\vdash\gamma$
\end_inset

 is translated into the Boolean formula 
\begin_inset Formula 
\[
\alpha,\beta\vdash\gamma=\left(\left(\alpha\wedge\beta\right)\Rightarrow\gamma\right)=\left(\neg\alpha\vee\neg\beta\vee\gamma\right)\quad.
\]

\end_inset

Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 translates all proof rules of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 into Boolean formulas.
 The first two lines are axioms, while the subsequent lines are Boolean
 theorems that can be verified by calculation.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Constructive logic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Boolean logic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{create unit})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\neg\Gamma\vee True=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use arg})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\neg\Gamma\vee\neg\alpha\vee\alpha=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\neg\alpha\vee\beta\right)=\left(\neg\Gamma\vee\left(\alpha\Rightarrow\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\left(\neg\Gamma\vee\alpha\right)\wedge\left(\neg\Gamma\vee\left(\alpha\Rightarrow\beta\right)\right)\right)\Rightarrow\left(\neg\Gamma\vee\beta\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\alpha\right)\wedge\left(\neg\Gamma\vee\beta\right)=\left(\neg\Gamma\vee\left(\alpha\wedge\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\left(\alpha\wedge\beta\right)\right)\Rightarrow\left(\neg\Gamma\vee\alpha\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Left})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\alpha\right)\Rightarrow\left(\neg\Gamma\vee\left(\alpha\vee\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use Either})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\left(\neg\Gamma\vee\alpha\vee\beta\right)\wedge\left(\neg\Gamma\vee\neg\alpha\vee\gamma\right)\wedge\left(\neg\Gamma\vee\neg\beta\vee\gamma\right)\right)\Rightarrow\left(\neg\Gamma\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof rules of constructive logic are true also in the Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Proof-rules-of-constructive-and-boolean"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To simplify the calculations, note that all terms in the formulas contain
 the operation 
\begin_inset Formula $\left(\neg\Gamma\vee...\right)$
\end_inset

 corresponding to the context 
\begin_inset Formula $\Gamma$
\end_inset

.
 Now, if 
\begin_inset Formula $\Gamma$
\end_inset

 is 
\begin_inset Formula $False$
\end_inset

, the entire formula becomes automatically 
\begin_inset Formula $True$
\end_inset

, and there is nothing else to check.
 So, it remains to verify the formula in case 
\begin_inset Formula $\Gamma=True$
\end_inset

, and then we can simply omit all instances of 
\begin_inset Formula $\neg\Gamma$
\end_inset

 in the formulas.
 Let us show the Boolean derivations for the rules 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use Either}$
\end_inset


\begin_inset Quotes erd
\end_inset

; other formulas are checked in a similar way.
 
\begin_inset Formula 
\begin{align*}
\text{formula ``use function''}:\quad & \left(\alpha\wedge\left(\alpha\Rightarrow\beta\right)\right)\Rightarrow\beta\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\gunderline{\neg}(\alpha\,\gunderline{\wedge}\,(\neg\alpha\,\gunderline{\vee}\,\beta))\vee\beta\\
\text{de Morgan's laws}:\quad & =\gunderline{\neg\alpha\vee(\alpha\wedge\neg\beta)}\vee\beta\\
\text{identity }p\vee(\neg p\wedge q)=p\vee q\text{ with }p=\neg\alpha\text{ and }q=\beta:\quad & =\neg\alpha\vee\gunderline{\neg\beta\vee\beta}\\
\text{axiom ``use arg''}:\quad & =True\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{formula ``use Either''}:\quad & \left(\left(\alpha\vee\beta\right)\wedge\left(\alpha\Rightarrow\gamma\right)\wedge\left(\beta\Rightarrow\gamma\right)\right)\Rightarrow\gamma\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\neg\left(\left(\alpha\vee\beta\right)\wedge\left(\neg\alpha\vee\gamma\right)\wedge\left(\neg\beta\vee\gamma\right)\right)\vee\gamma\\
\text{de Morgan's laws}:\quad & =\left(\neg\alpha\wedge\neg\beta\right)\vee\gunderline{\left(\alpha\wedge\neg\gamma\right)}\vee\gunderline{\left(\beta\wedge\neg\gamma\right)}\vee\gamma\\
\text{identity }p\vee(\neg p\wedge q)=p\vee q:\quad & =\gunderline{\left(\neg\alpha\wedge\neg\beta\right)\vee\alpha}\vee\beta\vee\gamma\\
\text{identity }p\vee(\neg p\wedge q)=p\vee q:\quad & =\gunderline{\neg\alpha\vee\alpha}\vee\beta\vee\gamma\\
\text{axiom ``use arg''}:\quad & =True\quad.
\end{align*}

\end_inset

Since each proof rule of the constructive logic is translated into a true
 formula in Boolean logic, it follows that a proof tree in the constructive
 logic will be translated into a tree of Boolean formulas that have value
 
\begin_inset Formula $True$
\end_inset

 for each axiom or proof rule.
 The result is that any constructive proof for a sequent such as 
\begin_inset Formula $\emptyset\vdash f(\alpha,\beta,\gamma)$
\end_inset

 is translated into a chain of Boolean implications that look like this,
\begin_inset Formula 
\[
True=(...)\Rightarrow(...)\Rightarrow...\Rightarrow f(\alpha,\beta,\gamma)\quad.
\]

\end_inset

Since 
\begin_inset Formula $\left(True\Rightarrow\alpha\right)=\alpha$
\end_inset

, this chain proves the Boolean formula 
\begin_inset Formula $f(\alpha,\beta,\gamma)$
\end_inset

.
\end_layout

\begin_layout Standard
For example, the proof tree shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is translated into
\begin_inset Formula 
\begin{align*}
\text{axiom ``use arg''}:\quad & True=\left(\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\neg\alpha\vee\alpha\right)\\
\text{rule ``create function''}:\quad & \quad\Rightarrow\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\alpha\right)\quad.\\
\text{axiom ``use arg''}:\quad & True=\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\quad.\\
\text{rule ``use function''}:\quad & True\Rightarrow\left(\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\beta\right)\\
\text{rule ``create function''}:\quad & \quad\Rightarrow\left(\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\Rightarrow\beta\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It is easier to check Boolean truth than to find a proof tree in constructive
 logic (or to establish that no proof tree exists).
 So, if we find that a formula is not true in Boolean logic, we know it
 is also not true in constructive logic.
 This gives us a quick way of proving that some type signatures are not
 implementable as fully parametric functions.
 In addition to formulas shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-not-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

), further examples of formulas that are not true in Boolean logic are
\begin_inset Formula 
\begin{align*}
 & \forall A.\,A\quad,\\
 & \forall(A,B).\,A\Rightarrow B\quad,\\
 & \forall(A,B).\,(A\Rightarrow B)\Rightarrow B\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 uses the Boolean identity 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=(\neg\alpha\vee\beta)$
\end_inset

, which does not hold in the constructive logic, to translate the constructive
 axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

 into the Boolean axiom 
\begin_inset Formula $\neg\alpha\vee\alpha=True$
\end_inset

.
 The formula 
\begin_inset Formula $\neg\alpha\vee\alpha=True$
\end_inset

 is known as the 
\series bold
law of excluded middle
\series default
,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Law_of_excluded_middle"
target "https://en.wikipedia.org/wiki/Law_of_excluded_middle"
literal "false"

\end_inset


\end_layout

\end_inset

 and is equivalent to saying that any proposition 
\begin_inset Formula $\alpha$
\end_inset

 is either true or false.
 It is remarkable that the constructive logic 
\emph on
does not have
\emph default
 the law of excluded middle; it is neither an axiom nor a derived theorem
 of constructive logic.
 
\end_layout

\begin_layout Standard
To see why, consider what it would mean for 
\begin_inset Formula $\neg\alpha\vee\alpha=True$
\end_inset

 to hold in the constructive logic.
 The negation operation, 
\begin_inset Formula $\neg\alpha$
\end_inset

, is defined as the implication 
\begin_inset Formula $\alpha\Rightarrow False$
\end_inset

.
 So, the logical formula 
\begin_inset Formula $\forall\alpha.\,\neg\alpha\vee\alpha$
\end_inset

 corresponds to the type 
\begin_inset Formula $\forall A.\,\left(A\Rightarrow\bbnum 0\right)+A$
\end_inset

.
 Can we compute a value of this type in a fully parametric function? We
 would need to compute either a value of type 
\begin_inset Formula $A\Rightarrow\bbnum 0$
\end_inset

 or a value of type 
\begin_inset Formula $A$
\end_inset

; this decision needs to be made in advance independently of 
\begin_inset Formula $A$
\end_inset

, because the code of a fully parametric function must operate in the same
 way for all types.
 Should we decide to return 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $A\Rightarrow\bbnum 0$
\end_inset

? We certainly cannot compute a value of type 
\begin_inset Formula $A$
\end_inset

 from scratch, since 
\begin_inset Formula $A$
\end_inset

 is a type parameter.
 As we have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset

, a value of type 
\begin_inset Formula $A\Rightarrow\bbnum 0$
\end_inset

 exists if the type 
\begin_inset Formula $A$
\end_inset

 is itself 
\begin_inset Formula $\bbnum 0$
\end_inset

; but we do not know that, and a fully parametric function needs to have
 the same code for all types 
\begin_inset Formula $A$
\end_inset

.
 Since there are no values of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, and the type parameter 
\begin_inset Formula $A$
\end_inset

 could be, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, we cannot compute a value of type 
\begin_inset Formula $A\Rightarrow\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Standard
Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed that the type 
\begin_inset Formula $A\Rightarrow\bbnum 0$
\end_inset

 is equivalent to 
\begin_inset Formula $\bbnum 0$
\end_inset

 if 
\begin_inset Formula $A$
\end_inset

 is not itself void (
\begin_inset Formula $A\not\cong\bbnum 0$
\end_inset

), and to 
\begin_inset Formula $\bbnum 1$
\end_inset

 otherwise.
 Surely, any type 
\begin_inset Formula $A$
\end_inset

 is either void or not void.
 So, why exactly is it impossible to implement a value of the type 
\begin_inset Formula $\left(A\Rightarrow\bbnum 0\right)+A$
\end_inset

? We could say that if 
\begin_inset Formula $A$
\end_inset

 is void then 
\begin_inset Formula $\left(A\Rightarrow\bbnum 0\right)\cong\bbnum 1$
\end_inset

 is not void, and so one of the types in the disjunction 
\begin_inset Formula $\left(A\Rightarrow\bbnum 0\right)\vee A$
\end_inset

 should be non-void (i.e.
\begin_inset space ~
\end_inset

have values).
\end_layout

\begin_layout Standard
However, this reasoning is incorrect.
 A fully parametric functions' code must work in the same general way for
 all types; the code cannot decide what to do depending on a specific type.
 So, it is insufficient to show that a value 
\begin_inset Quotes eld
\end_inset

should exist
\begin_inset Quotes erd
\end_inset

; the real requirement is to compute a value of type 
\begin_inset Formula $\left(A\Rightarrow\bbnum 0\right)+A$
\end_inset

 in fully parametric code that works the same way for all types 
\begin_inset Formula $A$
\end_inset

.
 But, as we have seen, this is impossible.
\end_layout

\begin_layout Standard
In Boolean logic, it is sufficient to prove that a value 
\begin_inset Quotes eld
\end_inset

should exist
\begin_inset Quotes erd
\end_inset

 (or that the non-existence of a value is contradictory in some way).
 However, any practically useful program needs to 
\begin_inset Quotes eld
\end_inset

construct
\begin_inset Quotes erd
\end_inset

 (i.e.
\begin_inset space ~
\end_inset

compute) actual values and return them.
 The 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Index idx
status open

\begin_layout Plain Layout
constructive logic
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 logic got its name from this requirement.
 So, it is the constructive logic (not the Boolean logic) that provides
 correct reasoning about the types of values computable by functional programs.
\end_layout

\end_body
\end_document
