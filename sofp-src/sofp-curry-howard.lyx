#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}	

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The logic of types.
 III.
 The Curry-Howard correspondence
\begin_inset CommandInset label
LatexCommand label
name "chap:5-Curry-Howard"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset

Fully parametric functions (introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Fully-parametric-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) perform operations so general that their code works in the same way for
 all types.
 An example of a fully parametric function is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { x => g(f(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Deriving-a-function-s-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that for certain functions of this kind one can derive the code unambiguously
 from the type signature.
 There exists a mathematical theory (called the 
\series bold
Curry-Howard correspondence
\series default
) that gives precise conditions for the possibility of deriving a function's
 code from its type.
 There is also a systematic derivation algorithm that either produces the
 function's code or proves that the given type signature cannot be implemented.
 This chapter describes the main results and applications of that theory
 to functional programming.
\end_layout

\begin_layout Section
Values computed by fully parametric functions
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
Consider the following sketch of a fully parametric function's Scala code:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B, ...]: ...
 = {
\end_layout

\begin_layout Plain Layout

  val x: Either[A, B] = ...
 // Some expression here.
\end_layout

\begin_layout Plain Layout

  ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
If this program compiles without type errors, it means that the types match
 and, in particular, that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is able to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is sometimes 
\emph on
impossible
\emph default
 to compute a value of a certain type within the body of a fully parametric
 function.
 For example, the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  val x: A = ???            // Cannot compute x here!
\end_layout

\begin_layout Plain Layout

  ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The reason is that a fully parametric function cannot compute values of
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 from scratch without using a previously given value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and without applying a function that returns values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 are given as arguments; the given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 returns values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 must perform pattern matching on a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  case None       => 
\end_layout

\begin_layout Plain Layout

    val x: A = ??? // Cannot compute x here!
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

  case Some(a)    =>
\end_layout

\begin_layout Plain Layout

    val x: A = a   // Can compute x in this scope.
\end_layout

\begin_layout Plain Layout

    ...
 }
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Since the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 has no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we are unable to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in that scope (as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 remains a fully parametric function).
 
\end_layout

\begin_layout Standard
Being able to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

within the body of a function
\begin_inset Quotes erd
\end_inset

 means that, if needed, the function should be able to 
\emph on
return
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a result value.
 This requires computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in all cases, not just within one part of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression.
 
\end_layout

\begin_layout Standard
The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 also cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Since no arguments of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are given, the only way of obtaining a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 would be to apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 to 
\emph on
some
\emph default
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 But we just saw that the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Another example where one cannot compute a value of a certain type is the
 following code:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -10baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = {
\end_layout

\begin_layout Plain Layout

  //  val h: C => A = ???   // Cannot compute h here!
\end_layout

\begin_layout Plain Layout

  a => g(f(a)) // Can compute a value of type A => C.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 may only use the arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

.
 We can compose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to get a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

.
 But it is impossible to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => A
\end_layout

\end_inset

, no matter what code we try to write.
 The reason is that the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 has no given values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and no functions that return values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, so a nameless function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{c:C => ???}
\end_layout

\end_inset

 cannot compute a return value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Since a fully parametric function cannot create values of an arbitrary
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 from scratch, computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 within the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 seems to be impossible.
\end_layout

\begin_layout Standard
Can we prove rigorously that a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => A
\end_layout

\end_inset

 cannot be computed within the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

? Or, perhaps, a clever trick could produce a value of that type? So far,
 we only saw informal arguments about whether values of certain types can
 be computed.
 To make the arguments rigorous, we need to translate statements such as
 
\begin_inset Quotes eld
\end_inset

a fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 can compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => A
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 into mathematical formulas with rules for proving them true or false.
\end_layout

\begin_layout Standard
The first step towards a rigorous mathematical formulation of a property
 is to choose a precise notation.
 In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctions-and-conjunctions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we denoted by 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 the proposition 
\begin_inset Quotes eld
\end_inset

the 
\begin_inset Formula ${\cal C}$
\end_inset

ode 
\begin_inset Formula ${\cal H}$
\end_inset

as a value of type 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 By 
\begin_inset Quotes eld
\end_inset

the code
\begin_inset Quotes erd
\end_inset

 we now mean the body of a given fully parametric function.
 When writing the code of a function's body, we are allowed to use the values
 of the function's arguments, which may have other types (say, 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

).
 So, the validity of the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 depends also on the types 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

.
 It follows that a 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula ${\cal CH}$
\end_inset

-proposition
\begin_inset Quotes erd
\end_inset

 is actually the following statement:
\begin_inset Formula 
\begin{align}
{\cal CH}\text{-proposition}:\quad & \text{a fully parametric expression can compute a value of type }A\nonumber \\
 & \text{using previously given values of types }X,Y,...,Z\quad.\label{eq:ch-CH-proposition-def}
\end{align}

\end_inset

Here 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 may be either type parameters or more complicated type expressions, such
 as 
\begin_inset Formula $B\rightarrow C$
\end_inset

 or 
\begin_inset Formula $(C\rightarrow D)\rightarrow E$
\end_inset

, built from other type parameters.
\end_layout

\begin_layout Standard
If values of types 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 are given, it means we 
\begin_inset Quotes eld
\end_inset

already have
\begin_inset Quotes erd
\end_inset

 values of those types.
 So, the propositions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 will be already true.
 Thus, proposition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-CH-proposition-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is true assuming 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 are true
\begin_inset Quotes erd
\end_inset

.
 In mathematical logic, a statement of this form is called a 
\series bold
sequent
\series default
 and
\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)
\end_layout

\end_inset

 is denoted using the symbol 
\begin_inset Formula $\vdash$
\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

turnstile
\begin_inset Quotes erd
\end_inset

):
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $\vdash$
\end_inset

 (turnstile) symbol
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
turnstile (
\begin_inset Formula $\vdash$
\end_inset

) symbol
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
\text{sequent}:\quad & {\cal CH}(X),{\cal CH}(Y),...,{\cal CH}(Z)\vdash{\cal CH}(A)\quad.\label{eq:ch-example-sequent}
\end{align}

\end_inset

The assumptions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 are called 
\series bold
premises
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)!premises
\end_layout

\end_inset

 and the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is called the 
\series bold
goal
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)!goal
\end_layout

\end_inset

 of the sequent.
\end_layout

\begin_layout Standard
Sequents provide a notation for the problem of computing values within the
 code of fully parametric functions.
 Since our goal is to solve such problems rigorously, we will need to be
 able to 
\emph on
prove
\emph default
 sequents of the form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Our previous examples are denoted by the following sequents:
\begin_inset Formula 
\begin{align*}
\text{\texttt{fmap} for \texttt{Option}}:\quad & {\cal CH}(\text{\texttt{A => B}})\vdash{\cal CH}(\text{\texttt{Option[A] => Option[B]}})\\
\text{the function \texttt{before}}:\quad & {\cal CH}(\text{\texttt{A => B}}),{\cal CH}(\text{\texttt{B => C}})\vdash{\cal CH}(\text{\texttt{A => C}})\\
\text{value of type }A\text{ within \texttt{fmap}}:\quad & {\cal CH}(\text{\texttt{A => B}}),{\cal CH}(\text{\texttt{Option[A]}})\vdash{\cal CH}(\text{\texttt{A}})\\
\text{value of type }C\rightarrow A\text{ within \texttt{before}}:\quad & {\cal CH}(\text{\texttt{A => B}}),{\cal CH}(\text{\texttt{B => C}})\vdash{\cal CH}(\text{\texttt{C => A}})
\end{align*}

\end_inset

In this section we gave informal arguments towards proving the first two
 sequents and disproving the last two.
 We will now develop tools for proving sequents.
 This will allow us to prove rigorously that a given fully parametric function
 can compute values of a certain type (or that it cannot).
\end_layout

\begin_layout Standard
In formal logic, sequents are proved
\begin_inset Index idx
status open

\begin_layout Plain Layout
proof (in logic)
\end_layout

\end_inset

 by starting with certain axioms and following certain derivation rules.
 Different choices of axioms and derivation rules will give different 
\emph on
logics
\emph default
.
 We will need to discover the correct logic for reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 That is, we will find a set of axioms and derivation rules that give correct
 answers about implementable and non-implementable types.
\end_layout

\begin_layout Subsection
Type notation and 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for standard type constructions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Type-notation-and-standard-type-constructions"

\end_inset


\end_layout

\begin_layout Standard
A proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 may be true with one set of premises such as 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 but false with another.
 Here and in the following sections, we will be reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions within the body of a 
\emph on
chosen
\emph default
 fully parametric function, i.e., with a fixed set of premises.
 We will then temporarily omit the premises and write just 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 instead of 
\begin_inset Formula ${\cal CH}(X),{\cal CH}(Y),...,{\cal CH}(Z)\vdash{\cal CH}(A)$
\end_inset

.
 In later sections, we will need to write full sets of premises for sequents.
\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctions-and-conjunctions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we saw examples of reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for case classes and for disjunctive types.
 We will now extend this reasoning systematically to all type constructions
 that fully parametric programs could use.
 A special type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation
\end_layout

\end_inset

 explained in this section will help us write type expressions more concisely.
 (See Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Appendix-Notations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for reference on the type notation.)
\end_layout

\begin_layout Standard
There exist 
\series bold
six
\series default
 
\series bold
standard type constructions
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
six type constructions
\end_layout

\end_inset

 supported by all functional languages: primitive types (including 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type and the void type, called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 in Scala), tuples (also called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product types
\end_layout

\end_inset


\series bold
product types
\series default
), disjunctive types (also called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
co-product types
\end_layout

\end_inset


\series bold
co-product types
\series default
), function types, parameterized types, and recursive types.
 We will now derive the rules for writing 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for each of these type constructions (except recursive types).
\end_layout

\begin_layout Paragraph
1a) Rule for the 
\family typewriter
Unit
\family default
 type
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has only a single value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, an 
\begin_inset Quotes eld
\end_inset

empty tuple
\begin_inset Quotes erd
\end_inset

.
 This value can be 
\emph on
always
\emph default
 computed since it does not need any previous data:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[...]: ...
 = {
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  val x: Unit = () // We can always compute a `Unit` value.
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\end_inset

So, the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always true.
 In the type notation, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 We may write 
\begin_inset Formula $\mathcal{CH}(\bbnum 1)=True$
\end_inset

.
\end_layout

\begin_layout Standard
Named unit types
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset

 also have a single value that is always possible to compute.
 For example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class N1()
\end_layout

\end_inset

defines a named unit type.
 We can compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N1
\end_layout

\end_inset

 without using any other given values:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "42col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: N1 = N1()
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
So, the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N1
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always true.
 Named unit types are also denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

, just as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type itself.
\end_layout

\begin_layout Paragraph
1b) Rule for the void type
\end_layout

\begin_layout Standard
The Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has no values, so the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always false.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\bbnum 0$
\end_inset

 in the type notation.
 So, the rule is 
\begin_inset Formula $\mathcal{CH}(\bbnum 0)=False$
\end_inset

.
\end_layout

\begin_layout Paragraph
1c) Rule for primitive types
\end_layout

\begin_layout Standard
For a specific primitive (or library-defined) type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, the corresponding 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition is 
\emph on
always true
\emph default
 because we could use a constant value, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[...]: ...
 {
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   val x: String = 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

 // We can always compute a `String` value.
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\end_inset

So, the rule for primitive types is the same as that for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
 For example, 
\begin_inset Formula $\mathcal{CH}(\text{String})=True$
\end_inset

.
\end_layout

\begin_layout Paragraph
2) Rule for tuple types
\end_layout

\begin_layout Standard
To compute a value of a tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 requires computing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 
\emph on
and
\emph default
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 This is expressed by the logic formula 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\begin_inset Formula $)={\cal CH}(A)\wedge{\cal CH}(B)$
\end_inset

.
 A similar formula holds for case classes, as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:curry-howard-example-case-class"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows.
 In the type notation, the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A\times B$
\end_inset

.
 Tuples and case classes with more than two parts are denoted similarly
 as 
\begin_inset Formula $A\times B\times...\times C$
\end_inset

.
 For example, the Scala definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Person(firstName: String, lastName: String, age: Int)
\end_layout

\end_inset

is written in the type notation as 
\begin_inset Formula $\text{String}\times\text{String}\times\text{Int}$
\end_inset

.
 So, the rule for tuple types is:
\begin_inset Formula 
\[
{\cal CH}\left(A\times B\times...\times C\right)={\cal CH}(A)\wedge{\cal CH}(B)\wedge...\wedge{\cal CH}(C)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
3) Rule for disjunctive types
\end_layout

\begin_layout Standard
A disjunctive type may consist of several case classes.
 Having a value of a disjunctive type means to have a value of (at least)
 one of those case classes.
 An example of translating this relationship into a formula was shown by
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:curry-howard-example-disjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For the standard disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, we have the logical formula 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\begin_inset Formula $)={\cal CH}(A)\vee{\cal CH}(B)$
\end_inset

.
 In the type notation, the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A+B$
\end_inset

.
 As another example, the Scala definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class NoRoots()                      extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class OneRoot(x: Double)             extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end_layout

\end_inset

is translated to the type notation as:
\begin_inset Formula 
\[
\text{RootsOfQ}\triangleq\bbnum 1+\text{Double}+\text{Double}\times\text{Double}\quad.
\]

\end_inset

Here, the type notation is significantly shorter because it omits all case
 class names and part names from the type definitions.
 Using the type notation, the rule for disjunctive types is written as:
\begin_inset Formula 
\[
{\cal CH}\left(A+B+...+C\right)={\cal CH}(A)\vee{\cal CH}(B)\vee...\vee{\cal CH}(C)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
4) Rule for function types
\end_layout

\begin_layout Standard
Consider now a function type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 This type is written in the type notation as 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 To compute a value of that type, we need to write code like this:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: A => B = { (a: A) =>
\end_layout

\begin_layout Plain Layout

  ??? // Compute a value of type B in this scope.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The inner scope of the function needs to compute a value of type 
\begin_inset Formula $B$
\end_inset

, and the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

 may be used for that.
 So, 
\begin_inset Formula ${\cal CH}(A\rightarrow B)$
\end_inset

 is true if and only if we are able to compute a value of type 
\begin_inset Formula $B$
\end_inset

 when we are given a value of type 
\begin_inset Formula $A$
\end_inset

.
 To translate this statement into the language of logical propositions,
 we need to use the logical
\begin_inset Index idx
status open

\begin_layout Plain Layout
logical implication
\end_layout

\end_inset

 
\series bold
implication
\series default
, 
\begin_inset Formula ${\cal CH}(A)\Rightarrow{\cal CH}(B)$
\end_inset

, which means that 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

 can be proved if we already have a proof of 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

.
 So, the rule for function types is:
\begin_inset Formula 
\[
{\cal CH}(A\rightarrow B)={\cal CH}(A)\Rightarrow{\cal CH}(B)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
5) Rule for parameterized types
\end_layout

\begin_layout Standard
Here is an example of a function with type parameters:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (A => B) => B = { x => g => g(x) }
\end_layout

\end_inset

Being able to define the body of such a function is the same as being able
 to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A => B) => B
\end_layout

\end_inset

 for 
\emph on
all
\emph default
 possible types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 In the notation of formal logic, this is written as:
\begin_inset Formula 
\[
{\cal CH}\left(\forall(A,B).\,A\rightarrow(A\rightarrow B)\rightarrow B\right)\quad,
\]

\end_inset

and is equivalent to:
\begin_inset Formula 
\[
\forall(A,B).\,{\cal CH}\left(A\rightarrow(A\rightarrow B)\rightarrow B\right)\quad.
\]

\end_inset

The symbol 
\begin_inset Formula $\forall$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

for all
\begin_inset Quotes erd
\end_inset

 and is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
universal quantifier
\end_layout

\end_inset


\series bold
universal quantifier
\series default
 in logic.
 
\end_layout

\begin_layout Standard
The type notation for the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is written in one of the following ways:
\begin_inset Formula 
\[
f^{A,B}:A\rightarrow\left(A\rightarrow B\right)\rightarrow B\quad,\quad\text{or equivalently}:\quad f:\forall(A,B).\,A\rightarrow\left(A\rightarrow B\right)\rightarrow B\quad.
\]

\end_inset

The type quantifier (
\begin_inset Quotes eld
\end_inset

for all 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

) indicates that 
\begin_inset Formula $f$
\end_inset

 can be used with all types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
In Scala, longer type expressions can be named and their names (called 
\series bold
type aliases
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

) can be used to make code shorter.
 Type aliases may also contain type parameters.
 Defining and using a type alias for the type of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A, B] = A => (A => B) => B
\end_layout

\begin_layout Plain Layout

def f[A, B]: F[A, B] = { x => g => g(x) }
\end_layout

\end_inset

This is written in the type notation by placing all type parameters into
 superscripts:
\begin_inset Formula 
\begin{align*}
F^{A,B} & \triangleq A\rightarrow\left(A\rightarrow B\right)\rightarrow B\quad,\\
f^{A,B}:F^{A,B} & \triangleq x^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(x)\quad,
\end{align*}

\end_inset

or equivalently (although somewhat less readably) as:
\begin_inset Formula 
\[
f:\big(\forall(A,B).\,F^{A,B}\big)\triangleq\forall(A,B).\,x^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(x)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In Scala 3, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 can be written as a value (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

) via this syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: [A, B] => A => (A => B) => B = {   // Valid only in Scala 3.
\end_layout

\begin_layout Plain Layout

  [A, B] => (x: A) => (g: A => B) => g(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This syntax corresponds more closely to the code notation 
\begin_inset Formula $\forall(A,B).\,x^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(x)$
\end_inset

.
\end_layout

\begin_layout Standard
So, the rule for parameterized types with the type notation 
\begin_inset Formula $F^{A}$
\end_inset

 is:
\begin_inset Formula 
\[
{\cal CH}(\forall A.\,F^{A})=\forall A.\,{\cal CH}(F^{A})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Case classes and disjunctive types use 
\emph on
names
\emph default
 for the types and their parts.
 However, those names only add convenience for programmers and do not affect
 the computational properties of types.
 The type notation is designed to support nameless type expressions.
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes the type notation and also shows how to translate it into logic
 formulas with propositions of the form 
\begin_inset Formula ${\cal CH}(...)$
\end_inset

.
\end_layout

\begin_layout Standard
The precedence
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation!operator precedence
\end_layout

\end_inset

 of operators in the type notation is chosen to have fewer parentheses in
 the type expressions that are frequently used.
 The rules of precedence are:
\end_layout

\begin_layout Itemize
The type product operator (
\begin_inset Formula $\times$
\end_inset

) groups stronger than the disjunctive operator (
\begin_inset Formula $+$
\end_inset

), so that type expressions such as 
\begin_inset Formula $A+B\times C$
\end_inset

 have the same operator precedence as in standard arithmetic.
 That is, 
\begin_inset Formula $A+B\times C$
\end_inset

 means 
\begin_inset Formula $A+\left(B\times C\right)$
\end_inset

.
 This convention makes type expressions easier to reason about (for people
 familiar with arithmetic).
\end_layout

\begin_layout Itemize
The function type arrow (
\begin_inset Formula $\rightarrow$
\end_inset

) groups weaker than the operators 
\begin_inset Formula $+$
\end_inset

 and 
\begin_inset Formula $\times$
\end_inset

, so that often-used types such as 
\begin_inset Formula $A\rightarrow\bbnum 1+B$
\end_inset

 (representing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Option[B]
\end_layout

\end_inset

) or 
\begin_inset Formula $A\times B\rightarrow C$
\end_inset

 (representing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B)) => C
\end_layout

\end_inset

) can be written without any parentheses.
 Type expressions such as 
\begin_inset Formula $\left(A\rightarrow B\right)\times C$
\end_inset

 will require parentheses but are needed less often.
\end_layout

\begin_layout Itemize
The type quantifiers group weaker than all other operators, so we can write
 types such as 
\begin_inset Formula $\forall A.\,A\rightarrow A\rightarrow A$
\end_inset

 without parentheses.
 This is helpful because type quantifiers are most often placed outside
 a type expression.
 When this is not the case, parentheses are necessary, e.g., in the type expressio
n 
\begin_inset Formula $\left(\forall A.\,A\rightarrow A\rightarrow A\right)\rightarrow\bbnum 1+\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
product type (tuple)
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\wedge$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
disjunctive type
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\vee$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
function type
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
unit or a 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Quotes erd
\end_inset

 type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\bbnum 1)=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
primitive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Int}$
\end_inset

, 
\begin_inset Formula $\text{String}$
\end_inset

, ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\text{Int})=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
void type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\bbnum 0)=False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
value parameterized by type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A]: F[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{A}:F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,{\cal CH}(F^{A})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
type with quantifier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val f: [A] => F[A]
\end_layout

\end_inset


\size small
 (Scala 3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f:\forall A.\,F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,{\cal CH}(F^{A})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The correspondence
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation
\end_layout

\end_inset

 between type constructions and 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\begin_inset CommandInset label
LatexCommand label
name "tab:ch-correspondence-type-notation-CH-propositions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Solved examples: Type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
From now on, we will prefer to write types in the type notation rather than
 in the Scala syntax.
 The type notation allows us to write nameless type expressions and , makes
 the structure of complicated types more clear, compared with the Scala
 syntax.
 Names of types and parts of types are, of course, helpful for reminding
 programmers of the meaning of data in a program.
 However, writing names for every part of every type is not helpful for
 reasoning about the properties of types.
 Type notation makes reasoning about types easier, as we will see throughout
 this chapter.
 Once the programmer has finished deriving the necessary types and verifying
 their properties, the type notation can be straightforwardly translated
 into Scala code.
 Let us get some experience doing that.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-dupl-function"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-dupl-function"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 taking an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returning the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, x)
\end_layout

\end_inset

.
 Derive the most general type for this function.
 Write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 in the type notation, and translate it into a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition.
 Simplify the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition if possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the code of the function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta(x: ...) = (x, x)
\end_layout

\end_inset

To derive the most general type for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

, first assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is a type parameter; then the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, x)
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

.
 We do not see any constraints on the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 represents an arbitrary type and needs to be added to the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A](x: A): (A, A) = (x, x)
\end_layout

\end_inset

We find that the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A, A)
\end_layout

\end_inset

.
 We also note that there is only one way of implementing a fully parametric
 function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A, A)
\end_layout

\end_inset

: the function must duplicate its given argument.
\end_layout

\begin_layout Standard
We will use the letter 
\begin_inset Formula $\Delta$
\end_inset

 for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

.
 In the type notation, the type signature of 
\begin_inset Formula $\Delta$
\end_inset

 is:
\begin_inset Formula 
\[
\Delta^{A}:A\rightarrow A\times A\quad.
\]

\end_inset

So, the proposition 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 (meaning 
\begin_inset Quotes eld
\end_inset

the function 
\begin_inset Formula $\Delta$
\end_inset

 can be implemented
\begin_inset Quotes erd
\end_inset

) is:
\begin_inset Formula 
\[
{\cal CH}(\Delta)=\forall A.{\cal \,CH}\left(A\rightarrow A\times A\right)\quad.
\]

\end_inset

In the type expression 
\begin_inset Formula $A\rightarrow A\times A$
\end_inset

, the product symbol (
\begin_inset Formula $\times$
\end_inset

) binds stronger than the function arrow (
\begin_inset Formula $\rightarrow$
\end_inset

), so the parentheses in 
\begin_inset Formula $A\rightarrow\left(A\times A\right)$
\end_inset

 may be omitted.
\end_layout

\begin_layout Standard
Using the rules for transforming 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions, we rewrite:
\begin_inset Formula 
\begin{align*}
 & {\cal CH}(A\rightarrow A\times A)\\
\text{rule for function types}:\quad & ={\cal CH}(A)\Rightarrow{\cal CH}(A\times A)\\
\text{rule for tuple types}:\quad & ={\cal CH}(A)\Rightarrow\left({\cal CH}(A)\wedge{\cal CH}(A)\right)\quad.
\end{align*}

\end_inset

Thus the proposition 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 is equivalent to:
\begin_inset Formula 
\[
{\cal CH}(\Delta)=\forall A.\,{\cal CH}(A)\Rightarrow({\cal CH}(A)\wedge{\cal CH}(A))\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The standard types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 are written in the type notation as:
\begin_inset Formula 
\[
\text{Either}^{A,B}\triangleq A+B\quad,\quad\quad\text{Opt}^{A}\triangleq\bbnum 1+A\quad.
\]

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A+B$
\end_inset

 by definition of the disjunctive type notation (
\begin_inset Formula $+$
\end_inset

).
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 has two disjoint cases, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

.
 The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 is a 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

 contains a single value of type 
\begin_inset Formula $A$
\end_inset

.
 So, the type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 We will also sometimes write 
\begin_inset Formula $\text{Opt}^{A}$
\end_inset

 to denote 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-1-a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-1-a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The Scala definition of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

UserAction
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait UserAction
\end_layout

\begin_layout Plain Layout

final case class SetName(first: String, last: String) extends UserAction
\end_layout

\begin_layout Plain Layout

final case class SetEmail(email: String)              extends UserAction
\end_layout

\begin_layout Plain Layout

final case class SetUserId(id: Long)                  extends UserAction
\end_layout

\end_inset

is written in the type notation as:
\begin_inset Formula 
\begin{equation}
\text{UserAction}\triangleq\text{String}\times\text{String}+\text{String}+\text{Long}\quad.\label{eq:ch-example-case-class-type-notation}
\end{equation}

\end_inset

The type operation 
\begin_inset Formula $\times$
\end_inset

 groups stronger than 
\begin_inset Formula $+$
\end_inset

, as in arithmetic.
 To derive the type notation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-case-class-type-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we first drop all names from case classes and get three nameless tuples
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String, String)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Long)
\end_layout

\end_inset

.
 Each of these tuples is then converted into a product using the operator
 
\begin_inset Formula $\times$
\end_inset

, and all products are 
\begin_inset Quotes eld
\end_inset

summed
\begin_inset Quotes erd
\end_inset

 in the type notation using the operator 
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The parameterized disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either3
\end_layout

\end_inset

 is a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Left[A, B, C](x: A)   extends Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Middle[A, B, C](x: B) extends Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Right[A, B, C](x: C)  extends Either3[A, B, C]
\end_layout

\end_inset

This disjunctive type is written in the type notation as 
\begin_inset Formula $\text{Either3}^{A,B,C}\triangleq A+B+C$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 corresponding to the type notation:
\begin_inset Formula 
\[
F^{A}\triangleq\bbnum 1+\text{Int}\times A\times A+\text{Int}\times\left(\text{Int}\rightarrow A\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The formula for 
\begin_inset Formula $F^{A}$
\end_inset

 defines a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 with three parts.
 To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 in Scala, we need to choose names for each of the disjoint parts, which
 will become case classes.
 For the purposes of this example, let us choose names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F3
\end_layout

\end_inset

.
 Each of these case classes needs to have the same type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So we begin writing the code as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A](...) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F2[A](...) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F3[A](...) extends F[A]
\end_layout

\end_inset

Each of these case classes represents one part of the disjunctive type:
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F1
\end_layout

\end_inset

 represents 
\begin_inset Formula $\bbnum 1$
\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F2
\end_layout

\end_inset

 represents 
\begin_inset Formula $\text{Int}\times A\times A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F3
\end_layout

\end_inset

 represents 
\begin_inset Formula $\text{Int}\times\left(\text{Int}\rightarrow A\right)$
\end_inset

.
 It remains to choose names and define the case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A]()                     extends F[A]  // Named unit
 type.
\end_layout

\begin_layout Plain Layout

final case class F2[A](n: Int, x1: A, x2: A) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F3[A](n: Int, f: Int => A)  extends F[A]
\end_layout

\end_inset

The names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 are chosen purely for convenience.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the type signature of the following function in the type notation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B]
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
This is a curried function, so we first rewrite the type signature as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B]: (A => B) => Option[A] => Option[B]
\end_layout

\end_inset

The type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 Now we can write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 as:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}^{A,B}:\left(A\rightarrow B\right)\rightarrow\bbnum 1+A\rightarrow\bbnum 1+B\quad,\\
\text{or equivalently}:\quad & \text{fmap}:\forall(A,B).\,\left(A\rightarrow B\right)\rightarrow\bbnum 1+A\rightarrow\bbnum 1+B\quad.
\end{align*}

\end_inset

We do not put parentheses around 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $\bbnum 1+B$
\end_inset

 because the function arrow (
\begin_inset Formula $\rightarrow$
\end_inset

) groups weaker than the other type operations.
 Parentheses around 
\begin_inset Formula $\left(A\rightarrow B\right)$
\end_inset

 are required.
\end_layout

\begin_layout Standard
We will usually prefer to write type parameters in superscripts rather than
 under type quantifiers.
 So, for example, we will write 
\begin_inset Formula $\text{id}^{A}\triangleq x^{:A}\rightarrow x$
\end_inset

 rather than 
\begin_inset Formula $\text{id}\triangleq\forall A.\,x^{:A}\rightarrow x$
\end_inset

.
\end_layout

\begin_layout Subsection
Exercises: Type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[T, A]
\end_layout

\end_inset

 corresponding to the type notation:
\begin_inset Formula 
\[
Q^{T,A}\triangleq\bbnum 1+T\times A+\text{Int}\times(T\rightarrow T)+\text{String}\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Rewrite 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, Int), Either[(A, Char), (A, Float)]]
\end_layout

\end_inset

 in the type notation.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Opt2[A, B]
\end_layout

\end_inset

 written in the type notation as 
\begin_inset Formula $\bbnum 1+A+B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write a Scala type signature for the fully parametric function:
\begin_inset Formula 
\[
\text{flatMap}^{A,B}:\bbnum 1+A\rightarrow\left(A\rightarrow\bbnum 1+B\right)\rightarrow\bbnum 1+B
\]

\end_inset

and implement this function, preserving information as much as possible.
\end_layout

\begin_layout Section
The logic of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions
\end_layout

\begin_layout Subsection
Motivation and first examples
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Motivation-and-first-examples"

\end_inset


\end_layout

\begin_layout Standard
So far, we were able to convert statements such as 
\begin_inset Quotes eld
\end_inset


\emph on
a fully parametric function can compute values of type
\emph default
 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 into logical propositions that we called 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 The next step is to determine the proof rules suitable for reasoning about
 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\end_layout

\begin_layout Standard
Formal logic uses axioms and derivation rules for proving that certain formulas
 are true or false.
 We will use Greek letters (
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, etc.) to denote propositions in logic.
\end_layout

\begin_layout Standard
We will often need logical formulas that talk about properties of 
\emph on
arbitrary
\emph default
 propositions.
 This is denoted by using the 
\series bold
universal quantifier
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
universal quantifier
\end_layout

\end_inset

 symbol (
\begin_inset Formula $\forall$
\end_inset

), pronounced 
\begin_inset Quotes eld
\end_inset

for all
\begin_inset Quotes erd
\end_inset

.
 The universal quantifier will be usually located in front of the formula,
 for example:
\begin_inset Formula 
\[
\forall(\alpha,\beta).\,\left(\alpha\Rightarrow\beta\right)\Rightarrow\alpha\Rightarrow\alpha\quad.
\]

\end_inset

The symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 denotes 
\begin_inset Index idx
status open

\begin_layout Plain Layout
implication (in logic)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
logical implication
\end_layout

\end_inset


\series bold
implication
\series default
: 
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset

 means that 
\emph on
if
\emph default
 
\begin_inset Formula $\alpha$
\end_inset

 can be proved true 
\emph on
then
\emph default
 
\begin_inset Formula $\beta$
\end_inset

 will be proved true.
\end_layout

\begin_layout Standard
Formulas whose propositions are universally quantified correspond to type
 signatures that are made entirely from type parameters.
 For instance, the formula shown above corresponds to the following type
 signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: (A => B) => A => A
\end_layout

\end_inset

The universal quantifier 
\begin_inset Formula $\forall(\alpha,\beta)$
\end_inset

 corresponds to the fact that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 works with any choice of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A simple example of a true logical formula is 
\begin_inset Quotes eld
\end_inset

any proposition 
\begin_inset Formula $\alpha$
\end_inset

 follows from itself
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{equation}
\forall\alpha.\,\alpha\Rightarrow\alpha\quad.\label{eq:ch-type-sig-1a}
\end{equation}

\end_inset

If the proposition 
\begin_inset Formula $\alpha$
\end_inset

 is a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition, that is, if 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 for some type 
\begin_inset Formula $A$
\end_inset

, we obtain from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-type-sig-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) the formula:
\begin_inset Formula 
\begin{equation}
\forall A.\,{\cal CH}(A)\Rightarrow{\cal CH}(A)\quad.\label{eq:ch-type-sig-1}
\end{equation}

\end_inset

We expect true 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions to correspond to types that 
\emph on
can
\emph default
 be computed in a fully parametric function.
 Let us see if this example fits our expectations.
 We can rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-type-sig-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,\gunderline{{\cal CH}(A)\Rightarrow{\cal CH}(A)}\\
\text{rule for function types}:\quad & =\gunderline{\forall A}.\,{\cal CH}\left(A\rightarrow A\right)\\
\text{rule for parameterized types}:\quad & ={\cal CH}\left(\forall A.\,A\rightarrow A\right)\quad.
\end{align*}

\end_inset

The last line shows a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition that corresponds to the type 
\begin_inset Formula $\forall A.\,A\rightarrow A$
\end_inset

.
 Translating this type notation into a Scala type signature, we get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => A
\end_layout

\end_inset

This type signature can be easily implemented as an identity function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => A = { x => x }
\end_layout

\end_inset

So, in this example we see how a formula in logic is converted into a type
 signature of a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, and we found that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 can be implemented in code.
\end_layout

\begin_layout Standard
While the correctness of the formula 
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset

 may be self-evident, the point of using formal logic is to have a set of
 axioms and proof rules that allow us to verify 
\emph on
all
\emph default
 true formulas systematically, without guessing or testing.
 What axioms and proof rules are suitable for proving 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions?
\end_layout

\begin_layout Standard
A set of axioms and proof rules defines a 
\series bold
formal logic
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
formal logic
\end_layout

\end_inset

.
 Mathematicians have studied many different logics that are useful for solving
 different problems.
 We are now looking for a specific formal logic that gives correct answers
 when reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fn:Bornat-proof-book"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bornat
\end_layout

\end_inset

For an overview and more details about that logic and the necessary proof
 techniques, see the book by R.
\begin_inset space ~
\end_inset

Bornat, 
\begin_inset Quotes eld
\end_inset

Proof and disproof in formal logic: an introduction for programmers
\begin_inset Quotes erd
\end_inset

.
 An early draft version of that book is available at 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://homepages.phonecoop.coop/randj/richard/books/ProofandDisproof.pdf"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The rules of proof for 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-rules-of-proof"

\end_inset


\end_layout

\begin_layout Standard
To derive the suitable logical axioms and proof rules systematically, let
 us examine what makes a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition true.
 A sequent 
\begin_inset Formula ${\cal CH}(A)\vdash{\cal CH}(X)$
\end_inset

 is true when a value of type 
\begin_inset Formula $X$
\end_inset

 can be computed by fully parametric code that may only use a given value
 of type 
\begin_inset Formula $A$
\end_inset

.
 To describe all possible ways of computing a value of type 
\begin_inset Formula $X$
\end_inset

, we need to enumerate all possible ways of 
\emph on
writing code
\emph default
 for a fully parametric function body.
 The requirement of full parametricity means that we are not allowed to
 use any specific types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, any concrete values such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, or any library functions that work with specific (non-parametric) types.
 We are only allowed to work with values of unknown types described by the
 given type parameters.
 However, we are permitted to use fully parametric types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
In fact, we can enumerate all the allowed constructions that may be used
 by fully parametric code implementing a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition.
 There are 
\emph on
eight
\emph default
 code constructions
\begin_inset Index idx
status open

\begin_layout Plain Layout
eight code constructions
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code constructions
\end_layout

\end_inset

 as illustrated by this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B, ...](a: A, b: B): X = {   // Any given type signature.
\end_layout

\begin_layout Plain Layout

  val x1: Unit = ()                   // 1) Use a value of type Unit.
\end_layout

\begin_layout Plain Layout

  val x2: A = a                       // 2) Use a given argument.
\end_layout

\begin_layout Plain Layout

  val x3 = { x: A => b }              // 3) Create a function.
\end_layout

\begin_layout Plain Layout

  val x4: D = x3(x2)                  // 4) Use a function.
\end_layout

\begin_layout Plain Layout

  val x5: (A, B) = (a, b)             // 5) Create a tuple.
\end_layout

\begin_layout Plain Layout

  val x6: B = x5._2                   // 6) Use a tuple.
\end_layout

\begin_layout Plain Layout

  val x7: Option[A] = Some(x2)        // 7) Create values of a disjunctive
 type.
\end_layout

\begin_layout Plain Layout

  val x8 = x7 match { ...
 }           // 8) Use values of a disjunctive type.
\end_layout

\begin_layout Plain Layout

}     // 9) Call f() itself recursively.
 Not included here because not supported by CH-propositions.
\end_layout

\end_inset

The proposition 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

 is true if we can create a sequence of computed values such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x2
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xN
\end_layout

\end_inset

, each using one of these eight code constructs, with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xN
\end_layout

\end_inset

 having type 
\begin_inset Formula $X$
\end_inset

.
 So, each of the eight code constructs will give a proof rule in the logic.
\end_layout

\begin_layout Standard
It is important that there are only a finite number of allowed code construction
s.
 This defines rigorously the concept of 
\begin_inset Quotes eld
\end_inset

fully parametric code
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
fully parametric!code
\end_layout

\end_inset

 and allows us to 
\emph on
prove
\emph default
 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\end_layout

\begin_layout Standard
Reasoning about proof rules is easier with a compact notation.
 To obtain that notation, we first need to translate the eight code constructs
 into the notation of sequents.
 A proof of a sequent, e.g., 
\begin_inset Formula $\mathcal{CH}(A)\vdash\mathcal{CH}(X)$
\end_inset

, will consist of applying some of those proof rules.
 We will then combine the code constructs corresponding to each rule and
 obtain some code that computes a value of type 
\begin_inset Formula $X$
\end_inset

 using an argument of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
Conversely, any fully parametric (and non-recursive) code computing a value
 of type 
\begin_inset Formula $X$
\end_inset

 must be a combination of some of the eight code constructs
\begin_inset Index idx
status open

\begin_layout Plain Layout
eight code constructions
\end_layout

\end_inset

.
 That code combination can be translated into a combination of logic rules,
 which will produce a proof of the proposition 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

.
\end_layout

\begin_layout Standard
In the following text, we will need to use the full formulation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-CH-proposition-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions and write them as sequents such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For brevity, we define 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

, 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

, etc.
 It is also customary to use the letter 
\begin_inset Formula $\Gamma$
\end_inset

 to denote a set of premises, such as 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we can write a shorter formula 
\begin_inset Formula $\Gamma\vdash\alpha$
\end_inset

 instead of the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
With these notations, we list the rules for proving 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions and the corresponding code:
\end_layout

\begin_layout Paragraph
1) Use the 
\family typewriter
Unit
\family default
 value
\end_layout

\begin_layout Standard
At any place in the code, we may write the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 This expression corresponds to a proof of the proposition 
\begin_inset Formula ${\cal CH}(\bbnum 1)$
\end_inset

 with any set 
\begin_inset Formula $\Gamma$
\end_inset

 of premises (even with an empty set of premises).
 So, the sequent 
\begin_inset Formula $\Gamma\vdash{\cal CH}(\bbnum 1)$
\end_inset

 is always true.
 The code corresponding to the proof of this sequent is an expression that
 creates a value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type:
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma\vdash{\cal CH}(\bbnum 1)\big)=1\quad,
\]

\end_inset

where we denoted by 
\begin_inset Formula $1$
\end_inset

 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In formal logic, a sequent that is always true, such as our 
\begin_inset Formula $\Gamma\vdash{\cal CH}(\bbnum 1)$
\end_inset

, is called an 
\series bold
axiom
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
logical axiom
\end_layout

\end_inset

 and is written in the following notation:
\begin_inset Formula 
\[
\frac{}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{create unit})\quad\quad.
\]

\end_inset

The 
\begin_inset Quotes eld
\end_inset

fraction with a label
\begin_inset Quotes erd
\end_inset

 represents a proof rule.
 The denominator of the 
\begin_inset Quotes eld
\end_inset

fraction
\begin_inset Quotes erd
\end_inset

 is the target sequent that we need to prove.
 The numerator of the 
\begin_inset Quotes eld
\end_inset

fraction
\begin_inset Quotes erd
\end_inset

 can have zero or more other sequents that need to be proved before the
 target sequent can be proved.
 In this case, the set of previous sequents is empty: the target sequent
 is an axiom and so requires no previous sequents for its proof.
 The label 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create unit}$
\end_inset


\begin_inset Quotes erd
\end_inset

 is an arbitrary name used to refer to the rule.
\end_layout

\begin_layout Paragraph
2) Use a given argument
\end_layout

\begin_layout Standard
At any place within the code of a fully parametric function, we may use
 one of the function's arguments, say 
\begin_inset Formula $x^{:A}$
\end_inset

.
 If some argument has type 
\begin_inset Formula $A$
\end_inset

, it means that 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 belongs to the set of premises of the sequent we are trying to prove.
 To indicate this, we write the set of premises as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\Gamma,\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The code construct 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 computes a value of type 
\begin_inset Formula $A$
\end_inset

, i.e., show that 
\begin_inset Formula $\alpha$
\end_inset

 is true, given these premises.
 This is expressed by the sequent 
\begin_inset Formula $\Gamma,\alpha\vdash\alpha$
\end_inset

.
 The proof of this sequent corresponds to an expression that returns one
 of the given arguments (which we here called 
\begin_inset Formula $x^{:A}$
\end_inset

):
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma,\alpha\vdash\alpha\big)=x^{:A}\quad.
\]

\end_inset

This sequent is an axiom since its proof requires no previous sequents.
 We denote this axiom by:
\begin_inset Formula 
\[
\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use arg})\quad\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
3) Create a function
\end_layout

\begin_layout Standard
At any place in the code, we may compute a nameless function of type, say,
 
\begin_inset Formula $A\rightarrow B$
\end_inset

, by writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:A) => expr
\end_layout

\end_inset

 as long as a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 of type 
\begin_inset Formula $B$
\end_inset

 can be computed in the inner scope of the function.
 The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 is also required to be fully parametric; it may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and/or other values visible in that scope.
 So we now need to answer the question of whether a fully parametric function
 can compute a value of type 
\begin_inset Formula $B$
\end_inset

, given an argument of type 
\begin_inset Formula $A$
\end_inset

 as well as all other arguments previously given to the parent function.
 This question is answered by a sequent whose premises contain one more
 proposition, 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, in addition to all previously available premises.
 Translating this into the language of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions, we find that we will prove the sequent:
\begin_inset Formula 
\[
\Gamma\vdash{\cal CH}(A\rightarrow B)\quad=\quad\Gamma\vdash{\cal CH}(A)\Rightarrow{\cal CH}(B)\quad=\quad\Gamma\vdash\alpha\Rightarrow\beta
\]

\end_inset

if we can prove the sequent 
\begin_inset Formula $\Gamma,{\cal CH}(A)\vdash{\cal CH}(B)=\Gamma,\alpha\vdash\beta$
\end_inset

.
 In the notation of formal logic, this is a 
\series bold
derivation rule
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
derivation rule
\end_layout

\end_inset

 (rather than an axiom) and is written as:
\begin_inset Formula 
\[
\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})\quad\quad.
\]

\end_inset

The 
\series bold
turnstile
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $\vdash$
\end_inset

 (turnstile) symbol
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
turnstile (
\begin_inset Formula $\vdash$
\end_inset

) symbol
\end_layout

\end_inset

 symbol (
\begin_inset Formula $\vdash$
\end_inset

) groups weaker than other operators.
 So, we can write sequents such as 
\begin_inset Formula $(\Gamma,\alpha)\vdash(\beta\Rightarrow\gamma)$
\end_inset

 with fewer parentheses: 
\begin_inset Formula $\Gamma,\alpha\vdash\beta\Rightarrow\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
What code corresponds to the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 rule? The proof of 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

 depends on a proof of another sequent.
 So, the corresponding code must be a 
\emph on
function
\emph default
 that takes a proof of the previous sequent as an argument and returns a
 proof of the new sequent.
 By the CH correspondence, a proof of a sequent corresponds to a code expression
 of the type given by the goal of the sequent.
 That expression may use arguments of types corresponding to the premises
 of the sequent.
 So, a proof of the sequent 
\begin_inset Formula $\Gamma,\alpha\vdash\beta$
\end_inset

 is an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exprB
\end_layout

\end_inset

 of type 
\begin_inset Formula $B$
\end_inset

 that may use a given value of type 
\begin_inset Formula $A$
\end_inset

 as well as any other arguments given previously.
 Then we can write the proof code for the sequent 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

 as the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:A) => exprB
\end_layout

\end_inset

.
 This function has type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 and requires us to already have a suitable expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exprB
\end_layout

\end_inset

.
 This exactly corresponds to the proof rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 We may write the corresponding code as:
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma\vdash{\cal CH}(A)\Rightarrow{\cal CH}(B)\big)=x^{:A}\rightarrow\text{Proof}\,\big(\Gamma,x^{:A}\vdash{\cal CH}(B)\big)\quad.
\]

\end_inset

Here we wrote 
\begin_inset Formula $x^{:A}$
\end_inset

 instead of 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 since the value 
\begin_inset Formula $x^{:A}$
\end_inset

 is a proof of the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

.
 We will see in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example:-Proving-a-ch-proposition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 how premises such as 
\begin_inset Formula $\Gamma,x^{:A}$
\end_inset

 are implemented in code.
\end_layout

\begin_layout Paragraph
4) Use a function
\end_layout

\begin_layout Standard
At any place in the code, we may apply an already defined function of type
 
\begin_inset Formula $A\rightarrow B$
\end_inset

 to an already computed value of type 
\begin_inset Formula $A$
\end_inset

.
 The result will be a value of type 
\begin_inset Formula $B$
\end_inset

.
 This corresponds to assuming 
\begin_inset Formula ${\cal CH}(A\rightarrow B)$
\end_inset

 and 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, and then deriving 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

.
 The notation for this proof rule is:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})\quad\quad.
\]

\end_inset

The code corresponding to this proof rule takes previously computed values
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f:A => B
\end_layout

\end_inset

, and writes the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 This can be written as a function application:
\begin_inset Formula 
\[
\text{Proof}\,(\Gamma\vdash\beta)=\text{Proof}\left(\Gamma\vdash\alpha\Rightarrow\beta\right)(\text{Proof}\,(\Gamma\vdash\alpha))\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
5) Create a tuple
\end_layout

\begin_layout Standard
If we have already computed some values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

, we may write the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

 and so compute a value of the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

.
 The proof rule is:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})\quad\quad.
\]

\end_inset

Writing 
\begin_inset Formula $a\times b$
\end_inset

 to mean the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

, we can write the corresponding code expression as:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)=\text{Proof}\left(\Gamma\vdash\alpha\right)\times\text{Proof}\left(\Gamma\vdash\beta\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
This rule describes creating a tuple of 
\begin_inset Formula $2$
\end_inset

 values.
 A larger tuple, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(w, x, y, z)
\end_layout

\end_inset

, can be expressed via nested pairs, e.g., as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(w, (x, (y, z)))
\end_layout

\end_inset

.
 So, it suffices to have a derivation rule for creating pairs.
 That rule allows us to express the rules for creating all larger tuples,
 so we do not need to define separate rules for, say, 
\begin_inset Formula $\Gamma\vdash\alpha\wedge\beta\wedge\gamma$
\end_inset

.
\end_layout

\begin_layout Paragraph
6) Use a tuple
\end_layout

\begin_layout Standard
If we already have a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t:(A,B)
\end_layout

\end_inset

 of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

, we can extract one of the parts of the tuple and obtain a value of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The code is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t._2
\end_layout

\end_inset

 respectively, and the corresponding sequent proof rules are:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)\quad\quad\quad\quad\quad\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\beta}\quad(\text{use tuple-}2)\quad\quad.
\]

\end_inset

The code can be written as:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\alpha\right)=\pi_{1}\left(\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)\right)\quad,\quad\quad\text{Proof}\left(\Gamma\vdash\beta\right)=\pi_{2}\left(\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)\right)\quad,
\]

\end_inset

where we introduced the notation 
\begin_inset Formula $\pi_{1}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}$
\end_inset

 to mean the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Since all tuples can be expressed through pairs, it is sufficient to have
 proof rules for pairs.
\end_layout

\begin_layout Paragraph
7) Create a disjunctive value
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 corresponding to the disjunction 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 can be used to define any other disjunctive type; e.g., a disjunctive type
 with three parts can be expressed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Either[B, C]]
\end_layout

\end_inset

.
 So, it suffices to have proof rules for a disjunction of 
\emph on
two
\emph default
 propositions.
\end_layout

\begin_layout Standard
There are two ways of creating a value of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

: the code expressions are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x:A)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y:B)
\end_layout

\end_inset

.
 The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

 must have been computed previously (and correspond to previously proved
 sequents).
 So, the sequent proof rules are:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Left})\quad\quad\quad\quad\quad\frac{\Gamma\vdash\beta}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Right})\quad\quad.
\]

\end_inset

The corresponding code can be written using the case class names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right)=\text{Left}\,(\text{Proof}\left(\Gamma\vdash\alpha\right))\quad,\quad\quad\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right)=\text{Right}\,(\text{Proof}\left(\Gamma\vdash\beta\right))\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
8) Use a disjunctive value
\end_layout

\begin_layout Standard
Pattern matching is the basic way of using a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "42col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: C = (e: Either[A, B]) match {
\end_layout

\begin_layout Plain Layout

  case Left(x:A)    => expr1(x)
\end_layout

\begin_layout Plain Layout

  case Right(y:B)   => expr2(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr1(x)
\end_layout

\end_inset

 is an expression of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

C
\end_layout

\end_inset

 computed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and any previously computed values.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr2(y)
\end_layout

\end_inset

 is computed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

 and previous values.
 The values used in computation correspond to the premises of a sequent.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr1(x)
\end_layout

\end_inset

 represents a proof of a sequent with an additional premise of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Denoting 
\begin_inset Formula $\gamma\triangleq{\cal CH}(C)$
\end_inset

, we write that sequent as: 
\begin_inset Formula $\Gamma,\alpha\vdash\gamma$
\end_inset

.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr2(y)
\end_layout

\end_inset

 is a proof of the sequent 
\begin_inset Formula $\Gamma,\beta\vdash\gamma$
\end_inset

.
 We can compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

result
\end_layout

\end_inset

 only if we can compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

e
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

expr1
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

expr2
\end_layout

\end_inset

.
 So, the proof rule is: 
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use Either})\quad\quad.
\]

\end_inset

The corresponding code can be written as:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\gamma\right)=\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right)\text{ match }\begin{cases}
\text{case }a^{:A}\rightarrow & \text{Proof}\left(\Gamma,\alpha\vdash\gamma\right)_{\text{given }a}\\
\text{case }b^{:B}\rightarrow & \text{Proof}\left(\Gamma,\beta\vdash\gamma\right)_{\text{given }b}
\end{cases}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We found eight proof rules shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These rules define the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
intuitionistic propositional logic
\end_layout

\end_inset

intuitionistic propositional logic
\series default
, also called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
constructive logic
\end_layout

\end_inset

constructive propositional logic
\series default
.
 We will call this logic 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

 for short.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset Formula 
\begin{align*}
\text{axioms}:\quad & \frac{~}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{use unit})\quad\quad\quad\quad\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use arg})\\
\text{derivation rules}:\quad & \frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})\\
 & \frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})\\
 & \frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})\\
 & \frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)\quad\quad\quad\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\beta}\quad(\text{use tuple-}2)\\
 & \frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create \texttt{Left}})\quad\quad\quad\frac{\Gamma\vdash\beta}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create \texttt{Right}})\\
 & \frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use \texttt{Either}})
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof rules for the constructive logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Proof-rules-for-constructive-logic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Example: Proving a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition and deriving code
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example:-Proving-a-ch-proposition"

\end_inset


\end_layout

\begin_layout Standard
We will implement a fully parametric function:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: ((A => A) => B) => B = ???
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Implementing this function is the same as being able to compute a value
 of type 
\begin_inset Formula $F$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is defined as:
\begin_inset Formula 
\[
F\triangleq\forall(A,B).\,((A\rightarrow A)\rightarrow B)\rightarrow B\quad.
\]

\end_inset

Since the type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are arbitrary, the body of the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 cannot use any previously defined values of types 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $B$
\end_inset

.
 So, the task is formulated as computing a value of type 
\begin_inset Formula $F$
\end_inset

 with 
\emph on
no
\emph default
 previously defined values.
 This is written as the sequent 
\begin_inset Formula $\Gamma\vdash{\cal CH}(F)$
\end_inset

, where the set 
\begin_inset Formula $\Gamma$
\end_inset

 of premises is empty (
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

).
 Rewriting this sequent using the rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we get:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).~\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta\quad,\label{eq:ch-example-sequent-2}
\end{equation}

\end_inset

where we denoted 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

.
 
\end_layout

\begin_layout Standard
The next step is to prove the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) using the proof rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For brevity, we will omit the quantifier 
\begin_inset Formula $\forall(\alpha,\beta)$
\end_inset

 since it will be present in front of every sequent.
\end_layout

\begin_layout Standard
Begin by looking for a proof rule whose 
\begin_inset Quotes eld
\end_inset

denominator
\begin_inset Quotes erd
\end_inset

 has a sequent similar to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), i.e., has an implication (
\begin_inset Formula $p\Rightarrow q$
\end_inset

) in the goal.
 We have only one rule that can prove a sequent of the form 
\begin_inset Formula $\Gamma\vdash(p\Rightarrow q$
\end_inset

); this is the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 That rule requires us to already have a proof of the sequent 
\begin_inset Formula $(\Gamma,p)\vdash q$
\end_inset

.
 So, we use this rule with 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

, and we set 
\begin_inset Formula $p\triangleq(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

 and 
\begin_inset Formula $q\triangleq\beta$
\end_inset

: 
\begin_inset Formula 
\[
\frac{(\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta}{\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta}\quad.
\]

\end_inset

We now need to prove the sequent 
\begin_inset Formula $(\alpha\Rightarrow\alpha)\Rightarrow\beta)\vdash\beta$
\end_inset

, which we can write as 
\begin_inset Formula $\Gamma_{1}\vdash\beta$
\end_inset

 where 
\begin_inset Formula $\Gamma_{1}\triangleq[(\alpha\Rightarrow\alpha)\Rightarrow\beta]$
\end_inset

 denotes the set containing the single premise 
\begin_inset Formula $(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
 
\end_layout

\begin_layout Standard
There are no proof rules that derive a sequent with a premise in the form
 of an implication 
\begin_inset Formula $p\Rightarrow q$
\end_inset

.
 However, we have a rule called 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 that derives a sequent by assuming another sequent containing an implication.
 After some trial and error, one finds that the rule may be used like this:
\begin_inset Formula 
\[
\frac{\Gamma_{1}\vdash\alpha\Rightarrow\alpha\quad\quad\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta}{\Gamma_{1}\vdash\beta}\quad.
\]

\end_inset

Now we need to prove the two new sequents 
\begin_inset Formula $\Gamma_{1}\vdash\alpha\Rightarrow\alpha$
\end_inset

 and 
\begin_inset Formula $\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
 To prove these sequents, note that the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 applies to 
\begin_inset Formula $\Gamma_{1}\vdash\alpha\Rightarrow\alpha$
\end_inset

 like this:
\begin_inset Formula 
\[
\frac{\Gamma_{1},\alpha\vdash\alpha}{\Gamma_{1}\vdash\alpha\Rightarrow\alpha}\quad.
\]

\end_inset

The sequent 
\begin_inset Formula $\Gamma_{1},\alpha\vdash\alpha$
\end_inset

 is proved directly by the axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The sequent 
\begin_inset Formula $\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

 is also proved by the axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

 because 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 already contains 
\begin_inset Formula $(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
\end_layout

\begin_layout Standard
The proof of the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is now complete and can be drawn as a tree (Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The next step is to convert that proof to Scala code.
\end_layout

\begin_layout Standard
To do that, we combine the code expressions that correspond to each of the
 proof rules we used.
 We need to retrace the proof backwards, starting from the leaves of the
 tree and going towards the root.
 We will then assemble the 
\begin_inset Formula $\text{Proof}\left(...\right)$
\end_inset

 code expressions one after another.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Preview

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ .$
\backslash
emptyset
\backslash
vdash((
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta)
\backslash
Rightarrow
\backslash
beta $ [ .{rule ``$
\backslash
text{create function}$''} [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash
\backslash
beta$ [ .{rule ``$
\backslash
text{use function}$''} [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha$ [ .{rule ``$
\backslash
text{create function}$''} [ .$
\backslash
Gamma_1,
\backslash
alpha
\backslash
vdash
\backslash
alpha$ {axiom ``$
\backslash
text{use arg}$''} ] ] ] [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta$ {axiom ``$
\backslash
text{use arg}$''} ] ] ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof tree for sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset CommandInset label
LatexCommand label
name "fig:Proof-of-the-sequent-example-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Begin with the left-most leaf: 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 That rule gives the code 
\begin_inset Formula $x^{:A}$
\end_inset

:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma_{1},\alpha\vdash\alpha\right)_{\text{given }x}=x^{:A}\quad.
\]

\end_inset

Here 
\begin_inset Quotes eld
\end_inset

given 
\begin_inset Formula $x$
\end_inset


\begin_inset Quotes erd
\end_inset

 means that 
\begin_inset Formula $x^{:A}$
\end_inset

 must be a proof of the premise 
\begin_inset Formula $\alpha$
\end_inset

 in the sequent 
\begin_inset Formula $\Gamma_{1},\alpha\vdash\alpha$
\end_inset

 (recall that 
\begin_inset Formula $\alpha$
\end_inset

 denotes 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

).
 So, we need to use the same 
\begin_inset Formula $x^{:A}$
\end_inset

 when we write the code for the previous rule, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma_{1}\vdash\alpha\Rightarrow\alpha\right)=(x^{:A}\rightarrow\text{Proof}\left(\Gamma_{1},\alpha\vdash\alpha\right)_{\text{given }x})=(x^{:A}\rightarrow x)\quad.
\]

\end_inset

The right-most leaf 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

 corresponds to the code 
\begin_inset Formula $f^{:(A\rightarrow A)\rightarrow B}$
\end_inset

, where 
\begin_inset Formula $f$
\end_inset

 is the premise contained in 
\begin_inset Formula $\Gamma_{1}$
\end_inset

.
 So we can write:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta\right)_{\text{given }f}=f^{:(A\rightarrow A)\rightarrow B}\quad.
\]

\end_inset

The previous rule, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

, combines the two preceding proofs:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\left((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta\right)_{\text{given }f^{:\left(A\rightarrow A\right)\rightarrow B}}\\
 & =\text{Proof}\,(\Gamma_{1}\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta)\left(\text{Proof}\,(\Gamma_{1}\vdash\alpha\Rightarrow\alpha)\right)_{\text{given }f}\\
 & =f(x^{:A}\rightarrow x)\quad.
\end{align*}

\end_inset

Going further backwards, we find that the rule applied before 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 was 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 We need to provide the same 
\begin_inset Formula $f^{:\left(A\rightarrow A\right)\rightarrow B}$
\end_inset

 as in the premise above, and so we obtain the code:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\left(\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta\right)\\
 & =f^{:\left(A\rightarrow A\right)\rightarrow B}\rightarrow\text{Proof}\left((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta\right)_{\text{given }f^{:\left(A\rightarrow A\right)\rightarrow B}}\\
 & =f^{:\left(A\rightarrow A\right)\rightarrow B}\rightarrow f(x^{:A}\rightarrow x)\quad.
\end{align*}

\end_inset

This is the final code expression that implements the type 
\begin_inset Formula $((A\rightarrow A)\rightarrow B)\rightarrow B$
\end_inset

.
 In this way, we have systematically derived the code from the type signature
 of a function.
 That function can be written in Scala as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: ((A => A) => B) => B = { f => f(x => x) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We found the proof tree in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by guessing how to combine various proof rules.
 In particular, we had to guess how to apply the 
\begin_inset Quotes eld
\end_inset

use function
\begin_inset Quotes erd
\end_inset

 rule.
 So, if we 
\emph on
somehow
\emph default
 find a proof tree for a sequent, we can prove the sequent and derive the
 corresponding code.
 However, it is not always obvious how to apply the proof rules, and we
 sometimes have to guess or to try different possibilities.
 In other words, the rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 do not provide an algorithm for finding a proof tree automatically.
 It turns out that one can replace the rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by a different but equivalent set of derivations rules that do give an
 algorithm called the 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
LJT algorithm
\end_layout

\end_inset

LJT algorithm
\begin_inset Quotes erd
\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:The-LJT-algorithm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
 That algorithm first translates a type signature containing tuples, disjunctive
 types, and function types into a logical formula.
 Then the algorithm either finds that the given formula cannot be proved,
 or it finds a proof and infers code that has the given type signature.
\end_layout

\begin_layout Standard
The library 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
curryhoward
\family default
 library
\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset


\family typewriter

\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Chymyst/curryhoward"

\end_inset


\end_layout

\end_inset


\family default
 implements the LJT algorithm.
 Here are some examples of using this library for 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
code inference
\end_layout

\end_inset

code inference
\begin_inset Quotes erd
\end_inset

.
 We will run the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ammonite
\end_layout

\end_inset


\family typewriter

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://ammonite.io/#Ammonite-Shell"

\end_inset


\end_layout

\end_inset


\family default
 shell to load the library more easily.
\end_layout

\begin_layout Standard
As a non-trivial (but artificial) example, consider the type signature:
\begin_inset Formula 
\[
\forall(A,B).\,\left(\left(\left(\left(A\rightarrow B\right)\rightarrow A\right)\rightarrow A\right)\rightarrow B\right)\rightarrow B\quad.
\]

\end_inset

It is not obvious whether a function with this type signature exists.
 The LJT algorithm can figure that out and derive the code automatically.
 The library does this via the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implement
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ import $ivy.`io.chymyst::curryhoward:0.3.8`, io.chymyst.ch._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ def f[A, B]: ((((A => B) => A) => A) => B) => B   =   implement
\end_layout

\begin_layout Plain Layout

defined function f
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ println(f.lambdaTerm.prettyPrint)
\end_layout

\begin_layout Plain Layout

a => a (b => b (c => a (d => c)))
\end_layout

\end_inset

The code 
\begin_inset Formula $a\rightarrow a\left(b\rightarrow b\left(c\rightarrow a\left(d\rightarrow c\right)\right)\right)$
\end_inset

 was produced automatically for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 has been compiled and is ready to be used in any subsequent code.
\end_layout

\begin_layout Standard
A compile-time error occurs when no fully parametric function has the given
 type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def g[A, B]: ((A => B) => A) => A   =   implement
\end_layout

\begin_layout Plain Layout

cmd3.sc:1: type ((A => B) => A) => A cannot be implemented
\end_layout

\end_inset

The logical formula corresponding to this type signature is:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).\,\left(\left(\alpha\Rightarrow\beta\right)\Rightarrow\alpha\right)\Rightarrow\alpha\quad.\label{eq:ch-example-3-peirce-law}
\end{equation}

\end_inset

This formula is known as 
\begin_inset Quotes eld
\end_inset

Peirce's law
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Peirce%27s_law"
target "https://en.wikipedia.org/wiki/Peirce%27s_law"
literal "false"

\end_inset


\end_layout

\end_inset

 and gives an example showing that the logic of types in functional programming
 languages is not Boolean (other examples are shown in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example:-Failure-of-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relationship-between-Boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Peirce's law is true in Boolean logic but does not hold in the constructive
 logic, i.e., it cannot be derived using the proof rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 If we try to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g[A, B]
\end_layout

\end_inset

 with the type signature shown above via fully parametric code, we will
 fail to write code that compiles without type errors.
 This is because no such code exists, — not because we are insufficiently
 clever.
 The LJT algorithm can 
\emph on
prove
\emph default
 that the given type signature cannot be implemented.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library will then print an error message, and compilation will fail.
\end_layout

\begin_layout Standard
As another example, let us verify that the type signature from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example:-Failure-of-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is not implementable:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def bad[A, B, C](g: A => Either[B, C]): Either[A => B, A => C]   =   implement
\end_layout

\begin_layout Plain Layout

cmd4.sc:1: type (A => Either[B, C]) => Either[A => B, A => C] cannot be implement
ed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The LJT algorithm will sometimes find several inequivalent proofs of the
 same logic formula.
 In that case, each of the different proofs will be automatically translated
 into code.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library tries to select the code that has the least information loss, according
 to several heuristics.
 In many cases, the heuristics select the implementation that is most useful
 to the programmer.
\end_layout

\begin_layout Standard
The rules of constructive logic and the LJT algorithm define rigorously
 what it means to write code 
\begin_inset Quotes eld
\end_inset

guided by the types
\begin_inset Quotes erd
\end_inset

.
 However, in order to use the LJT algorithm well, a programmer needs to
 learn how to infer code from types by hand.
 We will practice doing that throughout the book.
\end_layout

\begin_layout Subsection
Failure of Boolean logic in reasoning about 
\begin_inset Formula $\mathcal{CH}$
\end_inset

-propositions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example:-Failure-of-Boolean-logic"

\end_inset


\end_layout

\begin_layout Standard
Programmers are most familiar with the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Boolean logic
\end_layout

\end_inset

Boolean logic whose operations are written in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x && y
\end_layout

\end_inset

 (conjunction), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x || y
\end_layout

\end_inset

 (disjunction), and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!x
\end_layout

\end_inset

 (negation).
 However, it turns out that the Boolean logic does 
\emph on
not
\emph default
 always produce correct conclusions when reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 One needs to use the constructive logic to reason correctly about implementable
 type signatures.
\end_layout

\begin_layout Standard
Let us nevertheless briefly look at how Boolean logic would handle that
 reasoning.
 In the Boolean logic, each proposition (
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, ...) is either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 The operations are 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

 (conjunction), 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 (disjunction), and 
\begin_inset Formula $\neg\alpha$
\end_inset

 (negation).
 The 
\series bold
implication
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
implication (in logic)
\end_layout

\end_inset

 (
\begin_inset Formula $\Rightarrow$
\end_inset

) is defined through other operations by:
\begin_inset Formula 
\begin{equation}
\left(\alpha\Rightarrow\beta\right)\triangleq\left((\neg\alpha)\vee\beta\right)\quad.\label{eq:ch-definition-of-implication-in-Boolean-logic}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
To verify whether a formula is true in the Boolean logic, we can substitute
 either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

 into every variable and check if the formula has the value 
\begin_inset Formula $True$
\end_inset

 in all possible cases.
 The result can be arranged into a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
truth table
\end_layout

\end_inset

truth table.
 The formula is true if all values in its truth table are 
\begin_inset Formula $True$
\end_inset

.
\end_layout

\begin_layout Standard
Disjunction, conjunction, negation, and implication operations have the
 following truth table:
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\vee\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\neg\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Using this table, we find that the formula 
\begin_inset Formula $\alpha\Rightarrow\alpha$
\end_inset

 has the value 
\begin_inset Formula $True$
\end_inset

 in all cases, whether 
\begin_inset Formula $\alpha$
\end_inset

 itself is 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This check is sufficient to show that 
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset

 is true in Boolean logic.
\end_layout

\begin_layout Standard
Here is the truth table for the formulas 
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset

 and 
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset

.
 The first formula is true in Boolean logic since all values in its column
 are 
\begin_inset Formula $True$
\end_inset

, while the second formula is not true since one value in the last column
 is 
\begin_inset Formula $False$
\end_inset

:
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows more examples of logical formulas that are true in Boolean logic.
 Each formula is first written in terms of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions (we denote 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

 for brevity) and then as a Scala type signature of a function.
 So, all these type signatures 
\emph on
can
\emph default
 be implemented.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def id[A](x: A): A = x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,A\rightarrow\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def toUnit[A](x: A): Unit = ()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\vee\beta)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def toL[A, B](x: A): Either[A, B] = Left(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\times B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def first[A, B](p: (A, B)): A = p._1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\beta\Rightarrow\alpha)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\rightarrow(B\rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def const[A, B](x: A): B => A = (_ => x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of logical formulas that are true theorems in Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-formulas-Boolean-theorems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-not-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 some examples of formulas that are 
\emph on
not true
\emph default
 in Boolean logic.
 Translated into type formulas and then into Scala, these formulas yield
 type signatures that 
\emph on
cannot
\emph default
 be implemented by fully parametric functions.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala type signature
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,True\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,\bbnum 1\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A](x: Unit): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\vee\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A+B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](x: Either[A, B]): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\rightarrow A\times B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](p: A): (A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\Rightarrow\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,(A\rightarrow B)\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](x: A => B): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of logical formulas that are 
\emph on
not
\emph default
 true in Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-formulas-not-Boolean-theorems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At first sight, it may appear from these examples that whenever a logical
 formula is true in Boolean logic, the corresponding type signature can
 be implemented in code, and vice versa.
 However, this is 
\emph on
incorrect
\emph default
: the rules of Boolean logic are not fully suitable for reasoning about
 types in a functional language.
 We will now show some examples of formulas that are true in Boolean logic
 but correspond to unimplementable type signatures.
\end_layout

\begin_layout Standard
The first example is given by the following type:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\rightarrow B+C\right)\rightarrow\left(A\rightarrow B\right)+\left(A\rightarrow C\right)\quad,\label{eq:ch-example-boolean-bad-type}
\end{equation}

\end_inset

which corresponds to the Scala type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bad[A, B, C](g: A => Either[B, C]): Either[A => B, A => C] = ???
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 
\emph on
cannot
\emph default
 be implemented via fully parametric code.
 To see why, consider that the only available data is a function 
\begin_inset Formula $g^{:A\rightarrow B+C}$
\end_inset

, which returns values of type 
\begin_inset Formula $B$
\end_inset

 or 
\begin_inset Formula $C$
\end_inset

 depending (in some unknown way) on the input value of type 
\begin_inset Formula $A$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 must return either a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or a function of type 
\begin_inset Formula $A\rightarrow C$
\end_inset

.
 How can the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 make that decision? The only input data is the function 
\begin_inset Formula $g$
\end_inset

 that takes an argument of type 
\begin_inset Formula $A$
\end_inset

.
 We could imagine applying 
\begin_inset Formula $g$
\end_inset

 to various arguments of type 
\begin_inset Formula $A$
\end_inset

 and to see whether 
\begin_inset Formula $g$
\end_inset

 returns a 
\begin_inset Formula $B$
\end_inset

 or a 
\begin_inset Formula $C$
\end_inset

.
 However, the type 
\begin_inset Formula $A$
\end_inset

 is arbitrary, and a fully parametric function cannot produce a value of
 type 
\begin_inset Formula $A$
\end_inset

 in order to apply 
\begin_inset Formula $g$
\end_inset

 to it.
 So, the decision about whether to return 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\rightarrow C$
\end_inset

 must be independent of 
\begin_inset Formula $g$
\end_inset

.
 That decision must be hard-coded in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Suppose we hard-coded the decision to return a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 How would we create a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 in the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

? Given a value 
\begin_inset Formula $x^{:A}$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

, we would need to compute some value of type 
\begin_inset Formula $B$
\end_inset

.
 Since the type 
\begin_inset Formula $B$
\end_inset

 is arbitrary (it is a type parameter), we cannot produce a value of type
 
\begin_inset Formula $B$
\end_inset

 from scratch.
 The only potential source of values of type 
\begin_inset Formula $B$
\end_inset

 is the given function 
\begin_inset Formula $g$
\end_inset

.
 The only way of using 
\begin_inset Formula $g$
\end_inset

 is to apply it to 
\begin_inset Formula $x^{:A}$
\end_inset

.
 However, for some 
\begin_inset Formula $x$
\end_inset

, the value 
\begin_inset Formula $g(x)$
\end_inset

 may be of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 is of type 
\begin_inset Formula $C$
\end_inset

.
 In that case, we will have a value of type 
\begin_inset Formula $C$
\end_inset

, not 
\begin_inset Formula $B$
\end_inset

.
 So, in general, we cannot guarantee that we can always obtain a value of
 type 
\begin_inset Formula $B$
\end_inset

 from a given value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 This means we cannot build a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 out of the function 
\begin_inset Formula $g$
\end_inset

.
 Similarly, we cannot build a function of type 
\begin_inset Formula $A\rightarrow C$
\end_inset

 out of 
\begin_inset Formula $g$
\end_inset

.
 
\end_layout

\begin_layout Standard
Whether we decide to return 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\rightarrow C$
\end_inset

, we will not be able to return a value of the required type, as we just
 saw.
 We must conclude that we cannot implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 as a fully parametric function.
\end_layout

\begin_layout Standard
We could try to switch between 
\begin_inset Formula $A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $A\rightarrow C$
\end_inset

 depending on a given value of type 
\begin_inset Formula $A$
\end_inset

.
 This idea, however, means that we are working with a different type signature:
 
\begin_inset Formula 
\[
\forall(A,B,C).\,\left(A\rightarrow B+C\right)\rightarrow A\rightarrow\left(A\rightarrow B\right)+\left(A\rightarrow C\right)\quad.
\]

\end_inset

This type signature 
\emph on
can
\emph default
 be implemented, for instance, by this Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B, C](g: A => Either[B, C]): A => Either[A => B, A => C] = { a
 =>
\end_layout

\begin_layout Plain Layout

  g(a) match {
\end_layout

\begin_layout Plain Layout

    case Left(b) => Left(_ => b)
\end_layout

\begin_layout Plain Layout

    case Right(c) => Right(_ => c)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

But this is not the required type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-bad-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Now let us convert the type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-bad-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition:
\begin_inset Formula 
\begin{align}
 & \forall(\alpha,\beta,\gamma).\,\left(\alpha\Rightarrow\left(\beta\vee\gamma\right)\right)\Rightarrow\left(\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)\right)\quad,\label{eq:abc-example-classical-logic-bad}\\
\text{where we denoted}\quad & \alpha\triangleq{\cal CH}(A),\quad\beta\triangleq{\cal CH}(B),\quad\gamma\triangleq{\cal CH}(C)\quad.\nonumber 
\end{align}

\end_inset

It turns out that this formula is true in Boolean logic.
 To prove this, we need to show that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equal to 
\begin_inset Formula $True$
\end_inset

 for any Boolean values of the variables 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, 
\begin_inset Formula $\gamma$
\end_inset

.
 One way is to rewrite the expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) using the rules of Boolean logic, such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \gunderline{\alpha\Rightarrow}\left(\beta\vee\gamma\right)\\
\text{definition of }\Rightarrow\text{ via Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=(\neg\alpha)\vee\beta\vee\gamma\quad,\\
 & \gunderline{\left(\alpha\Rightarrow\beta\right)}\vee\gunderline{\left(\alpha\Rightarrow\gamma\right)}\\
\text{definition of }\Rightarrow\text{ via Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=\gunderline{(\neg\alpha)}\vee\beta\vee\gunderline{(\neg\alpha)}\vee\gamma\\
\text{property }x\vee x=x\text{ in Boolean logic}:\quad & \quad=(\neg\alpha)\vee\beta\vee\gamma\quad,
\end{align*}

\end_inset

showing that 
\begin_inset Formula $\alpha\Rightarrow(\beta\vee\gamma)$
\end_inset

 is in fact 
\emph on
equal
\emph default
 to 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)$
\end_inset

 in Boolean logic.
\end_layout

\begin_layout Standard
Let us also give a proof via truth-value reasoning.
 The only possibility for an implication 
\begin_inset Formula $X\Rightarrow Y$
\end_inset

 to be 
\begin_inset Formula $False$
\end_inset

 is when 
\begin_inset Formula $X=True$
\end_inset

 and 
\begin_inset Formula $Y=False$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be 
\begin_inset Formula $False$
\end_inset

 only if 
\begin_inset Formula $\left(\alpha\Rightarrow(\beta\vee\gamma)\right)=True$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)=False$
\end_inset

.
 A disjunction can be false only when both parts are false; so we must have
 both 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=False$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\gamma\right)=False$
\end_inset

.
 This is only possible if 
\begin_inset Formula $\alpha=True$
\end_inset

 and 
\begin_inset Formula $\beta=\gamma=False$
\end_inset

.
 But, with these value assignments, we find 
\begin_inset Formula $\left(\alpha\Rightarrow(\beta\vee\gamma)\right)=False$
\end_inset

 rather than 
\begin_inset Formula $True$
\end_inset

 as we assumed.
 It follows that we cannot ever make Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) equal to 
\begin_inset Formula $False$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is true in Boolean logic.
\end_layout

\begin_layout Section
Equivalence of types
\end_layout

\begin_layout Standard
We found a correspondence between types, code, logical propositions, and
 proofs, which is known as the 
\series bold
Curry-Howard correspondence
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

.
 An example of the CH correspondence is that a proof of the logical proposition:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).\,\alpha\Rightarrow\left(\beta\Rightarrow\alpha\right)\label{eq:ch-proposition-example-2}
\end{equation}

\end_inset

corresponds to the code of the following function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (B => A) = { x => _ => x }
\end_layout

\end_inset

With the CH correspondence in mind, we may say that the 
\emph on
existence
\emph default
 of the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => _ => x
\end_layout

\end_inset

 with the type 
\begin_inset Formula $A\rightarrow(B\rightarrow A)$
\end_inset

 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 a proof of the logical formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-proposition-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), because it shows how to compute a value of type 
\begin_inset Formula $\forall(A,B).\,A\rightarrow B\rightarrow A$
\end_inset

.
\end_layout

\begin_layout Standard
The Curry-Howard correspondence maps logic formulas such as 
\begin_inset Formula $(\alpha\vee\beta)\wedge\gamma$
\end_inset

 into type expressions such as 
\begin_inset Formula $\left(A+B\right)\times C$
\end_inset

.
 We have seen that types behave similarly to logic formulas in one respect:
 A logic formula is a true theorem of constructive logic when the corresponding
 type signature can be implemented as a fully parametric function, and vice
 versa.
\end_layout

\begin_layout Standard
It turns out that the similarity ends here.
 In other respects, type expressions behave as 
\emph on
arithmetic
\emph default
 expressions and not as logic formulas.
 For this reason, the type notation used in this book denotes disjunctive
 types by 
\begin_inset Formula $A+B$
\end_inset

 and tuples by 
\begin_inset Formula $A\times B$
\end_inset

, which is designed to remind us of arithmetic expressions (such as 
\begin_inset Formula $1+2$
\end_inset

 and 
\begin_inset Formula $2\times3$
\end_inset

) rather than of logical formulas (such as 
\begin_inset Formula $A\vee B$
\end_inset

 and 
\begin_inset Formula $A\wedge B$
\end_inset

).
 
\end_layout

\begin_layout Standard
An important use of the type notation is for writing equations with types.
 Can we use the arithmetic intuition for writing type equations such as:
\begin_inset Formula 
\begin{equation}
\left(A+B\right)\times C=A\times C+B\times C\quad?\label{eq:ch-example-distributive}
\end{equation}

\end_inset

In this section, we will learn how to check whether one type expression
 is equivalent to another.
\end_layout

\begin_layout Subsection
Logical identity does not correspond to type equivalence
\begin_inset CommandInset label
LatexCommand label
name "subsec:Logical-identity-not-type-equivalence"

\end_inset


\end_layout

\begin_layout Standard
The CH correspondence maps Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the logic formula:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\vee B\right)\wedge C=\left(A\wedge C\right)\vee\left(B\wedge C\right)\quad.\label{eq:ch-example-distributive-1}
\end{equation}

\end_inset

This formula is the well-known 
\begin_inset Quotes eld
\end_inset

distributive law
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Distributive_property#Rule_of_replacement"

\end_inset


\end_layout

\end_inset

 valid in Boolean logic as well as in the constructive logic.
 Since a logical equation 
\begin_inset Formula $P=Q$
\end_inset

 means 
\begin_inset Formula $P\Rightarrow Q$
\end_inset

 and 
\begin_inset Formula $Q\Rightarrow P$
\end_inset

, the distributive law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) means that the two formulas hold:
\begin_inset Formula 
\begin{align}
 & \forall(A,B,C).\,\left(A\vee B\right)\wedge C\Rightarrow\left(A\wedge C\right)\vee\left(B\wedge C\right)\quad,\label{eq:ch-example-distributive-1a}\\
 & \forall(A,B,C).\,\left(A\wedge C\right)\vee\left(B\wedge C\right)\Rightarrow\left(A\vee B\right)\wedge C\quad.\label{eq:ch-example-distributive-1b}
\end{align}

\end_inset

The CH correspondence maps these logical formulas to fully parametric functions
 with types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: ((Either[A, B], C))    => Either[(A, C), (B, C)] = ???
\end_layout

\begin_layout Plain Layout

def f2[A, B, C]: Either[(A, C), (B, C)] => (Either[A, B], C)      = ???
\end_layout

\end_inset

In the type notation, these type signatures are written as:
\begin_inset Formula 
\begin{align*}
 & f_{1}^{A,B,C}:\left(A+B\right)\times C\rightarrow A\times C+B\times C\quad,\\
 & f_{2}^{A,B,C}:A\times C+B\times C\rightarrow\left(A+B\right)\times C\quad.
\end{align*}

\end_inset

Since the two logical formulas (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1b"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are true theorems in constructive logic, we expect to be able to implement
 the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 It is not straightforward to guess how to combine the proof rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to obtain proofs of Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1b"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, instead of deriving the implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 from the CH correspondence, we will write the Scala code directly.
\end_layout

\begin_layout Standard
To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, we need to perform pattern matching on the argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: ((Either[A, B], C)) => Either[(A, C), (B, C)] = {
\end_layout

\begin_layout Plain Layout

  case (Left(a), c)   => Left((a, c))  // No other choice here.
\end_layout

\begin_layout Plain Layout

  case (Right(b), c)  => Right((b, c)) // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In both cases, we have only one possible expression of the correct type.
\end_layout

\begin_layout Standard
Similarly, the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 leaves us no choices:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "65col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B, C]: Either[(A, C), (B, C)] => (Either[A, B], C) = {
\end_layout

\begin_layout Plain Layout

  case Left((a, c))   => (Left(a), c)  // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right((b, c))  => (Right(b), c) // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 never discards any given values; in other words, these functions appear
 to preserve information.
 We can formulate this property rigorously as a requirement that an arbitrary
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: (Either[A, B], C)
\end_layout

\end_inset

 be mapped by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 to some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: Either[(A, C), (B, C)]
\end_layout

\end_inset

 and then mapped by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 back to 
\emph on
the same
\emph default
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 Similarly, any value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

y
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, C), (B, C)]
\end_layout

\end_inset

 should be transformed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 and then by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 back to the same value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us write these conditions as equations:
\begin_inset Formula 
\[
\forall x^{:(A+B)\times C}.\,f_{2}(f_{1}(x))=x\quad,\quad\quad\forall y^{:A\times C+B\times C}.\,f_{1}\left(f_{2}(y)\right)=y\quad.
\]

\end_inset

If these equations hold, it means that all the information in a value 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 is completely preserved inside the value 
\begin_inset Formula $y\triangleq f_{1}(x)$
\end_inset

; the original value 
\begin_inset Formula $x$
\end_inset

 can be recovered as 
\begin_inset Formula $x=f_{2}(y)$
\end_inset

.
 Then the function 
\begin_inset Formula $f_{1}$
\end_inset

 is the 
\series bold
inverse
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
inverse function
\end_layout

\end_inset

 of 
\begin_inset Formula $f_{2}$
\end_inset

.
 Conversely, all the information in a value 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

 is preserved inside 
\begin_inset Formula $x\triangleq f_{2}(y)$
\end_inset

 and can be recovered by applying 
\begin_inset Formula $f_{1}$
\end_inset

.
 Since the values 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 and 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

 are arbitrary, it will follow that the 
\emph on
data types
\emph default
 themselves, 
\begin_inset Formula $\left(A+B\right)\times C$
\end_inset

 and 
\begin_inset Formula $A\times C+B\times C$
\end_inset

, carry equivalent information.
 Such types are called equivalent
\begin_inset Index idx
status open

\begin_layout Plain Layout
types!equivalent
\end_layout

\end_inset

 or isomorphic
\begin_inset Index idx
status open

\begin_layout Plain Layout
types!isomorphic
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
isomorphic types
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Generally, we say that types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are 
\series bold
equivalent
\series default
 or 
\series bold
isomorphic
\series default
 (denoted 
\begin_inset Formula $P\cong Q$
\end_inset

) 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence
\end_layout

\end_inset

when there exist functions 
\begin_inset Formula $f_{1}:P\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $f_{2}:Q\rightarrow P$
\end_inset

 that are inverses of each other.
 We can write these conditions using the notation 
\begin_inset Formula $(f_{1}\bef f_{2})(x)\triangleq f_{2}(f_{1}(x))$
\end_inset

 as:
\begin_inset Formula 
\[
f_{1}\bef f_{2}=\text{id}\quad,\quad\quad f_{2}\bef f_{1}=\text{id}\quad.
\]

\end_inset

(In Scala, the forward composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 is the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

.
 We omit type annotations since we already checked that the types match.)
 If these conditions hold, there is a one-to-one correspondence between
 values of types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 This is the same as to say that the data types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 
\begin_inset Quotes eld
\end_inset

carry equivalent information
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
To verify that the Scala functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 defined above are inverses of each other, we first check if 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

.
 Applying 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 means to apply 
\begin_inset Formula $f_{1}$
\end_inset

 and then to apply 
\begin_inset Formula $f_{2}$
\end_inset

 to the result.
 Begin by applying 
\begin_inset Formula $f_{1}$
\end_inset

 to an arbitrary value 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

.
 A value 
\begin_inset Formula $x$
\end_inset

 of that type can be in only one of the two disjoint cases: a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 or a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

, for some values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c:C
\end_layout

\end_inset

.
 The Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 maps these tuples to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 and to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

 respectively; we can see this directly from the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

.
 We then apply 
\begin_inset Formula $f_{2}$
\end_inset

 to those values, which maps them back to a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 or to a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 respectively, according to the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 These tuples are exactly the value 
\begin_inset Formula $x$
\end_inset

 we started with.
 So, applying 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 to an arbitrary 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 returns that value 
\begin_inset Formula $x$
\end_inset

.
 This is the same as to say that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To check whether 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

, we apply 
\begin_inset Formula $f_{2}$
\end_inset

 to an arbitrary value 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

, which must be one of the two disjoint cases, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 maps these two cases into tuples 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 respectively.
 Then we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and map these tuples back to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

 respectively.
 It follows that applying 
\begin_inset Formula $f_{2}$
\end_inset

 and then 
\begin_inset Formula $f_{1}$
\end_inset

 will always return the initial value.
 As a formula, this is written as 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
By looking at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we can directly observe that these functions are inverses of each other:
 the tuple pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 is mapped to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

, and the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

, or vice versa.
 It is visually clear that no information is lost and that the original
 values are returned by function compositions 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 or 
\begin_inset Formula $f_{2}\bef f_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
We find that the logical identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to an equivalence of the corresponding types:
\begin_inset Formula 
\begin{equation}
\left(A+B\right)\times C\cong A\times C+B\times C\quad.\label{eq:ch-distributive-law-types}
\end{equation}

\end_inset

To get Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-distributive-law-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to convert a logical formula to an arithmetic expression by replacing
 the disjunction operations 
\begin_inset Formula $\vee$
\end_inset

 by 
\begin_inset Formula $+$
\end_inset

 and the conjunctions 
\begin_inset Formula $\wedge$
\end_inset

 by 
\begin_inset Formula $\times$
\end_inset

 everywhere.
\end_layout

\begin_layout Standard
As another example of a logical identity, consider the associativity law
 for conjunction:
\begin_inset Formula 
\begin{equation}
\left(\alpha\wedge\beta\right)\wedge\gamma=\alpha\wedge\left(\beta\wedge\gamma\right)\quad.\label{eq:ch-example-associativity-conjunction}
\end{equation}

\end_inset

The corresponding types are 
\begin_inset Formula $(A\times B)\times C$
\end_inset

 and 
\begin_inset Formula $A\times(B\times C)$
\end_inset

; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B), C)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, (B, C))
\end_layout

\end_inset

.
 We can define functions that convert between these types without information
 loss
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f3[A, B, C]: (((A, B), C)) => (A, (B, C)) = { case ((a, b), c) => (a,
 (b, c)) }
\end_layout

\begin_layout Plain Layout

def f4[A, B, C]: (A, (B, C)) => (((A, B), C)) = { case (a, (b, c)) => ((a,
 b), c) }
\end_layout

\end_inset

By applying these functions to arbitrary values of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B), C)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, (B, C))
\end_layout

\end_inset

, it is easy to see that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f4
\end_layout

\end_inset

 are inverses of each other.
 This is also directly visible in the code: the nested tuple pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((a, b), c)
\end_layout

\end_inset

 is mapped to the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, (b, c))
\end_layout

\end_inset

 and back.
 So, the types 
\begin_inset Formula $\left(A\times B\right)\times C$
\end_inset

 and 
\begin_inset Formula $A\times\left(B\times C\right)$
\end_inset

 are equivalent, and we can write 
\begin_inset Formula $A\times B\times C$
\end_inset

 without parentheses.
\end_layout

\begin_layout Standard
Does a logical identity always correspond to an equivalence of types? This
 turns out to be 
\emph on
not
\emph default
 so.
 A simple example of a logical identity that does not correspond to a type
 equivalence is:
\begin_inset Formula 
\begin{equation}
True\vee\alpha=True\quad.\label{eq:ch-example-logic-identity-2}
\end{equation}

\end_inset

Since the CH correspondence maps the logical constant 
\begin_inset Formula $True$
\end_inset

 into the unit type 
\begin_inset Formula $\bbnum 1$
\end_inset

, the type equivalence corresponding to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-logic-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\begin_inset Formula $\bbnum 1+A\cong\bbnum 1$
\end_inset

.
 The type denoted by 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 in Scala, so the corresponding equivalence is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset


\begin_inset Formula $\cong$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 Intuitively, this type equivalence should not hold: an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 may carry a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, which cannot possibly be stored in a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 We can verify this intuition rigorously by proving that any fully parametric
 functions with type signatures 
\begin_inset Formula $g_{1}:\bbnum 1+A\rightarrow\bbnum 1$
\end_inset

 and 
\begin_inset Formula $g_{2}:\bbnum 1\rightarrow\bbnum 1+A$
\end_inset

 will not satisfy 
\begin_inset Formula $g_{1}\bef g_{2}=\text{id}$
\end_inset

.
 To verify this, we note that 
\begin_inset Formula $g_{2}:\bbnum 1\rightarrow\bbnum 1+A$
\end_inset

 must have this type signature:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g2[A]: Unit => Option[A] = ???
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This function must always return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, since a fully parametric function cannot produce values of an arbitrary
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 from scratch.
 Therefore, 
\begin_inset Formula $g_{1}\bef g_{2}$
\end_inset

 is also a function that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 The function 
\begin_inset Formula $g_{1}\bef g_{2}$
\end_inset

 has type signature 
\begin_inset Formula $\bbnum 1+A\rightarrow\bbnum 1+A$
\end_inset

 or, in Scala syntax, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[A]
\end_layout

\end_inset

, and is not equal to the identity function, because the identity function
 does 
\emph on
not
\emph default
 always return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Another example of a logical identity without a type equivalence is the
 distributive law:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\wedge B\right)\vee C=\left(A\vee C\right)\wedge\left(B\vee C\right)\quad,\label{eq:ch-example-distributive-2}
\end{equation}

\end_inset

which is 
\begin_inset Quotes eld
\end_inset

dual
\begin_inset Quotes erd
\end_inset

 to the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), i.e., it is obtained from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by swapping all conjunctions (
\begin_inset Formula $\wedge$
\end_inset

) with disjunctions (
\begin_inset Formula $\vee$
\end_inset

).
 In logic, a dual formula to an identity is also an identity.
 The CH correspondence maps Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the type equation:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\times B\right)+C=\left(A+C\right)\times\left(B+C\right)\quad.\label{eq:ch-example-incorrect-identity-2}
\end{equation}

\end_inset

However, the types 
\begin_inset Formula $A\times B+C$
\end_inset

 and 
\begin_inset Formula $\left(A+C\right)\times\left(B+C\right)$
\end_inset

 are 
\emph on
not
\emph default
 equivalent.
 To see why, look at the possible code of a function 
\begin_inset Formula $g_{3}:\left(A+C\right)\times\left(B+C\right)\rightarrow A\times B+C$
\end_inset

:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def g3[A,B,C]: ((Either[A, C], Either[B, C])) => Either[(A, B), C] = {
\end_layout

\begin_layout Plain Layout

  case (Left(a), Left(b))      => Left((a, b)) // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(c))     => Right(c)     // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Right(c), Left(b))     => Right(c)     // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Right(c1), Right(c2))  => Right(c1)    // Must discard c1 or c2
 here!
\end_layout

\begin_layout Plain Layout

}   // May return Right(c2) instead of Right(c1) in the last line.
\end_layout

\end_inset

In line 5, we have a choice of returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c1)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c2)
\end_layout

\end_inset

.
 Whichever we choose, we will lose information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 because we will have discarded one of the given values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c2
\end_layout

\end_inset

.
 After evaluating 
\begin_inset Formula $g_{3}$
\end_inset

, we will not be able to restore 
\emph on
both
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c2
\end_layout

\end_inset

, no matter what code we write.
 So, the composition 
\begin_inset Formula $g_{3}\bef g_{4}$
\end_inset

 with any 
\begin_inset Formula $g_{4}$
\end_inset

 cannot be equal to the identity function.
 The type equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-incorrect-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is incorrect.
\end_layout

\begin_layout Standard
We find that a logical identity 
\begin_inset Formula ${\cal CH}(P)={\cal CH}(Q)$
\end_inset

 guarantees, via the CH correspondence, that we can implement 
\emph on
some
\emph default
 fully parametric functions of types 
\begin_inset Formula $P\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $Q\rightarrow P$
\end_inset

.
 However, it is not guaranteed that these functions are inverses of each
 other, i.e., that the type conversions 
\begin_inset Formula $P\rightarrow Q$
\end_inset

 or 
\begin_inset Formula $Q\rightarrow P$
\end_inset

 have no information loss
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

.
 So, the type equivalence 
\begin_inset Formula $P\cong Q$
\end_inset

 does not automatically follow from the logical identity 
\begin_inset Formula ${\cal CH}(P)={\cal CH}(Q)$
\end_inset

.
\end_layout

\begin_layout Standard
The CH correspondence means that for true propositions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

 we can compute 
\emph on
some
\emph default
 value 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $X$
\end_inset

.
 However, the CH correspondence does not guarantee that the computed value
 
\begin_inset Formula $x^{:X}$
\end_inset

 will satisfy any additional properties or laws.
\end_layout

\begin_layout Subsection
Arithmetic identity corresponds to type equivalence
\end_layout

\begin_layout Standard
Looking at the examples of equivalent types, we notice that correct type
 equivalences correspond to 
\emph on
arithmetical
\emph default
 identities rather than 
\emph on
logical
\emph default
 identities.
 For instance, the logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to the type equivalence
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-distributive-law-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which looks like a standard identity of arithmetic, such as:
\begin_inset Formula 
\[
(1+10)\times20=1\times20+10\times20\quad.
\]

\end_inset

The logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which does 
\emph on
not
\emph default
 yield a type equivalence, leads to an incorrect arithmetic equation
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-incorrect-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, e.g., 
\begin_inset Formula $\left(1\times10\right)+20\neq\left(1+20\right)\times\left(10+20\right)$
\end_inset

.
 Similarly, the associativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-associativity-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to a type equivalence and to the arithmetic identity:
\begin_inset Formula 
\[
\left(a\times b\right)\times c=a\times\left(b\times c\right)\quad,
\]

\end_inset

The logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-logic-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which does not yield a type equivalence, leads to an incorrect arithmetic
 statement (
\begin_inset Formula $\forall a.\,1+a=1$
\end_inset

).
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes these and other examples of logical identities and the corresponding
 type equivalences.
 In all rows, quantifiers such as 
\begin_inset Formula $\forall\alpha$
\end_inset

 or 
\begin_inset Formula $\forall(A,B)$
\end_inset

 are implied as necessary.
\end_layout

\begin_layout Standard
Because we chose the type notation to be similar to the ordinary arithmetic
 notation, it is easy to translate a possible type equivalence into an arithmeti
c equation.
 In all cases, valid arithmetic identities correspond to type equivalences,
 and failures to obtain a type equivalence correspond to incorrect arithmetic
 identities.
 With regard to type equivalence, types such as 
\begin_inset Formula $A+B$
\end_inset

 and 
\begin_inset Formula $A\times B$
\end_inset

 behave similarly to arithmetic expressions such as 
\begin_inset Formula $10+20$
\end_inset

 and 
\begin_inset Formula $10\times20$
\end_inset

 and not similarly to logical formulas such as 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 and 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logical identity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type equivalence (if it holds)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True\vee\alpha=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+A\not\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True\wedge\alpha=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1\times A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False\vee\alpha=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False\wedge\alpha=False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\vee\beta=\beta\vee\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A+B\cong B+A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\wedge\beta=\beta\wedge\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times B\cong B\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\vee\gamma=\alpha\vee\left(\beta\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\wedge\beta\right)\wedge\gamma=\alpha\wedge\left(\beta\wedge\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A\times B\right)\times C\cong A\times\left(B\times C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\wedge\gamma=\left(\alpha\wedge\gamma\right)\vee\left(\beta\wedge\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A+B\right)\times C\cong A\times C+B\times C$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\wedge\beta\right)\vee\gamma=\left(\alpha\vee\gamma\right)\wedge\left(\beta\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A\times B\right)+C\not\cong\left(A+C\right)\times\left(B+C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logic identities with disjunction and conjunction, and the possible type
 equivalences.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-identities-with-disjunction-and-conjunction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We already verified the first line and the last three lines of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Other identities are verified in a similar way.
 Let us begin with lines 3 and 4 of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which involve the proposition 
\begin_inset Formula $False$
\end_inset

 and the corresponding 
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

void type 
\begin_inset Formula $\bbnum 0$
\end_inset

 (Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

).
 Reasoning about the void type needs a special technique that we will now
 develop while verifying the type isomorphisms 
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset

 and 
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-0-times-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-0-times-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 0\times A$
\end_inset

 represents the Scala tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

.
 To demonstrate that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 is equivalent to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, we need to show that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 has 
\emph on
no
\emph default
 values.
 Indeed, how could we create a value of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, Int)
\end_layout

\end_inset

? We would need to fill 
\emph on
both
\emph default
 parts of the tuple.
 We have values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, but we can never get a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 So, regardless of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, it is impossible to create any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

.
 In other words, the set of values of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 is empty.
 But that is the definition of the void type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 The types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 0\times A$
\end_inset

) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 0$
\end_inset

) are both void and therefore equivalent.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-0-plus-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-0-plus-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 represents the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

.
 We need to show that any value of that type can be mapped without loss
 of information to a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and vice versa.
 This means implementing functions 
\begin_inset Formula $f_{1}:\bbnum 0+A\rightarrow A$
\end_inset

 and 
\begin_inset Formula $f_{2}:A\rightarrow\bbnum 0+A$
\end_inset

 such that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
The argument of 
\begin_inset Formula $f_{1}$
\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

.
 How can we create a value of that type? Our only choices are to create
 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Nothing
\end_layout

\end_inset

, or to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:A
\end_layout

\end_inset

.
 However, we cannot create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 because the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has 
\emph on
no
\emph default
 values.
 We cannot create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

.
 The only remaining possibility is to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, any values of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 must be of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

, and we can extract that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Either[Nothing, A] => A = {
\end_layout

\begin_layout Plain Layout

  case Right(y) => y
\end_layout

\begin_layout Plain Layout

  // No need for `case Left(x) => ...` since no `x` can ever be given as `Left(x)`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

For the same reason, there is only one implementation of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A]: A => Either[Nothing, A] = { y => Right(y) }
\end_layout

\end_inset

It is clear from the code that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
\end_layout

\begin_layout Standard
We have just seen that a value of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 is always a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:A
\end_layout

\end_inset

.
 Similarly, a value of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 is always a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 So, we will use the notation 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 to 
\emph on
denote
\emph default
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 parts of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

.
 This notation agrees with the behavior of the Scala compiler, which will
 infer the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Nothing] 
\end_layout

\end_inset

or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

 for these parts:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "53col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toLeft[A, B]: A => Either[A, B] = x => Left(x)
\end_layout

\begin_layout Plain Layout

def toRight[A, B]: B => Either[A, B] = y => Right(y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toLeft(123)
\end_layout

\begin_layout Plain Layout

res0: Either[Int, Nothing] = Left(123)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toRight(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res1: Either[Nothing, String] = Right("abc")
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -200baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We can write the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toRight
\end_layout

\end_inset

 in a code notation as:
\begin_inset Formula 
\begin{align*}
 & \text{toLeft}^{A,B}\triangleq x^{:A}\rightarrow x+\bbnum 0^{:B}\quad,\\
 & \text{toRight}^{A,B}\triangleq y^{:B}\rightarrow\bbnum 0^{:A}+y\quad.
\end{align*}

\end_inset

In this notation, a value of the disjunctive type is shown without using
 Scala class names such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

.
 This shortens the writing and speeds up code reasoning.
 
\end_layout

\begin_layout Standard
The type annotation 
\begin_inset Formula $\bbnum 0^{:A}$
\end_inset

 is helpful to remind ourselves about the type parameter 
\begin_inset Formula $A$
\end_inset

 used, e.g., by the disjunctive value 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset

 in the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toRight[A, B]
\end_layout

\end_inset

.
 Without this type annotation, 
\begin_inset Formula $\bbnum 0+y^{:B}$
\end_inset

 means a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 where the parameter 
\begin_inset Formula $A$
\end_inset

 should be determined by matching the types of other expressions.
 When it is clear what types are being used, we may omit type annotations
 and write simply 
\begin_inset Formula $\bbnum 0+y$
\end_inset

 instead of 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset

.
\end_layout

\begin_layout Standard
In the notation 
\begin_inset Formula $\bbnum 0+y^{:B}$
\end_inset

, we use the symbol 
\begin_inset Formula $\bbnum 0$
\end_inset

 rather than an ordinary zero (
\begin_inset Formula $0$
\end_inset

), to avoid suggesting that 
\begin_inset Formula $0$
\end_inset

 is a value of type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 The void type 
\begin_inset Formula $\bbnum 0$
\end_inset

 has 
\emph on
no
\emph default
 values, unlike the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, 
\begin_inset Formula $\bbnum 1$
\end_inset

, which has a value denoted by 
\begin_inset Formula $1$
\end_inset

 in the code notation.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-1xA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-1xA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\times\bbnum 1\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The corresponding Scala types are the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, Unit)
\end_layout

\end_inset

 and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 We need to implement functions 
\begin_inset Formula $f_{1}:\forall A.\,A\times\bbnum 1\rightarrow A$
\end_inset

 and 
\begin_inset Formula $f_{2}:\forall A.\,A\rightarrow A\times\bbnum 1$
\end_inset

 and to demonstrate that they are inverses of each other.
 The Scala code for these functions is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: ((A, Unit)) => A = { case (a, ()) => a }
\end_layout

\begin_layout Plain Layout

def f2[A]: A => (A, Unit) = { a => (a, ()) }
\end_layout

\end_inset

Let us first write a proof by reasoning directly with Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(f1 andThen f2)((a,())) == f2(f1((a,())) == f2(a) == (a, ())
\end_layout

\begin_layout Plain Layout

(f2 andThen f1)(a) == f1(f2(a)) == f1((a, ())) = a
\end_layout

\end_inset

Now let us write a proof in the code notation.
 The codes of 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are:
\begin_inset Formula 
\[
f_{1}\triangleq a^{:A}\times1\rightarrow a\quad,\quad\quad f_{2}\triangleq a^{:A}\rightarrow a\times1\quad,
\]

\end_inset

where we denoted by 
\begin_inset Formula $1$
\end_inset

 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
 We find:
\begin_inset Formula 
\begin{align*}
(f_{1}\bef f_{2})(a^{:A}\times1) & =f_{2}\left(f_{1}(a\times1)\right)=f_{2}\left(a\right)=a\times1\quad,\\
(f_{2}\bef f_{1})(a^{:A}) & =f_{1}(f_{2}(a))=f_{1}(a\times1)=a\quad.
\end{align*}

\end_inset

This shows that both compositions are identity functions.
 Another way of writing the proof is by computing the function compositions
 symbolically, without applying to a value 
\begin_inset Formula $a^{:A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(a\times1\rightarrow a\right)\bef\left(a\rightarrow a\times1\right)=\left(a\times1\rightarrow a\times1\right)=\text{id}^{A\times\bbnum 1}\quad,\\
f_{2}\bef f_{1} & =\left(a\rightarrow a\times1\right)\bef\left(a\times1\rightarrow a\right)=\left(a\rightarrow a\right)=\text{id}^{A}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-A+B"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-A+B"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A+B\cong B+A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The corresponding Scala types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[B, A]
\end_layout

\end_inset

.
 We use pattern matching to implement the functions required for the type
 equivalence:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "55col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -86baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Either[A, B] => Either[B, A] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Right(a) // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Left(b)  // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A, B]: Either[B, A] => Either[A, B] = f1[B, A]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\end_inset

The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are implemented by code that can be derived unambiguously from the type
 signatures.
 For instance, the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Left(a) => ...
\end_layout

\end_inset

 is required to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[B, A]
\end_layout

\end_inset

 by using a given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 The only way of doing that is by returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is clear from the code that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 To verify that rigorously, we need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

 is equal to an identity function.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

 applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 contains two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case ...
\end_layout

\end_inset

 lines, each returning a result.
 So, we need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 separately in each line.
 Evaluate the code symbolically:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(f1 andThen f2) == {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => f2(Right(a))
\end_layout

\begin_layout Plain Layout

  case Right(b)   => f2(Left(b))
\end_layout

\begin_layout Plain Layout

} == {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Left(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Right(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The result is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B] => Either[A, B]
\end_layout

\end_inset

 that does not change its argument; so, it is equal to the identity function.
 
\end_layout

\begin_layout Standard
Let us now write the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 in the code notation and perform the same derivation.
 We will also develop a useful notation for functions operating on disjunctive
 types.
\end_layout

\begin_layout Standard
The pattern matching construction in the Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 is similar to a pair of functions with types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Either[B, A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => Either[B, A]
\end_layout

\end_inset

.
 One of these functions is applied depending on whether the argument of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 has type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+B$
\end_inset

.
 So, we may write the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
f_{1}\triangleq x^{:A+B}\rightarrow\begin{cases}
\text{if }x=a^{:A}+\bbnum 0^{:B}\quad: & \bbnum 0^{:B}+a^{:A}\\
\text{if }x=\bbnum 0^{:A}+b^{:B}\quad: & b^{:B}+\bbnum 0^{:A}
\end{cases}
\]

\end_inset

Since both the argument and the result of 
\begin_inset Formula $f_{1}$
\end_inset

 are disjunctive types with 
\begin_inset Formula $2$
\end_inset

 parts each, it is convenient to write the code of 
\begin_inset Formula $f_{1}$
\end_inset

 as a 
\begin_inset Formula $2\times2$
\end_inset

 
\emph on
matrix
\emph default
 that maps the input parts to the output parts:
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type!in matrix notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
matrix notation
\end_layout

\end_inset


\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Either[A, B] => Either[B, A] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Right(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Left(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -200baselineskip%
\end_inset


\end_layout

\end_inset


\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset Formula 
\[
f_{1}\triangleq\,\begin{array}{|c||cc|}
 & B & A\\
\hline A & \bbnum 0 & a^{:A}\rightarrow a\\
B & b^{:B}\rightarrow b & \bbnum 0
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Standard
The rows of the matrix correspond to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 rows in the Scala code.
 There is one row for each part of the disjunctive type of the argument.
 The columns of the matrix correspond to the parts of the disjunctive type
 of the result.
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching!in matrix notation
\end_layout

\end_inset

 The double line shows where the argument types are.
\end_layout

\begin_layout Standard
The code of 
\begin_inset Formula $f_{2}$
\end_inset

 is written similarly.
 Let us rename arguments for clarity:
\begin_inset space \hfill{}
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Wrap figure
lines 4
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: Either[B, A] => Either[A, B] = {
\end_layout

\begin_layout Plain Layout

  case Left(y)    => Right(y)
\end_layout

\begin_layout Plain Layout

  case Right(x)   => Left(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace -150baselineskip%
\end_inset


\begin_inset Formula 
\[
f_{2}\triangleq\,\begin{array}{|c||cc|}
 & A & B\\
\hline B & \bbnum 0 & y^{:B}\rightarrow y\\
A & x^{:A}\rightarrow x & \bbnum 0
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
The forward composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 is computed by the standard rules of row-by-column matrix multiplication.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Matrix_multiplication"

\end_inset


\end_layout

\end_inset

 Any terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

 are omitted, and the remaining functions are composed:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\,\begin{array}{|c||cc|}
 & B & A\\
\hline A & \bbnum 0 & a^{:A}\rightarrow a\\
B & b^{:B}\rightarrow b & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & B\\
\hline B & \bbnum 0 & y^{:B}\rightarrow y\\
A & x^{:A}\rightarrow x & \bbnum 0
\end{array}\\
\text{matrix multiplication/composition}:\quad & =\,\,\begin{array}{|c||cc|}
 & A & B\\
\hline A & (a^{:A}\rightarrow a)\bef(x^{:A}\rightarrow x) & \bbnum 0\\
B & \bbnum 0 & (b^{:B}\rightarrow b)\bef(y^{:B}\rightarrow y)
\end{array}\\
\text{function composition}:\quad & =\,\begin{array}{|c||cc|}
 & A & B\\
\hline A & \text{id} & \bbnum 0\\
B & \bbnum 0 & \text{id}
\end{array}\,=\text{id}^{:A+B\rightarrow A+B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Several features of the matrix notation are helpful in such calculations.
 The parts of the code of 
\begin_inset Formula $f_{1}$
\end_inset

 are automatically composed with the corresponding parts of the code of
 
\begin_inset Formula $f_{2}$
\end_inset

.
 To check that the types match in the function composition, we just need
 to compare the types in the output row 
\begin_inset Formula $\,\begin{array}{||cc|}
B & A\end{array}\,$
\end_inset

 of 
\begin_inset Formula $f_{1}$
\end_inset

 with the input column 
\begin_inset Formula $\,\begin{array}{|c||}
B\\
A
\end{array}\,$
\end_inset

 of 
\begin_inset Formula $f_{2}$
\end_inset

.
 Once we verified that all types match, we may omit the type annotations
 and write the same derivation more concisely as:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\,\begin{array}{||cc|}
\bbnum 0 & a^{:A}\rightarrow a\\
b^{:B}\rightarrow b & \bbnum 0
\end{array}\,\bef\,\begin{array}{||cc|}
\bbnum 0 & y^{:B}\rightarrow y\\
x^{:A}\rightarrow x & \bbnum 0
\end{array}\\
\text{matrix multiplication/composition}:\quad & =\,\,\begin{array}{||cc|}
(a^{:A}\rightarrow a)\bef(x^{:A}\rightarrow x) & \bbnum 0\\
\bbnum 0 & (b^{:B}\rightarrow b)\bef(y^{:B}\rightarrow y)
\end{array}\\
\text{function composition}:\quad & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset

The identity function is represented by the diagonal matrix: 
\begin_inset Formula $\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}$
\end_inset


\begin_inset space ~
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-AxB"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-AxB"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\times B\cong B\times A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-A+B+C"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-A+B+C"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset

.
 Since Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Logical-identity-not-type-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

 proved the equivalences 
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset

 and 
\begin_inset Formula $\left(A\times B\right)\times C\cong A\times\left(B\times C\right)$
\end_inset

, we may write 
\begin_inset Formula $A+B+C$
\end_inset

 and 
\begin_inset Formula $A\times B\times C$
\end_inset

 without any parentheses.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-A+B2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-A+B2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence:
\begin_inset Formula 
\[
\left(A+B\right)\times\left(A+B\right)=A\times A+\bbnum 2\times A\times B+B\times B\quad,
\]

\end_inset

where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type
\begin_inset Index idx
status open

\begin_layout Plain Layout
2@
\begin_inset Formula $\bbnum 2$
\end_inset

 (the 
\family typewriter
Boolean
\family default
 type)
\end_layout

\end_inset

 (which may be defined as 
\begin_inset Formula $\bbnum 2\triangleq\bbnum 1+\bbnum 1$
\end_inset

).
\end_layout

\begin_layout Subsection
Type cardinalities and type equivalence
\end_layout

\begin_layout Standard
To understand why type equivalences are related to arithmetic identities,
 consider the question of how many different values a given type can have.
\end_layout

\begin_layout Standard
Begin by counting the number of distinct values for simple types.
 For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has only one distinct value; the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has zero values; the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type has two distinct values (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

); and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 has 
\begin_inset Formula $2^{32}$
\end_inset

 distinct values.
\end_layout

\begin_layout Standard
It is more difficult to count the number of distinct values in a type such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, which is equivalent to a list of unknown length, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Char]
\end_layout

\end_inset

.
 However, each computer's memory is limited, so there will exist a maximum
 length for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 So, the total number of possible different strings will be finite (but
 will depend on the computer).
\end_layout

\begin_layout Standard
For a given type 
\begin_inset Formula $A$
\end_inset

, let us denote by 
\begin_inset Formula $\left|A\right|$
\end_inset

 the number of distinct values of type 
\begin_inset Formula $A$
\end_inset

.
 The number 
\begin_inset Formula $\left|A\right|$
\end_inset

 is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
cardinality
\end_layout

\end_inset


\series bold
cardinality
\series default
 of type 
\begin_inset Formula $A$
\end_inset

.
 This is the same as the number of elements in the set of all values of
 type 
\begin_inset Formula $A$
\end_inset

.
 Since any computer's memory is finite, there will be 
\emph on
finitely
\emph default
 many different values of a given type 
\begin_inset Formula $A$
\end_inset

 that can exist in the computer.
 So, we may assume that 
\begin_inset Formula $\left|A\right|$
\end_inset

 is always a finite integer value.
 This assumption will simplify our reasoning.
 We will not actually need to compute the precise number of, say, all the
 different possible strings.
 It is sufficient to know that the set of all strings is finite, so that
 we can denote its cardinality by 
\begin_inset Formula $|\text{String}|$
\end_inset

.
\end_layout

\begin_layout Standard
The next step is to consider the cardinality of types such as 
\begin_inset Formula $A\times B$
\end_inset

 and 
\begin_inset Formula $A+B$
\end_inset

.
 If the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have cardinalities 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

, it follows that the set of all distinct pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 has 
\begin_inset Formula $\left|A\right|\times\left|B\right|$
\end_inset

 elements.
 So, the cardinality of the type 
\begin_inset Formula $A\times B$
\end_inset

 is equal to the (arithmetic) product of the cardinalities of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 The set of all pairs, denoted in mathematics by:
\begin_inset Formula 
\[
\left\{ (a,b)|a\in A,b\in B\right\} \quad,
\]

\end_inset

is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cartesian product
\end_layout

\end_inset


\series bold
Cartesian product
\series default
 of sets 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, and is denoted by 
\begin_inset Formula $A\times B$
\end_inset

.
 For this reason, the tuple type is also called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product type
\end_layout

\end_inset


\series bold
product type
\series default
.
 Accordingly, the type notation adopts the symbol 
\begin_inset Formula $\times$
\end_inset

 for the product type.
\end_layout

\begin_layout Standard
The set of all distinct values of the type 
\begin_inset Formula $A+B$
\end_inset

, i.e., of the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, is a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
labeled union
\end_layout

\end_inset

labeled union of the set of values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 and the set of values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(b)
\end_layout

\end_inset

.
 It is clear that the cardinalities of these two sets are equal to 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

 respectively.
 So, the cardinality of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is equal to 
\begin_inset Formula $\left|A\right|+\left|B\right|$
\end_inset

.
 For this reason, disjunctive types are also called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
sum type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\series bold
sum types
\series default
, and the type notation adopts the symbol 
\begin_inset Formula $+$
\end_inset

 for these types.
\end_layout

\begin_layout Standard
We can write our conclusions as:
\begin_inset Formula 
\begin{align*}
\left|A\times B\right| & =\left|A\right|\times\left|B\right|\quad,\\
\left|A+B\right| & =\left|A\right|+\left|B\right|\quad.
\end{align*}

\end_inset

The type notation, 
\begin_inset Formula $A\times B$
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset

 and 
\begin_inset Formula $A+B$
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, translates directly into type cardinalities.
\end_layout

\begin_layout Standard
The last step is to notice that two types can be equivalent, 
\begin_inset Formula $P\cong Q$
\end_inset

, only if their cardinalities are equal, 
\begin_inset Formula $\left|P\right|=\left|Q\right|$
\end_inset

.
 When the cardinalities are not equal, 
\begin_inset Formula $\left|P\right|\neq\left|Q\right|$
\end_inset

, it will be impossible to have a one-to-one correspondence between the
 sets of values of type 
\begin_inset Formula $P$
\end_inset

 and values of type 
\begin_inset Formula $Q$
\end_inset

.
 So, it will be impossible to convert values from type 
\begin_inset Formula $P$
\end_inset

 to type 
\begin_inset Formula $Q$
\end_inset

 and back without loss of information.
\end_layout

\begin_layout Standard
We conclude that types are equivalent when a logical identity 
\emph on
and
\emph default
 an arithmetic identity hold.
\end_layout

\begin_layout Standard
The presence of both identities does not automatically guarantee a useful
 type equivalence.
 The fact that information in one type can be identically stored in another
 type does not necessarily mean that it is helpful to do so in a given applicati
on.
\end_layout

\begin_layout Standard
For example, the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[A]]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Boolean, A]
\end_layout

\end_inset

 are equivalent because both types contain 
\begin_inset Formula $2+\left|A\right|$
\end_inset

 distinct values.
 The short notation for these types is 
\begin_inset Formula $\bbnum 1+\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $\bbnum 2+A$
\end_inset

 respectively.
 The type Boolean is denoted by 
\begin_inset Formula $\bbnum 2$
\end_inset

 since it has only 
\emph on
two
\emph default
 distinct values.
 
\end_layout

\begin_layout Standard
One could write code for converting between these types without loss of
 information:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[Option[A]] => Either[Boolean, A] = {
\end_layout

\begin_layout Plain Layout

  case None           => Left(false) // Or maybe Left(true)?
\end_layout

\begin_layout Plain Layout

  case Some(None)     => Left(true)
\end_layout

\begin_layout Plain Layout

  case Some(Some(x))  => Right(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Boolean, A] => Option[Option[A]] = {
\end_layout

\begin_layout Plain Layout

  case Left(false)    => None
\end_layout

\begin_layout Plain Layout

  case Left(true)     => Some(None)
\end_layout

\begin_layout Plain Layout

  case Right(x)       => Some(Some(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The presence of an arbitrary choice in this code is a warning sign.
 In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, we could map 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(false)
\end_layout

\end_inset

 or to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(true)
\end_layout

\end_inset

 and adjust the rest of the code accordingly.
 The type equivalence holds with either choice.
 So, these types 
\emph on
are
\emph default
 equivalent, but there is no 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

 choice of the conversion functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 that will work correctly in all applications, because the meaning of these
 data types will be application-dependent.
 We call this type equivalence 
\series bold
accidental
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!accidental
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-cardinality-option-either"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-cardinality-option-either"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Are the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 equivalent? Check whether the corresponding logic identity and arithmetic
 identity hold.
\end_layout

\begin_layout Paragraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the given types in the type notation: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $\bbnum 1+A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 is written also as 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 The notation already indicates that the types are equivalent.
 But let us verify explicitly that the type notation is not misleading us
 here.
\end_layout

\begin_layout Standard
To establish the type equivalence, we need to implement two fully parametric
 functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[A] => Either[Unit, A] = ???
\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Unit, A] => Option[A] = ???
\end_layout

\end_inset

These functions must satisfy 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
 It is straightforward to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[A] => Either[Unit, A] = {
\end_layout

\begin_layout Plain Layout

  case None      => Left(())
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Right(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Unit, A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Left(())   => None
\end_layout

\begin_layout Plain Layout

  case Right(x)   => Some(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code clearly shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 This verifies the type equivalence.
\end_layout

\begin_layout Standard
The logic identity is 
\begin_inset Formula $True\vee A=True\vee A$
\end_inset

 and holds trivially.
 It remains to check the arithmetic identity, which relates the cardinalities
 of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

.
 Assume that the cardinality of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is 
\begin_inset Formula $\left|A\right|$
\end_inset

.
 Any possible value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, the number of distinct values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $1+\left|A\right|$
\end_inset

.
 All possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 are of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(())
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, the cardinality of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 is 
\begin_inset Formula $1+\left|A\right|$
\end_inset

.
 We see that the arithmetic identity holds: the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 have equally many distinct values.
\end_layout

\begin_layout Standard
This example shows that the type notation is helpful for reasoning about
 type equivalences.
 The answer was found immediately when we wrote the type notation (
\begin_inset Formula $\bbnum 1+A$
\end_inset

) for the given types.
\end_layout

\begin_layout Subsection
Type equivalence involving function types
\end_layout

\begin_layout Standard
Until now, we have looked at product types and disjunctive types.
 Let us now consider type constructions involving function types.
\end_layout

\begin_layout Standard
Consider two types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, whose cardinalities 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

 are known.
 How many distinct values does the function type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 have? A function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 needs to select a value of type 
\begin_inset Formula $B$
\end_inset

 for each possible value of type 
\begin_inset Formula $A$
\end_inset

.
 Therefore, the number of different functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 is 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

.
 Here, 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 denotes the 
\series bold
numeric exponent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
exponent
\end_layout

\end_inset

, 
\begin_inset Formula $\left|B\right|$
\end_inset

 to the power 
\begin_inset Formula $\left|A\right|$
\end_inset

.
\end_layout

\begin_layout Standard
We use the numeric exponent notation (
\begin_inset Formula $a^{b}$
\end_inset

) only when computing with numbers.
 When denoting types and code, superscripts are used in this book for type
 parameters and type annotations.
\end_layout

\begin_layout Standard
For the types 
\begin_inset Formula $A=B=\text{Int}$
\end_inset

, we have 
\begin_inset Formula $\left|A\right|=\left|B\right|=2^{32}$
\end_inset

, and the exponential formula gives:
\begin_inset Formula 
\[
\left|A\rightarrow B\right|=(2^{32})^{\left(2^{32}\right)}=2^{32\times2^{32}}=2^{2^{37}}\approx10^{4.1\times10^{10}}\quad.
\]

\end_inset

This number greatly exceeds the number of atoms in the observable Universe!
\begin_inset Foot
status open

\begin_layout Plain Layout
Estimated to be between 
\begin_inset Formula $10^{78}$
\end_inset

 and 
\begin_inset Formula $10^{82}$
\end_inset

, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.universetoday.com/36302/atoms-in-the-universe/amp/"
literal "false"

\end_inset


\end_layout

\end_inset

 However, almost all of those functions will map integers to integers in
 an extremely complicated (and practically useless) way.
 The code of those functions will be much larger than the available memory
 of a realistic computer.
 So, the number of practically implementable functions of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 can be much smaller than 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

.
 Since the code of a function is a string of bytes that needs to fit into
 the computer's memory, the number of implementable functions is no larger
 than the number of possible byte strings.
\end_layout

\begin_layout Standard
Nevertheless, the formula 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 is useful since it shows the number of distinct functions that are possible
 in principle.
 When types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have only a small number of distinct values (for example, 
\begin_inset Formula $A=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]]
\end_layout

\end_inset

 and 
\begin_inset Formula $B=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Boolean, Boolean]
\end_layout

\end_inset

), the formula 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 gives an exact and practically relevant answer.
\end_layout

\begin_layout Standard
Let us now look for logic identities and arithmetic identities involving
 function types.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 lists the available identities and the corresponding type equivalences.
 (In the last column, we defined 
\begin_inset Formula $a\triangleq\left|A\right|$
\end_inset

, 
\begin_inset Formula $b\triangleq\left|B\right|$
\end_inset

, and 
\begin_inset Formula $c\triangleq\left|C\right|$
\end_inset

 for brevity.) 
\end_layout

\begin_layout Standard
It is notable that no logic identity is available for the formula 
\begin_inset Formula $\alpha\Rightarrow\left(\beta\vee\gamma\right)$
\end_inset

, and correspondingly no type equivalence is available for the type expression
 
\begin_inset Formula $A\rightarrow B+C$
\end_inset

 (although there is an identity for 
\begin_inset Formula $A\rightarrow B\times C$
\end_inset

).
 Type reasoning becomes more complicated in the presence of type expressions
 of the form 
\begin_inset Formula $A\rightarrow B+C$
\end_inset

 because those expressions cannot be transformed into simpler type formulas.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logical identity (if holds)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type equivalence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Arithmetic identity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(True\Rightarrow\alpha\right)=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1\rightarrow A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a^{1}=a$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(False\Rightarrow\alpha\right)=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0\rightarrow A\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $a^{0}=1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\Rightarrow True\right)=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\rightarrow\bbnum 1\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1^{a}=1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\Rightarrow False\right)\neq False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\rightarrow\bbnum 0\not\cong\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0^{a}\neq0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\Rightarrow\gamma=\left(\alpha\Rightarrow\gamma\right)\wedge\left(\beta\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A+B\rightarrow C\cong\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $c^{a+b}=c^{a}\times c^{b}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(\alpha\wedge\beta)\Rightarrow\gamma=\alpha\Rightarrow\left(\beta\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times B\rightarrow C\cong A\rightarrow B\rightarrow C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $c^{a\times b}=(c^{b})^{a}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\Rightarrow\left(\beta\wedge\gamma\right)=\left(\alpha\Rightarrow\beta\right)\wedge\left(\alpha\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\rightarrow B\times C\cong\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(b\times c\right)^{a}=b^{a}\times c^{a}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logical identities with implication, and the corresponding type equivalences
 and arithmetic identities.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-identities-with-function-types"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now prove some of the type identities in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-f"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-f"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 1\rightarrow A\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 means the Scala function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

.
 There is only one value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 The choice of a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

 is the same as the choice of a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, the type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 has 
\begin_inset Formula $\left|A\right|$
\end_inset

 distinct values, and the arithmetic identity holds.
\end_layout

\begin_layout Standard
To verify the type equivalence explicitly, we need to implement two functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: (Unit => A) => A = ???
\end_layout

\begin_layout Plain Layout

def f2[A]: A => Unit => A = ???
\end_layout

\end_inset

The first function needs to produce a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, given an argument of the function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

.
 The only possibility is to apply that function to the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 We can always produce that value as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: (Unit => A) => A = (h: Unit => A) => h(())
\end_layout

\end_inset

Implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is straightforward.
 We can just discard the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A]: A => Unit => A = (x: A) => _ => x
\end_layout

\end_inset

It remains to show that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 Let us show the proof using Scala code and then using the code notation.
\end_layout

\begin_layout Standard
Writing Scala code, compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(f2(x))
\end_layout

\end_inset

 for an arbitrary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 Using the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f1(f2(x)) == f1(_ => x) == (_ => x)(()) == x
\end_layout

\end_inset

Now compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2(f1(h))
\end_layout

\end_inset

 for arbitrary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h: Unit => A
\end_layout

\end_inset

 in Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f2(f1(h)) == f2(h(())) == { _ => h(()) }
\end_layout

\end_inset

How can we show that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{_ => h(())}
\end_layout

\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

? Whenever we apply equal functions to equal arguments, they return equal
 results.
 In our case, the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, so we only need to verify that the result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 to the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 is the same as the result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{_ => h(())}
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 In other words, we need to apply both sides to an additional argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f2(f1(h))(()) == { _ => h(()) } (()) == h(())
\end_layout

\end_inset

This completes the proof.
\end_layout

\begin_layout Standard
For comparison, let us show the same proof in the code notation.
 The functions 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are:
\begin_inset Formula 
\[
f_{1}\triangleq h^{:\bbnum 1\rightarrow A}\rightarrow h(1)\quad,\quad\quad f_{2}\triangleq x^{:A}\rightarrow1\rightarrow x\quad.
\]

\end_inset

Now write the function compositions in both directions:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & f_{1}\bef f_{2}=(h^{:\bbnum 1\rightarrow A}\rightarrow h(1))\bef(x^{:A}\rightarrow1\rightarrow x)\\
\text{compute composition}:\quad & \quad=h^{:\bbnum 1\rightarrow A}\rightarrow\gunderline{1\rightarrow h(1)}\\
\text{note that }1\rightarrow h(1)\text{ is the same as }h:\quad & \quad=(h^{:\bbnum 1\rightarrow A}\rightarrow h)=\text{id}\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & f_{2}\bef f_{1}=(x^{:A}\rightarrow1\rightarrow x)\bef(h^{:\bbnum 1\rightarrow A}\rightarrow h(1))\\
\text{compute composition}:\quad & \quad=x^{:A}\rightarrow\gunderline{(1\rightarrow x)(1)}\\
\text{apply function}:\quad & \quad=(x^{:A}\rightarrow x)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 is equivalent to the type 
\begin_inset Formula $A$
\end_inset

, but these types are not the same.
 The most important difference between these types is that a value of type
 
\begin_inset Formula $A$
\end_inset

 is available immediately, while a value of type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 is a function that still needs to be applied to an argument (of type 
\begin_inset Formula $\bbnum 1$
\end_inset

) before a value of type 
\begin_inset Formula $A$
\end_inset

 is obtained.
 The type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 may represent an 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
on-call value
\end_layout

\end_inset

 value of type 
\begin_inset Formula $A$
\end_inset

.
 That value is computed on demand every time it is requested.
 (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Lazy-values-iterators-and-streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details about 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset

 values.)
\end_layout

\begin_layout Standard
The void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 
\begin_inset Formula $\bbnum 0$
\end_inset

 needs special reasoning, as the next examples show:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-0-to-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0\rightarrow A\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To verify that a type 
\begin_inset Formula $X$
\end_inset

 is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, we need to show that there is only one distinct value of type 
\begin_inset Formula $X$
\end_inset

.
 So, let us find out how many values the type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

 has.
 Consider a value of that type, which is a function 
\begin_inset Formula $f^{:\bbnum 0\rightarrow A}$
\end_inset

 from the type 
\begin_inset Formula $\bbnum 0$
\end_inset

 to a type 
\begin_inset Formula $A$
\end_inset

.
 Since there exist no values of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, the function 
\begin_inset Formula $f$
\end_inset

 will never be applied to any arguments and so 
\emph on
does not need
\emph default
 to compute any actual values of type 
\begin_inset Formula $A$
\end_inset

.
 So, 
\begin_inset Formula $f$
\end_inset

 is a function whose body may be 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

.
 At least, 
\begin_inset Formula $f$
\end_inset

's body does not need to contain any expressions of type 
\begin_inset Formula $A$
\end_inset

.
 In Scala, such a function can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def absurd[A]: Nothing => A = { ??? }
\end_layout

\end_inset

This code will compile without type errors.
 An equivalent code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def absurd[A]: Nothing => A = { x => ??? }
\end_layout

\end_inset

The symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset

 is defined in the Scala library and represents code that is 
\begin_inset Quotes eld
\end_inset

not implemented
\begin_inset Quotes erd
\end_inset

.
 Trying to evaluate this symbol will produce an error:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x = ???
\end_layout

\begin_layout Plain Layout

scala.NotImplementedError: an implementation is missing
\end_layout

\end_inset

Since the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd
\end_layout

\end_inset

 can never be applied to an argument, this error will never happen.
 So, one can pretend that the result value (which will never be computed)
 has any required type, e.g., the type 
\begin_inset Formula $A$
\end_inset

.
 In this way, the compiler will accept the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us now verify that there exists 
\emph on
only one
\emph default
 distinct function of type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

.
 Take any two functions of that type, 
\begin_inset Formula $f^{:\bbnum 0\rightarrow A}$
\end_inset

 and 
\begin_inset Formula $g^{:\bbnum 0\rightarrow A}$
\end_inset

.
 Are they different? The only way of showing that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are different is by producing a value 
\begin_inset Formula $x^{:\bbnum 0}$
\end_inset

 such that 
\begin_inset Formula $f(x)\neq g(x)$
\end_inset

.
 But there are 
\emph on
no
\emph default
 
\emph on
values
\emph default
 of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, and for this reason, we will never be able to find the required value
 
\begin_inset Formula $x^{:\bbnum 0}$
\end_inset

.
 It follows that any two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

 are equal, 
\begin_inset Formula $f=g$
\end_inset

.
 In other words, there exists only one distinct value of type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

.
 Since the cardinality of the type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

, we obtain the type equivalence 
\begin_inset Formula $\bbnum 0\rightarrow A\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-A-0"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $A\rightarrow\bbnum 0\not\cong\bbnum 0$
\end_inset

 and 
\begin_inset Formula $A\rightarrow\bbnum 0\not\cong\bbnum 1$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is an arbitrary type.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To prove that two types are 
\emph on
not
\emph default
 equivalent, it is sufficient to show that their type cardinalities are
 different.
 Let us determine the cardinality of the type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

, assuming that the cardinality of 
\begin_inset Formula $A$
\end_inset

 is known.
 We note that a function of type, say, 
\begin_inset Formula $\text{Int}\rightarrow\bbnum 0$
\end_inset

 is impossible to implement.
 (If we had such a function 
\begin_inset Formula $f^{:\text{Int}\rightarrow\bbnum 0}$
\end_inset

, we could evaluate, say, 
\begin_inset Formula $x\triangleq f(123)$
\end_inset

 and obtain a value 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, which is impossible by definition of the type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 It follows that 
\begin_inset Formula $\left|\text{Int}\rightarrow\bbnum 0\right|=0$
\end_inset

.
 However, Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\bbnum 0\rightarrow\bbnum 0$
\end_inset

 has cardinality 
\begin_inset Formula $1$
\end_inset

.
 So, we find that 
\begin_inset Formula $\left|A\rightarrow\bbnum 0\right|=1$
\end_inset

 if the type 
\begin_inset Formula $A$
\end_inset

 is itself 
\begin_inset Formula $\bbnum 0$
\end_inset

 but 
\begin_inset Formula $\left|A\rightarrow\bbnum 0\right|=0$
\end_inset

 for all other types 
\begin_inset Formula $A$
\end_inset

.
 We conclude that the type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 is not equivalent to 
\begin_inset Formula $\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 1$
\end_inset

 when 
\begin_inset Formula $A$
\end_inset

 is an unknown type.
 The type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 is void only for non-void types 
\begin_inset Formula $A$
\end_inset

, and vice versa.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\rightarrow\bbnum 1\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
There is only one fully parametric function that returns 
\begin_inset Formula $\bbnum 1$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => Unit = { _ => () }
\end_layout

\end_inset

The function 
\begin_inset Formula $f$
\end_inset

 cannot use its argument of type 
\begin_inset Formula $A$
\end_inset

 since nothing is known about the type 
\begin_inset Formula $A$
\end_inset

.
 So, the code of 
\begin_inset Formula $f$
\end_inset

 
\emph on
must
\emph default
 discard its argument and return the fixed value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 In the code notation, this function is written as:
\begin_inset Formula 
\[
f^{:A\rightarrow\bbnum 1}\triangleq\_\rightarrow1\quad.
\]

\end_inset

We can show that there exist only 
\emph on
one
\emph default
 distinct function of type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 (that is, the type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 has cardinality 
\begin_inset Formula $1$
\end_inset

).
 Assume that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are two such functions, and try to find a value 
\begin_inset Formula $x^{:A}$
\end_inset

 such that 
\begin_inset Formula $f(x)\neq g(x)$
\end_inset

.
 We cannot find any such 
\begin_inset Formula $x$
\end_inset

 because 
\begin_inset Formula $f(x)=1$
\end_inset

 and 
\begin_inset Formula $g(x)=1$
\end_inset

 for all 
\begin_inset Formula $x$
\end_inset

.
 So, any two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 must be equal to each other.
 The cardinality of the type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Standard
Any type having cardinality 
\begin_inset Formula $1$
\end_inset

 is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type (
\begin_inset Formula $\bbnum 1$
\end_inset

).
 So, 
\begin_inset Formula $A\rightarrow\bbnum 1\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the following type equivalence:
\begin_inset Formula 
\[
A+B\rightarrow C\cong(A\rightarrow C)\times(B\rightarrow C)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing two functions with type signatures:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (Either[A, B] => C) => (A => C, B => C) = ???
\end_layout

\begin_layout Plain Layout

def f2[A,B,C]: ((A => C, B => C)) => Either[A, B] => C = ???
\end_layout

\end_inset

The code can be derived unambiguously from the type signatures.
 For the first function, we need to produce a pair of functions of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => C, B => C)
\end_layout

\end_inset

.
 Can we produce the first part of that pair? Computing a function of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

 means that we need to produce a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 given an arbitrary value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 The available data is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B] => C
\end_layout

\end_inset

 called, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

.
 We can apply that function to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 and obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 as required.
 So, a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

 is computed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a => h(Left(a))
\end_layout

\end_inset

.
 We can produce a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

 similarly.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (Either[A, B] => C) => (A => C, B => C) =
\end_layout

\begin_layout Plain Layout

  (h: Either[A, B] => C) => (a => h(Left(a)), b => h(Right(b)))
\end_layout

\end_inset

We write this function in the code notation like this:
\begin_inset Formula 
\begin{align*}
 & f_{1}:\left(A+B\rightarrow C\right)\rightarrow\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)\quad,\\
 & f_{1}\triangleq h^{:A+B\rightarrow C}\rightarrow\big(a^{:A}\rightarrow h(a+\bbnum 0^{:B})\big)\times\big(b^{:B}\rightarrow h(\bbnum 0^{:A}+b)\big)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
For the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we need to apply pattern matching to both curried arguments and then return
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 This can be achieved in only one way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A,B,C](f: A => C, g: B => C): Either[A, B] => C = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => f(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => g(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We write this function in the code notation like this:
\begin_inset Formula 
\begin{align*}
 & f_{2}:\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)\rightarrow A+B\rightarrow C\quad,\\
 & f_{2}\triangleq f^{:A\rightarrow C}\times g^{:B\rightarrow C}\rightarrow\,\begin{array}{|c||c|}
 & C\\
\hline A & a\rightarrow f(a)\\
B & b\rightarrow g(b)
\end{array}\quad.
\end{align*}

\end_inset

The matrix in the last line has only one column because the result type,
 
\begin_inset Formula $C$
\end_inset

, is not known to be a disjunctive type.
 We may also simplify the functions, e.g., replace 
\begin_inset Formula $a\rightarrow f(a)$
\end_inset

 by just 
\begin_inset Formula $f$
\end_inset

, and write:
\begin_inset Formula 
\[
f_{2}\triangleq f^{:A\rightarrow C}\times g^{:B\rightarrow C}\rightarrow\,\begin{array}{|c||c|}
 & C\\
\hline A & f\\
B & g
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
 To compute 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

, we write (omitting types):
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\big(h\rightarrow(a\rightarrow h(a+\bbnum 0))\times(b\rightarrow h(\bbnum 0+b))\big)\bef\bigg(f\times g\rightarrow\,\begin{array}{||c|}
f\\
g
\end{array}\,\bigg)\\
\text{compute composition}:\quad & =h\rightarrow\,\begin{array}{||c|}
a\rightarrow h(a+\bbnum 0)\\
b\rightarrow h(\bbnum 0+b)
\end{array}\quad.
\end{align*}

\end_inset

To proceed, we need to simplify the expressions 
\begin_inset Formula $h(a+\bbnum 0)$
\end_inset

 and 
\begin_inset Formula $h(\bbnum 0+b)$
\end_inset

.
 We rewrite the argument 
\begin_inset Formula $h$
\end_inset

 (an arbitrary function of type 
\begin_inset Formula $A+B\rightarrow C$
\end_inset

) in the matrix notation:
\begin_inset Formula 
\[
h\triangleq\,\begin{array}{|c||c|}
 & C\\
\hline A & a\rightarrow p(a)\\
B & b\rightarrow q(b)
\end{array}\,=\,\begin{array}{|c||c|}
 & C\\
\hline A & p\\
B & q
\end{array}\quad,
\]

\end_inset

where 
\begin_inset Formula $p^{:A\rightarrow C}$
\end_inset

 and 
\begin_inset Formula $q^{:B\rightarrow C}$
\end_inset

 are new arbitrary functions.
 Since we already checked the types, we can omit all type annotations and
 write 
\begin_inset Formula $h$
\end_inset

 as:
\begin_inset Formula 
\[
h\triangleq\,\begin{array}{||c|}
p\\
q
\end{array}\quad.
\]

\end_inset

To evaluate expressions such as 
\begin_inset Formula $h(a+\bbnum 0)$
\end_inset

 and 
\begin_inset Formula $h(\bbnum 0+b)$
\end_inset

, we need to use one of the rows of this matrix.
 The correct row will be selected 
\emph on
automatically
\emph default
 by the rules of matrix multiplication if we place a row vector to the left
 of the matrix and use the convention of omitting terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=a\triangleright p\quad,\quad\quad\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=b\triangleright q\quad.
\]

\end_inset

Here we used the symbol 
\begin_inset Formula $\triangleright$
\end_inset

 to separate an argument from a function when the argument is written to
 the 
\emph on
left
\emph default
 of the function.
 The symbol 
\begin_inset Formula $\triangleright$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $\triangleright$
\end_inset

-notation!see 
\begin_inset Quotes eld
\end_inset

pipe notation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

) is defined by 
\begin_inset Formula $x\triangleright f\triangleq f(x)$
\end_inset

.
 In Scala, this operation is available as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 as of Scala 2.13.
\end_layout

\begin_layout Standard
We can write values of disjunctive types, such as 
\begin_inset Formula $a+\bbnum 0$
\end_inset

, as row vectors 
\begin_inset Formula $\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,$
\end_inset

:
\begin_inset Formula 
\begin{equation}
h(a+\bbnum 0)=(a+\bbnum 0)\triangleright h=\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,h\quad.\label{eq:forward-notation-}
\end{equation}

\end_inset

With these notations, we compute further.
 Omit all terms applying 
\begin_inset Formula $\bbnum 0$
\end_inset

 or applying something to 
\begin_inset Formula $\bbnum 0$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,h=\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=a\triangleright p=p(a)\quad,\\
 & \begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,h=\,\,\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=b\triangleright q=q(b)\quad.
\end{align*}

\end_inset

Now we can complete the proof of 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =h\rightarrow\,\begin{array}{||c|}
a\rightarrow h(a+\bbnum 0)\\
b\rightarrow h(\bbnum 0+b)
\end{array}\\
\text{previous equations}:\quad & =\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
a\rightarrow p(a)\\
b\rightarrow q(b)
\end{array}\\
\text{simplify functions}:\quad & =\,\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
p\\
q
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To prove that 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

, use the notation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:forward-notation-"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & f_{2}\bef f_{1}=\bigg(f\times g\rightarrow\,\begin{array}{||c|}
f\\
g
\end{array}\,\bigg)\bef\big(h\rightarrow(a\rightarrow(a+\bbnum 0)\triangleright h)\times(b\rightarrow(\bbnum 0+b)\triangleright h)\big)\\
\text{compute composition}:\quad & =f\times g\rightarrow\big(a\rightarrow\gunderline{\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright}\,\begin{array}{||c|}
f\\
g
\end{array}\,\big)\times\big(b\rightarrow\gunderline{\,\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright}\,\begin{array}{||c|}
f\\
g
\end{array}\,\big)\\
\text{apply functions}:\quad & =f\times g\rightarrow(a\rightarrow\gunderline{a\triangleright f})\times(b\rightarrow\gunderline{b\triangleright g})\\
\text{definition of }\triangleright:\quad & =f\times g\rightarrow\gunderline{\left(a\rightarrow f(a)\right)}\times\gunderline{\left(b\rightarrow g(b)\right)}\\
\text{simplify functions}:\quad & =\left(f\times g\rightarrow f\times g\right)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In this way, we have proved that 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are mutual inverses.
 The proofs appear long because we took time to motivate and introduce new
 notation for applying matrices to row vectors.
 Once this notation is understood, the proof for 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 can be written as:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(h\rightarrow(a\rightarrow(a+\bbnum 0)\triangleright h)\times(b\rightarrow(\bbnum 0+b)\triangleright h)\right)\bef\bigg(f\times g\rightarrow\,\begin{array}{||c|}
f\\
g
\end{array}\bigg)\\
\text{compute composition}:\quad & =h\rightarrow\,\begin{array}{||c|}
\,a\,\rightarrow\,\left|\begin{array}{cc}
a & \bbnum 0\end{array}\right|\triangleright h\\
b\rightarrow\left|\begin{array}{cc}
\bbnum 0 & b\end{array}\right|\triangleright h
\end{array}\,=\,\begin{array}{||c|}
p\\
q
\end{array}\rightarrow\,\begin{array}{||c|}
a\rightarrow\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\\
b\,\rightarrow\,\begin{array}{|cc|}
\bbnum 0 & b\,\,\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}
\end{array}\\
\text{apply functions}:\quad & =\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
a\rightarrow a\triangleright p\\
b\rightarrow b\triangleright q
\end{array}\,=\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
p\\
q
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset

Proofs in the code notation are shorter than in Scala syntax because certain
 names and keywords (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

, etc.) are omitted.
 From now on, we will prefer to use the code notation in proofs, keeping
 in mind that one can always convert the code notation to Scala.
\end_layout

\begin_layout Standard
Note that the function arrow (
\begin_inset Formula $\rightarrow$
\end_inset

) binds weaker than the pipe operation (
\begin_inset Formula $\triangleright$
\end_inset

), so the code notation 
\begin_inset Formula $x\rightarrow y\triangleright z$
\end_inset

 means 
\begin_inset Formula $x\rightarrow(y\triangleright z)$
\end_inset

.
 We will review the code notation more systematically in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Reasoning-about-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence:
\begin_inset Formula 
\[
A\times B\rightarrow C\cong A\rightarrow B\rightarrow C\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the two functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (((A, B)) => C) => A => B => C = ???
\end_layout

\begin_layout Plain Layout

def f2[A,B,C]: (A => B => C) => ((A, B)) => C = ???
\end_layout

\end_inset

The Scala code can be derived from the type signatures unambiguously:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (((A, B)) => C) => A => B => C = g => a => b => g((a, b))
\end_layout

\begin_layout Plain Layout

def f2[A,B,C]: (A => B => C) => ((A, B)) => C = h => { case (a, b) => h(a)(b)
 }
\end_layout

\end_inset

Write these functions in the code notation:
\begin_inset Formula 
\begin{align*}
 & f_{1}=g^{:A\times B\rightarrow C}\rightarrow a^{:A}\rightarrow b^{:B}\rightarrow g(a\times b)\quad,\\
 & f_{2}=h^{:A\rightarrow B\rightarrow C}\rightarrow\left(a\times b\right)^{:A\times B}\rightarrow h(a)(b)\quad.
\end{align*}

\end_inset

We denote by 
\begin_inset Formula $\left(a\times b\right)^{:A\times B}$
\end_inset

 the argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 with pattern matching implied.
 This notation allows us to write shorter code formulas involving tupled
 arguments.
\end_layout

\begin_layout Standard
Compute the function composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =(g\rightarrow\gunderline{a\rightarrow b\rightarrow g(a\times b)})\bef\left(h\rightarrow a\times b\rightarrow h(a)(b)\right)\\
\text{substitute }h=a\rightarrow b\rightarrow g(a\times b):\quad & =g\rightarrow\gunderline{a\times b\rightarrow g(a\times b)}\\
\text{simplify function}:\quad & =\left(g\rightarrow g\right)=\text{id}\quad.
\end{align*}

\end_inset

Compute the function composition 
\begin_inset Formula $f_{2}\bef f_{1}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{2}\bef f_{1} & =(h\rightarrow\gunderline{a\times b\rightarrow h(a)(b)})\bef\left(g\rightarrow a\rightarrow b\rightarrow g(a\times b)\right)\\
\text{substitute }g=a\times b\rightarrow h(a)(b):\quad & =h\rightarrow a\rightarrow\gunderline{b\rightarrow h(a)(b)}\\
\text{simplify function }b\rightarrow h(a)(b):\quad & =h\rightarrow\gunderline{a\rightarrow h(a)}\\
\text{simplify function }a\rightarrow h(a)\text{ to }h:\quad & =\left(h\rightarrow h\right)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What tasks can we perform now?
\end_layout

\begin_layout Itemize
Convert a fully parametric type signature into a logical formula and:
\end_layout

\begin_deeper
\begin_layout Itemize
Decide whether the type signature can be implemented in code.
\end_layout

\begin_layout Itemize
If possible, derive the code using the CH correspondence.
\end_layout

\end_deeper
\begin_layout Itemize
Use the type notation (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for reasoning about types to:
\end_layout

\begin_deeper
\begin_layout Itemize
Decide type equivalence using the rules in Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Itemize
Simplify type expressions before writing code.
\end_layout

\end_deeper
\begin_layout Itemize
Use the matrix notation and the pipe notation to write code that works on
 disjunctive types.
\end_layout

\begin_layout Standard
What tasks 
\emph on
cannot
\emph default
 be performed with these tools?
\end_layout

\begin_layout Itemize
Automatically generate code for 
\emph on
recursive
\emph default
 functions.
 The CH correspondence is based on propositional logic, which cannot describe
 recursion.
 Accordingly, recursion is absent from the eight code constructions of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Recursive functions need to be coded by hand.
\end_layout

\begin_layout Itemize
Automatically generate code satisfying a property (e.g., isomorphism).
 We may generate some code, but the CH correspondence does not guarantee
 that properties will hold.
 We need to verify the required properties manually, after deriving the
 code.
\end_layout

\begin_layout Itemize
Express complicated conditions (e.g., 
\begin_inset Quotes eld
\end_inset

array is sorted
\begin_inset Quotes erd
\end_inset

) in a type signature.
 This can be done using 
\series bold
dependent types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent type
\end_layout

\end_inset

 (i.e., types that directly depend on values in some way).
 This is an advanced technique beyond the scope of this book.
 Programming languages such as Coq, Agda, and Idris fully support dependent
 types, while Scala has only limited support.
\end_layout

\begin_layout Itemize
Generate code using type constructors with known methods (e.g., the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method).
\end_layout

\begin_layout Standard
As an example of using type constructors with known methods, consider this
 type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A]: Array[A] => (A => Option[B]) => Array[Option[B]]
\end_layout

\end_inset

Can we generate the code of this function from its type signature? We know
 that the Scala library defines a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 class.
 So, an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A]: Array[A] => (A => Option[B]) => Array[Option[B]] = { arr => f
 => arr.map(f) }
\end_layout

\end_inset

However, it is hard to create an 
\emph on
algorithm
\emph default
 that can derive this implementation automatically from the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 via the Curry-Howard correspondence.
 The algorithm would have to convert the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 into this logical formula:
\begin_inset Formula 
\begin{equation}
{\cal CH}(\text{Array}^{A})\Rightarrow{\cal CH}(A\rightarrow\text{Opt}^{B})\Rightarrow{\cal CH}(\text{Array}^{\text{Opt}^{B}})\quad.\label{eq:ch-example-quantified-proposition}
\end{equation}

\end_inset

To derive an implementation, the algorithm would need to use the available
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

.
 That method has the type signature:
\begin_inset Formula 
\[
\text{map}:\forall(A,B).\,\text{Array}^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Array}^{B}\quad.
\]

\end_inset

To derive the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the algorithm will need to assume that the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition:
\begin_inset Formula 
\begin{equation}
{\cal CH}\,\big(\forall(A,B).\,\text{Array}^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Array}^{B}\big)\label{eq:ch-example-quantified-proposition-2}
\end{equation}

\end_inset

already holds.
 In other words Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is one of the premises of a sequent.
 Reasoning about premises such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) requires 
\begin_inset Index idx
status open

\begin_layout Plain Layout
first-order logic
\end_layout

\end_inset


\series bold
first-order logic
\series default
 — a logic whose proof rules can handle quantified types such as 
\begin_inset Formula $\forall(A,B)$
\end_inset


\emph on
 
\emph default
inside premises.
 However, first-order logic is 
\series bold
undecidable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
undecidable logic
\end_layout

\end_inset

: no algorithm can find a proof (or verify the absence of a proof) in all
 cases.
 
\end_layout

\begin_layout Standard
The constructive propositional logic with the rules listed in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\series bold
decidable
\series default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
decidable logic
\end_layout

\end_inset

 i.e., it has an algorithm that either finds a proof or disproves any given
 formula.
 However, that logic cannot handle type constructors such as 
\begin_inset Formula $\text{Array}^{A}$
\end_inset

.
 It also cannot handle premises containing type quantifiers such as 
\begin_inset Formula $\forall(A,B)$
\end_inset

, because all the available rules have the quantifiers placed 
\emph on
outside
\emph default
 the premises.
 
\end_layout

\begin_layout Standard
So, code for functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 can only be derived by trial and error, informed by intuition.
 This book will help programmers to acquire the necessary intuition and
 technique.
\end_layout

\begin_layout Subsection
Solved examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the cardinality of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Option[Option[Boolean] => Boolean]
\end_layout

\end_inset

.
 Write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 in the type notation and simplify it to an equivalent type.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin with the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

, which can be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

 with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Boolean
\end_layout

\end_inset

.
 Since the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 has 
\begin_inset Formula $2$
\end_inset

 possible values, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

 has 
\begin_inset Formula $3$
\end_inset

 values:
\begin_inset Formula 
\[
|\text{Opt}^{\text{Boolean}}|=\left|\bbnum 1+\text{Boolean}\right|=1+\left|\text{Boolean}\right|=1+2=3\quad.
\]

\end_inset

In the type notation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 is denoted by the symbol 
\begin_inset Formula $\bbnum 2$
\end_inset

, and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

 by 
\begin_inset Formula $\bbnum 1+\bbnum 2$
\end_inset

.
 So, the type notation 
\begin_inset Formula $\bbnum 1+\bbnum 2$
\end_inset

 is consistent with the cardinality 
\begin_inset Formula $3$
\end_inset

 of that type:
\begin_inset Formula 
\[
\left|\bbnum 1+\text{Boolean}\right|=\left|\bbnum 1+\bbnum 2\right|=1+2=3\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean] => Boolean
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\bbnum 1+\bbnum 2\rightarrow\bbnum 2$
\end_inset

.
 Compute its cardinality as:
\begin_inset Formula 
\[
|\text{Opt}^{\text{Boolean}}\rightarrow\text{Boolean}|=\left|\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right|=\left|\bbnum 2\right|^{\left|\bbnum 1+\bbnum 2\right|}=2^{3}=8\quad.
\]

\end_inset

Finally, the we write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 in the type notation as 
\begin_inset Formula $P=\bbnum 1+\left(\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right)$
\end_inset

 and find:
\begin_inset Formula 
\[
\left|P\right|=\left|\bbnum 1+\left(\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right)\right|=1+\left|\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right|=1+8=9\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A]
\end_layout

\end_inset

 given by this type notation:
\begin_inset Formula 
\[
P^{A}\triangleq1+A+\text{Int}\times A+(\text{String}\rightarrow A)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To translate type notation into Scala code, begin by defining the disjunctive
 types as case classes, choosing class names for convenience.
 In this case, 
\begin_inset Formula $P^{A}$
\end_inset

 is a disjunctive type with four parts, so we need four case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P4[A](???) extends P[A]
\end_layout

\end_inset

Each of the case classes represents one part of the disjunctive type.
 Now we write the contents for each of the case classes, in order to implement
 the data in each of the disjunctive parts:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A]()                 extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](x: A)             extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](n: Int, x: A)     extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P4[A](f: String => A)   extends P[A]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-2a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find an equivalent disjunctive type for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = (Either[A, B], Either[C, D])
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the given type in the type notation.
 The tuple becomes the product type, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 becomes the disjunctive (or 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

) type:
\begin_inset Formula 
\[
P\triangleq(A+B)\times(C+D)\quad.
\]

\end_inset

By the usual rules of arithmetic, we expand brackets and obtain an equivalent
 type:
\begin_inset Formula 
\[
P\cong A\times C+A\times D+B\times C+B\times D\quad.
\]

\end_inset

This is a disjunctive type having 
\begin_inset Formula $4$
\end_inset

 parts.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following type equivalences do 
\emph on
not
\emph default
 hold: 
\begin_inset Formula $A+A\not\cong A$
\end_inset

 and 
\begin_inset Formula $A\times A\not\cong A$
\end_inset

, although the corresponding logical identities hold.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Note that the arithmetic equalities do not hold, 
\begin_inset Formula $A+A\neq A$
\end_inset

 and 
\begin_inset Formula $A\times A\ne A$
\end_inset

.
 This already indicates that the types are not equivalent.
 To build further intuition, consider that a value of type 
\begin_inset Formula $A+A$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

) is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 In the code notation, it is either 
\begin_inset Formula $a^{:A}+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+a^{:A}$
\end_inset

.
 So, a value of type 
\begin_inset Formula $A+A$
\end_inset

 contains a value of type 
\begin_inset Formula $A$
\end_inset

 with the additional information about whether it is the first or the second
 part of the disjunctive type.
 We cannot represent that information in a single value of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
Similarly, a value of type 
\begin_inset Formula $A\times A$
\end_inset

 contains two (possibly different) values of type 
\begin_inset Formula $A$
\end_inset

, which cannot be represented by a single value of type 
\begin_inset Formula $A$
\end_inset

 without loss of information.
\end_layout

\begin_layout Standard
However, the corresponding logical identities 
\begin_inset Formula $\alpha\vee\alpha=\alpha$
\end_inset

 and 
\begin_inset Formula $\alpha\wedge\alpha=\alpha$
\end_inset

 hold.
 To see that, we could derive the four formulas:
\begin_inset Formula 
\[
\alpha\vee\alpha\Rightarrow\alpha\quad,\quad\quad\alpha\Rightarrow\alpha\vee\alpha\quad,\quad\quad\alpha\wedge\alpha\Rightarrow\alpha\quad,\quad\quad\alpha\Rightarrow\alpha\wedge\alpha\quad,
\]

\end_inset

using the proof rules of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Alternatively, we may use the CH correspondence and show that the type
 signatures:
\begin_inset Formula 
\[
\forall A.\,A+A\rightarrow A\quad,\quad\quad\forall A.\,A\rightarrow A+A\quad,\quad\quad\forall A.\,A\times A\rightarrow A\quad,\quad\quad\forall A.\,A\rightarrow A\times A\quad
\]

\end_inset

can be implemented via fully parametric functions.
 For a programmer, it is easier to write code than to guess the correct
 sequence of proof rules.
 For the first pair of type signatures, we find:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Either[A, A] => A = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => a   // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right(a)   => a   // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A]: A => Either[A, A] = { a => Left(a) } // Can be also Right(a).
\end_layout

\end_inset

The presence of an arbitrary choice, to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

, is a warning sign showing that additional information is required to create
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

.
 This is precisely the information present in the type 
\begin_inset Formula $A+A$
\end_inset

 but missing in the type 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
The code notation for these functions is:
\begin_inset Formula 
\[
f_{1}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline A & a^{:A}\rightarrow a\\
A & a^{:A}\rightarrow a
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\quad,\quad\quad f_{2}\triangleq a^{:A}\rightarrow a+\bbnum 0^{:A}=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & a^{:A}\rightarrow a & \bbnum 0
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & \text{id} & \bbnum 0
\end{array}\quad.
\]

\end_inset

The composition of these functions is not equal to identity:
\begin_inset Formula 
\[
f_{1}\bef f_{2}=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\text{id} & \bbnum 0
\end{array}\,\quad,\quad\text{while we have}\quad\text{id}^{:A+A\rightarrow A+A}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
For the second pair of type signatures, the code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: ((A, A)) => A = { case (a1, a2) => a1 }   // Could be also `a2`.
\end_layout

\begin_layout Plain Layout

cef f2[A]:   A => (A, A) = { a => (a, a) }           // No other choice
 here.
\end_layout

\end_inset

It is clear that the first function loses information when it returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and discards 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

 (or vice versa).
\end_layout

\begin_layout Standard
The code notation for the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
f_{1}\triangleq a_{1}^{:A}\times a_{2}^{:A}\rightarrow a_{1}=\pi_{1}^{:A\times A\rightarrow A}\quad,\quad\quad f_{2}\triangleq a^{:A}\rightarrow a\times a=\Delta^{:A\rightarrow A\times A}\quad.
\]

\end_inset

Computing the compositions of these functions, we find that 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

 while 
\begin_inset Formula $f_{1}\bef f_{2}\ne\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(a_{1}\times a_{2}\rightarrow a_{1}\right)\bef\left(a\rightarrow a\times a\right)\\
 & =\left(a_{1}\times a_{2}\rightarrow a_{1}\times a_{1}\right)\neq\text{id}=\left(a_{1}\times a_{2}\rightarrow a_{1}\times a_{2}\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We have implemented all four type signatures as fully parametric functions,
 which shows that the corresponding logical formulas are all true (i.e., can
 be derived using the proof rules).
 However, the functions cannot be inverses of each other.
 So, the type equivalences do not hold.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $\left(\left(A\wedge B\right)\Rightarrow C\right)\neq(A\Rightarrow C)\vee(B\Rightarrow C)$
\end_inset

 in the constructive logic, but the equality holds in Boolean logic.
 This is another example where the Boolean reasoning fails to give correct
 answers about implementability of type signatures.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by rewriting the logical equality as two implications:
\begin_inset Formula 
\[
(A\wedge B\Rightarrow C)\Rightarrow(A\Rightarrow C)\vee(B\Rightarrow C)\quad\text{ and }\quad\left((A\Rightarrow C)\vee(B\Rightarrow C)\right)\Rightarrow\left(\left(A\wedge B\right)\Rightarrow C\right)\quad.
\]

\end_inset

It is sufficient to show that one of these implications is incorrect.
 Rather than looking for a proof tree in the constructive logic (which would
 be difficult, since we need to demonstrate that 
\emph on
no
\emph default
 proof exists), let us use the CH correspondence.
 According to the CH correspondence, an equivalent task is to implement
 fully parametric functions with the type signatures:
\begin_inset Formula 
\[
(A\times B\rightarrow C)\rightarrow(A\rightarrow C)+(B\rightarrow C)\quad\text{ and }\quad(A\rightarrow C)+(B\rightarrow C)\rightarrow A\times B\rightarrow C\quad.
\]

\end_inset

For the first type signature, the Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (((A, B)) => C) => Either[A => C, B => C] = { k => ??? }
\end_layout

\end_inset

We are required to return either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(g)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: A => C
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(h)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h: B => C
\end_layout

\end_inset

.
 The only given data is a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 of type 
\begin_inset Formula $A\times B\rightarrow C$
\end_inset

, so the decision of whether to return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 must be hard-coded in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 independently of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

.
 Can we produce a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

? Given a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we would need to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 The only way to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 to some arguments.
 But to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

, we need a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, which we do not have.
 So we cannot produce a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: A => C
\end_layout

\end_inset

.
 Similarly, we cannot produce a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We repeat the same argument in the type notation.
 Obtaining a value of type 
\begin_inset Formula $(A\rightarrow C)+(B\rightarrow C)$
\end_inset

 means to compute either 
\begin_inset Formula $g^{:A\rightarrow C}+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+h^{:B\rightarrow C}$
\end_inset

.
 This decision must be hard-coded since the only data is a function 
\begin_inset Formula $k^{:A\times B\rightarrow C}$
\end_inset

.
 We can compute 
\begin_inset Formula $g^{:A\rightarrow C}$
\end_inset

 only by partially applying 
\begin_inset Formula $k^{:A\times B\rightarrow C}$
\end_inset

 to a value of type 
\begin_inset Formula $B$
\end_inset

.
 However, we have no values of type 
\begin_inset Formula $B$
\end_inset

.
 Similarly, we cannot compute a value 
\begin_inset Formula $h^{:B\rightarrow C}$
\end_inset

.
\end_layout

\begin_layout Standard
The inverse type signature 
\emph on
can
\emph default
 be implemented:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "55col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace 32baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A,B,C]: Either[A=>C, B=>C] => ((A,B)) => C = {
\end_layout

\begin_layout Plain Layout

  case Left(g)    =>   { case (a, b)    => g(a) }
\end_layout

\begin_layout Plain Layout

  case Right(h)   =>   { case (a, b)    => h(b) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -240baselineskip%
\end_inset


\end_layout

\end_inset


\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\[
f_{2}\triangleq\,\begin{array}{|c||c|}
 & A\times B\rightarrow C\\
\hline A\rightarrow C & g^{:A\rightarrow C}\rightarrow a\times b\rightarrow g(a)\\
B\rightarrow C & h^{:B\rightarrow C}\rightarrow a\times b\rightarrow h(b)
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\begin_layout Standard
Let us now show that the logical identity:
\begin_inset Formula 
\begin{equation}
((\alpha\wedge\beta)\Rightarrow\gamma)=((\alpha\Rightarrow\gamma)\vee(\beta\Rightarrow\gamma))\label{eq:ch-example-identity-boolean-not-constructive}
\end{equation}

\end_inset

holds in Boolean logic.
 A straightforward calculation is to simplify the Boolean expression using
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which only holds in Boolean logic (but not in the constructive logic).
 We find:
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:ch-example-identity-boolean-not-constructive})}:\quad & \left(\alpha\wedge\beta\right)\gunderline{\Rightarrow}\,\gamma\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=\gunderline{\neg(\alpha\wedge\beta)}\vee\gamma\\
\text{use de Morgan's law}:\quad & \quad=\neg\alpha\vee\neg\beta\vee\gamma\quad.\\
\text{right-hand side of Eq.~(\ref{eq:ch-example-identity-boolean-not-constructive})}:\quad & (\gunderline{\alpha\Rightarrow\gamma})\vee(\gunderline{\beta\Rightarrow\gamma})\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=\neg\alpha\vee\gunderline{\gamma}\vee\neg\beta\vee\gunderline{\gamma}\\
\text{use identity }\gamma\vee\gamma=\gamma:\quad & \quad=\neg\alpha\vee\neg\beta\vee\gamma\quad.
\end{align*}

\end_inset

Both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are equal to the same formula, 
\begin_inset Formula $\neg\alpha\vee\neg\beta\vee\gamma$
\end_inset

, so the identity holds.
\end_layout

\begin_layout Standard
This calculation does not work in the constructive logic because its proof
 rules can derive neither the Boolean formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) nor the 
\series bold
law of de Morgan
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
law of de Morgan
\end_layout

\end_inset

, 
\begin_inset Formula $\neg(\alpha\wedge\beta)=\left(\neg\alpha\vee\neg\beta\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Another way of proving the Boolean identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is to enumerate all possible truth values for the variables 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

.
 The left-hand side, 
\begin_inset Formula $\left(\alpha\wedge\beta\right)\Rightarrow\gamma$
\end_inset

, can be 
\begin_inset Formula $False$
\end_inset

 only if 
\begin_inset Formula $\alpha\wedge\beta=True$
\end_inset

 (that is, both 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are 
\begin_inset Formula $True$
\end_inset

) and 
\begin_inset Formula $\gamma=False$
\end_inset

.
 For all other truth values of 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

, the formula 
\begin_inset Formula $\left(\alpha\wedge\beta\right)\Rightarrow\gamma$
\end_inset

 is 
\begin_inset Formula $True$
\end_inset

.
 Let us determine when the right-hand side, 
\begin_inset Formula $(\alpha\Rightarrow\gamma)\vee(\beta\Rightarrow\gamma)$
\end_inset

, can be 
\begin_inset Formula $False$
\end_inset

.
 This can happen only if both parts of the disjunction are 
\begin_inset Formula $False$
\end_inset

.
 That means 
\begin_inset Formula $\alpha=True$
\end_inset

, 
\begin_inset Formula $\beta=True$
\end_inset

, and 
\begin_inset Formula $\gamma=False$
\end_inset

.
 So, the two sides of the identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are both 
\begin_inset Formula $True$
\end_inset

 or both 
\begin_inset Formula $False$
\end_inset

 with any choice of truth values of 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

.
 In Boolean logic, this is sufficient to prove the identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The following example shows how to use the formulas from Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to derive the type equivalence of complicated type expressions without
 need for proofs.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known formulas to verify the type equivalences without direct proofs:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $A\times\left(A+\bbnum 1\right)\times\left(A+\bbnum 1+\bbnum 1\right)\cong A\times\left(\bbnum 1+\bbnum 1+A\times\left(\bbnum 1+\bbnum 1+\bbnum 1+A\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\bbnum 1+A+B\rightarrow\bbnum 1\times B\cong\left(B\rightarrow B\right)\times\left(A\rightarrow B\right)\times B$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We can expand brackets in type expressions as in arithmetic:
\begin_inset Formula 
\begin{align*}
A\times\left(A+\bbnum 1\right) & \cong A\times A+A\times\bbnum 1\cong A\times A+A\quad,\\
A\times\left(A+\bbnum 1\right)\times\left(A+\bbnum 1+\bbnum 1\right) & \cong\left(A\times A+A\right)\times\left(A+\bbnum 1+\bbnum 1\right)\\
 & \cong A\times A\times A+A\times A+A\times A\times\left(\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\\
 & \cong A\times A\times A+A\times A\times\left(\bbnum 1+\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\quad.
\end{align*}

\end_inset

The result looks like a polynomial in 
\begin_inset Formula $A$
\end_inset

, which we can now rearrange into the required form:
\begin_inset Formula 
\[
A\times A\times A+A\times A\times\left(\bbnum 1+\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\cong A\times\left(\bbnum 1+\bbnum 1+A\times\left(\bbnum 1+\bbnum 1+\bbnum 1+A\right)\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Keep in mind that the conventions of the type notation make the function
 arrow 
\begin_inset Formula $\left(\rightarrow\right)$
\end_inset

 group weaker than other type operations.
 So, the type expression 
\begin_inset Formula $\bbnum 1+A+B\rightarrow\bbnum 1\times B$
\end_inset

 means a function from 
\begin_inset Formula $\bbnum 1+A+B$
\end_inset

 to 
\begin_inset Formula $\bbnum 1\times B$
\end_inset

.
 
\end_layout

\begin_layout Standard
Begin by using the equivalence 
\begin_inset Formula $\bbnum 1\times B\cong B$
\end_inset

 to obtain 
\begin_inset Formula $\bbnum 1+A+B\rightarrow B$
\end_inset

.
 Now we use another rule:
\begin_inset Formula 
\[
A+B\rightarrow C\cong\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)
\]

\end_inset

and derive the equivalence:
\begin_inset Formula 
\[
\bbnum 1+A+B\rightarrow B\cong\left(\bbnum 1\rightarrow B\right)\times\left(A\rightarrow B\right)\times\left(B\rightarrow B\right)\quad.
\]

\end_inset

Finally, we note that 
\begin_inset Formula $\bbnum 1\rightarrow B\cong B$
\end_inset

 and that the type product is commutative, so we can rearrange the last
 type expression into the required form:
\begin_inset Formula 
\[
B\times\left(A\rightarrow B\right)\times\left(B\rightarrow B\right)\cong\left(B\rightarrow B\right)\times\left(A\rightarrow B\right)\times B\quad.
\]

\end_inset

We obtain the required type expression: 
\begin_inset Formula $\left(B\rightarrow B\right)\times\left(A\rightarrow B\right)\times B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Read}^{E,A}\triangleq E\rightarrow A$
\end_inset

 and implement fully parametric functions with types 
\begin_inset Formula $A\rightarrow\text{Read}^{E,A}$
\end_inset

 and 
\begin_inset Formula $\text{Read}^{E,A}\rightarrow(A\rightarrow B)\rightarrow\text{Read}^{E,B}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by defining a type alias for the type constructor 
\begin_inset Formula $\text{Read}^{E,A}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Read[E, A] = E => A
\end_layout

\end_inset

The first type signature has only one implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[E, A]: A => Read[E, A] = { x => _ => x }
\end_layout

\end_inset

We 
\emph on
must
\emph default
 discard the argument of type 
\begin_inset Formula $E$
\end_inset

; we cannot use it for computing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The second type signature has three type parameters.
 It is the curried version of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: Read[E, A] => (A => B) => Read[E, B] = ???
\end_layout

\end_inset

Expanding the type alias, we see that the two curried arguments are functions
 of types 
\begin_inset Formula $E\rightarrow A$
\end_inset

 and 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 The forward composition of these functions is a function of type 
\begin_inset Formula $E\rightarrow B$
\end_inset

, or 
\begin_inset Formula $\text{Read}^{E,B}$
\end_inset

, which is exactly what we are required to return.
 So, the code can be written as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: (E => A) => (A => B) => E => B = { r => f => r andThen
 f }
\end_layout

\end_inset

If we did not notice this shortcut, we would reason differently: We are
 required to compute a value of type 
\begin_inset Formula $B$
\end_inset

 given 
\emph on
three
\emph default
 curried arguments 
\begin_inset Formula $r^{:E\rightarrow A}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $e^{:E}$
\end_inset

.
 Write this requirement as:
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow???^{:B}\quad,
\]

\end_inset

The symbol 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

 is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
typed hole
\end_layout

\end_inset


\series bold
typed hole
\series default
.
 It stands for a value that we are still figuring out how to compute, but
 whose type is already known.
 Typed holes are supported in Scala by an experimental compiler plugin.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "https://github.com/cb372/scala-typed-holes"
target "https://github.com/cb372/scala-typed-holes"
literal "false"

\end_inset


\end_layout

\end_inset

 The plugin will print the known information about the typed hole.
\end_layout

\begin_layout Standard
To fill the typed hole 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

, we need a value of type 
\begin_inset Formula $B$
\end_inset

.
 Since no arguments have type 
\begin_inset Formula $B$
\end_inset

, the only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to some value of type 
\begin_inset Formula $A$
\end_inset

.
 So we write:
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow f(???^{:A})\quad.
\]

\end_inset

The only way of getting an 
\begin_inset Formula $A$
\end_inset

 is to apply 
\begin_inset Formula $r$
\end_inset

 to some value of type 
\begin_inset Formula $E$
\end_inset

:
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow f(r(???^{:E}))\quad.
\]

\end_inset

We have exactly one value of type 
\begin_inset Formula $E$
\end_inset

, namely 
\begin_inset Formula $e^{:E}$
\end_inset

.
 So, the code must be:
\begin_inset Formula 
\[
\text{map}^{E,A,B}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow f(r(e))\quad.
\]

\end_inset

Translate this to the Scala syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: (E => A) => (A => B) => E => B = { r => f => e => f(r(e))
 }
\end_layout

\end_inset

We may now notice that the expression 
\begin_inset Formula $e\rightarrow f(r(e))$
\end_inset

 is a function composition 
\begin_inset Formula $r\bef f$
\end_inset

 applied to 
\begin_inset Formula $e$
\end_inset

, and simplify the code accordingly.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Read[A, T] => (A => B) => Read[B, T]
\end_layout

\end_inset

 cannot be implemented as a fully parametric function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Expand the type signature and try implementing this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def m[A, B, T] : (A => T) => (A => B) => B => T = { r => f => b => ??? }
\end_layout

\end_inset

Given values 
\begin_inset Formula $r^{:A\rightarrow T}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $b^{:B}$
\end_inset

, we need to compute a value of type 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\[
m=r^{:A\rightarrow T}\rightarrow f^{:A\rightarrow B}\rightarrow b^{:B}\rightarrow???^{:T}\quad.
\]

\end_inset

The only way of getting a value of type 
\begin_inset Formula $T$
\end_inset

 is to apply 
\begin_inset Formula $r$
\end_inset

 to some value of type 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
m=r^{:A\rightarrow T}\rightarrow f^{:A\rightarrow B}\rightarrow b^{:B}\rightarrow r(???^{:A})\quad.
\]

\end_inset

However, we do not have any values of type 
\begin_inset Formula $A$
\end_inset

.
 We have a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 that 
\emph on
consumes
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

, and we cannot use 
\begin_inset Formula $f$
\end_inset

 to produce any values of type 
\begin_inset Formula $A$
\end_inset

.
 So, it seems that we are unable to fill the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

 and implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In order to verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 is unimplementable, we need to prove that the logical formula:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta,\tau).\,(\alpha\Rightarrow\tau)\Rightarrow(\alpha\Rightarrow\beta)\Rightarrow(\beta\Rightarrow\tau)\label{eq:ch-example-boolean-formula-3}
\end{equation}

\end_inset

is not true in the constructive logic.
 We could use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library for that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def m[A, B, T] : (A => T) => (A => B) => B => T = implement
\end_layout

\begin_layout Plain Layout

cmd1.sc:1: type (A => T) => (A => B) => B => T cannot be implemented
\end_layout

\begin_layout Plain Layout

def m[A, B, T] : (A => T) => (A => B) => B => T = implement
\end_layout

\begin_layout Plain Layout

                                                ^
\end_layout

\begin_layout Plain Layout

Compilation Failed
\end_layout

\end_inset

Another way is to check whether this formula is true in Boolean logic.
 A formula that holds in constructive logic will always hold in Boolean
 logic, because all rules shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 preserve Boolean truth values (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relationship-between-Boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a proof).
 It follows that any formula that fails to hold in Boolean logic will also
 not hold in constructive logic.
 
\end_layout

\begin_layout Standard
It is relatively easy to check whether a given Boolean formula is always
 equal to 
\begin_inset Formula $True$
\end_inset

.
 Simplifying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-formula-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with the rules of Boolean logic, we find:
\begin_inset Formula 
\begin{align*}
 & (\alpha\Rightarrow\tau)\,\gunderline{\Rightarrow}\,(\alpha\Rightarrow\beta)\,\gunderline{\Rightarrow}\,(\beta\Rightarrow\tau)\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\neg(\gunderline{\alpha\Rightarrow\tau})\vee\neg(\gunderline{\alpha\Rightarrow\beta})\vee(\gunderline{\beta\Rightarrow\tau})\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\gunderline{\neg(\neg\alpha\vee\tau)}\vee\gunderline{\neg(\neg\alpha\vee\beta)}\vee(\neg\beta\vee\tau)\\
\text{use de Morgan's law}:\quad & =\left(\alpha\wedge\neg\tau\right)\vee\gunderline{\left(\alpha\wedge\neg\beta\right)\vee\neg\beta}\vee\tau\\
\text{use identity }(p\wedge q)\vee q=q:\quad & =\gunderline{\left(\alpha\wedge\neg\tau\right)}\vee\neg\beta\vee\gunderline{\tau}\\
\text{use identity }(p\wedge\neg q)\vee q=p\vee q:\quad & =\alpha\vee\neg\beta\vee\tau\quad.
\end{align*}

\end_inset

This formula is not identically 
\begin_inset Formula $True$
\end_inset

: it is 
\begin_inset Formula $False$
\end_inset

 when 
\begin_inset Formula $\alpha=\tau=False$
\end_inset

 and 
\begin_inset Formula $\beta=True$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-formula-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is not true in Boolean logic, therefore it is also not true in constructive
 logic.
 By the CH correspondence, we conclude that the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 cannot be implemented by a fully parametric function.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define the type constructor 
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A+A$
\end_inset

 and implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for it:
\begin_inset Formula 
\[
\text{map}^{A,B}:P^{A}\rightarrow(A\rightarrow B)\rightarrow P^{B}\quad.
\]

\end_inset

To check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 preserves information, verify the law 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(p)(x => x) == p
\end_layout

\end_inset

 for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: P[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
It is implied that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 should be fully parametric and information-preserving.
 Begin by defining a Scala type constructor for the notation 
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A+A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A]()     extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](x: A) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](x: A) extends P[A]
\end_layout

\end_inset

Now we can write code to implement the required type signature.
 Each time we have several choices of an implementation, we will choose
 to preserve information as much as possible.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: P[A] => (A => B) => P[B] =
\end_layout

\begin_layout Plain Layout

  p => f => p match {
\end_layout

\begin_layout Plain Layout

    case P1()    => P1() // No other choice.
\end_layout

\begin_layout Plain Layout

    case P2(x)   => ???
\end_layout

\begin_layout Plain Layout

    case P3(x)   => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\begin_inset VSpace -90baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(x)
\end_layout

\end_inset

, we are required to produce a value of type 
\begin_inset Formula $P^{B}$
\end_inset

 from a value 
\begin_inset Formula $x^{:A}$
\end_inset

 and a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Since 
\begin_inset Formula $P^{B}$
\end_inset

 is a disjunctive type with three parts, we can produce a value of type
 
\begin_inset Formula $P^{B}$
\end_inset

 in three different ways: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P1()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(...)
\end_layout

\end_inset

.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P1()
\end_layout

\end_inset

, we will lose the information about the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(...)
\end_layout

\end_inset

, we will preserve the information about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 but lose the information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 that the input value was a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2
\end_layout

\end_inset

 rather than a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3
\end_layout

\end_inset

.
 By returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

 in that scope, we preserve the entire input information.
 
\end_layout

\begin_layout Standard
The value under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

 must be of type 
\begin_inset Formula $B$
\end_inset

, and the only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f$
\end_inset

 to 
\begin_inset Formula $x$
\end_inset

.
 So, we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(f(x))
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Similarly, in the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(x)
\end_layout

\end_inset

, we should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(f(x))
\end_layout

\end_inset

.
 The final code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: P[A] => (A => B) => P[B] = p => f => p match {
\end_layout

\begin_layout Plain Layout

  case P1()    => P1()         // No other choice here.
\end_layout

\begin_layout Plain Layout

  case P2(x)   => P2(f(x))    // Preserve information.
\end_layout

\begin_layout Plain Layout

  case P3(x)   => P3(f(x))    // Preserve information.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify the given law, we first write a matrix notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{map}^{A,B}\triangleq p^{:\bbnum 1+A+A}\rightarrow f^{:A\rightarrow B}\rightarrow p\triangleright\,\begin{array}{|c||ccc|}
 & \bbnum 1 & B & B\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & f & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & f
\end{array}\quad.
\]

\end_inset

The required law is written as an equation 
\begin_inset Formula $\text{map}\left(p\right)(\text{id})=p$
\end_inset

, called the
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
map
\end_layout

\end_inset

 
\series bold
identity law
\series default
.
 Substituting the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we verify the law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p:\quad & \text{map}\left(p\right)(\text{id})\\
\text{apply \texttt{map()()} to arguments}:\quad & =p\triangleright\,\begin{array}{||ccc|}
\text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 0 & \text{id} & \bbnum 0\\
\bbnum 0 & \bbnum 0 & \text{id}
\end{array}\\
\text{identity function in matrix notation}:\quad & =p\triangleright\text{id}\\
\triangleright\text{-notation}:\quad & =\text{id}\left(p\right)=p\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[L, R]
\end_layout

\end_inset

, applied to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For a type constructor, say, 
\begin_inset Formula $P^{A}$
\end_inset

, the standard type signatures for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 are:
\begin_inset Formula 
\[
\text{map}:P^{A}\rightarrow(A\rightarrow B)\rightarrow P^{B}\quad,\quad\quad\text{flatMap}:P^{A}\rightarrow(A\rightarrow P^{B})\rightarrow P^{B}\quad.
\]

\end_inset

If a type constructor has more than one type parameter, e.g., 
\begin_inset Formula $P^{A,S,T}$
\end_inset

, one can define the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 applied to a chosen type parameter.
 For example, when applied to the type parameter 
\begin_inset Formula $A$
\end_inset

, the type signatures are:
\begin_inset Formula 
\begin{align*}
\text{map} & :P^{A,S,T}\rightarrow(A\rightarrow B)\rightarrow P^{B,S,T}\quad,\\
\text{flatMap} & :P^{A,S,T}\rightarrow(A\rightarrow P^{B,S,T})\rightarrow P^{B,S,T}\quad.
\end{align*}

\end_inset

Being 
\begin_inset Quotes eld
\end_inset

applied to the type parameter 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 means that the other type parameters 
\begin_inset Formula $S,T$
\end_inset

 in 
\begin_inset Formula $P^{A,S,T}$
\end_inset

 remain fixed while the type parameter 
\begin_inset Formula $A$
\end_inset

 is replaced by 
\begin_inset Formula $B$
\end_inset

 in the type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[L, R]
\end_layout

\end_inset

 (in the type notation, 
\begin_inset Formula $L+R$
\end_inset

), we keep the type parameter 
\begin_inset Formula $R$
\end_inset

 fixed while 
\begin_inset Formula $L$
\end_inset

 is replaced by 
\begin_inset Formula $M$
\end_inset

.
 So we obtain the type signatures:
\begin_inset Formula 
\begin{align*}
\text{map} & :L+R\rightarrow(L\rightarrow M)\rightarrow M+R\quad,\\
\text{flatMap} & :L+R\rightarrow(L\rightarrow M+R)\rightarrow M+R\quad.
\end{align*}

\end_inset

Implementing these functions is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[L,M,R]: Either[L, R] => (L => M) => Either[M, R] = e => f => e match
 {
\end_layout

\begin_layout Plain Layout

  case Left(x)    => Left(f(x))
\end_layout

\begin_layout Plain Layout

  case Right(y)   => Right(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def flatMap[L,M,R]: Either[L, R] => (L => Either[M, R]) => Either[M, R]
 = e => f => e match {
\end_layout

\begin_layout Plain Layout

  case Left(x)    => f(x)
\end_layout

\begin_layout Plain Layout

  case Right(y)   => Right(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code notation for these functions is:
\begin_inset Formula 
\begin{align*}
\text{map} & \triangleq e^{:L+R}\rightarrow f^{:L\rightarrow M}\rightarrow e\triangleright\,\begin{array}{|c||cc|}
 & M & R\\
\hline L & f & \bbnum 0\\
R & \bbnum 0 & \text{id}
\end{array}\quad,\\
\text{flatMap} & \triangleq e^{:L+R}\rightarrow f^{:L\rightarrow M+R}\rightarrow e\triangleright\,\begin{array}{|c||c|}
 & M+R\\
\hline L & f\\
R & y^{:R}\rightarrow\bbnum 0^{:M}+y
\end{array}\quad.
\end{align*}

\end_inset

Note that we cannot split 
\begin_inset Formula $f$
\end_inset

 into the 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 columns since we do not know in advance which part of the disjunctive type
 
\begin_inset Formula $M+R$
\end_inset

 is returned by 
\begin_inset Formula $f(x^{:L})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-9"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Define a type constructor 
\begin_inset Formula $\text{State}^{S,A}\equiv S\rightarrow A\times S$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{pure}^{S,A}:A\rightarrow\text{State}^{S,A}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{map}^{S,A,B}:\text{State}^{S,A}\rightarrow(A\rightarrow B)\rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\text{flatMap}^{S,A,B}:\text{State}^{S,A}\rightarrow(A\rightarrow\text{State}^{S,B})\rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
It is assumed that all functions must be fully parametric and preserve as
 much information as possible.
 We define the type alias:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type State[S, A] = S => (A, S)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The type signature is 
\begin_inset Formula $A\rightarrow S\rightarrow A\times S$
\end_inset

, and there is only one implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[S, A]: A => State[S, A] = a => s => (a, s)
\end_layout

\end_inset

In the code notation, this is written as:
\begin_inset Formula 
\[
\text{pu}^{S,A}\triangleq a^{:A}\rightarrow s^{:S}\rightarrow a\times s\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The type signature is:
\begin_inset Formula 
\[
\text{map}^{S,A,B}:(S\rightarrow A\times S)\rightarrow(A\rightarrow B)\rightarrow S\rightarrow B\times S\quad.
\]

\end_inset

Begin writing a Scala implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[S, A, B]: State[S, A] => (A => B) => State[S, B] = { t => f => s
 => ??? }
\end_layout

\end_inset

We need to compute a value of 
\begin_inset Formula $B\times S$
\end_inset

 from the curried arguments 
\begin_inset Formula $t^{:S\rightarrow A\times S}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $s^{:S}$
\end_inset

.
 We begin writing the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 using a typed hole:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow s^{:S}\rightarrow\text{???}^{:B}\times\text{???}^{:S}\quad.
\]

\end_inset

The only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is by applying 
\begin_inset Formula $f$
\end_inset

 to a value of type 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow s^{:S}\rightarrow f(\text{???}^{:A})\times\text{???}^{:S}\quad.
\]

\end_inset

The only possibility of filling the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

 is to apply 
\begin_inset Formula $t$
\end_inset

 to a value of type 
\begin_inset Formula $S$
\end_inset

.
 We already have such a value, 
\begin_inset Formula $s^{:S}$
\end_inset

.
 Computing 
\begin_inset Formula $t(s)$
\end_inset

 yields a pair of type 
\begin_inset Formula $A\times S$
\end_inset

, from which we may take the first part (of type 
\begin_inset Formula $A$
\end_inset

) to fill the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

.
 The second part of the pair is a value of type 
\begin_inset Formula $S$
\end_inset

 that we may use to fill the second typed hole, 
\begin_inset Formula $\text{???}^{:S}$
\end_inset

.
 So, the Scala code is:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "62col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def map[S, A, B]: State[S, A] => (A => B) => State[S, B] = {
\end_layout

\begin_layout Plain Layout

  t => f => s =>
\end_layout

\begin_layout Plain Layout

    val (a, s2) = t(s)
\end_layout

\begin_layout Plain Layout

    (f(a), s2)     // We could also return `(f(a), s)` here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -125baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Why not return the original value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 in the tuple 
\begin_inset Formula $B\times S$
\end_inset

, instead of the new value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

? The reason is that we would like to preserve information as much as possible.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f(a), s)
\end_layout

\end_inset

 in line 4, we will have discarded the computed value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

, which is a loss of information.
\end_layout

\begin_layout Standard
To write the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we need to destructure the pair that 
\begin_inset Formula $t(s)$
\end_inset

 returns.
 We can write explicit destructuring code like this:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow s^{:S}\rightarrow(a^{:A}\times s_{2}^{:S}\rightarrow f(a)\times s_{2})(t(s))\quad.
\]

\end_inset

If we temporarily denote by 
\begin_inset Formula $q$
\end_inset

 the following destructuring function:
\begin_inset Formula 
\[
q\triangleq(a^{:A}\times s_{2}^{:S}\rightarrow f(a)\times s_{2})\quad,
\]

\end_inset

we will notice that the expression 
\begin_inset Formula $s\rightarrow q(t(s))$
\end_inset

 is a function composition applied to 
\begin_inset Formula $s$
\end_inset

.
 So, we rewrite 
\begin_inset Formula $s\rightarrow q(t(s))$
\end_inset

 as the composition 
\begin_inset Formula $t\bef q$
\end_inset

 and obtain shorter code:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow t\bef(a^{:A}\times s^{:S}\rightarrow f(a)\times s)\quad.
\]

\end_inset

Shorter formulas are often easier to reason about in derivations, although
 not necessarily easier to read when converted to program code.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The required type signature is:
\begin_inset Formula 
\[
\text{flatMap}^{S,A,B}:(S\rightarrow A\times S)\rightarrow(A\rightarrow S\rightarrow B\times S)\rightarrow S\rightarrow B\times S\quad.
\]

\end_inset

We perform code reasoning with typed holes:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow s^{:S}\rightarrow\text{???}^{:B\times S}\quad.
\]

\end_inset

To fill 
\begin_inset Formula $\text{???}^{:B\times S}$
\end_inset

, we need to apply 
\begin_inset Formula $f$
\end_inset

 to some arguments, since 
\begin_inset Formula $f$
\end_inset

 is the only function that returns any values of type 
\begin_inset Formula $B$
\end_inset

.
 Applying 
\begin_inset Formula $f$
\end_inset

 to two values will yield a value of type 
\begin_inset Formula $B\times S$
\end_inset

, just as we need:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow s^{:S}\rightarrow f(\text{???}^{:A})(\text{???}^{:S})\quad.
\]

\end_inset

To fill the new typed holes, we need to apply 
\begin_inset Formula $t$
\end_inset

 to an argument of type 
\begin_inset Formula $S$
\end_inset

.
 We have only one given value 
\begin_inset Formula $s^{:S}$
\end_inset

 of type 
\begin_inset Formula $S$
\end_inset

, so we must compute 
\begin_inset Formula $t(s)$
\end_inset

 and destructure it:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow s^{:S}\rightarrow\left(a\times s_{2}\rightarrow f(a)(s_{2})\right)(t(s))\quad.
\]

\end_inset

Translating this notation into Scala code, we obtain:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[S, A, B]: State[S, A] => (A => State[S, B]) => State[S, B] =
 {
\end_layout

\begin_layout Plain Layout

  t => f => s =>
\end_layout

\begin_layout Plain Layout

    val (a, s2) = t(s)
\end_layout

\begin_layout Plain Layout

    f(a)(s2)            // We could also return `f(a)(s)` here, but that
 would lose information.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In order to preserve information, we choose not to discard the computed
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The code notation for this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 can be simplified to:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow t\bef\left(a\times s\rightarrow f(a)(s)\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-0"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-0"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the cardinality of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Option[Boolean => Option[Boolean]]
\end_layout

\end_inset

.
 Show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean] => Boolean
\end_layout

\end_inset

, and that the equivalence is accidental
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!accidental
\end_layout

\end_inset

 and not 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-1-a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-1-a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalences 
\begin_inset Formula $A+A\cong\bbnum 2\times A$
\end_inset

 and 
\begin_inset Formula $A\times A\cong\bbnum 2\rightarrow A$
\end_inset

, where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $A\Rightarrow(B\vee C)\neq(A\Rightarrow B)\wedge(A\Rightarrow C)$
\end_inset

 in constructive and Boolean logic.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\left(A\rightarrow B\times C\right)\cong\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)$
\end_inset

 with full proofs.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-type-identity-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-type-identity-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known rules to verify the type equivalences without need for proofs:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\left(A+B\right)\times\left(A\rightarrow B\right)\cong A\times\left(A\rightarrow B\right)+\left(\bbnum 1+A\rightarrow B\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\left(A\times(\bbnum 1+A)\rightarrow B\right)\cong\left(A\rightarrow B\right)\times\left(A\rightarrow A\rightarrow B\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $A\rightarrow\left(\bbnum 1+B\right)\rightarrow C\times D\cong\left(A\rightarrow C\right)\times\left(A\rightarrow D\right)\times\left(A\times B\rightarrow C\right)\times\left(A\times B\rightarrow D\right)\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, Int), Either[(A, Char), (A, Float)]]
\end_layout

\end_inset

.
 Transform this type into an equivalent type of the form 
\begin_inset Formula $A\times(...)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a type 
\begin_inset Formula $\text{OptE}^{T,A}\triangleq\bbnum 1+T+A$
\end_inset

 and implement information-preserving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for it, applied to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 Get the same result using the equivalent type 
\begin_inset Formula $(\bbnum 1+A)+T$
\end_inset

, i.e., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Option[A], T]
\end_layout

\end_inset

.
 The required type signatures are:
\begin_inset Formula 
\begin{align*}
\text{map}^{A,B,T} & :\text{OptE}^{T,A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{OptE}^{T,B}\quad,\\
\text{flatMap}^{A,B,T} & :\text{OptE}^{T,A}\rightarrow(A\rightarrow\text{OptE}^{T,B})\rightarrow\text{OptE}^{T,B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A]
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required type signature is 
\begin_inset Formula $P^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow P^{B}$
\end_inset

.
 Preserve information as much as possible.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the type constructor 
\begin_inset Formula $Q^{T,A}$
\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function, preserving information as much as possible:
\begin_inset Formula 
\[
\text{map}^{T,A,B}:Q^{T,A}\rightarrow\left(A\rightarrow B\right)\rightarrow Q^{T,B}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a recursive type constructor 
\begin_inset Formula $\text{Tr}_{3}$
\end_inset

 as 
\begin_inset Formula $\text{Tr}_{3}{}^{A}\triangleq\bbnum 1+A\times A\times A\times\text{Tr}_{3}{}^{A}$
\end_inset

 and implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for it, with the standard type signature: 
\begin_inset Formula $\text{map}^{A,B}:\text{Tr}_{3}{}^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Tr}_{3}{}^{B}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement fully parametric, information-preserving functions with the types:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $Z+A\times A\rightarrow(A\rightarrow B)\rightarrow Z+B\times B\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $A+Z\rightarrow B+Z\rightarrow(A\rightarrow B\rightarrow C)\rightarrow C+Z\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $P+A\times A\rightarrow(A\rightarrow B)\rightarrow(P\rightarrow A+Q)\rightarrow Q+B\times B\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $\text{flatMap}^{E,A,B}:\text{Read}^{E,A}\rightarrow(A\rightarrow\text{Read}^{E,B})\rightarrow\text{Read}^{E,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $\text{State}^{S,A}\rightarrow\left(S\times A\rightarrow B\right)\rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Cont}^{R,T}\triangleq\left(T\rightarrow R\right)\rightarrow R$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{map}^{R,T,U}:\text{Cont}^{R,T}\rightarrow(T\rightarrow U)\rightarrow\text{Cont}^{R,U}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{flatMap}^{R,T,U}:\text{Cont}^{R,T}\rightarrow(T\rightarrow\text{Cont}^{R,U})\rightarrow\text{Cont}^{R,U}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-8"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Sel}^{Z,T}\triangleq\left(T\rightarrow Z\right)\rightarrow T$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{map}^{Z,A,B}:\text{Sel}^{Z,A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Sel}^{Z,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{flatMap}^{Z,A,B}:\text{Sel}^{Z,A}\rightarrow(A\rightarrow\text{Sel}^{Z,B})\rightarrow\text{Sel}^{Z,B}\quad.$
\end_inset


\end_layout

\begin_layout Section
Discussion and further developments
\end_layout

\begin_layout Subsection
Using the Curry-Howard correspondence for writing code
\end_layout

\begin_layout Standard
The CH correspondence is used in two practically important reasoning tasks:
 checking whether a type signature can be implemented as a fully parametric
 function, and determining whether two types are equivalent.
 For the first task, we map type expressions into formulas in the constructive
 logic and apply the proof rules of that logic.
 For the second task, we map type expressions into 
\emph on
arithmetic
\emph default
 formulas and apply the ordinary rules of arithmetic.
\end_layout

\begin_layout Standard
Although tools such as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library can sometimes derive code from types, it is beneficial if a programmer
 is able to derive an implementation by hand or to determine that an implementat
ion is impossible.
 For instance, the programmer should recognize that the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (A => B) => B
\end_layout

\end_inset

has only one fully parametric implementation, while the following two type
 signatures have none:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g[A, B]: A => (B => A) => B
\end_layout

\begin_layout Plain Layout

def h[A, B]: ((A => B) => A) => A
\end_layout

\end_inset

Exercises in this chapter help to build up the required technique and intuition.
 For instance, we use heuristics such as 
\begin_inset Quotes eld
\end_inset

values of parametric types cannot be constructed from scratch
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

one must hard-code the decision to return a chosen part of a disjunctive
 type
\begin_inset Quotes erd
\end_inset

.
 These heuristics can be justified by the rigorous rules of proof (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For instance, sequents producing a value of type 
\begin_inset Formula $A$
\end_inset

 can be proved only if there are premises that contain 
\begin_inset Formula $A$
\end_inset

 or a function that returns a value of type 
\begin_inset Formula $A$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
This is proved rigorously in the paper 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://research-repository.st-andrews.ac.uk/handle/10023/8824"
literal "false"

\end_inset


\family default
 (2016) by R.
\begin_inset space ~
\end_inset

Dyckhoff.
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Roy Dyckhoff
\end_layout

\end_inset

 See the 
\begin_inset Quotes eld
\end_inset

Theorem
\begin_inset Quotes erd
\end_inset

 in section 6 (
\begin_inset Quotes eld
\end_inset

Goal-directed pruning
\begin_inset Quotes erd
\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Throughout this chapter, we require all code to be fully parametric.
 The reason is that the CH correspondence is useful only for parameterized
 types and fully parametric code.
 For concrete, non-parameterized types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, etc.), one can always produce 
\emph on
some
\emph default
 values even with no previous data.
 So, the propositions 
\begin_inset Formula $\mathcal{CH}(\text{Int})$
\end_inset

 or 
\begin_inset Formula $\mathcal{CH}(\text{String})$
\end_inset

 are 
\emph on
always
\emph default
 true within any code.
\end_layout

\begin_layout Standard
Consider the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:Int) => x + 1
\end_layout

\end_inset

.
 Its type signature, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, may be implemented by many other functions, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x - 1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x * 2
\end_layout

\end_inset

, etc.
 So, the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 is insufficient to specify the code of the function, and deriving code
 from that type is not a meaningful task.
 Only a fully parametric type signature, such as 
\begin_inset Formula $A\rightarrow\left(A\rightarrow B\right)\rightarrow B$
\end_inset

, might give enough information for deriving the function's code.
 If we permit functions that are not fully parametric, we will not be able
 to reason about implementability of type signatures or about code derivation.
\end_layout

\begin_layout Standard
Information about the implementability of type signatures is given by logical
 formulas involving 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 Validity of a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 means that we can compute 
\emph on
some
\emph default
 value of the given type 
\begin_inset Formula $T$
\end_inset

.
 But this does not yet give any information about the properties of that
 value, such as whether it satisfies any laws.
 This is why type equivalence (which requires the laws of isomorphism) is
 not determined by an equivalence of logical formulas.
\end_layout

\begin_layout Standard
It is useful for programmers to be able to transform type expressions to
 equivalent simpler types before starting to write code.
 The type notation introduced in this book is designed to help programmers
 to recognize patterns in type expressions and to reason about them more
 easily.
 We have shown that a type equivalence corresponds to 
\emph on
each
\emph default
 standard arithmetic identity such as 
\begin_inset Formula $\left(a+b\right)+c=a+\left(b+c\right)$
\end_inset

, 
\begin_inset Formula $\left(a\times b\right)\times c=a\times(b\times c)$
\end_inset

, 
\begin_inset Formula $1\times a=a$
\end_inset

, 
\begin_inset Formula $\left(a+b\right)\times c=a\times c+b\times c$
\end_inset

, and so on.
 Because of this, we are allowed to transform and simplify types as if they
 were arithmetic expressions, e.g., to rewrite:
\begin_inset Formula 
\[
\bbnum 1\times\left(A+B\right)\times C+D\cong D+A\times C+B\times C\quad.
\]

\end_inset

The type notation makes this reasoning more intuitive (for people familiar
 with arithmetic).
 
\end_layout

\begin_layout Standard
These results apply to all type expressions built up using product types,
 disjunctive types (also called 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 types because they correspond to arithmetic sums), and function types (also
 called 
\begin_inset Quotes eld
\end_inset

exponential
\begin_inset Quotes erd
\end_inset

 types because they correspond to arithmetic exponentials).
 Type expressions that contain only products and sum types are called 
\series bold
polynomial
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!polynomial types
\end_layout

\end_inset

.
 Type expressions that also contain function types may be called 
\series bold
exponential-polynomial
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!exponential-polynomial types
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
Polynomial types are often called 
\begin_inset Quotes eld
\end_inset

algebraic data types
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic data types
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 This book focuses on exponential-polynomial types because they are sufficient
 for almost all design patterns used in functional programming.
\end_layout

\begin_layout Standard
There are no types corresponding to subtraction or division, so arithmetic
 equations such as:
\begin_inset Formula 
\begin{align*}
\left(1-t\right)\times\left(1+t\right) & =1-t\times t\quad\text{or }\quad\frac{t+t\times t}{t}=1+t
\end{align*}

\end_inset

do not directly yield any type equivalences.
 However, consider this well-known formula:
\begin_inset Formula 
\[
\frac{1}{1-t}=1+t+t^{2}+t^{3}+...+t^{n}+...\quad.
\]

\end_inset

At first sight, this formula appears to involve subtraction, division, and
 an infinite series, and so cannot be directly translated into a type equivalenc
e.
 However, the formula can be rewritten as:
\begin_inset Formula 
\begin{equation}
\frac{1}{1-t}\triangleq L(t)=1+t+t^{2}+t^{3}+...+t^{n}\times L(t)\quad,\label{eq:ch-example-type-formula-list}
\end{equation}

\end_inset

which is finite and only contains additions and multiplications.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-type-formula-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be translated into a type equivalence:
\begin_inset Formula 
\begin{equation}
L^{A}\cong1+A+A\times A+A\times A\times A+...+\underbrace{A\times...\times A}_{n\text{ times}}\times\,L^{A}\quad.\label{eq:ch-example-type-expansion-list}
\end{equation}

\end_inset

This type formula (with 
\begin_inset Formula $n=1$
\end_inset

) is equivalent to a recursive definition of the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq1+A\times\text{List}^{A}\quad.
\]

\end_inset

The type equivalence
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-type-expansion-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) suggests that we may view the recursive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 heuristically as an 
\begin_inset Quotes eld
\end_inset

infinite disjunction
\begin_inset Quotes erd
\end_inset

 describing lists of zero, one, etc., elements.
\end_layout

\begin_layout Subsection
Implications for designing new programming languages
\end_layout

\begin_layout Standard
Today's functional programming practice assumes, at the minimum, that programmer
s will use the six standard type constructions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-notation-and-standard-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the eight standard code constructions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 These constructions are foundational in the sense that they are used to
 express all design patterns of functional programming.
 A language that does not directly support some of these constructions cannot
 be considered a functional programming language.
\end_layout

\begin_layout Standard
A remarkable consequence of the CH correspondence is that the type system
 of any programming language (functional or not) is mapped into a 
\emph on
certain
\emph default
 
\emph on
logic
\emph default
, i.e., a system of logical operations and proof rules.
 A logical operation will correspond to each of the 
\emph on
type
\emph default
 constructions available in the programming language.
 A proof rule will correspond to each of the available 
\emph on
code
\emph default
 constructions.
 Functional programming languages that support all the standard type and
 code constructions — for instance, OCaml, Haskell, F#, Scala, Swift, Rust,
 — are mapped into the constructive logic with all standard logical operations
 available (
\begin_inset Formula $True$
\end_inset

, 
\begin_inset Formula $False$
\end_inset

, disjunction, conjunction, and implication).
\end_layout

\begin_layout Standard
Languages such as C, C++, Java, C#, Go are mapped into logics that do not
 have the disjunction operation or the constants 
\begin_inset Formula $True$
\end_inset

 and 
\begin_inset Formula $False$
\end_inset

.
 In other words, these languages are mapped into 
\emph on
incomplete
\emph default
 logics where some true formulas cannot be proved.
 Incompleteness of the logic of types will make a programming language unable
 to express certain computations, e.g., directly handle data that belongs
 to a disjoint domain.
 
\end_layout

\begin_layout Standard
Languages such as Python and JavaScript do not enforce type checking and
 so are mapped to inconsistent logics where any proposition can be proved
 — even propositions normally considered 
\begin_inset Formula $False$
\end_inset

.
 The CH correspondence will map such proofs to code that 
\emph on
appears
\emph default
 to compute a certain value (since the 
\begin_inset Formula $\mathcal{CH}$
\end_inset

-proposition appears to be 
\begin_inset Formula $True$
\end_inset

) although that value is not actually available.
 In practice, such code will crash when trying to use a value that has a
 wrong type, is 
\begin_inset Quotes eld
\end_inset

null
\begin_inset Quotes erd
\end_inset

, or is a pointer to an invalid memory location.
 These errors will not happen in a programming language whose logic of types
 is consistent, and whose compiler checks all types at compile time.
 
\end_layout

\begin_layout Standard
So, the CH correspondence gives a mathematically justified procedure for
 designing new programming languages.
 The procedure has the following steps:
\end_layout

\begin_layout Itemize
Choose a formal logic that is complete and free of inconsistencies.
\end_layout

\begin_layout Itemize
For each logical operation, provide a type construction in the language.
\end_layout

\begin_layout Itemize
For each proof rule or axiom of the logic, provide a code construction in
 the language.
\end_layout

\begin_layout Standard
Mathematicians have studied different logics, such as modal logic, temporal
 logic, or linear logic.
 Compared with the constructive logic, these other logics have some additional
 type operations.
 For instance, modal logic adds the operations 
\begin_inset Quotes eld
\end_inset

necessarily
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

possibly
\begin_inset Quotes erd
\end_inset

, and temporal logic adds the operation 
\begin_inset Quotes eld
\end_inset

until
\begin_inset Quotes erd
\end_inset

.
 For each logic, mathematicians have determined the minimal complete sets
 of operations, axioms, and proof rules that do not lead to inconsistency.
 Programming language designers can use this mathematical knowledge by choosing
 a logic and translating it into a minimal 
\begin_inset Quotes eld
\end_inset

core
\begin_inset Quotes erd
\end_inset

 of a programming language.
 Code in that language will be guaranteed 
\emph on
never to crash
\emph default
 as long as all types match.
 This mathematical guarantee (known as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type safety
\end_layout

\end_inset


\series bold
type safety
\series default
) is a powerful help for programmers since it automatically prevents a large
 number of coding errors.
 So, programmers will benefit if they use languages designed using the CH
 correspondence.
\end_layout

\begin_layout Standard
Practically useful programming languages will have more features than the
 minimal, mathematically necessary constructions derived from a chosen logic.
 Language designers need to make sure that the new features are consistent
 with the core language.
 
\end_layout

\begin_layout Standard
At present, it is still not fully understood how a practical programming
 language could use, say, modal or linear logic as its logic of types.
 Experience suggests that, at least, the operations of the plain constructive
 logic should be available.
 So, it appears that the six type constructions and the eight code constructions
 will remain available in all future languages of functional programming.
 
\end_layout

\begin_layout Standard
It is possible to apply the FP paradigm while writing code in any programming
 language.
 However, some languages lack certain features that make FP techniques easier
 to use in practice.
 For example, in a language such as JavaScript, Python, or Ruby, one can
 productively use the map/reduce operations but not disjunctive types.
 More advanced FP constructions (such as typeclasses) are impractical in
 these languages because the required code becomes too hard to read and
 to write without errors, which negates the advantages of rigorous reasoning
 about functional programs.
\end_layout

\begin_layout Standard
Some programming languages, such as Haskell and OCaml, were designed specificall
y for advanced use in the FP paradigm.
 Other languages, such as F#, Scala, Swift, PureScript, Elm, and Rust, have
 different design goals but still support enough FP features to be considered
 FP languages.
 This book uses Scala, but the same constructions may be implemented in
 other FP languages in a similar way.
 At the level of detail needed in this book, the differences between languages
 such as OCaml, Haskell, F#, Scala, Swift, PureScript, Elm, and Rust, do
 not play a significant role.
\end_layout

\begin_layout Subsection
Uses of the void type (Scala's 
\family typewriter
Nothing
\family default
)
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

void type
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset

void
\begin_inset Quotes erd
\end_inset

 type as defined in this book is a type with no values.
 It is not the same as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

void
\end_layout

\end_inset

 keyword Java or C, which is used for functions without a return value.
 These functions are equivalent to Scala's functions returning the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
\end_layout

\end_inset

 (Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

) corresponds to the logical constant 
\begin_inset Formula $False$
\end_inset

.
 (The proposition 
\begin_inset Quotes eld
\end_inset


\emph on
a value of the void type can be computed
\emph default

\begin_inset Quotes erd
\end_inset

 is always false.) There are few practical uses of the void type.
 One use case is for a branch of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression that throws an 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset

exception instead of returning a value.
 In this sense, returning a value of the void type corresponds to a crash
 in the program.
 So, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 expression is defined as if it returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 We can then pretend to convert that 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 (which will never be actually returned) into a value of any other type.
 Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how to write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd[A]
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing => A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To see how this trick is used, consider this code defining a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: Double = if (t >= 0.0) math.sqrt(t) else throw new Exception(
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 branch does not return a value, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is declared to have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 For this code to type-check, both branches must return values of the same
 type.
 So, the compiler needs to pretend that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 branch also returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 The compiler first assigns the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 to the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw ...
\end_layout

\end_inset

 and then automatically uses the conversion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing => Double
\end_layout

\end_inset

 to convert that type to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 In this way, types will match in the definition of the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
This book does not discuss exceptions in much detail.
 The functional programming paradigm does not use exceptions because their
 presence significantly complicates reasoning about code.
\end_layout

\begin_layout Standard
As another example of using the void type, suppose an external library implement
s a function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def parallel_run[E, A, B](f: A => Either[E, B]): Either[E, B] = ???
\end_layout

\end_inset

We may imagine that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parallel_run(f)
\end_layout

\end_inset

 performs some parallel computations using a given function 
\begin_inset Formula $f$
\end_inset

.
 In general, functions 
\begin_inset Formula $f^{:A\rightarrow E+B}$
\end_inset

 may return an error of type 
\begin_inset Formula $E$
\end_inset

 or a result of type 
\begin_inset Formula $B$
\end_inset

.
 Suppose we know that a particular function 
\begin_inset Formula $f$
\end_inset

 never fails to compute its result.
 To express that knowledge in code, we may explicitly set the type parameter
 
\begin_inset Formula $E$
\end_inset

 to the void type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 when applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parallel_run
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

parallel_run[Nothing, A, B](f)  // Types match only when values f(a) always
 are of the form Right(b).
 
\end_layout

\end_inset

Returning an error is now impossible (the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has no values).
 If the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parallel_run
\end_layout

\end_inset

 is fully parametric, it will work in the same way with all types 
\begin_inset Formula $E$
\end_inset

, including 
\begin_inset Formula $E=\bbnum 0$
\end_inset

.
 The code implements our intention via type parameters, giving a compile-time
 guarantee of correct results.
\begin_inset Note Note
status open

\begin_layout Plain Layout
So far, none of our examples involved the logical 
\series bold
negation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
negation (in logic)
\end_layout

\end_inset

 operation.
 It is defined as:
\begin_inset Formula 
\[
\neg\alpha\triangleq(\alpha\Rightarrow False)\quad.
\]

\end_inset

Its practical use is as limited as that of 
\begin_inset Formula $False$
\end_inset

 and the void type.
 However, logical negation plays an important role in Boolean logic, which
 we will discuss next.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Relationship between Boolean logic and constructive logic
\begin_inset CommandInset label
LatexCommand label
name "subsec:Relationship-between-Boolean"

\end_inset

 
\end_layout

\begin_layout Standard
We have seen that some true theorems of Boolean logic are not true in constructi
ve logic.
 For example, the Boolean identities 
\begin_inset Formula $\neg\left(\neg\alpha\right)=\alpha$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=(\neg\alpha\vee\beta)$
\end_inset

 do not hold in the constructive logic.
 However, any theorem of constructive logic is also a theorem of Boolean
 logic.
 The reason is that all eight rules of constructive logic (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are also true in Boolean logic.
\end_layout

\begin_layout Standard
To verify that a formula is true in Boolean logic, it is sufficient  to
 check that the value of the formula is 
\begin_inset Formula $True$
\end_inset

 for all possible truth values (
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

) of its variables.
 A sequent such as 
\begin_inset Formula $\alpha,\beta\vdash\gamma$
\end_inset

 is true in Boolean logic if and only if 
\begin_inset Formula $\gamma=True$
\end_inset

 under the assumption that 
\begin_inset Formula $\alpha=\beta=True$
\end_inset

.
 So, the sequent 
\begin_inset Formula $\alpha,\beta\vdash\gamma$
\end_inset

 is translated into the Boolean formula:
\begin_inset Formula 
\[
\alpha,\beta\vdash\gamma=\left(\left(\alpha\wedge\beta\right)\Rightarrow\gamma\right)=\left(\neg\alpha\vee\neg\beta\vee\gamma\right)\quad.
\]

\end_inset

Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 translates all proof rules of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 into Boolean formulas.
 The first two lines are axioms, while the subsequent lines are Boolean
 theorems that can be verified by calculation.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Constructive logic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Boolean logic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{create unit})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\neg\Gamma\vee True=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use arg})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\neg\Gamma\vee\neg\alpha\vee\alpha=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\neg\alpha\vee\beta\right)=\left(\neg\Gamma\vee\left(\alpha\Rightarrow\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\left(\neg\Gamma\vee\alpha\right)\wedge\left(\neg\Gamma\vee\left(\alpha\Rightarrow\beta\right)\right)\right)\Rightarrow\left(\neg\Gamma\vee\beta\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\alpha\right)\wedge\left(\neg\Gamma\vee\beta\right)=\left(\neg\Gamma\vee\left(\alpha\wedge\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\left(\alpha\wedge\beta\right)\right)\Rightarrow\left(\neg\Gamma\vee\alpha\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Left})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\alpha\right)\Rightarrow\left(\neg\Gamma\vee\left(\alpha\vee\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use Either})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\left(\neg\Gamma\vee\alpha\vee\beta\right)\wedge\left(\neg\Gamma\vee\neg\alpha\vee\gamma\right)\wedge\left(\neg\Gamma\vee\neg\beta\vee\gamma\right)\right)\Rightarrow\left(\neg\Gamma\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof rules of constructive logic are true also in the Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Proof-rules-of-constructive-and-boolean"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To simplify the calculations, note that all terms in the formulas contain
 the operation 
\begin_inset Formula $\left(\neg\Gamma\vee...\right)$
\end_inset

 corresponding to the context 
\begin_inset Formula $\Gamma$
\end_inset

.
 Now, if 
\begin_inset Formula $\Gamma$
\end_inset

 is 
\begin_inset Formula $False$
\end_inset

, the entire formula becomes automatically 
\begin_inset Formula $True$
\end_inset

, and there is nothing else to check.
 So, it remains to verify the formula in case 
\begin_inset Formula $\Gamma=True$
\end_inset

, and then we can simply omit all instances of 
\begin_inset Formula $\neg\Gamma$
\end_inset

 in the formulas.
 Let us show the Boolean derivations for the rules 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use Either}$
\end_inset


\begin_inset Quotes erd
\end_inset

; other formulas are checked in a similar way:
\begin_inset Formula 
\begin{align*}
\text{formula ``use function''}:\quad & \left(\alpha\wedge\left(\alpha\Rightarrow\beta\right)\right)\Rightarrow\beta\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\gunderline{\neg}(\alpha\,\gunderline{\wedge}\,(\neg\alpha\,\gunderline{\vee}\,\beta))\vee\beta\\
\text{de Morgan's laws}:\quad & =\gunderline{\neg\alpha\vee(\alpha\wedge\neg\beta)}\vee\beta
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{identity }p\vee(\neg p\wedge q)=p\vee q\text{ with }p=\neg\alpha\text{ and }q=\beta:\quad & =\neg\alpha\vee\gunderline{\neg\beta\vee\beta}\\
\text{axiom ``use arg''}:\quad & =True\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{formula ``use Either''}:\quad & \left(\left(\alpha\vee\beta\right)\wedge\left(\alpha\Rightarrow\gamma\right)\wedge\left(\beta\Rightarrow\gamma\right)\right)\Rightarrow\gamma\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\neg\left(\left(\alpha\vee\beta\right)\wedge\left(\neg\alpha\vee\gamma\right)\wedge\left(\neg\beta\vee\gamma\right)\right)\vee\gamma\\
\text{de Morgan's laws}:\quad & =\left(\neg\alpha\wedge\neg\beta\right)\vee\gunderline{\left(\alpha\wedge\neg\gamma\right)}\vee\gunderline{\left(\beta\wedge\neg\gamma\right)}\vee\gamma\\
\text{identity }p\vee(\neg p\wedge q)=p\vee q:\quad & =\gunderline{\left(\neg\alpha\wedge\neg\beta\right)\vee\alpha}\vee\beta\vee\gamma\\
\text{identity }p\vee(\neg p\wedge q)=p\vee q:\quad & =\gunderline{\neg\alpha\vee\alpha}\vee\beta\vee\gamma\\
\text{axiom ``use arg''}:\quad & =True\quad.
\end{align*}

\end_inset

Since each proof rule of the constructive logic is translated into a true
 formula in Boolean logic, it follows that a proof tree in the constructive
 logic will be translated into a tree of Boolean formulas that have value
 
\begin_inset Formula $True$
\end_inset

 for each axiom or proof rule.
 The result is that any constructive proof for a sequent such as 
\begin_inset Formula $\emptyset\vdash f(\alpha,\beta,\gamma)$
\end_inset

 is translated into a chain of Boolean implications that look like this:
\begin_inset Formula 
\[
True=(...)\Rightarrow(...)\Rightarrow...\Rightarrow f(\alpha,\beta,\gamma)\quad.
\]

\end_inset

Since 
\begin_inset Formula $\left(True\Rightarrow\alpha\right)=\alpha$
\end_inset

, this chain proves the Boolean formula 
\begin_inset Formula $f(\alpha,\beta,\gamma)$
\end_inset

.
\end_layout

\begin_layout Standard
For example, the proof tree shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is translated into:
\begin_inset Formula 
\begin{align*}
\text{axiom ``use arg''}:\quad & True=\left(\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\neg\alpha\vee\alpha\right)\\
\text{rule ``create function''}:\quad & \quad\Rightarrow\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\alpha\right)\quad.\\
\text{axiom ``use arg''}:\quad & True=\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\quad.\\
\text{rule ``use function''}:\quad & True\Rightarrow\left(\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\beta\right)\\
\text{rule ``create function''}:\quad & \quad\Rightarrow\left(\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\Rightarrow\beta\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It is easier to check Boolean truth tables than to find a proof tree in
 constructive logic (or to establish that no proof tree exists).
 If we find that a formula is 
\emph on
not
\emph default
 true in Boolean logic, we know it is also not true in constructive logic.
 This gives us a quick way of proving that some type signatures are 
\emph on
not
\emph default
 implementable as fully parametric functions.
 However, if a formula is true in Boolean logic, it does not follow that
 the formula is also true in the constructive logic.
\end_layout

\begin_layout Standard
In addition to formulas shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-not-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

), here are three more examples of formulas that are 
\emph on
not
\emph default
 true in Boolean logic:
\begin_inset Formula 
\[
\forall\alpha.\,\alpha\quad,\quad\quad\forall(\alpha,\beta).\,\alpha\Rightarrow\beta\quad,\quad\quad\forall(\alpha,\beta).\,(\alpha\Rightarrow\beta)\Rightarrow\beta\quad.
\]

\end_inset

These formulas are also 
\emph on
not
\emph default
 true in the constructive logic.
\end_layout

\begin_layout Subsection
The constructive logic and the law of excluded middle
\end_layout

\begin_layout Standard
Computations in the Boolean logic are often performed using truth tables.
 It is perhaps surprising that the proof rules of the constructive logic
 are 
\emph on
not
\emph default
 equivalent to checking whether some propositions are 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

 via a truth table.
 A general form of this statement was proved by Kurt G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\begin_inset Quotes erd
\end_inset

o
\end_layout

\end_inset

del
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kurt@Kurt G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\begin_inset Quotes erd
\end_inset

o
\end_layout

\end_inset

del
\end_layout

\end_inset

 in 1932.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "plato.stanford.edu/entries/intuitionistic-logic-development/"
target "https://plato.stanford.edu/entries/intuitionistic-logic-development/#SomeEarlResu"
literal "false"

\end_inset


\end_layout

\end_inset

 In this sense, constructive logic does 
\emph on
not
\emph default
 imply that every proposition is either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This is not intuitive and requires getting used to.
 Reasoning in the constructive logic must use the axioms and derivation
 rules directly, instead of truth tables.
\end_layout

\begin_layout Standard
The reason Boolean logic can use truth tables is that every Boolean proposition
 is either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This can be written as the formula 
\begin_inset Formula $\forall\alpha.\,(\neg\alpha\vee\alpha=True)$
\end_inset

.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 uses the Boolean identity 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=(\neg\alpha\vee\beta)$
\end_inset

, which does not hold in the constructive logic, to translate the constructive
 axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use arg}$
\end_inset


\begin_inset Quotes erd
\end_inset

 into the Boolean axiom 
\begin_inset Formula $\neg\alpha\vee\alpha=True$
\end_inset

.
 The formula 
\begin_inset Formula $\forall\alpha.\:\neg\alpha\vee\alpha=True$
\end_inset

 is known as the 
\series bold
law of excluded middle
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Law_of_excluded_middle"
target "https://en.wikipedia.org/wiki/Law_of_excluded_middle"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
law of excluded middle
\end_layout

\end_inset

.
 It is remarkable that the constructive logic 
\emph on
does not have
\emph default
 the law of excluded middle.
 It is neither an axiom nor a derived theorem of constructive logic.
\end_layout

\begin_layout Standard
To see why, consider how 
\begin_inset Formula $\neg\alpha\vee\alpha=True$
\end_inset

 could possibly hold in the constructive logic.
 The negation operation (
\begin_inset Formula $\neg\alpha$
\end_inset

) is defined as the implication 
\begin_inset Formula $\alpha\Rightarrow False$
\end_inset

.
 So, the formula 
\begin_inset Formula $\forall\alpha.\,\neg\alpha\vee\alpha$
\end_inset

 corresponds to the type 
\begin_inset Formula $\forall A.\,\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

.
 To compute a value of this type, we need to compute either a value of type
 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 or a value of type 
\begin_inset Formula $A$
\end_inset

.
 This decision needs to be made in advance independently of 
\begin_inset Formula $A$
\end_inset

, because the code of a fully parametric function must operate in the same
 way for all types.
 As we have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset

, a value of type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 exists if the type 
\begin_inset Formula $A$
\end_inset

 is itself 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 But we do not know in advance whether 
\begin_inset Formula $A=\bbnum 0$
\end_inset

.
 Since there are no values of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, and the type parameter 
\begin_inset Formula $A$
\end_inset

 could be, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, we cannot compute a value of type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Standard
Why exactly is it impossible to implement a value of the type 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

? Surely, the type 
\begin_inset Formula $A$
\end_inset

 is either void or not void.
 If 
\begin_inset Formula $A$
\end_inset

 is void then 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)\cong\bbnum 1$
\end_inset

 is not void (as Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows).
 So, one of the types in the disjunction 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

 should be non-void (i.e., have values).
\end_layout

\begin_layout Standard
While this argument is true, it does not help implementing a value of type
 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

 via fully parametric code.
 It is insufficient to know that one of the two values 
\begin_inset Quotes eld
\end_inset

should exist
\begin_inset Quotes erd
\end_inset

.
 We need to know 
\emph on
which
\emph default
 of the two values exists, and we need to write code that computes that
 value.
 That code may not decide what to do depending on whether 
\begin_inset Formula $A$
\end_inset

 is void, because the code must work in the same way for all types 
\begin_inset Formula $A$
\end_inset

 (void or not).
 As we have seen, that code is impossible to write.
\end_layout

\begin_layout Standard
In Boolean logic, it is sufficient to prove that a value 
\begin_inset Quotes eld
\end_inset

should exist
\begin_inset Quotes erd
\end_inset

, meaning that the non-existence of a value is contradictory in some way.
 However, any practically useful program needs to 
\begin_inset Quotes eld
\end_inset

construct
\begin_inset Quotes erd
\end_inset

, i.e., compute, actual values and return them.
 The 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Index idx
status open

\begin_layout Plain Layout
constructive logic
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 logic got its name from this requirement.
 So, it is the constructive logic (not the Boolean logic) that provides
 correct reasoning about the types of values computable by fully parametric
 functional programs.
\end_layout

\begin_layout Standard
Without the requirement of full parametricity, we 
\emph on
could
\emph default
 implement the law of excluded middle
\begin_inset Index idx
status open

\begin_layout Plain Layout
law of excluded middle
\end_layout

\end_inset

.
 Special features of Scala (
\begin_inset Quotes eld
\end_inset

reflection
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

type tags
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

type casts
\begin_inset Quotes erd
\end_inset

) allow us to compare types as values and to determine what type was given
 to a type parameter when a function is applied:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

import scala.reflect.runtime.universe._
\end_layout

\begin_layout Plain Layout

def getType[T: TypeTag]: Type = weakTypeOf[T]   // Convert the type parameter
 T into a special value.
\end_layout

\begin_layout Plain Layout

def equalTypes[A: TypeTag, B: TypeTag]: Boolean = getType[A] =:= getType[B]
 // Compare types A and B.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def excludedMiddle[A: TypeTag]: Either[A, A => Nothing] =  // excludedMiddle
 has type ${
\backslash
color{dkgreen}
\backslash
forall A.
\backslash
,
\backslash
left(A
\backslash
rightarrow
\backslash
bbnum 0
\backslash
right)+A}$.
\end_layout

\begin_layout Plain Layout

   if (equalTypes[A, Nothing]) Right((identity _).asInstanceOf[A => Nothing])
    // Return ${
\backslash
color{dkgreen}
\backslash
text{id}:
\backslash
bbnum 0
\backslash
rightarrow
\backslash
bbnum 0}$.
\end_layout

\begin_layout Plain Layout

   else if (equalTypes[A, Int]) Left(123.asInstanceOf[A])          // Produce
 some value of type Int.
\end_layout

\begin_layout Plain Layout

   else if (equalTypes[A, Boolean]) Left(true.asInstanceOf[A]) // Produce
 some value of type Boolean.
\end_layout

\begin_layout Plain Layout

   else ???                  // Need to write many more definitions to support
 all other Scala types.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> excludedMiddle[Int]
\end_layout

\begin_layout Plain Layout

res0: Either[Int,Int => Nothing] = Left(123)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> excludedMiddle[Nothing]
\end_layout

\begin_layout Plain Layout

res1: Either[Nothing,Nothing => Nothing] = Right(<function1>) 
\end_layout

\end_inset

In this code, we check whether 
\begin_inset Formula $A=\bbnum 0$
\end_inset

.
 If so, we can implement 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 as an identity function of type 
\begin_inset Formula $\bbnum 0\rightarrow\bbnum 0$
\end_inset

.
 Otherwise, we know that 
\begin_inset Formula $A$
\end_inset

 is one of the existing Scala types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

, etc.), which are not void and have values that we can simply write down
 one by one in the subsequent code.
 
\end_layout

\begin_layout Standard
Explicit
\begin_inset Index idx
status open

\begin_layout Plain Layout
type casts
\end_layout

\end_inset

 
\series bold
type casts
\series default
, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123.asInstanceOf[A]
\end_layout

\end_inset

, are needed because the Scala compiler cannot know that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 in the scope where we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(123)
\end_layout

\end_inset

.
 Without a type cast, the compiler will not accept 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset

 as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in that scope.
\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

asInstanceOf
\end_layout

\end_inset

 is dangerous because the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.asInstanceOf[T]
\end_layout

\end_inset

 disables the type checking for the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 This tells the Scala compiler to believe that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 even when the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is inconsistent with the actually given code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 The resulting programs compile but may give unexpected results or crash.
 These errors would have been prevented if we did not disable the type checking.
 In this book, we will avoid writing such code.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
so suppose we we know we need this type how do we get this code turns out
 mathematicians have studied this question for a long time mathematicians
 were only studying the logical domain of course not the program in domain
 since about 1930 or so many mathematicians have studied this including
 church tarski girdle lots of people in Poland and Germany in England and
 in the United States it took a very long time about 50 years between 1913
 and 1980 between the beginning of this activity when this was first formulated
 as logic with these particular rules and the time when the Curie Howard
 respondents was realized that or was it wasn't was discovered at that time
 it became clear that these things have a direct bearing on functional programmi
ng actually helping people to write code because if you know how to prove
 things here you just directly write the code
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
showing here this is equivalent in Scala just different syntax importantly
 non theorems cannot be implemented in code some on theorems are statements
 in logic that cannot be derived statements that are false or undereye verbal
 examples of these statements are these for all a from one follows a now
 this is certainly suspicious in terms of logic what if a were false then
 we would have it from true false false that's very obviously wrong and
 we cannot implement a function of this type to implement it we would have
 to take a unit argument and produce a value of type a where a is arbitrary
 type but how can we produce a value of type a of the type that we don't
 even know what it is and there is no data for us to produce that value
 so it is impossible another example of an impossible type is this type
 so from a plus B follows a if you wanted to implement this function you
 would have to take a value of disjunction type a plus B and return a value
 of type a but how can you do that what exodus Junction type happens to
 contain B and no a just B it cannot contain a if it contains a B it's a
 disjunction so then we don't have an A and then we again cannot produce
 any and having a B which is a completely different arbitrary type doesn't
 help us to produce me exactly the same reason shows why we cannot produce
 an A a and B given a because that requires a B we cannot produce and also
 this is not implementable because we are required to produce an A but all
 we have is a function from A to B this function will consume an A if given
 only this function cannot possibly produce an A for us but we are required
 to produce an A as a result so we cannot and also there is no proof of
 this formula in the logic so these examples actually lead us to a natural
 question how can we decide given a certain formula whether it is a theorem
 in logic and therefore whether it can be implemented in code it is not
 obvious consider this example can we write a function with this type in
 Scala it is not obvious can we prove this formula it is not clear not quite
 obvious right now suppose I were of the opinion that this cannot be proved
 but how do I show that this cannot be proved I certainly cannot just try
 all possible proofs that would be infinitely many possible proofs that
 would give me all kinds of other formulas and that would give me nothing
 that I can stand oh how to answer these questions so it is really a very
 hard question we are not going to try to answer it on our own we were going
 to use the results of mathematicians they have studied these questions
 for many many years for centuries logic has been studied since ancient
 Greece more than 2,000 years of study all we need to do is to find out
 by what name mathematicians call this logic they are probably already studied
 it what kind of logic is this that we are using that follows from the type
 constructions remember and the very beginning of our consideration we started
 with the type constructions that our programming languages have so that's
 set of type constructions specifies the set of rules of derivation of the
 logic mathematicians call this logic intuitionistic propositional logic
 or IPL also they call it constructive propositional logic but it is less
 frequently used most frequently used name is this and mathematicians also
 call this a non classical logic because this logic is actually different
 from the boolean logic that we are familiar with the logic of the values
 true and false and their truth tables I assume that you are familiar with
 those computations using truth tables and operations and or not in the
 boolean logic so actually this logic the logic of types as I call it or
 intuitionistic propositional logic is very different from boolean logic
 in certain ways it's similar in other ways disjunction for instance works
 very differently here's an example consider this sequence if it has given
 that from a follows B plus C then either from a follows B or from a follows
 C it sounds right from the common-sense point of it if if B plus C Falls
 a B or C if I was I'm using plus as a logical or so if B or C follows then
 it kind of makes sense either B follows or C Falls indeed this is correct
 in the boolean logic which we can find out by writing the truth table so
 we enumerate all the possibilities for a B and C to be true or false or
 eight such possibilities and for each of those possibilities we write the
 truth value of this the truth value of this and we see from the table that
 whenever this is true then this is also true in the boolean logic but this
 does not hold in the intuitionistic logic for the logic of types well why
 does it not hold that's counterintuitive well in fact there is very little
 that's intuitive about this so-called intuitionistic logic actually we
 need to think differently about this logic we need to think can we implement
 an expression of this sequent so implementing it would mean if we're given
 this expression we can build an expression of this type so we're given
 an expression of type A to B plus C let's say some F of this type can we
 build an expression of this type we can this differently by asking can
 we implement a function that takes this as an argument and returns this
 well we know that this is equivalent one of our derivation rules is that
 if you have this sequence then you can also have a sequence that is a function
 type from this to this so for the programmer it is easier to reason about
 a function taking this as an argument and returning this so how can we
 implement this function this function takes F and needs to return a value
 of this type so the body of this function if we could implement it and
 have to construct a value of type either of something there are only two
 ways of constructing a value of type either one is to construct the left
 value second is to construct the right value how do we decide whether to
 construct the left value or the right value we have to decide it somehow
 on the basis of what information can we decide it we don't actually have
 any such information what we have here is a function from a to either BC
 so given some value of a of type a we could compute f of that value and
 then we would have either B or C we could decide them whether to we could
 take them that B or that C but that's not what we need to return we don't
 need to return either of BC we need to return either of this function or
 that function and that function is not yet applied to any a it is it is
 too late for us to ask what is the a we already have to return the left
 of this or a right of that in other words this type either of something-somethi
ng is not itself a function of a it contains functions away but itself it
 cannot be decided on the basis of any assets too late so we need to supply
 a left or right so here right away immediately we have to decide whether
 this will return a left or a right and we cannot really decide that if
 we decide we return the left we must then return a function from A to B
 so there's no way for us to construct this function if we're given this
 function because this function could sometimes return C instead of B and
 then we'll be stuck we cannot do this and we can also return we cannot
 also return the right either so it is impossible to implement a function
 of this type implication also works a little differently in the intuitionistic
 logic here's an example this holds in boolean logic but not in intuitionistic
 logic again let's see why how can we compute this given this this function
 will give us an e only when given an argument of this type but how can
 we produce a value of this type we cannot we don't have information that
 will allow us to produce a value of this type a and B are some arbitrary
 types remember there is universal quantifier outside of all this for all
 a and for all B we're supposed to produce this and that is impossible we
 don't have enough data to produce some values type a and so we cannot implement
 this function conjunction works kind of the same as in boolean logic so
 here's an example this implemented and this is also in boolean logic a
 true theorem now in boolean logic the usual way of deciding whether something
 is true or something is a theorem is to write a truth table unfortunately
 the intuitionistic logic cannot have a truth table it cannot have a fixed
 number of truth values even if you allow more than two truth values such
 that the validity of formulas the truth of theorems can be decided on the
 basis of the truth table this was shown by noodle and this means we should
 not actually try to reason about this logic using truth values it is not
 very useful even an infinite infinite number of truth values will not help
 instead however it turns out that this logic has a decision procedure or
 an algorithm and this algorithm is guaranteed either to find the proof
 for any given formula of the internation intuitionistic logic or to determine
 that there is no proof for that formula the algorithm can also find several
 in equivalent proofs if there is a theorem so a theorem could have several
 in equivalent proofs and since each proof could be automatically translated
 into code of that type it means we could generate several in equivalent
 expressions of some type sometimes so that is the situation with this logic
 which we discover if we write if we read papers about intuitionistic propositio
nal logic that are available in the literature and their open source projects
 on the web such as the gen GHC which is a compiler plugin for haskell this
 is another project doing the same thing and for Scala are implemented occurred
 the Clary Howard library both of these Scala and Haskell all of these color
 and Haskell projects do the same thing they take a type of some expression
 for function and generate code for it automatic by translating the type
 into sequence finding a proof in this logic using the algorithm and translating
 that proof back into code in the way that we have seen in an example it
 is interesting that all these provers and there's a few others there's
 one more for the idris language I did not mention here they all used the
 same decision procedure or the same basic algorithm which is called ljt
 which was explained in a paper by dick off here they all side the same
 paper and I believe this is so because most other papers on this subject
 are unreadable to non-specialists they are written in a very complicated
 way or they describe algorithms that are too complicated so I will show
 how this works in the rest of this tutorial in order to find out how to
 get an algorithm we need to ask well first of all do we have the rules
 of derivation that allow us to create an algorithm already here is a summary
 of the axioms and the rules of derivation that we have found so far these
 are direct translations of the cold expressions that we held in the programming
 language in the notation of sequence now there's one other notation for
 derivation rules which looks like a fraction like this the numerator is
 one or more sequins and the denominator is a sequence and this notation
 means in order to derive what is in the denominator you have to present
 proofs for what is in the numerator so this is the convention in the literature
 this fraction like syntax or notation now we keep in mind that proofs of
 sequence are actually just called expressions that have these types as
 some variables and this type is the entire expression so these are directly
 responding to proofs of this sequence and to the proofs of these derivation
 rules and so if we have a proof that operates by combining some of these
 axioms and some of these generation rules which directly translate that
 back into code now the question is do these rules give us an algorithm
 for finding a proof the answer is no how can we use these rules to obtain
 an algorithm well suppose we need to prove some sequence like this in order
 to prove it we could first see if the sequence is one of the axioms if
 so then we have already proved if we know what expression to write now
 in this case none of the axioms match this so much means maybe a is a times
 B so B here is C and then on the Left we must have C or you must have a
 times B now we don't you don't have C on the left as we have because even
 that's not the same we also don't have a times B at the premise we have
 a but we don't have a times B so these rules don't match the other rules
 don't match the premises and the goal either but also these rules so how
 can we use them well when the writer must be an implication we don't have
 an application on the right here we could try to delete some of the premises
 because it's unused well actually it doesn't look like a good idea could
 you read a for example and we end up with an really hopeless sequence from
 B plus C we cannot get an A ever and so but sounds hopeless so this doesn't
 seem to help and changing the order doesn't seem to help much either and
 so we cannot find matching rules but actually this sequence is provable
 just a clever combination of what axiom to start with and what role to
 use and then again some axiom and so on it will give us that time sure
 because I know how to write code for this this is not difficult you have
 a function with two arguments one of them is a the other is B plus C so
 disjunction of either B C and we are supposed to produce a disjunction
 of tuple a B or C that's easy look at this disjunction if we have a B in
 this disjunction then we can produce a left of the tuple a B because we
 always have an A anyway if we have a see in this disjunction then we could
 return this part of the disjunction in the right of C and we're done but
 unfortunately we see that the rules here do not give us an algorithm for
 deciding this we need a better formulation of the logic again mathematicians
 need to save us from the situation and they have done so mathematicians
 have studied this logic for a long time starting from the early 20th of
 the last century the first algorithmic formulation of the logic that was
 found is due to Jensen who published what he called the calculus just ignore
 the word calculus it means not very much complete and sound calculus means
 that he came up with some rules of derivation which are summarized here
 such that they are equivalent to these they derive all the same theorems
 and only the same theorems so they derive all the stuff that is right and
 only that stuff they don't derive any wrong statements it's very hard to
 come up with such a system of axioms and derivation rules that are equivalent
 to another one in this sense also it's very hard to prove that these are
 actually the rules that will give you all the theorems that could be right
 in this logic that you can actually derive all the theorems that are right
 yet work is already done by mathematicians so we're not going to try to
 do it ourselves we're just going to understand how these rules work now
 the syntax here is slightly enhanced compared with this the enhancement
 is that their names pretty cool now these are just labels they don't really
 do anything in terms of sequence these help us identify which we all have
 has been applied to which sequence and that's all we do so other than that
 it is the same notation so the fraction such as this one means that there
 is a sequence in the denominator which we will prove if there are proofs
 given for sequence in the numerator in this rule there are two sequence
 of them in the numerator other rules may have one sequence in the numerator
 or no sequence in the numerator so these rules that will have no previous
 sequence required those are axioms this axiom means if you have an atomic
 X in other words it's a variable it's a type variables not not a complicated
 expression just attack variable and you can derive that same variable this
 is our accion right here now why is it important that this is atomic that
 this is type variable and not a more complicated expression actually not
 important but it's the simplest rule that you can come up with and mathematicia
ns always like the most minimal set of rules so that's why they say let's
 only consider this rule for the type variables X not for more complicated
 expressions but we can consider this rule for any expression of course
 the identity axiom well here is a truth truth axiom net which derives the
 truth which is the ste symbol which I denote it by one the format in logical
 notation this is the T symbol well let's just call this one for clarity
 so that can be derived from any premises with no previous sequence necessary
 none of these other rules now what do these other rules do they do an interesti
ng thing actually each of these rules is either about something in the sequence
 on the left to the trans time or something in the sequence to the right
 of the transplant which I here shown in blue so these are the interesting
 parts of the sequence that are being worked on or transformed by the rule
 so here's an example this rule is actually two rules the eyes the index
 so I is one or two another two rules just written for gravity like this
 with index I and each of them says you will prove this if you prove one
 of if you prove this so for example you will prove C given if you're given
 a a one A two if you will prove C given just a one which makes sense because
 if you can prove C given a one you don't need a two we can ignore this
 a T we can already proved C from anyone so in this way it would be proved
 and so all these rules work in this way you can prove what's on the bottom
 of the seat of the of the fraction if you're given proofs for what's on
 the top so these are eight derivation rules and two axioms we can use this
 now to make a proof search how do we do that I start with a sequence we
 see which rule matches that sequence so the sequence must have something
 on the left and something on the right well at least one of these it cannot
 be empty so it must be something somewhere and there are only four kinds
 of expressions in our logic type variables conjunctions implications and
 disjunctions now notice I'm using this arithmetic arithmetic all notation
 for logic just because I like it better and I will show that it has advantages
 later so we take a sequence we see which rule matches one of them won't
 match because either in the premise we have one of these expressions were
 in the goal we have one of these expressions and then we find the rule
 of match that matches we apply that rule so we now have new sequence one
 or more that we will need to be proved and if they're true then we fork
 the tree and now we have to prove both of them son-in we continue doing
 that for each of the sequence until we hit axioms so the tree will and
 this leaf or we hit a sequence to which no rule applies in which case we
 cannot prove it and the entire thing is unprovable so in the search tree
 there will be sequence at the nodes of the tree and proofs will be at the
 edges of the tree so each node sends its proof to the root of the tree
 this calculus is guaranteed by mathematicians to be such that indeed if
 you cannot find a rule that applies that means the sequence cannot be proved
 which was not the case here the sequence can be proved and yet we cannot
 find a rule that applies so in this calculus we can use bottom-up approach
 to make a proof search as a tree here we cannot that is the advantage capitaliz
ing on the mathematicians results let us look at an example suppose we want
 to prove this formula this theorem so first step we need to write a sequence
 and this needs to be proved from no premises so we write a sequence s0
 which has an empty set of premises this is a single now what rule applies
 to this sequence with your bottom up so in other words we look at these
 rules and they refine which denominator matches our sequential and our
 cylinders empty set on the left so all the rules on the left cannot be
 applied but on the right we have an expression which is an implication
 at the top level of this expression there is this implies that so this
 is of the form a implies B so this rule applies we have a sequence of the
 form something in our case this is an empty set and then a implies B so
 we apply this rule which is the right implication and we get a new sequence
 which is that what was here before the implication is now put on the left
 to the trans of the to the left of the trans time and it means that this
 expression needs to be now to the left of the turnstile so now this is
 the sequence s1 now we need to prove s1 well we see what rule applies to
 us one well on the right there is just Q so nothing can be done of these
 rules and Q is not truth so we cannot use the axiom either so let's look
 at their left rules on the Left we have now an implication so this is let's
 say a and this is B so we have a rule which has a implication B on the
 left this is the row left implication let's apply it that law will give
 us two new sequence so these two new sequence are s2 and s3 no these ones
 as you can check if you match a location B against this implication Q so
 this is a this is B so then you get these two sequence now we have to prove
 these two sequence as 2 and s 3 s 3 is easy it is just the axiom of identity
 it is this now as 2 again has an implication on the left let's again apply
 the rule left implication to that we get two more sequence as foreign s5
 as for is this because 5 is this so now actually we are in trouble because
 as 2 and s 4 is are the same sequence as 5 actually we could prove with
 some more work but that won't help because we are in a situation when to
 prove as two we need to prove again s 2 so that's it that's a loop that
 will never give us anything it means we applied the wrong rule so we need
 to backtrack this step when we apply the rule left implication to s 2 we
 erase is 4 in this 5 and try a different rule to apply to s 2 which rule
 can apply to s 2 well as to is this it actually has implication on the
 right so we can use the right implication rule and if we do that we get
 a sequence s 6 which is this and this sequence immediately follows from
 the identity axiom because it has promise are on the left and premise are
 and goal are on the right and that is this axiom whatever other premises
 and the premise X on the left premise X on the right and that is a type
 variable so that's perfect we have done the proof as 6 follows from the
 axiom and therefore we have proved s0 no more sequins need to be proved
 and because sequence s0 shows this to be derived from no premises than
 this formula is the theorem that's what the theorem means in the logic
 so that is how we use this calculus to do proof search now we notice that
 we were a bit stuck at some point we had a loop now if we are in the loop
 we don't know what to do maybe we need to continue applying the same rule
 maybe some new sequence come up or maybe we should not continue it is not
 clear what to do and just looking at the rule left implication shows us
 that it's copying this premise a implication B it is copied into the premises
 of the new sequence and so it will generate a loop assuredly after the
 second time you apply it however this sequence might be new so we might
 need to apply it second time we don't know that so that is a problem it
 will do now there have been a lot of work trying to fix this problem and
 literally decades from research by mathematicians the main ones I found
 were what are the off we published in the Soviet Union who de Meyer and
 dick Hoff who published in the United States over this time discovered
 gradually a new set of rules which is called ljt or the calculus ljt which
 cures this problem of looping the way it clears this problem is by replacing
 this rule left implication through four new rules which are listed here
 all other rules are kept the same from this calculus except the rule left
 implication which is replaced in what way so left implication was applying
 it applied to a sequence when the sequin had an implication among the premises
 or on the left to the left of the turnstile the new rules look in more
 detail at what is that implication so that implication could have one of
 the four expressions as the argument of the implication it could have an
 atomic expression as the argument it would have a conjunction as the argument
 could have a disjunction as the argument or it could have an implication
 as the argument in our logic there are no more expressions except these
 four atomic variables conjunctions disjunction and implications and so
 we have here enumerated all the possibilities for what could be to the
 left of the implication in this premise which I have here shown in the
 blue in blue and so for each of these we do certain things replacing this
 sequence with one or more other sequence again it's quite a lot of work
 to prove that these rules are equivalent to these and also that the new
 rules are somehow better they are not giving loops a lot of work which
 I am NOT going to go through because that's far too complicated for the
 scope so what we need suffice it to say that we have very smart people
 who published on this and it is reasonably sure that this is correct so
 the T in the name lgt starts stands for terminating so if we use these
 rules in the same way by by creating a proof tree the proof tree will have
 no loops and will terminate after a finite number of steps and there is
 actually this paper that is also helpful for understanding how to implement
 this algorithm and this paper shows explicitly how to construct an integer
 function from sequence to integers which is a measure of the complexity
 of the sequence and this measure decreases every time you apply a rule
 so it strictly decreases and since this is a strictly decreasing measure
 on the proof tree it means that all the next nodes in the proof tree will
 have a smaller value of this measure so eventually it will hit zero and
 the proof tree will terminate at that leaf either that or you have no more
 rules to apply and if you have no more laws to apply then again mathematicians
 have proved it means our sequence cannot be proved so this is an important
 result that we are going to use and note that this this rule is quite complicat
ed it does a very interesting thing it takes this expression which has implicati
on inside an implication and it transforms this expression in a weird way
 namely the B here is separated from the C by parenthesis but here it is
 not separated so this transformation is highly non-trivial and unexpected
 and its validity is based on this theorem that this in the intuitionistic
 logic is equivalent to this equivalent means they're both following from
 the other so from this promos that and from there follows this so this
 key theorem was attributed to rob you off my dick off in this paper and
 this is this lemma 2 which says that if this sorry that the this derivation
 is if and only if that derivations will have these two equivalences and
 the proof is trivial and the 34 is a reference to to borrow be off now
 when a mathematician says that something is trivial doesn't mean that a
 statement is easy to understand it doesn't mean that the proof is easy
 to find or that it has trees easy to understand it means none of these
 things it just means that right now for this mathematician it is not interestin
g to talk about how it is done that's all it means could be for any number
 of reasons for example mathematicians could just be lazy or have no time
 to again explain this and so they say it's trivial don't be don't be deceived
 when you see somebody says that something is trivial in a mathematical
 text so to prove this one stepping stone could be to prove this first this
 is an easier theorem and if you prove this then clearly from here you can
 get B to C B to C you can substitute in here you can get a to B and then
 you have here a to B so in this way you can show this equivalence in one
 direction now the proof of this statement is obviously trivial in order
 to show the expression of this type I will use my short notation so this
 is F which has this type the first argument of the function the second
 is B which is at this type then we need to produce a see how do we produce
 a C we apply F to an argument of this type the argument of this type is
 a function that takes a and returns a B so we take some X of type a and
 we return a B which was this B so we ignore this X we just returned that
 B and that's the argument of F so this expression is the proof of this
 sequence in other words this is the code that has this type and therefore
 the proof must be available somehow so the details of proving this theorem
 are left as an exercise for the reader again when you see in a mathematical
 text that something is left as an exercise for the reader it does not mean
 that it is easy to do it does not mean that for you it would be a useful
 exercise to do it also does not mean that the author knows how to do it
 it means none of these things it just means the author doesn't feel like
 doing it right now and showing it to you for whatever reason could be because
 they are lazy it could be because I don't know how to do it could be because
 they feel that they should know how to do it but they don't really do know
 how to do it could be any of these reasons don't be deceived when you see
 something like this but of course I had to actually produce an expression
 function of this type in order to implement my curry forward language because
 as I will show in a moment we need to be able to implement all these has
 code in order to help approver so why is that we believe the mathematicians
 that the new rules are equivalent to the old rules which means that if
 you find a proof using these rules somehow you should be able to find the
 proof also using our initial rules which means that if you found that proof
 it would easily translate that to code because each step here is directly
 corresponding to a certain code expression as we have seen at the beginning
 of this tutorial these cold expressions from each of these operations so
 in order to do this with new rules in other words in order to create code
 from proof using new rules we need to show equivalence or we need to show
 how to get code out of each of the new rules now proof of a sequence means
 that we have some expression let's say T what uses variables a B and C
 of these types and expression itself has type G and also as I have shown
 this could be conveniently seen as a function the T as a function from
 a B and C from these three arguments to the type G so for each sequencing
 a proof we should be able to show either that it follows from an axiom
 one of these or that it show it follows from a derivation rule and the
 derivations all transforms one proof into another the axioms are just fixed
 expressions as we had before the axiom that actually didn't change between
 our initial formulation of the logic and the new calculus lgt they actually
 did not change the derivation rules changed each new derivation rule means
 that you're given expressions that prove the sequence in the numerator
 one or more and you are out of these expressions somehow you have to construct
 an expression that proves this sequence now when I say an expression proves
 the sequence what it means is that expression has the type that is described
 by the sequence it's the same thing because we described types of expressions
 through sequence and only those sequence that correspond to valid and existing
 expressions in the programming language only those sequence can be proved
 by the logic this is by construction so now we need to just find what are
 these expressions that corresponds to each of the derivation rules in each
 rule has a proof transformer function as I call it and the proof transfer
 function is explicitly a function that takes one or more expressions that
 are in the numerator and converts that to the expression in the denominator
 that has this type so it has an expression as it has an explicit function
 we need to write down for each of the derivation rules so let's see how
 this is done for these two examples of derivation laws first example have
 a rule that says if you want to derive this sequence we need to derive
 these two sequence now this sequence represents an expression of type C
 which uses an expression of type A plus B so let's represent this as a
 function from a plus B to C now we will be able to just ignore these other
 premises which are common arguments and all these functions we just pass
 them and we don't write them out what is the proof transformer for this
 derivation rule the proof transformer for it is a function that has two
 arguments t1 which is the proof of this must be a function of type II to
 see and t2 which is a proof of this sequence which must be a function of
 type B to see now earlier I said that sequence represent expressions that
 use certain variables but equivalently we can say these are functions that
 take these variables and return these expressions that's more convenient
 when you implement this in code so what we need is a function that takes
 a to C and B to C and returns a function from a plus B to C and this is
 the code that does it we take an argument of type a plus B and we return
 a match expression if it's in the left we applied t1 to that value and
 we get to see if it's in the right we apply t2 to that value and we get
 a C so in any case we get a syllabus so this is a function from a plus
 B to C as required another example is the proof transformer for this rule
 this rule has one sequence going to one sequence so in order to transform
 is proof into this we need a function that takes argument of type A to
 B to C to D and returns a function of type tuple a B going to C to D so
 here's the code we take a function f of type A to B to C to D we return
 a function that takes a G of this type shown here in blue and return we
 need to return a D so how do we get a deal we apply F to a function of
 type A to B to C so we create that function out of G X of type a going
 to Y of type B going to G of x1 so this is a function of type A to B to
 C which is the argument of F as required and the result is of type D so
 that is what we write so this kind of code is the proof transformer for
 this derivation arrow and we need to produce this proof transformers for
 every rule of the calculus lgt and I have done it because I have implemented
 the Korea Howard library that uses LG T so I'll must have done it for each
 flow this is a bit tedious because there are many of those rules and you
 need to implement all this machinery of passing arguments no matter how
 many in this gamma which are emitted from this notation for brevity but
 in of course in the real code you have to deal with all that too so let's
 see how this works on an example because once the proof tree is found we
 need to start backwards from the leaves of the tree back to the root on
 each step we take the proof expression apply the proof transformer to ative
 according to the rule that was used on that step we get a new proof expression
 and so on so for each sequence we will get a proof expression and at the
 end we'll have a proof expression for the root sequence and that will be
 the answer so I will denote denote by T I the proof expressions for the
 sequence s hi so starting from s6 s6 was this sequence in our proof so
 I mean yes just just going through the proof example it was here backwards
 from a 6 back to a 0 s-six was this it followed from axiom identity it's
 proof expression t6 is a function of two variables these two variables
 of these two types and this function just returns the second variable so
 it's a function of RR q and r and just denote this by our argued and Garibaldi'
s types r RQ variable of this type is hard here so this function is very
 simple just ignores the first argument and returns or so that is what the
 axiom does the next sequence was as to as to was obtained by rule our implicati
on or right implication from s 6 so the proof transformer for right implication
 let's look at the right implication and see what the proof transformer
 must be so we are given this sequence for this expression which is the
 function body the function body that uses a variable of type a somehow
 out of this we need to produce a function expression that takes an argument
 of type a and returns that functional body so this is the code which is
 just writing a new argument returning the function body that was our proof
 transformer we need to convert function body into a function so we just
 write that argument and arrow in the function body so in our case we need
 this as a function body and so our t2 is a function of our Q and this function
 is this the sequence s 3 followed from the axiom and so it was just this
 function this is just the identity function then we used the left implication
 so this was actually still done in the calculus algae but the same thing
 works in the calculus lgt I'm just using algae because it's simpler for
 example here proof transformer for the left implication is a little more
 complicated and so if you look at it what what does it have to be it takes
 these two expressions and returns this expression so it takes a function
 from A to B to a and from B to C and it returns a function from A to B
 to see how does it do it given a function a to b you use this to derive
 a from it then you substitute that a into the function into B you get a
 B when you use this to derive see from that B and that's your C so you
 use this function a to be twice you put it in here once and then you get
 an A and substitute back into the same function when you get a B then you
 use that and that's exactly what the proof transformer does it takes this
 rrq and it uses it twice substitutes into it something that was obtained
 from one of the terms and then uses the second term on the result so then
 this is the proof transformer for the rule left implication the result
 of the proof transformation is the proof for the sequence s1 finally we
 use the right implication again which is just this function construction
 and we get the proof expression for the sequence s0 now this proof expression
 is written through these t1 t2 t3 we have to substitute all this back in
 order to get the final expression so if we substitute first of all we find
 this is our our cubone going to tea one of our cutie one of our queue is
 this so we have to put it here now t3 is just identity so we can just remove
 that so that gets you riq going to our Q of T 2 T 2 is less if I have to
 put it in T 6 is just identity on R so this is our going to our and so
 finally you have this expression so that is the final code that has the
 required type notice that we have derived this code completely algorithmic
 to it there was no guessing we found which rules applied to the sequence
 with transformed sequence according to the rules once we found the proof
 which was if we use the calculus ljt the proof will be just a finite tree
 with no loops it will terminate you can get an exhaustive depth-first search
 for it for example and you find all the possible proofs if you want as
 well well you will find many in any case in some for some expressions and
 then we use the proof transformers which are fixed functions that you can
 upfront compute for each these expressions are proof transformers applied
 to the previous proofs so these are completely fixed algorithmically fixed
 so we have derived this code completely algorithmically given this expression
 this type so it is in this way that the career Howard correspondence allows
 us to derive the code of functions from there type signatures another important
 application of the correspondence is to analyze type by some morphisms
 or type equivalences and I was led to this by asking the question so in
 this logic or in the types are these operations plus and times as I denoted
 them more like logic more like the disjunction and conjunction or are they
 more like arithmetic plus and times because this is kind of not so clear
 right away our logic is this intuitionistic logic it in any case this is
 different from boolean logic so what are the properties of these types
 really so are the properties such that it is better to think about these
 operations as plus and times rather than logical conjunction and disjunction
 can answer this question I looked at identities that we have in the water
 these are some identities from simple ones obvious ones to less obvious
 identities like this the equal sign here stands for implication in both
 directions so both this implies that and vice versa because of this each
 of the implications means a function so since these are all identities
 in logic it means that for example the implication from here to here is
 a theorem of logic and so it can be implemented as we know all our identities
 in logic can be implemented in code and we even have an algorithm now that
 can automatically produce proofs and automatically produce code so that
 means for any of these identities that has some ik some expression X on
 the left and some Y on the right so some kind of X equals y we have X implies
 Y and y implies X if we convert that to code we will have a pair of functions
 function from X to one and the function from Y to X what do these functions
 do well they convert values in some ways from type X to type Y and back
 so do these functions Express the equivalence of the types x and y so that
 any value of type X can be converted to some equivalent value type while
 and back without any loss of information is that so that was the question
 I asked I looked at some examples well first what does it mean more rigorously
 that types are equivalent for as mathematicians say isomorphic the types
 are isomorphic and we will use this notation for that if there is a one-to-one
 correspondence between the sets of values of these types and in order to
 demonstrate that we need a pair of functions one going from A to B the
 other going from B to a such that the composition of these functions in
 both directions is equal to identity function so F compose G or F value
 G will give you from A to B and then from B to a is back so that would
 be identity of a to a this will be identity of B to B if this is true if
 the composition is identity it means we indeed did not lose any information
 let's consider an example this is an identity in the logic a conjunction
 with one is equal to a in Scala the types responding to the left and the
 right hand sides of this conjunction all of this are equivalent are the
 conjunction of a and unit and a itself now we need functions with these
 types indeed we can write functions is having these types a pair of a and
 unit we need to produce an a out of that we'll just take the first element
 of the pair you are done take an X of type a will produce tuple of a and
 unit very easy just put a unit value in the tuple in here done and it's
 easy to verify that composition of these functions will not change any
 values so it will be identity in both directions another example this is
 an identity in logic if this is understood as a disjunction one or a or
 true or a is true that is an identity in logic for theorem in the logic
 are the types equivalent though the type for 1 plus a is the option in
 Scala it is option in Haskell at is called maybe this type is standard
 library type in pretty much every functional programming language now option
 of a is a disjunction of one or unit and a it is certainly not equivalent
 to just unit because this type could contain a value of a in it but this
 could not so there is no way that you could transform this type to this
 and then back without losing information you could transform so since this
 is a theorem you have functions from this type to this type and back some
 functions you have them but these functions do not compose to identity
 they cannot because what if you had a here you must map it into unit from
 this unit back you must map into this unit you cannot get an a out of unit
 and so that will erase this information and that cannot become isomorphism
 so we see that some logic identities do yield isomorphism types but others
 do not why is that let's look at some more examples to figure out why in
 all these examples we can implement functions F 1 and F 2 between the two
 sets to two types in both directions and then we can check we certainly
 can implement them because these are logical identities but then we can
 check if the compositions are identity functions and if so the types are
 isomorphic but we find that in the first three examples we can do it but
 in this last example we can note now I have written the logical identities
 logical theorems with the arithmetic notation I call this arithmetical
 notation because this suggests arithmetic operations plus and times and
 if you look at these identities this looks like a well-known algebraic
 identity from the school algebra in this too but this certainly seen your
 own as an arithmetic as an as an arithmetic identity this is certainly
 not true in arithmetic it is true in logical if you replace this with disjuncti
on and this with conjunction this is an identity in logic so this suggests
 an interesting thing if you replace disjunction by plus and conjunction
 by x and the result is an identity in arithmetic then it is an isomorphism
 of types otherwise it is not let's see why this is so indeed this is so
 I call this the arithmetic arithmetic oh very hard correspondence to see
 how it works let's consider only the types without loss of generation of
 generality that have a finite set of possible values for example a boolean
 type has only two possible true and false integer let's say in the computers
 all the integers are fine nights ago so those types have a finite set of
 possible values and this does not limit our generality because in the computer
 everything is finite all types have a finite set of possible values now
 let's consider how many values a given type has so that would be the size
 of the type or using the mathematical terminology it's called a cardinality
 of the type so let's see what is the cardinality of various type constructions
 the sum type for example if the cardinality of types a and B is known and
 the cardinality of a plus B the sum type the disjunction of a and B is
 the sum of the two cardinalities or sizes this is because a value of the
 disjunction type is constructed as either a value of the first part or
 a value of the second part and so you cannot have both together and so
 obviously the different number of values is just the sum of the two sizes
 that the number of different values of the sum type is just the sum of
 the numbers of different values of types a and B for the product type again
 we have an interesting thing it's the arithmetic product of the sizes of
 a and B because for every a value you could have an arbitrary B value so
 this is a direct product or transient product of sets and we have school
 level identities about the operations plus and times such as these identities
 or these all of these identities are valid for arithmetic and they show
 if you translate that into statements about the sizes of types they show
 that the size of the type on the left is equal to the size of the type
 on the right and that is very suggestive in other words if you take a identity
 like this and you compute the size of the type on the left and the size
 of the type on the right you get an arithmetic identity of the sizes but
 you don't get that identity here because the earth medical formula is not
 right this is very suggestive if the sizes are equal and maybe the types
 are equivalent or isomorphic when the sizes are not equal then certainly
 they cannot be equivalent the function type very interestingly also is
 described in the same way it provides the set of all maps between the two
 sets of values so for example from integer to boolean that would be all
 the functions that take some integer and return some boolean so that's
 and a number of boolean values ^ the number of integer values that's how
 many different functions you can have as a combinatorial number so it's
 an exponential and so the size of the type of function a to be is the size
 of the type of B ^ the size of type of a and again we have all the school
 identities about powers and how to multiply powers and so on and they are
 directly translated into these three identities if you take the sizes of
 the types on the left and on the right the sizes will be equal due to these
 three identities since the sizes are equal it's very likely that the type
 our actual equivalent so far haven't seen any counter examples to this
 in these constructions so this gives us a meaning of the Curie Howard correspon
dence so far we have seen three facets of the curly Howard correspondence
 one is the correspondence between types and logical formulas two is the
 correspondence between code and proofs and three the correspondence between
 the cardinality of a type or the set size of the type and the arithmetic
 identities that we have in the school algebra about these types so arithmetical
 identities signify type equivalence or isomorphism while logic identities
 only talk about how you create some value of this type out of value of
 another type so that does not guarantee that it preserves information it
 just guarantees that you can implement some function of that type it doesn't
 tell you that the function will be an isomorphism so if one type is logically
 equivalent to another it means are equally implementable if one is implementabl
e another is also implementable but no more than that whereas arithmetical
 identities actually tell you about isomorphism of types therefore if you
 look at types and write them using my preferred notation which is using
 the arithmetic all symbols instead of logical symbols instead of these
 I'll use these symbols if I do that this is very suggestive of a possible
 isomorphism of types then it becomes very easy for me to reason about types
 I can see right away that these two are isomorphic types or that these
 two are isomorphic types because I am used to looking at school algebra
 it's very obvious then that this is not an isomorphism of types because
 this doesn't make sense in the school algebra so reasoning about isomorphic
 types is basically school level algebra involving polynomials and powers
 so if you are familiar with all these identities as you should be it will
 be very easy for you the reason about what types are equivalent as long
 as all these types are made up of constants or primitive types disjunctions
 tuples or conjunctions and functions which will then directly be translated
 into exponential polynomial expressions constants sums products and expand
 powers or Exponential's so I call these exponential polynomial types that
 is types built up from these type constructions so all we have been talking
 about in this tutorial is what I call exponential polynomial types these
 are the basic type constructions that I started with tuple product function
 exponential disjunction some unit constant or 1 now just one comment that
 in the functional programming community today there is a terminology algebraic
 types so people usually call algebraic types the types that are made from
 constant types sums and products excluding Exponential's I do not find
 this terminology it's very helpful I find it confusing because what is
 particularly an algebraic about these identities these are identities of
 school algebra the properties of the function type are described by algebraic
 identities like this so it would be strange to call the function type not
 algebraic whereas these types are algebraic they are very similar to each
 other in terms of their properties being described by identity is known
 from school algebra so instead of algebraic types I would prefer to say
 polynomial types this is much more descriptive and precise and if you want
 to talk about function types as well then you just can you can just say
 exponential polynomial types or exfoli types for short so by way of summarizing
 what we have done so far what are the practical implications of the career
 Howard correspondence so one set of implications is actually for writing
 code and reason and eternal code one thing we can do now is if we're given
 a function with some type and usually this will be typed with type parameters
 all type trainers fully parametric types such as the function we have been
 considering here all these functions do not have any types that are specific
 like integer or string all the types are fully parametric and then there
 are some constructions some type expressions made out of these types so
 these are what I call fully parametric functions for these functions we
 have a decision procedure an algorithm that based on the ljt calculus which
 decides whether this function can be implemented in code and computer scientist
s a type is inhabited if you can produce a value of this type in your program
 so CH of T is this proposition which they call type is inhabited and I
 prefer to call it just that you can compute a value of this type or code
 has the type O code can create a value of this type and so we have a algorithm
 that can also generate the code from type when it is possible if it is
 not possible the algorithm will tell you so often not always but often
 this algorithm can be used actually to generate the code you want we can
 also use what I call the arithmetic of glory Harvard correspondence to
 reason about type isomorphisms and to transform types isomorphic we simplify
 type expressions just like we simplify expressions in school level algebra
 by expanding brackets by permuting the order of terms like a plus B is
 equal to B plus a or associativity a times B all times C can be expanded
 and so on so this allows us once we have written types in the short notation
 in the notation that I prefer which resembles school algebra because it
 uses the plus and times symbols instead of the logic symbols so once we
 rewrite our types and this notation which I have been doing consistently
 in this tutorial it enables us the reason very easily but which types are
 equal or isomorphic because we are all familiar with the school level algebra
 what are the problems that we cannot solve using this knowledge one thing
 we cannot do is to generate code automatically such that it will be an
 isomorphism so for instance in an example here we are able to generate
 automatically the code of these functions but it will not be an isomorphism
 and the lgt algorithm cannot check that this is nice a morphism that's
 the important thing this algorithm does not know about equations or isomorphism
s it only knows that it found some code that has the type you wanted whether
 this code is useful to you or not we don't know the algorithm doesn't know
 this also if the algorithm finds several such several proofs of a sequence
 it will generate several not in equivalent versions of your code it doesn't
 know which one is is useful maybe some of them are useless maybe not the
 algorithm cannot automatically decide that in general another thing we
 cannot do is to express complicated conditions via types such as that array
 is sorted the type system is not powerful enough in all the languages I
 listed you need a much more powerful type system such as that in the programmin
g language interests or add them or cook those are much more powerful type
 systems that can express such complicated conditions but for those type
 systems there is no algorithm that will generate code another thing we
 cannot do is to generate code that has type constructors such as the map
 function here's an example in Scala this is a map function on a list so
 there's the list of a a is a type parameter and then we say dot map and
 map has another type frame to be it takes a function from A to B for any
 B so a is fixed but now from any B we can take a function from A to B and
 generate a list of B so if we wrote this formula in the short type notation
 this would look something like this I'm writing subscript a because this
 is a type parameter so this is like an argument or a type parameter I'm
 writing it like this and then from this this is the first argument of the
 function and then there is a second argument which is this F and that is
 another quantifier for B inside parentheses so this formula has a quantifier
 inside so far we have been dealing with formulas that have all quantifiers
 outside and so we never write quantifiers explicitly but here we have to
 write them inside this is a more powerful logic which is called first-order
 logic in other words this is a logic where you have quantifiers anywhere
 in the formula including inside the formula unfortunately this logic is
 undecidable so there is no algorithm that we can use either to find the
 proof and therefore code freedom type or to show that there is no proof
 no code so we're kind of stuck in all these directions some more remarks
 about the curry Harvard correspondence first is that only with parameterize
 types we can get some interesting information out of it if we take concrete
 types like integer then the proposition CH event meaning that our code
 can have a value of type int it that's always true can always write any
 some integer value we don't need any previous data for it so for all specific
 types all these propositions are always choice completely void of information
 the only interesting part comes when we start considering type variables
 if we start asking can we make a type which is either of a B going to a
 going to B in soon for all a B once we start doing this with type parameters
 a B and so on then we get interesting information as we have seen in this
 tutorial another remark is that functions like this one are not sufficiently
 described by their type so that this is the type of integer going to integer
 now looking at this type we can put this into a sequence but we'll never
 get enough information to actually get this function so only certain class
 of functions which are fully typed biometric their type signature is informativ
e enough so that we can derive code automatically only in much more powerful
 type systems you can have type information that is enough to specify fully
 a code like this another caveat is that I don't know the proof that arithmetic
 identity guarantees the type equivalence it is certainly a necessary condition
 because if two types have different cardinality or different size of their
 sets of values that they cannot be equivalent or they cannot be isomorphic
 so this is a necessary condition but it's not a sufficient condition it
 looks like I don't know if this is sufficient I haven't seen any counter
 examples so far final remarks about type correspondence the logical constant
 false did not appear in any of my slides so far this was on purpose it
 has extremely limited practical use in programming languages because actually
 we have types corresponding to false Scala has type called nothing Haskell
 has type usually called void that corresponds to the logical constant false
 what does it mean CH of nothing is false it means your code can never have
 a value of type nothing or in Haskell void you can never compute a value
 of this type so clearly it has a very limited practical significance you
 will never be able to compute any values of this type ever in any program
 it's identically falseness this constant so if you want to add it to the
 logic it's very easy you just have one rule and you're not done you can
 derive things with it if you want but they will have almost never any use
 in practical code also we did not talk about negation none of the calculus
 calculate that I should have in logical negation as in operation again
 for the same reason we do not have a programming language construction
 that represents logical negation negation by definition is like this is
 an application from 8 to 4 so that's not a not a means from a follows falsehood
 now since you cannot ever get false in a programming language you cannot
 really implement this function in any useful sense and so i have seen some
 haskell library that used this type void as a type parameter in some way
 but certainly it's a very limited and rare use and so it is not really
 lumen 18 to include negation it could probably find some very esoteric
 uses of it but almost never useful and finally there is another set of
 important implications from the Kurihara correspondence these are implications
 for people who want to design new programming languages as we have seen
 the Karaka with correspondence maps the type system of a programming language
 into a certain logical system where prepositions follow from each other
 or can be proved from each other and this enables us to reason about programmed
 to see what kind of code can be written if some other kind of code can
 be written and logical reasoning is very powerful it's simpler than trying
 to write code and it gives you algorithms and all kinds of mathematical
 results that have been found over the centuries so languages like those
 listed here have all the five type constructions that I wasted in the beginning
 of this tutorial and mapping them into logic gives a full constructive
 logic or full intuitionistic logic with all logical operations and or so
 conjunction disjunction implication and the truth constant whereas languages
 such as C C++ Java and c-sharp and so on they're mapped to incomplete logics
 because they do not have some of these operations for instance they do
 not have type constructions of correspond to disjunction we also do not
 have the true constant or the false constant so they are mapped to a logic
 that lacks some of the foundational logical operation so it can be only
 fewer theorems can be proved in that logic and so your reasoning about
 theory types is hampered languages called scripting languages sometimes
 such as Python or JavaScript will be and so on also our belongs there in
 that line those languages only have one type they actually don't check
 types at compile time and so they're mapped to logics with only one proposition
 those logics are extremely small in terms of what kind of things you can
 reason about and so if you write a program in these languages you are completel
y unable to reason at the level of types whereas in these languages you
 are able to reason but in a limited way you're not having a complete logic
 so this suggests a principle for designing the type system in a new programming
 language the first step would be to choose a good and complete logic that
 is free of inconsistency mathematicians have studied all kinds of logics
 and they are always interested in questions such as is this logic consistent
 consistent means you cannot derive false from true is this logic complete
 can you derive all things that are true are there enough axioms and rules
 of derivation or maybe there are too many axioms and rules of derivation
 you can delete some of them and have fewer mathematicians have always been
 interested in such questions they found all kinds of interesting logics
 where you can derive a lot of interesting theorems non trivial theorems
 and they found the minimum sets of axioms and rules of derivations for
 these logics use their results take one of the logics that they do them
 and develop such as intuitionistic logic model logic temporal logic linear
 logic and so on take one of these logics for each of the basic operations
 of this logic provide type constructions in your programming language that
 are easy to use for instance your logic has disjunction implication or
 something else provide a type constructor for each of them that's easy
 to use easy to write down such as provided by the languages we have seen
 then every type will be mapped to a logical form of the OPF logical formula
 for every type and there will be a type for every logical formula and then
 for each rule of the new logic for each derivation rule there should be
 a construct in the code that corresponds to it so that you could transform
 proofs in logic into code and code into proofs if you do that your language
 will be faithful to the scorecard correspondence you will be able to use
 logic to reason about your language and one important result at this level
 while we have seen that you can sometimes generate code that is maybe nice
 but a very important result is that if your logic is free of inconsistency
 it means that no program will ever be able to derive an inconsistent an
 inconsistent type means that you had a function that requires some type
 a but it was called with a different type beam which is incompatible and
 that basically crashes so in languages like C and C++ we have all kinds
 of crashes like a segmentation fault in Java the exceptions nullpointerexceptio
n or class cast exception which happens when you call a function on the
 wrong type of argument and that happens if your logic is inconsistent if
 your logic can derive incorrect statements from correct premises then if
 you translate that derivation into code and the that code will derive incompati
ble type at the wrong place and it will crash the crash will happen at runtime
 the compiler will not catch this inconsistency because the compiler only
 checks the logic of types and the logic checks out you have followed the
 rules of derivation of the logic the compiler can check out all these logical
 rules but the compiler does not know that your logic is inconsistent maybe
 and then it will deep have derived an inconsistent result falsehood from
 truth for example and that will crash at runtime now we know that crashing
 at runtime is not a good outcome so in fact languages like Oh camel have
 been studied and for other languages some subsets of Haskell I believe
 called safe Haskell have been studied and it has been shown that they cannot
 crash and they're the way to show it mathematically is to use the fact
 that they are based on a complete and consistent logic and then all you
 need to show is that your compiler does not have some critical bugs that
 allow it to oversee that you have not followed the derivation rules of
 the logic that is an extremely valuable feature of functional programming
 languages that are based on the Curie habit correspondence you can prove
 their safety at compile time or at least exclude a large number of possible
 bugs and errors certainly these languages are quite large and they include
 features that are not covered by the Carey Hart correspondence type constructor
s that I have not considered in this tutorial and those might may not be
 safe but at least the foundation of these languages the foundation of the
 type system will be safe so that is the final lesson from the great Howard
 correspondence this concludes the tutorial
\end_layout

\end_inset


\end_layout

\end_body
\end_document
