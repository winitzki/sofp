#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[What I learned about FP]{What I learned about functional programming}
\subtitle{while writing a book on it}
\author{Sergei Winitzki}
\date{2021-10-29}
\institute[SBTB]{Scale by the Bay 2021}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\usepackage[nocenter]{qtree}
\usepackage{relsize}
\renewcommand\arraystretch{1.4}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why write a book about functional programming.
 I
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
My background: theoretical physics
\end_layout

\begin_layout Itemize
I used to write academic papers with lots of formulas and diagrams
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Winitzki - conformal diagrams - sample page.png
	lyxscale 40
	width 25col%

\end_inset


\begin_inset Graphics
	filename Winitzki - physics paper - sample page.png
	lyxscale 40
	height 47theight%

\end_inset


\begin_inset Graphics
	filename Winitzki - eibook - sample page.png
	lyxscale 40
	width 20col%

\end_inset


\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Itemize
Repented and turned to software engineering in 2010
\end_layout

\begin_layout Standard
I have been studying FP since 2008 (OCaml, Haskell, Scala)
\end_layout

\begin_layout Itemize
Learning from papers, books, online tutorials, and meetups
\end_layout

\begin_layout Itemize
Attending the SBTB conferences since 2014
\end_layout

\begin_layout Itemize
Using Scala at my day job since 2015
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why write a book about functional programming.
 II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
I found the FP community to be unlike other programmers' communities
\end_layout

\begin_layout Itemize
Others are focused on a chosen programming language (Java, Python, JavaScript,
 etc.), and on designing and using libraries and frameworks
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
\begin_inset Quotes eld
\end_inset

use this framework, override this method, use this annotation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The FP community talks in a very different way
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
\begin_inset Quotes eld
\end_inset

referential transparency, algebraic data types, monoid laws, parametric
 polymorphism, free applicative functors, monad transformers, Yoneda lemma,
 Curry-Howard isomorphism, profunctor lenses, catamorphisms
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "A glossary of FP terminology"
target "https://degoes.net/articles/fp-glossary"
literal "false"

\end_inset

 (more than 
\begin_inset Formula $100$
\end_inset

 terms)
\end_layout

\end_deeper
\begin_layout Itemize
From SBTB 2018: 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "The Functor,  Applicative,  Monad talk"
target "https://www.youtube.com/watch?v=L0aYcq1tqMo"
literal "false"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
By 2018, everyone expects to hear a talk about these concepts
\end_layout

\end_deeper
\begin_layout Itemize
An 
\begin_inset CommandInset href
LatexCommand href
name "actual Scala error message"
target "https://stackoverflow.com/questions/36002541/mysterious-gadt-skolem-what-type-is-trying-to-escape-its-scope"
literal "false"

\end_inset

:
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
\color blue
found   : Seq[Some[V]]
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
required: Seq[Option[?V8]] where type ?V8 <: V (this is a GADT skolem)
\end_layout

\begin_layout Standard
To do FP, should I learn all of this? How do I learn about this?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why write a book about functional programming.
 III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Main questions:
\end_layout

\begin_layout Itemize
Which theoretical knowledge will actually help write Scala code?
\end_layout

\begin_layout Itemize
Where can one learn this FP theory, with definitions and examples?
\end_layout

\begin_deeper
\begin_layout Itemize
What do the monad laws ensure? How to verify those laws?
\end_layout

\begin_layout Itemize
When is a data structure a functor (or monad, or applicative)?
\end_layout

\end_deeper
\begin_layout Standard
Reading various materials has given me more questions than answers
\end_layout

\begin_layout Itemize
Heuristic explanations without derivations and proofs
\end_layout

\begin_deeper
\begin_layout Itemize
Most FP books show code without proofs or rigorous definitions
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
\begin_inset CommandInset href
LatexCommand href
name "The Book of Monads"
target "https://www.amazon.com/Book-Monads-Alejandro-Serrano-Mena/dp/0578405296"
literal "false"

\end_inset


\emph default
 does not prove the laws for any monads
\end_layout

\end_deeper
\begin_layout Itemize
A few books (
\begin_inset CommandInset href
LatexCommand href
name "Haskell Wikibooks"
target "https://en.wikibooks.org/wiki/Haskell"
literal "false"

\end_inset


\emph on
, 
\begin_inset CommandInset href
LatexCommand href
name "Introduction to functional programming using Haskell"
target "https://www.amazon.co.uk/Introduction-Functional-Programming-Prentice-Hall-Paperback/dp/B00OVNLJTS/"
literal "false"

\end_inset

,
\emph default
 and 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "Functional programming in Scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\emph default
) include some simple proofs
\end_layout

\end_deeper
\begin_layout Itemize
Abstract, 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 theory with no applications in programming
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Monad is just a monoid in the category of endofunctors"
target "https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Any monad comes from an explicit adjunction of some functors"
target "https://en.wikipedia.org/wiki/Monad_(category_theory)#Monads_arising_from_adjunctions"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why write a book about functional programming.
 IV
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
I am writing a 
\begin_inset CommandInset href
LatexCommand href
name "new book"
target "https://leanpub.com/sofp"
literal "false"

\end_inset

 to answer all my FP questions
\end_layout

\begin_layout Itemize
by motivating and deriving all results from scratch
\end_layout

\begin_layout Itemize
organizing systematically the practice-relevant parts of FP theory
\end_layout

\begin_layout Standard

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "78col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -40baselineskip%
\end_inset

The book explains (with code examples and exercises):
\end_layout

\begin_layout Itemize
theory and applications of major design patterns of FP
\end_layout

\begin_layout Itemize
techniques for deriving and verifying properties of types and code (typeclass
 laws, equivalence of types)
\end_layout

\begin_layout Itemize
practical motivations for (and applications of) these techniques
\end_layout

\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "27col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename book-draft-cover.png
	lyxscale 20
	width 2.5cm

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\size small
Status of the book: 12.5 out of 14 chapters are ready
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 I.
 Questions that have rigorous answers
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
In FP, a programmer encounters certain questions about code that can be
 answered rigorously 
\end_layout

\begin_layout Itemize
The answers will guide the programmer in designing the code
\end_layout

\begin_layout Itemize
The answers are 
\emph on
not
\emph default
 a matter of opinion or experience
\end_layout

\begin_layout Itemize
The answers are found via mathematical derivations and reasoning
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks.
 I
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{0}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Can we compute a value of type 
\family typewriter
\size footnotesize
\color blue
Either[Z, R => A]
\family default
\size default
\color inherit
 given a value of type 
\family typewriter
\size footnotesize
\color blue
R => Either[Z, A]
\family default
\size default
\color inherit
 and conversely? (
\family typewriter
\size footnotesize
\color blue
A
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
R
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Z
\family default
\size default
\color inherit
 are type parameters.)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def f[Z, R, A](r: R => Either[Z, A]): Either[Z, R => A] = ???
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def g[Z, R, A](e: Either[Z, R => A]): R => Either[Z, A] = ???
\end_layout

\begin_layout Itemize
We can implement 
\family typewriter
\size footnotesize
\color blue
g
\family default
\size default
\color inherit
, and there is only one way:
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def g[Z, R, A](e: Either[Z, R => A]): R => Either[Z, A] =
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  r => e.map(f => f(r))       // 
\family default
\color inherit
Scala 2.12 code
\end_layout

\begin_layout Itemize
It turns out that 
\family typewriter
\size footnotesize
\color blue
f
\family default
\size default
\color inherit
 
\emph on
cannot
\emph default
 be implemented
\end_layout

\begin_deeper
\begin_layout Itemize
Not because we are insufficiently clever, but because...
 math!
\end_layout

\end_deeper
\begin_layout Itemize
Programmers need to develop intuition about why this is so
\end_layout

\begin_layout Itemize
These results are rigorous
\end_layout

\begin_deeper
\begin_layout Itemize
The Curry-Howard isomorphism and the LJT algorithm
\end_layout

\begin_layout Itemize
The code for 
\family typewriter
\size footnotesize
\color blue
g[Z, R, A]
\family default
\size default
\color inherit
 can be generated automatically
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks.
 II
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{1}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
How to use 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
 with 
\family typewriter
\size footnotesize
\color blue
Either[Z, A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Future[A]
\family default
\size default
\color inherit
 together?
\end_layout

\begin_layout LyX-Code

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.15cm}
\end_layout

\end_inset


\family typewriter
\color blue
val result = for { // This code will not compile; need to combine...
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  a <- Future(...) //  ...
 a computation that is run asynchronously,
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  b <- Either(...) // a computation whose result may be unavailable,
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
  c <- Future(...) // and another asynchronous computation.
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
} yield ???     // Continue computations when results are available.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space \hspace*{}
\length 1.8mm
\end_inset

Should 
\family typewriter
\size footnotesize
\color blue
result
\family default
\size default
\color inherit
 have type 
\family typewriter
\size footnotesize
\color blue
Either[Z, Future[A]]
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Future[Either[Z,A]]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space \hspace*{}
\length 1.8mm
\end_inset

How to combine 
\family typewriter
\size footnotesize
\color blue
Either
\family default
\size default
\color inherit
 with 
\family typewriter
\size footnotesize
\color blue
Future 
\family default
\size default
\color inherit
so that we can use 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
?
\end_layout

\begin_layout Itemize
It turns out that 
\family typewriter
\size footnotesize
\color blue
Either[Z, Future[A]]
\family default
\size default
\color inherit
 is wrong (cannot implement 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 correctly).
 The correct type is 
\family typewriter
\size footnotesize
\color blue
Future[Either[Z, A]]
\family default
\size default
\color inherit
.
\end_layout

\begin_layout Itemize
Programmers need to develop intuition about why this is so
\end_layout

\begin_layout Itemize
This is a rigorous result (programmers do not need to test it)
\end_layout

\begin_deeper
\begin_layout Itemize
The theory of monad transformers and their laws
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of reasoning tasks.
 III
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

[]
\backslash
setcounter{enumi}{2}
\end_layout

\end_inset


\size footnotesize

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Can we implement 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 for the type constructor 
\family typewriter
\size footnotesize
\color blue
Option[(A, A, A)]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def flatMap[A, B](fa: Option[(A, A, A)])(f: A => Option[(B, B, B)])
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
   : Option[(B, B, B)] = ???
\end_layout

\begin_layout Itemize
It turns out that 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 
\emph on
can
\emph default
 be implemented but fails the monad laws
\end_layout

\begin_layout Itemize
Programmers need to develop intuition about why this is so
\end_layout

\begin_deeper
\begin_layout Itemize
How should we modify 
\family typewriter
\size footnotesize
\color blue
Option[(A, A, A)]
\family default
\size default
\color inherit
 to make it into a monad?
\end_layout

\begin_deeper
\begin_layout Itemize
For example, 
\family typewriter
\size footnotesize
\color blue
Either[A, (A, A, A)]
\family default
\size default
\color inherit
 is a lawful monad
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
This is a rigorous result (programmers do not need to test it)
\end_layout

\begin_deeper
\begin_layout Itemize
The theory of monads and their laws
\end_layout

\begin_layout Itemize
The theory of type constructions of monads
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 II.
 Functional programming is engineering
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
FP is similar to engineering in some ways
\end_layout

\begin_deeper
\begin_layout Itemize
Mechanical, electrical, chemical engineering are based on calculus, classical
 and quantum mechanics, electrodynamics, thermodynamics
\end_layout

\begin_deeper
\begin_layout Itemize
These sciences give engineers rigorous answers to certain questions relevant
 to engineering design
\end_layout

\end_deeper
\begin_layout Itemize
FP is based on category theory, type theory, logic proof theory
\end_layout

\begin_deeper
\begin_layout Itemize
These theories give programmers rigorous answers to certain questions relevant
 to writing code
\end_layout

\end_deeper
\begin_layout Itemize
Programming in non-FP paradigms is similar to 
\emph on
artisanship
\emph default
 
\end_layout

\end_deeper
\begin_layout Itemize
Engineers use special terminology
\end_layout

\begin_deeper
\begin_layout Itemize
Examples from mechanical, electrical, chemical engineering: 
\begin_inset CommandInset href
LatexCommand href
name "rank-4 tensors"
target "https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral_physics/tensors.html"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Lagrangians with non-holonomic constraints"
target "https://arxiv.org/abs/math/0008147"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Fourier transform of the delta function"
target "https://www.youtube.com/watch?v=KAbqISZ6SHQ"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "inverse Z-transform"
target "https://ocw.mit.edu/resources/res-6-008-digital-signal-processing-spring-2011/video-lectures/lecture-6-the-inverse-z-transform/"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Gibbs free energy"
target "https://www.amazon.com/Introduction-Chemical-Engineering-Kinetics-Reactor/dp/1118368258"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
Examples from FP: 
\begin_inset CommandInset href
LatexCommand href
name "rank-$N$ types"
target "https://wiki.haskell.org/Rank-N_types"
literal "true"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "continuation-passing transformation"
target "https://www.cs.toronto.edu/~lczhang/324/ex/a2.pdf"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "polymorphic lambda functions"
target "https://stackoverflow.com/questions/20152939/what-is-a-polymorphic-lambda"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "free monads"
target "https://stackoverflow.com/questions/13352205/what-are-free-monads"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "hylomorphisms"
target "https://en.wikipedia.org/wiki/Hylomorphism_(computer_science)"
literal "false"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
As in engineering, the special terminology in FP is 
\emph on
not
\emph default
 self-explanatory
\end_layout

\begin_deeper
\begin_layout Itemize
What is a delta function? What is a lambda function? 
\end_layout

\begin_layout Itemize
What is the Gibbs free energy? What is the free monad?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 III.
 The science of 
\family typewriter
map
\family default
 / 
\family typewriter
filter
\family default
 / 
\family typewriter
reduce
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
/
\family typewriter
\size footnotesize
\color blue
reduce
\family default
\size default
\color inherit
 (MFR) programming style: iteration without loops
\end_layout

\begin_layout Itemize
Compute the list of all integers 
\begin_inset Formula $n$
\end_inset

 between 1 and 100 that can be expressed as 
\begin_inset Formula $n=p*q$
\end_inset

 (with 
\begin_inset Formula $2\leq p\leq q$
\end_inset

) in exactly 
\begin_inset Formula $4$
\end_inset

 different ways 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> (1 to 100).filter { n =>
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     |   4 == (2 to n).count { x => n % x == 0 && x * x <= n }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
     | }
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
res0: IndexedSeq[Int] = Vector(36, 48, 80, 100)
\end_layout

\begin_layout Standard
The MFR programming style is an FP success story
\end_layout

\begin_layout Itemize
Nameless functions (
\begin_inset Quotes eld
\end_inset

lambdas
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

closures
\begin_inset Quotes erd
\end_inset

) are widely used
\end_layout

\begin_deeper
\begin_layout Itemize
and have been added to most programming languages by now
\end_layout

\end_deeper
\begin_layout Itemize
Essential methods: 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\end_layout

\begin_layout Itemize
Similar techniques work with parallel and stream processing (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Spark
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
Similar techniques work with relational databases (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Slick
\end_layout

\end_inset

) 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 III.
 The science of 
\family typewriter
map
\family default
 / 
\family typewriter
filter
\family default
 / 
\family typewriter
reduce
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Essential MFR methods: 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\end_layout

\begin_layout Itemize
What data types other than 
\family typewriter
\size footnotesize
\color blue
Seq[A]
\family default
\size default
\color inherit
 can support these methods?
\end_layout

\begin_deeper
\begin_layout Itemize
Algebraic data types, such as 
\family typewriter
\size footnotesize
\color blue
(A, Either[String, Option[A]])
\end_layout

\begin_layout Itemize
Trees and other recursive types 
\end_layout

\begin_layout Itemize
Perfect-shaped trees 
\begin_inset Preview

\begin_layout Standard

\size scriptsize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] [ [ [ $a_5$ ]
 [ $a_6$ ] ] [ [ $a_7$ ] [ $a_8$ ] ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Which methods can be defined for 
\family typewriter
\size footnotesize
\color blue
MyData[A]
\family default
\size default
\color inherit
?
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
type MyData[A] = String => Option[(String, A)]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 III.
 The science of 
\family typewriter
map
\family default
 / 
\family typewriter
filter
\family default
 / 
\family typewriter
reduce
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
A systematic approach to understanding FP via a study of MFR
\end_layout

\begin_layout Itemize
Determine the required laws of 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\end_layout

\begin_deeper
\begin_layout Itemize
The laws express the programmers' expectations about code behavior
\end_layout

\begin_layout Itemize
Define the corresponding typeclasses
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Functor
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Filterable
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Monad
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
zip
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Applicative
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
fold
\family default
\size default
\color inherit
 — 
\family typewriter
\size footnotesize
\color blue
Traversable
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Find type constructions that preserve the typeclass laws
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Q[A]
\family default
\size default
\color inherit
 are filterable functors then so is 
\family typewriter
\size footnotesize
\color blue
Either[P[A], Q[A]]
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 is a monad then so is 
\family typewriter
\size footnotesize
\color blue
Either[A, P[A]]
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Q[A]
\family default
\size default
\color inherit
 are monads then so is 
\family typewriter
\size footnotesize
\color blue
(P[A], Q[A])
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 is a contravariant functor then 
\family typewriter
\size footnotesize
\color blue
P[A] => A
\family default
\size default
\color inherit
 is a monad
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size footnotesize
\color blue
P[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
Q[A]
\family default
\size default
\color inherit
 are applicative then so is 
\family typewriter
\size footnotesize
\color blue
Either[P[A], (A, Q[A])]
\end_layout

\begin_deeper
\begin_layout Itemize
I found many more type constructions of this kind
\end_layout

\end_deeper
\begin_layout Itemize
Sometimes it becomes necessary to define additional typeclasses
\end_layout

\begin_deeper
\begin_layout Itemize
Contravariant functor, contravariant filterable, contravariant applicative
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Develop intuition about implementing lawful typeclass methods 
\end_layout

\begin_layout Itemize
Develop intuition about data types that can have those methods
\end_layout

\begin_deeper
\begin_layout Itemize
...
 and about data types that 
\emph on
cannot
\emph default
 (and reasons why)
\end_layout

\end_deeper
\begin_layout Itemize
Develop notation and proof techniques for proving the laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 IV.
 The logic of types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
FP is not just 
\begin_inset Quotes eld
\end_inset

programming with functions
\begin_inset Quotes erd
\end_inset

: types play a central role
\end_layout

\begin_layout Itemize
The compiler needs to check all types at compile time
\end_layout

\begin_layout Itemize
The language needs to support certain type constructions
\end_layout

\begin_layout Standard
Most of FP use cases are based on only six type constructions:
\end_layout

\begin_layout Itemize
Unit type — 
\family typewriter
\size footnotesize
\color blue
Unit
\end_layout

\begin_layout Itemize
Type parameters — 
\family typewriter
\size footnotesize
\color blue
f[A](x)
\end_layout

\begin_layout Itemize
Product types — 
\family typewriter
\size footnotesize
\color blue
(A, B)
\end_layout

\begin_layout Itemize
Co-product types (
\begin_inset Quotes eld
\end_inset

disjunctive union
\begin_inset Quotes erd
\end_inset

 types) — 
\family typewriter
\size footnotesize
\color blue
Either[A, B]
\end_layout

\begin_layout Itemize
Function types — 
\family typewriter
\size footnotesize
\color blue
A => B
\end_layout

\begin_layout Itemize
Recursive types — 
\family typewriter
\size footnotesize
\color blue
Fix[A, S]
\family default
\size default
\color inherit
 where 
\family typewriter
\size footnotesize
\color blue
S[_, _]
\family default
\size default
\color inherit
 is a 
\begin_inset Quotes eld
\end_inset

recursion scheme
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
final case class Fix[A, S[_, _]](unfix: S[A, Fix[A, S]])
\end_layout

\begin_layout Standard
Going through all possible type combinations, we can enumerate essentially
 all possible typeclass instances
\end_layout

\begin_layout Itemize
all possible functors, filterables, monads, applicatives, traversables,
 etc.
\end_layout

\begin_layout Itemize
in some cases, we can generate typeclass instances automatically
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 IV.
 The logic of types
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Unit, product, co-product, and function types correspond to logical propositions
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(true)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A and B)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A or B)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(if A then B)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Not all programming languages support all of these type constructions
\end_layout

\begin_deeper
\begin_layout Itemize
The logic of types is 
\emph on
incomplete
\emph default
 in those languages
\end_layout

\end_deeper
\begin_layout Itemize
Languages that do not support co-products will make you suffer
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
fileOpened, err := os.Open("filename.txt")     // go-lang has you
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
if err != nil { log.Fatal(err) }  // doomed to write this forever
\end_layout

\begin_layout Itemize
Returning a pair (both a result and an error) instead of a disjunction (either
 a result or an error) promotes many ways of making hard-to-find mistakes
\end_layout

\begin_deeper
\begin_layout Itemize
In Scala, we may just return 
\family typewriter
\size footnotesize
\color blue
Try[Result]
\family default
\size default
\color inherit
 or 
\family typewriter
\size footnotesize
\color blue
Either[Error, Result]
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
My approach forced me to formulate and prove every statement
\end_layout

\begin_layout Standard
Each chapter gave me at least one surprise
\end_layout

\begin_layout Itemize
What I believed and tried to prove turned out to be incorrect
\end_layout

\begin_layout Itemize
What seemed to be intuitively unexpected turned out to be true
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapters 1 to 3:
\end_layout

\begin_layout Itemize
Nameless functions are used in mathematics too, just hidden
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\sum_{n=1}^{100}n^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\color blue
(1 to 100).map { n => n * n }.sum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\int_{0}^{1}\sin\,(x^{3})\,dx$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\color blue
integrateNumerically(0, 1) { x => math.sin(x * x * x) }
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Many algorithms require non-tail-recursive code (
\size footnotesize
\color blue
map
\size default
\color inherit
 for a tree)
\end_layout

\begin_layout Itemize
Perfect-shaped trees 
\emph on
can
\emph default
 be defined via recursive ADTs
\end_layout

\begin_layout Standard
\align center
\begin_inset Preview

\begin_layout Standard

\size scriptsize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] [ [ [ $a_5$ ]
 [ $a_6$ ] ] [ [ $a_7$ ] [ $a_8$ ] ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset VSpace -30baselineskip%
\end_inset

Chapters 4 and 5: a practical application of the Curry-Howard isomorphism
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Type inference
\begin_inset Quotes erd
\end_inset

 — determining type signature from given code
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Code inference
\begin_inset Quotes erd
\end_inset

 — determining code from given type signature
\end_layout

\begin_layout Itemize
The 
\family typewriter
\size footnotesize
\color blue

\begin_inset CommandInset href
LatexCommand href
name "curryhoward"
target "https://github.com/Chymyst/curryhoward"
literal "false"

\end_inset


\family default
\size default
\color inherit
 library uses the LJT algorithm for code inference
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
import io.chymyst.ch._
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> def in[A, B](a: A, b: Option[B]): Option[(A, B)] = implement
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def in[A, B](a: A, b: Option[B]): Option[(A, B)]
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> in(1.5, Some(true))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
val res0: Option[(Double, Boolean)] = Some((1.5,true))
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> def h[A, B]: ((((A => B) => A) => A) => B) => B  =  implement
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
def h[A, B]: ((((A => B) => A) => A) => B) => B
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> println(h.lambdaTerm.prettyPrint)
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
a ⇒ a (b ⇒ b (c ⇒ a (d ⇒ c))) 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
scala> def g[A, B]: ((((A => B) => B) => A) => B) => B  =  implement
\end_layout

\begin_layout LyX-Code

\family typewriter
\size footnotesize
\color blue
error: type ((((A ⇒ B) ⇒ B) ⇒ A) ⇒ B) ⇒ B cannot be implemented
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapters 6 to 8:
\end_layout

\begin_layout Itemize
Functions of type ADT => ADT can be manipulated via matrices
\end_layout

\begin_deeper
\begin_layout Itemize
Matrix code notation is useful in symbolic proofs
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\size footnotesize
\color blue
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
val p: Either[A, B] => Either[C, D] = {
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    case Left(x)   => Right(f(x))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
    case Right(y)  => Left(g(y))
\end_layout

\begin_layout LyX-Code

\size footnotesize
\color blue
}
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\size scriptsize
\color inherit

\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size scriptsize
\begin_inset Formula 
\[
\quad\begin{array}{|c||cc|}
 & C & D\\
\hline A & \bbnum 0 & x\rightarrow f(x)\\
B & y\rightarrow g(y) & \bbnum 0
\end{array}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset VSpace 75baselineskip%
\end_inset

Typeclasses can be viewed as partial functions from types to values
\end_layout

\begin_layout Itemize

\emph on
All
\emph default
 non-parameterized types have a monoid structure
\end_layout

\begin_layout Itemize
Subtypes / supertypes are not always the same as supersets / subsets
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapters 9 to 12:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Filterable functors
\begin_inset Quotes erd
\end_inset

 are a neglected typeclass with useful properties
\end_layout

\begin_layout Itemize
Data types 
\family typewriter
\size footnotesize
\color blue
Option[(A, A)]
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Option[(A, A, A)]
\family default
\size default
\color inherit
, etc., 
\emph on
cannot
\emph default
 be monads
\end_layout

\begin_layout Itemize
Monads need 
\begin_inset Quotes eld
\end_inset

runners
\begin_inset Quotes erd
\end_inset

 to be useful, but some monads' runners do not obey the laws or cannot exist
 (
\family typewriter
\size footnotesize
\color blue
State
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Continuation
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
Without some laws, 
\family typewriter
\size footnotesize
\color blue
flatMap
\family default
\size default
\color inherit
 is 
\emph on
not
\emph default
 equivalent to 
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 with 
\family typewriter
\size footnotesize
\color blue
flatten
\end_layout

\begin_deeper
\begin_layout Itemize
It is not enough to write 
\family typewriter
\size footnotesize
\color blue
_.flatten == _.flatMap(identity)
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
_.flatMap(f) == _.map(f).flatten
\family default
\size default
\color inherit
, we need to prove an isomorphism
\end_layout

\end_deeper
\begin_layout Itemize
All contravariant functors are applicative (if defined using the six standard
 type constructions)
\end_layout

\begin_layout Itemize
Breadth-first traversal of trees 
\emph on
can
\emph default
 be defined via 
\family typewriter
\size footnotesize
\color blue
fold
\family default
\size default
\color inherit
 and 
\family typewriter
\size footnotesize
\color blue
traverse
\family default
\size default
\color inherit
 (not only depth-first traversal)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapter 13 (free typeclass constructions):
\end_layout

\begin_layout Itemize
Not all typeclasses have a 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 construction: there is free functor, filterable, applicative, etc.; but
 
\emph on
no
\emph default
 free foldable or free traversable
\end_layout

\begin_layout Itemize

\emph on
\begin_inset Quotes eld
\end_inset

Tagless final
\begin_inset Quotes erd
\end_inset

 is just a Church encoding of the free monad, what is the problem?
\end_layout

\begin_layout Itemize
It is hard to prove the correctness of the Church encoding
\end_layout

\begin_deeper
\begin_layout Itemize
My book uses relational parametricity together with some results from 
\begin_inset CommandInset href
LatexCommand href
name "unpublished talk slides"
target "https://www.ioc.ee/~tarmo/tday-voore/vene-slides.pdf"
literal "false"

\end_inset

 to prove that the Church encoding works
\end_layout

\begin_layout Itemize
...
 but programmers do not need to study those proofs
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What I learned.
 V.
 Miscellaneous surprises
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Chapter 14 (monad transformers):
\end_layout

\begin_layout Itemize
Monad transformers likely exist for all explicitly definable monads, but
 there is 
\emph on
no
\emph default
 general method or scheme for defining the transformers
\end_layout

\begin_layout Itemize
Some monad transformers are incomplete, not fully usable for combining monadic
 effects (
\family typewriter
\size footnotesize
\color blue
Continuation
\family default
\size default
\color inherit
, 
\family typewriter
\size footnotesize
\color blue
Codensity
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize

\emph on
Monad transformers are just pointed endofunctors in the category of monads,
 what is the problem?
\end_layout

\begin_layout Itemize
Monad transformers have 18 laws
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Conclusions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Functional programming has a steep learning curve
\end_layout

\begin_deeper
\begin_layout Itemize
Programmers can already benefit from the simplest techniques
\end_layout

\begin_deeper
\begin_layout Itemize
...
 and mostly stop there (
\family typewriter
\size footnotesize
\color blue
map
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
filter
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
fold
\family default
\size default
\color inherit
, ADTs, 
\family typewriter
\size footnotesize
\color blue
for
\family default
\size default
\color inherit
 / 
\family typewriter
\size footnotesize
\color blue
yield
\family default
\size default
\color inherit
)
\end_layout

\end_deeper
\begin_layout Itemize
Full 
\emph on
ab initio
\emph default
 derivations and proofs take 500 pages
\end_layout

\begin_layout Itemize
The difficulty is at the level of undergraduate calculus / algebra
\end_layout

\end_deeper
\begin_layout Itemize
Much of the theory is directly beneficial for coding
\end_layout

\begin_layout Itemize
Using FP techniques makes programmers' work closer to 
\emph on
engineering
\end_layout

\begin_layout Itemize
Full details in the free book — 
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
