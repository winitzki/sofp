#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Typeclasses and functions of types
\begin_inset CommandInset label
LatexCommand label
name "chap:Typeclasses-and-functions"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset


\end_layout

\begin_layout Section
Motivation and first examples
\end_layout

\begin_layout Subsection
Constraining type parameters
\end_layout

\begin_layout Standard
The summation method, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, works for any collection of numeric values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).sum
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(1.0, 2.0, 3.0).sum
\end_layout

\begin_layout Plain Layout

res1: Double = 6.0
\end_layout

\end_inset

We can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 to compute the average of a sequence of numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg(s: Seq[Double]): Double = s.sum / s.length
\end_layout

\end_inset

Can we generalize the averaging function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 to other numeric types, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T](s: Seq[T]): T = ???
\end_layout

\end_inset

This code is impossible because averaging works only for certain types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

, not for arbitrary types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 as implied by the type signature above.
 We will be able to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 only if we constrain the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 to be a type representing a suitable numeric value (e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BigDecimal
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Another example of a similar situation is a function with type signature
 
\begin_inset Formula $A\times F^{B}\rightarrow F^{A\times B}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def inject[F[_], A, B](a: A, f: F[B]): F[(A, B)] = f.map(b => (a, b))   
  // Must have `f.map`.
\end_layout

\end_inset

This function requires the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 to have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method, i.e., to be a functor.
 We can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inject
\end_layout

\end_inset

 only if we constrain the parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 to be a functor.
\end_layout

\begin_layout Standard
What would that constraint be like? Consider an ordinary function with no
 type parameters, e.g.:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement L
overhang 0in
width "28col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int): Int = x + 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In this code, the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: Int
\end_layout

\end_inset

 constrains the value of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to be integer.
 It is a type error to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to a non-integer argument.
 
\end_layout

\begin_layout Standard
Using a similar syntax for 
\emph on
type
\emph default
 
\emph on
parameters
\emph default
, we write the type signatures for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inject
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T: Fractional](s: Seq[T]): T
\end_layout

\begin_layout Plain Layout

def inject[F[_]: Functor, A, B](a: A, f: F[B]): F[(A, B)]
\end_layout

\end_inset

Scala uses the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[T: Fractional]
\end_layout

\end_inset

 to constrain the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 to 
\begin_inset Quotes eld
\end_inset

fractional numeric
\begin_inset Quotes erd
\end_inset

 types.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[F[_]: Functor]
\end_layout

\end_inset

 requires the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

 to be a functor.
 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inject
\end_layout

\end_inset

 to types that do not obey those constraints will be a type error detected
 at compile time.
\end_layout

\begin_layout Standard
In these examples, we are restricting a type parameter to a subset of possible
 types, because only types from that subset have certain properties that
 we need.
 A subset of types, together with the required properties that those types
 must satisfy, is called a 
\series bold
typeclass
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass
\end_layout

\end_inset

.
 The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[T: Fractional]
\end_layout

\end_inset

 is a 
\series bold
typeclass constraint
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!constraint
\end_layout

\end_inset

 that forces the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 to belong to the typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fractional
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
This chapter focuses on defining and using typeclasses and on understanding
 their properties.
 We will see in detail how the syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[T: Fractional]
\end_layout

\end_inset

 is implemented and used.
\end_layout

\begin_layout Subsection
Functions of types and values
\end_layout

\begin_layout Standard
The similarity between the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 and the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 is clear in this type signature,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T: Fractional](s: Seq[T]): T
\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
def avg[T: Fractional](s : Seq[T]): T = {
\end_layout

\begin_layout Plain Layout
val frac = implicitly[Fractional[T]]
\end_layout

\begin_layout Plain Layout
frac.div(s.sum, frac.fromInt(s.length)) 
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset

We can view 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 as a function that takes 
\emph on
two
\emph default
 parameters (a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 and a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

) and returns a value.
 We can also view 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 as a function from a 
\emph on
type
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 to a 
\emph on
value
\emph default
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[T] => T
\end_layout

\end_inset

.
 We may call functions of this kind 
\series bold
type-to-value
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type-to-value function
\end_layout

\end_inset

 functions (TVF).
 The syntax for TVFs supported in a future version of Scala 3 will show
 this more clearly:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val avg: [T] => Seq[T] => T = ...
   // Scala 3 only.
\end_layout

\end_inset

To emphasize that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 is a TVF, we may write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T: Fractional]: Seq[T] => T // Inconvenient in practice! Use avg[T:
 Fractional](s: Seq[T]): T
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A type constructor such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[_]
\end_layout

\end_inset

 can be viewed as a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type-to-type function
\end_layout

\end_inset


\series bold
type-to-type
\series default
 function (TTF) because it can take any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 and return a new type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[T]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Functions can map from values or from types and to values or to types, as
 this table shows:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
functions...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
from value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
from type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
to value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
(VVF)
\begin_inset space ~
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x:Int):Int
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
(TVF)
\begin_inset space ~
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def pure[A]: A => List[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
to type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
(VTF)
\begin_inset space ~
\end_inset

 dependent type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
(TTF)
\begin_inset space ~
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type MyData[A] = Either[Int, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
We have already seen examples of VVFs, TVFs, and TTFs.
 Value-to-type functions (VTFs) are known as 
\series bold
dependent
\series default
 
\series bold
types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent type
\end_layout

\end_inset

 (or, more verbosely, as 
\begin_inset Quotes eld
\end_inset

value-dependent types
\begin_inset Quotes erd
\end_inset

).
 An example in Scala:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "36col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x = new { type T = Int }
\end_layout

\begin_layout Plain Layout

val y: x.T = 123
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In this example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.T
\end_layout

\end_inset

 is a dependent type because it is a type that depends on the 
\emph on
value
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 For the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 defined in this code, the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.T
\end_layout

\end_inset

 evaluates to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We will not consider dependent types (VTFs) in this chapter because typeclasses
 only require a combination of a TTF and a TVF.
\end_layout

\begin_layout Subsection
Partial functions of types and values
\end_layout

\begin_layout Standard
We would like to define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T: Fractional]
\end_layout

\end_inset

 as a TVF that can be applied only to a subset of possible types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 This is similar to a 
\series bold
partial function
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset

, i.e., a function defined only for a subset of possible values of its argument's
 type.
 We may call such functions partial type-to-value functions
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial type-to-value function
\end_layout

\end_inset

 (PTVFs), to distinguish them from partial value-to-value functions (PVVFs)
 we saw before.
\end_layout

\begin_layout Standard
In some situations, partial functions are safe to use.
 For instance, the following partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p: Either[Int, String] => Int = { case Left(x) => x - 1 }
\end_layout

\end_inset

can be applied only to values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(...)
\end_layout

\end_inset

.
 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 to a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(...)
\end_layout

\end_inset

 will cause a run-time error.
 However, consider this code:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x = Seq(Left(1), Right(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

), Left(2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.filter(_.isLeft).map(p)
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(0, 1)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Although 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

x.filter(_.isLeft)
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Seq[Either[Int, String]]
\end_layout

\end_inset

, all values in that sequence are guaranteed to be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Left
\end_layout

\end_inset

.
 So we know it is safe to apply the partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

p
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

.map(p)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Although safe, this code is brittle: if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation were moved to another place, we might by mistake write code equivalen
t to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(p)
\end_layout

\end_inset

, causing a run-time exception.
 It is better to refactor the code so that the compile-time type-checking
 guarantees the safety of all operations at run time.
 For the example shown above, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

 method would make a partial function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, safe to use:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> x.collect { case Left(y) => y - 1 }
\end_layout

\begin_layout Plain Layout

res1: Seq[Int] = List(0, 1)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

collect
\end_layout

\end_inset

 method is a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
total function
\end_layout

\end_inset


\series bold
total
\series default
 function because it is defined for all values of its arguments and does
 not throw exceptions.
 
\end_layout

\begin_layout Standard
Total functions are safer to use than partial functions.
 The partial function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

p
\end_layout

\end_inset

 can be converted into a total function by changing its type to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Left[Int, String] => Int
\end_layout

\end_inset

.
 Another example: applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 is unsafe, but the non-empty list type guarantees at compile time that
 the first element exists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val xs: NonEmptyList[Int] = ...
\end_layout

\begin_layout Plain Layout

val h = xs.head  // .head is a total function for a NonEmptyList.
\end_layout

\end_inset

In these cases, we achieve safety by making types more strictly constrained.
 Similarly, partial type-to-value functions (PTVFs) become safe to use if
 we impose suitable typeclass constraints on the type parameters.
 Typeclasses can be viewed as a systematic way of safely managing PTVFs.
\end_layout

\begin_layout Section
Implementing typeclasses
\end_layout

\begin_layout Standard
A typeclass constraint 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[T: Fractional]
\end_layout

\end_inset

 will generate a compile-time error when a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 is applied to an incorrectly chosen type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 If the Scala library did not already implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Fractional
\end_layout

\end_inset

 typeclass, how could we reproduce that functionality?
\end_layout

\begin_layout Subsection
Creating a partial function at type level
\end_layout

\begin_layout Standard
The code needs to specify that the type parameter must belong to a certain
 subset of allowed types.
 To simplify the task, assume that the allowed types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BigDecimal
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 One example of a type constraint is shown by unfunctors
\begin_inset Index idx
status open

\begin_layout Plain Layout
unfunctor
\end_layout

\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-non-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which are type constructors whose type parameters are restricted to specific
 types.
 As an example of an unfunctor, consider the code shown
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "54col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Frac[A]              // Unfunctor.
\end_layout

\begin_layout Plain Layout

final case class FracBD() extends Frac[BigDecimal]
\end_layout

\begin_layout Plain Layout

final case class FracD()  extends Frac[Double]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
at left, where values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Frac[A]
\end_layout

\end_inset

 can be created only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

A = BigDecimal
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

A = Double
\end_layout

\end_inset

.
 The keywords 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

sealed
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

final
\end_layout

\end_inset

 guarantee that no further code could extend this definition and allow us
 to create a value of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Frac[String]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Frac[Boolean]
\end_layout

\end_inset

.
 The Scala compiler will not detect any errors in the following code:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "32col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type T = Frac[String]
\end_layout

\begin_layout Plain Layout

type U = Frac[Boolean]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
But we will never be able to create and use any values of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

U
\end_layout

\end_inset

.
 In other words, the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Frac[String]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Frac[Boolean]
\end_layout

\end_inset

 are 
\emph on
void
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 types.
 Trying to create and use values of these types will result in type errors,
 as the following code shows:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "46col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def f[A]: Frac[A] = FracD()    // Type error.
\end_layout

\begin_layout Plain Layout

val x: U = FracD()             // Type error.
\end_layout

\begin_layout Plain Layout

val y: U = FracD().asInstanceOf[U]
\end_layout

\begin_layout Plain Layout

y match { case FracD() => }    // Type error.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -105baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In line
\begin_inset space ~
\end_inset

3, we disabled the type checker and forced the Scala compiler to ignore
 the type error in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

y
\end_layout

\end_inset

.
 However, line
\begin_inset space ~
\end_inset

4 shows that we are unable to use that value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

y
\end_layout

\end_inset

 in further computations.
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac[A]
\end_layout

\end_inset

 is non-void (i.e., has values) only for 
\begin_inset Formula $A$
\end_inset

 belonging to the set {
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BigDecimal
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

} 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
\begin_inset Formula $\{\text{BigDecimal},\text{Double}\}$
\end_inset


\end_layout

\end_inset

 of types.
 This set is called the 
\series bold
type domain
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type domain
\end_layout

\end_inset

 of the type function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

.
 We now need to define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 with a type parameter 
\begin_inset Formula $T$
\end_inset

 constrained to that type domain.
 
\end_layout

\begin_layout Standard
The type constraint 
\begin_inset Formula $T\negthickspace\in\,$
\end_inset

{
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BigDecimal
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

} is equivalent to the requirement that a value of type 
\begin_inset Formula $\text{Frac}^{T}$
\end_inset

 should exist.
 So, we will implement the type constraint if we include an 
\emph on
additional argument
\emph default
 of type 
\begin_inset Formula $\text{Frac}^{T}$
\end_inset

 into the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T](s: Seq[T], frac: Frac[T]): T
\end_layout

\end_inset

The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frac:Frac[T]
\end_layout

\end_inset

 is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!instance value
\end_layout

\end_inset


\series bold
typeclass instance
\series default
 value.
 Because that value needs to be passed to every call of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

, we will be unable to use types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 for which 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac[T]
\end_layout

\end_inset

 is void (i.e., has no values).
 
\end_layout

\begin_layout Standard
In this way, we implemented the typeclass constraint for the PTVF 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

.
 The main steps were:
\end_layout

\begin_layout Enumerate
Define a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac[_]
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Make sure values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac[A]
\end_layout

\end_inset

 exist only when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = BigDecimal
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Pass a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac[T]
\end_layout

\end_inset

 to the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 as an additional argument.
\end_layout

\begin_layout Standard
It is not necessary to define the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 via an unfunctor.
 The type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 is only needed to define the type domain {
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BigDecimal
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

}.
 We can use a simple case class instead:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Frac[T]()
\end_layout

\begin_layout Plain Layout

val fracBD: Frac[BigDecimal] = Frac()
\end_layout

\begin_layout Plain Layout

val fracD: Frac[Double] = Frac()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This code creates a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Frac
\end_layout

\end_inset

 and makes values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Frac[T]
\end_layout

\end_inset

 available for chosen type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

.
 In this way, we implemented the required type domain.
\end_layout

\begin_layout Standard
To write the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

, we need to be able to add numeric values and to divide by an integer value.
 More precisely, the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 needs access to two PTVFs that we may call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

intdiv
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add[T](x: T, y: T): T
\end_layout

\begin_layout Plain Layout

def intdiv[T](x: T, n: Int): T
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 now has an additional argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frac
\end_layout

\end_inset

, we may use that argument to hold the required functions.
 So, we redefine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 as a named tuple (case class) containing the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

intdiv
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Frac[T](add: (T, T) => T, intdiv: (T, Int) => T)
\end_layout

\end_inset

Typeclass instances for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BigDecimal
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 are then created by the following code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val fracBD = Frac[BigDecimal]( (x, y) => x + y,  (x, n) => x / n )
\end_layout

\begin_layout Plain Layout

val fracD = Frac[Double]( (x, y) => x + y,  (x, n) => x / n )
\end_layout

\end_inset

With these definitions, implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 becomes straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T](s: Seq[T], frac: Frac[T]): T = {      // Assuming `s` is a non-empty
 sequence.
\end_layout

\begin_layout Plain Layout

  val sum = s.reduce(frac.add)     // Here, `reduce` would fail on an empty
 sequence `s`.
\end_layout

\begin_layout Plain Layout

  frac.intdiv(sum, s.length)       // Compute `sum/length`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To use this function, we need to pass a typeclass instance corresponding
 to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> avg(Seq(1.0, 2.0, 3.0), fracD) // It will be a type error to use fracBD
 instead of fracD here.
\end_layout

\begin_layout Plain Layout

res0: Double = 2.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> avg(Seq(BigDecimal(1.0), BigDecimal(2.0)), fracBD)
\end_layout

\begin_layout Plain Layout

res1: BigDecimal = 1.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a fully working implementation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 function with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 typeclass constraint.
 We have achieved compile-time safety since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 cannot be applied to values of unsupported types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 We have also achieved easy extensibility: To implement another function
 as a PTVF with the same type domain, we need to add an extra argument of
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac[T]
\end_layout

\end_inset

 to the function.
 To add another supported type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 to the type domain, we just write one more line of code similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val fracD = ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An equivalent implementation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 typeclass via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 with methods requires this code:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "60col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -65baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Frac[T] {                 // Trait is not `sealed`.
\end_layout

\begin_layout Plain Layout

  def add(x: T, y: T): T
\end_layout

\begin_layout Plain Layout

  def intdiv(x: T, n: Int): T
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

val fracBD = new Frac[BigDecimal] {
\end_layout

\begin_layout Plain Layout

  def add(x: BigDecimal, y: BigDecimal): BigDecimal = x + y
\end_layout

\begin_layout Plain Layout

  def intdiv(x: BigDecimal, n: Int): BigDecimal = x / n
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

val fracD = new Frac[Double] {
\end_layout

\begin_layout Plain Layout

  def add(x: Double, y: Double): Double = x + y
\end_layout

\begin_layout Plain Layout

  def intdiv(x: Double, n: Int): Double = x / n
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 will work unchanged with this implementation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 typeclass.
\end_layout

\begin_layout Standard
The implementation via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 is significantly longer than the code using a case class as shown previously.
 One advantage of the longer code is the ability to combine different typeclasse
s by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 mixing.
 We will look at that in more detail below.
 For now, we note that both implementations will require the programmer
 to add a significant amount of new code:
\end_layout

\begin_layout Itemize
Calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func[T](args)
\end_layout

\end_inset

 need to be changed to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func[T](args, ti)
\end_layout

\end_inset

 with typeclass instances 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ti
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
For each supported type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

, a corresponding typeclass instance value needs to be created.
\end_layout

\begin_layout Itemize
All those values need to be passed to all places in the code where PTVFs
 are used.
\end_layout

\begin_layout Standard
The extra work can be reduced (and sometimes avoided) by using Scala's 
\begin_inset Quotes eld
\end_inset

implicit value
\begin_inset Quotes erd
\end_inset

 feature.
 
\end_layout

\begin_layout Subsection
Scala's 
\family typewriter
implicit
\family default
 values
\end_layout

\begin_layout Standard
An 
\series bold
implicit 
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
implicit value
\end_layout

\end_inset

 declaration is a feature of Scala that makes values automatically available
 to any function that declares an 
\begin_inset Quotes eld
\end_inset

implicit argument
\begin_inset Quotes erd
\end_inset

 of the same type.
 Scala's syntax for implicit values is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val x: Int = 123
\end_layout

\end_inset

This declaration introduces an implicit value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 into the current scope.
 That value will be automatically passed as an argument to any function
 declaring an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(a: String)(implicit n: Int) = s
\begin_inset Quotes erd
\end_inset

$a with $n
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: String = xyz with 123
\end_layout

\end_inset

We need to declare the arguments as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

 in the function's type signature, and the implicit arguments must be in
 a 
\emph on
separate
\emph default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
argument list
\end_layout

\end_inset

argument list.
\end_layout

\begin_layout Standard
The simplest useful function with an implicit argument is the identity function.
 In the Scala library, this function is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicitly
\end_layout

\end_inset

.
 Compare its code with the code of the ordinary identity function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def implicitly[T](implicit t: T): T = t
\end_layout

\begin_layout Plain Layout

def identity[T](t: T): T = t
\end_layout

\end_inset

What does 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicitly[T]
\end_layout

\end_inset

 do? Since its only argument is declared as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

, we can simply write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicitly[T]
\end_layout

\end_inset

 with no arguments to apply that function.
 (The type parameter usually needs to be specified.) If no implicit value
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is available, a compile-time error will occur.
 If an implicit value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is available in the current scope, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicitly[T]
\end_layout

\end_inset

 will return that value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val s: String = 
\begin_inset Quotes eld
\end_inset

qqq
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> implicitly[String]
\end_layout

\begin_layout Plain Layout

res1: String = qqq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is an error to declare more than one implicit value of the same type
 in the same scope, because implicit arguments are specified by type alone.
 The Scala compiler will not be able to set implicit arguments of functions
 automatically when the function's outer scope contains more than one implicit
 value of a required type, as in this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val x: Int = 1
\end_layout

\begin_layout Plain Layout

implicit val y: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> implicitly[Int]
\end_layout

\begin_layout Plain Layout

<console>:14: error: ambiguous implicit values:
\end_layout

\begin_layout Plain Layout

 both value x of type => Int
\end_layout

\begin_layout Plain Layout

 and value y of type => Int
\end_layout

\begin_layout Plain Layout

 match expected type Int
\end_layout

\begin_layout Plain Layout

       implicitly[Int]
\end_layout

\begin_layout Plain Layout

                 ^
\end_layout

\end_inset

But it is not an error to declare several implicit arguments of the 
\emph on
same
\emph default
 type, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(a: String)(implicit x: MyType, y: MyType)
\end_layout

\begin_layout Plain Layout

implicit val z: MyType = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

) // Same as f(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

)(z, z) since z is the unique implicit value of type MyType.
\end_layout

\end_inset

In the example above, the arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 will be set to the same value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

.
 A compile-time error will occur if no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MyType
\end_layout

\end_inset

 is visible in the current scope:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> implicitly[MyType]
\end_layout

\begin_layout Plain Layout

<console>:12: error: could not find implicit value for parameter e: MyType
\end_layout

\begin_layout Plain Layout

       implicitly[MyType]
\end_layout

\begin_layout Plain Layout

                 ^
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementing typeclasses by making instances 
\family typewriter
implicit
\family default
 
\end_layout

\begin_layout Standard
The idea is to declare typeclass instance values as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

.
 Typeclass instance arguments of functions are also declared as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

.
 As a result, typeclass instances will be passed to all PTVFs automatically
 (as long as the appropriate implicits are visible in the scope of the PTVFs).
 This makes typeclasses easier to use because instance values need to be
 written out much less often.
\end_layout

\begin_layout Standard
The example with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 typeclass is implemented using implicit values like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Frac[T](add: (T, T) => T, intdiv: (T, Int) => T)
\end_layout

\begin_layout Plain Layout

implicit val fracBD = Frac[BigDecimal]( (x, y) => x + y,  (x, n) => x /
 n )
\end_layout

\begin_layout Plain Layout

implicit val fracD = Frac[Double]( (x, y) => x + y,  (x, n) => x / n )
\end_layout

\end_inset

To define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

, we declare an implicit argument as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 typeclass instance for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T](s: Seq[T])(implicit frac: Frac[T]): T = { // Assuming `s` is
 a non-empty sequence.
\end_layout

\begin_layout Plain Layout

  val sum = s.reduce(frac.add)     // Here, `reduce` would fail on an empty
 sequence `s`.
\end_layout

\begin_layout Plain Layout

  frac.intdiv(sum, s.length)       // Compute `sum/length`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It is now easier to use the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg
\end_layout

\end_inset

 because the typeclass instances are inserted automatically:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> avg(Seq(1.0, 2.0, 3.0))
\end_layout

\begin_layout Plain Layout

res0: Double = 2.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> avg(Seq(BigDecimal(1.0), BigDecimal(2.0)))
\end_layout

\begin_layout Plain Layout

res1: BigDecimal = 1.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala supports the 
\begin_inset Quotes eld
\end_inset

type constraint
\begin_inset Quotes erd
\end_inset

 syntax for implicit typeclass instance arguments: the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B](args...)(implicit t1: Typeclass1[A], t2: Typeclass2[B])
\end_layout

\end_inset

is equivalent to the shorter code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A: Typeclass1, B: Typeclass2](args...)
\end_layout

\end_inset

The shorter code omits the names (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

) of the typeclass instances.
 These values can be extracted via the standard function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicitly
\end_layout

\end_inset

 because all implicit arguments are automatically made available as implicit
 values in the scope of a function's body.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

avg[T]
\end_layout

\end_inset

 can then be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def avg[T: Frac](s: Seq[T]): T = {
\end_layout

\begin_layout Plain Layout

  val frac = implicitly[Frac[T]]
\end_layout

\begin_layout Plain Layout

  val sum = s.reduce(frac.add)
\end_layout

\begin_layout Plain Layout

  frac.intdiv(sum, s.length)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When an implicit argument is required, the Scala compiler will search for
 implicit values of the required type in different places of the code.
 If implicit values are declared in another module, they can be made available
 by using an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 declaration.
 In many cases, explicit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 declarations can be avoided.
 One way to avoid them is to declare the required implicit values within
 the 
\series bold
companion object
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
companion object
\end_layout

\end_inset

 of the typeclass (i.e., the Scala 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

object
\end_layout

\end_inset

 with the same name as the type constructor):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Frac[T](add: (T, T) => T, intdiv: (T, Int) => T)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object Frac {   // The companion object of `Frac[T]` creates some typeclass
 instances as `implicit`.
\end_layout

\begin_layout Plain Layout

  implicit val fracBD = Frac[BigDecimal]( (x, y) => x + y,  (x, n) => x
 / n )
\end_layout

\begin_layout Plain Layout

  implicit val fracD = Frac[Double]( (x, y) => x + y,  (x, n) => x / n )
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Whenever a function needs an implicit value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac[T]
\end_layout

\end_inset

 for a specific type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

, the Scala compiler will automatically look within the companion object
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

 (as well as within the companion object of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

) for any instances declared there.
 So, the programmer's code will not need to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 those typeclass instances explicitly even if the companion object is in
 a different module:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> avg(Seq(1.0, 2.0, 3.0))
\end_layout

\begin_layout Plain Layout

res0: Double = 2.0
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Extension methods
\end_layout

\begin_layout Standard
In Scala, function applications can use three kinds of syntax: 
\end_layout

\begin_layout Enumerate
The 
\begin_inset Quotes eld
\end_inset

function
\begin_inset Quotes erd
\end_inset

 syntax: arguments are to the right of the function as in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

plus(x, y)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

plus(x)(y)
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
The 
\begin_inset Quotes eld
\end_inset

method
\begin_inset Quotes erd
\end_inset

 syntax: the first argument is to the left of the function, and all other
 arguments (if any) are placed to the right of the function, as in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.plus(y)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.foldLeft(0)(updater)
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
The 
\begin_inset Quotes eld
\end_inset

infix method
\begin_inset Quotes erd
\end_inset

 syntax (only applies to functions with two 
\emph on
explicit
\emph default
 arguments): no dot character is used.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x plus y
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs map {x => x + 1}
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set(1, 2, 3) contains 1
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The last two syntax features are often used when writing chains of function
 applications, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.map(f).filter(g)
\end_layout

\end_inset

, because that code is easier to read than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter(map(xs, f), g)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The method syntax is available only for methods defined in a class.
 A special feature of Scala allows us to add new functions with method syntax
 to previously defined types.
 New functions added in this way are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
extension methods
\end_layout

\end_inset


\series bold
extension methods
\series default
.
 
\end_layout

\begin_layout Standard
Suppose we would like to convert a previously defined function, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def func(x: X, y: Y): Z = { ...
 }
\end_layout

\end_inset

into an extension method on the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 with the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.func(y)
\end_layout

\end_inset

.
 To do that, we define a new helper 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 that has a method named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func
\end_layout

\end_inset

.
 The class's constructor must be declared as an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

 function having a 
\emph on
single
\emph default
 argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class FuncSyntax(x: X) {  def func(y: Y): Z = ...
 }
\end_layout

\end_inset

After this declaration, we can write the method syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.func(y)
\end_layout

\end_inset

 as well as the infix method syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x func y
\end_layout

\end_inset

.
 The new syntax will work because the compiler automatically rewrites 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.func(y)
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new FuncSyntax(x).func(y)
\end_layout

\end_inset

, creating a new temporary value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FuncSyntax(x)
\end_layout

\end_inset

.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func
\end_layout

\end_inset

 will be available since it is defined in the class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FuncSyntax
\end_layout

\end_inset

.
 (Scala 3 will have a shorter syntax.)
\end_layout

\begin_layout Standard
As an example, let us define an extension method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

average
\end_layout

\end_inset

 for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[T]
\end_layout

\end_inset

.
 Both the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 and its typeclass constraint can be written in the constructor of the helper
 class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class AvgSyntax[T: Frac](xs: Seq[T]) {
\end_layout

\begin_layout Plain Layout

  def average: T = avg(xs) // Use a different name, `average`, to avoid
 name clash with `avg`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now use the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

average
\end_layout

\end_inset

 on numeric sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1.0, 2.0, 3.0).average
\end_layout

\begin_layout Plain Layout

res0: Double = 2.0
\end_layout

\end_inset

The Scala compiler automatically rewrites the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(1.0, 2.0, 3.0).average
\end_layout

\end_inset

 as the expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

new AvgSyntax(Seq(1.0, 2.0, 3.0))(implicitly[Frac[Double]]).average
\end_layout

\end_inset

In this way, the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

average
\end_layout

\end_inset

 is actually invoked on a temporarily created value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AvgSyntax
\end_layout

\end_inset

.
 These values will be created automatically because the class constructor
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AvgSyntax
\end_layout

\end_inset

 is declared as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

.
 Since the constructor of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AvgSyntax
\end_layout

\end_inset

 includes the typeclass constraint 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[T: Frac]
\end_layout

\end_inset

, we will not be able to create values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AvgSyntax[T]
\end_layout

\end_inset

 for types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 not in the type domain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Frac
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This example illustrates the convenience of implementing PTVFs as extension
 methods.
 An extension method is defined only once but automatically becomes available
 for all types in the domain of the typeclass.
 Because of the typeclass constraint, the new method will be available 
\emph on
only
\emph default
 on values of supported types.
\end_layout

\begin_layout Standard
This convenience comes at a cost: helper classes such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AvgSyntax
\end_layout

\end_inset

 need to be explicitly imported into every scope where extension methods
 are used, with a declaration like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import some.library.having.a.longwinded.packagename.AvgSyntax
\end_layout

\end_inset

If the helper class is defined in some library, the programmer will have
 to look at the library's source code to determine the full name of the
 helper class that needs to be imported.
\end_layout

\begin_layout Subsection
Solved examples: Implementing typeclasses in practice
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now look at some practical examples of programming tasks implemented
 via typeclasses.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-metadata-extractors"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-metadata-extractors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (metadata extractors)
\end_layout

\begin_layout Standard
An application needs to work with data structures implemented in various
 external libraries.
 All those data structures are case classes containing certain metadata:
 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 (a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

) and 
\begin_inset Quotes eld
\end_inset

count
\begin_inset Quotes erd
\end_inset

 (a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

 integer).
 However, the specific data structures define the metadata differently,
 each in its own way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Data1(p: String, q: String, r: Long) // 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 = p, 
\begin_inset Quotes eld
\end_inset

count
\begin_inset Quotes erd
\end_inset

 = r
\end_layout

\begin_layout Plain Layout

final case class Data2(s: String, c: Long, x: Int)    // 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 = s, 
\begin_inset Quotes eld
\end_inset

count
\begin_inset Quotes erd
\end_inset

 = c
\end_layout

\begin_layout Plain Layout

final case class Data3(x: Int, y: Long, z: String)    // 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 = z, 
\begin_inset Quotes eld
\end_inset

count
\begin_inset Quotes erd
\end_inset

 = x * y
\end_layout

\end_inset

The task is to implement two functions, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getName[T]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getCount[T]
\end_layout

\end_inset

, for extracting the metadata out of the data structures of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is one of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data3
\end_layout

\end_inset

.
 Type signatures and sample tests:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getName[T: HasMetadata](t: T): String = ???
\end_layout

\begin_layout Plain Layout

def getCount[T: HasMetadata](t: T): Long = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> getName(Data2(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

, 123, 0))
\end_layout

\begin_layout Plain Layout

res0: String = abc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> getCount(Data3(10, 20, 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

res1: Long = 200
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will implement a typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasMetadata
\end_layout

\end_inset

 and declare instances only for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data3
\end_layout

\end_inset

.
 The code for extracting the metadata will be contained within the typeclass
 instances.
 Since the metadata extractors have types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T => String
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T => Long
\end_layout

\end_inset

, a simple solution is to define the typeclass as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class
\end_layout

\end_inset

 containing these two functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class HasMetadata[T](getName: T => String, getCount: T => Long)
\end_layout

\end_inset

The required typeclass instances are declared as implicit values within
 the companion object:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object HasMetadata {    // Extract metadata from each type as appropriate.
\end_layout

\begin_layout Plain Layout

  implicit val data1 = HasMetadata[Data1](_.p, _.r)
\end_layout

\begin_layout Plain Layout

  implicit val data2 = HasMetadata[Data2](_.s, _.c)
\end_layout

\begin_layout Plain Layout

  implicit val data3 = HasMetadata[Data3](_.z, data3 => data3.x * data3.y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getName
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getCount
\end_layout

\end_inset

 as PTVFs with typeclass constraints.
 First, let us write the code using an implicit argument to pass the typeclass
 instance:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getName[T](t: T)(implicit ti: HasMetadata[T]): String = ti.getName(t)
\end_layout

\begin_layout Plain Layout

def getCount[T](t: T)(implicit ti: HasMetadata[T]): Long = ti.getCount(t)
\end_layout

\end_inset

Or we could use the typeclass constraint syntax, replacing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ti
\end_layout

\end_inset

 by calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicitly[...]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getName[T: HasMetadata](t: T): String = implicitly[HasMetadata[T]].getName(t)
\end_layout

\begin_layout Plain Layout

def getCount[T: HasMetadata](t: T): Long = implicitly[HasMetadata[T]].getCount(t)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code defines PTVFs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getName
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getCount
\end_layout

\end_inset

 with the type domain that contains the three types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data3
\end_layout

\end_inset

.
 In order to add a new type, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data4
\end_layout

\end_inset

, to the type domain, we will need to declare a new typeclass instance as
 an implicit value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasMetadata[Data4]
\end_layout

\end_inset

.
 New implicit values can be defined anywhere in the code, not necessarily
 within the companion object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasMetadata
\end_layout

\end_inset

.
 To avoid extra 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 statements, the implicit value may be defined within the companion object
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data4
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Data4(x: Int, message: String)
\end_layout

\begin_layout Plain Layout

object Data4 {   // Add Data4 to the type domain of HasMetadata:
\end_layout

\begin_layout Plain Layout

  implicit val data4 = HasMetadata[Data4](_.message, _.x.toLong)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> getName(Data4(1, 
\begin_inset Quotes erd
\end_inset

abc
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

res2: String = abc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For convenience, let us declare the metadata extractors as extension methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class ExtractorsSyntax[T: HasMetadata](t: T) {
\end_layout

\begin_layout Plain Layout

  def name: String = getName(t)
\end_layout

\begin_layout Plain Layout

  def count: Long = getCount(t)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

With this definition, we can write:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "34col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Data2("abc", 123, 0).name
\end_layout

\begin_layout Plain Layout

res3: String = "abc"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Data3(10, 20, 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

).count
\end_layout

\begin_layout Plain Layout

res4: Long = 200
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The code looks as if the new methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 became available for each of the supported data types.
 It is important that the new methods were added 
\emph on
without
\emph default
 any changes to the implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data2
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data3
\end_layout

\end_inset

.
 Those implementations may reside in external libraries whose code we do
 not need to modify.
 The typeclass pattern enables us to to add externally defined types to
 a type domain whenever necessary, and to implement new PTVFs for them.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-observability"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-observability"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (counters)
\end_layout

\begin_layout Standard
A certain application needs to count the number of files processed and to
 send this number to external observability services.
 The functionality of a counter is provided by an external library as a
 special class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counter
\end_layout

\end_inset

 with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inc
\end_layout

\end_inset

 method that increments the counter.
 To test the code, we want to be able to pass a test-only counter provided
 by another library as a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TestCounter
\end_layout

\end_inset

 with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

incr
\end_layout

\end_inset

 method.
 The task is to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bump[C]()
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is a type constrained to be one of the supported types of counters.
 The type signature and sample code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bump[C]()(...) = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val counter = Counter(...)
\end_layout

\begin_layout Plain Layout

val testCounter = TestCounter(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bump(counter)       // Should call counter.inc()
\end_layout

\begin_layout Plain Layout

bump(testCounter)   // Should call testCounter.incr()
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will implement a typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bumpable
\end_layout

\end_inset

 whose type domain contains the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TestCounter
\end_layout

\end_inset

.
 Typeclass instances should allow us to increment a counter of any supported
 type.
 So, a typeclass instance value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bumpable[C]
\end_layout

\end_inset

 needs to contain a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => Unit
\end_layout

\end_inset

 that will increment a counter of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 appropriately:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Bumpable[C](bump: C => Unit)
\end_layout

\end_inset

We can now create the typeclass instances and implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bump[C]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object Bumpable {
\end_layout

\begin_layout Plain Layout

  implicit val b1 = Bumpable[Counter](c => c.inc())
\end_layout

\begin_layout Plain Layout

  implicit val b2 = Bumpable[TestCounter](c => c.incr())
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  def bump[C](counter: C)(implicit ti: Bumpable[C]): Unit = ti.bump(counter)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

An equivalent implementation with the type constraint syntax looks like
 this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bump[C: Bumpable](counter: C): Unit = implicitly[Bumpable[C]].bump(counter)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-Pointed-type"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Pointed-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (default values)
\end_layout

\begin_layout Standard
Certain types have naturally chosen 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 values (e.g., integer zero, empty string, empty array, etc.).
 The task is to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

default[T]
\end_layout

\end_inset

 restricted to types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 for which default values are available.
 The required type signature and sample tests:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def default[T: HasDefault]: T = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> default[Int]
\end_layout

\begin_layout Plain Layout

res0: Int = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> default[Double]
\end_layout

\begin_layout Plain Layout

res1: Double = 0.0
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to define a PTVF 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

default[T]
\end_layout

\end_inset

 with a type domain that contains (at least) the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 For every supported type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

, we need to store the known default value of that type.
 So, the typeclass instance can be defined as a simple wrapper for values
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class HasDefault[T](value: T)
\end_layout

\end_inset

Typeclass instances are declared straightforwardly:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object HasDefault {
\end_layout

\begin_layout Plain Layout

  implicit val defaultInt = HasDefault[Int](0)
\end_layout

\begin_layout Plain Layout

  implicit val defaultDouble = HasDefault[Double](0.0)
\end_layout

\begin_layout Plain Layout

  implicit val defaultString = HasDefault[String](
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  implicit val defaultUnit = HasDefault[Unit](())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

default[T]
\end_layout

\end_inset

 is written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def default[T](implicit ti: HasDefault[T]) = ti.value
\end_layout

\end_inset

When using the typeclass constraint syntax, the code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def default[T: HasDefault]: T = implicitly[HasDefault[T]].value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How to define an empty list as a default value for lists of 
\emph on
any
\emph default
 chosen type? We cannot write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val defaultList = HasDefault[List[A]](List())     // Error: `A`
 is undefined.
\end_layout

\end_inset

The type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 needs to be defined in the left-hand side.
 Since Scala 2 does not support 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 declarations with type parameters (Scala 3 does), we need to write the
 typeclass instance as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def defaultList[A] = HasDefault[List[A]](List())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another example of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 instance with a type parameter is for functions of type 
\begin_inset Formula $A\rightarrow A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def defaultFunc[A]: HasDefault[A => A] = HasDefault[A => A](identity)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Types that have default values are also called 
\series bold
pointed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pointed type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!pointed
\end_layout

\end_inset

 types.
 This book defines the typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 for pointed 
\emph on
functors
\emph default
 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-functors-motivation-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

) because they are more widely used than pointed types.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-Semigroups"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Semigroups"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (semigroups)
\end_layout

\begin_layout Standard
In many cases, data items can be combined or merged into a larger data item
 of the same type.
 For instance, two numbers can be added, two sets combined into one set,
 two strings concatenated into one string, and two lists into one list.
 The 
\begin_inset Quotes eld
\end_inset

merge
\begin_inset Quotes erd
\end_inset

 operation can be defined as a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine[T]
\end_layout

\end_inset

 taking two arguments of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 and returning a new value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 We will denote that operation by 
\begin_inset Formula $\oplus$
\end_inset

, e.g., we write 
\begin_inset Formula $x\oplus y$
\end_inset

.
 In all the examples just mentioned (integers, strings, lists, etc.), that
 operation is associative:
\begin_inset Formula 
\begin{equation}
\forall(x,y,z).\,\left(x\oplus y\right)\oplus z=x\oplus\left(y\oplus z\right)\quad.\label{eq:associativity-law-semigroup}
\end{equation}

\end_inset

This associativity law
\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of semigroups
\end_layout

\end_inset

 makes parentheses in the expression 
\begin_inset Formula $x\oplus y\oplus z$
\end_inset

 unnecessary.
\end_layout

\begin_layout Standard
A type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 with an associative binary operation is called a 
\series bold
semigroup
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
semigroup
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Semigroup
\end_layout

\end_inset

.
 The task in this example is to define the semigroup operation for the types
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For every supported type 
\begin_inset Formula $T$
\end_inset

, the required data is a function of type 
\begin_inset Formula $T\times T\rightarrow T$
\end_inset

.
 So, we define the typeclass as a wrapper over that type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Semigroup[T](combine: (T, T) => T)
\end_layout

\end_inset

The typeclass instances for the supported types are defined using a short
 syntax as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object Semigroup {
\end_layout

\begin_layout Plain Layout

  implicit val semigroupInt = Semigroup[Int](_ + _)
\end_layout

\begin_layout Plain Layout

  implicit val semigroupString = Semigroup[String](_ + _)
\end_layout

\begin_layout Plain Layout

  implicit def semigroupList[A] = Semigroup[List[A]](_ ++ _)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine[T]
\end_layout

\end_inset

 is implemented as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def combine[T](x: T, y: T)(implicit ti: Semigroup[T]): T = ti.combine(x,
 y)
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine
\end_layout

\end_inset

 is a binary operation, it is convenient to define infix method syntax for
 it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class SemigroupSyntax[T: Semigroup](x: T) { def |+|(y: T): T =
 combine(x, y) }
\end_layout

\end_inset

After this definition, we may use the infix operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

|+|
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3) |+| List(4)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4)
\end_layout

\end_inset

Due to the associativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-semigroup"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x |+| y |+| z
\end_layout

\end_inset

 does not depend on the choice of parentheses: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x |+| y) |+| z == x |+| (y |+| z)
\end_layout

\end_inset

.
 This makes programs written using the semigroup operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

|+|
\end_layout

\end_inset

 easier to understand and reason about.
\end_layout

\begin_layout Standard
Semigroup types represent data that can be pairwise 
\begin_inset Quotes eld
\end_inset

merged
\begin_inset Quotes erd
\end_inset

 in a certain well-defined way.
 Using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 typeclass, we can write code that is parameterized by the type of 
\begin_inset Quotes eld
\end_inset

mergeable
\begin_inset Quotes erd
\end_inset

 data.
 As an example, given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[T]
\end_layout

\end_inset

 where the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is a semigroup, we can 
\begin_inset Quotes eld
\end_inset

merge
\begin_inset Quotes erd
\end_inset

 all elements to compute a result of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 This computation can be implemented as a function parameterized by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def merge[T: Semigroup](ts: Seq[T]): T = ts.reduce(combine[T])
\end_layout

\end_inset

This function assumes a non-empty input sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ts
\end_layout

\end_inset

 whose elements are of a semigroup type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 We can also implement the same function as an extension method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class SumSyntax[T: Semigroup](ts: Seq[T]) { def merge: T = ts.reduce(com
bine[T]) }
\end_layout

\end_inset

With the previous definitions, we can now evaluate expressions such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).merge
\end_layout

\begin_layout Plain Layout

res1: Int = 6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(List(), List(true), List(), List(true, false)).merge
\end_layout

\begin_layout Plain Layout

res2: List[Boolean] = List(true, true, false)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important that the associativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-semigroup"
plural "false"
caps "false"
noprefix "false"

\end_inset

) should hold for each of the supported types.
 If that is not so, programs written with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 will not work as expected.
 (For instance, programmers would certainly expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.merge |+| ys.merge == (xs ++ ys).merge
\end_layout

\end_inset

 for any sequences 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ys
\end_layout

\end_inset

.) However, the code of the typeclass 
\emph on
does not
\emph default
 check the associativity law.
 It is the responsibility of the programmer to verify that the implementation
 of each typeclass instance is lawful.
 
\end_layout

\begin_layout Standard
The associativity law of integer addition is a standard arithmetic identity:
\begin_inset Formula 
\[
\left(x+y\right)+z=x+\left(y+z\right)\quad.
\]

\end_inset

Verifying associativity for lists and strings (which are lists of characters)
 is intuitively simple because concatenation preserves the order of elements.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 are lists, the concatenation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x ++ y) ++ z
\end_layout

\end_inset

 is a list containing all elements from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 in their original order.
 It is evident that the concatenation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x ++ (y ++ z)
\end_layout

\end_inset

 is a list with the same elements in the same order.
 However, a rigorous proof of the associativity law for lists, starting
 from the code of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 function, requires significant work (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Proofs-for-associativity-law-lists-and-arrays-concat"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-semigroup-alternative-implementations"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-semigroup-alternative-implementations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (alternative semigroup implementations)
\end_layout

\begin_layout Standard
The definitions of the semigroup operation 
\begin_inset Formula $\oplus$
\end_inset

 as concatenation for strings and as addition for integers may appear to
 be 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

.
 However, alternative implementations are useful in certain applications.
 As long as the associativity law holds, 
\emph on
any
\emph default
 function of type 
\begin_inset Formula $T\times T\rightarrow T$
\end_inset

 may be used as the semigroup operation.
 The task of this example is to show that the following implementations
 of the semigroup operation are lawful and to implement the corresponding
 typeclass instances in Scala.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For any type 
\begin_inset Formula $T$
\end_inset

, define 
\begin_inset Formula $x\oplus y\triangleq x$
\end_inset

 (ignoring the value of 
\begin_inset Formula $y$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 For pair types 
\begin_inset Formula $T\triangleq A\times B$
\end_inset

, define the operation 
\begin_inset Formula $\oplus$
\end_inset

 by 
\begin_inset Formula $\left(a_{1}\times b_{1}\right)\oplus\left(a_{2}\times b_{2}\right)\triangleq a_{1}\times b_{2}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 For 
\begin_inset Formula $T\triangleq\text{String}$
\end_inset

, define 
\begin_inset Formula $x\oplus y$
\end_inset

 as the longer of the strings 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 For 
\begin_inset Formula $T\triangleq S\rightarrow S$
\end_inset

 (the type 
\begin_inset Formula $S$
\end_inset

 is fixed), define 
\begin_inset Formula $x\oplus y\triangleq x\bef y$
\end_inset

 (the forward function composition) or 
\begin_inset Formula $x\oplus y\triangleq x\circ y$
\end_inset

 (the backward function composition).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 To verify the associativity law, use the definition 
\begin_inset Formula $x\oplus y\triangleq x$
\end_inset

 to compute:
\begin_inset Formula 
\[
\left(x\oplus y\right)\oplus z=x\oplus z=x\quad,\quad x\oplus\left(y\oplus z\right)=x\quad.
\]

\end_inset

So the associativity law holds: 
\begin_inset Formula $\left(x\oplus y\right)\oplus z=x\oplus\left(y\oplus z\right)$
\end_inset

 for any 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, 
\begin_inset Formula $z$
\end_inset

.
\end_layout

\begin_layout Standard
It is clear that 
\begin_inset Formula $x\oplus y\oplus z\oplus...=x$
\end_inset

 for any number of values; the binary operation keeps the first value and
 ignores all further values.
 We can implement this semigroup instance at once for all types 
\begin_inset Formula $T$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def semigroup1[T] = Semigroup[T]{ (x, y) => x }
\end_layout

\end_inset

Similarly, the definition 
\begin_inset Formula $x\oplus y\triangleq y$
\end_inset

 gives an associative binary operation for a (different) semigroup.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 To verify the associativity law:
\begin_inset Formula 
\begin{align*}
\left(\left(a_{1}\times b_{1}\right)\oplus\left(a_{2}\times b_{2}\right)\right)\oplus\left(a_{3}\times b_{3}\right) & =\left(a_{1}\times b_{2}\right)\oplus\left(a_{3}\times b_{3}\right)=a_{1}\times b_{3}\quad,\\
\left(a_{1}\times b_{1}\right)\oplus\left(\left(a_{2}\times b_{2}\right)\oplus\left(a_{3}\times b_{3}\right)\right) & =\left(a_{1}\times b_{1}\right)\oplus\left(a_{2}\times b_{3}\right)=a_{1}\times b_{3}\quad.
\end{align*}

\end_inset

The implementation is possible for any types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def semigroup2[A, B] = Semigroup[(A, B)]{ case ((a1, b1), (a2,
 b2)) => (a1, b2) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One use case for this semigroup is to maintain a pair of timestamps for
 the first and the last events in a temporally ordered series.
 Merging two such pairs for consecutive events means to keep the first value
 from the first pair and the second value from the second pair.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 It is clear that 
\begin_inset Formula $x\oplus y\oplus z$
\end_inset

 is the longest of the strings 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, and 
\begin_inset Formula $z$
\end_inset

.
 Since the definition of 
\begin_inset Quotes eld
\end_inset

longest
\begin_inset Quotes erd
\end_inset

 does not depend on the order in which we select pairs for comparison, the
 operation is associative.
 (For the same reason, any 
\begin_inset Quotes eld
\end_inset

maximum
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

minimum
\begin_inset Quotes erd
\end_inset

 operation is associative.) Implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val semigroup3 = Semigroup[String]{ (x, y) => if (x.length > y.length)
 x else y }
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 The composition of functions is associative (see proofs in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Whether we choose to define 
\begin_inset Formula $x\oplus y\oplus z=x\bef y\bef z$
\end_inset

 or 
\begin_inset Formula $x\oplus y\oplus z=x\circ y\circ z=z\bef y\bef x$
\end_inset

, the results do not depend on inserting parentheses.
 The code for these two typeclass instances is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def semigroup4[S] = Semigroup[S => S]{ (x, y) => x andThen y }
\end_layout

\begin_layout Plain Layout

implicit def semigroup5[S] = Semigroup[S => S]{ (x, y) => x compose y }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-Monoids"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (monoids)
\end_layout

\begin_layout Standard
When a data type is a semigroup, it is often possible to find a special
 value that acts as an 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 value with respect to the semigroup operation.
 Merging with the default value will not change any other value.
 For instance, concatenating with an empty list does not change any other
 list; so the empty list plays the role of the default value for lists.
 Merging an empty set with any other set does not change the other set;
 so the empty set is the default for sets.
\end_layout

\begin_layout Standard
A semigroup with such a default value is called a 
\series bold
monoid
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monoid|textit
\end_layout

\end_inset

.
 Formally, a type 
\begin_inset Formula $T$
\end_inset

 is a monoid when it has an associative binary operation 
\begin_inset Formula $\oplus_{T}$
\end_inset

 and a chosen default or 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 value (
\begin_inset Formula $e^{:T}$
\end_inset

) such that: 
\begin_inset Formula 
\begin{equation}
\text{for all }x^{:T}:\quad e\oplus_{T}x=x\quad,\quad\quad x\oplus_{T}e=x\quad.\label{eq:identity-laws-of-monoid}
\end{equation}

\end_inset

The laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-laws-of-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are called the 
\series bold
identity laws
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of monoids
\end_layout

\end_inset

 of a monoid.
 
\end_layout

\begin_layout Standard
The task in this example is to define a typeclass describing monoids.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The typeclass
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Monoid
\end_layout

\end_inset

 instances should contain the same information as semigroups and additionally
 the default value of type 
\begin_inset Formula $T$
\end_inset

.
 So, we write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Monoid[T](combine: (T, T) => T, empty: T)
\end_layout

\end_inset

Let us define some typeclass instances for illustration:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

object Monoid {
\end_layout

\begin_layout Plain Layout

  implicit val monoidInt = Monoid[Int](_ + _, 0)
\end_layout

\begin_layout Plain Layout

  implicit val monoidString = Monoid[String](_ + _, 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  implicit def monoidList[A] = Monoid[List[A]](_ ++ _, List())
\end_layout

\begin_layout Plain Layout

  implicit def monoidFunc[A] = Monoid[A => A](_ andThen _, identity)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Monoids formalize the general properties of data aggregation.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will study monoids in more detail and show further examples of their use.
 At this point, we look at one more example that defines a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance using two previously defined typeclasses, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-Monoids-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Monoids-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (monoids as semigroups with default)
\end_layout

\begin_layout Standard
A monoid combines the properties of a semigroup and a type with a default
 value.
 If a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is a semigroup and has a default value, it is likely that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is a monoid.
 The task is to define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass instance given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 instances for a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidOf[T]
\end_layout

\end_inset

 that returns the required monoid typeclass instance for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 The typeclass constraints for this function are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

.
 So the type signature must be:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidOf[T](implicit ti1: Semigroup[T], ti2: HasDefault[T]): Monoid[T]
 = ???
\end_layout

\end_inset

To implement a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid[T]
\end_layout

\end_inset

, we need to provide a function of type 
\begin_inset Formula $T\times T\rightarrow T$
\end_inset

 and a value of type 
\begin_inset Formula $T$
\end_inset

.
 Precisely that data is available in the typeclass instances of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

, and so it is natural to use them:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidOf[T](implicit ti1: Semigroup[T], ti2: HasDefault[T]): Monoid[T]
 =
\end_layout

\begin_layout Plain Layout

  Monoid(ti1.combine, ti2.value)
\end_layout

\end_inset

Using the type constraint syntax, the equivalent code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidOf[T: Semigroup : HasDefault]: Monoid[T] =
\end_layout

\begin_layout Plain Layout

  Monoid(implicitly[Semigroup[T]].combine, implicitly[HasDefault[T]].value)
\end_layout

\end_inset

We can also define this function as an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implicit
\end_layout

\end_inset

, so that every type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 instances will automatically receive a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass instance as well.
\end_layout

\begin_layout Standard
Writing the types of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instances in the type notation, we get:
\begin_inset Formula 
\[
\text{Semigroup}^{T}\triangleq T\times T\rightarrow T\quad,\quad\quad\text{HasDefault}^{T}\triangleq T\quad,\quad\quad\text{Monoid}^{T}\triangleq\left(T\times T\rightarrow T\right)\times T\quad.
\]

\end_inset

It is now clear that the following equivalence holds:
\begin_inset Formula 
\[
\text{Monoid}^{T}\cong\text{Semigroup}^{T}\times\text{HasDefault}^{T}\quad.
\]

\end_inset

Indeed, the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidOf
\end_layout

\end_inset

 computes a pair of values from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 instances.
 
\end_layout

\begin_layout Standard
Is this implementation lawful with respect to the monoid laws? The associativity
 law
\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of monoids
\end_layout

\end_inset

 will hold for the monoid if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 typeclass instance was already lawful.
 However, the value stored in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 instance is not guaranteed to satisfy the identity laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-laws-of-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with respect to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine
\end_layout

\end_inset

 operation stored in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance.
 The programmer must verify that the identity laws hold.
 It can happen that, for some type 
\begin_inset Formula $T$
\end_inset

, typeclass instances of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 already exist but are not 
\begin_inset Quotes eld
\end_inset

compatible
\begin_inset Quotes erd
\end_inset

, so that the monoid identity laws do not hold.
 In that case, a simple combination of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 instances will not work, and a different 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance must be defined.
\end_layout

\begin_layout Standard
Are there alternative implementations of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass instance given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 instances? The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidOf
\end_layout

\end_inset

 needs to produce a value of type 
\begin_inset Formula $\left(T\times T\rightarrow T\right)\times T$
\end_inset

 given values of type 
\begin_inset Formula $T\times T\rightarrow T$
\end_inset

 and a value of type 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\[
\text{monoidOf}:\left(T\times T\rightarrow T\right)\times T\rightarrow\left(T\times T\rightarrow T\right)\times T\quad.
\]

\end_inset

When the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidOf
\end_layout

\end_inset

 is written in this notation, it is clear that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidOf
\end_layout

\end_inset

 should be the identity function; indeed, that is what our code translates
 to.
 Although there are many other implementations of the same type signature,
 only the code shown above will satisfy the monoid laws.
 An example of an unlawful implementation is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def badMonoidOf[T](implicit ti1: Semigroup[T], ti2: HasDefault[T]): Monoid[T]
 =
\end_layout

\begin_layout Plain Layout

  Monoid((x, y) => ti1.combine(x, ti1.combine(x, y)), ti2.value)
\end_layout

\end_inset

This implementation defines the monoid operation as 
\begin_inset Formula $x\oplus x\oplus y$
\end_inset

 instead of the correct definition 
\begin_inset Formula $x\oplus y$
\end_inset

.
 If we set 
\begin_inset Formula $y=e_{T}$
\end_inset

, we will get 
\begin_inset Formula $x\oplus x$
\end_inset

 instead of 
\begin_inset Formula $x$
\end_inset

, violating one of the identity laws.
\end_layout

\begin_layout Subsection
Typeclasses for type constructors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Typeclasses-for-type-constructors"

\end_inset


\end_layout

\begin_layout Standard
As an example of a function parameterized by a type constructor, consider
 the following function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inject
\end_layout

\end_inset

 with a type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 constrained to be a functor:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "65col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -5baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def inject[F[_]: Functor, A, B](a: A, f: F[B]): F[(A, B)] = ???
\end_layout

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Functor
\end_layout

\end_inset

 typeclass implementing this constraint will use the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[F[_]]
\end_layout

\end_inset

 because the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 is itself a type constructor.
 
\end_layout

\begin_layout Standard
What information needs to be wrapped by a typeclass instance? A functor
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 must have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function with the standard type signature:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](fa: F[A])(f: A => B): F[B]
\end_layout

\end_inset


\begin_inset VSpace -5baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In the type notation, this type signature is written as:
\begin_inset VSpace -45baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{map}:\forall(A,B).\,F^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow F^{B}\quad.
\]

\end_inset


\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
So, a typeclass instance of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass must contain this function as a value.
 But defining the typeclass as before via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class
\end_layout

\end_inset

 does not work with Scala 2:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

final case class Functor[F[_]](map: $
\backslash
forall(A,B).
\backslash
,$F[A] => (A => B) => F[B])   // Not possible in Scala 2.
\end_layout

\end_inset

Scala 3 will directly support an argument type that 
\emph on
itself
\emph default
 contains type quantifiers such as 
\begin_inset Formula $\forall(A,B)$
\end_inset

.
 In Scala 2, we need to represent such 
\begin_inset Quotes eld
\end_inset

nested
\begin_inset Quotes erd
\end_inset

 type quantifiers by writing a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 method:
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Functor
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Functor[F[_]] {
\end_layout

\begin_layout Plain Layout

  def map[A, B](fa: F[A])(f: A => B): F[B]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Functor
\end_layout

\end_inset

 has the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

F[_]
\end_layout

\end_inset

, which must be itself a type constructor.
 For any type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

F
\end_layout

\end_inset

, a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Functor[F]
\end_layout

\end_inset

 is a wrapper for a value of type 
\begin_inset Formula $\forall(A,B).\,F^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow F^{B}$
\end_inset

.
 Values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 (i.e., typeclass instances) are implemented with the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

new { ...
 }
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val functorSeq = new Functor[Seq] {
\end_layout

\begin_layout Plain Layout

  def map[A, B](fa: Seq[A])(f: A => B): Seq[B] = fa.map(f)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This is currently the most common way of defining typeclasses in Scala.
\end_layout

\begin_layout Standard
It is convenient to declare 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as an extension method on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 type constructors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class FunctorSyntax[F[_]: Functor, A](fa: F[A]) {    // Syntax
 helper class.
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): F[B] = implicitly[Functor[F]].map(fa)(f)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If this class definition is in scope, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method becomes available for values of functor types.
\end_layout

\begin_layout Standard
Using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass and the syntax helper, we can now implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inject
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def inject[F[_]: Functor, A, B](a: A, f: F[B]): F[(A, B)] = f.map { b =>
 (a, b) }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> inject(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

, Seq(1, 2, 3))   // Assuming that implicit Functor[Seq] is in scope.
\end_layout

\begin_layout Plain Layout

res0: Seq[(String, Int)] = List(("abc", 1), ("abc", 2), ("abc", 3))
\end_layout

\end_inset

 Just like the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass, the code of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass does not enforce the functor laws on the implementation.
 It is the programmer responsibility to verify that the laws hold.
\end_layout

\begin_layout Standard
One way of checking the laws is to use the 
\family typewriter
scalacheck
\family default
 library
\begin_inset Index idx
status open

\begin_layout Plain Layout
verifying laws with 
\family typewriter
scalacheck
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.scalacheck.org"
literal "false"

\end_inset


\end_layout

\end_inset

 that automatically runs random tests for the given assertions, trying to
 discover a set of values for which some assertion fails.
 Using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass constraint, we can implement a function (in our terminology,
 a PTVF) that checks the functor laws for 
\emph on
any
\emph default
 given type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import org.scalacheck.Arbitrary                                 // Necessary
 imports and definitions.
\end_layout

\begin_layout Plain Layout

import org.scalatest.prop.GeneratorDrivenPropertyChecks
\end_layout

\begin_layout Plain Layout

class FunctorTest extends Matchers with GeneratorDrivenPropertyChecks {
\end_layout

\begin_layout Plain Layout

  def checkFunctorLaws[F[_], A, B, C]()(implicit ff: Functor[F],     //
 Use the `Arbitrary` typeclass
\end_layout

\begin_layout Plain Layout

      fa: Arbitrary[F[A]], ab: Arbitrary[A => B], bc: Arbitrary[B => C])
 = {    // from `scalacheck`.
\end_layout

\begin_layout Plain Layout

    forAll { (fa: F[A]) => fa.map(identity[A]) shouldEqual fa }  // Identity
 law.
 
\begin_inset Quotes eld
\end_inset

For all `fa`, ...
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

    forAll { (f: A => B, g: B => C, fa: F[A]) =>          // Composition
 law.
 The assertion must hold
\end_layout

\begin_layout Plain Layout

      fa.map(f).map(g) shouldEqual fa.map(f andThen g)    // for all `f`, `g`,
 `fa`.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // Check the laws for F = Seq using specific types instead of type parameters
 A, B, C.
\end_layout

\begin_layout Plain Layout

  checkFunctorLaws[Seq, Int, String, Double]()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
scalacheck
\family default
 library will substitute a large number of random values into the given
 assertions, Note that the laws are being tested only with a finite number
 of values and with type parameters set to specific types.
 While it is useful to test laws with 
\family typewriter
scalacheck
\family default
 (we might find a bug), only a symbolic derivation provides a rigorous proof
 that the laws hold.
 One of the main themes of this book is to show how to perform symbolic
 derivations efficiently.
\end_layout

\begin_layout Section
Deriving typeclass instances via structural analysis of types
\end_layout

\begin_layout Standard
In Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we analyzed the structure of functors by checking which of the six standard
 type constructions can make new functors out of previous ones.
 We will now apply the same
\begin_inset Index idx
status open

\begin_layout Plain Layout
structural analysis
\end_layout

\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
types!structural analysis
\end_layout

\end_inset


\series bold
structural analysis
\series default
 to various typeclasses.
 Is a product of two monoids a monoid? Is a co-product of two semigroups
 a semigroup? Answers to such questions will enable us to:
\end_layout

\begin_layout Itemize
Quickly decide whether a given type can have a typeclass instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

, etc.
\end_layout

\begin_layout Itemize
If so, derive the code for the new typeclass instance without guessing.
\end_layout

\begin_layout Itemize
Have assurance that the required typeclass laws will hold for newly constructed
 instances.
\end_layout

\begin_layout Standard
In the following sections, we will show how to use this approach for some
 simple typeclasses.
\end_layout

\begin_layout Subsection
Extractors
\end_layout

\begin_layout Standard
Our first typeclass is a generalization of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-metadata-extractors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The functionality was to extract metadata of fixed types from a value of
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
 The typeclass instance contained a pair of functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class HasMetadata[T](getName: T => String, getCount: T => Long)
\end_layout

\end_inset

In the type notation, this type constructor is written as
\begin_inset Formula 
\[
\text{HasMetadata}^{T}\triangleq(T\rightarrow\text{String})\times(T\rightarrow\text{Long})\quad.
\]

\end_inset

A standard type equivalence (see Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows that this type is equivalent to 
\begin_inset Formula $T\rightarrow\text{String}\times\text{Long}$
\end_inset

.
 This motivates us to denote 
\begin_inset Formula $\text{String}\times\text{Long}$
\end_inset

 by 
\begin_inset Formula $Z$
\end_inset

 and to consider a typeclass whose instances are values of type 
\begin_inset Formula $T\rightarrow Z$
\end_inset

.
 We may call this typeclass a 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $Z$
\end_inset

-extractor
\begin_inset Index idx
status open

\begin_layout Plain Layout
extractor typeclass
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Extractor
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 since types 
\begin_inset Formula $T$
\end_inset

 from its type domain permit us somehow to extract values of type 
\begin_inset Formula $Z$
\end_inset

.
 With a fixed type 
\begin_inset Formula $Z$
\end_inset

, we denote the typeclass by
\begin_inset Formula 
\[
\text{Extractor}^{T}\triangleq T\rightarrow Z\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Extractor[Z, T](extract: T => Z)
\end_layout

\end_inset

What kind of types can have an Extractor typeclass instance? To answer that
 question, we apply structural analysis and check whether any of the standard
 type constructions produce new typeclass instances.
 The results are summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-Extractor"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Let us show the required calculations.
\end_layout

\begin_layout Paragraph
Fixed types
\end_layout

\begin_layout Standard
We check whether an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 typeclass instance can be computed for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type or for another fixed type 
\begin_inset Formula $C$
\end_inset

.
 To compute 
\begin_inset Formula $\text{Extractor}^{\bbnum 1}=\bbnum 1\rightarrow Z$
\end_inset

 requires creating a value of type 
\begin_inset Formula $Z$
\end_inset

 from scratch, which we cannot do in a fully parametric function.
 For a fixed type 
\begin_inset Formula $C$
\end_inset

, a value of type 
\begin_inset Formula $\text{Extractor}^{C}=C\rightarrow Z$
\end_inset

 can be computed only if we can compute a value of type 
\begin_inset Formula $Z$
\end_inset

 given a value of type 
\begin_inset Formula $C$
\end_inset

.
 This is possible only if we choose 
\begin_inset Formula $C$
\end_inset

 as 
\begin_inset Formula $C=Z$
\end_inset

.
 The typeclass instance for 
\begin_inset Formula $\text{Extractor}^{Z}$
\end_inset

 is implemented as an identity function of type 
\begin_inset Formula $Z\rightarrow Z$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def extractorZ[Z] = Extractor[Z, Z](identity)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
Creating a typeclass instance 
\begin_inset Formula $\text{Extractor}^{A}$
\end_inset

 for an arbitrary type 
\begin_inset Formula $A$
\end_inset

 means to compute 
\begin_inset Formula $\forall A.\,A\rightarrow Z$
\end_inset

; this is not possible since we cannot create values of type 
\begin_inset Formula $Z$
\end_inset

 using only a value of an unknown type 
\begin_inset Formula $A$
\end_inset

.
 So, there is no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 for arbitrary types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
If the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are known to be within the type domain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

, can we add the pair 
\begin_inset Formula $A\times B$
\end_inset

 to that domain? If we can extract a value of type 
\begin_inset Formula $Z$
\end_inset

 from each of two values 
\begin_inset Formula $a^{:A}$
\end_inset

 and 
\begin_inset Formula $b^{:B}$
\end_inset

, we can certainly extract a value of type 
\begin_inset Formula $Z$
\end_inset

 from the product 
\begin_inset Formula $a\times b$
\end_inset

 by choosing to extract only from 
\begin_inset Formula $a$
\end_inset

 or only from 
\begin_inset Formula $b$
\end_inset

.
 So, it appears that we have two possibilities for implementing the typeclass
 for 
\begin_inset Formula $A\times B$
\end_inset

.
 Reasoning more rigorously, we see that computing a new typeclass instance
 from two previous ones requires implementing a conversion function with
 type signature:
\begin_inset Formula 
\[
\forall(A,B,Z).\,\text{Extractor}^{A}\times\text{Extractor}^{B}\rightarrow\text{Extractor}^{A\times B}=\left(A\rightarrow Z\right)\times\left(B\rightarrow Z\right)\rightarrow A\times B\rightarrow Z\quad.
\]

\end_inset

We can derive only two fully parametric implementations of this type signature:
 
\begin_inset Formula 
\[
f^{:A\rightarrow Z}\times g^{:B\rightarrow Z}\rightarrow a\times b\rightarrow f(a)\quad\quad\text{ and }\quad\quad f^{:A\rightarrow Z}\times g^{:B\rightarrow Z}\rightarrow a\times b\rightarrow g(b)\quad.
\]

\end_inset

Both implementations give a valid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance (since there are no laws to check).
 However, every choice will use one of the two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instances and ignore the other.
 So, we can simplify this construction by keeping the typeclass constraint
 only for 
\begin_inset Formula $A$
\end_inset

 and allowing 
\emph on
any
\emph default
 type 
\begin_inset Formula $B$
\end_inset

:
\begin_inset Formula 
\[
\text{extractorPair}:\forall(A,B,Z).\,\text{Extractor}^{A}\rightarrow\text{Extractor}^{A\times B}\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def extractorPair[Z, A, B](implicit ti: Extractor[Z, A]) =
\end_layout

\begin_layout Plain Layout

  Extractor[Z, (A, B)] { case (a, b) => ti.extract(a) }
\end_layout

\end_inset

If 
\begin_inset Formula $A$
\end_inset

 has an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance, the product of 
\begin_inset Formula $A$
\end_inset

 with any type 
\begin_inset Formula $B$
\end_inset

 also has an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance.
 Examples of this construction are 
\begin_inset Formula $Z\times B$
\end_inset

 and 
\begin_inset Formula $P\times Q\times Z$
\end_inset

 (since the type 
\begin_inset Formula $Z$
\end_inset

 itself has an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance).
\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
Given typeclass instances 
\begin_inset Formula $\text{Extractor}^{A}$
\end_inset

 and 
\begin_inset Formula $\text{Extractor}^{B}$
\end_inset

, can we compute a value of type 
\begin_inset Formula $\text{Extractor}^{A+B}$
\end_inset

? Writing out the types, we get:
\begin_inset Formula 
\[
\text{Extractor}^{A}\times\text{Extractor}^{B}\rightarrow\text{Extractor}^{A+B}=\left(A\rightarrow Z\right)\times\left(B\rightarrow Z\right)\rightarrow A+B\rightarrow Z\quad.
\]

\end_inset

Due to a known type equivalence (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we have a unique implementation of this function:
\begin_inset Formula 
\[
\text{extractorEither}\triangleq f^{:A\rightarrow Z}\times g^{:B\rightarrow Z}\rightarrow\,\begin{array}{|c||c|}
 & Z\\
\hline A & a\rightarrow f(a)\\
B & b\rightarrow g(b)
\end{array}\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def extractorEither[Z, A, B](implicit ti1: Extractor[Z, A], ti2: Extractor[Z,
 B]) =
\end_layout

\begin_layout Plain Layout

  Extractor[Z, Either[A, B]] {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => ti1.extract(a)
\end_layout

\begin_layout Plain Layout

    case Right(b)   => ti2.extract(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

So, the co-product of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 can be given a unique 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance.
\end_layout

\begin_layout Standard
Since the product and the co-product constructions preserve 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instances, we conclude that any polynomial type expression has an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance as long as every product type contains at least one 
\begin_inset Formula $Z$
\end_inset

 or another 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 type.
 For example, the type expression 
\begin_inset Formula 
\[
A\times Z+Z\times(P+Z\times Q)+B\times C\times Z
\]

\end_inset

is of that form and therefore has an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance.
 Generally, a polynomial in 
\begin_inset Formula $Z$
\end_inset

 will have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance only if the polynomial is of the form 
\begin_inset Formula $Z\times P^{Z}$
\end_inset

 for some functor 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Paragraph
Function types
\end_layout

\begin_layout Standard
We need to investigate whether 
\begin_inset Formula $C\rightarrow A$
\end_inset

 or 
\begin_inset Formula $A\rightarrow C$
\end_inset

 can have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance for some choice of 
\begin_inset Formula $C$
\end_inset

, assuming that we have an instance for 
\begin_inset Formula $A$
\end_inset

.
 The required conversion functions must have type signatures:
\begin_inset Formula 
\[
\text{Extractor}^{A}\rightarrow\text{Extractor}^{A\rightarrow C}\quad\quad\text{ or }\quad\quad\text{Extractor}^{A}\rightarrow\text{Extractor}^{C\rightarrow A}\quad.
\]

\end_inset

Writing out the types, we find:
\begin_inset Formula 
\[
\left(A\rightarrow Z\right)\rightarrow\left(A\rightarrow C\right)\rightarrow Z\quad\quad\text{ or }\quad\quad\left(A\rightarrow Z\right)\rightarrow\left(C\rightarrow A\right)\rightarrow Z\quad.
\]

\end_inset

None of these type signatures can be implemented.
 The first one is hopeless since we do not have values of type 
\begin_inset Formula $A$
\end_inset

; the second one is missing values of type 
\begin_inset Formula $C$
\end_inset

.
 However, since the type 
\begin_inset Formula $C$
\end_inset

 is fixed, we may store a value of type 
\begin_inset Formula $C$
\end_inset

 as part of the newly constructed type.
 So, we consider the pair type 
\begin_inset Formula $C\times\left(C\rightarrow A\right)$
\end_inset

 and find that its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance, i.e., a value of type 
\begin_inset Formula $C\times\left(C\rightarrow A\right)\rightarrow Z$
\end_inset

, can be derived from a value of type 
\begin_inset Formula $A\rightarrow Z$
\end_inset

 as:
\begin_inset Formula 
\[
f^{:A\rightarrow Z}\rightarrow c^{:C}\times g^{:C\rightarrow A}\rightarrow f(g(c))\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def extractorFunc[Z, A, C](implicit ti: Extractor[Z, A]) =
\end_layout

\begin_layout Plain Layout

  Extractor[Z, (C, C => A)] { case (c, g) => ti.extract(g(c)) }
\end_layout

\end_inset

Examples of this construction are the type expressions 
\begin_inset Formula $C\times\left(C\rightarrow Z\right)$
\end_inset

 and 
\begin_inset Formula $D\times\left(D\rightarrow Z\times P\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Another situation where an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance exists for the type 
\begin_inset Formula $C\rightarrow A$
\end_inset

 is when the type 
\begin_inset Formula $C$
\end_inset

 has a known 
\begin_inset Quotes eld
\end_inset

default value
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $e_{C}$
\end_inset

 (as in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 typeclass).
 In that case, we may omit the first 
\begin_inset Formula $C$
\end_inset

 in 
\begin_inset Formula $C\times(C\rightarrow A)$
\end_inset

 and instead substitute the default value when necessary.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
We can add recursion to any of the constructions that create a new type
 with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance out of a previous such type.
 For clarity, let us use type constructors 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, etc., for describing the new types produced out of previous extractor types.
 For the product construction, we define 
\begin_inset Formula $F_{1}^{B,A}\triangleq A\times B$
\end_inset

.
 For the co-product construction, define 
\begin_inset Formula $F_{2}^{B,A}\triangleq B+A$
\end_inset

 (where 
\begin_inset Formula $B$
\end_inset

 must be also an extractor type).
 For the function construction, define 
\begin_inset Formula $F_{3}^{C,A}\triangleq C\times\left(C\rightarrow A\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Any recursive type equation that uses 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, and/or 
\begin_inset Formula $F_{3}$
\end_inset

 will define a new recursive type with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance.
 An example is the type equation involving the composition of 
\begin_inset Formula $F_{2}$
\end_inset

 and 
\begin_inset Formula $F_{1}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
T\triangleq F_{2}^{Z\times P,F_{1}^{T,Q}}=Z\times P+Q\times T\quad.\label{eq:example-recursive-equation-extractor}
\end{equation}

\end_inset

We can visualize this recursive type as an 
\begin_inset Quotes eld
\end_inset

infinite disjunction
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & T\cong Z\times P+Q\times T\\
 & \cong Z\times P+Q\times\left(Z\times P+Q\times\left(Z\times P+...\right)\right)\\
 & \cong Z\times P\times(\bbnum 1+Q+Q\times Q+...)\cong Z\times P\times\text{List}^{Q}\quad.
\end{align*}

\end_inset

Since the resulting type is equivalent to 
\begin_inset Formula $Z\times C$
\end_inset

 where 
\begin_inset Formula $C\triangleq P\times\text{List}^{Q}$
\end_inset

, we find that the recursive equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-recursive-equation-extractor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equivalent to the product construction with a different type.
\end_layout

\begin_layout Standard
This will happen with any recursive equation containing 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

 (but no 
\begin_inset Formula $F_{3}$
\end_inset

): since 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

 are polynomial functors, the resulting type 
\begin_inset Formula $T$
\end_inset

 will be a recursive polynomial in 
\begin_inset Formula $Z$
\end_inset

.
 To support an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance, such polynomials must be the form 
\begin_inset Formula $Z\times P^{Z}$
\end_inset

 for some functor 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
Recursive equations involving 
\begin_inset Formula $F_{3}$
\end_inset

 will produce new examples of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 types, such as:
\begin_inset Formula 
\begin{equation}
T\triangleq F_{3}^{C,F_{2}^{Z,F_{1}^{T,P}}}=C\times\left(C\rightarrow Z+P\times T\right)\quad.\label{eq:example-good-recursive-equation-extractor}
\end{equation}

\end_inset

Heuristically, this type can be seen as an 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

 exponential-polynomial type expression:
\begin_inset Formula 
\[
T=C\times\left(C\rightarrow Z+P\times C\times\left(C\rightarrow Z+P\times C\times\left(C\rightarrow Z+...\right)\right)\right)\quad.
\]

\end_inset

Types of this form are useful in some applications involving lazy streams.
\end_layout

\begin_layout Standard
We will now show how to define an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance for any recursive type defined using 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, and/or 
\begin_inset Formula $F_{3}$
\end_inset

.
 A recursive type equation defining a type 
\begin_inset Formula $T$
\end_inset

 can be written generally as 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

, where 
\begin_inset Formula $S$
\end_inset

 is a type constructor built up by composing 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, and/or 
\begin_inset Formula $F_{3}$
\end_inset

 in some way.
 (The type constructor 
\begin_inset Formula $S$
\end_inset

 may use 
\begin_inset Formula $Z$
\end_inset

 or other fixed types.) For each of 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, and/or 
\begin_inset Formula $F_{3}$
\end_inset

, we implemented a function of type:
\begin_inset Formula 
\[
\text{extractorF}:\text{Extractor}^{A}\rightarrow\text{Extractor}^{F^{A}}\quad.
\]

\end_inset

Since 
\begin_inset Formula $S$
\end_inset

 is a composition of 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, and/or 
\begin_inset Formula $F_{3}$
\end_inset

, we are able to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extractorS
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{extractorS}:\text{Extractor}^{A}\rightarrow\text{Extractor}^{S^{A}}\quad.
\]

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance for the recursive type 
\begin_inset Formula $T$
\end_inset

 is then defined recursively as:
\begin_inset Formula 
\[
x^{:T\rightarrow Z}\triangleq\text{extractorS}\left(x\right)\quad.
\]

\end_inset

The types match because the type 
\begin_inset Formula $T$
\end_inset

 is equivalent to the type 
\begin_inset Formula $S^{T}$
\end_inset

.
 As long as the definition of the recursive type 
\begin_inset Formula $T$
\end_inset

 is valid (i.e., the type recursion terminates), the extractor function will
 also terminate.
\end_layout

\begin_layout Standard
To illustrate this construction, let us derive an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance for the type 
\begin_inset Formula $T$
\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-good-recursive-equation-extractor"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 That equation has the form 
\begin_inset Formula $T=S^{T}$
\end_inset

 with the type constructor 
\begin_inset Formula $S$
\end_inset

 defined by 
\begin_inset Formula $S^{A}\triangleq C\times\left(C\rightarrow Z+P\times A\right)$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A] = (C, C => Either[Z, (P, A)])  // The fixed types `C` and `P`
 must be defined previously.
\end_layout

\begin_layout Plain Layout

final case class TypeT(t: S[TypeT])      // Define the recursive type `TypeT`.
 
\end_layout

\end_inset

To implement the function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor[T] => Extractor[S[T]]
\end_layout

\end_inset

, which is 
\begin_inset Formula $\left(T\rightarrow Z\right)\rightarrow S^{T}\rightarrow Z$
\end_inset

, we begin with a typed hole:
\begin_inset Formula 
\[
f^{:T\rightarrow Z}\rightarrow s^{:C\times\left(C\rightarrow Z+P\times T\right)}\rightarrow\text{???}^{:Z}\quad.
\]

\end_inset

To fill 
\begin_inset Formula $\text{???}^{:Z}$
\end_inset

, we could apply 
\begin_inset Formula $f^{:T\rightarrow Z}$
\end_inset

 to some value of type 
\begin_inset Formula $T$
\end_inset

; but the only value of type 
\begin_inset Formula $T$
\end_inset

 can be obtained if we apply the function of type 
\begin_inset Formula $C\rightarrow Z+P\times T$
\end_inset

 to the given value of type 
\begin_inset Formula $C$
\end_inset

.
 So we write:
\begin_inset Formula 
\[
f^{:T\rightarrow Z}\rightarrow c^{:C}\times g^{:C\rightarrow Z+P\times T}\rightarrow g(c)\triangleright\text{???}^{:Z+P\times T\rightarrow Z}\quad.
\]

\end_inset

The new typed hole has a function type.
 We can write the code in matrix notation as:
\begin_inset Formula 
\[
\text{extractorS}\triangleq f^{:T\rightarrow Z}\rightarrow c^{:C}\times g^{:C\rightarrow Z+P\times T}\rightarrow g(c)\triangleright\,\begin{array}{|c||c|}
 & Z\\
\hline Z & \text{id}\\
P\times T & \_^{:P}\times t^{:T}\rightarrow f(t)
\end{array}\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def extractorS[A](f: Extractor[A]): Extractor[S[A]] = Extractor[S[A]] {
 case (c, g) =>
\end_layout

\begin_layout Plain Layout

  g(c) match {
\end_layout

\begin_layout Plain Layout

    case Left(z)         => z
\end_layout

\begin_layout Plain Layout

    case Right((_, t))   => f.extract(t)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The recursive construction defines an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $T$
\end_inset

 by a recursive equation:
\begin_inset Formula 
\begin{equation}
\text{extractorT}\triangleq\text{extractorS}\left(\text{extractorT}\right)\quad.\label{eq:recursive-extractor-def}
\end{equation}

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def extractorT: Extractor[TypeT] = Extractor[TypeT] { case TypeT(t) =>
\end_layout

\begin_layout Plain Layout

  extractorS(extractorT).extract(t)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test this code, we define a value of type 
\begin_inset Formula $T$
\end_inset

 while setting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C = Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Boolean
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z = String
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t = TypeT((10, x => Right((true, TypeT((x * 2, y => Left(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

)))))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> extractorT.extract(t) // The recursive definition of `extractorT`
 terminates.
\end_layout

\begin_layout Plain Layout

res0: String = abc
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Why the recursion terminates
\end_layout

\begin_layout Standard
The above code shows that the recursive definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:recursive-extractor-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) terminates.
 Why does it? A recursive definition of the form 
\begin_inset Formula $x\triangleq f(x)$
\end_inset

 could create an infinite loop, as in this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int): Int = x + 1
\end_layout

\begin_layout Plain Layout

def x: Int = f(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x                     // Infinite loop: f(f(f(f(...)))
\end_layout

\begin_layout Plain Layout

java.lang.StackOverflowError
\end_layout

\end_inset

The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extractorT
\end_layout

\end_inset

 works because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extractorT
\end_layout

\end_inset

 is a value of a 
\emph on
function
\emph default
 type, and because the presence of the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 forces us to rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:recursive-extractor-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in the form of an 
\begin_inset Quotes eld
\end_inset

expanded function
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\text{extractorT}\triangleq t\rightarrow\text{extractorS}\left(\text{extractorT}\right)(t)\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def extractorT: Extractor[TypeT] = Extractor { case TypeT(t) => extractorS(extra
ctorT).extract(t) }
\end_layout

\end_inset

Although a function 
\begin_inset Formula $f$
\end_inset

 is equivalent to its 
\series bold
expanded form
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
expanded form of a function!use in recursive values
\end_layout

\end_inset

 
\begin_inset Formula $t\rightarrow f(t)$
\end_inset

, there is an important difference: using expanded forms in the code will
 make recursive definitions 
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive function!termination
\end_layout

\end_inset

 terminate.
\end_layout

\begin_layout Standard
To see an example of that, consider a recursive equation 
\begin_inset Formula $f\triangleq k(f)$
\end_inset

, where 
\begin_inset Formula $k$
\end_inset

 is some function.
 The Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val f = k(f)
\end_layout

\end_inset

 creates an infinite loop when we compute anything that involves 
\begin_inset Formula $f$
\end_inset

:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def k(f: Int => Int): Int => Int = { x => if (x <= 0) 1 else 2 * f(x - 1)
 }
\end_layout

\begin_layout Plain Layout

def f: Int => Int = k(f)   // This definition is invalid!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f                   // Infinite loop: k(k(k(k(...)))
\end_layout

\begin_layout Plain Layout

java.lang.StackOverflowError
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(4)                // Infinite loop: k(k(k(k(...)))(4)
\end_layout

\begin_layout Plain Layout

java.lang.StackOverflowError
\end_layout

\end_inset

This code is clearly invalid.
 But if we expand the right-hand side of the recursive equation to:
\begin_inset Formula 
\[
f\triangleq t\rightarrow k(f)(t)
\]

\end_inset

instead of 
\begin_inset Formula $f\triangleq k(f)$
\end_inset

, the code will become valid, and the infinite loop disappears:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def f: Int => Int = { x => k(f)(x) }   // This defines $
\backslash
color{dkgreen} f(n) = 2^n $ for $
\backslash
color{dkgreen}n 
\backslash
geq 0$.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f                               // We can compute f without an infinite
 loop.
\end_layout

\begin_layout Plain Layout

res0: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(4)                            // We can compute f(4) without an
 infinite loop.
\end_layout

\begin_layout Plain Layout

res1: Int = 16
\end_layout

\end_inset

The recursive use of 
\begin_inset Formula $f$
\end_inset

 now occurs 
\emph on
within
\emph default
 a function body, and so 
\begin_inset Formula $k(f)$
\end_inset

 is evaluated only when 
\begin_inset Formula $f$
\end_inset

 is applied to an argument.
 This allows the recursive definition of 
\begin_inset Formula $f$
\end_inset

 to terminate.
\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
We derived the constructions that create new types with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 typeclass instances from previous ones.
 Any number of these constructions can be combined to create a new type
 expression that will always have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance.
 An example is this type expression:
\begin_inset Formula 
\[
K^{Z,P,Q,R,S}\triangleq Z\times P+Q\times\left(Q\rightarrow Z+R\times\left(R\rightarrow Z\times S\right)\right)\quad.
\]

\end_inset

Since the type 
\begin_inset Formula $K$
\end_inset

 is built up step by step from fixed types via the product, co-product,
 and function constructions, an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $K$
\end_inset

 can be derived systematically with no guessing:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

type K[Z,P,Q,R,S] = Either[(Z, P), (Q, Q => Either[Z, (R, R => (Z, S))])]
\end_layout

\begin_layout Plain Layout

implicit def extractorK[Z,P,Q,R,S]: Extractor[Z, K[Z,P,Q,R,S]] = {   //
 Extractor values for types:
\end_layout

\begin_layout Plain Layout

  implicit val e1 = extractorPair[Z, Z, S]                           //
 $
\backslash
color{dkgreen} Z 
\backslash
times S $.
 Needs Extractor[Z, Z].
\end_layout

\begin_layout Plain Layout

  implicit val e2 = extractorFunc[Z, (Z, S), R]                      //
 $
\backslash
color{dkgreen} R
\backslash
times
\backslash
left(R
\backslash
rightarrow Z
\backslash
times S
\backslash
right) $.
\end_layout

\begin_layout Plain Layout

  implicit val e3 = extractorEither[Z, Z, (R, R => (Z, S))]          //
 $
\backslash
color{dkgreen} Z+R
\backslash
times
\backslash
left(R
\backslash
rightarrow Z
\backslash
times S
\backslash
right) $.
\end_layout

\begin_layout Plain Layout

  implicit val e4 = extractorFunc[Z, Either[Z, (R, R => (Z, S))], Q] //
 $
\backslash
color{dkgreen} Q
\backslash
times
\backslash
left(Q
\backslash
rightarrow Z+R
\backslash
times
\backslash
left(R
\backslash
rightarrow Z
\backslash
times S
\backslash
right)
\backslash
right) $.
\end_layout

\begin_layout Plain Layout

  implicit val e5 = extractorPair[Z, Z, P]                           //
 $
\backslash
color{dkgreen} Z
\backslash
times P $.
\end_layout

\begin_layout Plain Layout

  extractorEither[Z, (Z,P), (Q, Q => Either[Z, (R, R => (Z, S))])]   //
 Extractor for type $
\backslash
color{dkgreen} K $.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code computes each implicit value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

e1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

e2
\end_layout

\end_inset

, ..., using constructions that require previously computed values to be present
 as implicits.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 typeclass is often used with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z = String
\end_layout

\end_inset

 as a way to 
\begin_inset Quotes eld
\end_inset

print
\begin_inset Quotes erd
\end_inset

 values of different types, and it is then called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Show
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Show
\end_layout

\end_inset

.
 When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z = Array[Byte]
\end_layout

\end_inset

, the typeclass is often called a 
\begin_inset Quotes eld
\end_inset

serializer
\begin_inset Index idx
status open

\begin_layout Plain Layout
serializer
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type signature to implement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, or other fixed type 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Extractor}^{\bbnum 1}$
\end_inset

 or 
\begin_inset Formula $\text{Extractor}^{C}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product of extractor type 
\begin_inset Formula $A$
\end_inset

 and any 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Extractor}^{A}\rightarrow\text{Extractor}^{A\times B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product of extractor types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Extractor}^{A}\times\text{Extractor}^{B}\rightarrow\text{Extractor}^{A+B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Function from or to another type 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Extractor}^{A}\rightarrow\text{Extractor}^{A\rightarrow C}$
\end_inset

 or 
\begin_inset Formula $\text{Extractor}^{C\rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Extractor}^{A}\rightarrow\text{Extractor}^{S^{A}}$
\end_inset

 where 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions producing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 typeclass.
\begin_inset CommandInset label
LatexCommand label
name "tab:Type-constructions-for-Extractor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Equality comparison: The 
\family typewriter
Eq
\family default
 typeclass
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-Eq-typeclass"

\end_inset


\end_layout

\begin_layout Standard
In Scala, the built-in operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 is not type-safe because the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x == y
\end_layout

\end_inset

 will compile regardless of the types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 We can replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 by a new operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

===
\end_layout

\end_inset

 constrained to a typeclass called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

, ensuring that types can be meaningfully compared for equality.
 The equality comparison for values of type 
\begin_inset Formula $A$
\end_inset

 is a function of type 
\begin_inset Formula $A\times A\rightarrow\bbnum 2$
\end_inset

 (where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type).
 Typeclass instances of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 need to wrap a function of that type.
 We also define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

===
\end_layout

\end_inset

 as an extension method:
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Eq
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Eq[A](equal: (A, A) => Boolean)
\end_layout

\begin_layout Plain Layout

object Eq {
\end_layout

\begin_layout Plain Layout

  implicit class EqOps[A: Eq](a: A) {
\end_layout

\begin_layout Plain Layout

    def ===(b: A): Boolean = implicitly[Eq[A]].equal(a, b)
\end_layout

\begin_layout Plain Layout

  } // Use type-specific comparisons to define some typeclass instances
 here:
\end_layout

\begin_layout Plain Layout

  implicit val eqInt: Eq[Int] = Eq[Int](_ == _)
\end_layout

\begin_layout Plain Layout

  implicit val eqString: Eq[String] = Eq[String](_ == _)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If we define an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 typeclass instance for all types via the built-in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

==
\end_layout

\end_inset

 operation, we will find that this operation does not work as expected when
 comparing values of a function type, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import Eq._
\end_layout

\begin_layout Plain Layout

implicit def eqTypeA[A] = Eq[A](_ == _)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ((n: Int) => n) === ((n: Int) => n)
\end_layout

\begin_layout Plain Layout

res1: Boolean = false 
\end_layout

\end_inset

Our expectations about equality comparisons are formalized via the laws
 of identity, symmetry, reflexivity, and transitivity (see also a discussion
 on page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "par:label-equality-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-non-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The 
\series bold
reflexivity
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
reflexivity law
\end_layout

\end_inset

 law states that 
\begin_inset Formula $x=x$
\end_inset

 for any 
\begin_inset Formula $x$
\end_inset

; so the comparison 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x === x
\end_layout

\end_inset

 should always return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 The example shown above violates that law when we choose 
\begin_inset Formula $x\triangleq n^{:\text{Int}}\rightarrow n$
\end_inset

.
\end_layout

\begin_layout Standard
Let us perform structural analysis for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 typeclass, defining 
\begin_inset Formula $\text{Eq}^{A}\triangleq A\times A\rightarrow\bbnum 2$
\end_inset

.
 The results (see Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-Eq"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below) will show which types can be usefully compared for equality.
\end_layout

\begin_layout Paragraph
Fixed types
\end_layout

\begin_layout Standard
All primitive types have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instances that use type-specific equality comparisons.
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have equality comparisons, we can compare pairs of type 
\begin_inset Formula $A\times B$
\end_inset

 by comparing each part of the pair separately:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def eqPair[A: Eq, B: Eq] = Eq[(A, B)]{ case ((a1, b1), (a2, b2)) => a1 ===
 a2 && b1 === b2 }
\end_layout

\end_inset

It is easy to check that the identity, symmetry, reflexivity, and transitivity
 laws hold for the new comparison operation if they hold for comparisons
 of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 separately.
\end_layout

\begin_layout Standard
It is important that the code for this construction assumes that both types
 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instances and performs the comparisons 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1 === a2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b1 === b2
\end_layout

\end_inset

.
 If the above code performed only, say, the comparison 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1 === a2
\end_layout

\end_inset

, the resulting comparison operation would have violated the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of equality
\end_layout

\end_inset


\series bold
identity law
\series default
 of the equality operation (if 
\begin_inset Formula $x=y$
\end_inset

 then 
\begin_inset Formula $f(x)=f(y)$
\end_inset

 for any function 
\begin_inset Formula $f$
\end_inset

): we would have pairs such as 
\begin_inset Formula $a\times b_{1}$
\end_inset

 and 
\begin_inset Formula $a\times b_{2}$
\end_inset

 that would be 
\begin_inset Quotes eld
\end_inset

equal
\begin_inset Quotes erd
\end_inset

 according to this definition, and yet many functions 
\begin_inset Formula $f^{:A\times B\rightarrow C}$
\end_inset

 exist such that 
\begin_inset Formula $f(a\times b_{1})\neq f(a\times b_{2})$
\end_inset

.
\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have equality comparisons, we can compare values of type 
\begin_inset Formula $A+B$
\end_inset

 while ensuring that a value of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 is never equal to a value of type 
\begin_inset Formula $\bbnum 0+B$
\end_inset

:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def eqEither[A: Eq, B: Eq] = Eq[Either[A, B]] {
\end_layout

\begin_layout Plain Layout

  case (Left(a1), Left(a2))     => a1 === a2    // Compare $
\backslash
color{dkgreen} a_1 + 
\backslash
bbnum0$ and $
\backslash
color{dkgreen} a_2 + 
\backslash
bbnum0$.
\end_layout

\begin_layout Plain Layout

  case (Right(b1), Right(b2))   => b1 === b2    // Compare $
\backslash
color{dkgreen} 
\backslash
bbnum0 + b_1$ and $
\backslash
color{dkgreen} 
\backslash
bbnum0 + b_2$.
\end_layout

\begin_layout Plain Layout

  case _                        => false        // $
\backslash
color{dkgreen} a + 
\backslash
bbnum0$ is never equal to $
\backslash
color{dkgreen} 
\backslash
bbnum0 + b$.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The laws hold for the new operation because the code defines values of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 as equal only when the types are both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 or both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

.
 If the comparisons of types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 satisfy the laws separately, the laws for 
\begin_inset Formula $A+B$
\end_inset

 will be satisfied separately for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Defining the comparison operation in any other way (e.g., setting 
\begin_inset Formula $a_{1}+\bbnum 0\neq a_{2}+\bbnum 0$
\end_inset

 for all 
\begin_inset Formula $a_{1}^{:A}$
\end_inset

 and 
\begin_inset Formula $a_{2}^{:A}$
\end_inset

, or 
\begin_inset Formula $\bbnum 0+b_{1}=\bbnum 0+b_{2}$
\end_inset

 for all 
\begin_inset Formula $b_{1}^{:B}$
\end_inset

 and 
\begin_inset Formula $b_{2}^{:B}$
\end_inset

) would have violated the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
reflexivity law
\end_layout

\end_inset

reflexivity law or the identity law.
\end_layout

\begin_layout Standard
Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 typeclass has both the product and the co-product constructions, any polynomial
 type expression made of primitive types will also have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 typeclass instance.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $A$
\end_inset

 has an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance, can we create an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance for 
\begin_inset Formula $R\rightarrow A$
\end_inset

 where 
\begin_inset Formula $R$
\end_inset

 is some other type? This would be possible with a function of this type:
\begin_inset Formula 
\begin{equation}
\forall A.\,(A\times A\rightarrow\bbnum 2)\rightarrow\left(R\rightarrow A\right)\times\left(R\rightarrow A\right)\rightarrow\bbnum 2\quad.\label{eq:type-signature-function-comparison}
\end{equation}

\end_inset

Here we assume that the type 
\begin_inset Formula $R$
\end_inset

 is an arbitrary chosen type, so no values of type 
\begin_inset Formula $R$
\end_inset

 can be computed from scratch.
 (This would not be the case when 
\begin_inset Formula $R=\bbnum 1$
\end_inset

 or 
\begin_inset Formula $R=\bbnum 2$
\end_inset

, say.
 But in those cases the type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 can be simplified to a polynomial type, e.g., 
\begin_inset Formula $\bbnum 1\rightarrow A\cong A$
\end_inset

 and 
\begin_inset Formula $\bbnum 2\rightarrow A\cong A\times A$
\end_inset

, etc.) Without values of type 
\begin_inset Formula $R$
\end_inset

, we cannot compute any values of type 
\begin_inset Formula $A$
\end_inset

 and cannot apply comparisons to them.
 Then the only possible implementations of the type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:type-signature-function-comparison"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are constant functions returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 However, the implementation that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 will violate the reflexivity law 
\begin_inset Formula $x=x$
\end_inset

.
 The implementation that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 is not useful.
\end_layout

\begin_layout Standard
We will be able to evaluate functions of type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 if some chosen values of type 
\begin_inset Formula $R$
\end_inset

 are available.
 Examples of that situation are types 
\begin_inset Formula $R$
\end_inset

 of the form 
\begin_inset Formula $R\cong\bbnum 1+S$
\end_inset

 for some type 
\begin_inset Formula $S$
\end_inset

; we then always have a chosen value 
\begin_inset Formula $r_{1}\triangleq1+\bbnum 0^{:S}$
\end_inset

 of type 
\begin_inset Formula $R$
\end_inset

.
 What if we compare functions only via their values at 
\begin_inset Formula $r_{1}$
\end_inset

?
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def equals[R, A: Eq](f: R => A, g: R => A): Boolean = f(r1) === g(r1)  //
 Violates the identity law.
\end_layout

\end_inset

The above code defines a comparison operation that violates the identity
 law: there are many functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 that will give different results for arguments not equal to 
\begin_inset Formula $r_{1}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Another way to see the problem is to write the type equivalence:
\begin_inset Formula 
\[
R\rightarrow A\cong\bbnum 1+S\rightarrow A\cong A\times(S\rightarrow A)\quad,
\]

\end_inset

which reduces this case to the product construction we saw above.
 It follows that we need to have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance for 
\begin_inset Formula $S\rightarrow A$
\end_inset

 to define the equality operation for 
\begin_inset Formula $R\rightarrow A$
\end_inset

.
 If we have a chosen value of type 
\begin_inset Formula $S$
\end_inset

, e.g., if 
\begin_inset Formula $S\cong\bbnum 1+T$
\end_inset

, we will again reduce the situation to the product construction with the
 function type 
\begin_inset Formula $T\rightarrow A$
\end_inset

.
 This process will end only if the type 
\begin_inset Formula $R$
\end_inset

 has the form:
\begin_inset Formula 
\[
R\cong\bbnum 1+\bbnum 1+...+\bbnum 1\quad,\quad\quad R\rightarrow A\cong\bbnum 1+\bbnum 1+...+\bbnum 1\rightarrow A\cong A\times A\times...\times A\quad,
\]

\end_inset

i.e., if 
\begin_inset Formula $R$
\end_inset

 has a 
\emph on
known
\emph default
 finite number of distinct values.
 Then we can write code that applies functions of type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 to every possible value of the argument of type 
\begin_inset Formula $R$
\end_inset

 and compares all the resulting values of type 
\begin_inset Formula $A$
\end_inset

.
 However, we also see that the type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 is equivalent to a polynomial type, which is a product of a fixed number
 of 
\begin_inset Formula $A$
\end_inset

's.
 The product construction already covers that type.
\end_layout

\begin_layout Standard
So, we can compare functions 
\begin_inset Formula $f_{1}^{:R\rightarrow A}$
\end_inset

 and 
\begin_inset Formula $f_{2}^{:R\rightarrow A}$
\end_inset

 only if we are able to check whether 
\begin_inset Formula $f_{1}(r)=f_{2}(r)$
\end_inset

 for 
\emph on
every
\emph default
 possible value of type 
\begin_inset Formula $R$
\end_inset

.
 We cannot implement such a comparison for a general type 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Standard
We conclude that functions of type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 cannot have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance for a general type 
\begin_inset Formula $R$
\end_inset

.
 A similar argument shows that functions of type 
\begin_inset Formula $A\rightarrow R$
\end_inset

 also cannot have a useful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance.
 The only exceptions are types 
\begin_inset Formula $R\rightarrow A$
\end_inset

 or 
\begin_inset Formula $A\rightarrow R$
\end_inset

 that are equivalent to some polynomial types.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
Since all polynomial type expressions preserve 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instances, the same logic can be applied to recursive polynomial types.
 For instance, lists and trees with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

-comparable values are also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

-comparable.
 Let us prove this rigorously.
\end_layout

\begin_layout Standard
Consider a recursive polynomial type 
\begin_inset Formula $T$
\end_inset

 defined using a polynomial functor 
\begin_inset Formula $S^{\bullet}$
\end_inset

:
\begin_inset Formula 
\[
T\triangleq S^{T}\quad.
\]

\end_inset

The functor 
\begin_inset Formula $S^{\bullet}$
\end_inset

 may use other fixed types that have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instances.
 To construct the typeclass instance for 
\begin_inset Formula $T$
\end_inset

, we first implement a function 
\begin_inset Formula $\text{eqS}$
\end_inset

 of type:
\begin_inset Formula 
\[
\text{eqS}:\text{Eq}^{A}\rightarrow\text{Eq}^{S^{A}}\quad.
\]

\end_inset

This function produces an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance for 
\begin_inset Formula $S^{A}$
\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instances of 
\begin_inset Formula $A$
\end_inset

 and of all other types that 
\begin_inset Formula $S^{A}$
\end_inset

 depends on.
 The product and co-product constructions guarantee that it is always possible
 to implement this function for a polynomial functor 
\begin_inset Formula $S^{\bullet}$
\end_inset

.
 Then we define an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance for 
\begin_inset Formula $T$
\end_inset

 recursively:
\begin_inset Formula 
\[
\text{eqT}:\text{Eq}^{T}\quad,\quad\quad\text{eqT}\triangleq\text{eqS}\,(\text{eqT})\quad.
\]

\end_inset

The recursive equation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

 needs to be implemented as an expanded function:
\begin_inset Formula 
\[
\text{eqT}\triangleq t^{:T}\times t^{:T}\rightarrow\text{eqS}\,(\text{eqT})\left(t\times t\right)\quad.
\]

\end_inset

Then the recursion will terminate, as we have seen in the previous section.
\end_layout

\begin_layout Standard
As an example, let us make an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance for the type 
\begin_inset Formula $T$
\end_inset

 defined by 
\begin_inset Formula $T\triangleq\text{Int}+T+\text{Int}\times T\times T$
\end_inset

:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

type S[A] = Either[Either[Int, A], (Int, (A, A))]
\end_layout

\begin_layout Plain Layout

final case class T(s: S[T])                     // Recursive type equation
 $
\backslash
color{dkgreen} T
\backslash
triangleq
\backslash
text{Int}+T+
\backslash
text{Int}
\backslash
times T
\backslash
times T $.
\end_layout

\begin_layout Plain Layout

def eqS[A](implicit ti: Eq[A]): Eq[S[A]] = {    // Function of type Eq[A]
 => Eq[S[A]].
\end_layout

\begin_layout Plain Layout

  implicit val e1 = eqEither[Int, A]            // Instance for $
\backslash
color{dkgreen} 
\backslash
text{Int}+A $.
\end_layout

\begin_layout Plain Layout

  implicit val e2 = eqPair[A, A]                // Instance for $
\backslash
color{dkgreen} A
\backslash
times A $.
\end_layout

\begin_layout Plain Layout

  implicit val e3 = eqPair[Int, (A, A)]         // Instance for $
\backslash
color{dkgreen} 
\backslash
text{Int}
\backslash
times A
\backslash
times A $.
\end_layout

\begin_layout Plain Layout

  eqEither[Either[Int, A], (Int, (A, A))]       // Instance for $
\backslash
color{dkgreen} 
\backslash
text{Int}+A+
\backslash
text{Int}
\backslash
times A
\backslash
times A $.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit def eqT: Eq[T] = Eq { case (T(s1), T(s2)) => eqS(eqT).equal(s1,
 s2) }
\end_layout

\end_inset

To test that the recursion terminates, define a value of type 
\begin_inset Formula $T$
\end_inset

 and run a comparison:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

val t = T(Left(Right(T(Left(Left(10))))))   // $
\backslash
color{dkgreen}t: 
\backslash
bbnum 0+(10^{
\backslash
scriptscriptstyle:
\backslash
text{Int}}+
\backslash
bbnum 0+
\backslash
bbnum 0)^{
\backslash
scriptscriptstyle:T}+
\backslash
bbnum 0$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t === t
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Checking laws for recursive instances
\end_layout

\begin_layout Standard
We use induction to verify that the laws of identity, symmetry, reflexivity,
 and transitivity will hold for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance just defined.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance for 
\begin_inset Formula $T$
\end_inset

 was defined as a recursive function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT = eqS(eqT)
\end_layout

\end_inset

.
 We know that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqS(x)
\end_layout

\end_inset

 satisfies all the required laws if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 satisfies them (
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqS
\end_layout

\end_inset

 preserves the laws
\begin_inset Quotes erd
\end_inset

).
 Let us visualize what happens when the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

 is applied to some values of type 
\begin_inset Formula $T$
\end_inset

.
 Are the laws satisfied in that case (e.g., is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT(t, t) == true
\end_layout

\end_inset

 for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t:T
\end_layout

\end_inset

)? The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

 will call itself recursively whenever the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqS
\end_layout

\end_inset

 calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

.
 
\emph on
Assuming
\emph default
 that all the recursive calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

 satisfy the laws, we find that the outer call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

 also satisfies the laws because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqS
\end_layout

\end_inset

 preserves them.
 This corresponds to the inductive step.
\end_layout

\begin_layout Standard
Eventually the recursion will terminate; so 
\emph on
some
\emph default
 calls of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT(t1, t2)
\end_layout

\end_inset

 with certain values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

 do not cause any more recursive self-calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

.
 For 
\emph on
those
\emph default
 values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

 will satisfy the required laws with no additional assumptions, because
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqS(eqT)(t1, t2)
\end_layout

\end_inset

, which satisfies the laws, does not call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eqT
\end_layout

\end_inset

.
 This corresponds to the base case of an inductive proof.
 
\end_layout

\begin_layout Standard
So, the recursively defined 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance is lawful.
 This argument is general and works in all cases when a typeclass instance
 
\begin_inset Formula $t$
\end_inset

 is defined by recursion, 
\begin_inset Formula $t\triangleq s(t)$
\end_inset

, via a function 
\begin_inset Formula $s$
\end_inset

 that preserves the laws.
\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
Instances of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 typeclass can be derived for any polynomial or recursive polynomial type
 expressions containing primitive types or type parameters constrained to
 be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

-comparable.
 The derivation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 instance is unambiguous and can be automated with libraries such as the
 
\family typewriter
kittens
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/typelevel/kittens"
literal "false"

\end_inset


\end_layout

\end_inset

, 
\family typewriter
magnolia
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/propensive/magnolia"
literal "false"

\end_inset


\end_layout

\end_inset

 , or 
\family typewriter
scalaz-deriving
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/scalaz/scalaz-deriving"
literal "false"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type signature to implement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, or other primitive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Eq}^{T}\triangleq T\times T\rightarrow\bbnum 2$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Eq}^{A}\times\text{Eq}^{B}\rightarrow\text{Eq}^{A\times B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Eq}^{A}\times\text{Eq}^{B}\rightarrow\text{Eq}^{A+B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Recursive types
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Eq}^{A}\rightarrow\text{Eq}^{S^{A}}$
\end_inset

 where 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions producing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 typeclass.
\begin_inset CommandInset label
LatexCommand label
name "tab:Type-constructions-for-Eq"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Semigroups
\begin_inset CommandInset label
LatexCommand label
name "subsec:Semigroups-constructions"

\end_inset


\end_layout

\begin_layout Standard
A type 
\begin_inset Formula $T$
\end_inset

 has an instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 when an associative binary operation of type 
\begin_inset Formula $T\times T\rightarrow T$
\end_inset

 is available.
 We will now apply structural analysis to this typeclass.
 The results are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-semigroup"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Fixed types
\end_layout

\begin_layout Standard
Each of the primitive types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, etc.) has at least one well-known associative binary operation that can
 be used to define a semigroup instance.
 Booleans have the conjunction and the disjunction operations; numbers can
 be added or multiplied, or the maximum or the minimum number chosen; strings
 can be concatenated or chosen in the alphabetical order.
 Examples
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-Semigroups"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-semigroup-alternative-implementations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 show several implementations of such binary operations.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has a trivially defined binary operation, which is also associative
 (since it always returns the same value).
 The same is true for any fixed type that has a chosen 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 value: the binary operation that always returns the default value is associativ
e (although not likely to be useful).
\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
A semigroup instance parametric in type 
\begin_inset Formula $T$
\end_inset

 means a value of type 
\begin_inset Formula $\forall T.\,T\times T\rightarrow T$
\end_inset

.
 There are two implementations of this type signature: 
\begin_inset Formula $a^{:T}\times b^{:T}\rightarrow a$
\end_inset

 and 
\begin_inset Formula $a^{:T}\times b^{:T}\rightarrow b$
\end_inset

.
 Both provide an associative binary operation, as Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-semigroup-alternative-implementations"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) shows.
 So, any type 
\begin_inset Formula $T$
\end_inset

 can be made into a 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 semigroup in one of these two ways.
 (
\begin_inset Index idx
status open

\begin_layout Plain Layout
trivial@
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 semigroup
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

Trivial
\begin_inset Quotes erd
\end_inset

 semigroups are occasionally useful.)
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
If types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are semigroups, the product 
\begin_inset Formula $A\times B$
\end_inset

 can be also given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance.
 
\end_layout

\begin_layout Standard
To compute that instance means, in the general case, to implement a function
 with type:
\begin_inset Formula 
\[
\text{semigroupPair}:\forall(A,B).\,\text{Semigroup}^{A}\times\text{Semigroup}^{B}\rightarrow\text{Semigroup}^{A\times B}\quad.
\]

\end_inset

Writing out the type expressions, we get the type signature:
\begin_inset Formula 
\[
\text{semigroupPair}:\forall(A,B).\,\left(A\times A\rightarrow A\right)\times\left(B\times B\rightarrow B\right)\rightarrow\left(A\times B\times A\times B\rightarrow A\times B\right)\quad.
\]

\end_inset

While this type signature can be implemented in a number of ways, we look
 for code that preserves information, in hopes of satisfying the associativity
 law.
 The code should be a function of the form:
\begin_inset Formula 
\[
\text{semigroupPair}\triangleq f^{:A\times A\rightarrow A}\times g^{:B\times B\rightarrow B}\rightarrow a_{1}^{:A}\times b_{1}^{:B}\times a_{2}^{:A}\times b_{2}^{:B}\rightarrow???^{:A}\times???^{:B}\quad.
\]

\end_inset

Since we are trying to define the new semigroup operation through the previously
 given operations 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

, it is natural to apply 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 to the given data 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $b_{1}$
\end_inset

, 
\begin_inset Formula $b_{2}$
\end_inset

 and write:
\begin_inset Formula 
\[
f^{:A\times A\rightarrow A}\times g^{:B\times B\rightarrow B}\rightarrow a_{1}^{:A}\times b_{1}^{:B}\times a_{2}^{:A}\times b_{2}^{:B}\rightarrow f(a_{1},a_{2})\times g(b_{1},b_{2})\quad.
\]

\end_inset

This code defines a new binary operation 
\begin_inset Formula $\oplus_{A\times B}$
\end_inset

 via the previously given 
\begin_inset Formula $\oplus_{A}$
\end_inset

 and 
\begin_inset Formula $\oplus_{B}$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
(a_{1}^{:A}\times b_{1}^{:B})\oplus_{A\times B}(a_{2}^{:A}\times b_{2}^{:B})=(a_{1}\oplus_{A}a_{2})\times(b_{1}\oplus_{B}b_{2})\quad.\label{eq:semigroup-product-operation-def}
\end{equation}

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def semigroupPair[A: Semigroup, B: Semigroup] =
\end_layout

\begin_layout Plain Layout

  Semigroup[(A, B)]{ case ((a1, b1),(a2, b2)) => (a1 |+| a2, b1 |+| b2)
 }
\end_layout

\end_inset

This implementation satisfies the associativity law if the operations 
\begin_inset Formula $\oplus_{A}$
\end_inset

, 
\begin_inset Formula $\oplus_{B}$
\end_inset

 already do, i.e., if the results of computing 
\begin_inset Formula $a_{1}\oplus_{A}a_{2}\oplus_{A}a_{3}$
\end_inset

 and 
\begin_inset Formula $b_{1}\oplus_{B}b_{2}\oplus_{B}b_{3}$
\end_inset

 do not depend on the order of parentheses:
\begin_inset Formula 
\begin{align*}
 & \left(\left(a_{1}\times b_{1}\right)\oplus_{A\times B}\left(a_{2}\times b_{2}\right)\right)\oplus_{A\times B}\left(a_{3}\times b_{3}\right)=\left((a_{1}\oplus_{A}a_{2})\times(b_{1}\oplus_{B}b_{2})\right)\oplus_{A\times B}\left(a_{3}\times b_{3}\right)\\
 & \quad\quad=\left(a_{1}\oplus_{A}a_{2}\oplus_{A}a_{3}\right)\times\left(b_{1}\oplus_{B}b_{2}\oplus_{B}b_{3}\right)\quad,\\
 & \left(a_{1}\times b_{1}\right)\oplus_{A\times B}\left(\left(a_{2}\times b_{2}\right)\oplus_{A\times B}\left(a_{3}\times b_{3}\right)\right)=\left(a_{1}\times b_{1}\right)\oplus_{A\times B}\left((a_{2}\oplus_{A}a_{3})\times(b_{2}\oplus_{B}b_{3})\right)\\
 & \quad\quad=\left(a_{1}\oplus_{A}a_{2}\oplus_{A}a_{3}\right)\times\left(b_{1}\oplus_{B}b_{2}\oplus_{B}b_{3}\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
To compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance for the co-product 
\begin_inset Formula $A+B$
\end_inset

 of two semigroups, we need:
\begin_inset Formula 
\[
\text{semigroupEither}:\forall(A,B).\,\text{Semigroup}^{A}\times\text{Semigroup}^{B}\rightarrow\text{Semigroup}^{A+B}\quad.
\]

\end_inset

Writing out the type expressions, we get the type signature:
\begin_inset Formula 
\[
\text{semigroupEither}:\forall(A,B).\,\left(A\times A\rightarrow A\right)\times\left(B\times B\rightarrow B\right)\rightarrow\left(A+B\right)\times\left(A+B\right)\rightarrow A+B\quad.
\]

\end_inset

Begin by writing a function with a typed hole:
\begin_inset Formula 
\[
\text{semigroupEither}\triangleq f^{:A\times A\rightarrow A}\times g^{:B\times B\rightarrow B}\rightarrow c^{:\left(A+B\right)\times\left(A+B\right)}\rightarrow\text{???}^{:A+B}\quad.
\]

\end_inset

Transforming the type expression 
\begin_inset Formula $\left(A+B\right)\times\left(A+B\right)$
\end_inset

 into an equivalent disjunctive type:
\begin_inset Formula 
\[
\left(A+B\right)\times\left(A+B\right)\cong A\times A+A\times B+B\times A+B\times B\quad,
\]

\end_inset

we can continue to write the function's code in matrix notation,
\begin_inset Formula 
\[
f^{:A\times A\rightarrow A}\times g^{:B\times B\rightarrow B}\rightarrow\,\begin{array}{|c||cc|}
 & A & B\\
\hline A\times A & \text{???}^{:A\times A\rightarrow A} & \text{???}^{:A\times A\rightarrow B}\\
A\times B & \text{???}^{:A\times B\rightarrow A} & \text{???}^{:A\times B\rightarrow B}\\
B\times A & \text{???}^{:B\times A\rightarrow A} & \text{???}^{:B\times A\rightarrow B}\\
B\times B & \text{???}^{:B\times B\rightarrow A} & \text{???}^{:B\times B\rightarrow B}
\end{array}\quad.
\]

\end_inset

The matrix is 
\begin_inset Formula $4\times2$
\end_inset

 because the input type, 
\begin_inset Formula $A\times A+A\times B+B\times A+B\times B$
\end_inset

, is a disjunction with 
\begin_inset Formula $4$
\end_inset

 parts, while the result type 
\begin_inset Formula $A+B$
\end_inset

 is a disjunction with 
\begin_inset Formula $2$
\end_inset

 parts.
 In each row, we need to fill only one of the two typed holes because only
 one part of the disjunction 
\begin_inset Formula $A+B$
\end_inset

 can have a value.
\end_layout

\begin_layout Standard
To save space, we will omit the types in the matrices.
 The first and the last rows of the matrix must contain functions of types
 
\begin_inset Formula $A\times A\rightarrow A$
\end_inset

 and 
\begin_inset Formula $B\times B\rightarrow B$
\end_inset

, and so it is natural to fill them with 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

:
\begin_inset Formula 
\[
f^{:A\times A\rightarrow A}\times g^{:B\times B\rightarrow B}\rightarrow\,\begin{array}{||cc|}
f^{:A\times A\rightarrow A} & \bbnum 0\\
\text{???}^{:A\times B\rightarrow A} & \text{???}^{:A\times B\rightarrow B}\\
\text{???}^{:B\times A\rightarrow A} & \text{???}^{:B\times A\rightarrow B}\\
\bbnum 0 & g^{:B\times B\rightarrow B}
\end{array}\quad.
\]

\end_inset

The remaining two rows can be filled in four different ways:
\begin_inset Formula 
\begin{align*}
f\times g\rightarrow\,\begin{array}{||cc|}
f^{:A\times A\rightarrow A} & \bbnum 0\\
a^{:A}\times b^{:B}\rightarrow a & \bbnum 0\\
b^{:B}\times a^{:A}\rightarrow a & \bbnum 0\\
\bbnum 0 & g^{:B\times B\rightarrow B}
\end{array}~\quad,\quad\quad & ~f\times g\rightarrow\,\begin{array}{||cc|}
f & \bbnum 0\\
\bbnum 0 & a^{:A}\times b^{:B}\rightarrow b\\
\bbnum 0 & b^{:B}\times a^{:A}\rightarrow b\\
\bbnum 0 & g
\end{array}\quad,\\
f\times g\rightarrow\,\begin{array}{||cc|}
f^{:A\times A\rightarrow A} & \bbnum 0\\
\bbnum 0 & a^{:A}\times b^{:B}\rightarrow b\\
b^{:B}\times a^{:A}\rightarrow a & \bbnum 0\\
\bbnum 0 & g^{:B\times B\rightarrow B}
\end{array}\quad,\quad\quad & f\times g\rightarrow\,\begin{array}{||cc|}
f & \bbnum 0\\
a^{:A}\times b^{:B}\rightarrow a & \bbnum 0\\
\bbnum 0 & b^{:B}\times a^{:A}\rightarrow b\\
\bbnum 0 & g
\end{array}\quad.
\end{align*}

\end_inset

The Scala code corresponding to the four possible definitions of 
\begin_inset Formula $\oplus$
\end_inset

 is:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def semigroupEither1[A: Semigroup, B: Semigroup] = Semigroup[Either[A, B]]
 {
\end_layout

\begin_layout Plain Layout

  case (Left(a1), Left(a2))     =>  a1 |+| a2 // Here a1 |+| a2 is $
\backslash
color{dkgreen} a_1 
\backslash
oplus_A a_2 $.
\end_layout

\begin_layout Plain Layout

  case (Right(b1), Right(b2))   =>  b1 |+| b2 // Here b1 |+| b2 is $
\backslash
color{dkgreen} b_1 
\backslash
oplus_B b_2$.
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(b))      =>  a         // 
\begin_inset Quotes eld
\end_inset

Take $
\backslash
color{dkgreen}A$
\begin_inset Quotes erd
\end_inset

 - discard all data of type $
\backslash
color{dkgreen}B$.
\end_layout

\begin_layout Plain Layout

  case (Right(b), Left(a))      =>  a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def semigroupEither2[A: Semigroup, B: Semigroup] = Semigroup[Either[A, B]]
 {
\end_layout

\begin_layout Plain Layout

  case (Left(a1), Left(a2))     =>  a1 |+| a2
\end_layout

\begin_layout Plain Layout

  case (Right(b1), Right(b2))   =>  b1 |+| b2
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(b))      =>  b         // 
\begin_inset Quotes eld
\end_inset

Take $
\backslash
color{dkgreen}B$
\begin_inset Quotes erd
\end_inset

 - discard all data of type $
\backslash
color{dkgreen}A$.
\end_layout

\begin_layout Plain Layout

  case (Right(b), Left(a))      =>  b
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def semigroupEither3[A: Semigroup, B: Semigroup] = Semigroup[Either[A, B]]
 {
\end_layout

\begin_layout Plain Layout

  case (Left(a1), Left(a2))     =>  a1 |+| a2
\end_layout

\begin_layout Plain Layout

  case (Right(b1), Right(b2))   =>  b1 |+| b2
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(b))      =>  a         // 
\begin_inset Quotes eld
\end_inset

Take first
\begin_inset Quotes erd
\end_inset

 - discard ${
\backslash
color{dkgreen}y}$ in ${
\backslash
color{dkgreen}x
\backslash
oplus y}$.
\end_layout

\begin_layout Plain Layout

  case (Right(b), Left(a))      =>  b
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def semigroupEither4[A: Semigroup, B: Semigroup] = Semigroup[Either[A, B]]
 {
\end_layout

\begin_layout Plain Layout

  case (Left(a1), Left(a2))     =>  a1 |+| a2
\end_layout

\begin_layout Plain Layout

  case (Right(b1), Right(b2))   =>  b1 |+| b2
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(b))      =>  b         // 
\begin_inset Quotes eld
\end_inset

Take last
\begin_inset Quotes erd
\end_inset

 - discard ${
\backslash
color{dkgreen}x}$ in ${
\backslash
color{dkgreen}x
\backslash
oplus y}$.
\end_layout

\begin_layout Plain Layout

  case (Right(b), Left(a))      =>  a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The four different choices of the binary operation can be described as:
\end_layout

\begin_layout Standard
1.
 (
\begin_inset Quotes eld
\end_inset

Take 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

) Discard all data of type 
\begin_inset Formula $B$
\end_inset

: 
\begin_inset Formula $(a^{:A}+\bbnum 0)\oplus(\bbnum 0+b^{:B})=a$
\end_inset

 and 
\begin_inset Formula $(\bbnum 0+b^{:B})\oplus(a^{:A}+\bbnum 0)=a$
\end_inset

.
\end_layout

\begin_layout Standard
2.
 (
\begin_inset Quotes eld
\end_inset

Take 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

) Discard all data of type 
\begin_inset Formula $A$
\end_inset

: 
\begin_inset Formula $(a^{:A}+\bbnum 0)\oplus(\bbnum 0+b^{:B})=b$
\end_inset

 and 
\begin_inset Formula $(\bbnum 0+b^{:B})\oplus(a^{:A}+\bbnum 0)=b$
\end_inset

.
\end_layout

\begin_layout Standard
3.
 (
\begin_inset Quotes eld
\end_inset

Take first
\begin_inset Quotes erd
\end_inset

) 
\begin_inset Formula $x\oplus y$
\end_inset

 discards 
\begin_inset Formula $y$
\end_inset

: 
\begin_inset Formula $(a^{:A}+\bbnum 0)\oplus(\bbnum 0+b^{:B})=a$
\end_inset

 and 
\begin_inset Formula $(\bbnum 0+b^{:B})\oplus(a^{:A}+\bbnum 0)=b$
\end_inset

.
\end_layout

\begin_layout Standard
4.
 (
\begin_inset Quotes eld
\end_inset

Take last
\begin_inset Quotes erd
\end_inset

) 
\begin_inset Formula $x\oplus y$
\end_inset

 discards 
\begin_inset Formula $x$
\end_inset

: 
\begin_inset Formula $(a^{:A}+\bbnum 0)\oplus(\bbnum 0+b^{:B})=b$
\end_inset

 and 
\begin_inset Formula $(\bbnum 0+b^{:B})\oplus(a^{:A}+\bbnum 0)=a$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Does the semigroup law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-semigroup"
plural "false"
caps "false"
noprefix "false"

\end_inset

) hold for the new typeclass instance with any of these implementations?
\end_layout

\begin_layout Standard
It turns out that 
\emph on
all
\emph default
 
\emph on
four
\emph default
 implementations are lawful.
 To verify the associativity law, we need to show that values such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x) |+| Left(y) |+| Right(z)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x) |+| Right(y) |+| Right(z)
\end_layout

\end_inset

 do not depend on the order of inserted parentheses.
 Expressions of the form 
\begin_inset Formula $x\oplus y\oplus z$
\end_inset

 can have 
\begin_inset Formula $8$
\end_inset

 possible combinations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 types.
 Each of them needs to be checked against each of the 
\begin_inset Formula $4$
\end_inset

 implementations of 
\begin_inset Formula $\oplus$
\end_inset

.
 Instead of doing 
\begin_inset Formula $32$
\end_inset

 separate derivations, we will reason case by case.
\end_layout

\begin_layout Standard
First consider the case when all three values are of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

.
 In all four implementations, the binary operation reduces to the binary
 operation of the semigroup 
\begin_inset Formula $A$
\end_inset

, which is associative since we assume that 
\begin_inset Formula $A$
\end_inset

 is a lawful semigroup:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Left(x) |+| Left(y) |+| Left(z) == Left(x |+| y |+| z) == Left(x) |+| (
 Left(y) |+| Left(z) )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The same argument applies to three values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

.
 It remains to consider the 
\begin_inset Quotes eld
\end_inset

mixed
\begin_inset Quotes erd
\end_inset

 cases.
\end_layout

\begin_layout Standard
In the first implementation (
\begin_inset Quotes eld
\end_inset

take 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

), we discard all data of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 from the expression 
\begin_inset Formula $x\oplus y\oplus z$
\end_inset

, keeping only data of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

.
 It is clear that discarding data of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 will yield the same result regardless of the order of parentheses.
 If more than one item of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 remains, the data is aggregated with the operation 
\begin_inset Formula $\oplus_{A}$
\end_inset

.
 So, the results do not depend on the order of parentheses:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Right(x) |+| Right(y) |+| Left(z) == Left(z) == Right(x) |+| ( Right(y)
 |+| Left(z) )
\end_layout

\begin_layout Plain Layout

Left(x) |+| Right(y) |+| Left(z) == Left(x |+| z) == Left(x) |+| ( Right(y)
 |+| Left(z) )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A similar argument shows that the second implementation (
\begin_inset Quotes eld
\end_inset

take 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

) is also associative.
\end_layout

\begin_layout Standard
The implementation 
\begin_inset Quotes eld
\end_inset

take first
\begin_inset Quotes erd
\end_inset

 will select the first value whenever the types are mixed.
 We get:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

Left(x) |+| Left(y) |+| Right(z) == Left(x |+| y) == Left(x) |+| ( Left(y)
 |+| Right(z) )
\end_layout

\begin_layout Plain Layout

Left(x) |+| Right(y) |+| p == Left(x) == Left(x) |+| ( Right(y) |+| p )
    // Regardless of p.
\end_layout

\begin_layout Plain Layout

Right(x) |+| Left(y) |+| p == Right(x) == Right(x) |+| ( Left(y) |+| p )
   // Regardless of p.
\end_layout

\begin_layout Plain Layout

Right(x) |+| Right(y) |+| Left(z) == Right(x |+| y) == Right(x) |+| ( Right(y)
 |+| Left(z) )
\end_layout

\end_inset

The results are independent of the parentheses.
 The same applies to the 
\begin_inset Quotes eld
\end_inset

take last
\begin_inset Quotes erd
\end_inset

 implementation.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $A$
\end_inset

 is a semigroup and 
\begin_inset Formula $E$
\end_inset

 is any fixed type, are the types 
\begin_inset Formula $A\rightarrow E$
\end_inset

 and/or 
\begin_inset Formula $E\rightarrow A$
\end_inset

 semigroups? To create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance for 
\begin_inset Formula $E\rightarrow A$
\end_inset

 means to implement the type signature:
\begin_inset Formula 
\[
\text{Semigroup}^{A}\rightarrow\text{Semigroup}^{E\rightarrow A}=\left(A\times A\rightarrow A\right)\rightarrow\left(E\rightarrow A\right)\times\left(E\rightarrow A\right)\rightarrow E\rightarrow A\quad.
\]

\end_inset

An implementation that preserves information is:
\begin_inset Formula 
\[
\text{semigroupFunc}\triangleq f^{:A\times A\rightarrow A}\rightarrow g_{1}^{:E\rightarrow A}\times g_{2}^{:E\rightarrow A}\rightarrow e^{:E}\rightarrow f(g_{1}(e),g_{2}(e))\quad.
\]

\end_inset

This defines the new 
\begin_inset Formula $\oplus$
\end_inset

 operation by 
\begin_inset Formula $g_{1}\oplus g_{2}\triangleq e\rightarrow g_{1}(e)\oplus_{A}g_{2}(e)$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def semigroupFunc[E, A: Semigroup] = Semigroup[E => A] { case (g1, g2) =>
 e => g1(e) |+| g2(e) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the pipe notation, 
\begin_inset Formula $e\triangleright(f\oplus g)=f(e)\oplus_{A}g(e)$
\end_inset

.
 The associativity law holds for this operation:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & e\triangleright\left(\left(f\oplus g\right)\oplus h\right)=\left(e\triangleright(f\oplus g)\right)\oplus_{A}h(e)=f(e)\oplus_{A}g(e)\oplus_{A}h(e)\quad.\\
\text{right-hand side}:\quad & e\triangleright\left(f\oplus\left(g\oplus h\right)\right)=f(e)\oplus_{A}\left(e\triangleright(g\oplus h)\right)=f(e)\oplus_{A}g(e)\oplus_{A}h(e)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The type 
\begin_inset Formula $A\rightarrow E$
\end_inset

 only allows semigroup operations that discard the left or the right element:
 the type signature 
\begin_inset Formula $f^{:A\times A\rightarrow A}\rightarrow h_{1}^{:A\rightarrow E}\times h_{2}^{:A\rightarrow E}\rightarrow\text{???}^{:A\rightarrow E}$
\end_inset

 can be implemented only by discarding 
\begin_inset Formula $f$
\end_inset

 and one of 
\begin_inset Formula $h_{1}$
\end_inset

 or 
\begin_inset Formula $h_{2}$
\end_inset

.
 Either choice makes 
\begin_inset Formula $A\rightarrow E$
\end_inset

 into a trivial semigroup.
\end_layout

\begin_layout Standard
We have seen constructions that create new semigroups via products, co-products,
 and functions.
 Thus, any exponential-polynomial type expression built up from primitive
 types and/or existing semigroups is again a semigroup.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
A type 
\begin_inset Formula $T$
\end_inset

 defined by a recursive type equation 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 can have a semigroup instance when 
\begin_inset Formula $S^{A}$
\end_inset

 is any exponential-polynomial type expression built up from primitive types,
 products, co-products, and the type parameter 
\begin_inset Formula $A$
\end_inset

.
 The known semigroup constructions guarantee that a typeclass instance 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup[S[A]]
\end_layout

\end_inset

 can be created out of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup[A]
\end_layout

\end_inset

.
 This gives us a function:
\begin_inset Formula 
\[
\text{semigroupS}:\text{Semigroup}^{A}\rightarrow\text{Semigroup}^{S^{A}}\quad.
\]

\end_inset

Then a semigroup instance for 
\begin_inset Formula $T$
\end_inset

 is defined recursively as:
\begin_inset Formula 
\[
\text{semigroupT}\triangleq\text{semigroupS}\,(\text{semigroupT})\quad.
\]

\end_inset

The recursive definition will terminate as long as we implement it in code
 as an expanded function.
 The associativity law holds for the semigroup 
\begin_inset Formula $T$
\end_inset

 by induction, as shown at the end of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Eq-typeclass"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
Any type whatsoever can have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance.
 Since the instances have several inequivalent implementations, automatic
 derivation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instances is not often useful.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type signature to implement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, or other fixed type 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Semigroup}^{C}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product of semigroups 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Semigroup}^{A}\times\text{Semigroup}^{B}\rightarrow\text{Semigroup}^{A\times B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product of semigroups 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Semigroup}^{A}\times\text{Semigroup}^{B}\rightarrow\text{Semigroup}^{A+B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Function from another type 
\begin_inset Formula $E$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Semigroup}^{A}\rightarrow\text{Semigroup}^{E\rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Semigroup}^{A}\rightarrow\text{Semigroup}^{S^{A}}$
\end_inset

 where 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions producing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 typeclass.
\begin_inset CommandInset label
LatexCommand label
name "tab:Type-constructions-for-semigroup"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Monoids
\begin_inset CommandInset label
LatexCommand label
name "subsec:Monoids-constructions"

\end_inset


\end_layout

\begin_layout Standard
Since a monoid is a semigroup with a default value, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance is a value of type:
\begin_inset Formula 
\[
\text{Monoid}^{A}\triangleq\left(A\times A\rightarrow A\right)\times A\quad.
\]

\end_inset

For the binary operation 
\begin_inset Formula $A\times A\rightarrow A$
\end_inset

, we can re-use the results of structural analysis for semigroups.
 Additionally, we will need to verify that the default value satisfies monoid's
 identity laws.
 The results are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Fixed types
\end_layout

\begin_layout Standard
Each of the primitive types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, etc.) has a well-defined monoidal operation (addition or multiplication
 for numbers, concatenation for strings, and so on).
 The unit type, 
\begin_inset Formula $\bbnum 1$
\end_inset

, also has a monoid instance where all methods return the unit value 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
This construction works for semigroups but 
\emph on
not
\emph default
 for monoids: the 
\begin_inset Quotes eld
\end_inset

trivial
\begin_inset Quotes erd
\end_inset

 semigroup operations 
\begin_inset Formula $x\oplus y=x$
\end_inset

 and 
\begin_inset Formula $x\oplus y=y$
\end_inset

 are not compatible with monoid's identity laws.
 (e.g., with the definition 
\begin_inset Formula $x\oplus y=x$
\end_inset

, no default value 
\begin_inset Formula $e$
\end_inset

 could possibly satisfy the left identity law 
\begin_inset Formula $e\oplus y=y$
\end_inset

 because 
\begin_inset Formula $e\oplus y=e$
\end_inset

 for all 
\begin_inset Formula $y$
\end_inset

).
\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
For two monoids 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, a monoid instance for the product 
\begin_inset Formula $A\times B$
\end_inset

 is computed by:
\begin_inset Formula 
\[
\text{monoidPair}:\forall(A,B).\,\text{Monoid}^{A}\times\text{Monoid}^{B}\rightarrow\text{Monoid}^{A\times B}\quad.
\]

\end_inset

The empty value for the monoid 
\begin_inset Formula $A\times B$
\end_inset

 is 
\begin_inset Formula $e_{A\times B}\triangleq e_{A}\times e_{B}$
\end_inset

, the pair of empty values from the monoids 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 The new binary operation is defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:semigroup-product-operation-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as in the pair semigroup construction.
 We can now verify the new monoid's identity laws, assuming that they hold
 for the monoids 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
(a_{1}\times b_{1})\oplus(e_{A}\times e_{B}) & =(a_{1}\oplus_{A}e_{A})\times(b_{1}\oplus_{B}e_{B})=a_{1}\times b_{1}\quad,\\
(e_{A}\times e_{B})\oplus(a_{2}\times b_{2}) & =(e_{A}\oplus_{A}a_{2})\times(e_{B}\oplus_{B}b_{2})=a_{2}\times b_{2}\quad.
\end{align*}

\end_inset

An implementation in Scala is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidPair[A: Monoid, B: Monoid]: Monoid[(A, B)] = Monoid[(A, B)](
\end_layout

\begin_layout Plain Layout

  { case ((a1, b1),(a2, b2)) => (a1 |+| a2, b1 |+| b2) },
\end_layout

\begin_layout Plain Layout

  ( implicitly[Monoid[A]].empty, implicitly[Monoid[B]].empty )
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
A special case of a product construction is the 
\begin_inset Quotes eld
\end_inset

twisted product
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $S\times P$
\end_inset

 where 
\begin_inset Formula $S$
\end_inset

 is a semigroup that has an 
\series bold
action on
\series default
 
\begin_inset Formula $P$
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

action
\begin_inset Quotes erd
\end_inset

 is a function 
\begin_inset Formula $\alpha:S\rightarrow P\rightarrow P$
\end_inset

 such that 
\begin_inset Formula $\alpha(s_{1})\bef\alpha(s_{2})=\alpha(s_{1}\oplus s_{2})$
\end_inset

.
 The operation is defined as 
\begin_inset Formula 
\[
(s_{1}\times p_{1})\oplus(s_{2}\times p_{2})=(s_{1}\oplus_{S}s_{2})\times\alpha(s_{2})(p_{1})\quad.
\]

\end_inset

Examples of this construction are 
\begin_inset Formula $\left(A\rightarrow A\right)\times A$
\end_inset

 and 
\begin_inset Formula $\bbnum 2\times\left(\bbnum 1+A\right)$
\end_inset

.
 This cannot be made into a monoid since the information about 
\begin_inset Formula $p_{2}$
\end_inset

 is discarded.
 The associativity law holds because the first part of the pair is associative
 by assumption of semigroup 
\begin_inset Formula $S$
\end_inset

, and the second part of the pair is
\begin_inset Formula 
\[
\alpha(s_{2}\oplus_{S}s_{3})(p_{1})=\alpha(s_{3})(\alpha(s_{2})(p_{1}))\quad.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
For two monoids 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, how can we implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for 
\begin_inset Formula $A+B$
\end_inset

? We have seen four versions of the semigroup operation 
\begin_inset Formula $\oplus$
\end_inset

 for the type 
\begin_inset Formula $A+B$
\end_inset

.
 Independently of those, we need to define the empty element 
\begin_inset Formula $e_{A+B}$
\end_inset

, which must have type 
\begin_inset Formula $A+B$
\end_inset

.
 There are two possibilities: 
\begin_inset Formula 
\[
e_{A+B}\triangleq e_{A}+\bbnum 0^{:B}\quad\quad\text{ or }\quad\quad e_{A+B}\triangleq\bbnum 0^{:A}+e_{B}\quad.
\]

\end_inset

It remains to see which of the eight combinations will satisfy the monoid
 identity laws:
\begin_inset Formula 
\begin{align*}
\left(a+\bbnum 0\right)\oplus e_{A+B} & =a+\bbnum 0\quad,\quad\quad e_{A+B}\oplus\left(a+\bbnum 0\right)=a+\bbnum 0\quad,\\
\left(\bbnum 0+b\right)\oplus e_{A+B} & =\bbnum 0+b\quad,\quad\quad e_{A+B}\oplus\left(\bbnum 0+b\right)=\bbnum 0+b\quad.
\end{align*}

\end_inset

First choose 
\begin_inset Formula $e_{A+B}=e_{A}+\bbnum 0$
\end_inset

; the reasoning for the other case will be quite similar.
 The first line above:
\begin_inset Formula 
\[
\left(a+\bbnum 0\right)\oplus\left(e_{A}+\bbnum 0\right)=a+\bbnum 0\quad,\quad\quad\left(e_{A}+\bbnum 0\right)\oplus\left(a+\bbnum 0\right)=a+\bbnum 0\quad,
\]

\end_inset

will hold because all four versions of the operation 
\begin_inset Formula $\oplus$
\end_inset

 will reduce to 
\begin_inset Formula $\oplus_{A}$
\end_inset

 on values of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

.
 The second line, however, is compatible only with one version of the 
\begin_inset Formula $\oplus$
\end_inset

 operation, namely with 
\begin_inset Quotes eld
\end_inset

take 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
(a^{:A}+\bbnum 0)\oplus(\bbnum 0+b^{:B})=b\quad\quad\text{ and }\quad\quad(\bbnum 0+b^{:B})\oplus(a^{:A}+\bbnum 0)=b\quad.
\]

\end_inset

So, the co-product construction must choose one of the monoids, say 
\begin_inset Formula $B$
\end_inset

, as 
\begin_inset Quotes eld
\end_inset

preferred
\begin_inset Quotes erd
\end_inset

.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidEitherPreferB[A: Monoid, B: Monoid] = Monoid[Either[A, B]]( {
\end_layout

\begin_layout Plain Layout

  case (Left(a1), Left(a2))     => Left(a1 |+| a2)
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(b))      => Right(b) // 
\begin_inset Quotes eld
\end_inset

Take B
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout

  case (Right(b), Left(a))      => Right(b)
\end_layout

\begin_layout Plain Layout

  case (Right(b1), Right(b2))   => Right(b1 |+| b2)
\end_layout

\begin_layout Plain Layout

}, Left(implicitly[Monoid[A]].empty) )
\end_layout

\end_inset

Similarly, the choice 
\begin_inset Formula $e_{A+B}\triangleq\bbnum 0+e_{B}$
\end_inset

 forces us to choose the version 
\begin_inset Quotes eld
\end_inset

take 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 of the 
\begin_inset Formula $\oplus$
\end_inset

 operation.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
The semigroup construction for function types works also for monoids.
 Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show that the function type 
\begin_inset Formula $R\rightarrow A$
\end_inset

 is a lawful monoid for any type 
\begin_inset Formula $R$
\end_inset

 and any monoid 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Additionally, the function type 
\begin_inset Formula $R\rightarrow R$
\end_inset

 is a monoid for any type 
\begin_inset Formula $R$
\end_inset

 (even if 
\begin_inset Formula $R$
\end_inset

 is not a monoid).
 The operation 
\begin_inset Formula $\oplus$
\end_inset

 and the empty value are defined as 
\begin_inset Formula $f^{:R\rightarrow R}\oplus g^{:R\rightarrow R}\triangleq f\bef g$
\end_inset

 and 
\begin_inset Formula $e_{R\rightarrow R}\triangleq\text{id}^{R}$
\end_inset

.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidFunc1[R]: Monoid[R => R] = Monoid( (f, g) => f andThen g, identity
 )
\end_layout

\end_inset

The monoidal operation 
\begin_inset Formula $\oplus$
\end_inset

 is the forward function composition 
\begin_inset Formula $f\bef g$
\end_inset

, so the monoid laws for this operation are the identity and the associativity
 laws of function composition (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We could also use the backward function composition (
\begin_inset Formula $f\circ g$
\end_inset

) to define 
\begin_inset Formula $f\oplus g$
\end_inset

.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
Can we define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for a type 
\begin_inset Formula $T$
\end_inset

 defined by 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

, where 
\begin_inset Formula $S^{\bullet}$
\end_inset

 is some type constructor? As we have seen, products, co-products, and function
 type constructions preserve monoids.
 For any type built up via these constructions from monoids, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance can be derived.
 These constructions cover all exponential-polynomial types.
 So, let us consider an exponential-polynomial type constructor 
\begin_inset Formula $S^{A}$
\end_inset

 that contains a type parameter 
\begin_inset Formula $A$
\end_inset

, primitive types, and other known monoid types.
 For such type constructors 
\begin_inset Formula $S^{\bullet}$
\end_inset

, we will always be able to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidS
\end_layout

\end_inset

 that derives a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for 
\begin_inset Formula $S^{A}$
\end_inset

 from a monoid instance for 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
\text{monoidS}:\text{Monoid}^{A}\rightarrow\text{Monoid}^{S^{A}}\quad.
\]

\end_inset

A monoid instance for 
\begin_inset Formula $T$
\end_inset

 is then defined recursively by:
\begin_inset Formula 
\[
\text{monoidT}\triangleq\text{monoidS}\left(\text{monoidT}\right)\quad.
\]

\end_inset

As we saw before, the code for this definition will terminate only if we
 implement it as a recursive function.
 However, the type 
\begin_inset Formula $\text{Monoid}^{A}$
\end_inset

 is not a function type: it is a pair 
\begin_inset Formula $\left(A\times A\rightarrow A\right)\times A$
\end_inset

.
 To obtain a working implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidT
\end_layout

\end_inset

, we need to rewrite that type into an equivalent function type,
\begin_inset Formula 
\[
\text{Monoid}^{A}=\left(A\times A\rightarrow A\right)\times A\cong\left(A\times A\rightarrow A\right)\times\left(\bbnum 1\rightarrow A\right)\cong\left(\bbnum 1+A\times A\rightarrow A\right)\quad,
\]

\end_inset

where we used the known type equivalences 
\begin_inset Formula $A\cong\bbnum 1\rightarrow A$
\end_inset

 and 
\begin_inset Formula $\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)\cong A+B\rightarrow C$
\end_inset

.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Monoid[A](methods: Option[(A, A)] => A)
\end_layout

\end_inset

With this new definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass (and with the appropriate changes to the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidPair
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidEitherPreferB
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidFunc
\end_layout

\end_inset

), we can now implement the recursive construction.
\end_layout

\begin_layout Standard
To illustrate how that works, consider the exponential-polynomial type construct
or 
\begin_inset Formula $S^{\bullet}$
\end_inset

 defined as:
\begin_inset Formula 
\[
S^{A}\triangleq\left(\text{Int}+A\right)\times\text{Int}+\text{String}\times\left(A\rightarrow\left(A\rightarrow\text{Int}\right)\rightarrow A\right)\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A] = Either[(Either[Int, A], Int), (String, A => (A => Int) => A)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is clear that 
\begin_inset Formula $S^{A}$
\end_inset

 is built up from type constructions that preserve monoids at each step.
 So, we expect that the recursive type 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 is a monoid.
 We first implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidS
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidS[A](implicit ti: Monoid[A]): Monoid[S[A]] = {
\end_layout

\begin_layout Plain Layout

  implicit val m0 = monoidEitherPreferB[Int, A]
\end_layout

\begin_layout Plain Layout

  implicit val m1 = monoidPair[Either[Int, A], Int]
\end_layout

\begin_layout Plain Layout

  implicit val m2 = monoidFunc[A, A => Int]
\end_layout

\begin_layout Plain Layout

  implicit val m3 = monoidFunc[(A => Int) => A, A]
\end_layout

\begin_layout Plain Layout

  implicit val m4 = monoidPair[String, A => (A => Int) => A]
\end_layout

\begin_layout Plain Layout

  monoidEitherPreferB[(Either[Int, A], Int), (String, A => (A => Int) =>
 A)]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now use this function to define the recursive type 
\begin_inset Formula $T$
\end_inset

 and a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class T(s: S[T])
\end_layout

\begin_layout Plain Layout

def monoidT: Monoid[T] = Monoid[T] {
\end_layout

\begin_layout Plain Layout

  case None             => T(monoidS[T](monoidT).methods(None))
\end_layout

\begin_layout Plain Layout

  case Some((t1, t2))   => T(monoidS[T](monoidT).methods(Some(t1.s, t2.s)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test this code, create a value of type 
\begin_inset Formula $T$
\end_inset

 and perform a computation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t = T(Right((
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, t => f => T(Left((Left(f(t)), 10))))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t |+| t
\end_layout

\begin_layout Plain Layout

res0: T = T(Right((aa,<function1>)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another way of implementing the recursive construction is to write the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

.
 Although the code is longer, it is easier to read.
 The recursive instance is implemented by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidT: Monoid[T] = new Monoid[T] {
\end_layout

\begin_layout Plain Layout

  def empty: T = T(monoidS[T](monoidT).empty)   // This must be a `def empty`,
 not a `val empty`.
\end_layout

\begin_layout Plain Layout

  def combine: (T, T) => T = (x, y) => T(monoidS[T](monoidT).combine(x.s,
 y.s))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

 The recursive definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidT
\end_layout

\end_inset

 terminates because the methods of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 are declared as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 (not as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

).
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidS
\end_layout

\end_inset

 remains the same; we need to rewrite 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidPair
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidEitherPreferB
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidFunc
\end_layout

\end_inset

 to accommodate the new definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass.
 The full code is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Implementation-of-Monoid-typeclass-with-trait"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The monoid laws hold for the recursive instances by induction (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Eq-typeclass"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "frame=single,fillcolor={\color{black}},framesep={0.2mm},framexleftmargin=2mm,framexrightmargin=2mm,framextopmargin=2mm,framexbottommargin=2mm"
inline false
status open

\begin_layout Plain Layout

trait Monoid[T] {
\end_layout

\begin_layout Plain Layout

  def empty: T
\end_layout

\begin_layout Plain Layout

  def combine: (T, T) => T
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit val monoidInt: Monoid[Int] = new Monoid[Int] {
\end_layout

\begin_layout Plain Layout

  def empty: Int = 0
\end_layout

\begin_layout Plain Layout

  def combine: (Int, Int) => Int = _ + _
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit val monoidString: Monoid[String] = new Monoid[String] {
\end_layout

\begin_layout Plain Layout

  def empty: String = 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  def combine: (String, String) => String = _ + _
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class MonoidOps[T: Monoid](t: T) {
\end_layout

\begin_layout Plain Layout

  def |+|(a: T): T = implicitly[Monoid[T]].combine(t, a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def monoidPair[A: Monoid, B: Monoid]: Monoid[(A, B)] = new Monoid[(A, B)]
 {
\end_layout

\begin_layout Plain Layout

  def empty: (A, B) = (implicitly[Monoid[A]].empty, implicitly[Monoid[B]].empty)
\end_layout

\begin_layout Plain Layout

  def combine: ((A, B), (A, B)) => (A, B) = {
\end_layout

\begin_layout Plain Layout

    case ((a1, b1), (a2, b2)) => (a1 |+| a2, b1 |+| b2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def monoidEitherPreferB[A: Monoid, B: Monoid] = new Monoid[Either[A, B]]
 {
\end_layout

\begin_layout Plain Layout

  def empty: Either[A, B] = Left(implicitly[Monoid[A]].empty)
\end_layout

\begin_layout Plain Layout

  def combine: (Either[A, B], Either[A, B]) => Either[A, B] = {
\end_layout

\begin_layout Plain Layout

    case (Left(a1), Left(a2))     => Left(a1 |+| a2)
\end_layout

\begin_layout Plain Layout

    case (Left(a), Right(b))      => Right(b) // "Take B".
\end_layout

\begin_layout Plain Layout

    case (Right(b), Left(a))      => Right(b)
\end_layout

\begin_layout Plain Layout

    case (Right(b1), Right(b2))   => Right(b1 |+| b2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def monoidFunc[A: Monoid, E] = new Monoid[E => A] {
\end_layout

\begin_layout Plain Layout

  def empty: E => A = _ => implicitly[Monoid[A]].empty
\end_layout

\begin_layout Plain Layout

  def combine: (E => A, E => A) => E => A = {
\end_layout

\begin_layout Plain Layout

    case (f, g) => e => f(e) |+| g(e)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// This type constructor will be used below to define a recursive type T.
\end_layout

\begin_layout Plain Layout

type S[A] = Either[(Either[Int, A], Int), (String, A => (A => Int) => A)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// If we have a Monoid instance for A, we can get a Monoid instance for
 S[A].
\end_layout

\begin_layout Plain Layout

def monoidS[A](implicit ti: Monoid[A]): Monoid[S[A]] = {
\end_layout

\begin_layout Plain Layout

  implicit val m0 = monoidEitherPreferB[Int, A]
\end_layout

\begin_layout Plain Layout

  implicit val m1 = monoidPair[Either[Int, A], Int]
\end_layout

\begin_layout Plain Layout

  implicit val m2 = monoidFunc[A, A => Int]
\end_layout

\begin_layout Plain Layout

  implicit val m3 = monoidFunc[(A => Int) => A, A]
\end_layout

\begin_layout Plain Layout

  implicit val m4 = monoidPair[String, A => (A => Int) => A]
\end_layout

\begin_layout Plain Layout

  monoidEitherPreferB[(Either[Int, A], Int), (String, A => (A => Int) =>
 A)]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Define a recursive type T and a Monoid instance for it.
\end_layout

\begin_layout Plain Layout

final case class T(s: S[T])
\end_layout

\begin_layout Plain Layout

implicit def monoidT: Monoid[T] = new Monoid[T] {
\end_layout

\begin_layout Plain Layout

  def empty: T = T(monoidS[T](monoidT).empty) // Here, `val empty` will cause
 a StackOverflowError.
\end_layout

\begin_layout Plain Layout

  def combine: (T, T) => T = (x, y) => T(monoidS[T](monoidT).combine(x.s,
 y.s))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

val t = T(Right(("abc", t => f => T(Left((Left(f(t)), 10))))))
\end_layout

\begin_layout Plain Layout

val e = implicitly[Monoid[T]].empty
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t |+| t |+| e   // Expect to see the string 
\begin_inset Quotes eld
\end_inset

abcabc
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout

res0: T = T(Right((abcabc,<function1>)))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementing a recursive instance of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Implementation-of-Monoid-typeclass-with-trait"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance can be implemented, in at least one way, for 
\emph on
any
\emph default
 exponential-polynomial type
\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset

 expression (including recursive types) built from primitive types and other
 monoids.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
There exist other type constructions that work for monoids in special cases.
 One example is the 
\begin_inset Quotes eld
\end_inset

twisted product
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $P\times Q$
\end_inset

 where 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are monoids and additionally 
\begin_inset Formula $P$
\end_inset

 has an 
\series bold
action on
\series default
 
\begin_inset Formula $Q$
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

action
\begin_inset Quotes erd
\end_inset

 is a function 
\begin_inset Formula $\alpha:P\rightarrow Q\rightarrow Q$
\end_inset

 obeying the special composition law, 
\begin_inset Formula $\alpha(p_{1})\bef\alpha(p_{2})=\alpha(p_{1}\oplus p_{2})$
\end_inset

.
 The monoidal operation is defined by
\begin_inset Formula 
\[
(p_{1}\times q_{1})\oplus(p_{2}\times q_{2})=(p_{1}\oplus p_{2})\times(\alpha(p_{2})(q_{1})\oplus q_{2})\quad.
\]

\end_inset

 Examples of this construction are twisted products 
\begin_inset Formula $\left(A\rightarrow A\right)\times A$
\end_inset

 and 
\begin_inset Formula $\bbnum 2\times\left(\bbnum 1+A\right)$
\end_inset

.
 — Not sure how useful this is, and what additional properties we need.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type signature to implement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, or primitive types
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Monoid}^{\bbnum 1}$
\end_inset

, 
\begin_inset Formula $\text{Monoid}^{\text{Int}}$
\end_inset

, etc.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product of monoids 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Monoid}^{A}\times\text{Monoid}^{B}\rightarrow\text{Monoid}^{A\times B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product of monoid 
\begin_inset Formula $A$
\end_inset

 and semigroup 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Monoid}^{A}\times\text{Semigroup}^{B}\rightarrow\text{Monoid}^{A+B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Function from another type 
\begin_inset Formula $E$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Monoid}^{A}\rightarrow\text{Monoid}^{E\rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Monoid}^{A}\rightarrow\text{Monoid}^{S^{A}}$
\end_inset

 where 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions producing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass.
\begin_inset CommandInset label
LatexCommand label
name "tab:Type-constructions-for-monoid"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pointed functors: motivation and laws
\begin_inset CommandInset label
LatexCommand label
name "subsec:Pointed-functors-motivation-equivalence"

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Typeclasses-for-type-constructors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed how to implement typeclasses for type 
\emph on
constructors
\emph default
, e.g., the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass.
 Typeclass instances in such cases often contain a nested type quantifier
 such as 
\begin_inset Formula $\forall A.\left(...\right)$
\end_inset

, so the implementation needs to use Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 methods inside.
 We will now look at some examples of typeclasses that add further methods
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

.
 Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 performed a structural analysis of functors, which we will extend to the
 new typeclasses.
\end_layout

\begin_layout Standard
The first typeclass is a 
\begin_inset Quotes eld
\end_inset

pointed
\begin_inset Quotes erd
\end_inset

 functor.
 A functor type 
\begin_inset Formula $F^{T}$
\end_inset

 represents, in a generalized sense, 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

 values of type 
\begin_inset Formula $T$
\end_inset

.
 A frequently used operation is to create a 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

 value of type 
\begin_inset Formula $F^{T}$
\end_inset

 out of a single given value of type 
\begin_inset Formula $T$
\end_inset

.
 This operation, usually called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 in Scala libraries, is implemented as a function with a type signature:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[A]: A => F[A]
\end_layout

\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The code notation for this function is 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

, and the type signature is written as 
\begin_inset Formula $\text{pu}_{F}:\forall A.\,A\rightarrow F^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Some examples of pointed functors in Scala are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

.
 Each of these type constructors has a method that 
\begin_inset Quotes eld
\end_inset

wraps
\begin_inset Quotes erd
\end_inset

 a given single value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: Option[Int] = Some(10)                     // A non-empty option
 that holds a value.
\end_layout

\begin_layout Plain Layout

val y: List[String] = List(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

)                 // A list that holds a single value.
\end_layout

\begin_layout Plain Layout

val z: Try[Int] = Success(200)                    // A value computed without
 errors.
\end_layout

\begin_layout Plain Layout

val f: Future[String] = Future.successful(
\begin_inset Quotes eld
\end_inset

OK
\begin_inset Quotes erd
\end_inset

)   // A `Future` value that is already available.
\end_layout

\end_inset

As we can see, 
\begin_inset Quotes eld
\end_inset

wrapping a single value
\begin_inset Quotes erd
\end_inset

 means a different thing for each of the type constructors.
 Although the relevant methods of these type constructors are not called
 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, we can create a PTVF 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure[F]
\end_layout

\end_inset

 that would be defined only for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 that can 
\begin_inset Quotes eld
\end_inset

wrap
\begin_inset Quotes erd
\end_inset

 a single value.
 Such type constructors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 are called 
\begin_inset Quotes eld
\end_inset


\series bold
pointed
\series default

\begin_inset Quotes erd
\end_inset

.
 We may define the typeclass
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Pointed
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 via this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Pointed[F[_]] { def pure[A]: A => F[A] }
\end_layout

\end_inset

Now we can implement instances of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclass for some functors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val pointedOption = new Pointed[Option] { def pure[A]: A => Option[A]
 = x => Some(x)    }
\end_layout

\begin_layout Plain Layout

implicit val pointedList   = new Pointed[List]   { def pure[A]: A => List[A]
   = x => List(x)    }
\end_layout

\begin_layout Plain Layout

implicit val pointedTry    = new Pointed[Try]    { def pure[A]: A => Try[A]
    = x => Success(x) }
\end_layout

\end_inset

The PTVF 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 can be defined and used like this:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "41col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[F[_]: Pointed, A](x: A): F[A] =
\end_layout

\begin_layout Plain Layout

  implicitly[Pointed[F]].pure(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> pure[Option, Int](123)
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(123)
\end_layout

\end_inset


\begin_inset VSpace -95baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
When a pointed type constructor 
\begin_inset Formula $F$
\end_inset

 is a functor, we may use both the functor's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method.
 Do these two methods need to be compatible in some way? If we 
\begin_inset Quotes eld
\end_inset

wrap
\begin_inset Quotes erd
\end_inset

 a value 
\begin_inset Formula $123$
\end_inset

 in a 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 and then apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(x => x + 1)
\end_layout

\end_inset

, we expect to obtain a list containing 
\begin_inset Formula $124$
\end_inset

; any other result would break our intuition about 
\begin_inset Quotes eld
\end_inset

wrapping
\begin_inset Quotes erd
\end_inset

.
 We can generalize this situation to an arbitrary value 
\begin_inset Formula $x^{:A}$
\end_inset

 wrapped using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 applied to the wrapped value via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "41col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

pure(x).map(f)    //   $
\backslash
color{dkgreen}
\backslash
text{pu}_{F}(x)
\backslash
triangleright
\backslash
, 
\backslash
scriptstyle{f^{
\backslash
uparrow F}}$
\end_layout

\end_inset


\begin_inset VSpace -80baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We expect that the result should be the same as a wrapped 
\begin_inset Formula $f(x)$
\end_inset

.
 This expectation can be formulated as a law, called the 
\series bold
naturality law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
pure
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

; it must hold for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pure(x).map(f) == pure(f(x))
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{pu}_{F}(x)\triangleright f^{\uparrow F}=\text{pu}_{F}(f(x))\quad.
\]

\end_inset

In the 
\begin_inset Formula $\triangleright$
\end_inset

-notation, this law is 
\begin_inset Formula $x\triangleright\text{pu}_{F}\triangleright f^{\uparrow F}=x\triangleright f\triangleright\text{pu}_{F}$
\end_inset

 or equivalently 
\begin_inset Formula $x\triangleright\text{pu}_{F}\bef f^{\uparrow F}=x\triangleright f\bef\text{pu}_{F}$
\end_inset

.
 Since both sides of the law are functions applied to an arbitrary value
 
\begin_inset Formula $x^{:A}$
\end_inset

, we can omit 
\begin_inset Formula $x$
\end_inset

 and write:
\begin_inset Formula 
\begin{equation}
\text{pu}_{F}\bef f^{\uparrow F}=f\bef\text{pu}_{F}\quad.\label{eq:naturality-law-of-pure}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "28col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -420baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{4.0pc}A\ar[r]\sp(0.5){\text{pu}_{F}}\ar[d]\sb(0.45){f} & F^{A}\ar[d]\sp(0.45){f^{\uparrow F}}\\
B\ar[r]\sp(0.5){\text{pu}_{F}} & F^{B}
}
\]

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -190baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
This motivates the following definition: A functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pointed functor|textit
\end_layout

\end_inset


\series bold
pointed
\series default
 if there exists a fully parametric function 
\begin_inset Formula $\text{pu}_{F}:\forall A.\,A\rightarrow F^{A}$
\end_inset

 satisfying the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for any function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
\end_layout

\begin_layout Standard
It turns out that we can avoid checking the naturality law of pointed functors
 if we use a trick: reduce 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 to a simpler but equivalent form for which the law is satisfied automatically.
\end_layout

\begin_layout Standard
Both sides of the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are functions of type 
\begin_inset Formula $A\rightarrow F^{B}$
\end_inset

.
 The trick is to choose 
\begin_inset Formula $A=\bbnum 1$
\end_inset

 (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type) and 
\begin_inset Formula $f^{:\bbnum 1\rightarrow B}\triangleq(\_\rightarrow b)$
\end_inset

, a constant function returning some fixed value 
\begin_inset Formula $b^{:B}$
\end_inset

.
 Both sides of the naturality law may then be applied to the unit value
 
\begin_inset Formula $1$
\end_inset

 and must evaluate to the same result:
\begin_inset Formula 
\[
1\triangleright\text{pu}_{F}\triangleright(\_\rightarrow b)^{\uparrow F}=1\triangleright f\triangleright\text{pu}_{F}\quad.
\]

\end_inset

Since 
\begin_inset Formula $1\triangleright f=f(1)=b$
\end_inset

, we find:
\begin_inset Formula 
\begin{equation}
\text{pu}_{F}(1)\triangleright(\_\rightarrow b)^{\uparrow F}=\text{pu}_{F}(b)\quad.\label{eq:pu-via-wu}
\end{equation}

\end_inset

The naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

) applies to all types 
\begin_inset Formula $A,B$
\end_inset

 and to any function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Thus, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pu-via-wu"
plural "false"
caps "false"
noprefix "false"

\end_inset

) must apply to an arbitrary value 
\begin_inset Formula $b^{:B}$
\end_inset

 for any type 
\begin_inset Formula $B$
\end_inset

.
 That formula expresses the function 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 through one value 
\begin_inset Formula $\text{pu}_{F}(1)$
\end_inset

 of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

.
 This value can be viewed as a 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Index idx
status open

\begin_layout Plain Layout
wrapped@
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 value.
 
\end_layout

\begin_layout Standard
To perform the same derivation in Scala syntax, we may write
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val one: Unit = ()
\end_layout

\begin_layout Plain Layout

val f: Unit => B = { _ => b }
\end_layout

\begin_layout Plain Layout

pure(one).map(f) == pure(f(one)) == pure(b)    // Because f(one) == b.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It follows that if 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 satisfies the naturality law then a single 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value of that function, 
\begin_inset Formula $\text{pu}_{F}(1)$
\end_inset

, is sufficient to recover the entire function 
\begin_inset Formula $\text{pu}_{F}(b)$
\end_inset

 by using this code:
\begin_inset Formula 
\[
\text{pu}_{F}(b)\triangleq\text{pu}_{F}(1)\triangleright(\_\rightarrow b)^{\uparrow F}\quad
\]

\end_inset

So, given just a 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value (denoted 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

) of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

, we can define a new function 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "46col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[A](x: A): F[A] = wu.map { _ => x }
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset Formula 
\begin{equation}
\text{pu}_{F}^{:A\rightarrow F^{A}}\triangleq x^{:A}\rightarrow\text{wu}_{F}\triangleright(\_\rightarrow x)^{\uparrow F}\quad.\label{eq:pu-via-wu-def}
\end{equation}

\end_inset

Does this function satisfy the naturality law with respect to an arbitrary
 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

? It does:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }x\triangleright f\bef\text{pu}_{F}:\quad & x\triangleright\text{pu}_{F}\bef f^{\uparrow F}\\
\text{definition of }\text{pu}_{F}:\quad & =\text{wu}_{F}\triangleright(\_\rightarrow x)^{\uparrow F}\bef f^{\uparrow F}\\
\text{functor composition law of }F:\quad & =\text{wu}_{F}\triangleright(\left(\_\rightarrow x\right)\bef f)^{\uparrow F}\\
\text{compute function composition}:\quad & =\text{wu}_{F}\triangleright(\_\rightarrow f(x))^{\uparrow F}\\
\text{definition of }\text{pu}_{F}:\quad & =\text{pu}_{F}(f(x))\\
\triangleright\text{-notation}:\quad & =x\triangleright f\triangleright\text{pu}_{F}=x\triangleright f\bef\text{pu}_{F}\quad.
\end{align*}

\end_inset

Applied to the unit value, this new function gives 
\begin_inset Formula $\text{pu}_{F}(1)=\text{wu}_{F}$
\end_inset

 because:
\begin_inset Formula 
\begin{align*}
\triangleright\text{-notation}:\quad & \text{pu}_{F}(1)=1\triangleright\text{pu}_{F}\\
\text{definition of }\text{pu}_{F}\text{ via }\text{wu}_{F}:\quad & =\text{wu}_{F}\triangleright(\_\rightarrow1)^{\uparrow F}\\
\text{the function }(\_\rightarrow1)\text{ is the identity function }\text{id}^{:\bbnum 1\rightarrow\bbnum 1}:\quad & =\text{wu}_{F}\triangleright\text{id}^{\uparrow F}\\
\text{functor identity law of }F:\quad & =\text{wu}_{F}\triangleright\text{id}=\text{wu}_{F}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To summarize our results, we can say that for any functor 
\begin_inset Formula $F$
\end_inset

:
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $F$
\end_inset

 is a lawful pointed functor, its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method satisfies Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pu-via-wu-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) where 
\begin_inset Formula $\text{wu}_{F}\triangleq\text{pu}_{F}(1)$
\end_inset

 is a fixed 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

.
\end_layout

\begin_layout Itemize
If any 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value 
\begin_inset Formula $\text{wu}_{F}:F^{\bbnum 1}$
\end_inset

 is given, we may define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pu-via-wu-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and make the functor 
\begin_inset Formula $F$
\end_inset

 into a lawful pointed functor; the naturality law will be satisfied automatical
ly.
 The value 
\begin_inset Formula $\text{pu}_{F}(1)$
\end_inset

 will be equal to the originally given value 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

.
\end_layout

\begin_layout Standard
So, the types of 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 and 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 are
\series bold
 equivalent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence
\end_layout

\end_inset

: each one can be converted into the other and back without loss of information.
 We may define a pointed functor equivalently as a functor with a chosen
 value 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

.
 When reasoning about pointed functors, it is simpler to use the definition
 via the 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 because it has a simpler type and no laws.
 When writing code, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method is more convenient.
\end_layout

\begin_layout Subsection
Pointed functors: structural analysis
\begin_inset CommandInset label
LatexCommand label
name "subsec:Pointed-functors:-structural-analysis"

\end_inset


\end_layout

\begin_layout Standard
To perform structural analysis, we begin with the known functor-building
 constructions from Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and impose an additional requirement that a 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value 
\begin_inset Formula $\text{wu}_{F}:F^{\bbnum 1}$
\end_inset

 should exist.
 As we have seen in the previous section, no additional laws need to be
 checked.
 The results are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-pointed-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The typeclass can be defined by a simpler code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Pointed[F[_]](wu: F[Unit])
\end_layout

\begin_layout Plain Layout

def pure[F[_]: Pointed : Functor, A](a: A): F[A] = implicitly[Pointed[F]].wu.map(_
 => a)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

 has several distinct values, the choice of 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 is application-dependent.
 E.g., if 
\begin_inset Formula $F\triangleq\text{List}$
\end_inset

, the type 
\begin_inset Formula $\text{List}^{\bbnum 1}$
\end_inset

 has values such as an empty list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Unit]()
\end_layout

\end_inset

, a list of length 
\begin_inset Formula $1$
\end_inset

: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(())
\end_layout

\end_inset

, a list of length 
\begin_inset Formula $2$
\end_inset

: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List((), ())
\end_layout

\end_inset

, and so on.
 Each of these choices gives a valid 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 instance for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor.
 It is up to the programmer to choose the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 instance that will be useful for the application at hand.
 In the case of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, the standard choice 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wu == List(())
\end_layout

\end_inset

 and correspondingly 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(x) = List(x)
\end_layout

\end_inset

 is motivated by the usage of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor to represent a choice of possibilities, e.g., in a search problem;
 then the 
\begin_inset Quotes eld
\end_inset

pure
\begin_inset Quotes erd
\end_inset

 list represents the situation with only one possibility.
\end_layout

\begin_layout Paragraph
Nameless type-to-type functions
\end_layout

\begin_layout Standard
To implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclass instances for the following constructions, we need to use some
 advanced syntax features of Scala.
 In the previous sections, we wrote PTVFs parameterized by a type built
 out of other types, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidPair[A: Monoid, B: Monoid]: Monoid[(A, B)] = ???
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidPair
\end_layout

\end_inset

 creates a typeclass instance for the type 
\begin_inset Formula $A\times B$
\end_inset

, which is built out of the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 In Scala, the typeclass instance is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid[(A, B)]
\end_layout

\end_inset

.
 The analog for type constructors is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed[L]
\end_layout

\end_inset

 where the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 is defined by the type alias:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type L[A] = (F[A], G[A])
\end_layout

\end_inset

However, the following declaration of the analogous function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pointedPair
\end_layout

\end_inset

 is invalid in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedPair[F[_]: Pointed, G[_]: Pointed]: Pointed[L]     // Does not
 work in Scala.
\end_layout

\end_inset

It is not possible to use the type alias 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 within this function declaration, because the type alias needs to use the
 type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

 that are defined only within the type signature of the function.
 To achieve that, we would need somehow to insert a new type alias declaration
 within the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pointedPair
\end_layout

\end_inset

, but the syntax of Scala does not support that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedPair[F[_]: Pointed, G[_]: Pointed]: (            // Not a valid
 Scala syntax.
\end_layout

\begin_layout Plain Layout

    type L[A] = (F[A], G[A]) // Temporarily define a type constructor L,
 and now use it:
\end_layout

\begin_layout Plain Layout

    Pointed[L] )
\end_layout

\end_inset

The return type is required to be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed[L]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 needs to be a type expression that defines a type constructor, i.e., a type-to-ty
pe function with a 
\emph on
single
\emph default
 type parameter.
 Writing a type alias with parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type L[F[_], G[_], A] = (F[A], G[A])
\end_layout

\begin_layout Plain Layout

def pointedPair[F[_]: Pointed, G[_]: Pointed]: Pointed[L[F, G]]    // Still
 does not work.
\end_layout

\end_inset

will not help because the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[F, G]
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed[L[F, G]]
\end_layout

\end_inset

 is not a valid type constructor with one type parameter.
 We cannot define a new type name (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

) within the type signature; what we need is a 
\emph on
nameless
\emph default
 type-to-type function (i.e., a nameless type constructor).
\end_layout

\begin_layout Standard
The special Scala plugin called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
kind@
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/typelevel/kind-projector"
target "https://github.com/typelevel/kind-projector"
literal "false"

\end_inset


\end_layout

\end_inset

 adds syntax for nameless type constructors.
 The syntax is similar to defining a nameless function: for instance, the
 pair functor 
\begin_inset Formula $F^{\bullet}\times G^{\bullet}$
\end_inset

 is defined as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Lambda[X => (F[X], G[X])]
\end_layout

\end_inset

.
 Such type expressions can be understood as nameless
\begin_inset Index idx
status open

\begin_layout Plain Layout
nameless type-to-type function
\end_layout

\end_inset

 type-to-type functions.
 When using the 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin, the syntax for defining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pointedPair
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedPair[F[_]: Pointed, G[_]: Pointed]: Pointed[Lambda[X => (F[X],
 G[X])]] = ???
\end_layout

\end_inset

Scala 3 will support a shorter syntax for nameless type-to-type functions,
 e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[X] => (F[X], G[X])
\end_layout

\end_inset

.
 We will use the 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 syntax in this book's code examples.
\end_layout

\begin_layout Paragraph
Fixed types
\end_layout

\begin_layout Standard
A constant functor 
\begin_inset Formula $\text{Const}^{Z,\bullet}$
\end_inset

 is defined as 
\begin_inset Formula $\text{Const}^{Z,A}\triangleq Z$
\end_inset

, where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
 A 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value is thus also a value of type 
\begin_inset Formula $Z$
\end_inset

.
 Since we cannot produce values of an arbitrary type 
\begin_inset Formula $Z$
\end_inset

 from scratch, the constant functor is not pointed in general.
 The constant functor 
\emph on
will
\emph default
 be pointed when there exists a known value of type 
\begin_inset Formula $Z$
\end_inset

.
 Examples are 
\begin_inset Formula $Z=\bbnum 1$
\end_inset

 or 
\begin_inset Formula $Z=\bbnum 1+U$
\end_inset

 (where 
\begin_inset Formula $U$
\end_inset

 is an arbitrary type).
 If we know that 
\begin_inset Formula $Z$
\end_inset

 is equivalent to 
\begin_inset Formula $\bbnum 1+U$
\end_inset

, we will be able to produce a value of type 
\begin_inset Formula $Z$
\end_inset

 as 
\begin_inset Formula $1+\bbnum 0^{:U}$
\end_inset

.
 In that case, we set 
\begin_inset Formula $\text{wu}_{\text{Const}^{Z,\bullet}}=1+\bbnum 0^{:U}$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Const[Z, A] = Z
\end_layout

\begin_layout Plain Layout

def pointedOpt[U]: Pointed[Lambda[X => Const[Option[U], X]]] = Pointed(None:
 Const[Option[U], Unit])
\end_layout

\end_inset

Other cases are types such as 
\begin_inset Formula $Z=\text{Int}$
\end_inset

, 
\begin_inset Formula $Z=\text{String}$
\end_inset

, etc., that have well-known 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 values.
\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
The identity functor 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

 is pointed since 
\begin_inset Formula $\text{Id}^{\bbnum 1}=\bbnum 1$
\end_inset

, and we can set 
\begin_inset Formula $\text{wu}_{\text{Id}}=1$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Id[A] = A
\end_layout

\begin_layout Plain Layout

def pointedId: Pointed[Id] = Pointed[Id](())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The other functor constructions that work by setting type parameters are
 functor compositions.
 If 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are two functors or two contrafunctors then 
\begin_inset Formula $F\circ G$
\end_inset

 is a functor.
 The functor 
\begin_inset Formula $F\circ G$
\end_inset

 is pointed when we can create a value of type 
\begin_inset Formula $F^{G^{\bbnum 1}}$
\end_inset

.
 If both 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are pointed, we can apply 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method to 
\begin_inset Formula $\text{wu}_{G}:G^{\bbnum 1}$
\end_inset

 and obtain a value of type 
\begin_inset Formula $F^{G^{\bbnum 1}}$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedFoG[F[_]: Pointed : Functor, G[_]: Pointed]: Pointed[Lambda[X
 => F[G[X]]]]
\end_layout

\begin_layout Plain Layout

  = Pointed[Lambda[X => F[G[X]]]](pure[F, G[Unit]](implicitly[Pointed[G]].wu))
     
\end_layout

\end_inset

The case when 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are contrafunctors requires us to assume that 
\begin_inset Formula $F$
\end_inset

 belongs to the 
\begin_inset Quotes eld
\end_inset

pointed contrafunctor
\begin_inset Quotes erd
\end_inset

 typeclass (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
 A pointed contrafunctor has a 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

, which can be transformed into 
\begin_inset Formula $F^{A}$
\end_inset

 for any type 
\begin_inset Formula $A$
\end_inset

 by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 with a constant function 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cpure[F[_]: Pointed : Contrafunctor, A]: F[A] = implicitly[Pointed[F]].wu.cmap
(_ => ())
\end_layout

\end_inset

In this way, we can create a value of type 
\begin_inset Formula $F^{G^{\bbnum 1}}$
\end_inset

.
 The contrafunctor 
\begin_inset Formula $G$
\end_inset

 does not need to be pointed.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedCFoG[F[_]: Pointed : Contrafunctor, G[_]]: Pointed[Lambda[X =>
 F[G[X]]]] =
\end_layout

\begin_layout Plain Layout

  Pointed[Lambda[X => F[G[X]]]](cpure[F, G[Unit]])
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are two pointed functors, is the functor product 
\begin_inset Formula $L^{A}\triangleq F^{A}\times G^{A}$
\end_inset

 a pointed functor? We need to produce a value 
\begin_inset Formula $\text{wu}_{L}:F^{\bbnum 1}\times G^{\bbnum 1}$
\end_inset

, and we have values 
\begin_inset Formula $\text{wu}_{F}:F^{\bbnum 1}$
\end_inset

 and 
\begin_inset Formula $\text{wu}_{G}:G^{\bbnum 1}$
\end_inset

.
 It is clear that we must set 
\begin_inset Formula $\text{wu}_{L}=\text{wu}_{F}\times\text{wu}_{G}$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedFxG[F[_]: Pointed, G[_]: Pointed]: Pointed[Lambda[X => (F[X],G[X])]]
 =
\end_layout

\begin_layout Plain Layout

  Pointed[Lambda[X => (F[X],G[X])]]((implicitly[Pointed[F]].wu, implicitly[Pointe
d[G]].wu))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are two pointed functors, is the functor co-product 
\begin_inset Formula $L^{A}\triangleq F^{A}+G^{A}$
\end_inset

 a pointed functor? We need to produce a value 
\begin_inset Formula $\text{wu}_{L}:F^{\bbnum 1}+G^{\bbnum 1}$
\end_inset

, and we have values 
\begin_inset Formula $\text{wu}_{F}:F^{\bbnum 1}$
\end_inset

 and 
\begin_inset Formula $\text{wu}_{G}:G^{\bbnum 1}$
\end_inset

.
 There are two choices, 
\begin_inset Formula $\text{wu}_{L}=\text{wu}_{F}+\bbnum 0^{:G^{\bbnum 1}}$
\end_inset

 and 
\begin_inset Formula $\text{wu}_{L}=\bbnum 0^{:F^{\bbnum 1}}+\text{wu}_{G}$
\end_inset

, both making 
\begin_inset Formula $L^{\bullet}$
\end_inset

 a pointed functor.
 
\end_layout

\begin_layout Standard
It is sufficient if just 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a pointed functor: 
\begin_inset Formula $\text{wu}_{L}\triangleq\text{wu}_{F}+\bbnum 0^{:G^{\bbnum 1}}$
\end_inset

 is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclass instance for 
\begin_inset Formula $F^{\bullet}+G^{\bullet}$
\end_inset

, even if 
\begin_inset Formula $G^{\bullet}$
\end_inset

 is not pointed.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedEitherFG[F[_]: Pointed, G[_]]: Pointed[Lambda[X => Either[F[X],G[X]]]
] =
\end_layout

\begin_layout Plain Layout

  Pointed[Lambda[X => Either[F[X],G[X]]]](Left(implicitly[Pointed[F]].wu))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $C$
\end_inset

 is any contrafunctor and 
\begin_inset Formula $F$
\end_inset

 is a pointed functor, the functor 
\begin_inset Formula $L^{A}\triangleq C^{A}\rightarrow F^{A}$
\end_inset

 will be pointed if we can produce a value 
\begin_inset Formula $\text{wu}_{L}:C^{\bbnum 1}\rightarrow F^{\bbnum 1}$
\end_inset

.
 We already have a value 
\begin_inset Formula $\text{wu}_{F}:F^{\bbnum 1}$
\end_inset

, and we cannot use a value of type 
\begin_inset Formula $C^{\bbnum 1}$
\end_inset

 with a general contrafunctor 
\begin_inset Formula $C$
\end_inset

.
 So, we have to set 
\begin_inset Formula $\text{wu}_{L}\triangleq(\_\rightarrow\text{wu}_{F})$
\end_inset

.
 This makes 
\begin_inset Formula $L$
\end_inset

 into a pointed functor.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedFuncFG[F[_]: Pointed, C[_]]: Pointed[Lambda[X => C[X] => F[X]]]
 =
\end_layout

\begin_layout Plain Layout

  Pointed[Lambda[X => C[X] => F[X]]](_ => implicitly[Pointed[F]].wu)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
The recursive construction for functors (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-recursive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) assumes a bifunctor 
\begin_inset Formula $S^{\bullet,\bullet}$
\end_inset

 and defines a recursive functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 via the type equation 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}$
\end_inset

.
 The functor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 will be pointed if we can compute a value 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

.
 The type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

 is a recursive type defined via the type equation 
\begin_inset Formula $F^{\bbnum 1}\triangleq S^{\bbnum 1,F^{\bbnum 1}}$
\end_inset

.
 If that type is not void, i.e., if there exists some value of that type,
 we will be able to define 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 as that value.
 
\end_layout

\begin_layout Standard
How can we construct 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 for a given bifunctor 
\begin_inset Formula $S$
\end_inset

? The procedure can be derived by structural analysis of 
\begin_inset Formula $S$
\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursive-types-and-the-existence-of-their-values"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
 For 
\emph on
polynomial
\emph default
 bifunctors 
\begin_inset Formula $S$
\end_inset

 (which is the most often used kind of bifunctors), the necessary and sufficient
 condition is that the type 
\begin_inset Formula $S^{\bbnum 1,\bbnum 0}$
\end_inset

 should be non-void.
 If we can create a value of type 
\begin_inset Formula $S^{\bbnum 1,\bbnum 0}$
\end_inset

 , arguments shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursive-types-and-the-existence-of-their-values"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will guarantee that we can also create a value of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

, and so the recursive functor 
\begin_inset Formula $F$
\end_inset

 will be pointed.
\end_layout

\begin_layout Standard
As an example, consider the polynomial bifunctor 
\begin_inset Formula $S^{A,R}\triangleq A+A\times R$
\end_inset

.
 The corresponding recursive functor 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}=A+A\times F^{A}$
\end_inset

 is the non-empty list (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-non-empty-list-foldLeft"
plural "false"
caps "false"
noprefix "false"

\end_inset

, Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Examples-of-recursive-disjunctive-type-equations"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-recursive"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The type 
\begin_inset Formula $F^{A}$
\end_inset

 can be (non-rigorously) viewed as an 
\begin_inset Quotes eld
\end_inset

infinite disjunction
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
F^{A}=A+A\times(A+A\times\left(A+...\right))=A+A\times A+A\times A\times A+...
\]

\end_inset

Since the type 
\begin_inset Formula $S^{\bbnum 1,\bbnum 0}=\bbnum 1+\bbnum 1\times\bbnum 0\cong\bbnum 1$
\end_inset

 is non-void, the necessary and sufficient condition holds, so we expect
 that the recursive construction will work.
 The type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
F^{\bbnum 1}\triangleq S^{\bbnum 1,F^{\bbnum 1}}=\bbnum 1+\bbnum 1\times F^{\bbnum 1}\cong\bbnum 1+F^{\bbnum 1}\quad.
\]

\end_inset

This type can be also viewed as an 
\begin_inset Quotes eld
\end_inset

infinite disjunction
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
F^{\bbnum 1}\cong\bbnum 1+F^{\bbnum 1}\cong\bbnum 1+\bbnum 1+F^{\bbnum 1}=\bbnum 1+\bbnum 1+\bbnum 1+...
\]

\end_inset

It is clear that a value of that type can be computed, for example, as:
\begin_inset Formula 
\[
\text{wu}_{F}=1+\bbnum 0+\bbnum 0+...\cong1+\bbnum 0^{:F^{\bbnum 1}}\quad.
\]

\end_inset

In Scala, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(())
\end_layout

\end_inset

.
 So, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclass instance for 
\begin_inset Formula $F$
\end_inset

 is implemented by the following code:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "38col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (A, R)]
\end_layout

\begin_layout Plain Layout

final case class F[A](s: S[A, F[A]])
\end_layout

\begin_layout Plain Layout

implicit val pointedF: Pointed[F] =
\end_layout

\begin_layout Plain Layout

  Pointed( F(Left(())) )
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method will use 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to transform 
\begin_inset Formula $\text{wu}_{F}=1+\bbnum 0+\bbnum 0+...$
\end_inset

 into:
\begin_inset Formula 
\[
a+\bbnum 0+\bbnum 0+...:A+A\times A+A\times A\times A+...\quad.
\]

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method of 
\begin_inset Formula $F$
\end_inset

 creates a non-empty list with a single element 
\begin_inset Formula $a^{:A}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
Can we recognize a pointed functor 
\begin_inset Formula $F$
\end_inset

 by looking at its type expression, e.g.:
\begin_inset Formula 
\[
F^{A,B}\triangleq\left((\bbnum 1+A\rightarrow\text{Int})\rightarrow A\times B\right)+\text{String}\times A\times A\quad?
\]

\end_inset

This type constructor is a functor in both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, and we ask whether 
\begin_inset Formula $F$
\end_inset

 is pointed with respect to 
\begin_inset Formula $A$
\end_inset

 and/or with respect to 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
To answer this question with respect to 
\begin_inset Formula $A$
\end_inset

, we set 
\begin_inset Formula $A=\bbnum 1$
\end_inset

 in 
\begin_inset Formula $F^{A,B}$
\end_inset

 and obtain the type expression:
\begin_inset Formula 
\[
F^{\bbnum 1,B}=\left((\bbnum 1+\bbnum 1\rightarrow\text{Int})\rightarrow\bbnum 1\times B\right)+\text{String}\times\bbnum 1\times\bbnum 1\cong\left(\left(\bbnum 2\rightarrow\text{Int}\right)\rightarrow B\right)+\text{String}\quad.
\]

\end_inset

The functor 
\begin_inset Formula $F$
\end_inset

 will be pointed with respect to 
\begin_inset Formula $A$
\end_inset

 if we can compute a value of this type from scratch.
 At the outer level, this type expression is a disjunctive type with two
 parts; it is sufficient to compute one of the parts.
 Can we compute a value of type 
\begin_inset Formula $\left(\bbnum 2\rightarrow\text{Int}\right)\rightarrow B$
\end_inset

? Since the parameter 
\begin_inset Formula $B$
\end_inset

 is an arbitrary, unknown type, we cannot construct values of type 
\begin_inset Formula $B$
\end_inset

 using a given value of type 
\begin_inset Formula $\bbnum 2\rightarrow\text{Int}$
\end_inset

.
 The remaining possibility is to compute the second part of the co-product,
 which is 
\begin_inset Formula $\text{String}\times\bbnum 1\times\bbnum 1$
\end_inset

.
 We are able to compute a value of this type because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 is a fixed type with a known default value (an empty string).
 So, we conclude that 
\begin_inset Formula $F^{A,B}$
\end_inset

 is pointed with respect to 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Considering now the type parameter 
\begin_inset Formula $B$
\end_inset

, we set 
\begin_inset Formula $B=\bbnum 1$
\end_inset

 and obtain:
\begin_inset Formula 
\[
F^{A,\bbnum 1}=\left((\bbnum 1+A\rightarrow\text{Int})\rightarrow A\times\bbnum 1\right)+\text{String}\times A\times A\quad.
\]

\end_inset

The type 
\begin_inset Formula $A$
\end_inset

 is now an arbitrary and unknown type, so we cannot compute any values of
 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $\text{String}\times A\times A$
\end_inset

 from scratch.
 The function type 
\begin_inset Formula $(\bbnum 1+A\rightarrow\text{Int})\rightarrow A\times\bbnum 1$
\end_inset

 cannot be implemented because a value of type 
\begin_inset Formula $A$
\end_inset

 cannot be computed from a function 
\begin_inset Formula $\bbnum 1+A\rightarrow\text{Int}$
\end_inset

 that 
\emph on
consumes
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

.
 So, 
\begin_inset Formula $F^{A,B}$
\end_inset

 is not pointed with respect to 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type signature to implement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Constant functor returning a fixed type 
\begin_inset Formula $Z$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
value of type 
\begin_inset Formula $Z$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Identity functor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Composition of pointed functors/contrafunctors
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\times\text{Pointed}^{G^{\bullet}}\rightarrow\text{Pointed}^{F^{G^{\bullet}}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product of pointed functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\times\text{Pointed}^{G^{\bullet}}\rightarrow\text{Pointed}^{F^{\bullet}\times G^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product of a pointed functor 
\begin_inset Formula $F$
\end_inset

 and any 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\times\text{Functor}^{G^{\bullet}}\rightarrow\text{Pointed}^{F^{\bullet}+G^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Function from any 
\begin_inset Formula $C$
\end_inset

 to a pointed 
\begin_inset Formula $F$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\times\text{Contrafunctor}^{C^{\bullet}}\rightarrow\text{Pointed}^{C^{\bullet}\rightarrow F^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\rightarrow\text{Pointed}^{S^{\bullet,F^{\bullet}}}$
\end_inset

 where 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions producing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 functor typeclass.
\begin_inset CommandInset label
LatexCommand label
name "tab:Type-constructions-for-pointed-functor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Co-pointed functors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Co-pointed-functors"

\end_inset


\end_layout

\begin_layout Standard
Pointed functors provide the functionality of wrapping a given value in
 a 
\begin_inset Quotes eld
\end_inset

pure wrapper
\begin_inset Quotes erd
\end_inset

.
 Another useful operation is 
\emph on
extracting
\emph default
 a value from a given 
\begin_inset Quotes eld
\end_inset

wrapper
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def extract[A]: F[A] => A
\end_layout

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{ex}:\forall A.\,F^{A}\rightarrow A\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Functors having this operation are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
co-pointed functor
\end_layout

\end_inset


\series bold
co-pointed
\series default
.
 We may define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Copointed
\end_layout

\end_inset

 typeclass
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Copointed
\end_layout

\end_inset

 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Copointed[F[_]] { def ex[A]: F[A] => A }
\end_layout

\begin_layout Plain Layout

def extract[F[_]: Copointed, A](f: F[A]): A = implicitly[Copointed[F]].ex(f)
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extract
\end_layout

\end_inset

 function must be fully parametric and obey the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
extract
\end_layout

\end_inset


\series bold
naturality law
\series default
 (compare to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-pure"
plural "false"
caps "false"
noprefix "false"

\end_inset

)):
\begin_inset Formula 
\begin{equation}
\text{ex}_{F}\bef f=f^{\uparrow F}\bef\text{ex}_{F}\quad.\label{eq:naturality-law-of-extract}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "25col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -420baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{4.0pc}F^{A}\ar[r]\sp(0.5){\text{ex}_{F}}\ar[d]\sb(0.45){f^{\uparrow F}} & A\ar[d]\sp(0.45){~f}\\
F^{B}\ar[r]\sp(0.5){\text{ex}_{F}} & B
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The naturality law formulates our expectation that the extractor function
 somehow 
\begin_inset Quotes eld
\end_inset

selects
\begin_inset Quotes erd
\end_inset

 a value of type 
\begin_inset Formula $A$
\end_inset

 among all the values wrapped by 
\begin_inset Formula $F^{A}$
\end_inset

, and the 
\begin_inset Quotes eld
\end_inset

selection
\begin_inset Quotes erd
\end_inset

 works independently of the values.
 If all wrapped values are transformed by a function 
\begin_inset Formula $f$
\end_inset

 into wrapped values of type 
\begin_inset Formula $B$
\end_inset

, the extractor function will still select a value of type 
\begin_inset Formula $B$
\end_inset

 in the same way as it did for values of type 
\begin_inset Formula $A$
\end_inset

.
 So, the result will be the same as if we first extracted a value of type
 
\begin_inset Formula $A$
\end_inset

 and then transformed that value with 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
Both sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-extract"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are functions of type 
\begin_inset Formula $F^{A}\rightarrow B$
\end_inset

.
 We saw in the previous section that, when 
\begin_inset Formula $F$
\end_inset

 is a functor, the type of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclass is equivalent to the type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

.
 That provides a simpler form of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclass.
 For co-pointed functors, there is no simpler form of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extract
\end_layout

\end_inset

 method.
 If we set 
\begin_inset Formula $A=\bbnum 1$
\end_inset

 and 
\begin_inset Formula $f^{:\bbnum 1\rightarrow B}\triangleq(1\rightarrow b)$
\end_inset

 in the naturality law, both sides will become functions of type 
\begin_inset Formula $F^{\bbnum 1}\rightarrow B$
\end_inset

.
 But the type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

 might be void, or a value of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

 may not be computable via fully parametric code.
 So, we cannot deduce any further information from the naturality law of
 co-pointed functors.
 
\end_layout

\begin_layout Standard
However, if 
\begin_inset Formula $F$
\end_inset

 is also a pointed functor, we 
\emph on
will
\emph default
 have a chosen value 
\begin_inset Formula $\text{wu}_{F}:F^{\bbnum 1}$
\end_inset

 to which we may then apply both sides of the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-extract"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and obtain:
\begin_inset Foot
status open

\begin_layout Plain Layout
The symbol 
\begin_inset Formula $\overset{!}{=}$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

must be equal, according to what we know
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{wu}_{F}\triangleright\text{ex}_{F}\bef f\overset{!}{=}\text{wu}_{F}\triangleright f^{\uparrow F}\bef\text{ex}_{F}\quad.
\]

\end_inset

Calculating both sides separately, we find:
\begin_inset Formula 
\begin{align*}
 & \text{wu}_{F}\triangleright\text{ex}_{F}\bef f=\gunderline{\text{wu}_{F}\triangleright\text{ex}_{F}}\triangleright f=1\triangleright f=b\quad,\\
 & \gunderline{\text{wu}_{F}\triangleright f^{\uparrow F}}\bef\text{ex}_{F}=\text{pu}_{F}(b)\triangleright\text{ex}_{F}=b\triangleright\text{pu}_{F}\bef\text{ex}_{F}\quad.
\end{align*}

\end_inset

So, we know that 
\begin_inset Formula $b\triangleright\text{pu}_{F}\bef\text{ex}_{F}\overset{!}{=}b$
\end_inset

.
 This can hold for all 
\begin_inset Formula $b^{:B}$
\end_inset

 only if:
\begin_inset Formula 
\[
\text{pu}_{F}\bef\text{ex}_{F}=\text{id}\quad.
\]

\end_inset

This additional 
\series bold
nondegeneracy
\series default
 
\series bold
law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nondegeneracy law!of pointed and co-pointed functors
\end_layout

\end_inset

 is a consequence of naturality laws if the functor 
\begin_inset Formula $F$
\end_inset

 is pointed and co-pointed at the same time.
\end_layout

\begin_layout Standard
In the derivation above, we have used the equation:
\begin_inset Formula 
\begin{equation}
\text{wu}_{F}\triangleright\text{ex}_{F}=1\quad.\label{eq:co-pointed-nondegeneracy-law-wu}
\end{equation}

\end_inset

 This equation holds automatically, simply because its left-hand side is
 of type 
\begin_inset Formula $\bbnum 1$
\end_inset

, which has only one value (which we denote by 1).
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Let us perform structural analysis for co-pointed functors; the results
 are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-copointed-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Fixed types
\end_layout

\begin_layout Standard
A constant functor 
\begin_inset Formula $\text{Const}^{Z,A}\triangleq Z$
\end_inset

 is 
\emph on
not
\emph default
 co-pointed because we cannot implement 
\begin_inset Formula $\forall A.\,Z\rightarrow A$
\end_inset

 (a value of an arbitrary type 
\begin_inset Formula $A$
\end_inset

 cannot be computed from a value of a fixed type 
\begin_inset Formula $Z$
\end_inset

).
\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
The identity functor 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

 is co-pointed with 
\begin_inset Formula $\text{ex}\triangleq\text{id}^{:A\rightarrow A}$
\end_inset

.
 An identity function will always satisfy any naturality law.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Id[A] = A
\end_layout

\begin_layout Plain Layout

def copointedId: Copointed[Id] = new Copointed[Id] { def ex[A]: Id[A] =>
 A = identity }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Composition of two co-pointed functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $G$
\end_inset

 is co-pointed:
\begin_inset Formula 
\[
\text{ex}_{F\circ G}\triangleq h^{:F^{G^{A}}}\rightarrow\text{ex}_{G}(\text{ex}_{F}(h))\quad\text{ or equivalently }\quad\text{ex}_{F\circ G}=\text{ex}_{F}\bef\text{ex}_{G}\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def copointedFoG[F[_]: Copointed, G[_]: Copointed]: Copointed[Lambda[X =>
 F[G[X]]]] =     
\end_layout

\begin_layout Plain Layout

  new Copointed[Lambda[X => F[G[X]]]] {
\end_layout

\begin_layout Plain Layout

    def ex[A]: F[G[A]] => A = extract[F,G[A]] _ andThen extract[G, A]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

The naturality law holds for 
\begin_inset Formula $\text{ex}_{F\circ G}$
\end_inset

 because:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ex}_{F\circ G}\bef f:\quad & \gunderline{f^{\uparrow F\circ G}}\bef\gunderline{\text{ex}_{F\circ G}}\\
\text{definition of }\ensuremath{f^{\uparrow F\circ G}},\text{ see Eq.~(\ref{eq:def-functor-composition-fmap})}:\quad & =\gunderline{(f^{\uparrow G})^{\uparrow F}\bef\text{ex}_{F}}\bef\text{ex}_{G}\\
\text{naturality law of }\text{ex}_{F}:\quad & =\text{ex}_{F}\bef\gunderline{f^{\uparrow G}\bef\text{ex}_{G}}\\
\text{naturality law of }\text{ex}_{G}:\quad & =\gunderline{\text{ex}_{F}\bef\text{ex}_{G}}\bef f=\text{ex}_{F\circ G}\bef f\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
If functors 
\begin_inset Formula $F$
\end_inset

 or 
\begin_inset Formula $G$
\end_inset

 are co-pointed, we can implement a function of type 
\begin_inset Formula $F^{A}\times G^{A}\rightarrow A$
\end_inset

 by discarding 
\begin_inset Formula $F^{A}$
\end_inset

 (if 
\begin_inset Formula $G$
\end_inset

 is co-pointed) or by discarding 
\begin_inset Formula $G^{A}$
\end_inset

 (if 
\begin_inset Formula $F$
\end_inset

 is co-pointed).
 The functor product 
\begin_inset Formula $F^{\bullet}\times G^{\bullet}$
\end_inset

 is then made into a co-pointed functor.
 For instance, if 
\begin_inset Formula $F$
\end_inset

 is co-pointed, we discard 
\begin_inset Formula $G^{A}$
\end_inset

, so the code for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extract
\end_layout

\end_inset

 method will be:
\begin_inset Formula 
\[
\text{ex}_{F\times G}\triangleq f^{:F^{A}}\times g^{:G^{A}}\rightarrow\text{ex}_{F}(f)=\pi_{1}\bef\text{ex}_{F}\quad,
\]

\end_inset

where we used the pair projection function 
\begin_inset Formula $\pi_{1}\triangleq(a\times b\rightarrow a)$
\end_inset

.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def copointedFxG[F[_]: Copointed, G[_]]: Copointed[Lambda[X => (F[X], G[X])]]
 =
\end_layout

\begin_layout Plain Layout

  new Copointed[Lambda[X => (F[X], G[X])]] {
\end_layout

\begin_layout Plain Layout

    def ex[A]: ((F[A], G[A])) => A = { case (f, g) => extract(f) }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

The following calculation verifies the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-extract"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for this definition of 
\begin_inset Formula $\text{ex}_{F\times G}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ex}_{F\times G}\bef f:\quad & \gunderline{f^{\uparrow F\times G}}\bef\text{ex}_{F\times G}\\
\text{definition of }f^{\uparrow F\times G},\text{ see Eq.~(\ref{eq:def-of-functor-product-fmap})}:\quad & =(f^{\uparrow F}\boxtimes f^{\uparrow G})\bef\gunderline{\text{ex}_{F\times G}}\\
\text{definition of }\text{ex}_{F\times G}:\quad & =\gunderline{(f^{\uparrow F}\boxtimes f^{\uparrow G})\bef\pi_{1}}\bef\text{ex}_{F}\\
\text{use the property }(p\boxtimes q)\bef\pi_{1}=\pi_{1}\bef p:\quad & =\pi_{1}\bef\gunderline{f^{\uparrow F}\bef\text{ex}_{F}}\\
\text{naturality law of }\text{ex}_{F}:\quad & =\gunderline{\pi_{1}\bef\text{ex}_{F}}\bef f\\
\text{definition of }\text{ex}_{F\times G}:\quad & =\text{ex}_{F\times G}\bef f\quad.
\end{align*}

\end_inset

To demonstrate the property 
\begin_inset Formula $(p\boxtimes q)\bef\pi_{1}=\pi_{1}\bef p$
\end_inset

 used in this proof, apply both sides to 
\begin_inset Formula $a\times b$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (a\times b)\triangleright(p\boxtimes q)\,\gunderline{\bef}\,\pi_{1}=\gunderline{(a\times b)\triangleright(p\boxtimes q)}\triangleright\pi_{1}=(p(a)\times q(b))\triangleright\pi_{1}=p(a)\quad,\\
 & (a\times b)\triangleright\pi_{1}\,\gunderline{\bef}\,p=\gunderline{(a\times b)\triangleright\pi_{1}}\triangleright p=a\triangleright p=p(a)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
For co-pointed functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, there is only one possible implementation of the type signature 
\begin_inset Formula $\text{ex}_{F+G}:F^{A}+G^{A}\rightarrow A$
\end_inset

, given that we have functions 
\begin_inset Formula $\text{ex}_{F}$
\end_inset

 and 
\begin_inset Formula $\text{ex}_{G}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "62col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -85baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def copointedEitherFG[F[_]: Copointed, G[_]: Copointed]:
\end_layout

\begin_layout Plain Layout

                 Copointed[Lambda[X => Either[F[X],G[X]]]] =
\end_layout

\begin_layout Plain Layout

  new Copointed[Lambda[X => Either[F[X],G[X]]]] {
\end_layout

\begin_layout Plain Layout

    def ex[A]: Either[F[A], G[A]] => A = {
\end_layout

\begin_layout Plain Layout

      case Left(f)    => extract(f)
\end_layout

\begin_layout Plain Layout

      case Right(g)   => extract(g)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\begin_inset VSpace -250baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -15baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{ex}_{F+G}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline F^{A} & \text{ex}_{F}\\
G^{A} & \text{ex}_{G}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify that 
\begin_inset Formula $\text{ex}_{F+G}$
\end_inset

 satisfies the naturality law, we compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ex}_{F+G}\bef f:\quad & \gunderline{f^{\uparrow F+G}}\bef\gunderline{\text{ex}_{F+G}}\\
\text{definition of }f^{\uparrow F+G},\text{ see Eq.~(\ref{eq:f-coproduct-functor-def-fmap})}:\quad & =\,\begin{array}{||cc|}
f^{\uparrow F} & \bbnum 0\\
\bbnum 0 & f^{\uparrow G}
\end{array}\,\bef\,\begin{array}{||c|}
\text{ex}_{F}\\
\text{ex}_{G}
\end{array}\\
\text{matrix function composition}:\quad & =\,\,\begin{array}{||c|}
\gunderline{f^{\uparrow F}\bef\text{ex}_{F}}\\
\gunderline{f^{\uparrow G}\bef\text{ex}_{G}}
\end{array}\\
\text{naturality laws of }\text{ex}_{F}\text{ and }\text{ex}_{G}:\quad & =\,\begin{array}{||c|}
\text{ex}_{F}\,\gunderline{\bef f}\\
\text{ex}_{G}\,\gunderline{\bef f}
\end{array}\,=\,\gunderline{\begin{array}{||c|}
\text{ex}_{F}\\
\text{ex}_{G}
\end{array}}\,\bef f=\text{ex}_{F+G}\bef f\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
A functor of the form 
\begin_inset Formula $L^{A}\triangleq C^{A}\rightarrow P^{A}$
\end_inset

 (where 
\begin_inset Formula $C$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $P$
\end_inset

 is a functor) will be co-pointed if we can implement a function of type
 
\begin_inset Formula $\forall A.\,(C^{A}\rightarrow P^{A})\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
\text{ex}_{L}:\forall A.\,(C^{A}\rightarrow P^{A})\rightarrow A\quad,\quad\quad\text{ex}_{L}\triangleq h^{:C^{A}\rightarrow P^{A}}\rightarrow\text{???}^{:A}\quad.
\]

\end_inset

Since the type 
\begin_inset Formula $A$
\end_inset

 is arbitrary, the only way of computing a value of type 
\begin_inset Formula $A$
\end_inset

 is somehow to use the function 
\begin_inset Formula $h$
\end_inset

.
 The only way of using 
\begin_inset Formula $h$
\end_inset

 is to apply it to a value of type 
\begin_inset Formula $C^{A}$
\end_inset

, which will yield a value of type 
\begin_inset Formula $P^{A}$
\end_inset

.
 So, we need to assume that we can somehow create a value of type 
\begin_inset Formula $C^{A}$
\end_inset

, for any type 
\begin_inset Formula $A$
\end_inset

.
 We may call a contrafunctor 
\begin_inset Formula $C$
\end_inset

 with a method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cpure
\end_layout

\end_inset

 of type 
\begin_inset Formula $\forall A.\,C^{A}$
\end_inset

 a 
\series bold
pointed contrafunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pointed contrafunctor
\end_layout

\end_inset

.
 Assuming that 
\begin_inset Formula $C$
\end_inset

 is pointed and denoting its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cpure
\end_layout

\end_inset

 method by 
\begin_inset Formula $\text{cpu}_{C}$
\end_inset

, we can thus compute a value of type 
\begin_inset Formula $P^{A}$
\end_inset

 as 
\begin_inset Formula $h(\text{cpu}_{C})$
\end_inset

.
 To extract 
\begin_inset Formula $A$
\end_inset

 from 
\begin_inset Formula $P^{A}$
\end_inset

, we need to assume additionally that 
\begin_inset Formula $P$
\end_inset

 is co-pointed and use its method 
\begin_inset Formula $\text{ex}_{P}:P^{A}\rightarrow A$
\end_inset

.
 Finally, we have:
\begin_inset Formula 
\begin{equation}
\text{ex}_{L}\triangleq h^{:C^{A}\rightarrow P^{A}}\rightarrow\text{ex}_{P}(h(\text{cpu}_{C}))\quad\quad\text{ or equivalently}:\quad\quad h^{:C^{A}\rightarrow P^{A}}\triangleright\text{ex}_{L}=\text{cpu}_{C}\triangleright h\triangleright\text{ex}_{P}\quad.\label{eq:def-of-ex-for-C-mapsto-P}
\end{equation}

\end_inset

To verify the naturality law, we apply both sides to an arbitrary 
\begin_inset Formula $h^{:C^{A}\rightarrow P^{A}}$
\end_inset

 and compute
\begin_inset Formula 
\begin{align*}
\text{expect to equal }h\triangleright\text{ex}_{L}\bef f:\quad & h\triangleright f^{\uparrow L}\bef\text{ex}_{L}=(h\triangleright f^{\uparrow L})\,\gunderline{\triangleright\,\text{ex}_{L}}\\
\text{use Eq.~(\ref{eq:def-of-ex-for-C-mapsto-P})}:\quad & =\text{cpu}_{C}\triangleright(h\triangleright f^{\uparrow L})\triangleright\text{ex}_{P}=\text{cpu}_{C}\triangleright\gunderline{(h\triangleright f^{\uparrow L})}\bef\text{ex}_{P}\\
\text{definition of }f^{\uparrow L},\text{ see Eq.~(\ref{eq:f-functor-exponential-def-fmap-f-h})}:\quad & =\text{cpu}_{C}\triangleright f^{\downarrow C}\bef h\bef\gunderline{f^{\uparrow P}\bef\text{ex}_{P}}\\
\text{naturality law of }\text{ex}_{P}:\quad & =\text{cpu}_{C}\triangleright f^{\downarrow C}\bef h\bef\text{ex}_{P}\bef f\quad.
\end{align*}

\end_inset

We expect the last expression to equal this one:
\begin_inset Formula 
\[
h\triangleright\text{ex}_{L}\bef f=\text{cpu}_{C}\triangleright h\triangleright\text{ex}_{P}\triangleright f=\text{cpu}_{C}\triangleright h\bef\text{ex}_{P}\bef f\quad.
\]

\end_inset

This is possible only if 
\begin_inset Formula $\text{cpu}_{C}\triangleright f^{\downarrow C}=\text{pu}_{C}$
\end_inset

 for all 
\begin_inset Formula $f$
\end_inset

.
 This motivates us to assume that law as the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
pure
\family default
 for contrafunctors
\end_layout

\end_inset


\series bold
naturality law
\series default
 of 
\begin_inset Formula $\text{cpu}_{C}$
\end_inset

 for pointed contrafunctors.
 With that last assumption, we have finished proving the naturality law
 of 
\begin_inset Formula $\text{ex}_{L}$
\end_inset

.
 The code for 
\begin_inset Formula $\text{ex}_{L}$
\end_inset

 is
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def copointedFunc[C[_]: Pointed, P[_]: Copointed]: Copointed[Lambda[X =>
 C[X] => P[X]]] =
\end_layout

\begin_layout Plain Layout

  new Copointed[Lambda[X => C[X] => P[X]]] {
\end_layout

\begin_layout Plain Layout

    def ex[A]: (C[A] => P[A]) => A = h => extract[P, A](h(cpure[C, A]))
\end_layout

\begin_layout Plain Layout

  }      // In Scala 2.13: h => cpure[C, A] pipe h pipe extract[P, A] as
 in ${
\backslash
color{dkgreen} h
\backslash
rightarrow
\backslash
text{pu}_{C}
\backslash
triangleright h
\backslash
triangleright
\backslash
text{ex}_{P} }$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will analyze pointed contrafunctors and their naturality law in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
Consider a functor 
\begin_inset Formula $F$
\end_inset

 defined by a recursive equation 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}$
\end_inset

 where 
\begin_inset Formula $S$
\end_inset

 is a bifunctor (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Bifunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The functor 
\begin_inset Formula $F$
\end_inset

 is co-pointed if a method 
\begin_inset Formula $\text{ex}_{F}:(F^{A}\rightarrow A)\cong(S^{A,F^{A}}\rightarrow A)$
\end_inset

 can be defined.
 Since the recursive definition of 
\begin_inset Formula $F$
\end_inset

 uses 
\begin_inset Formula $F^{A}$
\end_inset

 as a type argument in 
\begin_inset Formula $S^{A,F^{A}}$
\end_inset

, we may assume (by induction) that an extractor function 
\begin_inset Formula $F^{A}\rightarrow A$
\end_inset

 is already available when applied to the recursively used 
\begin_inset Formula $F^{A}$
\end_inset

.
 Then we can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 method of 
\begin_inset Formula $S$
\end_inset

 to map 
\begin_inset Formula $S^{A,F^{A}}\rightarrow S^{A,A}$
\end_inset

.
 It remains to extract a value of type 
\begin_inset Formula $A$
\end_inset

 out of a bifunctor value 
\begin_inset Formula $S^{A,A}$
\end_inset

.
 We call a bifunctor 
\begin_inset Formula $S$
\end_inset

 
\series bold
co-pointed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
co-pointed bifunctor
\end_layout

\end_inset

 if a fully parametric function 
\begin_inset Formula $\text{ex}_{S}:S^{A,A}\rightarrow A$
\end_inset

 exists and satisfies the corresponding 
\series bold
naturality law
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of co-pointed bifunctors
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\text{ex}_{S}\bef f=\text{bimap}_{S}(f)(f)\bef\text{ex}_{S}\quad.\label{eq:copointed-bifunctor-naturality-law}
\end{equation}

\end_inset

Assuming that 
\begin_inset Formula $S$
\end_inset

 is co-pointed, we can finally define 
\begin_inset Formula $\text{ex}_{F}$
\end_inset

 by recursion:
\begin_inset Formula 
\[
\text{ex}_{F}\triangleq s^{:S^{A,F^{A}}}\rightarrow s\triangleright\big(\text{bimap}_{S}(\text{id})(\text{ex}_{F})\big)\triangleright\text{ex}_{S}\quad\text{ or equivalently}\quad\text{ex}_{F}\triangleq\text{bimap}_{S}(\text{id})(\text{ex}_{F})\bef\text{ex}_{S}\quad.
\]

\end_inset

To verify the naturality law of 
\begin_inset Formula $\text{ex}_{F}$
\end_inset

, we denote recursive uses by an overline and compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ex}_{F}\bef f:\quad & \gunderline{f^{\uparrow F}}\bef\text{ex}_{F}\\
\text{definition of }f^{\uparrow F},\text{ see Eq.~(\ref{eq:def-recursive-functor-fmap})}:\quad & =\text{bimap}_{S}(f)(\overline{f^{\uparrow F}})\bef\gunderline{\text{ex}_{F}}\\
\text{definition of }\text{ex}_{F}:\quad & =\gunderline{\text{bimap}_{S}(f)(\overline{f^{\uparrow F}})\bef\text{bimap}_{S}(\text{id})(\overline{\text{ex}_{F}})}\bef\text{ex}_{S}\\
\text{bifunctor composition law~(\ref{eq:f-bimap-composition-law})}:\quad & =\text{bimap}_{S}(f\bef\text{id})(\overline{\gunderline{f^{\uparrow F}\bef\text{ex}_{F}}})\bef\text{ex}_{S}\\
\text{naturality law of }\text{ex}_{F}:\quad & =\gunderline{\text{bimap}_{S}(f)(\overline{\text{ex}_{F}\bef f})}\bef\text{ex}_{S}\\
\text{bifunctor composition law in reverse}:\quad & =\text{bimap}_{S}(\text{id})(\overline{\text{ex}_{F}})\bef\text{bimap}_{S}(f)(\overline{f})\bef\text{ex}_{S}\\
\text{naturality law~(\ref{eq:copointed-bifunctor-naturality-law}) of }\text{ex}_{S}:\quad & =\gunderline{\text{bimap}_{S}(\text{id})(\overline{\text{ex}_{F}})\bef\text{ex}_{S}}\bef f\\
\text{definition of }\text{ex}_{F}:\quad & =\text{ex}_{F}\bef f\quad.
\end{align*}

\end_inset

An example illustrating the recursive construction is the bifunctor 
\begin_inset Formula $S^{A,R}\triangleq A+R\times R$
\end_inset

 that defines 
\begin_inset Formula $F^{A}$
\end_inset

 to be the binary tree functor:
\begin_inset Formula 
\[
F^{A}\triangleq S^{A,F^{A}}=A+F^{A}\times F^{A}\quad.
\]

\end_inset

The bifunctor 
\begin_inset Formula $S$
\end_inset

 is co-pointed because there exists a suitable function, 
\begin_inset Formula $\text{ex}_{S}:S^{A,A}\rightarrow A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "47col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace 35baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, (R, R)]
\end_layout

\begin_layout Plain Layout

def exS[A]: S[A, A] => A = {
\end_layout

\begin_layout Plain Layout

  case Left(a)          => a
\end_layout

\begin_layout Plain Layout

  case Right((a1, a2))  => a1 // Could be a2.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -225baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In the code notation, the function 
\begin_inset Formula $\text{ex}_{S}$
\end_inset

 is written as:
\begin_inset VSpace -20baselineskip%
\end_inset


\begin_inset Formula 
\[
\text{ex}_{S}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A\times A & \pi_{1}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -75baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent
This function extracts the left-most leaf of a binary tree because it is
 using the projection 
\begin_inset Formula $\pi_{1}$
\end_inset

 (not 
\begin_inset Formula $\pi_{2}$
\end_inset

).
\end_layout

\begin_layout Standard
To implement the co-pointed instance 
\begin_inset Formula $\text{ex}_{F}$
\end_inset

 for the binary tree functor, we need to use the implementation of 
\begin_inset Formula $\text{bimap}_{S}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bimap_S[A,B,P,Q](f: A => B)(g: P => Q): S[A, P] => S[B, Q] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)         => Left(f(a))
\end_layout

\begin_layout Plain Layout

  case Right((x, y))   => Right((g(x), g(y)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can define the recursive type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 and a co-pointed instance for it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class F[A](s: S[A, F[A]])
\end_layout

\begin_layout Plain Layout

val copointedF: Copointed[F] = new Copointed[F1] {
\end_layout

\begin_layout Plain Layout

  def ex[A]: F1[A] => A = { case F1(s) => exS1(bimap_S(identity[A], ex[A])(s))
 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The naturality law holds for the recursive instance by induction (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Eq-typeclass"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
Can we recognize a co-pointed functor 
\begin_inset Formula $F$
\end_inset

 by looking at its type expression, e.g.:
\begin_inset Formula 
\[
F^{A,B}\triangleq\left(\left(\bbnum 1+A\rightarrow\text{Int}\right)\rightarrow A\times B\right)+\text{String}\times A\times A\quad?
\]

\end_inset

The constructions shown in this section tell us that a co-product of two
 co-pointed functors is again co-pointed.
 Let us first check whether 
\begin_inset Formula $\text{String}\times A\times A$
\end_inset

 is co-pointed.
 We can certainly extract a value of type 
\begin_inset Formula $A$
\end_inset

 out of 
\begin_inset Formula $\text{String}\times A\times A$
\end_inset

, but not a value of type 
\begin_inset Formula $B$
\end_inset

.
 So, there is no hope for 
\begin_inset Formula $F^{A,B}$
\end_inset

 to be co-pointed with respect to the parameter 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
It remains to consider 
\begin_inset Formula $A$
\end_inset

 as the type parameter.
 The type constructor 
\begin_inset Formula $\text{String}\times A\times A$
\end_inset

 is co-pointed, but we still need to check 
\begin_inset Formula $\left(\bbnum 1+A\rightarrow\text{Int}\right)\rightarrow A\times B$
\end_inset

, which is a function type.
 The function construction requires 
\begin_inset Formula $\bbnum 1+A\rightarrow\text{Int}$
\end_inset

 to be a pointed contrafunctor and 
\begin_inset Formula $A\times B$
\end_inset

 to be a co-pointed functor (with respect to 
\begin_inset Formula $A$
\end_inset

).
 It is clear that 
\begin_inset Formula $A\times B$
\end_inset

 is co-pointed with respect to 
\begin_inset Formula $A$
\end_inset

 since we have 
\begin_inset Formula $\pi_{1}:A\times B\rightarrow A$
\end_inset

.
 It remains to check that the contrafunctor 
\begin_inset Formula $C^{A}\triangleq\bbnum 1+A\rightarrow\text{Int}$
\end_inset

 is pointed.
 A contrafunctor 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is pointed if values of type 
\begin_inset Formula $C^{\bbnum 1}$
\end_inset

 can be computed (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

); this requires us to compute a value of type 
\begin_inset Formula $\bbnum 1+\bbnum 1\rightarrow\text{Int}$
\end_inset

.
 One such value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ _ => 0 }
\end_layout

\end_inset

, a constant function that always returns the integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We conclude that 
\begin_inset Formula $F^{A,B}$
\end_inset

 is co-pointed with respect to 
\begin_inset Formula $A$
\end_inset

 but not co-pointed with respect to 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type signature to implement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Identity functor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{id}:A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Composition of co-pointed functors
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Copointed}^{F^{\bullet}}\times\text{Copointed}^{G^{\bullet}}\rightarrow\text{Copointed}^{F^{G^{\bullet}}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product of co-pointed functor 
\begin_inset Formula $F$
\end_inset

 and any 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Copointed}^{F^{\bullet}}\times\text{Functor}^{G^{\bullet}}\rightarrow\text{Copointed}^{F^{\bullet}\times G^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product of co-pointed functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Copointed}^{F^{\bullet}}\times\text{Copointed}^{G^{\bullet}}\rightarrow\text{Copointed}^{F^{\bullet}+G^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Function from pointed 
\begin_inset Formula $C$
\end_inset

 to co-pointed 
\begin_inset Formula $F$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{\text{Pointed}^{C^{\bullet}}}\times\text{Copointed}^{F^{\bullet}}\rightarrow\text{Copointed}^{C^{\bullet}\rightarrow F^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Copointed}^{F^{\bullet}}\rightarrow\text{Copointed}^{S^{\bullet,F^{\bullet}}}$
\end_inset

 where 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions producing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Copointed
\end_layout

\end_inset

 functor typeclass.
\begin_inset CommandInset label
LatexCommand label
name "tab:Type-constructions-for-copointed-functor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pointed contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Pointed-contrafunctors"

\end_inset


\end_layout

\begin_layout Standard
In the previous section, the function-type construction required a contrafunctor
 
\begin_inset Formula $C^{\bullet}$
\end_inset

 to have a method 
\begin_inset Formula $\text{cpu}_{C}$
\end_inset

 of type 
\begin_inset Formula $\forall A.\,C^{A}$
\end_inset

; we called such contrafunctors 
\series bold
pointed
\series default
.
 We also needed to assume that the naturality law holds for all functions
 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{cpu}_{C}\triangleright f^{\downarrow C}=\text{cpu}_{C}\quad,\quad\text{or equivalently}:\quad\text{cmap}_{C}(f^{:A\rightarrow B})(\text{cpu}_{C}^{:C^{B}})=\text{cpu}_{C}^{:C^{A}}\quad.\label{eq:naturality-law-for-pure-for-contrafunctors}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{3.0pc}\bbnum 1\ar[rd]\sb(0.5){}\ar[r]\sb(0.5){} & \text{cpu}_{C}:C^{B}\ar[d]\sp(0.45){\text{cmap}_{C}(f)}\\
 & \text{cpu}_{C}:C^{A}
}
\]

\end_inset

We may simplify the formulation of the typeclass by setting 
\begin_inset Formula $B=\bbnum 1$
\end_inset

 in the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-pure-for-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and denoting 
\begin_inset Formula $\text{wu}_{C}\triangleq\text{cpu}_{C}^{\bbnum 1}$
\end_inset

.
 The law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-pure-for-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then gives: 
\begin_inset Formula 
\begin{equation}
\text{cpu}_{C}^{A}=\text{wu}_{C}\triangleright(\_^{:A}\rightarrow1)^{\downarrow C}\quad.\label{eq:def-pure-via-wu-for-contrafunctor}
\end{equation}

\end_inset

In this way, we express the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cpure
\end_layout

\end_inset

 method through a chosen value 
\begin_inset Formula $\text{wu}_{C}:C^{\bbnum 1}$
\end_inset

.
 For the same reasons as in the case of pointed functors, the types of 
\begin_inset Formula $\text{cpu}_{C}$
\end_inset

 and 
\begin_inset Formula $\text{wu}_{C}$
\end_inset

 are equivalent.
 The law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-pure-for-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $\text{cpu}_{C}$
\end_inset

 will be satisfied automatically if 
\begin_inset Formula $\text{cpu}_{C}$
\end_inset

 is defined via Eq.
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-via-wu-for-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To verify that, compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{cpu}_{C}^{A}:\quad & \text{cpu}_{C}^{B}\triangleright f^{\downarrow C}\\
\text{use definition~(\ref{eq:def-pure-via-wu-for-contrafunctor})}:\quad & =\text{wu}_{C}\triangleright\gunderline{(\_^{:B}\rightarrow1)^{\downarrow C}\triangleright f^{\downarrow C}}\\
\text{composition law of contrafunctor }C:\quad & =\text{wu}_{C}\triangleright(\gunderline{f\bef(\_^{:B}\rightarrow1)})^{\downarrow C}\\
\text{compute function composition}:\quad & =\text{wu}_{C}\triangleright(\_^{:A}\rightarrow1)^{\downarrow C}=\text{cpu}_{C}^{A}\quad.
\end{align*}

\end_inset

So, a pointed contrafunctor instance for 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is equivalent to a chosen value of type 
\begin_inset Formula $C^{\bbnum 1}$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Pointed[F[_]](wu: F[Unit])
\end_layout

\begin_layout Plain Layout

def cpure[F[_]: Pointed : Contrafunctor, A]: F[A] = implicitly[Pointed[F]].wu.cmap
(_ => ())
\end_layout

\end_inset

Here we used a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 typeclass (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-6"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
 We can now apply structural analysis to pointed contrafunctors, similarly
 to Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Contrafunctor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The results are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-pointed-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Fixed types
\end_layout

\begin_layout Standard
This construction is the same as for pointed functors (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-functors:-structural-analysis"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 A fixed type 
\begin_inset Formula $Z$
\end_inset

 gives a constant contrafunctor 
\begin_inset Formula $C^{A}\triangleq Z$
\end_inset

.
 Since 
\begin_inset Formula $C^{\bbnum 1}=Z$
\end_inset

, the constant contrafunctor is pointed if we have a chosen value of type
 
\begin_inset Formula $Z$
\end_inset

; this will be the case, for instance, if 
\begin_inset Formula $Z=\bbnum 1+U$
\end_inset

 for some type 
\begin_inset Formula $U$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Type parameters
\end_layout

\begin_layout Standard
Since the identity functor 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

 is not a contrafunctor, it remains to consider the functor compositions
 
\begin_inset Formula $C^{F^{A}}$
\end_inset

 and 
\begin_inset Formula $F^{C^{A}}$
\end_inset

 where 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a functor.
 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $C$
\end_inset

 is pointed, we can always obtain a value 
\begin_inset Formula $\text{cpu}_{C}$
\end_inset

 of type 
\begin_inset Formula $C^{A}$
\end_inset

 for any type 
\begin_inset Formula $A$
\end_inset

, in particular for 
\begin_inset Formula $A=F^{\bbnum 1}$
\end_inset

 (whether or not a value of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

 can be computed).
 So, 
\begin_inset Formula $C^{F^{\bullet}}$
\end_inset

 is a pointed contrafunctor whenever 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is one, for any (not necessarily pointed) functor 
\begin_inset Formula $F$
\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedCoF[C[_]: Pointed: Contrafunctor, F[_]]: Pointed[Lambda[X =>
 C[F[X]]]] =
\end_layout

\begin_layout Plain Layout

  Pointed[Lambda[X => C[F[X]]]](cpure[C, F[Unit]])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Creating a value of type 
\begin_inset Formula $F^{C^{\bbnum 1}}$
\end_inset

 requires 
\begin_inset Formula $F$
\end_inset

 to have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method that could be applied to a value of type 
\begin_inset Formula $C^{\bbnum 1}$
\end_inset

 to compute a value of type 
\begin_inset Formula $F^{C^{\bbnum 1}}$
\end_inset

.
 So, 
\begin_inset Formula $F^{C^{\bullet}}$
\end_inset

 is pointed whenever both 
\begin_inset Formula $C^{\bullet}$
\end_inset

 and 
\begin_inset Formula $F^{\bullet}$
\end_inset

 are pointed.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedFoC[C[_]: Pointed, F[_]: Pointed : Functor]: Pointed[Lambda[X
 => F[C[X]]]] =
\end_layout

\begin_layout Plain Layout

  Pointed[Lambda[X => F[C[X]]]](pure[F, C[Unit]](implicitly[Pointed[C]].wu))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Products
\end_layout

\begin_layout Standard
The construction is the same as for pointed functors: If we have values
 of type 
\begin_inset Formula $C^{\bbnum 1}$
\end_inset

 and 
\begin_inset Formula $D^{\bbnum 1}$
\end_inset

, we can compute the pair 
\begin_inset Formula $C^{\bbnum 1}\times D^{\bbnum 1}$
\end_inset

.
 This makes the product contrafunctor 
\begin_inset Formula $L^{A}\triangleq C^{A}\times D^{A}$
\end_inset

 pointed if both 
\begin_inset Formula $C^{\bullet}$
\end_inset

 and 
\begin_inset Formula $D^{\bullet}$
\end_inset

 are pointed contrafunctors.
\end_layout

\begin_layout Paragraph
Co-products
\end_layout

\begin_layout Standard
The construction is the same as for pointed functors: If at least one of
 the contrafunctors 
\begin_inset Formula $C^{\bullet}$
\end_inset

 and 
\begin_inset Formula $D^{\bullet}$
\end_inset

 is pointed, we can create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 instance for the co-product contrafunctor 
\begin_inset Formula $L^{A}\triangleq C^{A}+D^{A}$
\end_inset

 as either 
\begin_inset Formula $\text{wu}_{L}=\text{wu}_{C}+\bbnum 0^{:D^{\bbnum 1}}$
\end_inset

 or 
\begin_inset Formula $\text{wu}_{L}=\bbnum 0^{:C^{\bbnum 1}}+\text{wu}_{D}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
The construction is 
\begin_inset Formula $L^{A}\triangleq F^{A}\rightarrow C^{A}$
\end_inset

, where 
\begin_inset Formula $C^{\bullet}$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $F^{\bullet}$
\end_inset

 is a functor.
 To create a value 
\begin_inset Formula $\text{wu}_{L}:L^{\bbnum 1}$
\end_inset

 means to create a function of type 
\begin_inset Formula $F^{\bbnum 1}\rightarrow C^{\bbnum 1}$
\end_inset

.
 That function cannot use its argument of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

 for computing a value 
\begin_inset Formula $C^{\bbnum 1}$
\end_inset

 since 
\begin_inset Formula $F$
\end_inset

 is an arbitrary functor.
 So, 
\begin_inset Formula $\text{wu}_{L}$
\end_inset

 must be a constant function 
\begin_inset Formula $(\_^{:F^{\bbnum 1}}\rightarrow\text{wu}_{C})$
\end_inset

, where we assumed that a value 
\begin_inset Formula $\text{wu}_{C}:C^{\bbnum 1}$
\end_inset

 is available.
 Thus, 
\begin_inset Formula $F^{A}\rightarrow C^{A}$
\end_inset

 is pointed when 
\begin_inset Formula $C$
\end_inset

 is a pointed contrafunctor and 
\begin_inset Formula $F$
\end_inset

 is any functor.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pointedFuncFC[C[_]: Pointed, F[_]]: Pointed[Lambda[X => F[X] => C[X]]]
 =
\end_layout

\begin_layout Plain Layout

      Pointed[Lambda[X => F[X] => C[X]]](_ => implicitly[Pointed[C]].wu)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Recursive types
\end_layout

\begin_layout Standard
The recursive construction for contrafunctors (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-contrafunctor-recursive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\begin_inset Formula $C^{A}\triangleq S^{A,C^{A}}$
\end_inset

 where 
\begin_inset Formula $S^{A,R}$
\end_inset

 is a contrafunctor in 
\begin_inset Formula $A$
\end_inset

 and a functor in 
\begin_inset Formula $R$
\end_inset

.
 Values of type 
\begin_inset Formula $C^{\bbnum 1}$
\end_inset

 will exist when the recursive type equation 
\begin_inset Formula $T\triangleq S^{\bbnum 1,T}$
\end_inset

 defines a non-void type 
\begin_inset Formula $T$
\end_inset

.
 This condition is similar to that for pointed functors, and the resulting
 construction is the same.
\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
Can we recognize a pointed contrafunctor 
\begin_inset Formula $C$
\end_inset

 by looking at its type expression, e.g.
\begin_inset Formula 
\[
C^{A,B}\triangleq\left(\bbnum 1+A\rightarrow B\right)+(\text{String}\times A\times B\rightarrow\text{String})\text{ with respect to type parameter }A?
\]

\end_inset

We need to set 
\begin_inset Formula $A=\bbnum 1$
\end_inset

 and try to create a value 
\begin_inset Formula $\text{wu}:C^{\bbnum 1,B}$
\end_inset

.
 In this example, 
\begin_inset Formula $C^{\bbnum 1,B}=\left(\bbnum 1+\bbnum 1\rightarrow B\right)+(\text{String}\times\bbnum 1\times B\rightarrow\text{String})$
\end_inset

.
 A value of this type is 
\begin_inset Formula $\text{wu}_{C}\triangleq\bbnum 0+(s^{:\text{String}}\times1\times b^{:B}\rightarrow s)$
\end_inset

.
 So, the contrafunctor 
\begin_inset Formula $C^{A,B}$
\end_inset

 is pointed with respect to 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type signature to implement
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Constant functor returning a fixed type 
\begin_inset Formula $Z$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
value of type 
\begin_inset Formula $Z$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Composition of pointed functors/contrafunctors
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\times\text{Pointed}^{G^{\bullet}}\rightarrow\text{Pointed}^{F^{G^{\bullet}}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Product of pointed contrafunctors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\times\text{Pointed}^{G^{\bullet}}\rightarrow\text{Pointed}^{F^{\bullet}\times G^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Co-product of a pointed 
\begin_inset Formula $F$
\end_inset

 and any 
\begin_inset Formula $G$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{F^{\bullet}}\times\text{Contrafunctor}^{G^{\bullet}}\rightarrow\text{Pointed}^{F^{\bullet}+G^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Function from a functor 
\begin_inset Formula $F$
\end_inset

 to a pointed 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{C^{\bullet}}\times\text{Functor}^{F^{\bullet}}\rightarrow\text{Pointed}^{F^{\bullet}\rightarrow C^{\bullet}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\text{Pointed}^{C^{\bullet}}\rightarrow\text{Pointed}^{S^{\bullet,C^{\bullet}}}$
\end_inset

 where 
\begin_inset Formula $C^{A}\triangleq S^{A,C^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions producing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 contrafunctor typeclass.
\begin_inset CommandInset label
LatexCommand label
name "tab:Type-constructions-for-pointed-contrafunctor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Itemize
Define arbitrary PTVFs using typeclass constraints on type parameters.
\end_layout

\begin_layout Itemize
Define typeclasses and typeclass instances for types and for type constructors.
\end_layout

\begin_layout Itemize
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

, and other standard typeclasses, and prove their laws.
\end_layout

\begin_layout Itemize
Use known constructions to derive typeclass instances from previous ones.
\end_layout

\begin_layout Standard
What problems cannot be solved with these tools?
\end_layout

\begin_layout Itemize

\emph on
Automatically
\emph default
 derive type class instances for given data types or type constructors.
\end_layout

\begin_layout Itemize
Combine typeclasses and express dependencies, e.g., typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC1
\end_layout

\end_inset

 requires 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC3
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We may want to write code such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = (A => Int) => A                     // Define a type constructor.
\end_layout

\begin_layout Plain Layout

implicit val functorF: Functor[F] = implement   // Automatically implement
 typeclass instance for F.
\end_layout

\begin_layout Plain Layout

implicit val pointedF: Pointed[F] = implement   // Automatically use the
 function-type construction.
\end_layout

\end_inset

However, no currently available library provides such functionality.
 Also, typeclass instances are not always derived uniquely, as we have seen
 in several cases (e.g., the co-product construction of monoids or pointed
 functors).
\end_layout

\begin_layout Standard
We will discuss how to combine typeclasses in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Inheritance-and-automatic-typeclass"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
\end_layout

\begin_layout Subsection
Solved examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a PTVF with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def bitsize[T]: Int
\end_layout

\end_inset

 such that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize[Short]
\end_layout

\end_inset

 returns 
\begin_inset Formula $16$
\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize[Int]
\end_layout

\end_inset

 returns 
\begin_inset Formula $32$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize[Long]
\end_layout

\end_inset

 returns 
\begin_inset Formula $64$
\end_inset

.
 For all other types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

, the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize[T]
\end_layout

\end_inset

 should remain undefined.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize[T]
\end_layout

\end_inset

 needs to take an additional implicit argument that will be available only
 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T = Short
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T = Int
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T = Long
\end_layout

\end_inset

.
 To implement that, we need to define a new type constructor, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasBitsize[T]
\end_layout

\end_inset

, and create implicit values of the corresponding types.
 The new type constructor defines a typeclass whose instances need to carry
 the information about the bit size:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class HasBitsize[T](size: Int)
\end_layout

\begin_layout Plain Layout

object HasBitsize {
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeShort = HasBitsize[Short](16)
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeInt   = HasBitsize[Int]  (32)
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeLong  = HasBitsize[Long] (64)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize
\end_layout

\end_inset

 as a PTVF,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bitsize[T](implicit ti: HasBitsize[T]): Int = ti.size
\end_layout

\end_inset

The instance argument such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ti: HasBitsize[T]
\end_layout

\end_inset

 is sometimes called the 
\begin_inset Quotes eld
\end_inset

evidence
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
evidence value
\end_layout

\end_inset

 argument
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!evidence argument
\end_layout

\end_inset

 because its presence provides 
\begin_inset Quotes eld
\end_inset

evidence
\begin_inset Quotes erd
\end_inset

 that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 belongs to the type domain of the typeclass.
\end_layout

\begin_layout Standard
We can check that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize
\end_layout

\end_inset

 is defined only for supported types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> bitsize[Long]
\end_layout

\begin_layout Plain Layout

res0: Int = 64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> bitsize[String]
\end_layout

\begin_layout Plain Layout

<console>:15: error: could not find implicit value for evidence parameter
 of type HasBitsize[String]
\end_layout

\begin_layout Plain Layout

       bitsize[String]
\end_layout

\begin_layout Plain Layout

              ^ 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The current implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasBitsize
\end_layout

\end_inset

 allows the programmer to add new types to its type domain whenever necessary.
 For example, the following code will add support for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type so that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize[Boolean]
\end_layout

\end_inset

 will evaluate to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val bitsizeBoolean = HasBitsize[Boolean](1)
\end_layout

\end_inset

In some applications, it is important that the type domain of a PTVF should
 remain fixed (e.g., as defined in a library).
 To prevent the programmer from creating any further values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasBitsize
\end_layout

\end_inset

, we could make it a non-case class whose constructor is declared as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

private
\end_layout

\end_inset

 function like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final class HasBitsize[T] private (val size: Int) // Not a case class; the
 constructor is private.
\end_layout

\begin_layout Plain Layout

object HasBitsize {            // The companion object is allowed to call
 the private constructor.
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeShort = new HasBitsize[Short](16)
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeInt   = new HasBitsize[Int]  (32)
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeLong  = new HasBitsize[Long] (64)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bitsize[T]
\end_layout

\end_inset

 remains unchanged.
 With these definitions, no further typeclass instances can be created by
 any code outside of the companion object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasBitsize
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> implicit val bitsizeBoolean = new HasBitsize[Boolean](1)
\end_layout

\begin_layout Plain Layout

<console>:16: error: constructor HasBitsize in class HasBitsize cannot be
 accessed in object $iw
\end_layout

\begin_layout Plain Layout

       implicit val bitsizeBoolean = new HasBitsize[Boolean](1)
\end_layout

\begin_layout Plain Layout

                                     ^
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An implementation via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 requires longer code but brings no significant advantages:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait HasBitsize[T] { def size: Int } // Declare the trait as `sealed` to
 prohibit further instances.
\end_layout

\begin_layout Plain Layout

object HasBitsize {
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeShort = new HasBitsize[Short]{ def size: Int = 16
 }
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeInt   = new HasBitsize[Int]  { def size: Int = 32
 }
\end_layout

\begin_layout Plain Layout

  implicit val bitsizeLong  = new HasBitsize[Long] { def size: Int = 64
 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for the type 
\begin_inset Formula $\bbnum 1+(\text{String}\rightarrow\text{String})$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We look for suitable monoid constructions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that build up the given type expression from simpler parts.
 Since the type expression 
\begin_inset Formula $\bbnum 1+(\text{String}\rightarrow\text{String})$
\end_inset

 is a co-product at the outer level, we must start with the co-product construct
ion, which requires us to choose one of the parts of the disjunction, say
 
\begin_inset Formula $\text{String}\rightarrow\text{String}$
\end_inset

, as the 
\begin_inset Quotes eld
\end_inset

preferred
\begin_inset Quotes erd
\end_inset

 monoid.
 Next, we need to produce 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instances for 
\begin_inset Formula $\bbnum 1$
\end_inset

 and for 
\begin_inset Formula $\text{String}\rightarrow\text{String}$
\end_inset

.
 While the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has a unique 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance, there are several for 
\begin_inset Formula $\text{String}\rightarrow\text{String}$
\end_inset

.
 The function-type construction gives two possible monoid instances: the
 monoid 
\begin_inset Formula $R\rightarrow A$
\end_inset

 with 
\begin_inset Formula $R=A=\text{String}$
\end_inset

, and the function composition monoid.
 Let us choose the latter.
 The code using the monoid constructions from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can then be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val monoidX: Monoid[Either[Unit, String => String]] = {
\end_layout

\begin_layout Plain Layout

  implicit val m1 = Monoid[Unit]( (x, y) => (), () )
\end_layout

\begin_layout Plain Layout

  implicit val m2: Monoid[String => String] = monoidFunc1[String]
\end_layout

\begin_layout Plain Layout

  monoidEitherPreferB[Unit, String => String]
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

We can translate the constructions into code for a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[String => String]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val monoidX: Monoid[Option[String => String]] = Monoid( {
\end_layout

\begin_layout Plain Layout

  case (None, None)         => None
\end_layout

\begin_layout Plain Layout

  case (None, Some(f))      => Some(f)
\end_layout

\begin_layout Plain Layout

  case (Some(f), None)      => Some(f)
\end_layout

\begin_layout Plain Layout

  case (Some(f), Some(g))   => Some(f andThen g)
\end_layout

\begin_layout Plain Layout

}, None )
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that if 
\begin_inset Formula $A$
\end_inset

 is a monoid and 
\begin_inset Formula $B$
\end_inset

 is a semigroup then 
\begin_inset Formula $A+B$
\end_inset

 is a monoid.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The co-product construction  
\begin_inset Formula $A+B$
\end_inset

 (where both 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 are monoids) has two implementations: one of the empty elements 
\begin_inset Formula $e_{A}$
\end_inset

 or 
\begin_inset Formula $e_{B}$
\end_inset

 must be chosen as the empty element for the monoid 
\begin_inset Formula $A+B$
\end_inset

.
 If 
\begin_inset Formula $B$
\end_inset

 is not a monoid, the only choice is to set 
\begin_inset Formula $e_{A+B}\triangleq e_{A}+\bbnum 0$
\end_inset

.
 This is the implementation in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidEitherPreferB
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We just need to replace the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass constraint for 
\begin_inset Formula $B$
\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidEitherSemigroup[A: Monoid, B: Semigroup] = Monoid[Either[A, B]](
 {
\end_layout

\begin_layout Plain Layout

  case (Left(a1), Left(a2))     => Left(a1 |+| a2)
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(b))      => Right(b) // 
\begin_inset Quotes eld
\end_inset

Take B
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout

  case (Right(b), Left(a))      => Right(b)
\end_layout

\begin_layout Plain Layout

  case (Right(b1), Right(b2))   => Right(b1 |+| b2)
\end_layout

\begin_layout Plain Layout

}, Left(implicitly[Monoid[A]].empty) ) // The type B does not need an empty
 element.
\end_layout

\end_inset

The monoid laws hold here because the proofs of the laws do not depend on
 the existence of 
\begin_inset Formula $e_{B}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (a routing monoid)
\end_layout

\begin_layout Standard
A (much simplified) web server is implemented as a number of 
\begin_inset Quotes eld
\end_inset

routes
\begin_inset Quotes erd
\end_inset

.
 Each route may respond to one or more URL paths by evaluating a custom
 function.
 The task is to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine
\end_layout

\end_inset

 operation for routes.
 The combined route should respond to all paths that at least one of the
 previous routes responds to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Path = String              //    Here, the types `Path` and `Response`
 are defined only as an
\end_layout

\begin_layout Plain Layout

type Response = (Int, String)   // illustration.
 The code will use these types as type parameters.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type Route = Path => Option[Response]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val r1: Route = { case 
\begin_inset Quotes eld
\end_inset

/get_users
\begin_inset Quotes erd
\end_inset

 => (200, 
\begin_inset Quotes eld
\end_inset

user1, user2, user3
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\begin_layout Plain Layout

val r2: Route = { case 
\begin_inset Quotes eld
\end_inset

/get_names
\begin_inset Quotes erd
\end_inset

 => (200, 
\begin_inset Quotes eld
\end_inset

name1, name2, name3
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\begin_layout Plain Layout

      // The task is to implement an extension method |+| such that this
 works correctly:
\end_layout

\begin_layout Plain Layout

val route: Route = r1 |+| r2     // Should respond to both `/get_users`
 and `/get_names`.
\end_layout

\end_inset

Use the 
\family typewriter
cats
\family default
 library for implementing a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for routes; verify that the monoid laws hold.
\end_layout

\begin_layout Paragraph
Solution
\end_layout

\begin_layout Standard
We will first figure out how to implement the required functionality, and
 then adapt the code to the 
\family typewriter
cats
\family default
 library's definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass.
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

route
\begin_inset Quotes erd
\end_inset

 is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Path => Option[Response]
\end_layout

\end_inset

 that returns a non-empty option if the route responds to a given path value.
 A combination of two routes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 needs to be a new route, i.e., a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Path => Option[Response]
\end_layout

\end_inset

.
 The new function will first check whether 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

 responds to a given path.
 If so, it will evaluate the result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

.
 Otherwise, it will try applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 to the given path.
 We implement the required business logic in a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combineRoutes
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def combineRoutes(r1: Route, r2: Route): Route = { path =>
\end_layout

\begin_layout Plain Layout

  r1(path) match {
\end_layout

\begin_layout Plain Layout

    case Some(response) => Some(response)
\end_layout

\begin_layout Plain Layout

    case None => r2(path)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A monoid also needs to have an empty element.
 An 
\begin_inset Quotes eld
\end_inset

empty route
\begin_inset Quotes erd
\end_inset

 can be combined with any other route and will not change the behavior of
 that route.
 If the empty route responds to any path, it would prevent another route
 from also responding to the same path.
 So, the only solution is to define the 
\begin_inset Quotes eld
\end_inset

empty route
\begin_inset Quotes erd
\end_inset

 as a function that 
\emph on
never
\emph default
 responds to any path:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val emptyRoute: Route = { _ => None }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
cats
\family default
 library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 with methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

empty
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combine
\end_layout

\end_inset

.
 We can define that typeclass using our existing code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import $ivy.`org.typelevel::cats-core:1.5.0`, cats.Monoid      // Using `ammonite`
 for convenience.
\end_layout

\begin_layout Plain Layout

implicit val catsMonoidRoute: Monoid[Route] = new Monoid[Route] {
\end_layout

\begin_layout Plain Layout

  def empty: Route = emptyRoute
\end_layout

\begin_layout Plain Layout

  def combine(x: Route, y: Route): Route = combineRoutes(x, y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now check that the routes can be combined as we intended:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import cats.syntax.monoid._
\end_layout

\begin_layout Plain Layout

val route: Route = r1 |+| r2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ammonite@ route(
\begin_inset Quotes eld
\end_inset

/get_users
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: Response = (200, "user1, user2, user3")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ammonite@ route(
\begin_inset Quotes eld
\end_inset

/get_names
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res1: Response = (200, "name1, name2, name3")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify that the monoid laws hold, we could look for direct proofs using
 the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

emptyRoute
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combineRoutes
\end_layout

\end_inset

.
 However, it is easier to figure out how to reduce the definition of the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Route
\end_layout

\end_inset

 monoid to a number of constructions listed in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
For more convenient reasoning, we replace the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Path
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Response
\end_layout

\end_inset

 by type parameters 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
 We note that these types are used fully parametrically by the code of our
 functions.
 So, we will write the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Route
\end_layout

\end_inset

 as 
\begin_inset Formula $\text{Route}\triangleq P\rightarrow\bbnum 1+R$
\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Route
\end_layout

\end_inset

 is a function type at the outer level, we start with the function-type
 construction, which requires 
\begin_inset Formula $\bbnum 1+R$
\end_inset

 to be a monoid.
 This suggests using the co-product construction; however, 
\begin_inset Formula $R$
\end_inset

 is not necessarily a monoid.
 There are several possible monoid instances for 
\begin_inset Formula $\bbnum 1+R$
\end_inset

, so let us look at how the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combineRoutes
\end_layout

\end_inset

 handles values of that type.
 The value 
\begin_inset Formula $1+\bbnum 0^{:R}$
\end_inset

 corresponds to a route that is not responding to a given path; in that
 case, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combineRoutes
\end_layout

\end_inset

 will switch to the other route.
 So, the empty value of the monoid 
\begin_inset Formula $\bbnum 1+R$
\end_inset

 must be 
\begin_inset Formula $1+\bbnum 0^{:R}$
\end_inset

.
 This is indeed the value returned by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

emptyRoute
\end_layout

\end_inset

 when applied to any path.
\end_layout

\begin_layout Standard
A non-empty value 
\begin_inset Formula $\bbnum 0+r$
\end_inset

 corresponds to a route that responds to a given path; given two such values,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combineRoutes
\end_layout

\end_inset

 will take the first one.
 This corresponds to the binary operation 
\begin_inset Formula $\oplus_{R}$
\end_inset

 defined by 
\begin_inset Formula $r_{1}\oplus_{R}r_{2}=r_{1}$
\end_inset

.
 This operation makes 
\begin_inset Formula $R$
\end_inset

 into a trivial semigroup (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Semigroups-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 As Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed, 
\begin_inset Formula $\bbnum 1+R$
\end_inset

 is a monoid if 
\begin_inset Formula $R$
\end_inset

 is a semigroup (since the unit type 
\begin_inset Formula $\bbnum 1$
\end_inset

 is a monoid).
\end_layout

\begin_layout Standard
So, we have reduced the monoid instance defined by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

emptyRoute
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

combineRoutes
\end_layout

\end_inset

 to a trivial semigroup, a co-product construction, and a function-type
 construction.
 Since all those constructions are guaranteed to produce lawful monoids,
 we do not need to prove the monoid laws by hand.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the 
\family typewriter
cats
\family default
 library, define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Try[T]]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The 
\family typewriter
cats
\family default
 library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Functor[F[_]] { def map[A, B](fa: F[A])(f: A => B): F[B] }
\end_layout

\end_inset

The functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Try[T]]
\end_layout

\end_inset

 is a composition of functors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, so we can define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for it using the functor composition (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-composition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We wrap 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Try[T]]
\end_layout

\end_inset

 into a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import cats.Functor
\end_layout

\begin_layout Plain Layout

final case class F[T](s: Seq[Try[T]]) // `type F[T] = Seq[Try[T]]` does
 not work with `map` method.
\end_layout

\begin_layout Plain Layout

implicit val functorF: Functor[F] = new Functor[F] {
\end_layout

\begin_layout Plain Layout

  def map[A, B](fa: F[A])(f: A => B): F[B] = F(fa.s.map(_.map(f)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

One more 
\family typewriter
cats
\family default
-specific import is necessary to enable the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 extension method for functors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import cats.syntax.functor._      // Enable the `map` method.
\end_layout

\begin_layout Plain Layout

val s = F(Seq(Try(1), Try(2), Try(3)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ammonite@ s.map(_ * 10)
\end_layout

\begin_layout Plain Layout

res0: F[Int] = F(List(Success(10), Success(20), Success(30)))
\end_layout

\end_inset

For the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method to work, the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 must be defined as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

.
 Defining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 as a type alias would make the Scala compiler confused: if the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[T]
\end_layout

\end_inset

 were 
\emph on
the same
\emph default
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Try[T]]
\end_layout

\end_inset

, the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(Try(1)).map(_ * 10)
\end_layout

\end_inset

 would mean to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

's built-in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method rather than the extension method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 defined for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the 
\family typewriter
cats
\family default
 library, implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bifunctor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $Q^{X,Y}\triangleq X+X\times Y$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The 
\family typewriter
cats
\family default
 library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bifunctor
\end_layout

\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Bifunctor
\end_layout

\end_inset

typeclass as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 method.
 Implementing that method as an information-preserving, fully parametric
 function is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Q[X, Y](q: Either[X, (X, Y)])
\end_layout

\begin_layout Plain Layout

implicit val bifunctorQ = new Bifunctor[Q] {
\end_layout

\begin_layout Plain Layout

  def bimap[A, B, C, D](fab: Q[A, B])(f: A => C, g: B => D): Q[C, D] = fab.q
 match {
\end_layout

\begin_layout Plain Layout

    case Left(a)         => Q(Left(f(a)))
\end_layout

\begin_layout Plain Layout

    case Right((a, b))   => Q(Right((f(a), g(b))))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 typeclass having the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!
\family typewriter
Contrafunctor
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def contramap[A, B](c: C[A])(f: B => A): C[B]
\end_layout

\end_inset

Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 instance for the type constructor 
\begin_inset Formula $C^{A}\triangleq A\rightarrow\text{Int}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
An instance value must contain the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 method of type 
\begin_inset Formula $\forall(A,B).\,C^{A}\rightarrow(B\rightarrow A)\rightarrow C^{B}$
\end_inset

.
 This signature has type parameters, so the typeclass needs to be implemented
 as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

trait
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Contrafunctor[C[_]] { def contramap[A, B](c: C[A])(f: B => A): C[B]
 }
\end_layout

\end_inset

A typeclass instance for the type constructor 
\begin_inset Formula $C^{A}\triangleq A\rightarrow\text{Int}$
\end_inset

 is created by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type C[A] = A => Int
\end_layout

\begin_layout Plain Layout

implicit val contrafunctorC = new Contrafunctor[C] {
\end_layout

\begin_layout Plain Layout

  def contramap[A, B](c: A => Int)(f: B => A): B => Int = f andThen c
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
cats
\family default
 library defines an equivalent typeclass named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contravariant
\end_layout

\end_inset

 with the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for recursive type constructor 
\begin_inset Formula $Q^{A}\triangleq\left(\text{Int}\rightarrow A\right)+\text{Int}+Q^{A}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by defining 
\begin_inset Formula $Q^{A}$
\end_inset

 as a recursive disjunctive type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Q[A]
\end_layout

\begin_layout Plain Layout

final case class C1[A](i: Int => A) extends Q[A]
\end_layout

\begin_layout Plain Layout

final case class C2[A](x: Int)      extends Q[A]
\end_layout

\begin_layout Plain Layout

final case class C3[A](q: Q[A])     extends Q[A]
\end_layout

\end_inset

The methods of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 show how to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[A]
\end_layout

\end_inset

.
 Without repeating those steps, we will write code for a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance directly:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val functorQ: Functor[Q] = new Functor[Q] { // The function `map`
 is recursive.
\end_layout

\begin_layout Plain Layout

  def map[A, B](qa: Q[A])(f: A => B): Q[B] = qa match {
\end_layout

\begin_layout Plain Layout

    case C1(i)   => C1(i andThen f)
\end_layout

\begin_layout Plain Layout

    case C2(x)   => C2(x)
\end_layout

\begin_layout Plain Layout

    case C3(q)   => C3(map(q)(f)) // Recursive case.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using a function parameterized by the type constructors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 (required to be functors), implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The co-product construction (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows how to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for the functor 
\begin_inset Formula $F^{A}+G^{A}$
\end_inset

.
 We begin by writing code for a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance assuming that the type constructors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

 are given:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type L[A] = Either[F[A], G[A]]
\end_layout

\begin_layout Plain Layout

implicit val functorEither = new Functor[L] {
\end_layout

\begin_layout Plain Layout

  def map[A, B](e: L[A])(f: A => B): L[B] = e match {
\end_layout

\begin_layout Plain Layout

    case Left(fa)    => Left(fa.map(f))
\end_layout

\begin_layout Plain Layout

    case Right(ga)   => Right(ga.map(f))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We will now to rewrite this code by making 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

 into type parameters.
 To achieve that, we need to use the 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Index idx
status open

\begin_layout Plain Layout
kind@
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 plugin and replace the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 by a nameless type function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Lambda[X => Either[F[X], G[X]]]
\end_layout

\end_inset

.
 The code becomes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def functorEither[F[_], G[_]] = new Functor[Lambda[X => Either[F[X],
 G[X]]]] {
\end_layout

\begin_layout Plain Layout

  type L[A] = Either[F[A], G[A]]         // We may use F and G to define
 a type alias in this scope.
\end_layout

\begin_layout Plain Layout

  def map[A, B](e: L[A])(f: A => B): L[B] = e match {
\end_layout

\begin_layout Plain Layout

    case Left(fa)    => Left(fa.map(f))
\end_layout

\begin_layout Plain Layout

    case Right(ga)   => Right(ga.map(f))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-10"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Implement a function with type signature 
\begin_inset Formula $C^{A}+C^{B}\rightarrow C^{A\times B}$
\end_inset

 parameterized by a type constructor 
\begin_inset Formula $C$
\end_inset

 (required to be a contrafunctor) and by arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 Show that the inverse type signature 
\begin_inset Formula $C^{A\times B}\rightarrow C^{A}+C^{B}$
\end_inset

 is not implementable for some contrafunctors 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Implement a function with type signature 
\begin_inset Formula $F^{A\times B}\rightarrow F^{A}\times F^{B}$
\end_inset

 parameterized by a type constructor 
\begin_inset Formula $F$
\end_inset

 (required to be a functor) and by arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 Show that the inverse type signature 
\begin_inset Formula $F^{A}\times F^{B}\rightarrow F^{A\times B}$
\end_inset

 is not implementable for some functors 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We need to implement a function with type signature
\begin_inset Formula 
\[
\forall(A,B).\,C^{A}+C^{B}\rightarrow C^{A\times B}\quad.
\]

\end_inset

Begin by looking at the types involved.
 We need to relate values 
\begin_inset Formula $C^{A\times B}$
\end_inset

, 
\begin_inset Formula $C^{A}$
\end_inset

, and 
\begin_inset Formula $C^{B}$
\end_inset

; can we relate 
\begin_inset Formula $A\times B$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

, and 
\begin_inset Formula $B$
\end_inset

? There exist unique fully parametric functions 
\begin_inset Formula $\pi_{1}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}$
\end_inset

 of types 
\begin_inset Formula $A\times B\rightarrow A$
\end_inset

 and 
\begin_inset Formula $A\times B\rightarrow B$
\end_inset

.
 If we lift these functions to the contrafunctor 
\begin_inset Formula $C$
\end_inset

, we will get 
\begin_inset Formula $\pi_{1}^{\downarrow C}:C^{A}\rightarrow C^{A\times B}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}^{\downarrow C}:C^{B}\rightarrow C^{A\times B}$
\end_inset

.
 The required type signature is then implemented via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression like this:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "58col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[C[_]: Contrafunctor, A, B]
\end_layout

\begin_layout Plain Layout

               : Either[C[A], C[B]] => C[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case Left(ca)    => ca.contramap { case (a, b) => a }
\end_layout

\begin_layout Plain Layout

  case Right(cb)   => cb.contramap { case (a, b) => b }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -300baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The code notation for this function is:
\begin_inset VSpace -25baselineskip%
\end_inset


\begin_inset Formula 
\[
f^{:C^{A}+C^{B}\rightarrow C^{A\times B}}\triangleq\,\begin{array}{|c||c|}
 & C^{A\times B}\\
\hline C^{A} & \pi_{1}^{\downarrow C}\\
C^{B} & \pi_{2}^{\downarrow C}
\end{array}\quad.
\]

\end_inset


\begin_inset VSpace -85baselineskip%
\end_inset


\end_layout

\begin_layout Standard
To show that it is not possible to implement a function 
\begin_inset Formula $g$
\end_inset

 with the inverse type signature:
\begin_inset Formula 
\[
g:\forall(A,B).\,C^{A\times B}\rightarrow C^{A}+C^{B}\quad,
\]

\end_inset

we choose the contrafunctor 
\begin_inset Formula $C^{A}\triangleq A\rightarrow R$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 is a fixed type.
 The type signature becomes:
\begin_inset Formula 
\[
g:\forall(A,B).\,(A\times B\rightarrow R)\rightarrow(A\rightarrow R)+(B\rightarrow R)\quad.
\]

\end_inset

To implement this function, we need to decide whether to return values of
 type 
\begin_inset Formula $A\rightarrow R$
\end_inset

 or 
\begin_inset Formula $B\rightarrow R$
\end_inset

.
 Can we compute a value of type 
\begin_inset Formula $A\rightarrow R$
\end_inset

 given a value of type 
\begin_inset Formula $A\times B\rightarrow R$
\end_inset

?
\begin_inset Formula 
\[
g^{:(A\times B\rightarrow R)\rightarrow A\rightarrow R}\triangleq q^{:A\times B\rightarrow R}\rightarrow a^{:A}\rightarrow\text{???}^{:R}
\]

\end_inset

We cannot compute a value of type 
\begin_inset Formula $R$
\end_inset

 because that requires us to apply the function 
\begin_inset Formula $q$
\end_inset

 to a pair 
\begin_inset Formula $A\times B$
\end_inset

, while we only have a value of type 
\begin_inset Formula $A$
\end_inset

.
 So, the typed hole 
\begin_inset Formula $\text{???}^{:R}$
\end_inset

 cannot be filled.
 
\end_layout

\begin_layout Standard
Similarly, we are not able to compute a value of type 
\begin_inset Formula $B\rightarrow R$
\end_inset

 from a value of type 
\begin_inset Formula $A\times B\rightarrow R$
\end_inset

.
 Whatever choice we make, 
\begin_inset Formula $A\rightarrow R$
\end_inset

 or 
\begin_inset Formula $B\rightarrow R$
\end_inset

, we cannot implement the required type signature.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We need to implement a function with type signature:
\begin_inset Formula 
\[
\forall(A,B).\,F^{A\times B}\rightarrow F^{A}\times F^{B}\quad.
\]

\end_inset

The types 
\begin_inset Formula $A\times B$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

, and 
\begin_inset Formula $B$
\end_inset

 are related by the functions 
\begin_inset Formula $\pi_{1}:A\times B\rightarrow A$
\end_inset

 and 
\begin_inset Formula $\pi_{2}:A\times B\rightarrow B$
\end_inset

.
 Lifting these functions to the functor 
\begin_inset Formula $F$
\end_inset

, we obtain 
\begin_inset Formula $\pi_{1}^{\uparrow F}:F^{A\times B}\rightarrow F^{A}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}^{\uparrow F}:F^{A\times B}\rightarrow F^{B}$
\end_inset

.
 It remains to take the product of the resulting values:
\begin_inset Formula 
\[
f^{:F^{A\times B}\rightarrow F^{A}\times F^{B}}\triangleq p^{:F^{A\times B}}\rightarrow(p\triangleright\pi_{1}^{\uparrow F})\times(p\triangleright\pi_{2}^{\uparrow F})\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[F[_]: Functor, A, B](p: F[(A, B)]): (F[A], F[B]) =
\end_layout

\begin_layout Plain Layout

  (p.map { case (a, b) => a }, p.map { case (a, b) => b })  // Or (p.map(_._1),
 p.map(_._2))
\end_layout

\end_inset

A shorter code for 
\begin_inset Formula $f$
\end_inset

 via the 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function 
\begin_inset Formula $\Delta\triangleq(q^{:Q}\rightarrow q\times q)$
\end_inset

 and the pair product 
\begin_inset Formula $\boxtimes$
\end_inset

 is:
\begin_inset Formula 
\[
f^{:F^{A\times B}\rightarrow F^{A}\times F^{B}}\triangleq\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\quad.
\]

\end_inset

This notation is sometimes easier to reason about when deriving properties
 of functions.
\end_layout

\begin_layout Standard
If we try implementing a function 
\begin_inset Formula $g$
\end_inset

 with the inverse type signature:
\begin_inset Formula 
\begin{equation}
g:\forall(A,B).\,F^{A}\times F^{B}\rightarrow F^{A\times B}\quad,\label{eq:type-signature-of-g-zip}
\end{equation}

\end_inset

we will find that 
\begin_inset Formula $g$
\end_inset

 
\emph on
can
\emph default
 be implemented for functors such as 
\begin_inset Formula $F^{A}\triangleq A\times A$
\end_inset

, 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A$
\end_inset

, and 
\begin_inset Formula $F^{A}\triangleq P\rightarrow A$
\end_inset

.
 It is not obvious how to find a functor 
\begin_inset Formula $F$
\end_inset

 for which the function 
\begin_inset Formula $g$
\end_inset

 has no implementation.
 By looking through the known functor constructions (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and trying various combinations, we eventually find a suitable functor:
 
\begin_inset Formula $F^{A}\triangleq(P\rightarrow A)+(Q\rightarrow A)$
\end_inset

.
 The type signature of 
\begin_inset Formula $g$
\end_inset

 becomes:
\begin_inset Formula 
\[
g:\forall(A,B).\,\left((P\rightarrow A)+(Q\rightarrow A)\right)\times\left((P\rightarrow B)+(Q\rightarrow B)\right)\rightarrow(P\rightarrow A\times B)+(Q\rightarrow A\times B)\quad.
\]

\end_inset

The argument of this function is of type:
\begin_inset Formula 
\[
\left((P\rightarrow A)+(Q\rightarrow A)\right)\times\left((P\rightarrow B)+(Q\rightarrow B)\right)\quad,
\]

\end_inset

which can be transformed equivalently into a disjunction of four cases:
\begin_inset Formula 
\[
(P\rightarrow A)\times(P\rightarrow B)+(P\rightarrow A)\times(Q\rightarrow B)+(Q\rightarrow A)\times(P\rightarrow B)+(Q\rightarrow A)\times(Q\rightarrow B)\quad.
\]

\end_inset

Implementing the function 
\begin_inset Formula $g$
\end_inset

 requires, in particular, to handle the case when we are given values of
 types 
\begin_inset Formula $P\rightarrow A$
\end_inset

 and 
\begin_inset Formula $Q\rightarrow B$
\end_inset

, and we are required to produce a value of type 
\begin_inset Formula $(P\rightarrow A\times B)+(Q\rightarrow A\times B)$
\end_inset

.
 The resulting type signature:
\begin_inset Formula 
\[
(P\rightarrow A)\times(Q\rightarrow B)\rightarrow(P\rightarrow A\times B)+(Q\rightarrow A\times B)
\]

\end_inset

cannot be implemented: If we choose to return a value of type 
\begin_inset Formula $P\rightarrow A\times B$
\end_inset

, we would need to produce a pair of type 
\begin_inset Formula $A\times B$
\end_inset

 from a value of type 
\begin_inset Formula $P$
\end_inset

.
 However, producing a pair 
\begin_inset Formula $A\times B$
\end_inset

 requires, in this case, to have values of 
\emph on
both
\emph default
 types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

, since the given arguments have types 
\begin_inset Formula $P\rightarrow A$
\end_inset

 and 
\begin_inset Formula $Q\rightarrow B$
\end_inset

.
 Similarly, we cannot return a value of type 
\begin_inset Formula $Q\rightarrow A\times B$
\end_inset

.
\end_layout

\begin_layout Standard
We find that the function 
\begin_inset Formula $g$
\end_inset

 cannot be implemented for the functor 
\begin_inset Formula $F^{A}\triangleq(P\rightarrow A)+(Q\rightarrow A)$
\end_inset

.
 Functors 
\begin_inset Formula $F$
\end_inset

 for which the type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:type-signature-of-g-zip"
plural "false"
caps "false"
noprefix "false"

\end_inset

) 
\emph on
can
\emph default
 be implemented are called 
\begin_inset Quotes eld
\end_inset

applicative
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative functors
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 (see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for precise conditions).
 The functor 
\begin_inset Formula $F$
\end_inset

 is an example of a functor that is not applicative.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Example-pointed-alternative"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-pointed-alternative"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
(R.
\begin_inset space ~
\end_inset

O'Connor
\begin_inset Index idx
status open

\begin_layout Plain Layout
Russell O'Connor
\end_layout

\end_inset

 
\begin_inset Foot
status open

\begin_layout Plain Layout
This example is based on the post 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://mail.haskell.org/pipermail/haskell-cafe/2015-November/122357.html"

\end_inset


\end_layout

\end_inset

) Assume that a functor 
\begin_inset Formula $F$
\end_inset

 admits a function 
\begin_inset Formula $p$
\end_inset

 with type signature:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "63col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[A, B, F[_]: Functor]: Either[A, F[B]] => F[Either[A, B]]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset space ~
\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\begin_inset Formula 
\[
p^{A,B}:A+F^{B}\rightarrow F^{A+B}\quad,
\]

\end_inset

additionally satisfying the special laws of identity and associativity:
\begin_inset Formula 
\[
p^{\bbnum 0,B}=(b^{:B}\rightarrow\bbnum 0+b)^{\uparrow F}\quad,\quad\quad p^{A+B,C}=\,\begin{array}{|c||cc|}
 & A & F^{B+C}\\
\hline A & \text{id} & \bbnum 0\\
B+F^{C} & \bbnum 0 & p^{B,C}
\end{array}\,\bef p^{A,B+C}\quad.
\]

\end_inset

Show that the functor 
\begin_inset Formula $F$
\end_inset

 is pointed if such a function 
\begin_inset Formula $p$
\end_inset

 exists.
 Conversely, show that any pointed functor 
\begin_inset Formula $F$
\end_inset

 admits a function 
\begin_inset Formula $p$
\end_inset

 with these properties.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $F$
\end_inset

 is pointed, it is sufficient to find a value 
\begin_inset Formula $\text{wu}_{F}$
\end_inset

 of type 
\begin_inset Formula $F^{\bbnum 1}$
\end_inset

.
 We note that the given function 
\begin_inset Formula $p$
\end_inset

 can create values of type 
\begin_inset Formula $F^{A+B}$
\end_inset

 from input values of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

.
 So, we set the type parameters 
\begin_inset Formula $A=\bbnum 1$
\end_inset

 and 
\begin_inset Formula $B=\bbnum 0$
\end_inset

 and apply 
\begin_inset Formula $p$
\end_inset

 to the value 
\begin_inset Formula $1+\bbnum 0^{:F^{\bbnum 0}}$
\end_inset

:
\begin_inset Formula 
\[
\text{wu}_{F}\triangleq(1+\bbnum 0^{:F^{\bbnum 0}})\triangleright p^{\bbnum 1,\bbnum 0}\triangleright(1+\bbnum 0\rightarrow1)^{\uparrow F}\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val wu[F[_]: Functor]: F[Unit] = p[Unit, Nothing](Left(())).map { case Left(_)
 => () }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Conversely, assuming that 
\begin_inset Formula $F$
\end_inset

 is pointed, we use its 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 function to define 
\begin_inset Formula $p$
\end_inset

 as:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "58col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -20baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[F[_]: Functor : Pointed, A, B]
\end_layout

\begin_layout Plain Layout

              : Either[A, F[B]] => F[Either[A, B]] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)     => pure[F, Either[A, B]](Left(a))
\end_layout

\begin_layout Plain Layout

  case Right(fb)   => fb.map { b => Right[A, B](b) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -400baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset Formula 
\[
p^{A,B}\triangleq\,\begin{array}{|c||c|}
 & F^{A+B}\\
\hline A & (a^{:A}\rightarrow a+\bbnum 0^{:B})\bef\text{pu}_{F}\\
F^{B} & (b^{:B}\rightarrow\bbnum 0^{:A}+b)^{\uparrow F}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It remains to show that 
\begin_inset Formula $p$
\end_inset

 satisfies the required laws.
 The identity law holds because:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(b^{:B}\rightarrow\bbnum 0+b)^{\uparrow F}:\quad & p^{\bbnum 0,B}=\,\begin{array}{|c||c|}
 & F^{\bbnum 0+B}\\
\hline \bbnum 0 & \text{(we may delete this line)}\\
F^{B} & (b^{:B}\rightarrow\bbnum 0+b)^{\uparrow F}
\end{array}\,=(b^{:B}\rightarrow\bbnum 0+b)^{\uparrow F}\quad.
\end{align*}

\end_inset

To verify the associativity law, we begin with its right-hand side since
 it is more complicated:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{|c||cc|}
 & A & F^{B+C}\\
\hline A & \text{id} & \bbnum 0\\
B+F^{C} & \bbnum 0 & p^{B,C}
\end{array}\,\bef p^{A,B+C}=\,\begin{array}{|c||cc|}
 & A & F^{B+C}\\
\hline A & \text{id} & \bbnum 0\\
B+F^{C} & \bbnum 0 & p^{B,C}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & F^{A+B+C}\\
\hline A & (a^{:A}\rightarrow a+\bbnum 0^{:B+C})\bef\text{pu}_{F}\\
F^{B+C} & (x^{:B+C}\rightarrow\bbnum 0^{:A}+x)^{\uparrow F}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & F^{A+B+C}\\
\hline A & (a^{:A}\rightarrow a+\bbnum 0^{:B+C})\bef\text{pu}_{F}\\
B+F^{C} & p^{B,C}\bef(x^{:B+C}\rightarrow\bbnum 0^{:A}+x)^{\uparrow F}
\end{array}\,=\,\begin{array}{|c||c|}
 & F^{A+B+C}\\
\hline A & (a^{:A}\rightarrow a+\bbnum 0^{:B+C})\bef\text{pu}_{F}\\
B & (b^{:B}\rightarrow b+\bbnum 0^{:C})\bef\text{pu}_{F}\bef(x^{:B+C}\rightarrow\bbnum 0^{:A}+x)^{\uparrow F}\\
F^{C} & (c^{:C}\rightarrow\bbnum 0^{:A+B}+c)^{\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset

In the last line, we have expanded the type matrix to three rows corresponding
 to the disjunctive type 
\begin_inset Formula $A+B+F^{C}$
\end_inset

.
 We need to show that the last matrix equals 
\begin_inset Formula $p^{A+B,C}$
\end_inset

; so let us rewrite 
\begin_inset Formula $p^{A+B,C}$
\end_inset

 as a similarly expanded type matrix, using the type isomorphisms such as
 
\begin_inset Formula $\bbnum 0^{:A}+\bbnum 0^{:B}\cong\bbnum 0^{:A+B}$
\end_inset

:
\begin_inset Formula 
\[
p^{A+B,C}=\,\begin{array}{|c||c|}
 & F^{A+B+C}\\
\hline A & (a^{:A}\rightarrow a+\gunderline{\bbnum 0^{:B}+\bbnum 0^{:C}})\bef\text{pu}_{F}\\
B & (b^{:B}\rightarrow\bbnum 0^{:A}+b+\bbnum 0^{:C})\bef\text{pu}_{F}\\
F^{C} & (c^{:C}\rightarrow\gunderline{\bbnum 0^{:A}+\bbnum 0^{:B}}+c)^{\uparrow F}
\end{array}\,=\,\begin{array}{|c||c|}
 & F^{A+B+C}\\
\hline A & (a^{:A}\rightarrow a+\bbnum 0^{:B+C})\bef\text{pu}_{F}\\
B & (b^{:B}\rightarrow\bbnum 0^{:A}+b+\bbnum 0^{:C})\bef\text{pu}_{F}\\
F^{C} & (c^{:C}\rightarrow\bbnum 0^{:A+B}+c)^{\uparrow F}
\end{array}\quad.
\]

\end_inset

The only remaining difference is in the second lines of the matrices.
 We write those lines separately: 
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(b^{:B}\rightarrow\bbnum 0^{:A}+b+\bbnum 0^{:C})\bef\text{pu}_{F}:\quad & (b^{:B}\rightarrow b+\bbnum 0^{:C})\bef\gunderline{\text{pu}_{F}\bef(x^{:B+C}\rightarrow\bbnum 0^{:A}+x)^{\uparrow F}}\\
\text{naturality law of }\text{pu}_{F}:\quad & =\gunderline{(b^{:B}\rightarrow b+\bbnum 0^{:C})\bef(x^{:B+C}\rightarrow\bbnum 0^{:A}+x)}\bef\text{pu}_{F}\\
\text{compute function composition}:\quad & =(b^{:B}\rightarrow\bbnum 0^{:A}+b+\bbnum 0^{:C})\bef\text{pu}_{F}\quad.
\end{align*}

\end_inset

This completes the proof of the required laws.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a PTVF 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def isLong[T]: Boolean
\end_layout

\end_inset

 that returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T = Long
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 and returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T = Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Short
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

.
 The function should remain undefined for other types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for the type 
\begin_inset Formula $\text{String}\times(\bbnum 1+\text{Int})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 If 
\begin_inset Formula $A$
\end_inset

 is a monoid and 
\begin_inset Formula $R$
\end_inset

 any type, implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for 
\begin_inset Formula $R\rightarrow A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def monoidFunc[A: Monoid, R]: Monoid[R => A] = ???
\end_layout

\end_inset

Prove that the monoid laws hold for that instance.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 With the choice 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R = Boolean
\end_layout

\end_inset

, use the type equivalence 
\begin_inset Formula $(R\rightarrow A)=(\bbnum 2\rightarrow A)\cong A\times A$
\end_inset

 and verify that the monoid instance 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidFunc[A, Boolean]
\end_layout

\end_inset

 is the same as the monoid instance for 
\begin_inset Formula $A\times A$
\end_inset

 computed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

monoidPair[A, A]
\end_layout

\end_inset

 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monoids-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 is a semigroup then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[S]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(S, S)]
\end_layout

\end_inset

 are monoids.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-1-monads-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A framework implements a 
\begin_inset Quotes eld
\end_inset

route
\begin_inset Quotes erd
\end_inset

 type 
\begin_inset Formula $R$
\end_inset

 as 
\begin_inset Formula $R\triangleq Q\rightarrow(E+S)$
\end_inset

, where 
\begin_inset Formula $Q$
\end_inset

 is a query, 
\begin_inset Formula $E$
\end_inset

 is an error response, and 
\begin_inset Formula $S$
\end_inset

 is a success response.
 A server is defined as a combination of several routes.
 For a given query 
\begin_inset Formula $Q$
\end_inset

, the response is the first route (if it exists) that yields a success response.
 Implement the route combination operation and show that it makes 
\begin_inset Formula $R$
\end_inset

 into a semigroup.
 What would be necessary to make 
\begin_inset Formula $R$
\end_inset

 into a monoid?
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the 
\family typewriter
cats
\family default
 library, implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

type F[T] = Try[Seq[T]]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the 
\family typewriter
cats
\family default
 library, implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bifunctor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $B^{X,Y}\triangleq\left(\text{Int}\rightarrow X\right)+Y\times Y$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Profunctor
\end_layout

\end_inset

 typeclass having the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def xmap[A, B](f: A => B, g: B => A): F[A] => F[B]
\end_layout

\end_inset

Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Profunctor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $P^{A}\triangleq A\rightarrow\left(\text{Int}\times A\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for the recursive type 
\begin_inset Formula $Q^{A}\triangleq\text{String}+A\times A\times Q^{A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-8-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-8-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show explicitly that a value 
\begin_inset Formula $\text{wu}_{C}:C^{\bbnum 1}$
\end_inset

 is computationally equivalent to a value 
\begin_inset Formula $\text{pu}_{C}:\forall A.\,C^{A}$
\end_inset

 that satisfies the naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-for-pure-for-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using a function parameterized by the type constructors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 (required to be functors), implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $F^{A}\times G^{A}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 instance for 
\begin_inset Formula $F^{A}\rightarrow G^{A}$
\end_inset

 as a function parameterized by type constructors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, where 
\begin_inset Formula $F^{A}$
\end_inset

 is required to be a contrafunctor and 
\begin_inset Formula $G^{A}$
\end_inset

 is required to be a functor.
 For the contrafunctor 
\begin_inset Formula $F$
\end_inset

, use either the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 typeclass from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Example-6"
plural "false"
caps "false"
noprefix "false"

\end_inset

 or the 
\family typewriter
cats
\family default
 library's typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contravariant
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-9-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-9-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Implement a function with type signature 
\begin_inset Formula $F^{A}+F^{B}\rightarrow F^{A+B}$
\end_inset

 parameterized by a type constructor 
\begin_inset Formula $F$
\end_inset

 (required to be a functor) and by arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 Show that the inverse type signature 
\begin_inset Formula $F^{A+B}\rightarrow F^{A}+F^{B}$
\end_inset

 is not implementable for some functors 
\begin_inset Formula $F$
\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Implement a function with type signature 
\begin_inset Formula $C^{A+B}\rightarrow C^{A}\times C^{B}$
\end_inset

 parameterized by a type constructor 
\begin_inset Formula $C$
\end_inset

 (required to be a contrafunctor) and by arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 Show that the inverse type signature 
\begin_inset Formula $C^{A}\times C^{B}\rightarrow C^{A+B}$
\end_inset

 is not implementable for some contrafunctors 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-9-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-9-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
Implement a function with type signature 
\begin_inset Formula $F^{A\rightarrow B}\rightarrow A\rightarrow F^{B}$
\end_inset

 parameterized by a functor 
\begin_inset Formula $F$
\end_inset

 and arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

.
 Show that the inverse type signature, 
\begin_inset Formula $(A\rightarrow F^{B})\rightarrow F^{A\rightarrow B}$
\end_inset

, cannot be implemented for some functors 
\begin_inset Formula $F$
\end_inset

.
 (Functors admitting a function with that type signature are called 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

; see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tc-Exercise-9-1-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tc-Exercise-9-1-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

*
\end_layout

\begin_layout Standard
(dual O'Connor
\begin_inset Index idx
status open

\begin_layout Plain Layout
Russell O'Connor
\end_layout

\end_inset

) Assume that a functor 
\begin_inset Formula $F$
\end_inset

 admits a function 
\begin_inset Formula $q$
\end_inset

 with type signature
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "52col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B, F[_]: Functor]: F[(A, B)] => (A, F[B])
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -160baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula $q^{A,B}:F^{A\times B}\rightarrow A\times F^{B}$
\end_inset

, additionally satisfying the special laws of identity and associativity:
\begin_inset Formula 
\[
q^{\bbnum 1,B}=f^{:F^{\bbnum 1\times B}}\rightarrow1\times(f\triangleright(1\times b^{:B}\rightarrow b)^{\uparrow F})\quad,\quad\quad q^{A,B\times C}\bef(\text{id}^{A}\boxtimes q^{B,C})=q^{A\times B,C}\quad.
\]

\end_inset

This Scala code illustrates the required laws in full detail:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

      // For any value f: F[(Unit, B)], we first compute
\end_layout

\begin_layout Plain Layout

val (a1, b1) = q[Unit, B, F](f)._1
\end_layout

\begin_layout Plain Layout

      // Then we must have:    a1 == ()   and   b1 == f.map { case (_, b)
 => b }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      // For any value p: F[(A, B, C)], we first compute
\end_layout

\begin_layout Plain Layout

val ((a1: A, b1: B), f1: F[C]) = q[(A, B), C, F](p.map { case (a, b, c) =>
 ((a, b), c) })
\end_layout

\begin_layout Plain Layout

val (a2: A, f2: F[(B, C)]) = q[A, (B, C), F](p.map { case (a, b, c) => (a,
 (b, c)) }
\end_layout

\begin_layout Plain Layout

      // Then we must have:    a1 == a2   and   (b1, f1) == p[B, C, F](f2)
\end_layout

\end_inset

The following naturality law should also hold for 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\[
(f^{:A\rightarrow C}\boxtimes g^{:B\rightarrow D})^{\uparrow F}\bef q^{C,D}=q^{A,B}\bef f\boxtimes(g^{\uparrow F})\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

      // For any value k: F[(A, B)] and any functions f: A => C, g: B =>
 D, first compute
\end_layout

\begin_layout Plain Layout

val (a: A, fb: F[B]) = q[A, B, F](k)  // Then we must have:
\end_layout

\begin_layout Plain Layout

(f(a), fb.map(g)) == q[C, D, F](k.map { case (a, b) => (f(a), g(b)) })
\end_layout

\end_inset

Show that the functor 
\begin_inset Formula $F$
\end_inset

 is co-pointed if a function 
\begin_inset Formula $q$
\end_inset

 with these properties exists.
 Conversely, show that any lawful co-pointed functor 
\begin_inset Formula $F$
\end_inset

 admits a function 
\begin_inset Formula $q$
\end_inset

 with these properties.
\end_layout

\begin_layout Section
Further developments
\end_layout

\begin_layout Subsection
The existence of values for recursive types
\begin_inset CommandInset label
LatexCommand label
name "subsec:Recursive-types-and-the-existence-of-their-values"

\end_inset


\end_layout

\begin_layout Standard
A recursive type 
\begin_inset Formula $T$
\end_inset

 is defined by a type equation such as 
\begin_inset Formula $T\triangleq\bbnum 1+\text{Int}+T\times T$
\end_inset

.
 Can we decide whether such a type equation has a 
\begin_inset Quotes eld
\end_inset

solution
\begin_inset Quotes erd
\end_inset

, i.e., a well-defined type 
\begin_inset Formula $T$
\end_inset

 with values that we can create and manipulate in a program?
\end_layout

\begin_layout Standard
In all examples seen so far, the recursive type equations
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive type equation
\end_layout

\end_inset

 had the form 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 where the type constructor 
\begin_inset Formula $S$
\end_inset

 is a 
\emph on
functor
\emph default
.
 Type equations with non-functor 
\begin_inset Formula $S$
\end_inset

 (e.g., the equation 
\begin_inset Formula $T\triangleq T\rightarrow\text{Int}$
\end_inset

) do not seem to be useful in practice, and we will not consider them in
 this book.
\end_layout

\begin_layout Standard
In a rigorous approach, showing that 
\begin_inset Formula $T$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

solution
\begin_inset Quotes erd
\end_inset

 (called a 
\series bold
fixpoint
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
fixpoint type
\end_layout

\end_inset

) of the type equation 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 means proving that the types 
\begin_inset Formula $T$
\end_inset

 and 
\begin_inset Formula $S^{T}$
\end_inset

 are equivalent (isomorphic).
 We must implement this type isomorphism as two functions, named e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fix
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfix
\end_layout

\end_inset

, satisfying the conditions:
\begin_inset Formula 
\[
\text{fix}:S^{T}\rightarrow T\quad,\quad\quad\text{unfix}:T\rightarrow S^{T}\quad,\quad\quad\text{fix}\bef\text{unfix}=\text{id}\quad,\quad\quad\text{unfix}\bef\text{fix}=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Given a type constructor 
\begin_inset Formula $S$
\end_inset

, we can define the recursive type 
\begin_inset Formula $T$
\end_inset

 with this Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class T(s: S[T])               // Type constructor S[_] must
 be already defined.
\end_layout

\begin_layout Plain Layout

def fix:    S[T] => T   =   { s => T(s) }
\end_layout

\begin_layout Plain Layout

def unfix:  T => S[T]   =   { t => t.s }
\end_layout

\end_inset

We can generalize this code to a 
\begin_inset Quotes eld
\end_inset

fixpoint
\begin_inset Quotes erd
\end_inset

 constructor 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 that is 
\emph on
parameterized
\emph default
 by 
\begin_inset Formula $S$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Fix[S[_]](s: S[Fix[S]])
\end_layout

\begin_layout Plain Layout

def fix[S[_]]:    S[Fix[S]] => Fix[S]   =   { s => Fix(s) }
\end_layout

\begin_layout Plain Layout

def unfix[S[_]]:  Fix[S] => S[Fix[S]]   =   { t => t.s }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In both implementations, the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fix
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfix
\end_layout

\end_inset

 are inverses of each other because they merely wrap and unwrap values within
 a case class.
 So, we are always able to write code that 
\emph on
defines
\emph default
 the recursive type 
\begin_inset Formula $T$
\end_inset

.
 The remaining question is whether we will be able to create values of type
 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
Applying structural analysis to the functor 
\begin_inset Formula $S$
\end_inset

, we begin with the constant functor 
\begin_inset Formula $S^{A}\triangleq Z$
\end_inset

, where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
 The type equation 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 is just 
\begin_inset Formula $T\triangleq Z$
\end_inset

; so, 
\begin_inset Formula $T$
\end_inset

 is not a recursive type.
\end_layout

\begin_layout Standard
The next case is the identity functor 
\begin_inset Formula $S^{A}\triangleq A$
\end_inset

.
 The type equation 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 has the form 
\begin_inset Formula $T\triangleq T$
\end_inset

; since all types 
\begin_inset Formula $T$
\end_inset

 satisfy that equation trivially, we find that the identity functor does
 not define any specific type 
\begin_inset Formula $T$
\end_inset

.
 If we translate this type equation into Scala code, we will run into a
 problem with recursion:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "46col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Id[A] = A
\end_layout

\begin_layout Plain Layout

final case class T(s: Id[T])
\end_layout

\begin_layout Plain Layout

// Equivalent to `final case class T(s: T)`.
\end_layout

\begin_layout Plain Layout

val x = T(x)               // Infinite loop!
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -115baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
A value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

case class T
\end_layout

\end_inset

 can be created only if we supply a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

.
 Writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

def x = T(x)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

val
\end_layout

\end_inset

 does not help: the evaluation of the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

x
\end_layout

\end_inset

 will not terminate.
 We conclude that this recursive definition is invalid: one cannot create
 values of the resulting type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

 is void.
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
infinite loop in type recursion
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, consider a product functor such as 
\begin_inset Formula $S^{A}\triangleq A\times A\times\text{Int}$
\end_inset

.
 Can we create values of type 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "46col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class T(s: (T, T, Int))
\end_layout

\begin_layout Plain Layout

val x = T(s = (x, x, 123))  // Infinite loop!
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We again have an infinite loop when creating values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

.
 As in the example with the identity functor, the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

 requires us to compute some values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

 before we can create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

T
\end_layout

\end_inset

.
 That requirement is impossible to satisfy.
\end_layout

\begin_layout Standard
For some disjunctive type constructors 
\begin_inset Formula $S^{\bullet}$
\end_inset

, values of type 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 are created with no difficulty.
 One example is 
\begin_inset Formula $S^{A}\triangleq\text{Int}+A\times A$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "46col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class T(s: Either[Int, (T, T)])
\end_layout

\begin_layout Plain Layout

val x: T = T(Left(123))     // OK
\end_layout

\begin_layout Plain Layout

val y: T = T(Right(x, x))   // OK
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -100baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We are able to create 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

x
\end_layout

\end_inset

 of type 
\begin_inset Formula $S^{\bbnum 0}\triangleq\text{Int}+\bbnum 0^{:T\times T}$
\end_inset

 without need for any previous values of 
\begin_inset Formula $T$
\end_inset

.
 We can then use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

x
\end_layout

\end_inset

 to create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

y
\end_layout

\end_inset

 of type 
\begin_inset Formula $T$
\end_inset

.
 This resembles defining a value by induction: the base case is the type
 
\begin_inset Formula $\text{Int}+\bbnum 0^{:T\times T}$
\end_inset

, which is a disjunctive part of 
\begin_inset Formula $S^{A}$
\end_inset

 that does 
\emph on
not
\emph default
 contain any values of type 
\begin_inset Formula $A$
\end_inset

.
 The inductive step is the type 
\begin_inset Formula $\bbnum 0^{:\text{Int}}+T\times T$
\end_inset

, which creates a new value of type 
\begin_inset Formula $T$
\end_inset

 from two previous values.
 Type recursion terminates when the base case exists.
\end_layout

\begin_layout Standard
The examples we saw previously, 
\begin_inset Formula $S^{A}\triangleq A$
\end_inset

 and 
\begin_inset Formula $S^{A}\triangleq\text{Int}\times A\times A$
\end_inset

, do not have a base case where a value of type 
\begin_inset Formula $S^{A}$
\end_inset

 could be computed without need for any previous values of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
Given a functor 
\begin_inset Formula $S^{A}$
\end_inset

, how can we determine whether the type recursion 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 terminates? If 
\begin_inset Formula $S^{A}$
\end_inset

 is a 
\emph on
polynomial
\emph default
 functor, we can view 
\begin_inset Formula $S^{A}$
\end_inset

 as a polynomial function of 
\begin_inset Formula $A$
\end_inset

 and reduce it to the form:
\begin_inset Formula 
\begin{equation}
S^{A}\cong C_{0}+C_{1}\times A+C_{2}\times A\times A+...\label{eq:functor-polynomial-normal-form}
\end{equation}

\end_inset

It is clear from this formula that the type 
\begin_inset Formula $C_{0}$
\end_inset

 is found by setting 
\begin_inset Formula $A=\bbnum 0$
\end_inset

 in 
\begin_inset Formula $S^{A}$
\end_inset

, i.e., 
\begin_inset Formula $C_{0}\cong S^{\bbnum 0}$
\end_inset

.
 If we can compute a value 
\begin_inset Formula $c_{0}$
\end_inset

 of type 
\begin_inset Formula $C_{0}$
\end_inset

 (i.e., if 
\begin_inset Formula $C_{0}$
\end_inset

 is not void, 
\begin_inset Formula $C_{0}\not\cong\bbnum 0$
\end_inset

), we get a base-case value 
\begin_inset Formula $t_{0}$
\end_inset

 of type 
\begin_inset Formula $T$
\end_inset

 as:
\begin_inset Formula 
\[
t_{0}^{:T}\triangleq c_{0}^{:C_{0}}+\bbnum 0^{:C_{1}\times A}+\bbnum 0^{:C_{2}\times A\times A}+...
\]

\end_inset

Further values of type 
\begin_inset Formula $T$
\end_inset

 could be computed as 
\begin_inset Formula $c_{1}\times t_{0}$
\end_inset

 or 
\begin_inset Formula $c_{2}\times t_{0}\times t_{0}$
\end_inset

, etc.
\end_layout

\begin_layout Standard
We conclude that the recursive type 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

 defined via a 
\emph on
polynomial
\emph default
 functor 
\begin_inset Formula $S$
\end_inset

 will be non-void (i.e., type recursion will terminate) when the type 
\begin_inset Formula $S^{\bbnum 0}$
\end_inset

 is non-void.
\end_layout

\begin_layout Standard
In the examples 
\begin_inset Formula $S^{A}\triangleq A$
\end_inset

 and 
\begin_inset Formula $S^{A}\triangleq\text{Int}\times A\times A$
\end_inset

, we find 
\begin_inset Formula $S^{\bbnum 0}\cong\bbnum 0$
\end_inset

, so the type recursion is invalid.
\end_layout

\begin_layout Standard
It remains to consider functors 
\begin_inset Formula $S$
\end_inset

 that cannot be reduced to the polynomial form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:functor-polynomial-normal-form"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 As an example, take 
\begin_inset Formula $S^{A}\triangleq\text{String}\times(\text{Int}\rightarrow A)$
\end_inset

.
 For this functor 
\begin_inset Formula $S$
\end_inset

, the condition 
\begin_inset Formula $S^{\bbnum 0}\not\cong\bbnum 0$
\end_inset

 does not hold:
\begin_inset Formula 
\begin{align*}
 & S^{\bbnum 0}\cong\text{String}\times(\gunderline{\text{Int}\rightarrow\bbnum 0})\\
\text{use the type equivalence }\left(\text{Int}\rightarrow\bbnum 0\right)\cong\bbnum 0:\quad & \quad\cong\text{String}\times\bbnum 0\cong\bbnum 0\quad.
\end{align*}

\end_inset

Nevertheless, we can write Scala code implementing values of the type 
\begin_inset Formula $T$
\end_inset

 defined by 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class T(message: String, next: Int => T)
\end_layout

\begin_layout Plain Layout

val t: T = T(
\begin_inset Quotes eld
\end_inset

start
\begin_inset Quotes erd
\end_inset

, n => T(s
\begin_inset Quotes eld
\end_inset

have $n
\begin_inset Quotes erd
\end_inset

, _ => t))   // A recursive `val`.
\end_layout

\end_inset

The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 refers to itself recursively within a nested function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_ => t
\end_layout

\end_inset

, and there is no 
\begin_inset Quotes eld
\end_inset

base case
\begin_inset Quotes erd
\end_inset

 in the type 
\begin_inset Formula $S^{T}$
\end_inset

.
 However, the recursion does not lead to an infinite loop; we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 safely:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> t.next(10)
\end_layout

\begin_layout Plain Layout

res0: T = T(have 10,<function1>)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t.next(10).next(10)
\end_layout

\begin_layout Plain Layout

res1: T = T(start,<function1>)
\end_layout

\end_inset

A value of type 
\begin_inset Formula $T$
\end_inset

 contains a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

 that, when applied, returns a new value of the same type 
\begin_inset Formula $T$
\end_inset

.
 The new value of type 
\begin_inset Formula $T$
\end_inset

 does not need to be computed in advance: its evaluation is 
\emph on
delayed
\emph default
 until some code decides to call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

.
 For this reason, an infinite loop is avoided even though the structure
 functor 
\begin_inset Formula $S$
\end_inset

 has no 
\begin_inset Quotes eld
\end_inset

base case
\begin_inset Quotes erd
\end_inset

.
 Values of type 
\begin_inset Formula $T$
\end_inset

 can be viewed as an infinite stream of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 values computed on demand.
 An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value is required in order to produce the next element of the stream.
 A symbolic (and non-rigorous) representation of that type is:
\begin_inset Formula 
\[
T=\text{String}\times(\text{Int}\rightarrow\text{String}\times(\text{Int}\rightarrow\text{String}\times(\text{Int}\rightarrow\text{String}\times...)))\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
As another example, consider 
\begin_inset Formula $S^{A}\triangleq\bbnum 1\rightarrow\text{String}+\text{Int}\times A$
\end_inset

.
 Using the type equivalence 
\begin_inset Formula $P\cong(\bbnum 1\rightarrow P)$
\end_inset

, we could transform 
\begin_inset Formula $S^{A}$
\end_inset

 into an equivalent functor 
\begin_inset Formula $\tilde{S}^{A}$
\end_inset

 in the polynomial form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:functor-polynomial-normal-form"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\tilde{S}^{A}\triangleq\text{String}+\text{Int}\times A\quad.
\]

\end_inset

Although the types 
\begin_inset Formula $S^{A}$
\end_inset

 and 
\begin_inset Formula $\tilde{S}^{A}$
\end_inset

 are equivalent, the recursive types 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 and 
\begin_inset Formula $\text{Fix}^{\tilde{S}}$
\end_inset

 are different.
 While 
\begin_inset Formula 
\begin{align*}
\text{Fix}^{\tilde{S}} & =\text{String}+\text{Int}\times(\text{String}+\text{Int}\times(\text{String}+\text{Int}\times...))\\
 & \cong\left(\bbnum 1+\text{Int}+\text{Int}\times\text{Int}+\text{Int}\times\text{Int}\times\text{Int}+...\right)\times\text{String}\cong\text{String}\times\text{List}^{\text{Int}}\quad,
\end{align*}

\end_inset

the type 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 admits recursively defined values representing 
\emph on
unbounded
\emph default
 streams of integers, e.g.:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

final case class T(e: () => Either[String, (Int, T)]) // Define the type
 $
\backslash
color{dkgreen} T 
\backslash
triangleq
\backslash
text{String}+
\backslash
text{Int}
\backslash
times T$.
\end_layout

\begin_layout Plain Layout

val t1: T = T(() => Right((1, t1)))                   // Stream [1, 1, 1,
 ...].
\end_layout

\begin_layout Plain Layout

def t2(n: Int): T = T(() => Right((n, t2(n+1))))      // Stream [n, n+1,
 n+2, ...].
\end_layout

\end_inset

The type 
\begin_inset Formula $T\triangleq\text{Fix}^{S}$
\end_inset

 also admits finite streams that may be defined as 
\emph on
non-recursive
\emph default
 values of type 
\begin_inset Formula $T$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t0 = T(() => Right((10, T(() => Left(
\begin_inset Quotes eld
\end_inset

stop
\begin_inset Quotes erd
\end_inset

)))))  // Finite stream [10, 
\begin_inset Quotes eld
\end_inset

stop
\begin_inset Quotes erd
\end_inset

].
\end_layout

\end_inset

We can recognize that 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 has non-recursive values by checking that the type 
\begin_inset Formula $S^{\bbnum 0}$
\end_inset

 is not void:
\begin_inset Formula 
\[
S^{\bbnum 0}=\bbnum 1\rightarrow\text{Int}\times\bbnum 0+\text{String}\cong\bbnum 1\rightarrow\text{String}\cong\text{String}\not\cong\bbnum 0\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
How can we recognize functors 
\begin_inset Formula $S$
\end_inset

 that admit valid recursive values of type 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

? The exponential functor construction (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows that 
\begin_inset Formula $C^{A}\rightarrow P^{A}$
\end_inset

 is a functor when 
\begin_inset Formula $C$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $P$
\end_inset

 is a functor.
 If the type expression for 
\begin_inset Formula $S^{A}$
\end_inset

 contains a sub-expression of the form 
\begin_inset Formula $C^{A}\rightarrow P^{A}$
\end_inset

, how can we implement a value of type 
\begin_inset Formula $C^{T}\rightarrow P^{T}$
\end_inset

? We can use recursion to implement a value of 
\begin_inset Formula $T$
\end_inset

, as long as we can then somehow produce a value of type 
\begin_inset Formula $P^{T}$
\end_inset

 out of a value of type 
\begin_inset Formula $T$
\end_inset

.
 This is precisely the condition for 
\begin_inset Formula $P^{\bullet}$
\end_inset

 to be a pointed functor.
 The contrafunctor 
\begin_inset Formula $C^{A}$
\end_inset

 is an argument of the function of type 
\begin_inset Formula $C^{A}\rightarrow P^{A}$
\end_inset

, so we are not required to produce values of type 
\begin_inset Formula $C^{A}$
\end_inset

— we 
\emph on
consume
\emph default
 those values.
 It follows that we can implement a value of type 
\begin_inset Formula $C^{T}\rightarrow P^{T}$
\end_inset

 (with 
\begin_inset Formula $T=\text{Fix}^{S}$
\end_inset

) as long as 
\begin_inset Formula $P^{\bullet}$
\end_inset

 is a pointed functor.
 As we saw in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Pointed-functors-motivation-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

, a functor 
\begin_inset Formula $P^{\bullet}$
\end_inset

 is pointed if we can compute a value of type 
\begin_inset Formula $P^{\bbnum 1}$
\end_inset

.
\end_layout

\begin_layout Standard
In the example 
\begin_inset Formula $S^{A}\triangleq\text{String}\times(\text{Int}\rightarrow A)$
\end_inset

, the functor 
\begin_inset Formula $S^{A}$
\end_inset

 is pointed since:
\begin_inset Formula 
\[
S^{\bbnum 1}\cong\text{String}\times(\text{Int}\rightarrow\bbnum 1)\cong\text{String}\not\cong\bbnum 0\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
This consideration applies to any sub-expression of the form 
\begin_inset Formula $C^{A}\rightarrow P^{A}$
\end_inset

 within the type constructor 
\begin_inset Formula $S^{A}$
\end_inset

.
 The condition for values of 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 to exist is that every functor 
\begin_inset Formula $P^{A}$
\end_inset

 involved in such sub-expressions should be pointed.
 To check that, we can set the type parameter 
\begin_inset Formula $A=\bbnum 1$
\end_inset

 in all return types of 
\emph on
functions
\emph default
 within 
\begin_inset Formula $S^{A}$
\end_inset

.
 If the resulting type is not void, we will be able to implement a recursively
 defined value of type 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

.
\end_layout

\begin_layout Standard
If the functor 
\begin_inset Formula $S^{A}$
\end_inset

 has the property 
\begin_inset Formula $S^{\bbnum 0}\not\cong\bbnum 0$
\end_inset

 (i.e., we have a base case for the inductive definition of 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

), we will also be able to implement non-recursive values of type 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

.
\end_layout

\begin_layout Standard
We conclude that 
\begin_inset Formula $S^{\bbnum 0}\not\cong\bbnum 0$
\end_inset

 is a 
\emph on
sufficient
\emph default
 condition for the type 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 to be non-void.
 If 
\begin_inset Formula $S$
\end_inset

 is a polynomial functor, this condition is also a necessary condition.
 For exponential-polynomial functors 
\begin_inset Formula $S$
\end_inset

, recursive values of type 
\begin_inset Formula $\text{Fix}^{S}$
\end_inset

 can be implemented if every function-type sub-expression 
\begin_inset Formula $C^{A}\rightarrow P^{A}$
\end_inset

 in 
\begin_inset Formula $S^{A}$
\end_inset

 involves a pointed functor 
\begin_inset Formula $P$
\end_inset

 (i.e., if 
\begin_inset Formula $P^{\bbnum 1}\not\cong\bbnum 0$
\end_inset

).
\end_layout

\begin_layout Subsection
Proofs of associativity of 
\family typewriter
concat
\family default
 for lists and arrays
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proofs-for-associativity-law-lists-and-arrays-concat"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 function is defined for both lists and arrays, and works similarly for
 these data types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Array.concat(Array(1, 2), Array(3, 4), Array(5, 6))
\end_layout

\begin_layout Plain Layout

res0: Array[Int] = Array(1, 2, 3, 4, 5, 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List.concat(List(1, 2), List(3, 4), List(5, 6))
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6)
\end_layout

\end_inset

In this section, we will show rigorously that concatenation is an associative
 operation.
\end_layout

\begin_layout Standard
In Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[A]
\end_layout

\end_inset

 is a sequence whose elements can be accessed by index.
 The array access function (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

apply
\end_layout

\end_inset

 method defined on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 class) is a partial function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

 whose integer argument must be between 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $n-1$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the array length:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x = Array("a", "b", "c")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x(2)  // The syntax `x(2)` is the same as `x.apply(2)`.
 
\end_layout

\begin_layout Plain Layout

res2: String = c
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x(3)  // Applying the partial function `x.apply` to the value 3 will
 fail:
\end_layout

\begin_layout Plain Layout

java.lang.ArrayIndexOutOfBoundsException: 3
\end_layout

\end_inset

We can denote the type of this function by 
\begin_inset Formula $\text{Int}_{[0,n-1]}\rightarrow A$
\end_inset

 to indicate the bounds of the index.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type constructor is a recursive disjunctive type defined by the type equation:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}=\bbnum 1+A+A\times A+A\times A\times A+...
\]

\end_inset

Although the definitions of types are different, lists and arrays are conceptual
ly similar — they are both sequences of values of type 
\begin_inset Formula $A$
\end_inset

.
 However, proving properties is easier for non-recursive types than for
 recursive types.
 We begin by proving the associativity property of the array concatenation.
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-concat-array-associativity"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-concat-array-associativity"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For arrays, 
\begin_inset Formula $\text{Array}_{n}^{A}\triangleq\text{Int}_{[0,n-1]}\rightarrow A$
\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 function (denoted 
\begin_inset Formula $\pplus$
\end_inset

) defined by:
\begin_inset Formula 
\[
a_{1}^{:\text{Array}_{n_{1}}^{A}}\pplus a_{2}^{:\text{Array}_{n_{2}}^{A}}\triangleq i^{:\text{Int}_{[0,n_{1}+n_{2}-1]}}\rightarrow\begin{cases}
0\leq i<n_{1}: & a_{1}(i)\\
n_{1}\leq i<n_{1}+n_{2}: & a_{2}(i-n_{1})
\end{cases}
\]

\end_inset

satisfies the associativity law:
\begin_inset Formula 
\[
(a_{1}\pplus a_{2})\pplus a_{3}=a_{1}\pplus(a_{2}\pplus a_{3})\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Both sides of the law evaluate to the same partial function of type 
\begin_inset Formula $\text{Int}\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
(a_{1}\pplus a_{2})\pplus a_{3}=a_{1}\pplus(a_{2}\pplus a_{3})=i^{:\text{Int}_{[0,n_{1}+n_{2}+n_{3}-1]}}\rightarrow\begin{cases}
0\leq i<n_{1}: & a_{1}(i)\\
n_{1}\leq i<n_{1}+n_{2}: & a_{2}(i-n_{1})\\
n_{1}+n_{2}\leq i<n_{1}+n_{2}+n_{3}: & a_{3}(i-n_{1}-n_{2})
\end{cases}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Now we establish a rigorous equivalence between the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 types.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-array-list-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-array-list-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The type 
\begin_inset Formula $\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}$
\end_inset

 is equivalent to 
\begin_inset Formula $\text{Array}_{n}^{A}\triangleq\text{Int}_{[0,n-1]}\rightarrow A$
\end_inset

, where 
\begin_inset Formula $n\geq0$
\end_inset

 and 
\begin_inset Formula $\text{Int}_{[0,n-1]}$
\end_inset

 is the (possibly empty) subset of integers 
\begin_inset Formula $i$
\end_inset

 within the range 
\begin_inset Formula $0\leq i\leq n-1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to implement two isomorphism maps 
\begin_inset Formula $f_{1}$
\end_inset

, 
\begin_inset Formula $f_{2}$
\end_inset

 and show that:
\begin_inset Formula 
\[
f_{1}:\text{Array}_{n}^{A}\rightarrow\text{List}^{A}\quad,\quad\quad f_{2}:\text{List}^{A}\rightarrow\text{Array}_{n}^{A}\quad,\quad\quad f_{1}\bef f_{2}=\text{id}\quad,\quad\quad f_{2}\bef f_{1}=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To implement 
\begin_inset Formula $f_{1}$
\end_inset

, we proceed by induction in 
\begin_inset Formula $n$
\end_inset

.
 The base case is 
\begin_inset Formula $n=0$
\end_inset

, and we map 
\begin_inset Formula $\text{Array}_{0}$
\end_inset

 into an empty list.
 The inductive step assumes that 
\begin_inset Formula $f_{1}$
\end_inset

 is already defined on arrays of length 
\begin_inset Formula $n$
\end_inset

, and we now need to define 
\begin_inset Formula $f_{1}$
\end_inset

 for arrays of length 
\begin_inset Formula $n+1$
\end_inset

.
 An array of length 
\begin_inset Formula $n+1$
\end_inset

 is a partial function 
\begin_inset Formula $g^{:\text{Int}_{[0,n]}\rightarrow A}$
\end_inset

 defined on the integer interval 
\begin_inset Formula $[0,n]$
\end_inset

.
 We now split that array into its first element, 
\begin_inset Formula $g(0)$
\end_inset

, and the rest of the array, which needs to be represented by another partial
 function, say 
\begin_inset Formula $g'\triangleq i\rightarrow g(i+1)$
\end_inset

, defined on the integer interval 
\begin_inset Formula $[0,n-1]$
\end_inset

.
 The function 
\begin_inset Formula $g$
\end_inset

 represents an array of length 
\begin_inset Formula $n$
\end_inset

.
 By the inductive assumption, 
\begin_inset Formula $f_{1}$
\end_inset

 is already defined for arrays of length 
\begin_inset Formula $n$
\end_inset

.
 So, we can compute 
\begin_inset Formula $f_{1}(g'):\text{List}^{A}$
\end_inset

 and thus create a value of type 
\begin_inset Formula $\bbnum 0+A\times\text{List}^{A}$
\end_inset

, which is equivalent to a value of type 
\begin_inset Formula $\text{List}^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A](arr: Array[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  if (arr.length == 0) List()
\end_layout

\begin_layout Plain Layout

  else arr(0) :: f1(arr.tail)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -125baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -125baselineskip%
\end_inset


\begin_inset Formula 
\begin{align*}
f_{1}(\text{Array}_{0}^{A}) & \triangleq\bbnum 1+\bbnum 0^{:A\times\text{List}^{A}}\quad,\\
f_{1}(g^{:\text{Int}_{[0,n]}\rightarrow A}) & \triangleq\bbnum 0+g(0)^{:A}\times\overline{f_{1}}(i\rightarrow g(i+1))\quad.
\end{align*}

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Standard
To implement 
\begin_inset Formula $f_{2}$
\end_inset

, we use induction in the structure of the list.
 The length 
\begin_inset Formula $n$
\end_inset

 of the array is not known in advance and needs to be computed as we perform
 pattern matching on the given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 value.
 The base case is an empty list, which yields an empty array (i.e., an array
 of length 
\begin_inset Formula $n=0$
\end_inset

).
 In the inductive step, we assume that we already defined 
\begin_inset Formula $f_{2}$
\end_inset

 on lists of length 
\begin_inset Formula $n$
\end_inset

, and we now need to define 
\begin_inset Formula $f_{2}$
\end_inset

 for lists of length 
\begin_inset Formula $n+1$
\end_inset

.
 Such a list must have the form 
\begin_inset Formula $\bbnum 0+x^{:A}\times s^{:\text{List}^{A}}$
\end_inset

, where 
\begin_inset Formula $s$
\end_inset

 is a list of length 
\begin_inset Formula $n$
\end_inset

.
 By the inductive assumption, we are allowed to apply 
\begin_inset Formula $f_{2}$
\end_inset

 to 
\begin_inset Formula $s$
\end_inset

 and obtain an array of length 
\begin_inset Formula $n$
\end_inset

, i.e., a partial function 
\begin_inset Formula $g^{:\text{Int}_{[0,n-1]}\rightarrow A}$
\end_inset

.
 So we define 
\begin_inset Formula $f_{2}(\bbnum 0+x\times s)$
\end_inset

 as a new array whose 
\begin_inset Formula $0^{\text{th}}$
\end_inset

 element is 
\begin_inset Formula $x$
\end_inset

 and the 
\begin_inset Formula $i^{\text{th}}$
\end_inset

 element is computed by applying the function 
\begin_inset Formula $g\triangleq f_{2}(s)$
\end_inset

 to 
\begin_inset Formula $i-1$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "43.63col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A: ClassTag]: List[A] => Array[A] =
\end_layout

\begin_layout Plain Layout

{  case List()   => Array()
\end_layout

\begin_layout Plain Layout

   case x :: s   => Array(x) ++ f2.apply(s)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -125baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -125baselineskip%
\end_inset


\begin_inset Formula 
\begin{align*}
f_{2}(\bbnum 1+\bbnum 0^{:A\times\text{List}^{A}}) & \triangleq\text{Array}_{0}^{A}\quad,\\
f_{2}(\bbnum 0+x^{:A}\times s^{:\text{List}^{A}}) & \triangleq i^{:\text{Int}_{[0,n]}}\rightarrow\begin{cases}
i=0: & x\quad,\\
i\geq1: & \overline{f_{2}}(s)(i-1)\quad.
\end{cases}
\end{align*}

\end_inset


\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are inverse functions for each other, we again need to use induction.
 The base case is the empty list and the empty array, which are indeed mapped
 isomorphically to each other.
 The inductive step for 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 is an array of length 
\begin_inset Formula $n+1$
\end_inset

 with the inductive assumption that 
\begin_inset Formula $\overline{f_{1}\bef f_{2}}=\text{id}$
\end_inset

 for arrays of length 
\begin_inset Formula $n$
\end_inset

.
 Writing out the code of 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

, we find that 
\begin_inset Formula $g\triangleright f_{1}\bef f_{2}=g$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & g^{:\text{Int}_{[0,n]}\rightarrow A}\triangleright f_{1}\bef f_{2}=g\triangleright f_{1}\triangleright f_{2}=(\bbnum 0+g(0)\times\overline{f_{1}}(i\rightarrow g(i+1)))\triangleright f_{2}\\
 & =i\rightarrow\begin{cases}
i=0: & g(0)\\
i\geq1: & \gunderline{\overline{f_{2}}(\overline{f_{1}}}(i\rightarrow g(i+1)))(i-1)
\end{cases}=i\rightarrow\begin{cases}
i=0: & g(0)\\
i\geq1: & \gunderline{\text{id}}(i\rightarrow g(i+1)))(i-1)
\end{cases}\\
 & =i\rightarrow\begin{cases}
i=0: & g(0)\\
i\geq1: & g(\gunderline{\left(i-1\right)+1})
\end{cases}=\left(i\rightarrow g(i)\right)=g.
\end{align*}

\end_inset

Similarly, we find that 
\begin_inset Formula $(\bbnum 0+x^{:A}\times s^{:\text{List}^{A}})\triangleright f_{2}\bef f_{1}=(\bbnum 0+x^{:A}\times s^{:\text{List}^{A}})$
\end_inset

 via this calculation:
\begin_inset Formula 
\begin{align*}
 & (\bbnum 0+x^{:A}\times s^{:\text{List}^{A}})\triangleright f_{2}\bef f_{1}=f_{1}\left(i^{:\text{Int}_{[0,n]}}\rightarrow\begin{cases}
i=0: & x\\
i\geq1: & \overline{f_{2}}(s)(i-1)
\end{cases}\right)\\
 & =\bbnum 0+x\times\overline{f_{1}}(\gunderline{i\rightarrow\overline{f_{2}}(s)(i+1-1)})=\bbnum 0+x\times\gunderline{\overline{f_{1}}(\overline{f_{2}}}(s))=\bbnum 0+x\times s\quad.
\end{align*}

\end_inset

This concludes the proof of the isomorphism between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Since arrays and lists are isomorphic as types, the concatenation for lists
 is associative as long as we show that the concatenation operation for
 lists is isomorphic to that we defined for arrays.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-concat-array-as-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-concat-array-as-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 function for lists is defined recursively as:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "38col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -75baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def concat[A](p: List[A], q: List[A])
\end_layout

\begin_layout Plain Layout

    : List[A] = p match {
\end_layout

\begin_layout Plain Layout

  case List() => q
\end_layout

\begin_layout Plain Layout

  case a :: t => a :: concat(t, q)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -250baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -90baselineskip%
\end_inset


\begin_inset Formula 
\[
p^{:\text{List}^{A}}\pplus q^{:\text{List}^{A}}\triangleq p\triangleright\begin{array}{|c||c|}
 & \text{List}^{A}\\
\hline \bbnum 1 & q\\
A\times\text{List}^{A} & a\times t\rightarrow\bbnum 0+a\times(t\overline{\pplus}q)
\end{array}\quad,
\]

\end_inset

and is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 function on arrays defined in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-concat-array-associativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
\forall a^{:\text{Array}_{n_{1}}^{A}},b^{:\text{Array}_{n_{2}}^{A}}.\quad & f_{1}(a)\pplus f_{1}(b)=f_{1}(a\pplus b)\quad,\\
\forall p^{:\text{List}^{A}},q^{:\text{List}^{A}}.\quad & f_{2}(p)\pplus f_{2}(q)=f_{2}(p\pplus q)\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $f_{1}$
\end_inset

, 
\begin_inset Formula $f_{2}$
\end_inset

 are the isomorphism maps defined in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-array-list-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
If we show the property for 
\begin_inset Formula $f_{2}$
\end_inset

, we can apply 
\begin_inset Formula $f_{1}$
\end_inset

 to both sides and obtain the other property.
\end_layout

\begin_layout Standard
The base case for lists is 
\begin_inset Formula $[]\pplus q=q$
\end_inset

.
 This is clearly isomorphic to concatenating an empty array with another
 array since 
\begin_inset Formula $f_{2}([])$
\end_inset

 is an empty array.
 
\end_layout

\begin_layout Standard
The inductive step is 
\begin_inset Formula $p\pplus q$
\end_inset

 where 
\begin_inset Formula $p$
\end_inset

 is a non-empty list, 
\begin_inset Formula $p=\bbnum 0+a^{:A}\times t^{:\text{List}^{A}}$
\end_inset

.
 We need to show that:
\begin_inset Formula 
\[
f_{2}(\bbnum 0+a\times t)\pplus f_{2}(q)=f_{2}((\bbnum 0+a\times t)\pplus q)=f_{2}(\bbnum 0+a\times(t\pplus q))\quad.
\]

\end_inset

By definition of 
\begin_inset Formula $f_{2}$
\end_inset

, we have:
\begin_inset Formula 
\begin{align*}
 & f_{2}(\bbnum 0+a\times t)=i\rightarrow\begin{cases}
i=0: & a\\
i\geq1: & \overline{f_{2}}(t)(i-1)
\end{cases}\quad,\\
 & f_{2}(\bbnum 0+a\times(t\pplus q))=i\rightarrow\begin{cases}
i=0: & a\\
i\geq1: & \overline{f_{2}}(t\pplus q)(i-1)
\end{cases}\quad.
\end{align*}

\end_inset

The inductive assumption guarantees that 
\begin_inset Formula $\overline{f_{2}}(t\pplus q)=f_{2}(t)\pplus f_{2}(q)$
\end_inset

.
 Using the definition of array concatenation and assuming that the length
 of 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $n_{1}$
\end_inset

 and the length 
\begin_inset Formula $q$
\end_inset

 is 
\begin_inset Formula $n_{2}$
\end_inset

, we get:
\begin_inset Formula 
\[
f_{2}(\bbnum 0+a\times(t\pplus q))=i\rightarrow\begin{cases}
i=0: & a\\
1\leq i<n_{1}+1: & f_{2}(t)(i-1)\\
n_{1}+1\leq i<n_{1}+1+n_{2}: & f_{2}(q)(i-n_{1}-1)
\end{cases}\quad.
\]

\end_inset

This is the same array as the concatenation 
\begin_inset Formula $f_{2}(\bbnum 0+a\times t)\pplus f_{2}(q)$
\end_inset

.
 This concludes the proof.
\end_layout

\begin_layout Subsection
Higher-order type functions.
 Kinds
\end_layout

\begin_layout Standard
Type constructors are types parameterized by other types.
 We have also seen types parameterized by type constructors, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Functor[F[_]] { ...
 }
\end_layout

\end_inset

It is important to distinguish the ways in which types can be parameterized.
 A type constructor such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 can be seen as a type-to-type function (TTF): given a type, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, it produces another type, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

.
 It is a type error to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 to a type parameter that is not a simple type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: List[List] = ???
\end_layout

\begin_layout Plain Layout

<console>:11: error: type List takes type parameters
\end_layout

\begin_layout Plain Layout

       val x: List[List] = ???
\end_layout

\begin_layout Plain Layout

                   ^
\end_layout

\end_inset

To describe the restriction on possible type parameters of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, we say that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 has 
\series bold
kind signature
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
kind signature
\end_layout

\end_inset

 
\begin_inset Formula $*\rightarrow*$
\end_inset

.
 The symbol 
\begin_inset Formula $*$
\end_inset

 means an ordinary type (not a type function), i.e., a type that can have
 values.
 In the type notation, we can write 
\begin_inset Quotes eld
\end_inset

kind signatures
\begin_inset Quotes erd
\end_inset

 as:
\begin_inset Formula 
\[
\text{Int}:*\quad,\quad\quad\text{List}:*\rightarrow*\quad,\quad\quad\text{List}^{\text{Int}}:*\quad.
\]

\end_inset

So, the concept of 
\begin_inset Quotes eld
\end_inset


\series bold
kind
\series default

\begin_inset Quotes erd
\end_inset

 can be understood as the 
\begin_inset Quotes eld
\end_inset

type signature of a type
\begin_inset Quotes erd
\end_inset

.
 Types of kind 
\begin_inset Formula $*$
\end_inset

 (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

) can have values, but types of kind 
\begin_inset Formula $*\rightarrow*$
\end_inset

 cannot:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: Seq = ???
\end_layout

\begin_layout Plain Layout

<console>:11: error: type Seq takes type parameters
\end_layout

\begin_layout Plain Layout

       val x: Seq = ???
\end_layout

\begin_layout Plain Layout

              ^
\end_layout

\end_inset

Although Scala will check that all kinds match, there is no syntax in Scala
 to declare kinds.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 typeclass is another example of a non-trivial 
\begin_inset Quotes eld
\end_inset

kind
\begin_inset Quotes erd
\end_inset

: a type whose type parameter is itself a type constructor.
\begin_inset Formula 
\[
\text{Functor}:(*\rightarrow*)\rightarrow*\quad.
\]

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 type can be seen as a higher-order type-to-type function (TTF) since it
 takes a type parameter that is itself a TTF.
\begin_inset Index idx
status open

\begin_layout Plain Layout
higher-order type function
\end_layout

\end_inset

 Such types are often called 
\begin_inset Quotes eld
\end_inset

higher-kinded types
\begin_inset Index idx
status open

\begin_layout Plain Layout
types!higher-kinded
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
For higher-order TTFs, Scala requires syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[F[_]]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[_[_]]
\end_layout

\end_inset

, for example:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

// Ap1 and Ap2 will simply substitute type arguments into type constructors
 of various kinds.
\end_layout

\begin_layout Plain Layout

type Ap1[F[_], A] = F[A]   // $
\backslash
text{Ap1} : ((*
\backslash
rightarrow*) 
\backslash
times*)
\backslash
rightarrow* $
\end_layout

\begin_layout Plain Layout

type Ap2[P[_[_], _], Q[_], R] = P[Q, R] // Ap2: $
\backslash
color{dkgreen}(((*
\backslash
rightarrow*)
\backslash
times*
\backslash
rightarrow*)
\backslash
times(*
\backslash
rightarrow*)
\backslash
times*)
\backslash
rightarrow* $
\end_layout

\begin_layout Plain Layout

type G[A] = Either[(A, A, String), A]   // G: $
\backslash
color{dkgreen} *
\backslash
rightarrow* $
\end_layout

\begin_layout Plain Layout

type X = Ap2[Ap, G, Int]   // OK; X is now Either[(Int, Int, String), Int]
\end_layout

\begin_layout Plain Layout

type Y = Ap2[Ap, Ap, Int]  // Type error: the second argument of Ap2 has
 wrong kind.
\end_layout

\begin_layout Plain Layout

type Z = Ap2[G, G, Int]    // Type error: the first argument of Ap2 has
 wrong kind.
\end_layout

\end_inset

The 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin is often needed when writing code with higher-order TTFs:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

// `Twice` will apply the type constructor Q twice to its type argument,
 and substitute into P.
\end_layout

\begin_layout Plain Layout

type Twice[P[_[_], _], Q[_], R] = P[Lambda[X => Q[Q[X]]], R] // Twice$
\backslash
color{dkgreen}:(((*
\backslash
rightarrow*)
\backslash
times*
\backslash
rightarrow*)
\backslash
times(*
\backslash
rightarrow*)
\backslash
times*)
\backslash
rightarrow* $
\end_layout

\begin_layout Plain Layout

type O2[A] = Option[(A, A)]                                  // O2: $
\backslash
color{dkgreen}* 
\backslash
rightarrow *$
\end_layout

\begin_layout Plain Layout

type X2 = Twice[Ap1, O2, Int]         // X2 is now Option[(Option[(Int,
 Int)], Option[(Int, Int)])].
\end_layout

\begin_layout Plain Layout

val x2: X2 = Some((Some((1, 2)), Some((3, 4))))   // Types match for `x2`.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inductive typeclasses and their properties
\begin_inset CommandInset label
LatexCommand label
name "subsec:Inductive-typeclasses"

\end_inset


\end_layout

\begin_layout Standard
We have seen many examples of typeclasses that have similar structural propertie
s.
 For instance, a product of semigroups is a semigroup, a product of monoids
 is a monoid, a product of functors is a functor, a product of pointed functors
 is a pointed functor, and so on.
 It turns out that all these typeclasses have a common structure that simplifies
 reasoning.
 The common structure is that all typeclass methods can be expressed as
 a 
\emph on
single
\emph default
 uncurried function of a specific form 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

, as Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Types-of-typeclass-instance-values"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Typeclass
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Instance type as a function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Inductive form
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Structure functor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
default value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $P^{A}\triangleq\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
semigroup
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $P^{A}\triangleq A\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
monoid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+A\times A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
functor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $F^{A}\times\left(A\rightarrow B\right)\rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{\bullet,F}\rightarrow F^{\bullet}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{B,F^{\bullet}}\triangleq\forall A.\,F^{A}\times\left(A\rightarrow B\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
pointed functor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $B+F^{A}\times\left(A\rightarrow B\right)\rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{\bullet,F}\rightarrow F^{\bullet}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{B,F^{\bullet}}\triangleq\forall A.\,B+F^{A}\times\left(A\rightarrow B\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
contrafunctor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $F^{A}\times(B\rightarrow A)\rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{\bullet,F}\rightarrow F^{\bullet}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{B,F^{\bullet}}\triangleq\forall A.\,F^{A}\times\left(B\rightarrow A\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
pointed contrafunctor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+F^{A}\times\left(B\rightarrow A\right)\rightarrow F^{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{\bullet,F}\rightarrow F^{\bullet}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{B,F^{\bullet}}\triangleq\forall A.\,\bbnum 1+F^{A}\times\left(B\rightarrow A\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Structure of typeclass instance values for various inductive typeclasses.
\begin_inset CommandInset label
LatexCommand label
name "tab:Types-of-typeclass-instance-values"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Functions of type 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 compute new values of type 
\begin_inset Formula $A$
\end_inset

 from previous values (of type 
\begin_inset Formula $A$
\end_inset

 or other types) wrapped by the functor 
\begin_inset Formula $P$
\end_inset

.
 This superficially resembles defining values of type 
\begin_inset Formula $A$
\end_inset

 by induction and so motivates the following definition: A typeclass is
 
\series bold
inductive
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
inductive typeclass
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!inductive
\end_layout

\end_inset

 if a type 
\begin_inset Formula $A$
\end_inset

's typeclass instance is a value of type 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 with some functor 
\begin_inset Formula $P$
\end_inset

 called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
structure functor of a typeclass
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!structure functor
\end_layout

\end_inset


\series bold
structure functor
\series default
 of the typeclass.
 
\end_layout

\begin_layout Standard
A value of type 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 contains all the methods of the inductive typeclass in a single function.
 We can implement this definition by the Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class InductiveTypeclass[P[_]: Functor, A](methods: P[A] => A)
\end_layout

\end_inset

For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass is inductive because its instances have type:
\begin_inset Formula 
\[
\text{Monoid}^{A}=\left(A\times A\rightarrow A\right)\times A\cong(\bbnum 1+A\times A\rightarrow A)=P^{A}\rightarrow A\quad\text{ where }P^{A}\triangleq\bbnum 1+A\times A\quad.
\]

\end_inset

So, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass can be declared as an inductive typeclass by code like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class MonoidStructure[A](s: Option[(A, A)])
\end_layout

\begin_layout Plain Layout

val monoidStructureFunctor: Functor[MonoidStructure] = ...
 /* implementation */
\end_layout

\begin_layout Plain Layout

type InductiveMonoid[A] = InductiveTypeclass[MonoidStructure, A]
\end_layout

\end_inset

Implementing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass via a structure functor 
\begin_inset Formula $P$
\end_inset

 and a function 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 is inconvenient for practical programming.
 The inductive form 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 is mainly useful for reasoning about general properties of typeclasses.
 To illustrate that kind of reasoning, we will show that the product-type,
 the function-type, and the recursive-type constructions work for all inductive
 typeclasses.
 
\end_layout

\begin_layout Standard
Consider an arbitrary inductive typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC
\end_layout

\end_inset

 defined via a structure functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type P[A] = ...
\end_layout

\begin_layout Plain Layout

type TC[A] = P[A] => A
\end_layout

\end_inset

If two types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 have an instance of the typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC
\end_layout

\end_inset

, an instance for the product 
\begin_inset Formula $A\times B$
\end_inset

 can be derived automatically using the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

productTC
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def productTC[A, B](f: P[A] => A, g: P[B] => B): P[(A, B)] => (A, B) =
\end_layout

\begin_layout Plain Layout

  p => ( f(p.map(_._1)), g(p.map(_._2)) )
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{productTC} & :(P^{A}\rightarrow A)\times(P^{B}\rightarrow B)\rightarrow P^{A\times B}\rightarrow A\times B\quad,\\
\text{productTC} & \triangleq(f^{:P^{A}\rightarrow A}\times g^{:P^{B}\rightarrow B})\rightarrow p^{:P^{A\times B}}\rightarrow(p\triangleright\pi_{1}^{\uparrow P}\triangleright f)\times(p\triangleright\pi_{2}^{\uparrow P}\triangleright g)\quad.
\end{align*}

\end_inset

This explains why product types have instances for all typeclasses listed
 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Types-of-typeclass-instance-values"
plural "false"
caps "false"
noprefix "false"

\end_inset

: those typeclasses are inductive.
 (However, this argument does not prove that the 
\emph on
laws
\emph default
 of a given typeclass will also hold for the product types.)
\end_layout

\begin_layout Standard
It is interesting to note that the co-product construction cannot be derived
 in general for arbitrary inductive typeclasses: given 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 and 
\begin_inset Formula $P^{B}\rightarrow B$
\end_inset

, it is not guaranteed that we can compute 
\begin_inset Formula $P^{A+B}\rightarrow A+B$
\end_inset

.
 Not all inductive typeclasses support the co-product construction (although
 many do).
\end_layout

\begin_layout Standard
The function-type construction promises a typeclass instance for 
\begin_inset Formula $E\rightarrow A$
\end_inset

 if the type 
\begin_inset Formula $A$
\end_inset

 has a typeclass instance.
 This construction works for any inductive typeclass because a value of
 type 
\begin_inset Formula $P^{E\rightarrow A}\rightarrow E\rightarrow A$
\end_inset

 can be computed from a value of type 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 when 
\begin_inset Formula $P$
\end_inset

 is a functor:
\begin_inset Formula 
\[
q:(P^{A}\rightarrow A)\rightarrow P^{E\rightarrow A}\rightarrow E\rightarrow A\quad,\quad\quad q\triangleq h^{:P^{A}\rightarrow A}\rightarrow p^{:P^{E\rightarrow A}}\rightarrow e^{:E}\rightarrow p\triangleright(x^{:E\rightarrow A}\rightarrow e\triangleright x)^{\uparrow P}\triangleright h\quad.
\]

\end_inset

As in the case of the product construction, the laws still need to be checked
 for the new instances.
\end_layout

\begin_layout Standard
Finally, let us show that the recursive type construction works for inductive
 typeclasses.
 Consider a recursive type 
\begin_inset Formula $T$
\end_inset

 defined by a type equation 
\begin_inset Formula $T\triangleq S^{T}$
\end_inset

, where the functor 
\begin_inset Formula $S^{\bullet}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

preserves
\begin_inset Quotes erd
\end_inset

 typeclass instances: if 
\begin_inset Formula $A$
\end_inset

 has an instance then 
\begin_inset Formula $S^{A}$
\end_inset

 also does, as we saw in all our examples in this chapter.
 In other words, we have a function 
\begin_inset Formula $\text{tcS}:(P^{A}\rightarrow A)\rightarrow P^{S^{A}}\rightarrow S^{A}$
\end_inset

 that creates typeclass instances of type 
\begin_inset Formula $P^{S^{A}}\rightarrow S^{A}$
\end_inset

 out of instances of type 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

.
 Then we define an instance 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tcT
\end_layout

\end_inset

 for 
\begin_inset Formula $T$
\end_inset

 as:
\begin_inset Formula 
\[
\text{tcT}^{:P^{T}\rightarrow T}\triangleq p^{:P^{T}}\rightarrow\text{tcS}\,(\overline{\text{tcT}})(p)\quad.
\]

\end_inset

This recursive definition terminates because it is implemented as an expanded
 function.
 The types match since we can convert between the equivalent types 
\begin_inset Formula $T$
\end_inset

 and 
\begin_inset Formula $S^{T}$
\end_inset

 whenever necessary, so 
\begin_inset Formula $p^{:P^{T}}$
\end_inset

 can be converted to a value of type 
\begin_inset Formula $P^{S^{T}}$
\end_inset

, while the value 
\begin_inset Formula $\text{tcS}\,(\text{tcT})(p)$
\end_inset

 can be converted from type 
\begin_inset Formula $S^{T}$
\end_inset

 back to type 
\begin_inset Formula $T$
\end_inset

.
 In Scala code, the conversions between 
\begin_inset Formula $T$
\end_inset

 and 
\begin_inset Formula $S^{T}$
\end_inset

 are implemented by the constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T(...)
\end_layout

\end_inset

 and accessor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_.s)
\end_layout

\end_inset

 methods of the case class that wraps the type 
\begin_inset Formula $T$
\end_inset

.
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

type S[A] = ...
               // Define a functor S as required.
\end_layout

\begin_layout Plain Layout

final case class T(s: S[T])   // Define the recursive type T as ${ 
\backslash
color{dkgreen}
\backslash
scriptstyle{T
\backslash
triangleq 
\backslash
,S^{T}} }$.
\end_layout

\begin_layout Plain Layout

def tcS: TC[A] => TC[S[A]] = ...
 // Compute instances for S[A] from instances of A.
\end_layout

\begin_layout Plain Layout

def tcT: P[T] => T = p => T(tcS(tcT)(p.map(_.s))) // Define the recursive
 instance.
\end_layout

\end_inset

In this way, we can implement the recursive-type construction with any inductive
 typeclass.
 (The typeclass laws still need to be checked for the recursively defined
 instances.)
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset

 typeclasses are also inductive.
 Instead of a structure functor, we need to use a higher-order type function
 denoted by 
\begin_inset Formula $S^{A,F^{\bullet}}$
\end_inset

 and parameterized by a type constructor 
\begin_inset Formula $F^{\bullet}$
\end_inset

 as well as by a type parameter 
\begin_inset Formula $A$
\end_inset

.
 (The type 
\begin_inset Formula $S$
\end_inset

 has kind 
\begin_inset Formula $*\times(*\rightarrow*)\rightarrow*$
\end_inset

.) The methods of these typeclasses are expressed as 
\begin_inset Formula $S^{\bullet,F}\rightarrow F^{\bullet}$
\end_inset

, which is analogous to 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 except for additional type parameters.
 Similar arguments can be made for these typeclasses, although it is more
 difficult to reason about type constructors (and the laws will not hold
 without additional assumptions).
 As we have seen, the product-type, the function-type, and the recursive-type
 constructions work for functors, contrafunctors, pointed functors, and
 pointed contrafunctors.
\end_layout

\begin_layout Standard
Important inductive typeclasses are functors and contrafunctors (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

), filterables (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Filterable-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

), monads (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Semimonads-and-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and applicatives (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We will see in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Free-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that another general construction also works for all inductive typeclasses,
 — the 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 type construction.
\end_layout

\begin_layout Standard
We have also seen examples of typeclasses that are 
\emph on
not
\emph default
 inductive.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset

 typeclass has instances of type 
\begin_inset Formula $A\rightarrow Z$
\end_inset

, which is not of the form 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 for any functor 
\begin_inset Formula $P$
\end_inset

.
 Another such typeclass is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Copointed
\end_layout

\end_inset

, whose method 
\begin_inset Formula $F^{A}\rightarrow A$
\end_inset

 is not of the form 
\begin_inset Formula $S^{\bullet,F}\rightarrow F^{\bullet}$
\end_inset

.
 However, the methods of these typeclasses can be written in the inverted
 form 
\begin_inset Formula $A\rightarrow P^{A}$
\end_inset

 with some functor 
\begin_inset Formula $P$
\end_inset

.
 We call them 
\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!co-inductive
\end_layout

\end_inset


\series bold
co-inductive
\series default
 
\series bold
typeclasses
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
co-inductive typeclass
\end_layout

\end_inset

.
 A motivation for this name is that the 
\emph on
co-product
\emph default
 construction (rather than the product construction) works with co-inductive
 typeclasses: given values of types 
\begin_inset Formula $A\rightarrow P^{A}$
\end_inset

 and 
\begin_inset Formula $B\rightarrow P^{B}$
\end_inset

, we can produce a value of type 
\begin_inset Formula $A+B\rightarrow P^{A+B}$
\end_inset

, i.e., a co-product instance, but not necessarily a value of type 
\begin_inset Formula $A\times B\rightarrow P^{A\times B}$
\end_inset

, which would be a product-type instance.
 The function-type construction is not guaranteed to work with co-inductive
 typeclasses, but the recursive-type construction and the 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 type construction can be implemented after appropriate modifications.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 typeclass is 
\begin_inset Quotes eld
\end_inset

uninductive
\begin_inset Quotes erd
\end_inset

 (neither inductive nor co-inductive) because its instance type, 
\begin_inset Formula $A\times A\rightarrow\bbnum 2$
\end_inset

, is neither of the form 
\begin_inset Formula $P^{A}\rightarrow A$
\end_inset

 nor 
\begin_inset Formula $A\rightarrow P^{A}$
\end_inset

.
 The traversable functor (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:9-Traversable-functors-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is another example of an uninductive typeclass.
 Uninductive typeclasses usually support fewer type constructions.
 For example, only 
\emph on
polynomial
\emph default
 types can have instances of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 typeclasses.
\end_layout

\begin_layout Subsection
Typeclasses with several type parameters (type relations)
\begin_inset CommandInset label
LatexCommand label
name "subsec:Typeclasses-type-relations"

\end_inset


\end_layout

\begin_layout Standard
A typeclass constraint in a function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func[A: Monoid]
\end_layout

\end_inset

, restricts a type parameter to a certain type domain.
 Sometimes it is necessary to restrict 
\emph on
several
\emph default
 type parameters to satisfy some conditions together.
 A condition that constrains several type parameters at once is called a
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type relation|textit
\end_layout

\end_inset


\series bold
type relation
\series default
.
 Let us look at two simple examples of using type relations in practice.
 
\end_layout

\begin_layout Standard
The first example is converting integer numbers to floating point.
 The ranges of the available types allow us to convert a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Short
\end_layout

\end_inset

 to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

 and an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 Can we implement the type signature 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def convertNumber[M, N](x: M): N
\end_layout

\end_inset

where the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

 are constrained to be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M = Short
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N = Float
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M = Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N = Double
\end_layout

\end_inset

? (Also, later we may need to add support for more types.)
\end_layout

\begin_layout Standard
The second example is converting mutable data structures into the corresponding
 immutable ones.
 The Scala library contains data structures such as sequences, sets, and
 dictionaries; each data type has a mutable and an immutable version.
 Can we implement a function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def convertData[Mut[_], Immut[_], A](data: Mut[A]): Immut[A]
\end_layout

\end_inset

where the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mut
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Immut
\end_layout

\end_inset

 are constrained to represent the mutable / immutable versions of a supported
 data structure (for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mut = mutable.Set
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Immut = immutable.Set
\end_layout

\end_inset

, etc.)?
\end_layout

\begin_layout Standard
A typeclass constraint for a single type parameter, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func[A: Monoid]
\end_layout

\end_inset

, is implemented by requiring an 
\begin_inset Quotes eld
\end_inset

evidence value
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
evidence value
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!evidence value
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid[A]
\end_layout

\end_inset

 as an additional argument of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func
\end_layout

\end_inset

.
 Implementing a type relation for 
\emph on
two
\emph default
 type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is similar: We define a type constructor, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rel[_, _]
\end_layout

\end_inset

, and create some evidence values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rel[A, B]
\end_layout

\end_inset

 with chosen type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Any function, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f[A, B]
\end_layout

\end_inset

, that needs a relation constraint on its type parameters will take an extra
 evidence argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Rel[A, B]
\end_layout

\end_inset

.
 This will prevent our code from using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f[A, B]
\end_layout

\end_inset

 with types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 that are not in the required relation.
 
\end_layout

\begin_layout Standard
Using this technique, we can define a relation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MayConvert
\end_layout

\end_inset

 and write the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

convertNumber
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class MayConvert[A, B](convert: A => B)  // Evidence value contains
 a conversion function.
\end_layout

\begin_layout Plain Layout

implicit val ev1 = MayConvert[Short, Float](_.toFloat)          // Evidence
 value for [Short, Float].
\end_layout

\begin_layout Plain Layout

implicit val ev2 = MayConvert[Int, Double](_.toDouble)          // Evidence
 value for [Int, Double].
\end_layout

\begin_layout Plain Layout

def convertNumber[M, N](x: M)(implicit ev: MayConvert[M, N]): N = ev.convert(x)
\end_layout

\end_inset

With these definitions, it will be a compile-time error to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

convertNumber
\end_layout

\end_inset

 with unsupported types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> convertNumber(123)
\end_layout

\begin_layout Plain Layout

res0: Double = 123.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> convertNumber(123:Short)
\end_layout

\begin_layout Plain Layout

res1: Float = 123.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> convertNumber("abc")
\end_layout

\begin_layout Plain Layout

<console>:17: error: could not find implicit value for parameter ev: MayConvert[
String,N]
\end_layout

\begin_layout Plain Layout

       convertNumber("abc")
\end_layout

\begin_layout Plain Layout

                    ^
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have just seen, a type relation is defined by creating some evidence
 values.
 The code above defines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MayConvert
\end_layout

\end_inset

 as a one-to-one type relation because the evidence values (or 
\begin_inset Quotes eld
\end_inset

relation instances
\begin_inset Quotes erd
\end_inset

) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ev1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ev2
\end_layout

\end_inset

 do not have any types in common.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MayConvert
\end_layout

\end_inset

 is equivalent to a type-to-type 
\emph on
function
\emph default
 that maps 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Short
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 However, type relations are not limited to one-to-one relations.
 By creating suitable implicit evidence values, we can implement one-to-many
 or many-to-many relations when needed.
 
\end_layout

\begin_layout Standard
A practical example of a many-to-many 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type relation!many-to-many
\end_layout

\end_inset

type relation is the compatibility between physical units.
 Miles can be converted into kilometers; pounds can be converted into ounces
 or kilograms; but kilograms cannot be converted into miles.
 Type relations allow us to implement type-safe operations for quantities
 with units.
 Adding kilograms to pounds will automatically convert the quantity to a
 common unit, while adding kilograms to miles will raise a compile-time
 error.
\end_layout

\begin_layout Standard
Begin by declaring a type for 
\begin_inset Quotes eld
\end_inset

quantity with units
\begin_inset Quotes erd
\end_inset

 and some type names for the supported units:
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant functor
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait KG; trait LB; trait OZ; trait KM; trait MI; trait FT // Declare names
 for some supported units.
\end_layout

\begin_layout Plain Layout

final case class Quantity[U](value: Double)    // Constant functor: No values
 of type `U` are stored.
\end_layout

\begin_layout Plain Layout

def add[U1, U2](x: Quantity[U1], y: Quantity[U2]): Quantity[U2] = ???
\end_layout

\end_inset

The parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Quantity[U]
\end_layout

\end_inset

 is called a 
\series bold
phantom
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
phantom type parameter
\end_layout

\end_inset

 type parameter because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Quantity[U]
\end_layout

\end_inset

 contains no values that use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U
\end_layout

\end_inset

.
 The parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U
\end_layout

\end_inset

 would not be phantom if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Quantity[U]
\end_layout

\end_inset

 were not a constant functor
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant functor!example of use
\end_layout

\end_inset

 but instead contained values e.g., of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U
\end_layout

\end_inset

 or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U => Double
\end_layout

\end_inset

 or of some other type that uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add[U1, U2](x, y)
\end_layout

\end_inset

 must impose a type relation constraint on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U2
\end_layout

\end_inset

, so that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 may be added only when they have compatible units.
 The type relation is implemented as a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Convertible
\end_layout

\end_inset

 with two type parameters.
 A 
\begin_inset Quotes eld
\end_inset

relation instance
\begin_inset Quotes erd
\end_inset

 (i.e., a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Convertible[U1, U2]
\end_layout

\end_inset

) will contain a multiplier for converting any quantity from units 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U1
\end_layout

\end_inset

 to units 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

U2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Convertible[U1, U2](multiplier: Double)
\end_layout

\begin_layout Plain Layout

implicit val c1 = Convertible[KG, KG](1.0)
\end_layout

\begin_layout Plain Layout

implicit val c2 = Convertible[LB, KG](0.453592) // Pounds in kilograms.
\end_layout

\begin_layout Plain Layout

implicit val c3 = Convertible[KM, KM](1.0)
\end_layout

\begin_layout Plain Layout

implicit val c4 = Convertible[MI, KM](1.60934)  // Miles in kilometers.
 Add more definitions here.
\end_layout

\end_inset

Now we can implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add
\end_layout

\end_inset

 function and verify that the type relation works as we intended:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add[U1, U2](x: Quantity[U1], y: Quantity[U2])(implicit ev: Convertible[U1,
 U2]): Quantity[U2] =
\end_layout

\begin_layout Plain Layout

  Quantity(x.value * ev.multiplier + y.value)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> add(Quantity[LB](1), Quantity[KG](1))   // 1 pound + 1 kg = 1.453592
 kg.
\end_layout

\begin_layout Plain Layout

res0: Quantity[KG] = Quantity(1.453592)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> add(Quantity[MI](1), Quantity[KG](1))   // Compile-time error: cannot
 add miles to kilograms.
\end_layout

\begin_layout Plain Layout

<console>:25: error: could not find implicit value for parameter ev: Convertible
[MI,KG]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To make this code more convenient for practical use, we can add extension
 methods that shorten the syntax from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Quantity[KG](1)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1.kg
\end_layout

\end_inset

 and from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add(2.lb, 2.kg)
\end_layout

\end_inset

 to a more readable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2.lb + 2.kg
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class QuantitySyntax(x: Double) {
\end_layout

\begin_layout Plain Layout

  def kg = Quantity[KG](x)
\end_layout

\begin_layout Plain Layout

  def lb = Quantity[LB](x)        // Add more definitions as needed.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class QuantityAdd[U1](x: Quantity[U1]) {
\end_layout

\begin_layout Plain Layout

  def +[U2](y: Quantity[U2])(implicit ev: Convertible[U1, U2]): Quantity[U2]
 = add(x, y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 2.lb + 2.kg        // Compute 2 pounds + 2 kilograms; the result is
 in kilograms.
\end_layout

\begin_layout Plain Layout

res1: Quantity[KG] = Quantity(2.907184)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another necessary improvement is reducing the number of implicit values.
 The current code uses 
\begin_inset Formula $n^{2}$
\end_inset

 implicit values for every group of 
\begin_inset Formula $n$
\end_inset

 compatible units.
 Adding support for a new unit (say, inches) requires adding implicit values
 for converting between inches and all previously defined units of length.
 To avoid this problem, the code must be reorganized to convert all compatible
 quantities to chosen units (e.g., all length to kilometers and all mass to
 kilograms).
 This makes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Convertible
\end_layout

\end_inset

 relation many-to-one
\begin_inset Index idx
status open

\begin_layout Plain Layout
type relation!many-to-one
\end_layout

\end_inset

 instead of many-to-many.
 The resulting code is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Full-code-implementing-units-length-mass"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "frame=single,fillcolor={\color{black}},framesep={0.2mm},framexleftmargin=2mm,framexrightmargin=2mm,framextopmargin=2mm,framexbottommargin=2mm"
inline false
status open

\begin_layout Plain Layout

trait KG; trait LB; trait OZ; trait KM; trait MI; trait FT             //
 Some supported units.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// This type relation is many-to-1: it relates all mass units to KG and
 all length units to KM.
\end_layout

\begin_layout Plain Layout

final case class Convertible[U1, U2](multiplier: Double) extends AnyVal
\end_layout

\begin_layout Plain Layout

// Units of mass.
\end_layout

\begin_layout Plain Layout

implicit val cKG = Convertible[KG, KG](1.0)
\end_layout

\begin_layout Plain Layout

implicit val cLB = Convertible[LB, KG](0.453592)
\end_layout

\begin_layout Plain Layout

implicit val cOZ = Convertible[OZ, KG](0.0283495)
\end_layout

\begin_layout Plain Layout

// Units of distance.
\end_layout

\begin_layout Plain Layout

implicit val cKM = Convertible[KM, KM](1.0)
\end_layout

\begin_layout Plain Layout

implicit val cMI = Convertible[MI, KM](1.60934)
\end_layout

\begin_layout Plain Layout

implicit val cFT = Convertible[FT, KM](0.0003048)
\end_layout

\begin_layout Plain Layout

// We can add support for new units whenever necessary.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

final case class Quantity[U](value: Double) extends AnyVal { // Use `AnyVal`
 to reduce run-time cost.
\end_layout

\begin_layout Plain Layout

  def +[U2, C](q: Quantity[U2])(implicit ev1: Convertible[U, C], ev2: Convertibl
e[U2, C]) =
\end_layout

\begin_layout Plain Layout

      Quantity[U2](value * ev1.multiplier / ev2.multiplier + q.value)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  def ==[U2, C](q: Quantity[U2])(implicit ev1: Convertible[U, C], ev2: Convertib
le[U2, C]) =
\end_layout

\begin_layout Plain Layout

      value * ev1.multiplier == q.value * ev2.multiplier
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

implicit class QuantitySyntax(x: Double) {    // Extension methods defined
 for convenience.
\end_layout

\begin_layout Plain Layout

  def kg = Quantity[KG](x)
\end_layout

\begin_layout Plain Layout

  def lb = Quantity[LB](x)
\end_layout

\begin_layout Plain Layout

  def oz = Quantity[OZ](x)
\end_layout

\begin_layout Plain Layout

  def km = Quantity[KM](x)
\end_layout

\begin_layout Plain Layout

  def mi = Quantity[MI](x)
\end_layout

\begin_layout Plain Layout

  def ft = Quantity[FT](x)
\end_layout

\begin_layout Plain Layout

  // This general extension method, e.g., `1.in[KM]`, will also work for any
 units defined later.
\end_layout

\begin_layout Plain Layout

  def in[U](implicit ev: Convertible[U, _]): Quantity[U] = Quantity[U](x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 1.in[KM]         // Use the general method `.in` with a type parameter.
\end_layout

\begin_layout Plain Layout

res1: Quantity[KM] = Quantity(1.0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 10000.ft + 1.km  // Use the `.ft` and `.km` extension methods.
\end_layout

\begin_layout Plain Layout

res2: Quantity[KM] = Quantity(4.048)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 1.kg + 2.lb == 32.oz + 1.kg   // Compare values safely.
\end_layout

\begin_layout Plain Layout

res2: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 1.km + 2.lb      // Compile-time error: cannot add kilometers to pounds.
\end_layout

\begin_layout Plain Layout

<console>:29: error: could not find implicit value for parameter ev2: Convertibl
e[LB,C]
\end_layout

\begin_layout Plain Layout

       1.km + 2.lb
\end_layout

\begin_layout Plain Layout

            ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> trait YD; implicit val cYD = Convertible[YD, KM](0.0009144)  // Add
 support for yards.
\end_layout

\begin_layout Plain Layout

defined trait YD
\end_layout

\begin_layout Plain Layout

cIN: Convertible[YD,KM] = Convertible(9.144E-4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 1.in[YD] + 1.ft // Use .in[YD] to compute 1 YD + 1 FT = 4 FT.
\end_layout

\begin_layout Plain Layout

res3: Quantity[FT] = Quantity(4.0)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementing type-safe computations with units of length and mass.
\begin_inset CommandInset label
LatexCommand label
name "fig:Full-code-implementing-units-length-mass"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inheritance and automatic conversions of typeclasses
\begin_inset CommandInset label
LatexCommand label
name "subsec:Inheritance-and-automatic-typeclass"

\end_inset


\end_layout

\begin_layout Standard
It often happens that one typeclass is a subset of another; for example,
 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance for a type 
\begin_inset Formula $T$
\end_inset

 means that 
\begin_inset Formula $T$
\end_inset

 already has the properties of both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 typeclasses.
 One says that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 typeclass 
\series bold
inherits
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
typeclass!inheritance
\end_layout

\end_inset

 from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasDefault
\end_layout

\end_inset

 typeclasses.
 We may want to express inheritance relations between typeclasses, so that,
 e.g., a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 instance should automatically imply the presence of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance, without extra code.
\end_layout

\begin_layout Standard
One way of inheriting a typeclass is to add a constraint to the new typeclass
 constructor:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Semigroup[T](combine: (T, T) => T)
\end_layout

\begin_layout Plain Layout

final case class Monoid[T: Semigroup](empty: T)  // Inherit `Semigroup`.
\end_layout

\end_inset

The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 combines a previous 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance with the new method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

empty
\end_layout

\end_inset

.
 Creating an instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 for a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 will then require having an instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val c1 = Semigroup[Int](_ + _)
\end_layout

\begin_layout Plain Layout

implicit val c2 = Monoid[Int](0)  // Works only if a `Semigroup[Int]` is
 available.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid[T]
\end_layout

\end_inset

 instance, how can we recover the inherited implicit value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup[T]
\end_layout

\end_inset

? This is achieved by redefining the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 class like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Monoid[T](empty: T)(implicit val semigroup: Semigroup[T])
   // Use `implicit val`.
\end_layout

\begin_layout Plain Layout

implicit def semigroupFromMonoid[T](implicit ti: Monoid[T]): Semigroup[T]
 = ti.semigroup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another possibility of implementing typeclass inheritance is to use object-orien
ted inheritance of traits.
 This approach is often used when defining typeclasses as traits with methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait Semigroup[T] { def combine: (T, T) => T }
\end_layout

\begin_layout Plain Layout

trait Monoid[T] extends Semigroup[T] { def empty: T } // `def combine` is
 inherited from `Semigroup`.
\end_layout

\end_inset

Creating an instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 for a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 no longer requires having an instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "48col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -95baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val c: Monoid[Int] = new Monoid[Int] {
\end_layout

\begin_layout Plain Layout

  def empty: Int =  0
\end_layout

\begin_layout Plain Layout

  def combine: (Int, Int) => Int =  _ + _
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -110baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
With this approach, we cannot avoid repeating the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def combine...
\end_layout

\end_inset

 even if we 
\emph on
do
\emph default
 already have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 instance.
 However, conversion from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid[T]
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup[T]
\end_layout

\end_inset

 is now automatic due to 
\series bold
object-oriented inheritance
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
object-oriented inheritance
\end_layout

\end_inset

: Scala considers 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid[T]
\end_layout

\end_inset

 a subtype of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup[T]
\end_layout

\end_inset

 because the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Monoid
\end_layout

\end_inset

 class is declared as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extends Semigroup
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A problem with the object-oriented inheritance is that automatic type conversion
s to parent classes 
\emph on
cannot be disabled
\emph default
.
 When several typeclasses inherit from the same parent typeclass, duplicate
 implicit instances of the parent typeclass will be present, which is a
 compile-time error:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait TC[A]                    // Parent typeclass.
\end_layout

\begin_layout Plain Layout

trait TC1[A] extends TC[A]     // Two different typeclasses TC1 and TC2
 inherit from TC.
\end_layout

\begin_layout Plain Layout

trait TC2[A] extends TC[A]
\end_layout

\begin_layout Plain Layout

// The function f requires A to have both TC1 and TC2 instances and then
 wants to access TC instance.
\end_layout

\begin_layout Plain Layout

def f[A: TC1 : TC2]() = {
\end_layout

\begin_layout Plain Layout

  implicitly[TC[A]]  // Compilation fails because two implicit values of
 type TC[A] are found.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When typeclass inheritance is implemented by combining instances without
 object-oriented inheritance, conversions to parent typeclasses are not
 automatic: they are implemented by implicit functions that need to be imported
 into the current scope.
 The programmer's code can avoid producing duplicate instances by choosing
 which implicit conversions to import:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class TC[A]()
\end_layout

\begin_layout Plain Layout

final case class TC1[A]()(implicit val tc: TC[A])                      //
 TC1 inherits TC.
\end_layout

\begin_layout Plain Layout

object TC1 { implicit def toTC[A](implicit x: TC1[A]): TC[A] = x.tc }
\end_layout

\begin_layout Plain Layout

final case class TC2[A]()(implicit val tc: TC[A])                      //
 TC2 inherits TC.
\end_layout

\begin_layout Plain Layout

object TC2 { implicit def toTC[A](implicit x: TC2[A]): TC[A] = x.tc }
\end_layout

\begin_layout Plain Layout

// The function f requires A to have both TC1 and TC2 instances and then
 wants to access TC instance.
\end_layout

\begin_layout Plain Layout

def f[A: TC1 : TC2]() = {
\end_layout

\begin_layout Plain Layout

      import TC1._  // Can import TC1._ or TC2._ but not both.
 If the next line is uncommented,
\end_layout

\begin_layout Plain Layout

//    import TC2._  // compilation will fail because two implicits of type
 TC[A] will be found!
\end_layout

\begin_layout Plain Layout

  implicitly[TC[A]] // This compiles successfully.
 One implicit instance of TC[A] can be found.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem of duplicate inherited instances can be solved with less work
 for the programmer if the typeclasses are implemented using a special,
 more complicated encoding.
\begin_inset Foot
status open

\begin_layout Plain Layout
See slides 5–14 of the talk by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
John de Goes
\end_layout

\end_inset

John de Goes: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.slideshare.net/jdegoes/scalaz-8-a-whole-new-game"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
this tutorial is about typeclasses and type level functions to motivate
 why we want to talk about this let's consider what happens if we would
 like to implement the sum function generically so that the same implementation
 code will work for sequence of integers for sequence of doubles and so
 on if we try to do that we find that it doesn't quite work we cannot generalize
 the sum function like this with a type parameter T and an argument of type
 sequence of T because there is no way for us to sum or to add values of
 type T where T is unknown it's arbitrary unknown type obviously the sum
 function can only work for types T that in some sense or summable another
 very similar situation happens if we wanted for instance to define the
 F map function for factors that already define the map function as we know
 F map is equivalent to map so for each factor somebody defined already
 the map function we would like to define F map for all of them at once
 by in the same generic code but we cannot generalize F map to arbitrary
 type constructors F here is what we would have to write suppose that we
 tried we would have to put F as a type parameter F being the type constructor
 of the function just as an aside in Scala this syntax is necessary if you
 want to put a type parameter that is itself a type construction you can
 do that just by using this syntax so if we try to write F map like this
 we will have F me up with type parameters and we cannot write this code
 because F in here is an arbitrary type constructor parameter and there's
 no way for us to get the map function for that F we don't even know if
 it exists just like here there's no way for us to get the addition operation
 with some more plus or something for the type T and just like in that case
 the F map could work only for certain type constructors F namely for those
 that are factors so our desire to write code more generically leads us
 to the need to define functions whose type arguments for example the T
 and F are not just arbitrary types but there are types that are required
 to have certain properties or to belong to a certain subset of possible
 types here for instance it will be integer double long and so on maybe
 others string could be considered as well and here will be the filter types
 or rather to be precise the factor type constructors that should so somehow
 we should require require that this type parameter in the F map implementation
 is not just any type but it is a sub is belongs to a subset a certain subset
 of possible types which we also have to define somehow so if we are able
 to do that which is the whole focus of this tutorial if we're able to do
 that then we can use known properties of this type parameters in implementation
 of these functions also we would like to be able to add new supported types
 whenever it's needed so integer double maybe a library will define this
 property for the type T but we want to add new ones later so wanted to
 be extensible so this is our goal now the first step towards solving it
 and we will be solving this systematically the first step is to realize
 that this is similar to the concept of partial functions except that applied
 to types let me then look at what partial functions are generally functions
 can be total or partial the total function always has a result for any
 argument value the partial function sometimes has no result for some argument
 values it does have a result for others it does not an example of a total
 function would be an integer function taking an integer argument with returning
 that integer multiplied by 3 so for any input integer you always have an
 output integer the example of a partial function will be real valued square
 root it has no result for negative arguments no real valued square root
 from negative arguments but it does have a result for non-negative arguments
 so that's a partial function partial function has a domain of its definition
 which is smaller than the all values of that type now we should also consider
 that here we have type parameters so what does it mean that we have a function
 with type parameters it's like a function with argument is a type so let's
 consider functions both from value and from type to values in two types
 and that is the most most general kind of situation so we will have this
 table of all possible functions function from value or from type and to
 value and to type so the function fill value to value were value level
 function or value to value function that's just an ordinary function like
 that it takes a value argument of type integer let's say and returns a
 value of type integer so that's a value to value function a function from
 type to value could be visualized like this so it has a type parameter
 and the result is a value of this type now this type depends on the type
 parameter so first you have to give it the type parameter then it knows
 what type it value needs to return and then it creates somehow that value
 and returns it now one important observation here is that these functions
 are the same kind the same sort this function has a type parameter and
 then you can rewrite this in a different syntax by writing some column
 sequence t rlt which will be quite similar to this just a different syntax
 so just like in the example here first you have to get the type parameter
 T then you know which types you're taking in this function so the function
 some can be considered as a function film type from t2 value which is a
 function from sequence T 2 T so this is a value which is itself a function
 on a function at the value level but that's a value right so functions
 at value level or values sequence T 2 T where T is already fixed fixed
 type this type parameter finally we also have functions from type 2 type
 for example if we define this type then my data is a function from type
 2 type so later in the code you could say my data of string and that would
 be the same as evaluating this function substituting string instead of
 a and the result would be either of int and string and there also is a
 function from value to type in principle now in Scala it would be quite
 hard to come up with useful examples of this sort because these are actually
 dependent types so this is this kind of function is called a dependent
 type which means that it's a type that depends on a value and that is not
 very well supported in Scala or in Haskell for that matter so there are
 more advanced experimental aim which is like a dress or Agda not have better
 support for dependent types so we will not talk about dependent types here
 our concern will be mostly this part of the table functions from type either
 from type to value or from type 2 type now consider how these functions
 are being evaluated the value to value functions are evaluated at runtime
 type 2 value functions are evaluated at compile time because you cannot
 really call these functions without specifying a type parameter and that
 is evaluated at compile time the compiler will know that you are calling
 this function with string here say instead of a and that would be known
 at compile time as you write your code one caveat here is that if you use
 type casts in the code then you could make a run time evaluation based
 on types so type T value functions can become runtime which is a problem
 because it is possible to have a bug and a bug in a type 2 value or type
 2 type function at compile time that's okay because you you will find it
 before you run your program at runtime it's not okay you already deployed
 your program it's running and three months later it crashes because of
 some bug that's not a good outcome at all so we will avoid using type casts
 or any kind of runtime computation with types we want to keep all type
 computations compile time in this way they are safe consider now partial
 functions so these so far we just considered any kind of functions here
 of all kinds value to value value to type type to a value type to type
 consider now partial functions so partial value to value function is something
 like this it's a partial function that takes an argument if the argument
 here is an option that is not empty when it returns the value inside this
 option but if the argument of this function were the empty option which
 is to say the none value then there is no case to match that so this function
 cannot process that argument only so this function considered as a functional
 options is a partial function if you apply this to the room kind of argument
 you get an exception at runtime consider now functions from types of partial
 type the value function is a function that takes a type argument and it
 only works for certain types for certainty types T in the view call this
 function so this is an example of this would be this function which I will
 talk about it later but basically the idea is that it's a function that
 has a type parameter it returns a value and when you call this function
 with the wrong type parameter it's an error at compile time otherwise it
 works so that's a partial function at type two value level so partial type
 two value function is what we would like to have like to have those functions
 and the goal of this tutorial is to explain systematically how to create
 and manage partial type two value functions typeclasses is the mechanism
 for doing that and the idea roughly speaking is that the type T should
 belong to a certain typeclass or a certain subset of types or a certain
 type of domain there are certain kind of types and then you can apply that
 partial type to value function to that type if we are able to implement
 this then these problems would be solved we will just say well some is
 not just total type the value function is a partial type the value function
 it's only defined on types T that belong to the correct kind or typeclass
 which are summable in some sense and of course this code it won't work
 it has to be done honest it's like a different way which we will find out
 how to do in a systematic manner before we do that let's look at an example
 of using value level partial functions and let's see what's the issue there
 so imagine we have a situation we have a sequence of either end boolean
 we want to find the [Music] elements in that sequence that are in the left
 part of the disjunction having an integer and we just get one to get a
 sequence of those integers out of this sequence how do we do that well
 we just say take in a sequence we filter those that are on the left which
 is like this maybe and then we map with this partial function now after
 this step the result is still of type sequence of either so now we are
 applying this partial function to arguments of type either which is unsafe
 what about with a right element and there will be nothing to match well
 actually we know in this case it's okay to apply this partial function
 because we just filtered all the elements to be on the left side of the
 disjunction so we know it's safe however the types don't show that it is
 safe the compile-time checking can tell you maybe that there is some problem
 a warning but certain cases will not be matched but it doesn't know it's
 safe and so if you refactor this code in some way but say you put this
 part in one module in this part in another module and then different people
 start to modify this and eventually this condition has changed and it has
 more complicated conditions whatever features we need to implement and
 finally it's not always the left and so the other part of the code is also
 changed in some way and you get a runtime error after some refactoring
 sometime later the type side type safe version of this code does not use
 filter milk and sort of filter map you do collect so collect is basically
 a safe version of filtering only those that fit into this partial function
 and then applying the partial function so partial functions in Scala are
 special a special type and this type has a method to decide whether the
 partial function can apply to us and give an argument and so that's what
 we collect is doing and the result is safe it is of type sequence int and
 there's nothing you can refactor here to break the safety of this code
 so partial functions are safe but only in certain places where you take
 care to encapsulate the possible breakage so usually we make functions
 total we either add more code to handle other cases or we use more restrictive
 types so that we know that this is not just an either it's really always
 left and in other cases for instance there types such as non-empty list
 or positive number or or even this this is a subtype of option and if you
 have this than you you know it's not empty so instead of using option you
 use this in a specific function or you use known empty list and sort of
 just list and if you do that you can do it dot head on a non empty list
 and it's always safe and the safety is checked at compile time you cannot
 pass here instead of non empty list just arbitrary list so that's how we
 handle the unsafe team partial functions for value level functions so for
 type level functions we would like to restrict the type parameters to some
 restrictive subset of types so that this is safe that's our motivation
 so let's see how this can be done here is the first example of a partial
 type level function consider this data type so this is a disjunction the
 disjunction is paralysed by a type parameter a and has two cases in the
 one case gives you a my type constructor of int and the other case gives
 you my type constructor of string well this is just an artificial example
 but this could occur in some applications now notice we have defined the
 type constructor my TC my type constructor as if it's defined for any parameter
 a as any type a actually in code you can only ever create values either
 of my TC event or of type my DCF string you will never be able to define
 any values of any other type like my TC of bullying or mighty sea or anything
 else only either string or integer there is no other case and everything
 is sealed and final and so there's no way to add any more cases let's see
 how a code looks like for this so here's the code if I wanted to pretend
 that I have a value of type my TC of a for arbitrary a I cannot do that
 I have to create it instantly the only way to credit is to use case one
 or case two neither one would work so none of them type checks action for
 example if I did this I mean it may get no no no way I can do anything
 here I could say no this one is my t siient so the only thing that can
 work here is this but I cannot put here a equal to int either I have a
 parameter here or not so you can get rid of this parameter there's no way
 I can use this mighty sea with an arbitrary time frame type round you can
 get a value now I can define types such as this one which looks like I'm
 applying the type level function to int and get a type so you see I using
 this type constructor as as if it were a function of types I apply this
 to type into my data type t1 up out of that and this works and then I can
 use t1 and t2 for example in my code and it's all compiles when it works
 so this is to illustrate but the type constructor like my TC is quite similar
 to a function at type level since a functional takes types as arguments
 and returns types just that I have to say type instead of well because
 it's a type level function not a value level function otherwise it's very
 similar to a function so that's why I keep calling this a type 2 type function
 or type the value function because I'm I want to think about these type
 constructors in a general way I don't want to think about them in some
 kind of special magic fashion these are just functions their arguments
 are types the results are types and now I can use my mathematical intuition
 about functions to reason about them now here's a way to use this in code
 so for example x2 is of this type I can match this and I get a result so
 it works now what if I wanted to apply this function to a different argument
 so I am applying it to doing now there is no way to create a value of type
 boolean but the Scala compiler doesn't know this so in some sense I consider
 this function as a function that is only defined so it's a type 2 type
 function my TC that's only defined for int or string as type arguments
 but if I write my TC of boolean and I evaluate this it compiles so the
 compiler doesn't know doesn't check but there is no way to create this
 value but actually no code would ever compile it creates this value correctly
 like this for example this won't compile now what I can do is I can force
 the type like this using this construction as instance of which breaks
 type checking its runtime typecast and it's completely breaking the type
 checking there is nothing the compiler will check here the results are
 going to be wrong like this is going to be wrong I can't really use this
 in any useful way in other words it doesn't help if you break the type
 checking type checking is your friend this is to be used only in very rare
 situations when the type system is not strong enough not powerful enough
 to do some extremely complicated things and in most cases it's not necessary
 so this is cheating in terms of type checking and even this cheating pretend
 that I created a value of type t3 but actually I have not created such
 a value I cannot use it in the code still there's nothing I can do with
 this in code that would be compiled invented working so this motivates
 me to consider that a function my TC is actually a partial type function
 it is meaningless to apply this function to arguments such as doing the
 type argument such as bullying it's only meaningful to apply to arguments
 integer and string so in other words this type function has a domain type
 domain it is set of types to which it can be applied meaningfully and this
 domain contains only two types int and string so become the compiler as
 we have just seen does not enforce this it does not flag it immediately
 as an error however it does enforce that the values of this type only exist
 for the type parameter within the correct domain or the type domain and
 this type domain is defined at compile time and is what I mean by the domain
 of the partial type 2 type function just a side note here the type constructor
 my TC cannot possibly be a factor since it's not defined for all type arguments
 a factor must be a total type 2 type function partial type 2 type functions
 cannot be factors so these kind of types where you have partial type 2
 type functions and case classes they're called generalized algebraic data
 types or generalized means that these types are not the type parameter
 a there are just specific types so there are some cases when they're useful
 they're useful for domain modeling of certain kinds like for example you
 have some kind of query and the result types can be a fixed set of different
 result types then it's useful to have all these possible result types modeled
 directly via cases in the disjunction like this for domain-specific languages
 representing some kind of type expressions in some way then it's also useful
 these are specific problems where people have used GE T's in a useful way
 so this is our first example of a partial type function another way of
 doing this is to have a trait with code now here this is just a data type
 there is no code in here so let's see how that works when you have trade
 with code so that's more the object-oriented way because it uses method
 overriding so we start with the trait that has a method the trait has a
 type parameter as well and there are some case classes so it's very similar
 to the previous slide except the trade has code the DEF method the inside
 and the case class has override that def method other than that it's good
 could be case class just like in the previous slide and again you see this
 class extends heads plus with integer time from type parameter and not
 with an arbitrary type parameter and this extends with a string not with
 arbitrary type parameter so just as in the previous slide this defines
 a partial type 2 type function and now this is a function that's only defined
 for a certain a for a either int or string so this code is quite similar
 to having defined a function plus with a type parameter a having this type
 signature except that a must be from this type domain it's not quite the
 same as having defined such a function directly because plus doesn't have
 a type parameter and we can only access it by first creating a value of
 this type and I'm doing that value dot plus so because it's a def method
 there must be the syntax value dot plus another limitation is that all
 the functions support so we see this plus is one of the partial type to
 value functions it's a type to value function which is defined only for
 certain types all of these must be defined up front in the code of this
 trait so if I want plus minus times or divide or whatever I have to define
 all of those as def methods up front in this train I cannot later defined
 further partial type two value functions here and also I cannot use this
 partial type two value function in a different one defined later so that
 is quite a significant limitation so this mechanism kind of works for implement
ing a partial type two value function but it is limited so the object-oriented
 way it gives us some leverage but it's it's limited we will be using this
 mechanism in many cases but we need to have a more general mechanism for
 implementing partial type two value functions so what is that mechanism
 to understand this mechanism remember these values of type has plus of
 a here only be of two different types as plus event or as possib stream
 there are no other values that your code could possibly define so let's
 use that fact now there are only certain values that your code can define
 and require these values to exist and in this way we will define a partial
 type two value function so here's how it works suppose we want to define
 a function func with type argument a and some whatever value arguments
 and we want to define this only for certain types a first we define a partial
 type two type function that is defined only for these types a so we do
 it in the same way here there's really only one way in Scala of doing this
 make a trait and make some classes that extended with specific type parameters
 like this or like that that's it's the same thing it just there's only
 one way of doing this in Scala so it first to create this partial type
 two type function which defines your type domain its defined only for the
 specific types you want let's call this for now is good so it is this type
 parameter good and if so then we can proceed with it we create some specific
 values of these types for all relevant types a would create a specific
 value so this would be to say we create a value of this type you have to
 create a value of this type just you know Val a equals this without B equals
 that and that's what we will do now we will add an extra argument to this
 function func in addition to all the arguments it already has or needs
 we add another argument which we will call the type evidence and this argument
 will be of type is good of a so this function cannot be called unless you
 have a value of this type and you can only have values of this type if
 the type is supported by the partial type 2 type function in other words
 if the type is from the correct type domain that you are defining it becomes
 now impossible to call this function with an unsupported type parameter
 a because you will never be able to produce this value type evidence here
 you you can only produce values of these two types even if you define the
 type for a different type argument you can produce the value of that type
 so you could you could define a type of my TC of booing but you will never
 be able to produce a value of that type and calling func requires a value
 of that type so because we added an extra argument to funk so the type
 evidence is that value that is required now with a new argument that we
 have it and that guarantees we will always call func value with correct
 types a trying to call with wrong types will failed compile-time you can
 put some type evidence value for the wrong type at the wrong type check
 so that's a compile-time guarantee now you can make the trait not sealed
 here it was sealed because we were just thinking in terms of disjunctions
 but this trade doesn't have to be a disjunction it's just a type constructor
 it's just a type two type function and it doesn't have to be sealed these
 don't have to be final case classes they could be actually traits themselves
 or they could be objects or the case objects or they could be just classes
 not case it could be anything it doesn't have to be a disjunction we're
 not using this as a disjunction really we're using this as a partial type
 to type function so the only thing we want to define is a type and some
 values of that type with specific type parameters how we do this is implementat
ion detail one easy way of doing it is by using traits and classes that
 extend the trait we will see in the sample code another way of doing this
 or several other ways of doing this that might or might not be convenient
 for different situations let's implementation detail the important thing
 is if we make this a tree that's not sealed we can add new values for new
 types later so in in the libraries say we provide this with some standard
 types in an application we want more types so we just add more values there's
 no need to modify the library code so that's extensible new supported types
 can be added in user code and that's a great advantage so that actually
 is the general solution of the problem of defining a partial type two value
 function now the solution has its cost here is what we have to do now first
 all calls to this function will now become calls of this kind we have one
 more argument for each call this tantrum you have to put one more argument
 now this value this evidence or type evidence is the value that we need
 to create her each supported type a so if you have 15 different types that
 we want to use need to create 15 different values a lot of code and that
 code is probably going to be very straightforward just automatic kind of
 code which software engineers call boilerplate boring that is still missed
 it needs to be written and finally all these evidence values have to be
 passed around all the time because you call these functions in different
 places in your code have to get these these type evidence values you created
 created these values in one place but you have to pass them all around
 your code whenever they're needed so that's a lot of extra work for if
 you want to use these functions many times them in different places of
 your code that would be a lot of work in Scala these issues can be mitigated
 and mechanism for mitigating these issues is by using implicit values which
 we will look at very soon then we look at specific code the result of using
 implicit values is that type evidence arguments are only explicitly mentioned
 at the declaration side of the function func and when you call it you don't
 write them all so you don't have to pass them around they are already passed
 around invisibly once they are defined as input set these type evidence
 values and also you don't have to write a lot of code to define type evidence
 values for all kinds of types because you can define rules by which new
 implicit values can be built up automatically from previously built up
 implicit values and the compiler will do that recursively as much as necessary
 so that's more or less solves all these three issues however I would like
 to emphasize that these are cosmetic issues which make make code better
 and easier to write they do not change the character of the code in a qualitati
ve way these gains will stand whether we use this or not so we can use this
 mechanism the partial type 2 type functions so in languages that did not
 support implicit values we can even use this in Java these things are just
 cosmetic issues with their positi of the code and it's not changing the
 fact that we have implemented partial type 2 value functions in the most
 general way possible so what is the scholars mechanism of implicit values
 so here's how they work you declare a value of some type as implicit and
 also there are implicit def methods and implicit classes that you can define
 once you have defined it like this you can start defining functions with
 implicit arguments so like this for example and then once you have defined
 a value of this type as implicit you can call this function by you're saying
 F of args you don't have to pass X into it that would be found so the compiler
 at compile time will search in the local scope for this definition or in
 imports or in companion objects or in parent classes and it will find a
 definition like this and it will substitute that value silently and invisibly
 into your function so by the way having more than two implicit values of
 the same type is a compile time here so you cannot say implicit well X
 some type and possess well Y some type next to it that would be a compile
 time here in addition to this Scala has a short syntax for declaring type
 evidence arguments which is which is specifically very useful for declaring
 partial type to value functions and the syntax looks like this so it looks
 like you're saying that type parameter a is itself of some type well it's
 like a type 4 type notation but actually it's completely equivalent to
 this code take all these arguments that you have and add another list of
 arguments which are all implicit and they will have automatically generated
 names and the types will be this type constructor of a this type constructor
 will be and so on so this code is just shorter easier to read and this
 is longer but in exactly the same is less it it just rewritten so you could
 have some arguments implicit written out like this some other arguments
 written out like that we can combine both they will be already written
 to one big list of implicit arguments at the end so the difference between
 these two is that if you want to use the evidence argument in the code
 of the function you need its name and in this definition you have the name
 you define it yourself in this definition you don't see that name so that
 name would be automatically generated you don't see it don't matter another
 problem there's a special method defined in the standard library which
 covers a scope which is called implicitly and that method can grab the
 implicit argument defined for you when they define functions of the syntax
 the definition of implicitly is very simple and you could have defined
 it yourself it's just defined for convenience for you in the standard library
 we'll see how that works in one of the worst examples later so these things
 make the code shorter we still need to declare the trait or the type constructo
r as a partial type two type function and we still need to create type of
 evidence values I am declaring them as implicit but passing them around
 is very simple and calling the function is much shorter because of the
 implicit mechanism so now having done all this to let me say what typeclasses
 are so right now we were talking about partial type two value functions
 and partial type two type functions but this is not really the terminology
 that most people use it is just the terminology that I find the most illuminati
ng it tells you exactly what we're doing but actually people say typeclass
 what sorts a tight class a typeclass is basically a set of partial type
 two value functions that all have the same time dummy which means that
 for example you can have plus minus times divide let's say and they all
 have the same type domain which is numbers that can be added subtracted
 divided in something so instead of saying typeclass we could say some partial
 type two value functions that somebody has defined that's the same thing
 so in terms of specific code that needs to be written the typeclass is
 two things first it's a partial type two type function so it's a type construct
or with some code that creates specific type evidence values of specific
 types T and that defines the type domain second it is the code for the
 desired PT lives so whatever functions you need to define your write code
 for them and you use that PT TF in that code to define the type domain
 also for many important use cases these functions must satisfy certain
 laws certain equations for mathematical reasons otherwise it would be unusable
 or programs will have difficult bugs so that's what typeclasses are that's
 a definition of a tag class let's fix some terminology people say that
 a type T belongs to the typeclass my tag class what does it mean it means
 that there is a PTT F partial type two type function called the called
 this and this partial type of tag function has a domain to which type T
 belongs so for example integer could be T and then integer belongs to this
 if that type domain includes the integer which means that there is a type
 value sorry type evidence value of type MyType plus int so if some value
 of this type can be found then the type belongs to the type cost that's
 what what it means when people say that now a function with type parameter
 requires for this type parameter the typeclass might a class what does
 it mean well it means that actually one of the arguments of this function
 usually implicit argument is the value of a type like this which is constructed
 using a partial type two type function so if you if you see that there
 is some partial time to time function lying around then you know that this
 is a partial type 2 value function that requires F typeclass constraint
 or it constrains a type parameter to belong to the typeclass otherwise
 it cannot be called with that type now another important terminology is
 that the evidence value the type evidence value which is this extra argument
 of this type that value itself is is called not only type evidence is also
 called the typeclass instance now that terminology is completely equivalent
 to type evidence so I prefer evidence but instance is also standard terminology
 I will explain how how to create these things in many examples now so typically
 in Scala you create a trait with a type parameter like this then you create
 code that makes values of this type for various types T all these values
 are declared as implicit and somehow you make them available for user code
 either while imports or put them into companion objects for the types T
 which is quite convenient because then you don't need any imports then
 you also write some functions not have implicit arguments of this type
 usually these metals are def methods these functions are def methods in
 this trait we don't have to be but often they are because that's sometimes
 necessary and often convenient so as a rule a type evidence value should
 carry all the information they need about the typed you will see why let's
 look at the examples so semigroup is a typeclass that actually let me show
 you what it is a typeclass that has an associative binary operation so
 in other words there must be this function which is a partial type 2 value
 function it takes two arguments of type T and returns a value of type T
 so it's a any kind of combined operation so combine two elements and get
 another element of the same type combine two values in any way as whatsoever
 as long as it's associative so it doesn't have to be commutative doesn't
 have to be any inverse operation to this just can combine two values into
 one larger value in some way doesn't even have to be larger value we don't
 know anything about how it works so that's semigroup it's a very weak very
 bare-bones kind of operation binary operation it just is associative that's
 the only thing we know so let's implement that operation is a partial type
 to value function first step is to implement PDGF so let's just do that
 semi group with parameter T then we have two K subjects let's say well
 we have semi group and semi group string that's all nothing else fine so
 that actually defines PTT F that defines a type constructor of which you
 can only have value semigroup event and semigroup of string so that's sufficien
t in principle to create our partial target value function so let's see
 how we can do this so we can define up here the type parameter T it has
 an x and y as required it returns the t as required it also has an implicit
 argument which is the type evidence of type semigroup t so now this is
 it this is the partial type T value function you could not call this function
 with a type parameter T for which you cannot have cannot have a value of
 semigroup T so you could not call this with type parameter T other than
 int instance so this test for example says you can combine ends you can
 combine strings but option event cannot be combined this doesn't even compile
 because the type option int is not within the type domain of this partial
 type function and so you cannot have any type evidence for it and so it
 just won't compile so that's great now how do we implement this function
 well we have to add somehow integers or strings but how do you know which
 is which so let's see this evidence is the argument so the only thing we
 know about type T is this evidence value so we can imagine it where two
 cases so it could be an int or it could be a string evidence so if it's
 an int evidence we know that T is actually int so well what can we do well
 the only thing we can do with the force X to be event Y to be event add
 them together and then force their is out to be again of T because we're
 supposed to return T and that's what we have to do and we have to do we
 can do the same for string and actually this code works as the test shows
 the test passes it's a very unsafe code is not great not not not great
 at all because of these as instance of operations which are unsafe and
 maintaining this code is very hard and so don't do that we will never do
 this I'm just showing you an example of how we could do it in some way
 and that actually is an implementation of a typeclass so semigroup is a
 typeclass up rather op is a type course is a partial type to value function
 with a type domain we defined and it works for that type domain that's
 that's the typeclass a semigroup we have implemented seven rules on very
 ugly but we'll do it much better in just a few minutes this is our very
 first example note we derived the requirements for this completely systematical
 there is no there's no guessing so we must have a type dummy we must have
 a type function type constructor and we must have the implicit evidence
 argument well implicit is just convenient so we don't have to write this
 argument here in principle we could so the OP function if you look at it
 it has the second of arguments which is this one their evidence and we
 could put this evidence here in parentheses for example sending group into
 evidence it's exactly the same so this is how the function actually must
 be called and the compiler writes that for us we don't have to write that
 in our code so that just makes our cold sugar other than that that's what's
 going on this all right now why is it that we had all this trouble it's
 because we have no idea what tedious we know that it's either int or string
 so in this case it is int in this case it's string but we don't have any
 functions that help us to work with that so the way to solve this is to
 put more information into the evidence so right now here evidence is just
 an empty object it has no information except the type we put more information
 into the evidence we can get it out and work on these x and y's so why
 don't we just put the implementation into the evidence instead of putting
 it here and having all this trouble with type custom so that's what we
 do next we again implement semigroup again for empty string now the partial
 type to type function in our case is not going to be a sealed straight
 it's just going to be a type function which we define and it's going to
 carry this data so actually you see what we need is to combine these to
 fund these two elements and that's very natural to put that information
 directly onto the type constructor so now it's very easy for us to do find
 the evidence values so we just say this function which is adding two integers
 has this type and that's correct this function has this type that's correct
 so we have defined values of type semi group in the semi group string so
 that together with the type function defines a partial type two type function
 so now semi group int and semi group string are defined and others are
 not defined we put them as implicit now we define the partial type two
 value function let's say we define a sum that's what we wanted there is
 a sequence of values T and there's a default value for empty sequences
 say then there is an implicit type evidence argument so now the implementation
 is actually very easy we just do a fold left with the default element as
 the initial value and the fold has a function argument which is this OP
 an evidence has exactly the right type it is the hope so we just put it
 in there and we're done with no typecasting completely typesafe implementation
 and yet this is a partial type 2 value function because it can only be
 called on integer instrum and this is a test that shows how it works so
 this is a minimum implementation very very bare-bones implementation of
 a typeclass which is the sum a semigroup is the type 2 type function and
 sum is the type 2 value function we can define further type to value function
 functions if we want to use them this type 2 type function so that's a
 second attempt at defining a typeclass and the code is very easy as you
 see now let's try to use traits instead now this is a third implementation
 of second group we put this method which used to be here we put it as a
 def mounted on the trade so we override this then in the two specific implement
ations for integer and string evidence so that defines our PTT F and just
 as in the previous example all the data it's necessary for implementing
 what we want is carried by values of this type so all the data is carried
 by values of this straight now we do implicit case object just so that
 we don't have to write more implicit Val's in principle what we could do
 is we could say for example here is taste object not imported and then
 we said well maybe C equals that equals singing group in evidence we could
 do this just as well it's just shorter to write implicit case object right
 here so we have defined a PTT after now we define a PTV F which is adding
 of three numbers let's say and we define it in the same way so we have
 arguments at once and then additionally an implicit evidence argument and
 then we use the evidence dot up to perform the computation we see evidence
 dot what is this op that has been defined in the trade and since it's a
 deft method on the trade we have to use it in the syntax F dot op whereas
 here we didn't so here we could define add three C we can define new PTV
 F very easily so this must be of type same in Group G so how do we do that
 we do F F is a function right so that type is this function so we just
 do have of X or Y Z for example random so we can define any number of DVF's
 externally user code just like what we wanted so that's exactly how we
 expect this to work and here instead of saying just F will you have dot
 off every time because here op is a death metal in your trait same things
 should work alright so as we have seen it is quite useful if the type evidence
 value carries all information but the ETF's need to know about the type
 team and in many cases the trait contains these materials directly in some
 simple cases it can be a data type not a trait but actually as we will
 see a treatable death metals is necessary if we need higher order type
 functions it is convenient it's not particularly inconvenient to heaven
 it's just more writing to do trade with death metals if you can avoid it
 you don't have to do it and as we just have seen additional partial type
 2 value functions using the same unchanged type 2 type function can be
 added later so no need to modify the code of this trade if we want to add
 new partial type 2 value functions without changing the type domain so
 add 3 as an example we don't change the type deleting some and add 3 are
 defined for the same type domain for things that can be added no need to
 modify the code of library if we want to add more partial type 2 value
 functions with the same type domain and as we'll see later we can combine
 this with other partial type functions that we define in other code so
 that's exactly what we wanted let's look at some more examples of typeclasses
 semigroup we just saw now another interesting typeclass is pointed it's
 a very simple time code typeclass it just has a function point that returns
 a value of that type so that means somehow there is a special and naturally
 selected value of that type and the function gives you that value examples
 would be 0 integer type or empty string so these are naturally selected
 values of the type or for a function type it will be the identity fun for
 this function type that's also naturally selected value so I mean it's
 still selected in a sense that somebody selected it it's just that it's
 natural to consider that value it's useful to to have some kind of value
 of this sort and maybe it will have interesting properties and so if you
 have a value like this then the type is pointed an example of a type that's
 not pointed is a function from A to B there's no way to have some kind
 of natural function from A to B but from a to a there is you have the identity
 function another important typeclass is Mohammed monoid is a typeclass
 that represents data aggregation so data aggregation means you have some
 aggregator that is initially empty and you put data into it and it combines
 everything you put it into it into some aggregate value so it has two functions
 empty and combined so empty is just like the point it just gives you the
 value of that type and combined is just like the semigroup takes two values
 of the type of returns one additionally though we require that combine
 is associative just like in a semigroup and this law must hold so the empty
 value combined with anything either to the left or to the right should
 again return the same anything that you passed in so combining an empty
 with X does not change X that is a requirement so the value of the empty
 aggregate is special in the sense that you can combine empty aggregate
 with data and that doesn't change that data so monoids are used a lot in
 different contexts so one obvious context is log aggregation so you add
 logs and it's still log so you can add more you know put two logs together
 still it's a bigger log but it's still a log so that's you know you have
 an empty log or you can combine two logs that are maybe empty and you still
 have a big log as a result so logging is one application of this and there
 are other applications many many other occasion so one know it is a is
 a very useful abstraction so now we'll see examples of how to implement
 the monoi typeclass by either just doing it from scratch sorry implementing
 the PT TF and so on or in a very interesting way if we assume pointed and
 semigroup first so so pointed typeclass has this point function seven group
 has the OP function and you know it has these two functions of the same
 types while the names of the functions are completely material of course
 they can rename all you want the types are important so types are the same
 and so monoid is basically a semigroup combining is pointed and we can
 write code exactly saying that and save us the trouble of implementing
 everything from scratch so now we'll see how that works so first let's
 implement monoid from scratch we will not use trades will not use any names
 just the bare-bones implementation so the idea of implementation is that
 first we do a partial type 2 type functions so we define a type function
 and the value of this type should carry all the information we need to
 know this information consists of two pieces first the empty value remember
 the specification of monoid we need an empty value and we need a combined
 so empty value is just T combine as a function from T and T 2 T so let's
 put these two values in the tuple so we'll have a tuple of T and a function
 from T and T 2 T that's good enough we don't really need any names or trades
 or anything we just need the data the fact that they are called empty or
 combined this fact is immaterial this is not important we can rename this
 you can call us zero instead of empty we can call this append instead of
 combined or add or whatever or op it doesn't really matter what matters
 is the types so let's define the type domain for this partial type function
 that means we defined implicitly of type monoid int and 108 string so we
 define these values these are the tuples having the selected int value
 and the function that combines integers and the selected string value and
 the function that combines strings let's do it this way done so now we
 have the partial type 2 type function defined now let's define the function
 sum well we have finished defining the monoid typeclass let's define some
 partial functions so the function sum will take an argument of sequence
 of T and T will be constrained to have a monoid instance so or to have
 an evidence of belonging to the monoid typeclass so how do we do the implementa
tion while we fold down the sequence the first argument of the fold is the
 initial value which is the first element of the tuple the second argument
 of the fold is the combining function which is the second element of the
 tuple that's it we're done so some is implemented and it works let's implement
 a monoid tie plus in a slightly more verbose manner which might be not
 bad because it documents what we're doing it also helps read the code later
 because this code looks a bit cryptic with T comma T comma T parenthesis
 it's a bit cryptic so let's define names so instead of just using a tuple
 let's use names to pull name to post the case class so let's use it in
 case close call it monoid put names empty combined so exactly the same
 type and we define a type function in exactly the same way except now has
 names and these names help to help us document what we're doing exactly
 the same definition of the time to type domain except with the name exactly
 the same definition of the function some except now we have F dot empty
 and F dot combined because the typeclass has names if you compare with
 the previous definition that was f dot underscore one F dot underscore
 two so evidence now is a case closed and we can use noise names that's
 exactly the same code now good let's look at defining the pointed and the
 seven group in the same way so we define it as case classes with so this
 is the partial type two type function with its domain this is another partial
 type two type function with its domain now this is the partial type two
 type function we want to define and we want to automatically derive we
 don't want to repeat implicit values at all here how do we do that we use
 this with we use this implicit death so blessed F is a scholar feature
 which is that this function will be called by the compiler whenever necessary
 if it needs to produce an implicit value of this type it will see if it
 can call this function and if implicit value of these types are available
 if so it will insert the code to call this function and create these this
 value and put that into your implicit argument all of this will be happening
 silently and invisible so we define the instance is a function with two
 implicit arguments which returns the type evidence so it takes type evidence
 for semigroup and type evidence for pointed and returns type evidence from
 unalloyed well how do we do that well the type evidence from a Lloyd is
 a value of this type so we need to just create a case class value of this
 sorry of this type so we just say monoid which creates a case class value
 and we need to provide it with two values with the empty and that is the
 point from the pointed evidence and the combined function which is the
 cop from the sum of your packages that's it so we have defined the monoid
 instance the test will show that it works so we have not defined two different
 monoid instances for in ten string nevertheless we can use int and string
 in our code because this implicit def will generate them so imagine here
 we have 15 different types it's a big savings in code that we can automatically
 your life cause instances typeclass instances from previously defined evidence
 values now one other thing I'd like to show is that all these things are
 actually already defined in the library called cats and also in another
 library called scholar Z so all these typeclasses are pretty standard the
 semigroup the maloik and so on and they're defined in these libraries and
 the difference between these libraries may be names because types are the
 same your standard mathematical structures but the names might be different
 so in the cats library the names are empty and combined in the scholars
 e-library they're different names types are the same so how do we use the
 library to define Illinois so here's a here's a test so we want to say
 that if we have a semigroup and we have appointed we want to define a cation
 or instance so then we do it like this we define a value of type Katzman
 on it and that's a class so we do a new and then we override the functions
 empty and combine now unlike what we did here the cat's library does not
 use keys classes it uses traits and death methods so it means you need
 to override things but that's how it is otherwise it's exactly the same
 thing and then we can define some for the cats monoid and we can do the
 same test as before now one another thing that is interesting is that we
 can check laws in a generic way so I implemented this function to check
 cats monoid laws which is a function with a type parameter that takes an
 evidence that M is is from the cat monoid typeclass so these things are
 necessary for law checking all these assertions and arbitrary either property
 checks library notice I'm combining all kinds of syntax here I have typeclass
 syntax like this I have implicit argument of another type cost like this
 it's completely up to me and so this function will check their left and
 right identity laws that combine of empty and M is equal to M combined
 of M and M T is equal to M when the function data is equal is a general
 way of comparing two elements of type M it might be non-trivial if M our
 function types so that's why I have this data is equal by definite by default
 this is just a comparison but it could be different for function types
 we'll see examples for this social tivity law also needs to be checked
 up for all ABC and combine a combined BC is equal to combined combined
 ABC so that's associated and then I can call this function for interest
 ring but that won't compile because we didn't define them an audience in
 school double isn't a side here's how we can check laws for the partial
 type two value functions in a typeclass I'm using the Scala check library
 and the typeclasses it uses itself for instance or the arbitrary typeclass
 that typeclass means that the type has a function that produces arbitrary
 values of it or some set of values and that allows me to write for all
 function but of course cannot check all possible values but it checks the
 large number of them so then I write a function like this which is a generic
 function taking any type T as long as this type has an arbitrary instance
 and also a semigroup instance and then I'm imposing the condition that
 for all X Y & Z of type T the operation is associative so the operation
 of X with Y Z and gives me the same result as first combining x and y and
 then combining that result with Z now see I could have rewritten this function
 in a different way in a different syntax like this I can combine the typeclass
 connotations and this is just a different syntax and then I don't need
 to write this however now I need to replace this with something I need
 to access this operation which is the partial type 2 value function in
 the semigroup typeclass previously I had an implicit argument with named
 semi group F now the name is hidden I don't know what that name is so instead
 of doing this I just say implicitly same in group t that's and that's exactly
 the same thing so implicitly fetches the value of the pro of the implicit
 parameter of the given type and there's only one because there is a compile
 time error if they were two different implicit values of the same type
 so that's how I would write the code if I didn't want to put an explicit
 argument argument but actually it's exactly the same function that if I
 look at this function here I use it in exactly the same way I don't call
 it with any arguments so this is just syntax I can use this syntax or I
 can use the syntax I had before so once I have defined this function I
 call it by substituting different type parameters and this itself is also
 a partial type to value function that takes a type parameter and returns
 an assertion value and that better be success if it's a failure the test
 would fail so that's the way I can use the the Scala check library to test
 laws similarly I have a function that tests the monoid laws it takes an
 annoyed evidence and then tells me that there is a combined with empty
 which returns me the same value so notice this function is defined separately
 from the typeclass but it uses the same type domain as a time code typeclass
 it does not change the monoid or arbitrary type domain so I can combine
 two different type domains so there's no problem in defining partial type
 two value functions later in the code without changing the code of monoid
 typeclass later I can define further partial type two value functions like
 this one which will work on any type belonging to the relevant typeclass
 so that's the kind of extensibility we wanted use that to make my tests
 that verify with my defined instances for the moon the weight of integer
 in the noid of string they satisfy the correct mathematical law laws here's
 an example when this does not happen it does not satisfy the laws I create
 an instance of semigroup for a boolean but I use the operation which is
 the boolean implication if X than Y now this operation is not associative
 if I define this as my semigroup evidence which is the same as to say if
 I define this as my typeclass instance for boolean of semigroup typeclass
 then my law will not be satisfied so the associativity law is not going
 to be satisfied when I call this function this test will fail and it will
 print a counter example let me run this actually the Scala check library
 is such that it doesn't just check the laws for a large number of values
 of the parameters but if it finds some values that do not satisfy the law
 it tells me what those values are it will print the counter example values
 and then I can write a test where I can debug to see if this was about
 to see why it did not satisfy the law or I can write a test and that will
 correctly pass the law so let me just wait until this compiles there's
 a number of things it needs to be it needs to do and wellness test runs
 yeah so it fails it says true did not Eagle falls the current past generated
 values false false false so it prints a counter example in the previous
 run I had a different counter example which is false true false but false
 false cause apparently is also a counter example so then I have a test
 here that verifies that the laws are not holding and I use again this implicitl
y just to fetch in this but I could just instead of this since I know what
 that evidence is I can just say that the bad sending your evidence with
 exactly the same thing that's to say I made I declare that as implicit
 so fetching the implicit of this type is the same as just using your value
 of the type so now tests pass so let me undo my change alright so now let's
 consider a different example of typeclass which is a typeclass for a type
 instructor the example is that of a factor so the type constructor is a
 function if it has a map operation equivalently in earth map that satisfies
 the function laws which were they had identity law in the composition law
 now we would like to write a generic function that tests the functor laws
 so this function would look like this it will take the type constructor
 as as well as three types say ABC has type parameters and it will then
 run the tests with various values and check that all the laws hold for
 this type constructor this generic function should require that the type
 constructor F be a factor and we need to also access the function map that
 is defined for the given type constructor F so therefore we say that the
 map must be a typeclass so it is a partial type to value function whose
 type domain is following the filter type constructors while the factors
 F that we have declared and then we constrain F to belong to that typeclass
 in this function unit check frontier laws where did we do this in exactly
 the same way as before the only difference is that the type construction
 now is of a different kind is a type parameter F is a type constructor
 and not just a type based type nevertheless we just declare a partial type
 2 type function called factor which will be called like this it's type
 parameter is this F which is this type constructor and this will be well
 defined only for type constructors F which we have defined a functor instance
 in other words will define this implicit evidence value for each functor
 instance and we will then require that this implicit argument be one of
 the arguments of the check functor loss function we will see the implementation
 in a second and for now just note that functor is a higher-order type two
 type function it's a function whose argument it's a type function but it's
 argument is a itself a type function whose effort self the type function
 so just as we do with ordinary functions and we say that a function whose
 argument is itself the function is a higher-order function so here we just
 say this is a higher-order type function because it's argument is a type
 function it's already let's look at the test code them so we proceed in
 exactly the same way if you want to implement the Thunderer typeclass there's
 no matter that it's a higher-order type function we do exactly the same
 thing we define a trait let's say with a type rounder which is this F and
 we need to use the syntax with square brackets and underscore to show that
 this type is itself a typed function so this type parameter is itself a
 type function the trade has this def method which has itself to further
 type parameters because the factors map function has this type round now
 having these two type parameters pretty much forces us to use the trait
 with the DEF method for implementing the partial type two type function
 we could not do this within a data type because in Scala data values cannot
 have it themselves type parameters only def methods can have type parameters
 there are some ways of circumventing this limitation but they do not significan
tly change this fact they're just hiding the fact that somewhere there is
 a definite end with type parameters so let's not try hide this fact but
 use the trade with definite as very necessary so this is a partial type
 two type function what what is its type domain what are the type constructors
 for which we can have some values of type funky of F well let's say data
 one is one such type constructor so let's define some type constructor
 like this simple one let's define the evidence that this type constructor
 belongs to the type domain of this type function so the evidence means
 that we create a value of type filter of data 1 and this value could be
 anything could be evolved it could be an object so one way to write it
 is to say implicit object another way would be to say implicit well and
 then to say new here it's another different way of doing the same thing
 which one is better it's not so clear right now let's just use one of them
 now in this value when we extend this trait with a specific value of the
 typewriter we need to override this death metal because this def method
 has a different implementation for each type for each type constructor
 here so we need to override it so here we just write the implementation
 of the f map for the data 1 constructor so we already know how to do these
 things and I will not dwell on how to implement the factor instance for
 case closed now this is this is the entire definition of the partial function
 for type 2 type it now let's define our type 2 value function the map will
 use the F map will define generically the map so how do we do that well
 the F is one type parameter and we say this must be a functor that close
 and alb are two other type parameters and we define the F map as the functors
 F map so we fetch the implicit value which is this value or take the F
 map of it which is this sniff method apply distill F we get F of A to F
 of B and then apply this function to F a this gives us a value of f of
 B and that's the map method so the map method basically by hand we just
 use the F map and call it first of F and then on data and one away but
 you see this implementation is generic for all factors it is not specific
 to data one so in this way we have defined a generic partial type 2 value
 function where the type constructor is constrained to be a factor this
 is exactly what we wanted it would be impossible to call this with a type
 parameter that is not a factor because there is the implicit requirement
 so it required implicit argument it wouldn't be available other words so
 let's see how to use this so okay so we have this map function how do we
 use it let's create some data of this type and we just call that function
 on that date just an ordinary function the fact that this is a partial
 function is transparent we don't have to say what the type is the types
 are infrared data has a specific type data one of int this is a specific
 function from integer string so we transform this and we get data one with
 values one a B C 2 a B C or D 2 this transformation the result is of type
 data one of string so that's a typical result of applying a santur to data
 so as you see using the function map is no different from using a loan
 generic function but the definition of map is a generic one it would not
 have to be extended if we have more data types like data to that's safe
 with another function instance won't have to extend this function so this
 is very good for library design because we can put these functions into
 the library and we'll never have to extend them it's only the users code
 that needs to extend this needs to declare functor instances for new data
 types but this has to be done once together with each data type and you're
 done here's a function that can check functor laws it's a bit involved
 because functor laws involve arbitrary functions from A to B and from B
 to C and so I explicitly write down all the arguments that I need so these
 are the implicit arguments of this function factor f is a typeclass for
 functor then there are these arbitrary instances of typeclass so the Scala
 check library needs to use arbitrary values of these types to run the checks
 and if I don't put them here that it doesn't know that they exist but finally
 when I use this function I just give it some specific types and I don't
 have to specify anything more than that all these arbitrary instances are
 implicit values that are defined in the library and I don't want to talk
 about them in my code so for library design this is great the library becomes
 much more powerful and know his record needs to be written so just to be
 sure this is clear what this is doing it's checking the factory laws for
 specific types so data one is a factor and for example a the type parameter
 a here is int so here the identity law will be only checked for the int
 type so that into the int identity on data one instances of type data one
 int are preserved after F map that's the only thing that can it will check
 now I can obviously add some more checking here with different types with
 other types it's up to me I I can do this or I can neglect doing this but
 no more no necessary extra code so so let us see how the same works with
 a cat slightly you know the cats library has a standard function typeclass
 which is the cats not funky it works in a very different way except that
 it uses makeup rather than death map so the order of arguments is that
 first there is the data or the functor and then there is a function whereas
 the f map has the opposite order first the function and then the data now
 a convention that I follow is that the implicit values should be in the
 companion object of the data type now this is a useful convention because
 Scala has a mechanism for searching for implicit values and it will search
 in the companion objects of the types you are using so there is some function
 that tries to find implicit value of functor theta1 the compiler will automatic
ally search in the companion objects of function and in the companion object
 of later one now it makes sense to put data one specific stuff in a companion
 object of data one and functor specific stuff into a companion objective
 factor the factor is in the library later one is my own code so that's
 why I first defined my data 1 as as my own custom type and then I define
 companion object which is in Scala just an object with the same name as
 the type it's a special convention in Scala so in this object I have my
 implicit value I can again I can do implicit Val and then equals new if
 I want or I can do implicit object extends this it's up to me there is
 not a big difference and not a very different amount of code to be written
 when I write the implementation of the function instance so I implementing
 lab and then I check the factor laws so this function is very similar to
 what we saw above except it uses the cat's function typeclass within map
 so that's implemented in my test code very similar code checks the identity
 law in the composition law given three arbitrary types and a type constructor
 that must be effective so now having seen this let us take an overview
 of what we have achieved we have been working with type 2 value functions
 and type 2 type functions let's compare value to value functions and type
 2 value functions now value to value functions as the ones that are the
 ordinary functions the domain of a value to value function is the set of
 its admissible argument values we call that a type so the type is the subset
 of values that are admissible as an argument of functions of for example
 if the function takes an integer type of the argument when strings are
 not admissible arrays of something are not admissible nothing else except
 integers are admissible so in the set of all integer values is the value
 domain of that function and that's what we call a type so the function
 can be applied safely only if the argument is of the correct type and this
 is the example of having a function we declare its type and then we apply
 to some Y value and unless Y has this type this is not safe to do so so
 not safe to apply and if Y is not of this type there will be a compile
 time error that's how we use types types prevent applying functions to
 incorrect arguments now let's look at the partial type 2 value function
 it has a type domain which is the set of admissible argument types or type
 parameters the type domain is a sub set of types a sub set of type parameters
 that the function can accept so that is actually called a kind this is
 terminology it is accepted in functional programming so we say that the
 type 2 value function can be applied only to type arguments of the right
 kind similarly to a value to value function that can be only applied safely
 if the argument values are of the right type a function like this where
 we declare it's type parameter constrained to be in some typeclass this
 can be safely applied to a type parameter a only if a belongs to this typeclass
 we say only if alias of the right kind and in both cases the error will
 be caught at a compile time so if this is not the right type if this type
 does not belong to this typeclass writing this code will not compile in
 the case of PT BFS that will happen because the implicit argument will
 not be found but no matter it will still be a compile time error so kinds
 are the type system for types values are of the right type type arguments
 are of the right kind so a typeclass such as my typeclass defines a new
 a new kind as a subset of types there is a type notation which we use and
 there's also a kind notation now the kind notation is not part of the Scala
 language but we need a notation over the last to talk about kinds so I
 suggest to use this notation so star is a standard kind notation for any
 type basic type like integer or string an actual type that has values so
 star is a type that has values any type that has values and if I denote
 it like this with a typeclass a notation that means I'm only considering
 types that belong to the typeclass another existing available kind is a
 type function kind notation for that is this so let's look at an example
 consider this type and here F and T are types of different kinds F is a
 type constructor T is a type basic type not a type constructor so F is
 a type constructor or type function and so f has this kind is a function
 kind which is similar to function type except for types so it takes a type
 and returns a type a kind of T is the star T is just a basic type the kind
 of F is the function from basic type to basic type so this is the kind
 notation star means the basic type error means a function and colon with
 typeclass I suggest to use that for typeclasses here's an example we can
 define a type like this this is a type this is also type but this is a
 type function this is also type function so the kind of this is actually
 this expression it has two arguments the first argument is a type function
 which is this kind the second argument is a basic type which is a star
 kind and the return of this type function is a basic type which is a star
 called a return is a basic type pretty much always and so that would be
 the kind notation for app if I define the up like this note that Scala
 compiler will not compile if I put our own kinds so for example if I put
 up with two type parameters but a and B but a is not a type constructor
 so the kind of a must be the function kind or the type function kind if
 this is not so the Scala compiler will given there let's look at the test
 code so here I define type function just any type function here I define
 the app as in the slide now if I define type X like this I'm applying the
 type function app to the arguments G and int G is itself a type function
 defined here and so that's okay because app has the right kinds of arguments
 here so after I apply this X becomes the result of applying G to int which
 is this that's verified of X indeed is this so let's say X of type X is
 left of that and that compiles now if I were to try writing code like this
 it won't type check because the kinds are wrong the first argument of F
 must be a type function but it is not it is a basic type similarly here
 the second argument of app must be a basic type but it is not it is a type
 function so neither of these two will type check let's look at a little
 more complicated example we will write the tag current notation explicitly
 here again first we define a type constructor then we define app which
 has two arguments and the kind of app is this and we can write more verbose
 Li with argument names if we wish so f has the kind start to start a has
 the kind star so actually Scala requires the syntax that shows the kind
 you cannot just say F comma a if you write out of F comma a it will assume
 that F has star kind so you have to write this syntax if you want a higher
 kind higher order type now let me just say the terminology in functional
 programming has higher kind of types I don't think it's very limiting types
 are types are not kind it we don't say it's a higher type function we say
 higher order function because it's a function that takes functions as arguments
 here we have functions of types that take other functions of types of arguments
 why should we call it anything else than higher-order type function or
 higher-order type higher kind it is not very illuminating here so here
 is another different where I define up with two peas which is three parameter
 function the first parameter is itself a higher-order type function of
 the same kind as app so I can express it like this in Scala it's a little
 harder to read I have two arguments the first argument is a type constructor
 the second argument is a basic type and the function P is a type function
 of these two arguments so the kind of P is this the kind of Q is this and
 the kind of R is this basic typing so then I can define this you see I'm
 applying when I define the type function I said I need to apply P to Q
 and R and so Q is of the right kind to be put into P so now I can say define
 X the same X that I had here defined like this F by G int I can say app
 of app G and it will be exactly the same thing I verified the same things
 as I verified before namely that putting arguments of the wrong kinds does
 not work now there's one other thing that we would have to do if we want
 to be completely free dealing with type functions remember that in functional
 programming it's important to have anonymous functions not just named functions
 anonymous functions enable a lot of freedom in programming and without
 them things are difficult so functional programming really wouldn't work
 well without anonymous functions quite similarly we need anonymous type
 functions until now all we've seen were named typed functions all these
 names but we want also anonymous type functions because without them things
 are just not always possible to express anonymous type functions are more
 difficult to write in Scala but it is possible to write and there is a
 compiler plugin that makes the syntax easier it's just the syntax plug-in
 and I use that plug-in which is available and this address it's called
 the kind projector plug-in so let me show you how it works I define a type
 function just a simple one and I define the app just as before now I want
 to define a type function higher-order type function that takes a type
 constructor and applies it twice to its type argument so app two should
 take a P and the Q and then it will put Q twice into P so to speak so you
 see the first argument of P is a type constructor now previously I put
 Q as the first argument but now I want to put Q twice and on the SEC U
 of Q of a type argument to express this I need an anonymous type function
 because I want to put that anonymous type function as the first argument
 of the type function P unless I have that I cannot express this behavior
 this is the syntax of the kind projector it has the special single lambda
 and then it allows me to write my anonymous type function like this where
 X is now a new type variable anonymous functions type variable so this
 is a very similar syntax except under lambda and that is what the kind
 projector provides now instead of lambda I can write instead of the Greek
 letter lambda I can write lambda in Latin alphabet like that which is just
 more verbose no difference so this app to has this kind it's the same kind
 of app from the previous example except that here it instead of using Q
 once it uses Q twice it's it composes Q with itself q is a type function
 it composes that type function with itself in order to express such behavior
 we need anonymous type functions so now if I apply this app to using the
 o2 type constructor which is just an option of a tuple a a then this option
 of a tuple will be applied to itself twice so it will become option of
 a tuple of option of tuple option of tuple and indeed that's what it is
 x2 has this type and type checks so this is a bit of an advanced topic
 the anonymous type functions but this is similar to anonymous functions
 so just the syntax has to be a little different so as a result of this
 we have a uniform view of values and types types are two values as kinds
 are two types typeclasses are just a certain sort of kind function current
 type function is another sort of kind so there are different kinds there's
 type function kinds and typeclass kinds and you can combine them you can
 have a typeclass for type functions which is for instance for the factor
 factor is a type function and we can have a typeclass for it you can of
 course have typeclasses for higher order types as well so the syntax becomes
 a bit more involved but you can still do it if there is a use case for
 it so I showed you that there are some use cases for all these generic
 functions main idea being that you want to save your code you want to implement
ing generically right code once and have it work for all factors for all
 types from a certain typeclass and another thing that Scala provides by
 way of convenience is the implicit method syntax so let me show you what
 that is this is very often used together with typeclasses but this is a
 purely syntactic convenience there's no more power that this brings us
 the partial type 2 value functions are exactly the same as before all of
 these implicit things are just syntactic conveniences that make code shorter
 the basic idea of partial type T value functions remains the same so here
 is how it works in Scala in principle there are two sorts of syntax available
 for functions the first is the syntax similar to that of the ordinary mathemati
cs where you say function name in parentheses you list the arguments Scala
 also allows you several lists or one or more lists of arguments another
 way is to have a syntax like this X dot func of Y which is the method kind
 of syntax like object-oriented method all pretty much object-oriented languages
 use this syntax in Scala there is another equivalent syntax whenever you
 can say X dot funk of Y you can also say X space funk space Y sometimes
 that's easier to read now these functions are similar but they're just
 implemented differently and in some cases you can put you might prefer
 one in another case another so here's an example when it is convenient
 to have the method like syntax imagine we define a function called plus
 plus plus it is a partial type two value function and the type domain for
 it is this typeclass has plus plus plus and then there are some arguments
 and one argument is of type T so you will have to call this function like
 this plus plus plus of T and art now you would like to write this instead
 this is much more readable T plus plus plus Arg whatever plus plus plus
 means in your application this is certainly easier to read than this Scala
 provides a way of implementing that syntax this is what I call the implicit
 method syntax extension syntax so what is the implicit method syntax suppose
 you want to convert func which is a partial type to value function to the
 syntax you declare that as a method on a new trait or class well a new
 trait is necessary usually a class is sufficient and you declare an implicit
 conversion function from T to this new class and this implicit conversion
 function is a PTV F using the same typeclass so in this way you automatically
 extend your existing typeclass with new syntax you do not change a type
 domain of your typeclass when you do this since you don't change the domain
 you don't need to change the code of the existing typeclass so this can
 be done in a different piece of code or a different library different module
 and the implicit conversion function can be done as an implicit class I
 will show you the code in a second and that makes called shorter action
 here's how it works suppose we implements the monoid typeclass so this
 is our partial type 2 type function which has some methods in the trait
 here is our syntax so this is this new trait or class that we need to implement
 for the syntax purposes I called an implicit class and it has one argument
 which is so it's implicit class is really a function that at the same time
 defines a new type of this name and the function that creates values of
 this type the function has this argument it also has an implicit argument
 of the partial type 2 type per function which means that this is a partial
 type to value function so like I said implicit class means you define at
 once and you type and a function that creates a value of this type with
 this argument so in this way it's doing what I said here to do in one step
 I define a new trailer class a new type and I define a function that creates
 values of that type from values of type T so here's type M at the same
 time I constrain the type parameter m to belong to the typeclass la nuit
 so now it's a very short code comparatively all I need to do now is to
 implement a method that I want the method I want is the syntax method so
 let's call it append log I can change the name if I want because this is
 an extension so I do not actually change the functionality of monoid as
 it was previously defined I'm adding new syntax to the previous syntax
 the previous index will still keep working and so I can have a new name
 if I wish for the new syntax so this is the method that will be available
 on 108 types and the method will be append log with an argument Y I will
 just use the combined method from the moon wind and there's no new functionalit
y here I'm just repackaging the combined in the new syntax so how does this
 work then here's a data type in my application which is log data as I mentioned
 before logging is a typical monoid example because there isn't there's
 an empty log and there's appending to log so you can put two logs together
 and it's a bigger log again so let's define what empty log means is the
 string that says no log so far and then let's create a menorah instance
 which is a monoid of type my log data I'm using implicit Val here why not
 so the combined function will check if one of the logs is emptied and I
 just take the other one if not empty I will concatenate logs and add a
 new line between those log lines so this is a little more sophisticated
 than just concatenating strings so my logs will be well formatted will
 always be new lines separated then I import this monoid syntax now this
 is the new thing that I defined here for syntax I import and now here's
 the code of my application I have some log values here one log message
 another log message and then I just say initial log a pen log log data
 wand a pen log log data - so I'm appending all these logs so this is the
 new syntax but I have just defined and it works the log result is equal
 to this string what I could do for instance very easily now cuz I could
 rename the second log to [Music] plus plus plus what happens then I have
 code like this so this might be more readable depending on my application
 I am free to add new syntax without changing the typeclass that was defined
 before so I'm completely open to extension without having to change any
 of the library code for Edmund okay so to summarize what we have gained
 is that the partial function that we defined appears as emitted on values
 of the relevant types and only on those types so the plus plus plus will
 be only defined on those types that have a monoid instance in my previous
 example and the new syntax is defined automatically on all the types I
 did not have to define plus plus plus specifically for my log data not
 like that at all I define it generally for any type M it has a monoid instance
 so this is the power of typeclasses let's now go through some worked examples
 this is going over the entire material of this tutorial the first example
 is that we want to define a partial type value function of this kind the
 bit size has a type parameter T and if that's an int type it returns 32
 and if it's a long net return 64 otherwise this type the value function
 remains undefined how would we implement that we go systematically so a
 partial type 2 value function requires first of all the partial type 2
 type function to define a type domain so let us define this type constructor
 as a case class we could not just use a type definition because that's
 all going to be int for all the types T and so that's going to be a type
 collision so let's do a case class instead so this is a type constructor
 that will be our personal type two type function now we want to define
 this only for intent law so we do implicit Val bit-sized int evidence has
 bit sized with value 34 and long evidence has bit sized with value 64 32
 64 notice we put into the type that will be our type function we put the
 information that this function needs that the function we want is the bit
 size that will return to our 64 this information is carried by this type
 so the f-type evidence value here is the information we need that's almost
 always going to be the case for any partial type functions the partial
 type to type function represents a type that carries all the information
 we'll need about the type that the type 2 value functions we'll use later
 and the only information we're required to return is this number so let's
 put this number as our type in here now we define the partial type 2 value
 function so bit size has an implicit argument of type with size T and that
 returns just this evidence value dot size that's enough that's all we need
 to do and indeed this works as expected the test verifies that the next
 example is to define the mono it instance for this type now notice this
 is an option of a function from string to string so I'm going to use that
 as a type and I'm going to use the cats library for the standard memory
 typeclass so my tests here are all going to use the law checking for the
 cats library that I implemented in a different file so this is my data
 type I just define this as an option from string to string since this is
 such a simple type no need to do case classes here myself so defining a
 typeclass instance for the standard typeclass in the library means that
 the type constructor that PT TF is already defined in the library it is
 the monoid already defined in the cat's library the type constructor is
 there but I'm going to add more types to the domain so that's always going
 to be possible adding north types to the domain of this portion function
 and this so because the mono it is not sealed trait is just a trait not
 sealed here and so I can always add new new instances or new types to the
 type domain of that partial function so I'm going to so add this type to
 the type domain in order to do this all I need to do is to create value
 of the type monoid of data that's all that is required now so here's one
 value I create on this type I need to override two functions empty and
 combine the empty is a value of this type it combined is a function from
 two values of this type to a third value of this type so what is a naturally
 selected value of this type well I can think of many one could be it's
 an option of identity function so for some identity function so that's
 what I write here and the combined would have to be such that if there
 is a non-empty option then I compose these two functions so I have some
 of one function string to string some of another function I can post these
 two functions so this is the code I'm writing here so if there's a sum
 and the sum and I compose these two functions in all other cases I return
 none so clearly the identity function here is a neutral element for this
 operation so if I compose identity with anything I get the same function
 again in all other cases I get none anyway so this will satisfy the laws
 hopefully it's kind of a little boring instance because it very often produces
 none whenever one of the two parts of the combined one of the two arguments
 of the combined function isn't none it will produce no another instance
 would produce not much less frequently how would that work well if one
 of the two arguments of the combined function is none then I return the
 other one and so none becomes the neutral element and then I do compose
 the functions if they have two functions so basically I prefer to keep
 the function if I have one is non-empty option I prefer to keep it unless
 both are empty then the result won't be none so that's perhaps a more interesti
ng instance but we're free to choose one or the other it's not really clear
 at this point which one would be more interesting so there could be different
 implementations of the same typeclass and there could be use cases for
 both of them because of this I don't make them implicit in my test code
 I want to keep them explicitly implicitly be possible with only one of
 them because I cannot have two positive values of the same type and I check
 that both of these satisfy the monoid laws no the satisfying minora Clause
 requires two implicit arguments of the arbitrary data and non-oil instance
 so I since I'm not doing the implicit I have to put these arguments by
 hand if I look at this function it has an arbitrary typeclass and the monoid
 typeclass so I need to present arguments and the arbitrary data I don't
 know where to get that but it's implicitly available so I just say possibly
 arbitrary data and that's how it works both are valid monoid instances
 it turns out the third example is by assuming that a and B are types with
 monoi oil instance I define a monoid instance for the product type so this
 is a interesting example because it shows that I don't have to implement
 everything from scratch if there are monoid instances for some previous
 types I can just define monoi instance for a new type and don't have to
 write a lot of code maybe those monoid instances for the previous types
 had a lot of code on them but this code is not very large so how do I do
 that well I use this implicit death mechanism which is I define a function
 that produces the type evidence for the product type so the type evidence
 is the value of a type monoid of product type so i produce this type evidence
 given the type evidence for monoid a and one going to be so this is what
 it means sure to define the noid instance for product a B if I have monoid
 instances for a and B it means to make a function it takes the two monoid
 instances I remind you that what noid instance is exactly the same as a
 type evidence value it's just for from annoyed so typeclass instance is
 exactly the same as a type evidence value it's a value of the type that
 is the partial type two type function applied to the type that were producing
 evidence for so if you want producing evidence for type a and type evidence
 is something of type one noid a and that's something we'll typically carry
 the entire information when to implement know it for type a so that is
 also called for that reason monoid the monoid instance for type a and so
 our task is to implement a function that takes monoid instances for types
 a and B and produces a monoid instance for type product a B well so how
 do we do that we'll just say we're all new monoid which is the way to extend
 the trait very quickly and we override two methods so we need to produce
 a value of type tuple a B and the evidence will give us a value of type
 a and the value of type B so we just put them into a tuple and the combine
 works in a similar way so we know how to combine two A's and we know how
 to combine two B's so let's shows us how to combine a tuple a B and another
 tuple a B or just combine a separately and you combine these separately
 and you use the evidence values to fetch the combined functions from the
 one monoi oil and another monoid so that's all let's test so this test
 is just going very slowly to make it clear exactly what we're having achieved
 well we have achieved so first we have no entered uh Balma lloyd instances
 in scope just make sure we don't have them so this would not compile and
 this would not compile now we declare these instances so for int let's
 say the empty value is 1 and combined is product that's fine that works
 for double-amputee is zero and combined as a sum that works to multiplication
 actually wouldn't work because it's not precise enough and it would violate
 associativity by precision errors by by roundoff errors so I use addition
 not multiplication for double alright so after I have defined instances
 as implicit values of these types we have both int and double monoid instance
 event scope in this will compile and work whereas here it did not alright
 so now that should be sufficient for us to be able to derive the Malloy
 instance for the tuple int double automatically and that works so the monoid
 law has work that's this test runs and that's how it works the next example
 is to show that if a is a monoid and B is a semigroup then the disjunction
 a plus B is a mohamed now to show this means again to write a function
 it takes a type evidence for monoid of a in the type evidence for semi
 group of b and produces the type evidence of monoid of a plus B were using
 equivalent terminology typeclass instance for monoid of a typeclass instance
 for B as a semi group these are two values these are going to be arguments
 of my function and the result of my function must be the typeclass instance
 from annoyed for type a a plus B just either a B so showing this is not
 some kind of theoretical mathematical exercise but it's a specific coding
 exercise I need to write a function that produces the evidence of monoid
 typeclass given these two evidences and I want to check laws so here's
 how it works this is this function has two type parameters and two implicit
 arguments one is the evidence that a E is a monoid and the other is the
 evidence that B is a semigroup remind you the semigroup doesn't have the
 selected element mono it has both a selected element and the binary operation
 a semigroup just has the binary operation no select an element so it's
 interesting that if we combine the two of them with the disjunction and
 the result can be monoid while in the previous example we had a product
 both of them needed to be a monoid for the product okay I'm annoyed because
 we need to produce the empty value so both of them must have an empty value
 but here with disjunction we don't need to produce both empty values just
 one is sufficient so that's why one thing I'm annoyed and another is the
 semigroup is sufficient alright so let's see how that works so empty element
 needs to be of type either a B well obviously we don't have selected naturally
 selected element of B because it's a seven group we do have a naturally
 selected element of monoid so we produce that okay now how does combine
 work all takes X of either a B Y of either a B needs to produce again either
 either a B so we have different situations we can have a and a we can combine
 a a obviously because it's a monoid b and b we can also combine b and b
 obviously so these cases are easy another two cases when it's not clear
 what to do now we have a left of XA and the right of YB so how do we combine
 now we can't really combine a and B we have no idea what these types are
 except that one is a semigroup and another is a monoid but they're not
 combined a ball directly one with the other so we have to ignore one of
 them which one know we can think about this but basically things don't
 work unless here you ignore the X and here you ignore the Y and let's check
 that this is correct first we don't have instances then we define instances
 for int so let's see we need something that's not a monoid that's a semigroup
 it's kind of hard to come up with such such a thing most operations we
 know are monoidal like plus because as neutral we needed an operation that
 does not have a neutral element but is associative so it's not easy well
 fortunately there is a paper which I'm referring to here it describes a
 function that is non commutative but associative and this function does
 not have an inverse and it does not have a neutral element so I'm using
 this function which is buttons function which is described in this article
 you find by this formula very simple formula kind of curious in this not
 commutative and yet associative in any case this is fine for a semigroup
 and for the double I use the same instances before the addition with zero
 and it works so if you change this to X instead of Y or here to whine sin
 of X it was not work it will break so this is a curious definition but
 that's interesting we have only one choice to define annoying instance
 on the disjunction so think about it option is a disjunction so if you
 have a monoid an option a is a monoid an optional is also a monoid disjunction
 of two monitors I'm annoyed because the second group is less than a monoid
 so that's good conjunction of two Mundo videos I'm annoyed so you can combine
 Malloy's quite easily and this is a generic way of defining these combinations
 the next example is to define a functor instance for this type now here
 were using try which is a scholar standard library API just not a data
 type it's a special thing you find in the Scala library sequence is a another
 thing you find in the Scala library so we're just trying to say how can
 we do things with Scala library you find type constructors can we make
 them into functors in terms of cats library let's say yes so we say here's
 this type I use the type definition to define the type function f so that
 F after this becomes a type function defined like this and then and in
 order to define a functor instance I need to define an implicit value of
 type factor of F so that's why first I define this name F like this is
 a type function and then I declare the new factor instance by overriding
 the map now I just implement the map so hard way implement the map well
 FA is this F of a which is a sequence of trial of a I can map over a sequence
 the result will be a try I can map over try and the result will be again
 a try so this is a functor because it has a map this is also a function
 because it hasn't helped composition of two funders is a factors because
 this is a functor because I can just compose maps like this and all I'm
 doing here is to make the cat's library aware of this being a factor so
 that's all I need to do I'm not going to check laws here because it's quite
 a lot of work to produce arbitrary values of these types especially they
 try but it is easy to verify that composition of two functions is a factor
 so we could have checked the laws if we wanted to the next example is to
 define a cats by functor instance for this type function and notice that
 this type function has two type parameters x and y and by functor is a
 typeclass defined in cats as a standard by standard typeclass that is like
 functor except with two type parameters it's a factor with respect to both
 of them so to define that first we define a type function or type constructor
 the name of that is Q as we are given here and then I'm using either just
 to reduce typing I don't want to declare my own sealed trait and two cases
 for the disjunction but I could of course declare Q as a sealed trait with
 two type parameters all be just more typing then all I need to do is to
 define an implicit value of type by factor of Q so this is code that does
 that to do that I need to override this function by map so by map means
 that it's a factor when you transform both type parameters at the same
 time can that's a factor so by factor means that it's a factor with respect
 to both type parameters at once so you transform both of them at the same
 time and the result transforms as you will expect so for instance either
 of a a be transformed with two functions two arbitrary functions one a
 to C and the other B to D replaces this with either CCD so that's what
 is required now I'm not going to write code for this function and we're
 just going to use my curry Howard library to implement the code automatically
 using the type this is possible and it works I'm just trying to reduce
 the time I'm spending writing code now disk this is something we already
 know how to implement functions given their types and this work can be
 done by the computer so why not the non-trivial part here is how to define
 typeclass of instances and that's what we do by hand having done this we
 have defined a simple set value and we check the by funky laws now the
 checking the by funky laws is again a function I implemented in my test
 code the next example is to define a country funkier typeclass so this
 typeclass is like functor except it has contra f map where the direction
 of the arrow visa counter to the direction of the transformation of the
 function values the type constructor values since a contra factor and the
 example consists of first defining a new typeclass having this partial
 type 2 value function and then to define an instance of this type laws
 for the type constructor of this formula which is type argument a going
 to integer so this is a contra funky because the type argument is to the
 left of the function here and we expect to be able to define an instance
 instance of a country funky die class for this type of structure so let's
 see how that works so the given country factor is this and let me define
 the type right away so after this I have defined the type function C so
 first we need to define a new typeclass which consists of a partial type
 two type function carrying the data and we're required to carry this this
 type function is contra functor with type variable which is the C now see
 here is a parameter name it's a little confusing perhaps let's call this
 C Bo just so that we don't confuse this with this C over here so this is
 a contra factor this is a trait having a deaf method of the signature we're
 required to help and in order to show that this type domain includes this
 C we are required to produce a value of type control factor of C so we
 do it like this so we we can either do a new country factor or we can do
 an implicit object extends country factor is the same thing could you do
 that it would be equalled we need to override this function and this function
 is to have this type from FB to a to a tend to be target again I let my
 curry Harvard library handle this code and once I'm done it will work let's
 do the same thing with cats lightly cats library has a contractor typeclass
 which is called contravariant and it has a different name and a different
 type of the function instead of F myopic as my episode not a flipped argument
 order other than that is very similar so how do I know this well I just
 let me show you how I know this I just do that it's not happy because I
 need to define country map as it tells me so I press this button here and
 I say implement methods tells me what methods I need to implement now C
 of a is a - int as far as I remember and now I can just say that's my very
 hard lighting at work all right the title notation which is required and
 then and then I define equality comparison function for this scene it says
 it's a function so C of int let's say is a function and comparing two functions
 is not immediate need to substitute different arguments and compare results
 so that's this C equal code that says for all T C 1 of T must be equal
 to C 2 of T and when the function C 1 is equal to C 2 so that I substitute
 into the law checker and it will check my laws and that works tests lastly
 the next example is to define a functor instance for the recursive type
 we find by this formula so here let me first define this recursive type
 so it's the seal trade with three cases and the third case is recursive
 it contains the same type of the trade itself all the cases on the trait
 are parameterize by the type parameter a and extend cubed so this is a
 functor because any always occurs to the right of the error or here but
 this is the recursive instance so let's find it so let's implement the
 functor instance with a new factor so functor' is the cat's functor just
 to check and needs to override the map let me type override it's not necessary
 to type all right but it's more checking this way if I mix up the type
 it was tell me that I'm not overriding it in the right way so with these
 object oriented things more checking has a better so type override make
 sure that it checks that you are overriding it with the correct type okay
 so what does this function do this function takes an FA of type QA it takes
 a function f from A to B and it needs to produce K only so to do that we
 have to match on this value let me rename this to Kiwi for clarity the
 first case is the function from int to a well obviously I need to compose
 this with a function f and then I will have a function from int to be as
 required the second case doesn't have any age so it remains unchanged just
 the type has type parameter is changed there was C 2 of a now it's C 2
 of B ok so this is option int I said option int I'm not sure something
 is fishy here well X is int that's true oh I see it's a case it does not
 tell me the type and it tells me something else tells me that possible
 trying with your types so the interesting case is the third case so the
 Q here is a key of a and I need to produce key of B now I know how to produce
 key of B so I used a recursive call to the same map that I'm defining and
 I call this one q + and put this into c3 so in this case I remain in the
 c3 case and I transform this Q by using the recursive definition of the
 same map so that's how I have to do it there's no no other way really so
 in this way we defined a functor instance so let's see how I would check
 that this function works correctly so for example I get this implicitly
 founder Q dot map is the value that I just defined I could have said Q
 functor instance dot map because I just defined it here but I don't want
 to know about these names these names are completely unimportant as long
 as you make them implicit so I'm going to use this as my data and put identity
 function on it and see if that transforms the data into the same form and
 it does so it's just sanity check I'm going to check the laws are more
 systematically in a second to do that I need an equality comparison so
 that's a bit involved because there are many cases so I'm going to compare
 each case and then there's a recursive case as well and I need to compare
 functions so all of that requires extra code so here is the case for comparing
 functions here's the recursive call so if I need to compare a c3 with c3
 I recursively compare their contents of c3 using the same C equal function
 so that's how this works this is just to see that this works this would
 fail is that on the same and finally I call the frontal or checker on this
 type using C equal and the tests pass the final worked example was a bit
 more advanced so I started but it's not so bad it's to show that you can
 define a functor instance for a disjunction if you have functor instances
 for the two type constructors so this is a bit more advanced because you
 need to define a type function that is a disjunction of two given type
 functions so I need to define an implicit def which would have to type
 arguments F and G each of them being type functions and two implicit arguments
 which are the evidence that F is a factor and that the G is a function
 but what am I going to return I'm going to return if evidence that F plus
 G is a function but what is F plus G F plus G is a new type constructor
 in other words a new type function but it doesn't have a name yet and I
 cannot have a name for it because F and G are my parameters so the only
 way I mean to express this is to say that this is an anonymous type function
 so I'm returning type evidence that an anonymous type function is of typeclass
 functor and this is this anonymous type function it's X going to either
 f of X and G of X so that's a type X is a type parameter this is type expressio
n that defines my type function and so the lambda syntax is syntax for anonymous
 type functions using the kind projector plugin so that is the kind of difficult
 part and other than that the school is quite straightforward the difficult
 part is reasoning about these higher-order type functions so for convenience
 I can put a name on it in the body of this function but I cannot put a
 name on it before I define the function return type so that's why this
 kind projector is important but other than that it's not so bad so type
 either FG is a type function that is the same as this anonymous type function
 over there it just has a name now and that's now easier to use I can just
 put this name whenever I need it so now I return this functor instance
 by overriding the map I have can either F G of a and I have a function
 from A to B and I need to return either G only so how do I do that well
 I get this FG a which is either F of T or F of a on G of a I'm matching
 it if it's F of a then I use the evidence for F to get the map of F away
 with less transformation T and if it's in the right I'll use the evidence
 for G to get the map for the functor gene use that map on the G value and
 the transformation T so that's it that's a very straightforward code now
 I test this code I create filter instances for some simple data types D
 1 and D 2 very very simple data types for these data types I can just implement
 functor instances like that automatically and finally I I say well let's
 call this d1 or d2 so funny again for convenience introduced a specific
 name for the disjunction of two factors so this d1 or d2 is now a new type
 function which has a disjunction of the two type functions d1 and d2 and
 I check the function laws for d1 or d2 now the implicit function here was
 called invisibly I didn't have to call it myself to produce the type evidence
 that this is a functor but you see this function requires that evidence
 it wouldn't break even compiling if I didn't have that evidence since it
 compiles them it's correct now in this code I will show you how I attempted
 to do this without the current projector it's kind of difficult and the
 problem is we need to define this name if we cannot have anonymous functions
 anonymous type functions we have to define this name somewhere but we cannot
 define it before we have the type constructors F and G and so we have to
 define it inside the body of the function and then we can define the instance
 like this and check the laws but nobody outside of this function can see
 that instance because this is a function this is not an object this is
 not a well is this a function has to be called and when you call us it
 will define the instance and check the laws for it which works but normally
 outside of this code will be able to use this in instance so if you don't
 use the kind projector then you can't really express this situation but
 you actually have defined a functor instance for a disjunction of two arbitrary
 factors given as type parameters and this functor instance you see it's
 usable outside of this code so I can put this into a library I can put
 this into the companion objective factor and nobody will have to do any
 imports or anything just we'll just work automatically so that's the power
 of implicit function definitions that can automatically build new implicit
 evidence value so this is this becomes a new impressive evidence value
 that is automatically built up from existing implicit evidence values these
 two so this concludes the worked examples and here are some exercises for
 you that are quite similar to the worked examples and once you go through
 these exercises you will really have a solid understanding of type functions
 and typeclasses by way of conclusion let me summarize what are the problems
 we can solve now we can define arbitrary partial type two type functions
 and partial type two valued functions typeclasses are just a way to systematica
lly manage partial type two value functions a lot different so just PTDS
 under student is somewhat more systematic way we can define these together
 or separately we can define some of them then later more partial type two
 values functions we can combine them we can use a Katz library to define
 instances for some standard typeclasses such as mono word semigroup functor
 and so on we can derive typeclass instances automatically from previously
 derived ones or previously programmed ones and we can reason about higher
 type functions types and kinds whatever that is necessary so what is it
 that we cannot do at this point no there's still things we cannot do one
 of these things is to derive typeclass instances automatically for polynomial
 data types notice the case classes sealed traits with disjunction in case
 classes with with data in them although that curry Howard library can do
 this in some cases it cannot do this in all cases and cannot do this automatica
lly by implicit deaths either this requires more advanced tools which are
 available in the shapeless library and I have a link to a book online book
 a guide to shapeless where it is explained in depth how automatically an
 automatic derivation of type last instances works in the shapeless library
 another thing we cannot do is to derive a recursive type generically from
 an arbitrary type function so we have just seen an example of defining
 a functor instance for recursive type but this type was defined by hand
 so suppose we have a type function f given as a parameter and we want to
 define a recursive type R via this equation this is a recursive type equation
 or also called a fixed point equation R is a fixed point of the function
 f so this fixed point is a function of F and that function is usually denoted
 by Y the so called Y Combinator it takes an F which is itself a function
 and it returns its fixed point so the y must be defined by type equation
 of this sort so Y of F must be equal to Y of F is that R which is equal
 to F of R so Y of F must be equal to F of Y of F but this doesn't compile
 Scala doesn't allow us to make things like this more work is necessary
 to even define such things or have a generic type function that computes
 the recursive type and we haven't seen how to do it also for such recursive
 types we cannot derive typeclass instances automatically so for instance
 if F were a functor with some other type parameter then R would also be
 a factor or if if F is a mono then I would also be able know either something
 like this we would like to derive automatically typeclass instances whenever
 they exist and we cannot do this with the tools we have seen here now there
 are some advanced libraries like matryoshka that implement type level recursion
 or type level fix points that are able to handle these problems giving
 you a link here also shapeless might help not sure in any case these are
 more advanced topics which are perhaps further away from practical applications
 than I would like and there are some interesting discussions there is a
 blog post very interesting series of explanations of this kind of stuff
 that I encourage you to look at if you're interested this concludes chapter
 5 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
