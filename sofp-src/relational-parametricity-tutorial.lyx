#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Relational parametricity]{Relational parametricity and "theorems for free"}
\subtitle{A tutorial, with example code in Scala}
\author{Sergei Winitzki}
\date{2021-09-04}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\usepackage[nocenter]{qtree}
\usepackage{relsize}
\renewcommand\arraystretch{1.4}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,List,Option,Either,Future,Vector,Range,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frame{
\backslash
titlepage}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Beginning of slides.
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivation for parametricity.
 
\begin_inset Quotes eld
\end_inset

Theorems for free
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\series bold
Parametricity
\series default
: all fully parametric functions satisfy their naturality laws
\end_layout

\begin_layout Itemize
Naturality law: code must work in the same way for all types
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def headOption[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case Nil            => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case head :: tail   => Some(head)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Quotes eld
\end_inset

Fully parametric
\begin_inset Quotes erd
\end_inset


\series default
 code: use only type parameters, no JVM reflection 
\end_layout

\begin_deeper
\begin_layout Itemize
Naturality laws are 
\begin_inset Quotes eld
\end_inset

for free
\begin_inset Quotes erd
\end_inset

 only if all code is fully parametric
\end_layout

\end_deeper
\begin_layout Itemize
Naturality law for 
\family typewriter
\size small
\color blue
headOption
\family default
\size default
\color inherit
: for any 
\family typewriter
\size small
\color blue
x:
\begin_inset space ~
\end_inset

List[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
,
\end_layout

\begin_layout LyX-Code

\size small
\color blue
headOption(x).map(f) == headOption(x.map(f))
\end_layout

\begin_layout Standard
Parametricity theorems work only if the code is 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Parametricity theorems apply only to a subset of a programming language
\end_layout

\begin_layout Itemize
Usually, it is a certain flavor of typed lambda calculus
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Examples of code that fails parametricity
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Explicit matching on type parameters using JVM reflection:
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def badHeadOpt[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case Nil                 => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case (head: Int) :: tail => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case head :: tail        => Some(head)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Standard
Using typeclasses: define typeclass 
\size small
\color blue
NotInt[A]
\size default
\color inherit
 returning 
\size small
\color blue
true
\size default
\color inherit
 unless 
\size small
\color blue
A = Int
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\size small
\color blue
def badHeadOpt[A]: List[A] => Option[A] = {
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case h :: tail if implicitly[NotInt[A]]()   => Some(h)
\end_layout

\begin_layout LyX-Code

\size small
\color blue
  case _ => None
\end_layout

\begin_layout LyX-Code

\size small
\color blue
}
\end_layout

\begin_layout Standard
Failure of naturality law:
\end_layout

\begin_layout LyX-Code

\size small
\color blue
scala> badHeadOpt(List(10, 20, 30).map(x => s"x = $x"))
\end_layout

\begin_layout LyX-Code

\size small
\color blue
res0: Option[String] = Some(x = 10)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\size small
\color blue
scala> badHeadOpt(List(10, 20, 30)).map(x => s"x = $x")
\end_layout

\begin_layout LyX-Code

\size small
\color blue
res1: Option[String] = None
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace 100baselineskip%
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Fully parametric programs are written using the 9 code constructions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = { // 3
\end_layout

\begin_layout Plain Layout

   case Nil            => Nil
\end_layout

\begin_layout Plain Layout

//   8   1                1,7 
\end_layout

\begin_layout Plain Layout

   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

//   8       6             2 4     6  5 2 4     6    7   9
\end_layout

\begin_layout Plain Layout

}           // This code uses each of the nine allowed constructions.
\end_layout

\end_inset


\begin_inset VSpace -20baselineskip%
\end_inset


\end_layout

\begin_layout Enumerate
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value (or equivalent type), e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use bound variable (a given argument of the function)
\end_layout

\begin_layout Enumerate
Create a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr(x) }
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a function: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create a product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 (or via pattern matching)
\end_layout

\begin_layout Enumerate
Create a co-product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use a co-product: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...
 => ...
 }
\end_layout

\end_inset

 (pattern matching)
\end_layout

\begin_layout Enumerate
Use a recursive call: e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

 within the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Why we need relational parametricity
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Relational parametricity
\begin_inset Quotes erd
\end_inset

 is a method for proving parametricity theorems
\end_layout

\begin_layout Itemize
Main papers: 
\begin_inset CommandInset href
LatexCommand href
name "Reynolds (1983)"
target "https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf"
literal "false"

\end_inset

 and Wadler 
\begin_inset CommandInset href
LatexCommand href
name "“Theorems for free”"
target "https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf"
literal "false"

\end_inset

 (1989)
\end_layout

\begin_deeper
\begin_layout Itemize
Those papers are a bit outdated and also hard to understand 
\end_layout

\end_deeper
\begin_layout Itemize
There are very few pedagogical tutorials on relational parametricity
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "On a relation of functions"
target "https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Backhouse (1990) 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "The algebra of programming"
target "https://themattchan.com/docs/algprog.pdf"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Bird and O.
\begin_inset space ~
\end_inset

de Moor (1997)
\end_layout

\end_deeper
\begin_layout Standard
This tutorial does 
\emph on
not
\emph default
 follow any of the above but derives equivalent results
\end_layout

\begin_layout Itemize
Alternative approach: prove 
\begin_inset Quotes eld
\end_inset

dinaturality
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset href
LatexCommand href
name "de Lataillade"
target "https://www.irif.fr/~delatail/dinat.pdf"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "Voigtl\\\"ander"
target "https://arxiv.org/pdf/1908.07776"
literal "true"

\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
Dinaturality is a consequence of relational parametricity
\end_layout

\begin_layout Itemize
In practice, dinaturality laws are sufficient in most cases
\end_layout

\begin_layout Itemize
But some proofs still need full relational parametricity
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivating relational parametricity.
 I.
 Naturality laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Naturality law: applying 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

F[A] => G[A]
\family default
\size default
\color inherit
 
\emph on
before
\emph default
 
\family typewriter
\size small
\color blue
_.map(f)
\family default
\size default
\color inherit
 equals applying 
\family typewriter
\size small
\color blue
t[B]:
\begin_inset space ~
\end_inset

F[B] => G[B]
\family default
\size default
\color inherit
 
\emph on
after
\emph default
 
\family typewriter
\size small
\color blue
_.map(f)
\family default
\size default
\color inherit
 for any function 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\end_layout

\begin_layout Standard
Naturality laws need 
\emph on
lifting
\emph default
 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
F[A] => F[B]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[A] => G[B
\family default
\size default
\color inherit
] 
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar[d]\sb(0.5){~\mathtt{\_.map(f)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar[d]\sp(0.5){\mathtt{\_.map(f)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset


\end_layout

\begin_layout Itemize
Proof of the naturality law requires induction on the code of 
\family typewriter
\size small
\color blue
t[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
This code is built up by combining the 9 code constructions
\end_layout

\begin_layout Itemize
This code may include sub-expressions of types not covariant in 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivating relational parametricity.
 II.
 The difficulty
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Cannot lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
F[A] => F[B]
\family default
\size default
\color inherit
 when 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 is not covariant!
\end_layout

\begin_layout Itemize
For covariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 we lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
fmap(f):
\begin_inset space ~
\end_inset

F[A] => F[B]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
For contravariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 we lift 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

B => A
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
cmap(f):
\begin_inset space ~
\end_inset

F[A] => F[B]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
In general, 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 will be neither covariant nor contravariant
\end_layout

\begin_layout Itemize
Example: 
\family typewriter
\size small
\color blue
foldLeft
\family default
\size default
\color inherit
 with respect to type parameter 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
def foldLeft[T, A]: List[T] => (T => A => A) => A => A
\end_layout

\begin_layout Itemize
This is 
\emph on
not
\emph default
 of the form 
\family typewriter
\size small
\color blue
F[A] => G[A]
\family default
\size default
\color inherit
 with covariant 
\family typewriter
\size small
\color blue
F[_]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[_]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Some occurrences of 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 are in covariant positions but other occurrences are in contravariant positions
, all mixed up
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Motivating relational parametricity.
 III.
 Liftings
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The solution involves three nontrivial steps:
\begin_inset Note Note
status open

\begin_layout Enumerate
Introduce profunctors 
\family typewriter
\size small
\color blue
P[-X, +Y]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
Q[-X, +Y]
\family default
\size default
\color inherit
 instead of 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[A]
\family default
\size default
\color inherit
 so that 
\family typewriter
\size small
\color blue
F[A] = P[A, A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
G[A] = Q[A, A]
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Every type parameter is in a covariant or in a contravariant position
\end_layout

\begin_layout Itemize
Rename contravariant positions to 
\family typewriter
\size small
\color blue
X
\family default
\size default
\color inherit
 and contravariant ones to 
\family typewriter
\size small
\color blue
Y
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Enumerate
Replace functions 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 by relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 
\end_layout

\begin_deeper
\begin_layout Itemize
Instead of 
\family typewriter
\size small
\color blue
b == f(a)
\family default
\size default
\color inherit
, we will write: 
\family typewriter
\size small
\color blue
(a, b) in r
\end_layout

\end_deeper
\begin_layout Enumerate
Turns out, we can lift 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 to 
\family typewriter
\size small
\color blue
rmap(r):
\begin_inset space ~
\end_inset

F[A] <=> F[B]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Enumerate
Reformulate the naturality law of 
\family typewriter
\size small
\color blue
t
\family default
\size default
\color inherit
 via relations: for any 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
,
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{F[A]}\ar@{<->}[d]\sb(0.5){~\mathtt{rmap(r)}\text{ for }\mathtt{F}}\ar[r]\sp(0.5){\mathtt{t[A]}} & \mathtt{G[A]}\ar@{<->}[d]\sp(0.5){\mathtt{rmap(r)}\text{ for }\mathtt{G}}\\
\mathtt{F[B]}\ar[r]\sp(0.5){\mathtt{t[B]}} & \mathtt{G[B]}
}
\]

\end_inset

To read the diagram: the starting values are on the left
\begin_inset Newline newline
\end_inset

For any 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
, for any 
\family typewriter
\size small
\color blue
fa:
\begin_inset space ~
\end_inset

F[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
fb:
\begin_inset space ~
\end_inset

F[B]
\family default
\size default
\color inherit
 such that
\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
(fa, fb) in rmap_F(r)
\family default
\size default
\color inherit
, we require 
\family typewriter
\size small
\color blue
(t(fa), t(fb)) in rmap_G(r)
\family default
\size default
\color inherit
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Definition and examples of relations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
In the terminology of relational databases: 
\end_layout

\begin_layout Itemize
A relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 is a table with 2 columns (
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
B
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
Each row 
\family typewriter
\size small
\color blue
(a:
\begin_inset space ~
\end_inset

A, b:
\begin_inset space ~
\end_inset

B)
\family default
\size default
\color inherit
 means that the value 
\family typewriter
\size small
\color blue
a
\family default
\size default
\color inherit
 is related to 
\family typewriter
\size small
\color blue
b
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Mathematically speaking: a relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 is a subset 
\begin_inset Formula $r\subset A\times B$
\end_inset

 
\end_layout

\begin_layout Itemize
We write 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 to mean 
\begin_inset Formula $a\times b\in r$
\end_inset

 where 
\begin_inset Formula $a\in A$
\end_inset

 and 
\begin_inset Formula $b\in B$
\end_inset


\end_layout

\begin_layout Standard
Relations can be many-to-many while functions 
\family typewriter
\size small
\color blue
A => B
\family default
\size default
\color inherit
 are many-to-one
\end_layout

\begin_layout Standard
A function 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 can be also viewed as a relation 
\family typewriter
\size small
\color blue
rel(f):
\begin_inset space ~
\end_inset

A <=> B
\end_layout

\begin_layout Itemize
Two values 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
 are in 
\family typewriter
\size small
\color blue
rel(f)
\family default
\size default
\color inherit
 if 
\family typewriter
\size small
\color blue
b == f(a)
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
rel(identity:
\begin_inset space ~
\end_inset

A => A)
\family default
\size default
\color inherit
 defines an 
\series bold
identity
\series default
 relation 
\family typewriter
\size small
\color blue
id:
\begin_inset space ~
\end_inset

A <=> A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Example of a relation that can be many-to-many:
\end_layout

\begin_layout Standard
Given two functions 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => C
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
, define a 
\begin_inset Quotes eld
\end_inset

pullback
\begin_inset Quotes erd
\end_inset

 relation 
\family typewriter
\size small
\color blue
pullback(f, g):
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 as:
\family typewriter
\size small
\color blue

\begin_inset space ~
\end_inset

(a:
\begin_inset space ~
\end_inset

A, b:
\begin_inset space ~
\end_inset

B) in r 
\family default
\size default
\color inherit
means
\family typewriter
\size small
\color blue
 f(a) == g(b)
\end_layout

\begin_layout Itemize
The pullback relation is 
\emph on
not
\emph default
 equivalent to a function 
\family typewriter
\size small
\color blue
A => B
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
B => A
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 I.
 Relation combinators
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Relation combinators:
\end_layout

\begin_layout Itemize
For any relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
, the 
\series bold
inverse
\series default
 relation is 
\family typewriter
\size small
\color blue
inv(r):
\begin_inset space ~
\end_inset

B <=> A
\end_layout

\begin_deeper
\begin_layout Itemize
The inverse operation is its own inverse: 
\family typewriter
\size small
\color blue
inv(inv(r)) == r
\end_layout

\end_deeper
\begin_layout Itemize
For any relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
, get the union (
\family typewriter
\size small
\color blue
r or s
\family default
\size default
\color inherit
) and the intersection (
\family typewriter
\size small
\color blue
r and s
\family default
\size default
\color inherit
):
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
(a, b) in (r and s) 
\family default
\size default
\color inherit
means
\family typewriter
\size small
\color blue
 (a, b) in r
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(a, b) in s
\end_layout

\begin_layout LyX-Code

\family typewriter
\size small
\color blue
(a, b) in (r or s) 
\family default
\size default
\color inherit
means
\family typewriter
\size small
\color blue
 (a, b) in r
\family default
\size default
\color inherit
 or 
\family typewriter
\size small
\color blue
(a, b) in s
\end_layout

\begin_layout Itemize
For any relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s:
\begin_inset space ~
\end_inset

B <=> C
\family default
\size default
\color inherit
 define the 
\series bold
composition
\series default
 (
\family typewriter
\size small
\color blue
r compose s
\family default
\size default
\color inherit
) as a relation 
\family typewriter
\size small
\color blue
u:
\begin_inset space ~
\end_inset

A <=> C
\family default
\size default
\color inherit
 by 
\family typewriter
\size small
\color blue
(a:
\begin_inset space ~
\end_inset

A, c:
\begin_inset space ~
\end_inset

C) in u
\family default
\size default
\color inherit
 when there exists 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
 such that 
\family typewriter
\size small
\color blue
(a, b) in r 
\family default
\size default
\color inherit
and 
\family typewriter
\size small
\color blue
(b, c) in s
\end_layout

\begin_deeper
\begin_layout Itemize
Composition corresponds to 
\begin_inset Quotes eld
\end_inset

join
\begin_inset Quotes erd
\end_inset

 in relational databases
\end_layout

\begin_layout Itemize
Directionality law: 
\family typewriter
\size small
\color blue
inv(r compose s) == inv(s) compose inv(r)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Associativity and identity laws with respect to 
\family typewriter
\size small
\color blue
id:
\begin_inset space ~
\end_inset

A <=> A
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Itemize
Preserves composition of functions: for 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
,
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
rel(f andThen g) == rel(f) compose rel(g)
\end_layout

\end_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

pullback relation
\begin_inset Quotes erd
\end_inset

 can be expressed through composition:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\family typewriter
\size small
\color blue
pullback(f, g) == rel(f) compose inv(rel(g)) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Pullback relation expressed through composition of relations
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For any 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => C
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
g:
\begin_inset space ~
\end_inset

B => C
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
, to prove:
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
(a, b) in pullback(f, g)
\family default
\size default
\color inherit
 is equivalent to:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
(a, b) in rel(f) compose inv(rel(g))
\family default
\size default
\color inherit

\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{A}\ar@{<->}[r]\sp(0.5){\mathtt{rel(f)}} & \mathtt{C}\ar@{<->}[r]\sp(0.5){\mathtt{inv(rel(g))}} & \mathtt{B}}
\]

\end_inset


\end_layout

\begin_layout Itemize
The first condition is equivalent to: 
\family typewriter
\size small
\color blue
f(a) == g(b)
\end_layout

\begin_layout Itemize
The second condition is equivalent to: there exists 
\family typewriter
\size small
\color blue
c:
\begin_inset space ~
\end_inset

C
\family default
\size default
\color inherit
 such that:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
(a, c) in rel(f)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(c, b) in inv(rel(g))
\end_layout

\begin_layout Itemize
This is equivalent to: 
\family typewriter
\size small
\color blue
c
\family default
\size default
\color inherit
 is such that 
\family typewriter
\size small
\color blue
c == f(a)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
c == g(b)
\end_layout

\begin_layout Itemize
This is equivalent to the first condition
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 II.
 Definition of 
\family typewriter
rmap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
For a type constructor 
\family typewriter
\size small
\color blue
F
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
, need 
\family typewriter
\size small
\color blue
rmap(r):
\begin_inset space ~
\end_inset

F[A] <=> F[B]
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 for 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 by induction over the 
\emph on
type expression
\emph default
 of 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
There are seven possibilities (assuming that the code is fully parametric):
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = Unit
\family default
\size default
\color inherit
 or another fixed type (say, 
\family typewriter
\size small
\color blue
T
\family default
\size default
\color inherit
) not related to 
\family typewriter
\size small
\color blue
A
\end_layout

\begin_layout Enumerate
The identity functor: 
\family typewriter
\size small
\color blue
F[A] = A
\end_layout

\begin_layout Enumerate
Product type: 
\family typewriter
\size small
\color blue
F[A] = (G[A], H[A])
\end_layout

\begin_layout Enumerate
Co-product type: 
\family typewriter
\size small
\color blue
F[A] = Either[G[A], H[A]]
\end_layout

\begin_layout Enumerate
Function type: 
\family typewriter
\size small
\color blue
F[A] = G[A] => H[A]
\end_layout

\begin_layout Enumerate
Recursive type: 
\family typewriter
\size small
\color blue
F[A] = G[A, F[A]]
\end_layout

\begin_layout Enumerate
Universally quantified term: 
\family typewriter
\size small
\color blue
F[A] = [Z] => G[A, Z]
\end_layout

\begin_layout Standard
Define 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 similarly to how a functor's 
\family typewriter
\size small
\color blue
fmap
\family default
\size default
\color inherit
 is defined in these cases
\end_layout

\begin_layout Itemize
The inductive assumption is that liftings to 
\family typewriter
\size small
\color blue
G
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
H
\family default
\size default
\color inherit
 are already defined
\end_layout

\begin_layout Itemize
For 
\family typewriter
\size small
\color blue
G[A, Z]
\family default
\size default
\color inherit
, need to use two liftings (
\family typewriter
\size small
\color blue
rmap_G1
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
rmap_G2
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
Liftings with respect to different type parameters will commute!
\end_layout

\begin_layout Itemize
For 
\family typewriter
\size small
\color blue
F[A] = G[H[A]]
\family default
\size default
\color inherit
 we expect 
\family typewriter
\size small
\color blue
rmap_F(r) == rmap_G(rmap_H(r))
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Some diagrams for clarification
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The commutativity theorem for relational liftings: For any type constructor
 
\family typewriter
\size small
\color blue
G[A, X]
\family default
\size default
\color inherit
 and any two relations 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s:
\begin_inset space ~
\end_inset

X <=> Y
\family default
\size default
\color inherit
:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.8pc}\xyScaleX{5.5pc}\mathtt{G[A,~X]}\ar@{<->}[rd]\ar@{<->}[d]\sb(0.5){~\mathtt{rmap\_G1(r)}}\ar@{<->}[r]\sp(0.5){\mathtt{rmap\_G2(s)}} & \mathtt{G[A,~Y]}\ar@{<->}[d]\sp(0.5){\mathtt{rmap\_G1(r)}}\\
\mathtt{G[B,~X]}\ar@{<->}[r]\sp(0.5){\mathtt{rmap\_G2(s)}} & \mathtt{G[B,~Y]}
}
\]

\end_inset


\end_layout

\begin_layout Standard
Relational lifting for a composition of type constructors, 
\family typewriter
\size small
\color blue
F[A] = G[H[A]]
\family default
\size default
\color inherit
:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{8.0pc}\mathtt{H[A]}\ar@{<->}[r]\sp(0.5){~\mathtt{rmap\_H(r)}} & \mathtt{H[B]}\\
\mathtt{G[H[A]]}\ar@{<->}[r]\sp(0.53){\mathtt{rmap\_G(rmap\_H(r))}} & \mathtt{G[H[B]]}
}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 II.
 Definition of 
\family typewriter
rmap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Need to define 
\family typewriter
\size small
\color blue
rmap(r):
\begin_inset space ~
\end_inset

F[A] <=> F[B]
\family default
\size default
\color inherit
 in these 7 cases:
\end_layout

\begin_layout Enumerate

\family typewriter
\size small
\color blue
F[A] = T
\family default
\size default
\color inherit
 (a fixed type): define 
\family typewriter
\size small
\color blue
rmap(r) = id: T <=> T
\end_layout

\begin_layout Enumerate
The identity functor, 
\family typewriter
\size small
\color blue
F[A] = A
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
rmap(r) = r: A <=> B
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
F[A] = (G[A], H[A])
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
((g1,h1), (g2,h2)) in rmap(r)
\family default
\size default
\color inherit
 to mean 
\family typewriter
\size small
\color blue
(g1, g2) in rmap_G(r)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(h1, h2) in rmap_H(r)
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
F[A] = Either[G[A], H[A]]
\family default
\size default
\color inherit
: either 
\family typewriter
\size small
\color blue
(Left(g1), Left(g2)) in rmap(r)
\family default
\size default
\color inherit
 when 
\family typewriter
\size small
\color blue
(g1, g2) in rmap_G(r)
\family default
\size default
\color inherit
 or
\size small
\color blue
 
\family typewriter
(Right(h1), Right(h2)) in rmap(r)
\family default
\size default
\color inherit
 when 
\family typewriter
\size small
\color blue
(h1, h2) in rmap_H(r)
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
F[A] = G[A] => H[A]
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
(f1, f2) in rmap(r)
\family default
\size default
\color inherit
 to mean 
\family typewriter
\size small
\color blue
(f1(g1), f2(g2)) in rmap_H(r)
\family default
\size default
\color inherit
 for any 
\family typewriter
\size small
\color blue
g1:
\begin_inset space ~
\end_inset

G[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
g2:
\begin_inset space ~
\end_inset

G[B]
\family default
\size default
\color inherit
 such that 
\family typewriter
\size small
\color blue
(g1, g2) in rmap_G(r)
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
F[A] = G[A, F[A]]
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
rmap(r) = rmap_G1(r) compose rmap_G2(rmap(r))
\family default
\size default
\color inherit
 – the second 
\family typewriter
\size small
\color blue
rmap(r)
\family default
\size default
\color inherit
 is a recursive call
\end_layout

\begin_layout Enumerate
When 
\family typewriter
\size small
\color blue
F[A] = [Z] => G[A, Z]
\family default
\size default
\color inherit
: define 
\family typewriter
\size small
\color blue
(f1, f2) in rmap(r)
\family default
\size default
\color inherit
 to mean: for any types 
\family typewriter
\size small
\color blue
Z1
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
Z2
\family default
\size default
\color inherit
, and for any relation 
\family typewriter
\size small
\color blue
s:
\begin_inset space ~
\end_inset

Z1 <=> Z2
\family default
\size default
\color inherit
, we require 
\family typewriter
\size small
\color blue
(f1[A][Z1], f2[B][Z2]) in (rmap_G1(r) compose rmap_G2(s))
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 III.
 Examples of using 
\family typewriter
rmap
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Use 
\family typewriter
\size small
\color blue
rmap
\family default
\size default
\color inherit
 to lift a relation 
\family typewriter
\size small
\color blue
r
\family default
\size default
\color inherit
 to a type constructor
\end_layout

\begin_layout Standard
Two main examples of relations generated by functions:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
rel(f)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
pullback(f, g)
\family default
\size default
\color inherit
 
\end_layout

\begin_layout Standard
Three main examples of type constructors (
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
G[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
H[A]
\family default
\size default
\color inherit
):
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
F[A]
\family default
\size default
\color inherit
 is covariant then:
\begin_inset Newline newline
\end_inset


\family typewriter
\size small
\color blue
rmap(rel(f)) == rel(fmap(f))
\begin_inset Newline newline
\end_inset

rmap(pullback(f, g)) == pullback(fmap(f), fmap(g))
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
G[A] = A => A
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa, fb) in rmap(rel(f))
\family default
\size default
\color inherit
 means:
\begin_inset Newline newline
\end_inset

when 
\family typewriter
\size small
\color blue
(a, b) in rel(f)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa(a), fb(b)) in rel(f)
\family default
\size default
\color inherit

\begin_inset Newline newline
\end_inset

or: 
\family typewriter
\size small
\color blue
f(fa(a)) == fb(f(a))
\family default
\size default
\color inherit
 or: 
\family typewriter
\size small
\color blue
fa andThen f == f andThen fb
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
This relation has the form of a pullback
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
H[A] = (A => A) => A
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa, fb) in rmap_H(rel(f))
\family default
\size default
\color inherit
 means:
\begin_inset Newline newline
\end_inset

when 
\family typewriter
\size small
\color blue
(p, q) in rmap_G(rel(f))
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(fa(p), fb(q)) in rel(f)
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
equivalently: if 
\family typewriter
\size small
\color blue
p andThen f == f andThen q
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
f(fa(p))==fb(q)
\begin_inset Newline newline
\end_inset


\family default
\size default
\color inherit
This is 
\emph on
not
\emph default
 a pullback relation: cannot express 
\family typewriter
\size small
\color blue
p
\family default
\size default
\color inherit
 through 
\family typewriter
\size small
\color blue
q
\end_layout

\begin_layout Standard
It is hard to use relations that do not have the form of a pullback
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 IV.
 Formulation
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Instead of proving relational properties for 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

P[A] => Q[A]
\family default
\size default
\color inherit
, use the function type and the quantified type constructions and get:
\end_layout

\begin_layout Itemize
Any fully parametric 
\family typewriter
\size small
\color blue
t[A]:
\begin_inset space ~
\end_inset

P[A]
\family default
\size default
\color inherit
 satisfies for any 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 the relation 
\family typewriter
\size small
\color blue
(t[A], t[B]) in rmap_P(r)
\end_layout

\begin_layout Itemize
Any fully parametric 
\family typewriter
\size small
\color blue
t:
\begin_inset space ~
\end_inset

P[]
\family default
\size default
\color inherit
 satisfies 
\family typewriter
\size small
\color blue
(t, t) in rmap_P(id)
\end_layout

\begin_layout Standard
It is more convenient to prove a parametricity theorem with a free variable:
\end_layout

\begin_layout Itemize
Any fully parametric expression 
\family typewriter
\size small
\color blue
t[A](z):
\begin_inset space ~
\end_inset

P[A]
\family default
\size default
\color inherit
 with 
\family typewriter
\size small
\color blue
z:
\begin_inset space ~
\end_inset

Q[A]
\family default
\size default
\color inherit
 satisfies, for any relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B
\family default
\size default
\color inherit
 and for any 
\family typewriter
\size small
\color blue
z1:
\begin_inset space ~
\end_inset

Q[A]
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
z2:
\begin_inset space ~
\end_inset

Q[B]
\family default
\size default
\color inherit
, the law:
\begin_inset Newline newline
\end_inset

if 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_Q(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t[A](z1), t[B](z2)) in rmap_P(r)
\end_layout

\begin_layout Standard
This applies to expressions containing one free variable (
\family typewriter
\size small
\color blue
z
\family default
\size default
\color inherit
)
\end_layout

\begin_layout Itemize
Any number of free variables can be grouped into a tuple
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
From relational parametricity to naturality laws
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Example: 
\family typewriter
\size small
\color blue
t[A] = { a:
\begin_inset space ~
\end_inset

A => a }
\family default
\size default
\color inherit
 of type 
\family typewriter
\size small
\color blue
P[A] = A => A
\end_layout

\begin_layout Standard
Parametricity theorem says:
\end_layout

\begin_layout Itemize
For any types 
\family typewriter
\size small
\color blue
A
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
B,
\family default
\size default
\color inherit
 and for any relation 
\family typewriter
\size small
\color blue
r:
\begin_inset space ~
\end_inset

A <=> B,
\family default
\size default
\color inherit
 we have:
\end_layout

\begin_layout Standard

\family typewriter
\size small
\color blue
(t[A], t[B]) in rmap_P(r)
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
rmap_P(r):
\begin_inset space ~
\end_inset

(A => A) <=> (B => B)
\end_layout

\begin_layout Itemize

\family typewriter
\size small
\color blue
(p, q) in rmap_P(r)
\family default
\size default
\color inherit
 means: for any 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
, if 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
p(a), q(b) in r
\end_layout

\begin_layout Itemize
So, 
\family typewriter
\size small
\color blue
(t[A], t[B]) in rmap_P(r)
\family default
\size default
\color inherit
 means: for any 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
, if 
\family typewriter
\size small
\color blue
(a, b) in r
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t(a), t(b)) in r
\end_layout

\begin_layout Standard
Trick: choose 
\family typewriter
\size small
\color blue
r = rel(f)
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
f:
\begin_inset space ~
\end_inset

A => B
\family default
\size default
\color inherit
 is an arbitrary function
\end_layout

\begin_layout Itemize
We get: for any 
\family typewriter
\size small
\color blue
a:
\begin_inset space ~
\end_inset

A
\family default
\size default
\color inherit
, 
\family typewriter
\size small
\color blue
b:
\begin_inset space ~
\end_inset

B
\family default
\size default
\color inherit
, if 
\family typewriter
\size small
\color blue
f(a) == b
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
f(t(a)) == t(b)
\end_layout

\begin_layout Itemize
Equivalently: 
\family typewriter
\size small
\color blue
f(t(a)) == t(f(a))
\family default
\size default
\color inherit
, i.e., 
\family typewriter
\size small
\color blue
t
\family default
\size default
\color inherit
 commutes with all functions
\end_layout

\begin_layout Itemize
One can then prove that 
\family typewriter
\size small
\color blue
t
\family default
\size default
\color inherit
 must be an identity function
\end_layout

\begin_deeper
\begin_layout Itemize
Choose 
\family typewriter
\size small
\color blue
f = { _:
\begin_inset space ~
\end_inset

A => b }
\family default
\size default
\color inherit
 with a fixed constant 
\family typewriter
\size small
\color blue
b: B
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 V.
 Outline
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The theorem says that 
\family typewriter
\size small
\color blue
t[A](z)
\family default
\size default
\color inherit
 satisfies its relational parametricity law
\end_layout

\begin_layout Standard
Proof goes by induction on the structure of the code of 
\family typewriter
\size small
\color blue
t[A](z)
\end_layout

\begin_layout Standard
At the top level, 
\family typewriter
\size small
\color blue
t[A](z)
\family default
\size default
\color inherit
 must have one of the 9 code constructions
\end_layout

\begin_layout Standard
Each construction decomposes the code of 
\family typewriter
\size small
\color blue
t[A](z)
\family default
\size default
\color inherit
into sub-expressions
\end_layout

\begin_layout Standard
The inductive assumption is that the theorem holds for all sub-expressions
 (including the bound variable 
\family typewriter
\size small
\color blue
z
\family default
\size default
\color inherit
)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Proof of relational parametricity.
 VI.
 Examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
We will show how to prove the first 4 constructions
\end_layout

\begin_layout Standard
Constant type: If 
\family typewriter
\size small
\color blue
t[A](z) = c
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
c
\family default
\size default
\color inherit
 is a fixed value of a fixed type 
\family typewriter
\size small
\color blue
C
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
We have 
\family typewriter
\size small
\color blue
rmap_P(r) == id
\family default
\size default
\color inherit
 while 
\family typewriter
\size small
\color blue
(c, c) in id
\family default
\size default
\color inherit
 holds
\end_layout

\begin_layout Standard
Use argument: If 
\family typewriter
\size small
\color blue
t[A](z) = z
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
z
\family default
\size default
\color inherit
 is a value of type 
\family typewriter
\size small
\color blue
Q[A]
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_Q(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(t(z1), t(z2)) in rmap_Q(r)
\end_layout

\begin_layout Standard
Create function: If 
\family typewriter
\size small
\color blue
t(z) = h => s(z, h)
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
h:
\begin_inset space ~
\end_inset

H[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
s(z, h):
\begin_inset space ~
\end_inset

S[A]
\family default
\size default
\color inherit
:
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_Q(r)
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
(h1, h2) in rmap_H(r)
\family default
\size default
\color inherit
 then 
\family typewriter
\size small
\color blue
(s(z1, h1), s(z2, h2)) in rmap_S(r)
\end_layout

\begin_layout Standard
Use function: If 
\family typewriter
\size small
\color blue
t(z) = g(z)(h(z))
\family default
\size default
\color inherit
 where 
\family typewriter
\size small
\color blue
g(z):
\begin_inset space ~
\end_inset

H[A] => P[A]
\family default
\size default
\color inherit
 and 
\family typewriter
\size small
\color blue
h(z):
\begin_inset space ~
\end_inset

H[A]
\family default
\size default
\color inherit
 are sub-expressions:
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(z1, z2) in rmap_Q(r)
\family default
\size default
\color inherit
 then inductive assumption says:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
(h(z1), h(z2)) in rmap_H(r)
\end_layout

\begin_layout Itemize
If 
\family typewriter
\size small
\color blue
(h1, h2) in rmap_H(r)
\family default
\size default
\color inherit
 then inductive assumption says:
\begin_inset Newline newline
\end_inset

 
\family typewriter
\size small
\color blue
(g(h1), g(h2)) in rmap_P(r)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Summary
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Relational parametricity is a powerful technique
\end_layout

\begin_layout Itemize
It has been generalized to many different settings
\end_layout

\begin_deeper
\begin_layout Itemize
Gradual typing, higher-kinded types, dependent types, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Relational parametricity has a steep learning curve
\end_layout

\begin_deeper
\begin_layout Itemize
Cannot directly write code that manipulates relations
\end_layout

\begin_layout Itemize
All calculations need to be done symbolically or with proof assistants
\end_layout

\end_deeper
\begin_layout Itemize
The result may be a relation that is difficult to interpret as code
\end_layout

\begin_layout Itemize
A couple of results in FP do require the relational naturality law
\end_layout

\begin_layout Itemize
More details in the free book — 
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/winitzki/sofp"

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "27col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename book-draft-cover.png
	lyxscale 20
	width 2.5cm

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
End of slides.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
