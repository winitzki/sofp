#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
\usepackage{titlesec}
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}

%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

\end_preamble
\options numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.681in
\leftmargin 2cm
\topmargin 0.95cm
\rightmargin 1.2cm
\bottommargin 1.5cm
\headsep 0.4cm
\footskip 1.1cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Int,Char,Boolean,Double,Float,Long,Seq,Map,List,Option,Either,Future,Vector,IndexedSeq,Try,true,false,None,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip=2mm,belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The logic of types.
 II.
 Higher-order functions
\begin_inset CommandInset label
LatexCommand label
name "chap:Higher-order-functions"

\end_inset

 
\end_layout

\begin_layout Section
Functions that return functions
\end_layout

\begin_layout Subsection
Motivation and a first example
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset

Consider the task of preparing a logger function that prints messages but
 adds a fixed prefix to each message.
 
\end_layout

\begin_layout Standard
A simple logger function can be a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

, such as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val logger: String => Unit = { message => println(s
\begin_inset Quotes erd
\end_inset

INFO: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> logger("hello world")
\end_layout

\begin_layout Plain Layout

INFO: hello world
\end_layout

\end_inset

This function prints any given message with the logging prefix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The standard library function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

println(...)
\end_layout

\end_inset

 always returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value after printing its arguments.
 As we already know, there is only a single value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, and that value is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 To verify, run this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x = println(123)
\end_layout

\begin_layout Plain Layout

123
\end_layout

\begin_layout Plain Layout

x: Unit = ()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The task is to make the logging prefix configurable.
 A simple solution is to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 that takes a prefix as an argument and returns a new logger with that prefix
 fixed.
 It is important that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 will return a new value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

, i.e.
\begin_inset space ~
\end_inset

a new 
\emph on
function
\emph default
:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logWith(prefix: String): (String => Unit) = {
\end_layout

\begin_layout Plain Layout

    message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 consists of a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

message => println(...)
\end_layout

\end_inset

, which is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

.
 This value will be computed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We can now use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 to create a few logger functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val info = logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

info: String => Unit = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val warn = logWith(
\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

warn: String => Unit = <function1>
\end_layout

\end_inset

The created logger functions are then used as ordinary functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

INFO: hello
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> warn(
\begin_inset Quotes eld
\end_inset

goodbye
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

WARN: goodbye
\end_layout

\end_inset

The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 can be used by any code that needs a logging function.
\end_layout

\begin_layout Standard
It is important that the prefix is 
\begin_inset Quotes eld
\end_inset

baked into
\begin_inset Quotes erd
\end_inset

 functions created by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

.
 A logger such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 will always print messages with the prefix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, and the prefix cannot be changed any more.
 This is so because the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prefix
\end_layout

\end_inset

 is treated as a local value in the scope of the function returned by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

.
 For instance, the body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 is equivalent to
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ val prefix = 
\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset

; (message => s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\end_inset

So, whenever a new function is created using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(prefix)
\end_layout

\end_inset

, the (immutable) value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prefix
\end_layout

\end_inset

 is stored within the body of the newly created function.
 This is a general feature of nameless functions created in a scope that
 contains other local values: the function body keeps a copy of all the
 local values it uses.
 One sometimes says that the function body 
\begin_inset Quotes eld
\end_inset

closes over
\begin_inset Quotes erd
\end_inset

 the local values; for this reason, nameless functions are sometimes also
 called 
\begin_inset Quotes eld
\end_inset


\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
closure
\end_layout

\end_inset

closure
\series default
s
\begin_inset Quotes erd
\end_inset

.
 It would be perhaps clearer to say that nameless functions 
\begin_inset Quotes eld
\end_inset

capture
\begin_inset Quotes erd
\end_inset

 local values.
\end_layout

\begin_layout Standard
As another example of the capture of local values, consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Int => Int = {
\end_layout

\begin_layout Plain Layout

  val p = 10
\end_layout

\begin_layout Plain Layout

  val q = 20
\end_layout

\begin_layout Plain Layout

  x => p + q * x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{x => 10 + 20 * x}
\end_layout

\end_inset

 because the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p = 10
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q = 20
\end_layout

\end_inset

 were captured.
\end_layout

\begin_layout Subsection
Curried and uncurried functions
\end_layout

\begin_layout Standard
Reasoning mathematically about the code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val info = logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

we would expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 is 
\emph on
the same value
\emph default
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

, and so the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 should have the same effect as the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith("INFO")("hello")
\end_layout

\end_inset

.
 This is indeed so:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> logWith("INFO")("hello")
\end_layout

\begin_layout Plain Layout

INFO: hello
\end_layout

\end_inset

The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith("INFO")("hello")
\end_layout

\end_inset

 looks like the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 applied to 
\emph on
two
\emph default
 arguments.
 Yet, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 was defined as a function with a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 This is not a contradiction because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 returns a function that accepts an additional argument.
 So, both function applications 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 are valid.
 In this sense, we are allowed to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 to one argument at a time.
\end_layout

\begin_layout Standard
A function that can be applied to more than one argument in this way is
 called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
curried function
\end_layout

\end_inset


\series bold
curried
\series default
 function.
 A curried function can be applied to one argument at a time.
\end_layout

\begin_layout Standard
An 
\series bold
uncurried
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurried function
\end_layout

\end_inset

 function must be applied to all arguments at once, e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prefixLog(prefix: String, message: String): Unit =
\end_layout

\begin_layout Plain Layout

  println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

and returns a value of a non-function type.
\end_layout

\begin_layout Standard
The type of the curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => (String => Unit)
\end_layout

\end_inset

.
 Scala adopts the syntax convention that the function arrow (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

) groups to the 
\emph on
right
\emph default
.
 So the parentheses in the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => (String => Unit)
\end_layout

\end_inset

 are not necessary; the function's type can be written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String => Unit
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String => Unit
\end_layout

\end_inset

 is different from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String => String) => Unit
\end_layout

\end_inset

, – the type of a function returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 and taking a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String
\end_layout

\end_inset

 as its argument.
 When an argument's type is a function type, e.g.
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String
\end_layout

\end_inset

, it must be enclosed in parentheses.
\end_layout

\begin_layout Standard
In general, a curried function takes an argument and returns another function
 that again takes an argument and returns another function, and so on, until
 finally a non-function type is returned.
 So, the type signature of a curried function generally looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => ...
 => R => S
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R
\end_layout

\end_inset

 are the 
\series bold
curried arguments
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
curried arguments
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 result type.
\end_layout

\begin_layout Standard
For most people, it takes time to get used to reading this kind of syntax.
 In the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => D
\end_layout

\end_inset

, the first three types are curried arguments and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 is the final result type.
\end_layout

\begin_layout Standard
In Scala, functions defined with multiple argument groups (enclosed in multiple
 pairs of parentheses) are curried functions.
 We have seen examples of curried functions before:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
\end_layout

\begin_layout Plain Layout

def fmap[A, B](f: A => B)(xs: Option[A]): Option[B]
\end_layout

\begin_layout Plain Layout

def foldLeft[A, R](xs: Seq[A])(init: R)(update: (R, A) => R): R
\end_layout

\end_inset

The type signatures of these functions can be also written equivalently
 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: Seq[A] => (A => B) => Seq[B]
\end_layout

\begin_layout Plain Layout

def fmap[A, B]: (A => B) => Option[A] => Option[B]
\end_layout

\begin_layout Plain Layout

def foldLeft[A, R]: Seq[A] => R => ((R, A) => R) => R
\end_layout

\end_inset

Curried arguments of a function type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B)
\end_layout

\end_inset

, need parentheses.
\end_layout

\begin_layout Standard
The curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 can be defined in three equivalent ways in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logWith1(prefix: String)(message: String): Unit =
\end_layout

\begin_layout Plain Layout

  println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

def logWith2(prefix: String): String => Unit =
\end_layout

\begin_layout Plain Layout

  message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

def logWith3: String => String => Unit =
\end_layout

\begin_layout Plain Layout

  prefix => message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

Nameless functions in Scala may be enclosed in parentheses or curly braces.
 We will omit parentheses for simple expressions.
\end_layout

\begin_layout Standard
The last line in the above code shows that the arrow 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 groups to the right within the 
\emph on
code
\emph default
 of nameless functions: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => expr
\end_layout

\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{x => {y => expr}}
\end_layout

\end_inset

, a nameless function taking an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returning a nameless function that takes an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 and returns an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

.
 This syntax convention is useful for two reasons.
 First, the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z
\end_layout

\end_inset

 visually corresponds to the curried function's type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C
\end_layout

\end_inset

, which uses the same syntax convention.
 Second, the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y) => z
\end_layout

\end_inset

 could not be valid for a nameless function because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y)
\end_layout

\end_inset

 is not a valid pattern expression for the function's argument; it is impossible
 to define a pattern that matches arbitrary 
\emph on
functions
\emph default
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Although the code syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y) => z
\end_layout

\end_inset

 is invalid, a type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B) => C
\end_layout

\end_inset

 is valid.
 A nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B) => C
\end_layout

\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f => expr(f)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 is its argument and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(f)
\end_layout

\end_inset

 its body.
 So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => (y => z)
\end_layout

\end_inset

 is the only possible way of inserting parentheses into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Equivalence of curried and uncurried functions
\end_layout

\begin_layout Standard
We defined the curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 in order to be able to create logger functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

.
 However, some curried functions, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, are almost always applied to all possible arguments.
 A curried function applied to all its possible arguments is equivalent
 to an uncurried function that takes all those arguments at once.
 Let us look at this equivalence in more detail.
\end_layout

\begin_layout Standard
Consider a curried function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

.
 This function takes an integer and returns an (uncurried) function taking
 an integer and returning an integer.
 An example of such a curried function is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1(x: Int): Int => Int = { y => x - y }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function takes an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returns the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => x - y
\end_layout

\end_inset

, which is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 can be written equivalently as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f1: Int => Int => Int = { x => y => x - y }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us compare the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 with a function that takes its two arguments at once.
 Such a function will have a different type signature, e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2(x: Int, y: Int): Int = x - y
\end_layout

\end_inset

has type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset

 but computes the same value as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for using the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is different:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f1(20)(4)
\end_layout

\begin_layout Plain Layout

res0: Int = 16
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f2(20, 4)
\end_layout

\begin_layout Plain Layout

res1: Int = 16
\end_layout

\end_inset

The main difference between the usage of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 must be applied 
\emph on
at once
\emph default
 to both arguments, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 applied to just the first argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

.
 The result of evaluating 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(20)
\end_layout

\end_inset

 is a function that can be later applied to another argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r1 = f1(20)
\end_layout

\begin_layout Plain Layout

r1: Int => Int = <function1> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r1(4)
\end_layout

\begin_layout Plain Layout

res2: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applying a curried function to some but not all of possible arguments is
 called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

partial application
\series default
.
 Applying a curried function to all possible arguments is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
saturated application
\end_layout

\end_inset


\series bold
saturated
\series default
 application.
\end_layout

\begin_layout Standard
If we need to apply an 
\emph on
uncurried
\emph default
 function to some of its arguments but leave other arguments unspecified,
 we can use the underscore (
\begin_inset Formula $\_$
\end_inset

) symbol:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r2: Int => Int = f2(20, _)
\end_layout

\begin_layout Plain Layout

r2: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r2(4)
\end_layout

\begin_layout Plain Layout

res3: Int = 16
\end_layout

\end_inset

(Here, the type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 is required.) This code creates a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 by partially applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to the first argument but not to the second.
 Other than that, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 is the same function as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

 defined above; i.e.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 returns the same values for the same arguments as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

.
 A more general syntax for a partial application is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r3: Int => Int = { x => f2(20, x) }
\end_layout

\begin_layout Plain Layout

r3: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r3(4)
\end_layout

\begin_layout Plain Layout

res4: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see that a curried function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, is better adapted for partial application than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, because the syntax is shorter.
 However, the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are 
\series bold
computationally equivalent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
computational equivalence
\end_layout

\end_inset

 in the sense that given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 we can reconstruct 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 and vice versa:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2new(x: Int, y: Int): Int = f1(x)(y)
\end_layout

\begin_layout Plain Layout

def f1new: Int => Int => Int = { x => y => f2(x, y) }
\end_layout

\end_inset

It is clear that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1new
\end_layout

\end_inset

 computes the same results as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, and that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2new
\end_layout

\end_inset

 computes the same results as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 The computational equivalence of the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is not 
\emph on
equality
\emph default
  –  these functions are 
\emph on
different
\emph default
; but one of them can be easily reconstructed from the other if necessary.
 
\end_layout

\begin_layout Standard
More generally, a curried function has a type signature of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => ...
 => R => S
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 are some types.
 A function with this type signature is computationally equivalent to an
 uncurried
\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurried function
\end_layout

\end_inset

 function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B,C,...,R) => S
\end_layout

\end_inset

.
 The uncurried function takes all arguments at once, while the curried function
 takes one argument at a time.
 Other than that, these two functions compute the same results given the
 same arguments.
\end_layout

\begin_layout Standard
We have seen how a curried function can be converted to an equivalent uncurried
 one, and vice versa.
 The Scala library defines the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 that convert between these computationally equivalent forms of functions.
 Here we convert the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and back:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val f1c = (f2 _).curried
\end_layout

\begin_layout Plain Layout

f1c: Int => (Int => Int) = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val f2u = Function.uncurried(f1c)
\end_layout

\begin_layout Plain Layout

f2u: (Int, Int) => Int = <function2> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f2 _)
\end_layout

\end_inset

 is needed in Scala
\begin_inset Foot
status open

\begin_layout Plain Layout
The extra underscore will become unnecessary in Scala 3.
\end_layout

\end_inset

 to convert methods to function values.
 Recall that Scala has two ways of defining a function: one as a method
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala method
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

), another as a function value
\begin_inset Index idx
status open

\begin_layout Plain Layout
function value
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.uncurried
\end_layout

\end_inset

 are easy to implement in Scala code, as we will show in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-fully-parametric"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Fully parametric functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Fully-parametric-functions"

\end_inset


\end_layout

\begin_layout Standard
We have seen that some functions are declared with type parameters, which
 are set only when the function is applied to specific arguments.
 Examples of such functions are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 methods with type signatures
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
\end_layout

\begin_layout Plain Layout

def filter[A](xs: Seq[A])(p: A => Boolean): Seq[A]
\end_layout

\end_inset

Such functions can be applied to arguments of different types without changing
 the function's code.
 So, it is better to implement a single function with type parameters instead
 of several functions with the same code but applied to different types.
 When we apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(xs)(f)
\end_layout

\end_inset

 to a specific value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 of type, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Int]
\end_layout

\end_inset

, and a specific function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => String
\end_layout

\end_inset

, the Scala compiler will automatically set the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B = String
\end_layout

\end_inset

 in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 We may also set type parameters explicitly and write, for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map[Int, String](xs)(f)
\end_layout

\end_inset

.
 This syntax shows a certain similarity between type parameters such as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 and 
\begin_inset Quotes eld
\end_inset

value parameters
\begin_inset Quotes erd
\end_inset

 (arguments) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 Setting type parameters (e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map[Int, String]
\end_layout

\end_inset

) means setting type parameters equal to specific types (e.g.
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A=Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B=String
\end_layout

\end_inset

) in the type signature of the function, similarly to how setting value
 parameters means substituting specific values into the body of the function.
\end_layout

\begin_layout Standard
In the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 as just shown, some types are parameters while others are specific types,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

.
 It is sometimes possible to replace 
\emph on
all
\emph default
 types in the type signature of a function by type parameters.
\end_layout

\begin_layout Standard
A function is 
\series bold
fully parametric
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric function
\end_layout

\end_inset


\series default
 if its arguments have types described by type parameters, and the code
 of the function treats all types as type parameters.
 In other words, fully parametric functions do not use any values of specific
 types, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, in their type signature or in their body.
 A fully parametric function does not use any information about its argument
 types, other than assuming that values of the correct types were given
 as arguments.
\end_layout

\begin_layout Standard
What kind of functions are fully parametric? To build an intuition for that,
 let us compare these two functions having the same type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cos_sin(p: (Double, Double)): (Double, Double) = p match {
\end_layout

\begin_layout Plain Layout

  case (x, y) =>
\end_layout

\begin_layout Plain Layout

    val r = math.sqrt(x * x + y * y)
\end_layout

\begin_layout Plain Layout

    (x / r, y / r) // Return cos and sin of the angle.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def swap(p: (Double, Double)): (Double, Double) = p match {
\end_layout

\begin_layout Plain Layout

  case (x, y) => (y, x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can introduce type parameters into the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 to make it fully parametric, with no changes in the code of the function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap[A, B](p: (A, B)): (B, A) = p match {
\end_layout

\begin_layout Plain Layout

  case (x, y) => (y, x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Generalizing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 to a fully parametric function is possible because the operation of swapping
 two parts of a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 works in the same way for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The specialized version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 working on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset

 can be obtained from the fully parametric version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 if we set the type parameters as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A=Double
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B=Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In contrast, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 performs a computation that is specific to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 and cannot be generalized to an arbitrary type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 cannot be generalized to a fully parametric function.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 operation for pairs is already defined in the Scala library:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1, 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

).swap
\end_layout

\begin_layout Plain Layout

res0: (String, Int) = (abc,1)
\end_layout

\end_inset

Other swapping functions can be defined for tuples with more elements, e.g.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap12[A,B,C]: ((A, B, C)) => (B, A, C) = {
\end_layout

\begin_layout Plain Layout

  case (x, y, z) => (y, x, z)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The Scala syntax requires the double parentheses around tuple types
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuple types!as function arguments
\end_layout

\end_inset

 of arguments but not around the tuple type of a function's result.
 So, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 may be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cos_sin: ((Double, Double)) => (Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples.
 Function composition
\begin_inset CommandInset label
LatexCommand label
name "subsec:Examples-of-fully-parametric"

\end_inset


\end_layout

\begin_layout Standard
Further examples of fully parametric functions are the identity function,
 the constant function, the function composition methods, and the curry
 / uncurry conversions.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity function
\end_layout

\end_inset

identity function (available in the Scala library as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[T]
\end_layout

\end_inset

) is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def id[T]: T => T = t => t
\end_layout

\end_inset

The constant function
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset

 (available in the Scala library as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Function.const
\end_layout

\end_inset

) takes an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 and returns a new function that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def const[C, X](c: C): X => C = (_ => c)
\end_layout

\end_inset

The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_ => c
\end_layout

\end_inset

 is used to emphasize that the function ignores its argument.
\end_layout

\begin_layout Paragraph
Function composition
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
function composition
\end_layout

\end_inset

Consider two functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Double
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: Double => String
\end_layout

\end_inset

.
 We can apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to an integer argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Int
\end_layout

\end_inset

 and get a result 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 We can then apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to that result and obtain a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(f(x))
\end_layout

\end_inset

.
 The transformation from the original integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Int
\end_layout

\end_inset

 to the final 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(f(x))
\end_layout

\end_inset

 can be viewed as a new function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => String
\end_layout

\end_inset

.
 That new function is called the 
\series bold
forward composition
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
forward composition
\end_layout

\end_inset

 of the two functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

.
 In Scala, this operation is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Int => Double = x => 5.67 + x
\end_layout

\begin_layout Plain Layout

val g: Double => String = x => f"Result x = $x%3.2f"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val h = f andThen g
\end_layout

\begin_layout Plain Layout

h: Int => String = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> h(40)
\end_layout

\begin_layout Plain Layout

res36: String = Result x = 45.67
\end_layout

\end_inset

The Scala compiler derives the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 automatically as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => String
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The forward composition is denoted by 
\begin_inset Formula $\bef$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

before
\begin_inset Quotes erd
\end_inset

) and can be defined as
\begin_inset Formula 
\begin{equation}
f\bef g\triangleq\left(x\Rightarrow g(f(x))\right)\quad.\label{eq:def-of-forward-composition}
\end{equation}

\end_inset

The symbol 
\begin_inset Formula $\triangleq$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

is defined as
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
We could write the forward composition as a fully parametric function,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def andThen[X, Y, Z](f: X => Y)(g: Y => Z): X => Z = { x => g(f(x)) }
\end_layout

\end_inset

The type signature of this curried function is 
\begin_inset Formula 
\[
\text{andThen}:\left(X\Rightarrow Y\right)\Rightarrow\left(Y\Rightarrow Z\right)\Rightarrow X\Rightarrow Z\quad.
\]

\end_inset

This type signature requires the types of the function arguments to match
 in a certain way, or else the composition is undefined.
\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

 is an example of a function that 
\emph on
both
\emph default
 returns a new function 
\emph on
and
\emph default
 takes other functions as arguments.
\end_layout

\begin_layout Standard
The 
\series bold
backward composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
backward composition
\end_layout

\end_inset


\series default
 of two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 works in the opposite order: first 
\begin_inset Formula $g$
\end_inset

 is applied and then 
\begin_inset Formula $f$
\end_inset

 is applied to the result.
 Using the symbol 
\begin_inset Formula $\circ$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

after
\begin_inset Quotes erd
\end_inset

) for this operation, we can write
\begin_inset Formula 
\begin{equation}
f\circ g\triangleq\left(x\Rightarrow f(g(x))\right)\quad.\label{eq:def-of-backward-composition}
\end{equation}

\end_inset

In Scala, the backward composition is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

 and used as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f compose g
\end_layout

\end_inset

.
 This method may be implemented as a fully parametric function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compose[X, Y, Z](f: Y => X)(g: Z => Y): Z => X = { z => f(g(z)) }
\end_layout

\end_inset

The type signature of this curried function is
\begin_inset Formula 
\[
\text{compose}:\left(Y\Rightarrow X\right)\Rightarrow\left(Z\Rightarrow Y\right)\Rightarrow Z\Rightarrow X\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We have already seen the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 defined by the Scala library.
 As an illustration, let us write our own code for converting curried functions
 to uncurried:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def uncurry[A, B, R](f: A => B => R): ((A, B)) => R = {
\end_layout

\begin_layout Plain Layout

  case (a, b) => f(a)(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We conclude from these examples that fully parametric functions perform
 operations that are so general that they work in the same way for all types
 of arguments.
 Some arguments of fully parametric functions may have complicated types
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => R
\end_layout

\end_inset

, which are type expressions made up from type parameters alone.
 Fully parametric functions do not perform any operations with specific
 types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The property of being fully parametric is also called 
\series bold
parametricity
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametricity
\end_layout

\end_inset

.
 In some programming languages, functions with type parameters are called
 
\begin_inset Quotes eld
\end_inset

generic
\begin_inset Index idx
status open

\begin_layout Plain Layout
generic functions
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Laws of function composition
\begin_inset CommandInset label
LatexCommand label
name "subsec:Laws-of-function-composition"

\end_inset


\end_layout

\begin_layout Standard
The operations of function composition, introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-fully-parametric"
plural "false"
caps "false"
noprefix "false"

\end_inset

, have three important properties or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

 that follow directly from the definitions.
 These laws are:
\end_layout

\begin_layout Itemize
The two identity laws: the composition of any function 
\begin_inset Formula $f$
\end_inset

 with the identity function will give again the function 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Itemize
The associativity law: the consecutive composition of three functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

 does not depend on the order in which the pairs are composed.
\end_layout

\begin_layout Standard
These laws hold for the forward and the backward composition, since they
 are just syntactic variants of the same mathematical operation.
 Let us write these laws rigorously as mathematical equations and prove
 them.
\end_layout

\begin_layout Paragraph
Proofs in the forward notation
\end_layout

\begin_layout Standard
The composition of the identity function with an arbitrary function 
\begin_inset Formula $f$
\end_inset

 can be 
\begin_inset Formula $\text{id}\bef f$
\end_inset

 with the identity function to the left of 
\begin_inset Formula $f$
\end_inset

, or 
\begin_inset Formula $f\bef\text{id}$
\end_inset

 with the identity function to the right of 
\begin_inset Formula $f$
\end_inset

.
 In both cases, the result must be equal to the function 
\begin_inset Formula $f$
\end_inset

.
 The resulting two laws are
\begin_inset Formula 
\begin{align*}
\text{left identity law of composition}:\quad & \text{id}\bef f=f\quad,\\
\text{right identity law of composition}:\quad & f\bef\text{id}=f\quad.
\end{align*}

\end_inset

To show that these laws always hold, we need to show that both sides of
 the laws, which are functions, give the same result when applied to an
 arbitrary value 
\begin_inset Formula $x$
\end_inset

.
 Let us first clarify how the type parameters must be set for the laws to
 have consistent types.
\end_layout

\begin_layout Standard
The laws must hold for an arbitrary function 
\begin_inset Formula $f$
\end_inset

.
 So we may assume that 
\begin_inset Formula $f$
\end_inset

 has the type signature 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are arbitrary type parameters.
 Consider the left identity law.
 The function 
\begin_inset Formula $\left(\text{id}\bef f\right)$
\end_inset

 is, by definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-forward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), a function that takes an argument 
\begin_inset Formula $x$
\end_inset

, applies 
\begin_inset Formula $\text{id}$
\end_inset

 to that 
\begin_inset Formula $x$
\end_inset

, and then applies 
\begin_inset Formula $f$
\end_inset

 to the result: 
\begin_inset Formula 
\[
\text{id}\bef f=\left(x\Rightarrow f(\text{id}(x))\right)\quad.
\]

\end_inset

If 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, its argument must be of type 
\begin_inset Formula $A$
\end_inset

, or else the types will not match.
 Therefore, the identity function must have type 
\begin_inset Formula $A\Rightarrow A$
\end_inset

, and the argument 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $A$
\end_inset

.
 With these choices of the type parameters, the function 
\begin_inset Formula $\left(x\Rightarrow f(\text{id}(x))\right)$
\end_inset

 will have type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, as it must since the right-hand side of the law is 
\begin_inset Formula $f$
\end_inset

.
 We add type annotations to the code as 
\emph on
superscripts
\emph default
,
\begin_inset Formula 
\[
\text{id}^{A}\bef f^{:A\Rightarrow B}=\big(x^{:A}\Rightarrow f(\text{id}(x))\big)^{:A\Rightarrow B}\quad.
\]

\end_inset

In the Scala syntax, this formula may be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

id[A] andThen (f: A => B) == { x: A => f(id(x)) }: A => B
\end_layout

\end_inset

It is quicker to write the mathematical notation than code in the Scala
 syntax.
 We will follow the convention where type parameters are single uppercase
 letters; however, this convention is not enforced in Scala.
\end_layout

\begin_layout Standard
The colon symbol (
\begin_inset Formula $:$
\end_inset

) in the superscript 
\begin_inset Formula $x^{:A}$
\end_inset

 means a type annotation, as in Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 A superscript without the colon, such as 
\begin_inset Formula $\text{id}^{A}$
\end_inset

, means a type parameter, as in Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id[A]
\end_layout

\end_inset

.
 Since the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id[A]
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => A
\end_layout

\end_inset

, we can write 
\begin_inset Formula $\text{id}^{A}$
\end_inset

 or equivalently (but more verbosely) 
\begin_inset Formula $\text{id}^{:A\Rightarrow A}$
\end_inset

 to denote that function.
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\text{id}(x)=x$
\end_inset

 by definition of the identity function, we find that 
\begin_inset Formula 
\[
\text{id}\bef f=\left(x\Rightarrow f\left(\text{id}\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]

\end_inset

The last step works since 
\begin_inset Formula $x\Rightarrow f\left(x\right)$
\end_inset

 is a function taking an argument 
\begin_inset Formula $x$
\end_inset

 and applying 
\begin_inset Formula $f$
\end_inset

 to that argument; i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula $x\Rightarrow f\left(x\right)$
\end_inset

 is the same function as 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
Now consider the right identity law:
\begin_inset Formula 
\[
f\bef\text{id}=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)\quad.
\]

\end_inset

To make the types match, assume that 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

.
 Then 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $A$
\end_inset

, and the identity function must have type 
\begin_inset Formula $B\Rightarrow B$
\end_inset

.
 The result of 
\begin_inset Formula $\text{id}\left(f\left(x\right)\right)$
\end_inset

 will be also of type 
\begin_inset Formula $B$
\end_inset

.
 With these choices of type parameters, all types match:
\begin_inset Formula 
\[
f^{:A\Rightarrow B}\bef\text{id}^{B}=\left(x^{:A}\Rightarrow\text{id}(f(x))\right)^{:A\Rightarrow B}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{id}(f(x))=f(x)$
\end_inset

, we find that 
\begin_inset Formula 
\[
f\bef\text{id}=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]

\end_inset

In this way, we have demonstrated that both identity laws hold.
 
\end_layout

\begin_layout Standard
The associativity law is written as an equation like this:
\begin_inset Formula 
\begin{equation}
\left(f\bef g\right)\bef h=f\bef\left(g\bef h\right)\quad.\label{eq:associativity-of-function-composition}
\end{equation}

\end_inset

Let us first verify that the types match here.
 The types of the functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 must be such that all the function compositions exist.
 If 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 for some type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, then the argument of 
\begin_inset Formula $g$
\end_inset

 must be of type 
\begin_inset Formula $B$
\end_inset

; so we can choose 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

, where 
\begin_inset Formula $C$
\end_inset

 is another type parameter.
 The composition 
\begin_inset Formula $f\bef g$
\end_inset

 has type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

, so 
\begin_inset Formula $h$
\end_inset

 must be of type 
\begin_inset Formula $C\Rightarrow D$
\end_inset

 for some type 
\begin_inset Formula $D$
\end_inset

.
 Assuming the types as 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

, and 
\begin_inset Formula $h^{:C\Rightarrow D}$
\end_inset

, we find that the types in all the compositions 
\begin_inset Formula $f\bef g$
\end_inset

, 
\begin_inset Formula $g\bef h$
\end_inset

, 
\begin_inset Formula $\left(f\bef g\right)\bef h$
\end_inset

, and 
\begin_inset Formula $f\bef\left(g\bef h\right)$
\end_inset

 match.
 We can rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with type annotations, 
\begin_inset Formula 
\begin{equation}
(f^{:A\Rightarrow B}\bef g^{:B\Rightarrow C})\bef h^{:C\Rightarrow D}=f^{:A\Rightarrow B}\bef(g^{:B\Rightarrow C}\bef h^{:C\Rightarrow D})\quad.\label{eq:associativity-law-for-function-composition-with-types}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Having checked the types, we are ready to prove the associativity law.
 We note that both sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-for-function-composition-with-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are functions of type 
\begin_inset Formula $A\Rightarrow D$
\end_inset

.
 To prove that two functions are equal means to prove that they always return
 the same results when applied to the same argument.
 So we need to apply both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-for-function-composition-with-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 Using the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-forward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of the forward composition, 
\begin_inset Formula 
\[
\left(f\bef g\right)(x)=g(f(x))\quad,
\]

\end_inset

we find
\begin_inset Formula 
\begin{align*}
\left(\left(f\bef g\right)\bef h\right)(x) & =h\left(\left(f\bef g\right)(x)\right)=h(g(f(x)))\quad,\\
\left(f\bef\left(g\bef h\right)\right)(x) & =\left(g\bef h\right)(f(x))=h(g(f(x)))\quad.
\end{align*}

\end_inset

Both sides of the law are now clearly equal when applied to an arbitrary
 value 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Standard
Because of the associativity law, we do not need parentheses in the expression
 
\begin_inset Formula $f\bef g\bef h$
\end_inset

.
 The function 
\begin_inset Formula $\left(f\bef g\right)\bef h$
\end_inset

 is the same as 
\begin_inset Formula $f\bef\left(g\bef h\right)$
\end_inset

.
\end_layout

\begin_layout Standard
In the proof, we have omitted the types since we already checked that the
 types match.
 Checking the types beforehand allows us to write shorter proofs.
\end_layout

\begin_layout Paragraph
Proofs in the backward notation
\end_layout

\begin_layout Standard
This book uses the 
\series bold
forward notation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
forward notation
\end_layout

\end_inset

 
\begin_inset Formula $f\bef g$
\end_inset

 for writing function compositions, rather than the backward notation 
\begin_inset Formula $g\circ f$
\end_inset

.
 If necessary, all equations can be automatically converted from one notation
 to the other by reversing the order of function compositions, since
\begin_inset Formula 
\[
f\bef g=g\circ f
\]

\end_inset

for any functions 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

.
 Let us see how to prove the composition laws in the backward notation.
 We will just need to reverse the order of function compositions in the
 proofs above.
\end_layout

\begin_layout Standard
The left identity and right identity laws are
\begin_inset Formula 
\[
f\circ\text{id}=f\quad\quad,\quad\text{id}\circ f=f\quad.
\]

\end_inset

To match the types, we need to choose the type parameters as
\begin_inset Formula 
\[
f^{:A\Rightarrow B}\circ\text{id}^{:A\Rightarrow A}=f^{:A\Rightarrow B}\quad\quad,\quad\text{id}^{B\Rightarrow B}\circ f^{:A\Rightarrow B}=f^{:A\Rightarrow B}\quad.
\]

\end_inset

We can apply both sides of the laws to an arbitrary value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 For the left identity law, we find from definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-backward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that
\begin_inset Formula 
\[
f\circ\text{id}=\left(x\Rightarrow f(\text{id}(x))\right)=\left(x\Rightarrow f(x)\right)=f\quad.
\]

\end_inset

Similarly for the right identity law,
\begin_inset Formula 
\[
\text{id}\circ f=\left(x\Rightarrow\text{id}\left(f\left(x\right)\right)\right)=\left(x\Rightarrow f\left(x\right)\right)=f\quad.
\]

\end_inset

The associativity law,
\begin_inset Formula 
\[
h\circ\left(g\circ f\right)=\left(h\circ g\right)\circ f\quad,
\]

\end_inset

is proved by applying both sides to an arbitrary value 
\begin_inset Formula $x$
\end_inset

 of a suitable type:
\begin_inset Formula 
\begin{align*}
\left(h\circ\left(g\circ f\right)\right)(x) & =h\left(\left(g\circ f\right)(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad,\\
\left(\left(h\circ g\right)\circ f\right)(x) & =\left(h\circ g\right)\left(f(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad.
\end{align*}

\end_inset

The types are checked by assuming that 
\begin_inset Formula $f$
\end_inset

 has the type 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

.
 The types in 
\begin_inset Formula $g\circ f$
\end_inset

 match only when 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

, and then 
\begin_inset Formula $g\circ f$
\end_inset

 is of type 
\begin_inset Formula $A\Rightarrow C$
\end_inset

.
 The type of 
\begin_inset Formula $h$
\end_inset

 must be 
\begin_inset Formula $h^{:C\Rightarrow D}$
\end_inset

 for the types in 
\begin_inset Formula $h\circ\left(g\circ f\right)$
\end_inset

 to match.
 We can write the associativity law with type annotations as
\begin_inset Formula 
\begin{equation}
h^{:C\Rightarrow D}\circ(g^{:B\Rightarrow C}\circ f^{A\Rightarrow B})=(h^{:C\Rightarrow D}\circ g^{:B\Rightarrow C})\circ f^{:A\Rightarrow B}\quad.\label{eq:assoc-law-for-composition-with-types-backward}
\end{equation}

\end_inset

The associativity law allows us to omit parentheses in the expression 
\begin_inset Formula $h\circ g\circ f$
\end_inset

.
 
\end_layout

\begin_layout Standard
The length of calculations is the same in the forward and the backward notation.
 One difference is that types of function compositions are more visually
 clear in the forward notation: it is easier to check types in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-for-function-composition-with-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) than in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:assoc-law-for-composition-with-types-backward"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Example: A function that violates parametricity 
\end_layout

\begin_layout Standard
Fully parametric functions should not make any decisions based on the actual
 types of its parameters.
 As an example of an 
\emph on
incorrect
\emph default
 implementation of a fully parametric function, consider the following 
\begin_inset Quotes eld
\end_inset

fake identity
\begin_inset Quotes erd
\end_inset

 function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fakeId[A]: A => A = { // Special code for `A` = `Int`:
\end_layout

\begin_layout Plain Layout

  case x: Int => (x - 1).asInstanceOf[A]
\end_layout

\begin_layout Plain Layout

  case x => x // Common code for all other types `A`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This function's type signature is the same as that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id[A]
\end_layout

\end_inset

, and its behavior is the same for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 except for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fakeId("abc")
\end_layout

\begin_layout Plain Layout

res0: String = abc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fakeId(true)
\end_layout

\begin_layout Plain Layout

res1: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fakeId(0)
\end_layout

\begin_layout Plain Layout

res2: Int = -1
\end_layout

\end_inset

While Scala allows us to write this kind of code, the resulting function
 does not appear to be useful.
 In any case, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId
\end_layout

\end_inset

 is not a fully parametric function.
\end_layout

\begin_layout Standard
The identity laws of composition will not hold if we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId[A]
\end_layout

\end_inset

 instead of the correct function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id[A]
\end_layout

\end_inset

.
 For example, consider the composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId
\end_layout

\end_inset

 with a simple function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 defined by
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f_1: Int => Int = { x => x + 1 }
\end_layout

\end_inset

The composition (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1 andThen fakeId
\end_layout

\end_inset

) will have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, Scala will automatically set the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId[A]
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def f_2 = f_1 andThen fakeId
\end_layout

\begin_layout Plain Layout

f_2: Int => Int
\end_layout

\end_inset

The identity law says that 
\begin_inset Formula $f_{2}=f_{1}\bef\text{id}=f_{1}$
\end_inset

.
 But we can check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_2
\end_layout

\end_inset

 are not the same:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f_1(0)
\end_layout

\begin_layout Plain Layout

res3: Int = 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f_2(0)
\end_layout

\begin_layout Plain Layout

res3: Int = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important that we are able to detect a violation of parametricity
 by checking whether some equation holds, without need to examine the code
 of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fakeId
\end_layout

\end_inset

.
 In this book, we will always formulate any desired properties of functions
 through equations or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

.
 To prove the laws, we will need to perform symbolic calculations
\begin_inset Index idx
status open

\begin_layout Plain Layout
symbolic calculations
\end_layout

\end_inset

 similar to the proofs in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These calculations are 
\series bold
symbolic
\series default
 in the sense that we were manipulating symbols such as 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 without substituting any specific values for these symbols but using only
 the general properties of functions.
 In the next section, we will get some more experience with such calculations.
\end_layout

\begin_layout Section
Symbolic calculations with nameless functions
\end_layout

\begin_layout Subsection
Solved examples: Deriving a function's type from its code
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Checking that the types match is an important part of the functional programming
 paradigm – both in the practice of writing code and in theoretical derivations
 of laws for various functions.
 For instance, in the derivations of the composition laws (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we were able to deduce the possible type parameters for 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 in the expression 
\begin_inset Formula $f\bef g\bef h$
\end_inset

.
 This worked because the composition operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

 (denoted by the symbol 
\begin_inset Formula $\bef$
\end_inset

) is fully parametric.
 Given a fully parametric function, it is often possible to derive the most
 general type signature that matches the body of that function.
 The same type-matching procedure may also help in converting a given function
 to a fully parametric form.
\end_layout

\begin_layout Standard
Let us look at some examples of doing this.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 were defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-fully-parametric"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 What is the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 and what is its type? Determine the most general type parameters in the
 expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to treat the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 as values, since our goal is to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Write the code of these functions in a short notation:
\begin_inset Formula 
\begin{align*}
\text{const}^{C,X} & \triangleq c^{:C}\Rightarrow\_^{:X}\Rightarrow c\quad,\\
\text{id}^{A} & \triangleq a^{:A}\Rightarrow a\quad.
\end{align*}

\end_inset

The types will match in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 only if the argument of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 has the same type as the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Since 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{const}$
\end_inset


\begin_inset Quotes erd
\end_inset

 is a curried function, we need to look at its 
\emph on
first
\emph default
 curried argument, which is of type 
\begin_inset Formula $C$
\end_inset

.
 The type of 
\begin_inset Formula $\text{id}$
\end_inset

 is 
\begin_inset Formula $A\Rightarrow A$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is an arbitrary type so far.
 So, the type parameter 
\begin_inset Formula $C$
\end_inset

 in 
\begin_inset Formula $\text{const}^{C,X}$
\end_inset

 must be equal to 
\begin_inset Formula $A\Rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
C=A\Rightarrow A\quad.
\]

\end_inset

 The type parameter 
\begin_inset Formula $X$
\end_inset

 in 
\begin_inset Formula $\text{const}^{C,X}$
\end_inset

 is not constrained, so we keep it as 
\begin_inset Formula $X$
\end_inset

.
 The result of applying 
\begin_inset Formula $\text{const}$
\end_inset

 to 
\begin_inset Formula $\text{id}$
\end_inset

 is of type 
\begin_inset Formula $X\Rightarrow C$
\end_inset

, which equals 
\begin_inset Formula $X\Rightarrow A\Rightarrow A$
\end_inset

.
 In this way, we find that the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{const}^{A\Rightarrow A,X}(\text{id}^{A}):X\Rightarrow A\Rightarrow A\quad.
\]

\end_inset

The types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset

 can be arbitrary.
 The type 
\begin_inset Formula $X\Rightarrow A\Rightarrow A$
\end_inset

 is the most general type for the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 because we have not made any assumptions about the types except requiring
 that all functions must be always applied to arguments of the correct types.
\end_layout

\begin_layout Standard
To compute the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

, it remains to substitute the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Since we already checked the types, we may omit all type annotations:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{const}}\left(\text{id}\right)\\
\text{definition of const}:\quad & =(c\Rightarrow x\Rightarrow\gunderline c)(\text{id})\\
\text{substitute }c=\text{id}:\quad & =(x\Rightarrow\gunderline{\text{id}})\\
\text{definition of }\text{id}:\quad & =\left(x\Rightarrow a\Rightarrow a\right)\quad.
\end{align*}

\end_inset

This is a function that takes an argument 
\begin_inset Formula $x^{:X}$
\end_inset

 and returns the identity function 
\begin_inset Formula $a^{:A}\Rightarrow a$
\end_inset

.
 It is clear that the argument 
\begin_inset Formula $x$
\end_inset

 is ignored by this function, so we can rewrite the result equivalently
 as
\begin_inset Formula 
\[
\text{const}(\text{id})=(\_^{:X}\Rightarrow a^{:A}\Rightarrow a)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 that takes a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Int
\end_layout

\end_inset

 as its argument and returns a function that applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 twice.
 For example, if the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f = { x => x + 3 }
\end_layout

\end_inset

, the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(f)
\end_layout

\end_inset

 should be equal to the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x + 6
\end_layout

\end_inset

.
 After implementing the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

, generalize it to a fully parametric function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
According to the requirements, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 must return a new function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 So the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = ???
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(f)
\end_layout

\end_inset

 must be a new function with an integer argument, we begin to write the
 body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = { (x: Int) => ??? }
\end_layout

\end_inset

The new function must apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 twice to its argument, that is, it must return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(f(x))
\end_layout

\end_inset

.
 We can finish the implementation now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = { x => f(f(x)) }
\end_layout

\end_inset

The type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int)
\end_layout

\end_inset

 can be omitted.
 To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val g = twice(x => x + 3)
\end_layout

\begin_layout Plain Layout

g: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> g(10)
\end_layout

\begin_layout Plain Layout

res0: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example illustrates how a function can return a new function.
 We just write a nameless function in the function body.
\end_layout

\begin_layout Standard
To generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 to a fully parametric function means to replace the type signature by a
 parameterized type while keeping the function body unchanged,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice[A, B, ...](f: ...): ...
 = { x => f(f(x)) }
\end_layout

\end_inset

 To determine the type signature and the possible type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ..., we need to determine the most general type that matches the function
 body.
 The function body is the expression 
\begin_inset Formula $x\Rightarrow f(f(x))$
\end_inset

.
 Assume that 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

; for types to match in the sub-expression 
\begin_inset Formula $f(x)$
\end_inset

, we need 
\begin_inset Formula $f$
\end_inset

 to have type 
\begin_inset Formula $A\Rightarrow B$
\end_inset

 for some type 
\begin_inset Formula $B$
\end_inset

.
 The sub-expression 
\begin_inset Formula $f(x)$
\end_inset

 will then have type 
\begin_inset Formula $B$
\end_inset

.
 For types to match in 
\begin_inset Formula $f(f(x))$
\end_inset

, the argument of 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $B$
\end_inset

; but we already assumed 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

.
 This is consistent only if 
\begin_inset Formula $A=B$
\end_inset

.
 In this way, 
\begin_inset Formula $x^{:A}$
\end_inset

 implies 
\begin_inset Formula $f^{:A\Rightarrow A}$
\end_inset

, and the expression 
\begin_inset Formula $x\Rightarrow f(f(x))$
\end_inset

 has type 
\begin_inset Formula $A\Rightarrow A$
\end_inset

.
 We can now write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice[A](f: A => A): A => A = { x => f(f(x)) }
\end_layout

\end_inset

This fully parametric function has only one independent type parameter,
 
\begin_inset Formula $A$
\end_inset

, and can be equivalently written in the mathematical notation as the curried
 function
\begin_inset Formula 
\begin{equation}
\text{twice}^{A}\triangleq f^{:A\Rightarrow A}\Rightarrow x^{:A}\Rightarrow f(f(x))\quad.\label{eq:hof-def-of-twice-in-math-notation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The procedure of deriving the most general type for a given code is called
 
\series bold
type inference
\series default

\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

.
 The presence of the type parameter 
\begin_inset Formula $A$
\end_inset

 and the general type signature 
\begin_inset Formula $\left(A\Rightarrow A\right)\Rightarrow A\Rightarrow A$
\end_inset

 have been 
\begin_inset Quotes eld
\end_inset

inferred
\begin_inset Quotes erd
\end_inset

 from the code 
\begin_inset Formula $f\Rightarrow x\Rightarrow f(f(x))$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 What is the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, and what computation does it perform? Test your answer on the expression
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice[Int])(x => x+3)(10)
\end_layout

\end_inset

.
 What are the type parameters in that expression?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by figuring out the required type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

.
 We introduce unknown type parameters as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[A](twice[B])
\end_layout

\end_inset

.
 The types will match if the argument type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[A]
\end_layout

\end_inset

, which is 
\begin_inset Formula $A\Rightarrow A$
\end_inset

, matches the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[B]
\end_layout

\end_inset

, which is 
\begin_inset Formula $\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B$
\end_inset

.
 Since the symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 groups to the right, we have 
\begin_inset Formula 
\begin{align*}
 & \left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B\\
 & =\left(B\Rightarrow B\right)\Rightarrow\left(B\Rightarrow B\right)\quad.
\end{align*}

\end_inset

This can match with 
\begin_inset Formula $A\Rightarrow A$
\end_inset

 only if we set 
\begin_inset Formula $A=\left(B\Rightarrow B\right)$
\end_inset

.
 So the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 is
\begin_inset Formula 
\begin{equation}
\text{twice}^{B\Rightarrow B}(\text{twice}^{B}):\left(B\Rightarrow B\right)\Rightarrow B\Rightarrow B\quad.\label{eq:hof-twice-example-solved3}
\end{equation}

\end_inset

After checking that types match, we may omit types from further calculations.
\end_layout

\begin_layout Standard
Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 defined 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 syntax.
 To use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as an argument in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, it is convenient to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as a value,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val twice = ...
\end_layout

\end_inset

However, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 has type parameters, and Scala 2 does not directly support 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 definitions with type parameters.
 Scala 3 will support type parameters appearing together with value parameters
 in a nameless function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val twice = [A] => (f: A => A) => (x: A) => f(f(x)) // Scala 3 only!
\end_layout

\end_inset

Keeping this in mind, we will use the curried definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 given by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:hof-def-of-twice-in-math-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Substituting this into the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, we find
\begin_inset Formula 
\begin{align*}
 & \text{twice}(\text{twice})\\
\text{definition of twice}:\quad & =(f\Rightarrow x\Rightarrow f(f(x)))(\text{twice})\quad.\\
\text{substitute }f=\text{twice}:\quad & =x\Rightarrow\text{twice}(\text{twice}(x))\\
\text{definition of twice}:\quad & =x\Rightarrow\left(f\Rightarrow x\Rightarrow f(f(x))\right)\left(\left(f\Rightarrow x\Rightarrow f(f(x))\right)(x)\right)\quad.
\end{align*}

\end_inset

The last expression is hard to use: it is confusing that the argument names
 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

 are repeated.
 The calculation will be made clearer if we rename the arguments to remove
 shadowing of names
\begin_inset Index idx
status open

\begin_layout Plain Layout
shadowed name
\end_layout

\end_inset

.
 To avoid errors, we will start with 
\begin_inset Formula $x\Rightarrow\text{twice}(\text{twice}(x))$
\end_inset

 and rename arguments one scope at a time:
\begin_inset Formula 
\begin{align*}
 & x\Rightarrow\text{twice}(\text{twice}(\gunderline x))\\
\text{rename }x\text{ to }z:\quad & =z\Rightarrow\gunderline{\text{twice}}(\text{twice}(z))\\
\text{definition of twice}:\quad & =z\Rightarrow\gunderline{\left(f\Rightarrow x\Rightarrow f(f(x))\right)}\left(\text{twice}(z)\right)\\
\text{rename }f,x\text{ to }g,y:\quad & =z\Rightarrow(g\Rightarrow y\Rightarrow\gunderline g(\gunderline g(y)))\left(\text{twice}(z)\right)\\
\text{apply, }g=\text{twice}(z):\quad & =z\Rightarrow y\Rightarrow\gunderline{\left(\text{twice}(z)\right)}\left(\text{twice}(z)(y)\right)\\
\text{use }\text{twice}(z)=\left(x\Rightarrow z(z(x))\right):\quad & =z\Rightarrow y\Rightarrow\left(x\Rightarrow z(z(x))\right)(\gunderline{\text{twice}(z)(y)})\\
\text{apply, }x=\text{twice}(z)(y)=z(z(y)):\quad & =z\Rightarrow y\Rightarrow z(z(z(z(y))))\quad.
\end{align*}

\end_inset

So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 is a function that applies its (function-typed) argument 
\emph on
four
\emph default
 times.
\end_layout

\begin_layout Standard
The type parameters follow from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:hof-twice-example-solved3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $A=\text{Int}$
\end_inset

 and can be written as 
\begin_inset Formula $\text{twice}^{\text{Int}\Rightarrow\text{Int}}(\text{twice}^{\text{Int}})$
\end_inset

, or in Scala syntax, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[Int => Int](twice[Int])
\end_layout

\end_inset

.
 To test, we need to write at least one type parameter in the code, or else
 Scala cannot infer the types correctly:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> twice(twice[Int])(x => x + 3)(100) // _ + 3 + 3 + 3 + 3
\end_layout

\begin_layout Plain Layout

res0: Int = 112
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> twice[Int => Int](twice)(x => x + 3)(100)
\end_layout

\begin_layout Plain Layout

res1: Int = 112
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer the type signature for the fully parametric function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[...]:...
 = { f => f(2) }
\end_layout

\end_inset

Can the types possibly match in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
In the nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

, the argument 
\begin_inset Formula $f$
\end_inset

 must be itself a function with an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, otherwise the sub-expression 
\begin_inset Formula $f(2)$
\end_inset

 makes no sense.
 So, types will match if 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\Rightarrow\text{Int}$
\end_inset

 or 
\begin_inset Formula $\text{Int}\Rightarrow\text{String}$
\end_inset

 or similar.
 The most general case is when 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\Rightarrow A$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is an arbitrary type (i.e.
\begin_inset space ~
\end_inset

a type parameter).
 The type 
\begin_inset Formula $A$
\end_inset

 will then be the (so far unknown) type of the value 
\begin_inset Formula $f(2)$
\end_inset

.
 Since nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

 has an argument 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset Formula $\text{Int}\Rightarrow A$
\end_inset

 and the result of type 
\begin_inset Formula $A$
\end_inset

, we find that the type of 
\begin_inset Formula $p$
\end_inset

 must be 
\begin_inset Formula $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$
\end_inset

.
 With this type assignment, all types match.
 The type parameter 
\begin_inset Formula $A$
\end_inset

 remains undetermined and is added to the type signature of the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 The code is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[A]: (Int => A) => A = { f => f(2) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To answer the question about the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

, we begin by writing that expression with new type parameters as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A](p[B])
\end_layout

\end_inset

.
 Then we try to choose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 so that the types match in that expression.
 Does the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[B]
\end_layout

\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => B) => B
\end_layout

\end_inset

, match the type of the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A]
\end_layout

\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

, with some choice of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

? A function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P => Q
\end_layout

\end_inset

 matches 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X => Y
\end_layout

\end_inset

 only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = X
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q = Y
\end_layout

\end_inset

.
 So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => B) => B
\end_layout

\end_inset

 can match 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

 only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => B
\end_layout

\end_inset

 matches 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B = A
\end_layout

\end_inset

.
 But it is impossible for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => B
\end_layout

\end_inset

 to match 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, no matter how we choose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We conclude that types cannot be chosen consistently in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A](p[B])
\end_layout

\end_inset

.
 Such expressions contain a type error and are rejected by the Scala compiler.
 One also says that the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

 is 
\series bold
not well-typed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
well-typed expression
\end_layout

\end_inset

, or does not 
\series bold
typecheck
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type checking
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For any given code expression containing only function expressions, one
 can always find the most general type that makes all functions match their
 arguments, unless the expression does not typecheck.
 The Damas-Hindley-Milner algorithm
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W"
target "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W"
literal "false"

\end_inset


\end_layout

\end_inset

 performs type inference (or determines that there is a type error) for
 a large class of expressions containing functions, tuples, and disjunctive
 types.
 
\end_layout

\begin_layout Subsection
Calculations with curried functions
\end_layout

\begin_layout Standard
In mathematics, functions are evaluated by substituting their argument values
 into their body.
 Nameless functions are evaluated in the same way.
 For example, applying the nameless function 
\begin_inset Formula $x\Rightarrow x+10$
\end_inset

 to an integer 
\begin_inset Formula $2$
\end_inset

, we substitute 
\begin_inset Formula $2$
\end_inset

 instead of 
\begin_inset Formula $x$
\end_inset

 in “
\begin_inset Formula $x+10$
\end_inset

” and get “
\begin_inset Formula $2+10$
\end_inset

”, which we then evaluate to 
\begin_inset Formula $12$
\end_inset

.
 The computation is written like this, 
\begin_inset Formula 
\[
(x\Rightarrow x+10)(2)=2+10=12\quad.
\]

\end_inset

To run this computation in Scala, we need to add a type annotation: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x: Int) => x + 10)(2)
\end_layout

\begin_layout Plain Layout

res0: Int = 12 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Curried function applications such as 
\begin_inset Formula $f(x)(y)$
\end_inset

 are rarely used in mathematics , so we need to gain some experience working
 with them.
\end_layout

\begin_layout Standard
Let us consider a curried nameless function being applied to arguments,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y => x - y)(20)(4)
\end_layout

\end_inset

, and compute the result of this function application.
 Begin with the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

; applying a nameless function of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => ...)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

 means to substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 20
\end_layout

\end_inset

 into the body of the function.
 After that substitution, we obtain the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => 20 - y
\end_layout

\end_inset

, which is again a nameless function.
 Applying that function to the remaining argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(4)
\end_layout

\end_inset

 means substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = 4
\end_layout

\end_inset

 into the body of that function.
 This yields the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20 - 4
\end_layout

\end_inset

.
 We can compute that and get the result, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

16
\end_layout

\end_inset

.
 Check the result with Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x: Int) => (y: Int) => x - y)(20)(4)
\end_layout

\begin_layout Plain Layout

res1: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applying a curried function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z => expr(x,y,z)
\end_layout

\end_inset

 to three curried arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

30
\end_layout

\end_inset

 means to substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 10
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = 20
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z = 30
\end_layout

\end_inset

 into the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

.
 In this way, we can easily apply a curried function to any number of curried
 arguments.
\end_layout

\begin_layout Standard
This calculation is helped by the convention that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h)
\end_layout

\end_inset

 means first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 and then applying the result to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

.
 In other words, function application groups to the 
\emph on
left
\emph default
: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h) = (f(g))(h)
\end_layout

\end_inset

.
 It would be confusing if function application grouped to the right and
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h)
\end_layout

\end_inset

 meant first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 and then applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the result.
 If 
\emph on
that
\emph default
 were the syntax convention, it would be harder to reason about applying
 a curried function to the arguments.
\end_layout

\begin_layout Standard
We see that the right grouping of the function arrow 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 is well adapted to the left grouping of function applications.
 All functional languages adopt these syntactic conventions.
\end_layout

\begin_layout Standard
To make calculations shorter, we will write code in a mathematical notation
 rather than in the Scala syntax.
 Type annotations are written with a colon in the superscript, for example:
 
\begin_inset Formula $x^{:\text{Int}}\Rightarrow x+10$
\end_inset

 instead of the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x:Int) => x + 10)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The symbolic evaluation of the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x:Int) => (y:Int) => x - y)(20)(4)
\end_layout

\end_inset

 can be performed as the following line-by-line derivation,
\begin_inset Formula 
\begin{align*}
 & (\gunderline{x^{:\text{Int}}\Rightarrow}\,y^{:\text{Int}}\Rightarrow\gunderline x-y)\left(20\right)\left(4\right)\\
\text{substitute }x=20:\quad & =(\gunderline{y^{:\text{Int}}\Rightarrow}\,20-\gunderline y)\left(4\right)\\
\text{substitute }y=4:\quad & =20-4=16\quad.
\end{align*}

\end_inset

(The underlined part of the expression will be rewritten in the next line.)
\end_layout

\begin_layout Standard
Here we performed calculations by substituting an argument into a function
 at each step.
 A compiled Scala program is evaluated in a similar way at run time.
\end_layout

\begin_layout Standard
Nameless functions are 
\emph on
values
\emph default
 and so can be used as part of larger expressions, just as any other values.
 For instance, nameless functions can be arguments of other functions (nameless
 or not).
 Here is an example of applying a nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

 to a nameless function 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f\Rightarrow\gunderline f(2))\left(x\Rightarrow x+4\right)\\
\text{substitute }f=\left(x\Rightarrow x+4\right):\quad & =(x\Rightarrow\gunderline x+4)(2)\\
\text{substitute }x=2:\quad & =2+4=6\quad.
\end{align*}

\end_inset

In the nameless function 
\begin_inset Formula $f\Rightarrow f(2)$
\end_inset

, the argument 
\begin_inset Formula $f$
\end_inset

 has to be itself a function, otherwise the expression 
\begin_inset Formula $f(2)$
\end_inset

 would make no sense.
 The argument 
\begin_inset Formula $x$
\end_inset

 of 
\begin_inset Formula $f(x)$
\end_inset

 must be an integer, or else we would not be able to compute 
\begin_inset Formula $x+4$
\end_inset

.
 The result of computing 
\begin_inset Formula $f(2)$
\end_inset

 is 
\begin_inset Formula $4$
\end_inset

, and integer.
 We conclude that in this example, 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $\text{Int}\Rightarrow\text{Int}$
\end_inset

, or else the types will not match.
 To verify this result in Scala, we need to specify the type annotation
 for 
\begin_inset Formula $f$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((f: Int => Int) => f(2))(x => x + 4)
\end_layout

\begin_layout Plain Layout

res2: Int = 6  
\end_layout

\end_inset

No type annotation is needed for 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 since the Scala compiler already knows the type of 
\begin_inset Formula $f$
\end_inset

 and can infer that 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To summarize the standard syntax conventions for curried nameless functions:
\end_layout

\begin_layout Itemize
Function expressions group everything to the right,
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $x\Rightarrow y\Rightarrow z\Rightarrow e$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group everything to the left,
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $f(x)(y)(z)$
\end_inset

 means 
\begin_inset Formula $\big((f(x))(y)\big)(z)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group stronger than infix operations,
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $x+f(y)$
\end_inset

 means 
\begin_inset Formula $x+(f(y))$
\end_inset

, as in mathematics.
\end_layout

\begin_layout Standard
Here are some more examples of performing function applications symbolically.
 Types are omitted for brevity; every non-function value is of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default
.
\begin_inset Formula 
\begin{align*}
\left(x\Rightarrow x*2\right)(10) & =10*2=20\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)\left(t\right) & =(z\Rightarrow z*t)\quad.\\
\left(p\Rightarrow z\Rightarrow z*p\right)(t)(4) & =(z\Rightarrow z*t)(4)=4*t\quad.
\end{align*}

\end_inset

Some results of these computation are integer values such as 
\begin_inset Formula $20$
\end_inset

; other results are nameless functions such as 
\begin_inset Formula $z\Rightarrow z*t$
\end_inset

.
 Verify this in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x:Int) => x*2)(10)
\end_layout

\begin_layout Plain Layout

res3: Int = 20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ((p:Int) => (z:Int) => z*p)(10)
\end_layout

\begin_layout Plain Layout

res4: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ((p:Int) => (z:Int) => z*p)(10)(4)
\end_layout

\begin_layout Plain Layout

res5: Int = 40 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the following examples, some arguments are themselves functions.
 We saw in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the most general type for 
\begin_inset Formula $g\Rightarrow g(2)$
\end_inset

 is 
\begin_inset Formula $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$
\end_inset

.
 Let us now compute an expression that uses 
\begin_inset Formula $\left(g\Rightarrow g(2)\right)$
\end_inset

 as an argument:
\begin_inset Formula 
\begin{align}
 & (f\Rightarrow p\Rightarrow\gunderline f(p))\left(g\Rightarrow g(2)\right)\nonumber \\
\text{substitute }f=\left(g\Rightarrow g(2)\right):\quad & =p\Rightarrow(g\Rightarrow\gunderline g(2))\,(p)\nonumber \\
\text{substitute }g=p:\quad & =p\Rightarrow p(2)\quad.\label{eq:higher-order-functions-derivation1}
\end{align}

\end_inset

The result of this expression is a function 
\begin_inset Formula $p\Rightarrow p(2)$
\end_inset

 that will apply 
\emph on
its
\emph default
 argument to the value 
\begin_inset Formula $2$
\end_inset

.
 A possible argument is the function 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

.
 So, let us apply the previous expression to that function:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\left(f\Rightarrow p\Rightarrow f(p)\right)\left(g\Rightarrow g(2)\right)}\left(x\Rightarrow x+4\right)\\
\text{use Eq.~(\ref{eq:higher-order-functions-derivation1})}:\quad & =(p\Rightarrow\gunderline p(2))\left(x\Rightarrow x+4\right)\\
\text{substitute }p=\left(x\Rightarrow x+4\right):\quad & =(x\Rightarrow\gunderline x+4)\left(2\right)\\
\text{substitute }x=2:\quad & =2+4=6\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify this calculation in Scala, we need to add appropriate type annotations
 for 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

.
 To figure out the types, we reason like this:
\end_layout

\begin_layout Standard
We know that the function 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

 is being applied to the arguments 
\begin_inset Formula $f=g\Rightarrow g(2)$
\end_inset

 and 
\begin_inset Formula $p=x\Rightarrow x+4$
\end_inset

.
 The most general type of 
\begin_inset Formula $g\Rightarrow g(2)$
\end_inset

 is 
\begin_inset Formula $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$
\end_inset

.
 So, this must be the type of the argument 
\begin_inset Formula $f$
\end_inset

 in 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

.
\end_layout

\begin_layout Standard
The variable 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 must be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or else we cannot add 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $4$
\end_inset

.
 Thus, the type of the expression 
\begin_inset Formula $x\Rightarrow x+4$
\end_inset

 is 
\begin_inset Formula $\text{Int}\Rightarrow\text{Int}$
\end_inset

, and so must be the type of the argument 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Finally, we need to make sure that the types match in the function 
\begin_inset Formula $f\Rightarrow p\Rightarrow f(p)$
\end_inset

.
 The types match in 
\begin_inset Formula $f(p)$
\end_inset

 if the type of 
\begin_inset Formula $f$
\end_inset

's argument is the same as the type of 
\begin_inset Formula $p$
\end_inset

.
 Since 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\left(\text{Int}\Rightarrow A\right)\Rightarrow A$
\end_inset

, its argument has type 
\begin_inset Formula $\text{Int}\Rightarrow A$
\end_inset

.
 To match that with the type of 
\begin_inset Formula $p^{:\text{Int}\Rightarrow\text{Int}}$
\end_inset

 requires us to set 
\begin_inset Formula $A=\text{Int}$
\end_inset

.
 So, the actual type of 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset Formula $\left(\text{Int}\Rightarrow\text{Int}\right)\Rightarrow\text{Int}$
\end_inset

.
 We know enough to write the Scala code now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((f: (Int => Int) => Int) => p => f(p))(g => g(2))(x => x + 4)
\end_layout

\begin_layout Plain Layout

res6: Int = 6
\end_layout

\end_inset

Type annotations for 
\begin_inset Formula $p$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 may be omitted because the Scala compiler will infer the missing types
 unambiguously from the given type of 
\begin_inset Formula $f$
\end_inset

.
 However, it is never an error to specify more types; it just makes the
 code longer.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What can we do with this chapter's techniques?
\end_layout

\begin_layout Itemize
Implement functions that return new functions and/or take functions as arguments.
\end_layout

\begin_layout Itemize
Simplify function applications symbolically.
\end_layout

\begin_layout Itemize
Infer the most general type for a given code expression.
\end_layout

\begin_layout Itemize
Convert functions to a fully parametric form.
\end_layout

\begin_layout Standard
The following solved examples and exercises illustrate these techniques.
\end_layout

\begin_layout Subsection
Solved examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function that applies a given function 
\begin_inset Formula $f$
\end_inset

 repeatedly to an initial value 
\begin_inset Formula $x_{0}$
\end_inset

, until a given condition function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cond
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def converge[X](f: X => X, x0: X, cond: X => Boolean): X = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We create an iterator that keeps applying the function 
\begin_inset Formula $f$
\end_inset

, and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find
\end_layout

\end_inset

 to stop the sequence when the condition first holds:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def converge[X](f: X => X, x0: X, cond: X => Boolean): X = 
\end_layout

\begin_layout Plain Layout

  Stream.iterate(x0)(f) // Type is Stream[X].
\end_layout

\begin_layout Plain Layout

  .find(cond) // Type is Option[X].
\end_layout

\begin_layout Plain Layout

  .get // Type is X.
\end_layout

\end_inset

Here it is safe to perform 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.get
\end_layout

\end_inset

 on an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

: If the condition never holds, the program will run out of memory (since
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 keeps all computed values in memory) or the user runs out of time.
\end_layout

\begin_layout Standard
A tail-recursive implementation that works in constant memory is 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def converge[X](f: X => X, x0: X, cond: X => Boolean): X =
\end_layout

\begin_layout Plain Layout

  if (cond(x0)) x0 else converge(f, f(x0), cond)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To test this code, let us compute an approximation to the square root of
 a number 
\begin_inset Formula $q$
\end_inset

 by Newton's method.
 The iteration function 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset Formula 
\[
f(x)=\frac{1}{2}\left(x+\frac{q}{x}\right)\quad.
\]

\end_inset

We iterate 
\begin_inset Formula $f(x)$
\end_inset

 starting with 
\begin_inset Formula $x_{0}=q/2$
\end_inset

 until we obtain a given precision:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def approx_sqrt(x: Double, precision: Double): Double = {
\end_layout

\begin_layout Plain Layout

      def cond(y: Double): Boolean = math.abs(y * y - x) <= precision
\end_layout

\begin_layout Plain Layout

      def iterate_sqrt(y: Double): Double = 0.5 * (y + x / y)
\end_layout

\begin_layout Plain Layout

      converge(iterate_sqrt, x / 2, cond)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> approx_sqrt(25, 1.0e-8)
\end_layout

\begin_layout Plain Layout

res0: Double = 5.000000000016778
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, define a Scala function that takes an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returns a function that adds 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to 
\emph on
its
\emph default
 argument.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Let us first write down the required type signature: the function must take
 an integer argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Int
\end_layout

\end_inset

, and the return value must be a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add_x(x: Int): Int => Int = ???
\end_layout

\end_inset

We are required to return a function that adds 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to its argument.
 Let us call that argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

, to avoid confusion with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 So, we are required to return a function that we can write as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ z => z + x }
\end_layout

\end_inset

.
 Since functions are values, we can directly return a new function by writing
 a nameless function expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add_x(x: Int): Int => Int = { z => z + x }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To implement the same function via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, we first convert the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x
\end_layout

\end_inset

 to the equivalent type expression 
\begin_inset Formula $\text{Int}\Rightarrow\text{Int}\Rightarrow\text{Int}$
\end_inset

.
 Now we can write the Scala code of a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x_v
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val add_x_v: Int => Int => Int = { x => z => z + x }
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x_v
\end_layout

\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x
\end_layout

\end_inset

 except for using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 syntax instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

.
 It is not necessary to specify the type of the arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 because we already specified the type 
\begin_inset Formula $\text{Int}\Rightarrow\text{Int}\Rightarrow\text{Int}$
\end_inset

 for the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x_v
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, implement a curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

 that takes a function 
\begin_inset Formula $f$
\end_inset

 and an integer 
\begin_inset Formula $x$
\end_inset

, and returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 when 
\begin_inset Formula $f(x)$
\end_inset

 is a prime number.
 Use the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Nameless-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
First, we need to determine the required type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

.
 The value 
\begin_inset Formula $f(x)$
\end_inset

 must type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or else we cannot check whether it is prime.
 So, 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $\text{Int}\Rightarrow\text{Int}$
\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

 should be a curried function, we need to put each argument into its own
 set of parentheses:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prime_f(f: Int => Int)(x: Int): Boolean = ???
\end_layout

\end_inset

To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

, we need to return the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

 applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 A simple solution is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prime_f(f: Int => Int)(x: Int): Boolean = is_prime(f(x))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To implement the same function as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, rewrite its type signature as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = ???
\end_layout

\end_inset

(The parentheses around 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 are mandatory since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

 would be a completely different type.) The implementation is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = { f => x => is_prime(f(x))
 }
\end_layout

\end_inset

We also notice that the code is a forward composition of the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

is_prime
\end_layout

\end_inset

, so we can write it as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = (f => f andThen is_prime)
\end_layout

\end_inset

The function body is of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f => f.something
\end_layout

\end_inset

, which is equivalent to a shorter Scala syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_.something)
\end_layout

\end_inset

.
 So we can rewrite the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

 as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = (_ andThen is_prime)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice(x,p,f,g)
\end_layout

\end_inset

 that takes a value 
\begin_inset Formula $x$
\end_inset

, a predicate 
\begin_inset Formula $p$
\end_inset

, and two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 The return value must be 
\begin_inset Formula $f(x)$
\end_inset

 if 
\begin_inset Formula $p(x)$
\end_inset

 returns true; otherwise the return value must be 
\begin_inset Formula $g(x)$
\end_inset

.
 Infer the most general type for this function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The code of this function must be
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def choice[...](x,p,f,g) = if (p(x)) f(x) else g(x)
\end_layout

\end_inset

Now let us infer the most general type for this code.
 We begin by assuming that 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is a type parameter.
 Then the predicate 
\begin_inset Formula $p$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Boolean
\end_layout

\end_inset

.
 Since 
\begin_inset Formula $p$
\end_inset

 is an arbitrary predicate, the value 
\begin_inset Formula $p(x)$
\end_inset

 will be sometimes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and sometimes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice(x,p,f,g)
\end_layout

\end_inset

 will sometimes return 
\begin_inset Formula $f(x)$
\end_inset

 and sometimes 
\begin_inset Formula $g(x)$
\end_inset

.
 It follows that type 
\begin_inset Formula $A$
\end_inset

 must be the argument type of both 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

, which means that the most general types so far are 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:A\Rightarrow C}$
\end_inset

, yielding the type signature
\begin_inset Formula 
\[
\text{choice}(x^{:A},p^{:A\Rightarrow\text{Boolean}},f^{:A\Rightarrow B},g^{:A\Rightarrow C})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
What could be the return type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice(x,p,f,g)
\end_layout

\end_inset

? If 
\begin_inset Formula $p(x)$
\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 returns 
\begin_inset Formula $f(x)$
\end_inset

, which is of type 
\begin_inset Formula $B$
\end_inset

.
 Otherwise, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 returns 
\begin_inset Formula $g(x)$
\end_inset

, which is of type 
\begin_inset Formula $C$
\end_inset

.
 However, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 must be fixed in advance (at compile time) and cannot depend on the value
 
\begin_inset Formula $p(x)$
\end_inset

 computed at run time.
 So, the types of 
\begin_inset Formula $f(x)$
\end_inset

 and of 
\begin_inset Formula $g(x)$
\end_inset

 must be the same, 
\begin_inset Formula $B=C$
\end_inset

.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 will thus have only two type parameters, 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def choice[A, B](x: A, p: A => Boolean, f: A => B, g: A => B): B =
\end_layout

\begin_layout Plain Layout

  if (p(x)) f(x) else g(x)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer the most general type for the fully parametric function
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[...]: ...
 = { f => g => g(f) }
\end_layout

\end_inset

What types are inferred for the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by assuming 
\begin_inset Formula $f^{:A}$
\end_inset

 for an arbitrary type 
\begin_inset Formula $A$
\end_inset

.
 In the sub-expression 
\begin_inset Formula $g\Rightarrow g(f)$
\end_inset

, the curried argument 
\begin_inset Formula $g$
\end_inset

 must itself be a function, because it is being applied to 
\begin_inset Formula $f$
\end_inset

 as 
\begin_inset Formula $g(f)$
\end_inset

.
 So we assign types as 
\begin_inset Formula $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are some type parameters.
 Since there are no other constraints on the types, the parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 remain arbitrary, so we add them to the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To match types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

, we first assume arbitrary type parameters and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B](q[C, D])
\end_layout

\end_inset

.
 We need to introduce new type parameters 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

 because these type parameters will probably need to be set differently
 from 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 when we try to match the types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type of the first curried argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B]
\end_layout

\end_inset

, which is 
\begin_inset Formula $A$
\end_inset

, must match the entire type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[C, D]
\end_layout

\end_inset

, which is 
\begin_inset Formula $C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D$
\end_inset

.
 So we must set the type parameter 
\begin_inset Formula $A$
\end_inset

 as
\begin_inset Formula 
\[
A=C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\quad.
\]

\end_inset

The type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 becomes
\begin_inset Formula 
\begin{align*}
q^{A,B}(q^{C,D}) & :\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad,\\
\text{where}\quad & A=C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We use this result to infer the most general type for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

.
 We may denote 
\begin_inset Formula $r\triangleq q(q)$
\end_inset

 for brevity; then, as we just found, 
\begin_inset Formula $r$
\end_inset

 has type 
\begin_inset Formula $\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B$
\end_inset

.
 To infer types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(r)
\end_layout

\end_inset

, we introduce new type parameters 
\begin_inset Formula $E$
\end_inset

, 
\begin_inset Formula $F$
\end_inset

 and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[E, F](r)
\end_layout

\end_inset

.
 The type of the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[E, F]
\end_layout

\end_inset

 is 
\begin_inset Formula $E$
\end_inset

, and this must be the same as the type of 
\begin_inset Formula $r$
\end_inset

.
 This gives the constraint
\begin_inset Formula 
\[
E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\]

\end_inset

Other than that, the type parameters are arbitrary.
 The type of the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 is 
\begin_inset Formula $\left(E\Rightarrow F\right)\Rightarrow F$
\end_inset

.
 We conclude that the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 is
\begin_inset Formula 
\begin{align*}
q^{E,F}(q^{A,B}(q^{C,D})) & :\left(\left(\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\right)\Rightarrow F\right)\Rightarrow F\quad,\\
\text{where}\quad & A=C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\\
\text{and}\quad & E=\left(\left(C\Rightarrow\left(C\Rightarrow D\right)\Rightarrow D\right)\Rightarrow B\right)\Rightarrow B\quad.
\end{align*}

\end_inset

It is clear from this derivation that all expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q(q)))
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q(q(q))))
\end_layout

\end_inset

, etc., are well-typed.
\end_layout

\begin_layout Standard
Let us test these results in Scala, renaming the type parameters for clarity
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def qq[A, B, C]: ((A => (A => B) => B) => C) => C = q(q)
\end_layout

\begin_layout Plain Layout

qq: [A, B, C]=> ((A => ((A => B) => B)) => C) => C
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def qqq[A, B, C, D]: ((((A => (A => B) => B) => C) => C) => D) =>
 D = q(q(q))
\end_layout

\begin_layout Plain Layout

qqq: [A, B, C, D]=> ((((A => ((A => B) => B)) => C) => C) => D) => D
\end_layout

\end_inset

We did not need to write any type parameters within the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 because the full type signature was declared at the beginning of each of
 these expressions.
 Since the Scala compiler did not print any error messages, we are assured
 that the types match correctly.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-curried"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-curried"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types in the code expression
\begin_inset Formula 
\[
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow g\Rightarrow g(f)\right)\left(f\Rightarrow f(10)\right)\quad,
\]

\end_inset

and simplify the code.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The given expression is a curried function 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 applied to two curried arguments.
 The plan is to consider each of these sub-expressions in turn, assigning
 types for them using type parameters, and then to figure out how to set
 the type parameters so that all types match.
\end_layout

\begin_layout Standard
Begin by renaming the shadowed variables 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

, to remove shadowing:
\begin_inset Formula 
\begin{equation}
\left(f\Rightarrow g\Rightarrow g(f)\right)\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\quad.\label{eq:example-hof-curried-function-solved1}
\end{equation}

\end_inset

 As we have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the sub-expression 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 is typed as 
\begin_inset Formula $f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f)$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are some type parameters.
 The sub-expression 
\begin_inset Formula $x\Rightarrow y\Rightarrow y(x)$
\end_inset

 is the same function as 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 but with possibly different type parameters, say, 
\begin_inset Formula $x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x)$
\end_inset

.
 The types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

 are so far unknown.
\end_layout

\begin_layout Standard
Finally, the variable 
\begin_inset Formula $h$
\end_inset

 in the sub-expression 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

 must have type 
\begin_inset Formula $\text{Int}\Rightarrow E$
\end_inset

, where 
\begin_inset Formula $E$
\end_inset

 is another type parameter.
 So, the sub-expression 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

 is a function of type 
\begin_inset Formula $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$
\end_inset

.
\end_layout

\begin_layout Standard
The types must match in the entire expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{equation}
(f^{:A}\Rightarrow g^{:A\Rightarrow B}\Rightarrow g(f))(x^{:C}\Rightarrow y^{:C\Rightarrow D}\Rightarrow y(x))(h^{:\text{Int}\Rightarrow E}\Rightarrow h(10)\quad.\label{eq:example-hof-curried-function-solved2}
\end{equation}

\end_inset

It follows that 
\begin_inset Formula $f$
\end_inset

 must have the same type as 
\begin_inset Formula $x\Rightarrow y\Rightarrow y(x)$
\end_inset

, and 
\begin_inset Formula $g$
\end_inset

 must have the same type as 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

.
 The type of 
\begin_inset Formula $g$
\end_inset

, which we know as 
\begin_inset Formula $A\Rightarrow B$
\end_inset

, will match the type of 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

, which we know as 
\begin_inset Formula $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$
\end_inset

, only if 
\begin_inset Formula $A=\text{Int}\Rightarrow E$
\end_inset

 and 
\begin_inset Formula $B=E$
\end_inset

.
 It follows that 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\Rightarrow E$
\end_inset

.
 At the same time, the type of 
\begin_inset Formula $f$
\end_inset

 must match the type of 
\begin_inset Formula $x\Rightarrow y\Rightarrow y(x)$
\end_inset

, which is 
\begin_inset Formula $C\Rightarrow(C\Rightarrow D)\Rightarrow D$
\end_inset

.
 This can work only if 
\begin_inset Formula $C=\text{Int}$
\end_inset

 and 
\begin_inset Formula $E=(C\Rightarrow D)\Rightarrow D$
\end_inset

.
\end_layout

\begin_layout Standard
In this way, we have found all the relationships between the type parameters
 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The type 
\begin_inset Formula $D$
\end_inset

 remains undetermined (i.e.
\begin_inset space ~
\end_inset

arbitrary), while the type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

 are expressed as
\begin_inset Formula 
\begin{align}
A & =\text{Int}\Rightarrow\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved3}\\
B & =E=\left(\text{Int}\Rightarrow D\right)\Rightarrow D\quad,\label{eq:example-hof-curried-solved4}\\
C & =\text{Int}\quad.\nonumber 
\end{align}

\end_inset

The entire expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is a saturated application of a curried function, and thus has the same
 type as the 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 result expression 
\begin_inset Formula $g(f)$
\end_inset

, which has type 
\begin_inset Formula $B$
\end_inset

.
 So, the entire expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) has type 
\begin_inset Formula $B=\left(\text{Int}\Rightarrow D\right)\Rightarrow D$
\end_inset

.
\end_layout

\begin_layout Standard
Having established that types match, we can now omit the type annotations
 and rewrite the code expression as
\begin_inset Formula 
\begin{align*}
 & (f\Rightarrow g\Rightarrow\gunderline g(\gunderline f))\left(x\Rightarrow y\Rightarrow y(x)\right)\left(h\Rightarrow h(10)\right)\\
\text{substitute }f,g:\quad & =(h\Rightarrow\gunderline h(10))\left(x\Rightarrow y\Rightarrow y(x)\right)\\
\text{substitute }h:\quad & =(x\Rightarrow y\Rightarrow y(\gunderline x))(10)\\
\text{substitute }x:\quad & =y\Rightarrow y(10)\quad.
\end{align*}

\end_inset

The type of this expression is 
\begin_inset Formula $\left(\text{Int}\Rightarrow D\right)\Rightarrow D$
\end_inset

 with a type parameter 
\begin_inset Formula $D$
\end_inset

.
 Since the argument 
\begin_inset Formula $y$
\end_inset

 is an arbitrary function, we cannot simplify 
\begin_inset Formula $y(10)$
\end_inset

 or 
\begin_inset Formula $y\Rightarrow y(10)$
\end_inset

 any further.
 We conclude that 
\begin_inset Formula $y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)$
\end_inset

 is the final simplified form of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
To test this, we first define the function 
\begin_inset Formula $f\Rightarrow g\Rightarrow g(f)$
\end_inset

 as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end_layout

\end_inset

We also define the function 
\begin_inset Formula $h\Rightarrow h(10)$
\end_inset

 with a general type 
\begin_inset Formula $\left(\text{Int}\Rightarrow E\right)\Rightarrow E$
\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def r[E]: (Int => E) => E = { h => h(10) }
\end_layout

\end_inset

To help Scala evaluate Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to set the type parameters for the first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 function as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B]
\end_layout

\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are given by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-solved3"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-solved4"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def s[D] = q[Int => (Int => D) => D, (Int => D) => D](q)(r)
\end_layout

\begin_layout Plain Layout

s: [D]=> (Int => D) => D
\end_layout

\end_inset

To verify that the function 
\begin_inset Formula $s^{D}$
\end_inset

 indeed equals 
\begin_inset Formula $y^{:\text{Int}\Rightarrow D}\Rightarrow y(10)$
\end_inset

, we apply 
\begin_inset Formula $s^{D}$
\end_inset

 to some functions of type 
\begin_inset Formula $\text{Int}\Rightarrow D$
\end_inset

, say, for 
\begin_inset Formula $D=\text{Boolean}$
\end_inset

 or 
\begin_inset Formula $D=\text{Int}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> s(_ > 0) // Evaluate 10 > 0.
\end_layout

\begin_layout Plain Layout

res6: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s(_ + 20) // Evaluate 10 + 20.
\end_layout

\begin_layout Plain Layout

res7: Int = 30
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 as defined above, what are the types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(id)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(id)(id)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(id(id))
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(const)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(const)
\end_layout

\end_inset

? Simplify these expressions.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, infer the most general type for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice(twice)))
\end_layout

\end_inset

.
 What does that function do? Test your answer.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

thrice
\end_layout

\end_inset

 similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 except it should apply a given function 
\begin_inset Formula $3$
\end_inset

 times.
 What does the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

thrice(thrice(thrice)))
\end_layout

\end_inset

 do?
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ence
\end_layout

\end_inset

 similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 except it should apply a given function 
\begin_inset Formula $n$
\end_inset

 times, where 
\begin_inset Formula $n$
\end_inset

 is an additional curried argument.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flip(f)
\end_layout

\end_inset

 that swaps arguments for any given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of two arguments.
 To test: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int, y: Int) = x - y // Check that f(10, 2) == 8.
\end_layout

\begin_layout Plain Layout

val g = flip(f)  // Now check that g(2, 10) == 8.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Revise the function from Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

, implementing it a curried function and replacing the hard-coded number
 
\begin_inset Formula $100$
\end_inset

 by a 
\emph on
curried
\emph default
 first argument.
 The type signature should become 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => List[List[Int]] => List[List[Int]]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

converge
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a curried function, with an additional argument to set the maximum number
 of iterations, and returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Double]
\end_layout

\end_inset

 as the final result type.
 The new version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

converge
\end_layout

\end_inset

 should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 if the convergence condition is not satisfied after the given maximum number
 of iterations.
 The type signature and an example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def convergeN[X](p:X => Boolean)(x:X)(m:Int)(f:X => X): Option[X]
 = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> convergeN[Int](_ < 0)(0)(10)(_ + 1)
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> convergeN[Double]{ x => math.abs(x * x - 25) < 1e-8 }(1.0)(10) { x
 => 0.5 * (x + 25 / x ) }
\end_layout

\begin_layout Plain Layout

res1: Option[Double] = Some(5.000000000053722)
\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Solution:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def convergeN[X](p: X => Boolean)(x:X)(m:Int)(f: X => X): Option[X] =  {
\end_layout

\begin_layout Plain Layout

              if (m <= 0) None
\end_layout

\begin_layout Plain Layout

              else if (p(x)) Some(x) else converge(p)(f(x))(m-1)(f)    
         } // Defining as def convergeN[X]: (X => Boolean) => X => Int =>
 (X => X) => Option[X] = ??? will break tail recursion!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-8-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-8-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curry2
\end_layout

\end_inset

 converting an uncurried function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset


\family default
 into an equivalent curried function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Apply the function 
\begin_inset Formula $\left(x\Rightarrow\_\Rightarrow x\right)$
\end_inset

 to the value 
\begin_inset Formula $\left(z\Rightarrow z(q)\right)$
\end_inset

 where 
\begin_inset Formula $q$
\end_inset

 is a given value of type 
\begin_inset Formula $Q$
\end_inset

.
 Infer types in these expressions.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types in the following expressions:
\begin_inset Formula 
\begin{align*}
\text{(a):}\quad & p\Rightarrow q\Rightarrow p(t\Rightarrow t(q))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow x(p(q)))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following expressions cannot be well-typed:
\begin_inset Formula 
\begin{align*}
\text{(a):}\quad & p\Rightarrow p(q\Rightarrow q(p))\quad,\\
\text{(b):}\quad & p\Rightarrow q\Rightarrow q(x\Rightarrow p(q(x)))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types and simplify the following code expressions:
\begin_inset Formula 
\begin{align*}
\text{(a):}\quad & q\Rightarrow\left(x\Rightarrow y\Rightarrow z\Rightarrow x(z)(y(z))\right)\left(a\Rightarrow a\right)\left(b\Rightarrow b(q)\right)\quad,\\
\text{(b):}\quad & \left(f\Rightarrow g\Rightarrow h\Rightarrow f(g(h))\right)(x\Rightarrow x)\quad,\\
\text{(c):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow x\right)\quad,\\
\text{(d):}\quad & \left(x\Rightarrow y\Rightarrow x(y)\right)\left(x\Rightarrow y\Rightarrow y\right)\quad,\\
\text{(e):}\quad & x\Rightarrow\left(f\Rightarrow y\Rightarrow f(y)(x)\right)\left(z\Rightarrow\_\Rightarrow z\right)\quad,\\
\text{(f):}\quad & z\Rightarrow\left(x\Rightarrow y\Rightarrow x\right)\left(x\Rightarrow x(z)\right)(y\Rightarrow y(z))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Higher-order functions
\end_layout

\begin_layout Standard
The 
\series bold
order
\begin_inset Index idx
status open

\begin_layout Plain Layout
order of a function
\end_layout

\end_inset


\series default
 of a function is the number of function arrows (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

) contained in the type signature of that function.
 If a function's type signature contains more than one arrow, the function
 is called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
higher-order function
\end_layout

\end_inset

higher-order
\series default
 function.
 A higher-order function takes a function as argument and/or returns a function
 as its result value.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 are examples of higher-order functions that take other functions as arguments
 
\emph on
and
\emph default
 return a new function.
\end_layout

\begin_layout Standard
The following example illustrates the concept of a function's order.
 Consider 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1(x: Int): Int = x + 10
\end_layout

\end_inset

The function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset


\family default
 has type signature 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset


\family default
 and order 
\begin_inset Formula $1$
\end_inset

, so it is 
\emph on
not
\emph default
 a higher-order function.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2(x: Int): Int => Int = z => z + x
\end_layout

\end_inset

The function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset


\family default
 has type signature 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset


\family default
 and is a higher-order function of order 
\begin_inset Formula $2$
\end_inset

.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f3(g: Int => Int): Int = g(123)
\end_layout

\end_inset

The function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset


\family default
 has type signature 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => Int) => Int
\end_layout

\end_inset


\family default
 and is a higher-order function of order 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\begin_layout Standard
Although 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset


\family default
 is a higher-order function, its 
\begin_inset Quotes eld
\end_inset

higher-orderness
\begin_inset Quotes erd
\end_inset

 comes from the fact that the return value is of a function type.
 An equivalent computation can be performed by an uncurried function that
 is not higher-order:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def f2u(x: Int, z: Int): Int = z + x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 
\emph on
cannot
\emph default
 be converted to a non-higher-order function because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 has an argument of a function type.
 Converting to an uncurried form cannot eliminate an argument of a function
 type.
\end_layout

\begin_layout Subsection
Name shadowing and the scope of bound variables
\end_layout

\begin_layout Standard
Bound variables are introduced in nameless functions whenever an argument
 is defined.
 For example, in the curried nameless function 
\begin_inset Formula $x\Rightarrow y\Rightarrow f(x,y)$
\end_inset

, the bound variables are the curried arguments 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
 The variable 
\begin_inset Formula $y$
\end_inset

 is only defined within the scope 
\begin_inset Formula $\left(y\Rightarrow f(x,y)\right)$
\end_inset

 of the inner function; the variable 
\begin_inset Formula $x$
\end_inset

 is defined within the entire scope of 
\begin_inset Formula $x\Rightarrow y\Rightarrow f(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
Another way of introducing bound variables in Scala is to write a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 within curly braces:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x = {
\end_layout

\begin_layout Plain Layout

  val y = 10 // Bound variable.
\end_layout

\begin_layout Plain Layout

  y + y * y
\end_layout

\begin_layout Plain Layout

} // Same as `val x = 10 + 10 * 10`.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A bound variable is invisible outside the scope that defines it.
 This is why bound variables may be renamed at will: no outside code could
 possibly use them and depend on their values.
 However, outside code may define a variable that (by chance) has the same
 name as a bound variable inside the scope.
\end_layout

\begin_layout Standard
Consider this example from calculus: In the integral
\begin_inset Formula 
\[
f(x)=\int_{0}^{x}\frac{dx}{1+x}\quad,
\]

\end_inset

a bound variable named 
\begin_inset Formula $x$
\end_inset

 is defined in 
\emph on
two
\emph default
 local scopes: in the scope of 
\begin_inset Formula $f$
\end_inset

 and in the scope of the nameless function 
\begin_inset Formula $x\Rightarrow\frac{1}{1+x}$
\end_inset

.
 The convention in mathematics is to treat these two 
\begin_inset Formula $x$
\end_inset

's as two 
\emph on
completely
\emph default
 
\emph on
different
\emph default
 variables that just happen to have the same name.
 In sub-expressions where both of these bound variables are visible, priority
 is given to the bound variable defined in the closest inner scope.
 The outer definition of 
\begin_inset Formula $x$
\end_inset

 is 
\series bold
shadowed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
name shadowing
\end_layout

\end_inset

, i.e.
\begin_inset space \space{}
\end_inset

hidden, by the definition of the inner 
\begin_inset Formula $x$
\end_inset

.
 For this reason, mathematicians expect that evaluating 
\begin_inset Formula $f(10)$
\end_inset

 will give
\begin_inset Formula 
\[
f(10)=\int_{0}^{10}\frac{dx}{1+x}\quad,
\]

\end_inset

rather than 
\begin_inset Formula $\int_{0}^{10}\frac{dx}{1+10}$
\end_inset

, because the outer definition 
\begin_inset Formula $x=10$
\end_inset

 is shadowed within the expression 
\begin_inset Formula $\frac{1}{1+x}$
\end_inset

 by the closer definition of 
\begin_inset Formula $x$
\end_inset

 in the local scope of 
\begin_inset Formula $x\Rightarrow\frac{1}{1+x}$
\end_inset

.
\end_layout

\begin_layout Standard
Since this is the standard mathematical convention, the same convention
 is adopted in functional programming.
 A variable defined in a function scope (i.e.
\begin_inset space \space{}
\end_inset

a bound variable) is invisible outside that scope but will shadow any outside
 definitions of a variable with the same name.
\end_layout

\begin_layout Standard
Name shadowing
\begin_inset Index idx
status open

\begin_layout Plain Layout
name shadowing
\end_layout

\end_inset

 is not advisable, because it usually decreases the clarity of code and
 so invites errors.
 Consider the function
\begin_inset Formula 
\[
x\Rightarrow x\Rightarrow x\quad.
\]

\end_inset

Let us decipher this confusing syntax.
 The symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 groups to the right, so 
\begin_inset Formula $x\Rightarrow x\Rightarrow x$
\end_inset

 is the same as 
\begin_inset Formula $x\Rightarrow\left(x\Rightarrow x\right)$
\end_inset

.
 It is a function that takes 
\begin_inset Formula $x$
\end_inset

 and returns 
\begin_inset Formula $x\Rightarrow x$
\end_inset

.
 Since the nameless function 
\begin_inset Formula $\left(x\Rightarrow x\right)$
\end_inset

 may be renamed to 
\begin_inset Formula $\left(y\Rightarrow y\right)$
\end_inset

 without changing its value, we can rewrite the code to
\begin_inset Formula 
\[
x\Rightarrow\left(y\Rightarrow y\right)\quad.
\]

\end_inset

Having removed name shadowing, we can more easily understand this code and
 reason about it.
 For instance, it becomes clear that this function ignores its argument
 
\begin_inset Formula $x$
\end_inset

 and always returns the same value (the identity function 
\begin_inset Formula $y\Rightarrow y$
\end_inset

).
\end_layout

\begin_layout Subsection
Operator syntax for function applications
\end_layout

\begin_layout Standard
In mathematics, function applications are sometimes written without parentheses,
 for instance 
\begin_inset Formula $\cos x$
\end_inset

 or 
\begin_inset Formula $\sin z$
\end_inset

.
 There are also cases where formulas such as 
\begin_inset Formula $2\sin x\cos x$
\end_inset

 imply parentheses as 
\begin_inset Formula $2\cdot\sin\left(x\right)\cdot\cos\left(x\right)$
\end_inset

.
 Functions such as 
\begin_inset Formula $\cos x$
\end_inset

 are viewed as 
\begin_inset Quotes eld
\end_inset

operators
\begin_inset Quotes erd
\end_inset

 that are applied to their arguments without parentheses, similar to the
 operators of summation, 
\begin_inset Formula $\sum_{k}k$
\end_inset

, and differentiation, 
\begin_inset Formula $\partial_{x}f$
\end_inset

.
\end_layout

\begin_layout Standard
Many programming languages (such as ML, OCaml, F#, Haskell, Elm, PureScript)
 have adopted this 
\begin_inset Quotes eld
\end_inset

operator syntax
\begin_inset Index idx
status open

\begin_layout Plain Layout
operator syntax
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, making parentheses optional for function arguments.
 The result is a syntax where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f x
\end_layout

\end_inset

 means the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 Parentheses are still used where necessary to avoid ambiguity or for readabilit
y.
\begin_inset Foot
status open

\begin_layout Plain Layout
The operator syntax has a long history in programming.
 It is used in Unix shell commands, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cp file1 file2
\end_layout

\end_inset

.
 In LISP and Scheme, function applications are enclosed in parentheses but
 the arguments are separated by spaces, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f 10)
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The conventions for nameless functions in the operator syntax become:
\end_layout

\begin_layout Itemize
Function expressions group everything to the right,
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $x\Rightarrow y\Rightarrow z\Rightarrow e$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(z\Rightarrow e\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group everything to the left,
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $f\,x\,y\,z$
\end_inset

 means 
\begin_inset Formula $\big((f\,x)\:y\big)\:z$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group stronger than infix operations,
\begin_inset Newline newline
\end_inset

so 
\begin_inset Formula $x+f\,y$
\end_inset

 means 
\begin_inset Formula $x+(f\,y)$
\end_inset

, just as in mathematics 
\begin_inset Formula $x+\cos y$
\end_inset

 groups 
\begin_inset Formula $\cos y$
\end_inset

 stronger than the infix 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $+$
\end_inset


\begin_inset Quotes erd
\end_inset

 operation.
\end_layout

\begin_layout Standard
Thus, 
\begin_inset Formula $x\Rightarrow y\Rightarrow a\,b\,c+p\,q$
\end_inset

 means 
\begin_inset Formula $x\Rightarrow\left(y\Rightarrow\left(\left(a\,b\right)\,c\right)+(p\,q)\right)$
\end_inset

.
 When this notation becomes hard to read correctly, one needs to add parentheses
, e.g.
\begin_inset space \space{}
\end_inset

to write 
\begin_inset Formula $f(x\Rightarrow g\,h)$
\end_inset

 instead of 
\begin_inset Formula $f\,x\Rightarrow g\,h$
\end_inset

.
\end_layout

\begin_layout Standard
This book will avoid using the 
\begin_inset Quotes eld
\end_inset

operator syntax
\begin_inset Quotes erd
\end_inset

 when reasoning about code.
 Scala does not support the parentheses-free operator syntax; parentheses
 need to be put around every curried argument.
\end_layout

\begin_layout Standard
From the point of view of programming language theory, curried functions
 are 
\begin_inset Quotes eld
\end_inset

simpler
\begin_inset Quotes erd
\end_inset

 because they always have a 
\emph on
single
\emph default
 argument (and may return a function that will consume further arguments).
 From the point of view of programming practice, curried functions are often
 harder to read and to write.
\end_layout

\begin_layout Standard
In the operator syntax used e.g.
\begin_inset space \space{}
\end_inset

in OCaml and Haskell, a curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is applied to curried arguments as, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f 20 4
\end_layout

\end_inset

.
 This departs further from the mathematical tradition and requires some
 getting used to.
 If the two arguments are more complicated than just 
\begin_inset Formula $20$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

, the resulting expression may become harder to read, compared with the
 syntax where commas are used to separate the arguments.
 (Consider e.g.
\begin_inset space ~
\end_inset

the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f (g 10) (h 20) + 30
\end_layout

\end_inset

.) To improve readability of code, programmers may prefer to first define
 short names for complicated expressions and then use these names as curried
 arguments.
\end_layout

\begin_layout Standard
In Scala, the choice of whether to use curried or uncurried function signatures
 is largely a matter of syntactic convenience.
 Most Scala code tends to be written with uncurried functions, while curried
 functions are used when they produce more easily readable code.
\end_layout

\begin_layout Standard
One of the syntactic features for curried functions in Scala is the ability
 to specify a curried argument using the curly brace syntax.
 Compare the two definitions of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation
\end_layout

\end_inset

 described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Nameless-functions-in-mathematical-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def summation1(a: Int, b: Int, g: Int => Int): Int =
\end_layout

\begin_layout Plain Layout

  (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def summation2(a: Int, b: Int)(g: Int => Int): Int =
\end_layout

\begin_layout Plain Layout

  (a to b).map(g).sum
\end_layout

\end_inset

These functions are used in the code with a slightly different syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> summation1(1, 10, { x => x*x*x + 2*x })
\end_layout

\begin_layout Plain Layout

res0: Int = 3135
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> summation2(1, 10){ x => x*x*x + 2*x }
\end_layout

\begin_layout Plain Layout

res1: Int = 3135
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code that calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation2
\end_layout

\end_inset

 is easier to read because the curried argument is syntactically separated
 from the rest of the code by curly braces.
 This is especially useful when the curried argument is itself a function
 with a complicated body, since Scala's curly braces syntax allows function
 bodies to contain their own local definitions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Another feature of Scala is the 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax: for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs map f
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.map(f)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f.andThen(g)
\end_layout

\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 syntax is available only for infix methods, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map
\end_layout

\end_inset

, defined on specific types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

.
 In Scala 3, the 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 syntax will only work for methods having a special 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

@infix
\end_layout

\end_inset

 annotation.
 Do not confuse Scala's 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax with the operator syntax used in Haskell and some other languages.
\end_layout

\begin_layout Subsection
Deriving a function's code from its type signature
\begin_inset CommandInset label
LatexCommand label
name "subsec:Deriving-a-function's"

\end_inset


\end_layout

\begin_layout Standard
We have seen how the procedure of type inference
\begin_inset Index idx
status open

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

 derives the type of a fully parametric function from the function's code.
 A well-known algorithm for type inference is the Damas-Hindley-Milner algorithm
,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
\end_layout

\end_inset

 with a Scala implementation available.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is remarkable that one can sometimes derive the function's 
\emph on
code
\emph default
 from the function's type signature.
 We will now look at some examples of this.
\end_layout

\begin_layout Standard
Consider a fully parametric function that performs a partial application
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

 for arbitrary other functions.
 A possible type signature is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = ???
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

 will substitute a fixed argument value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 into another given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
How can we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

? Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa(x)(f)
\end_layout

\end_inset

 must return a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

, we have no choice other than to begin writing the function body as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y: B =>
\end_layout

\begin_layout Plain Layout

  ??? // Need to compute a value of type C in this scope.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inner scope, we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, and we have values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f:(A, B)=>C
\end_layout

\end_inset

.
 How can we compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

? If we knew that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C = Int
\end_layout

\end_inset

 when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa(x)(f)
\end_layout

\end_inset

 is applied, we could have simply selected a fixed integer value, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, as the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 If we knew that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C = String
\end_layout

\end_inset

, we could have selected a fixed string, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, as the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 But a fully parametric function cannot use any knowledge of the actual
 types used in the code when that function is being applied to arguments.
\end_layout

\begin_layout Standard
So, a fully parametric function cannot produce a value of an arbitrary type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 from scratch.
 The only way of producing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is by applying the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to arguments of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Since the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary, we cannot obtain any values of these types other than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:B
\end_layout

\end_inset

.
 So, the only way of obtaining a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x, y)
\end_layout

\end_inset

.
 Thus, the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

 must be
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y => f(x, y) }
\end_layout

\end_inset

In this way, we have 
\emph on
unambiguously
\emph default
 derived the body of this function from its type signature, by assuming
 that the function must be fully parametric.
\end_layout

\begin_layout Standard
Another example is the operation of forward composition 
\begin_inset Formula $f\bef g$
\end_inset

, viewed as a fully parametric function with type signature
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = ???
\end_layout

\end_inset

To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

, we need to create a nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { x: A =>
\end_layout

\begin_layout Plain Layout

  ??? // Need to compute a value of type C in this scope.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inner scope, we need to compute a value of type 
\begin_inset Formula $C$
\end_inset

, and we have the values 
\begin_inset Formula $x^{:A}$
\end_inset

, 
\begin_inset Formula $f^{:A\Rightarrow B}$
\end_inset

, and 
\begin_inset Formula $g^{:B\Rightarrow C}$
\end_inset

.
 Since the type 
\begin_inset Formula $C$
\end_inset

 is arbitrary, the only way of obtaining a value of type 
\begin_inset Formula $C$
\end_inset

 is to apply 
\begin_inset Formula $g$
\end_inset

 to an argument of type 
\begin_inset Formula $B$
\end_inset

.
 The only way of obtaining a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f$
\end_inset

 to an argument of type 
\begin_inset Formula $A$
\end_inset

.
 Finally, we have only one value of type 
\begin_inset Formula $A$
\end_inset

, namely 
\begin_inset Formula $x^{:A}$
\end_inset

.
 So, the only way of obtaining the required result is to compute 
\begin_inset Formula $g(f(x))$
\end_inset

.
 We have again unambiguously derived the body of the function before from
 its type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { x => g(f(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:3-3-The-formal-logic-curry-howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:The-Curry-Howard-correspondence"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we will see how a function's code can be derived from type signatures
 for a wide range of fully parametric functions.
\end_layout

\end_body
\end_document
