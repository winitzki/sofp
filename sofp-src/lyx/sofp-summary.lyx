#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset


\end_layout

\begin_layout Chapter
Summary of the book
\begin_inset CommandInset label
LatexCommand label
name "chap:Summary-of-the"

\end_inset


\end_layout

\begin_layout Standard
The book has been written in a tutorial format, motivating and deriving
 the results gradually.
 This makes it easier to learn but harder to navigate.
 In this summary chapter, the results are listed without detailed explanations
 or proofs, referring to the places of the book where more detail is found.
\end_layout

\begin_layout Section
Main ideas and results by chapter
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{secnumdepth}{1}
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
All the following subsections will appear in the TOC but will be unnumbered.
 The koma-script package does not have addsubsec.
 Another solution could be: 
\end_layout

\begin_layout Plain Layout
% Package 'hyperref' needed for command '
\backslash
nameref'
\end_layout

\begin_layout Plain Layout

\backslash
subsection*{Introduction} 
\end_layout

\begin_layout Plain Layout

\backslash
label{subsec:intro} 
\end_layout

\begin_layout Plain Layout

\backslash
addcontentsline{toc}{subsection}{
\backslash
nameref{subsec:intro}}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:1-Values,-types,-expressions,"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Standard mathematical notation such as 
\begin_inset Formula $\sum_{n=1}^{100}(n^{2}+n)$
\end_inset

 implicitly uses nameless functions.
 Functional programming improves upon this kind of mathematical notation
 by using nameless functions explicitly and consistently.
 For example, the computation 
\begin_inset Formula $\sum_{n=1}^{100}(n^{2}+n)$
\end_inset

 is implemented in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to 100).map(n => n * n + n).sum
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

product
\end_layout

\end_inset

 are examples of 
\begin_inset Quotes eld
\end_inset

aggregations
\begin_inset Quotes erd
\end_inset

 (functions that convert a collection of data items to a single value).
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 selects some elements from a sequence; 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 truncates a sequence once a certain condition is achieved.
 Those methods are examples of 
\begin_inset Quotes eld
\end_inset

transformations
\begin_inset Quotes erd
\end_inset

 (functions that convert a collection to another collection).
\end_layout

\begin_layout Standard
Functional programming means formulating the solution of a problem as a
 mathematical expression and then translating the mathematical formula into
 code.
 Mathematical formulas never use loops or modify variables.
 Iteration is expressed using special operators such as 
\begin_inset Formula $\sum$
\end_inset

.
 Functional programming encodes transformations and aggregations via standard
 library functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, etc., instead of loops.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Scala's tuple types represent several values, each with its own fixed type.
 Tuples support pattern-matching and are used often in the standard library
 when manipulating collections.
 In particular, the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

 use tuples when working with dictionaries (denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map
\end_layout

\end_inset

 in Scala).
\end_layout

\begin_layout Standard
Because of strict type checking at each stage, it is safe to work with collectio
ns via chains of those methods.
\end_layout

\begin_layout Standard
There are three sorts of tasks for working with collections: aggregation
 (converting a sequence to a single value), generation (converting a single
 value to a sequence), and transformation (converting a sequence to another
 sequence).
 Aggregation is typically performed with 
\begin_inset Quotes eld
\end_inset

reduce-like
\begin_inset Quotes erd
\end_inset

 functions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldRight
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, etc.) Generating a new sequence often involves computing each next element
 on demand, which can be done with iterators or streams.
 Transformation is performed with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scan
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If instead one wants to define a custom recursive function for working with
 sequences, one should take care to use tail recursion when appropriate.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Disjunctive-types"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
We begin by defining two basic building blocks for constructing new types:
 case classes and disjunctive types.
 Case classes can be viewed as tuples with names.
 Disjunctive types can be viewed as the familiar 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

 type enriched with arbitrary typed data for each alternative.
 In Scala, disjunctive types (also known as tagged unions, sum types, and
 co-product types) are typically implemented via 
\begin_inset Quotes eld
\end_inset

sealed traits
\begin_inset Quotes erd
\end_inset

 and case classes.
\end_layout

\begin_layout Standard
Both case classes and disjunctive types support pattern matching and recursive
 definitions.
 In addition to the standard disjunctive types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

), the user may define custom types via arbitrary combinations of case classes
 and disjunctive types.
 This gives rise to a rich type system where the programmer can define data
 types flexible enough to describe many real-world domains, assuring safe
 treatment of corner cases.
 Examples of such types are various list-like and tree-like data types.
 Functions for working with those types are often recursive, just as the
 types themselves are.
\end_layout

\begin_layout Standard
Compiler support for disjunctive types and pattern matching is absent in
 most programming languages except for languages designed with functional
 programming in mind.
 Disjunctive types give the programmer an important degree of flexibility
 in terms of the 
\begin_inset Quotes eld
\end_inset

logic of types
\begin_inset Quotes erd
\end_inset

.
 When a programming language supports both product and co-product types
 (which correspond to logical conjunctions and logical disjunctions), the
 programmer can directly model problem domains where certain data may be
 present, absent, or have a different type depending on circumstances.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Higher-order-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Higher-order functions take function parameters and/or return new functions.
 It takes some time to get used to working with higher-order functions,
 so we begin with the easier example: curried functions.
 The syntax for calling those functions in Scala looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)(y)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
A special sort of functions, called 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset

, will play an important role throughout this book.
 We show an example illustrating what kind of functions can be converted
 to fully parametric ones.
 
\end_layout

\begin_layout Standard
To visualize how functions are evaluated, we show several examples of 
\begin_inset Quotes eld
\end_inset

symbolic calculation
\begin_inset Quotes erd
\end_inset

: simulating program evaluation by hand.
 This is an important exercise for understanding and gaining facility with
 functional programming.
 One application of symbolic calculation is to prove properties of functions.
 As a first example, we show proofs for the identity law and the associativity
 law of function composition.
 
\end_layout

\begin_layout Standard
A useful skill for a functional programmer is to be able to derive the type
 of a function from its code.
 The Scala compiler has an algorithm for type inference, which sometimes
 needs help from the programmer.
 It is notable that, for some fully parametric functions, it is also possible
 to perform 
\begin_inset Quotes eld
\end_inset

code inference
\begin_inset Quotes erd
\end_inset

, that is, to derive a function's code from a given type signature.
 We show some examples of type inference and code inference.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:5-Curry-Howard"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Curry-Howard correspondence is between types 
\begin_inset Formula $T$
\end_inset

 and logical propositions (statements) of the form 
\begin_inset Quotes eld
\end_inset

fully parametric code can compute a value of type 
\begin_inset Formula $T$
\end_inset

 in a given program scope
\begin_inset Quotes erd
\end_inset

.
 Propositions of that form are called 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\end_layout

\begin_layout Standard
From the point of view of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions, type constructions correspond to logical operations.
 Case classes (product types) correspond to logical conjunctions, disjunctive
 types (also known as sum types and co-product types) correspond to logical
 disjunctions, and function types correspond to logical implications.
 This chapter starts developing special short notation for types and for
 code that allows us to reason about type expressions and code expressions
 more easily.
\end_layout

\begin_layout Standard
A proof of a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 corresponds to some code that computes a value of type 
\begin_inset Formula $T$
\end_inset

.
 We show how code can be extracted mechanically (that is, algorithmically)
 from a logical proof tree.
 Then we explain the LJT algorithm for automatic proof search.
 The LJT algorithm together with the technique of extracting code from the
 proof enables us to derive fully parametric code from a large class of
 type signatures.
\end_layout

\begin_layout Standard
Logical equivalence is not the same as type equivalence in the sense that
 programmers would expect (that is, the situation when two types carry equivalen
t information).
 We show how to recognize equivalent types in a number of simple cases,
 and derive some general rules for type equivalence (see Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

â€“
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the examples following).
\end_layout

\begin_layout Standard
The Curry-Howard correspondence clarifies the usefulness for specific type
 constructions in a programming language and gives guidance for language
 design in terms of formal logic.
 It is notable that the logic required for the CH correspondence is not
 the familiar (
\begin_inset Quotes eld
\end_inset

classical
\begin_inset Quotes erd
\end_inset

) Boolean logic but a slightly different logic, known as 
\begin_inset Quotes eld
\end_inset

intuitionistic
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

.
 We show some examples to illustrate the difference between those logics.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
This chapter begins the second part of the book, which is devoted to a systemati
c analysis of various type constructions that produce data structures with
 certain useful properties.
 The first kind of data structure to be analysed is 
\begin_inset Quotes eld
\end_inset

functors
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
We begin with a motivation for functors as containers or 
\begin_inset Quotes eld
\end_inset

wrappers
\begin_inset Quotes erd
\end_inset

 of data; a first example is a sequence type such as Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

.
 A typical operation for sequences is a loop over elements of the sequence.
 In functional programming, those loops are implemented by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method.
 Generalizing from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 to an arbitrary container 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

, we find that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method that 
\begin_inset Quotes eld
\end_inset

lifts
\begin_inset Quotes erd
\end_inset

 functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

 into functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] => F[B]
\end_layout

\end_inset

.
 We examine a programmer's expectations for the behavior of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for typical containers.
 Those expectations are formulated as mathematical equations (or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

) that an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 must obey.
 In this way, we arrive at the 
\begin_inset Quotes eld
\end_inset

functor laws
\begin_inset Quotes erd
\end_inset

: the identity law and the composition law.
\end_layout

\begin_layout Standard
Scala supports a special 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 syntax for chains of functor operations.
 (In later chapters, we will see how the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 syntax can also support conditionals and nested loops.)
\end_layout

\begin_layout Standard
Looking at examples of some type constructors that 
\emph on
cannot
\emph default
 have the map method, we find that in certain cases a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 method can be implemented.
 This motivates the concept of a 
\series bold
contrafunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

 (short for 
\begin_inset Quotes eld
\end_inset

contravariant functor
\begin_inset Quotes erd
\end_inset

).
 We show examples where we implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 method for different type constructors.
\end_layout

\begin_layout Standard
We introduce a condensed notation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method, because it is used very often in proofs.
 In that notation, the functor laws are written especially concisely, as
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:functor-laws-in-short-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows.
\end_layout

\begin_layout Standard
Type constructors with two type parameters may be functors (or contrafunctors)
 with respect to each type parameter separately.
 Bifunctors are functors with respect to both type parameters.
 We briefly explain their properties.
\end_layout

\begin_layout Standard
Then we systematically go through all six standard type constructions: fixed
 types, type parameters, product types, co-product types, function types,
 and recursive types.
 In each case, we prove that new functors (and contrafunctors) can be obtained
 from previously given ones.
 
\end_layout

\begin_layout Standard
It follows that in every type expression, each type parameter can be marked
 as being in a covariant or in a contravariant position.
 This allows us to learn to recognize covariance and contravariance quickly.
 The corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 methods may be implemented through a mechanical procedure.
\end_layout

\begin_layout Standard
The existence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 methods has a direct connection to subtyping.
 We use a simple definition of subtyping via type conversion functions,
 and show that covariant and contravariant functors naturally give rise
 to subtyping relations.
 It is curious that a type conversion function (from a subtype to a parent
 type) may be injective, surjective, or neither.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 is a subtype of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

, it does 
\emph on
not
\emph default
 mean that values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 are a subset or a superset of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

.
 We also prove that injective or surjective functions remain injective or
 surjective after lifting to a functor.
 
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Reasoning-about-code"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
This book uses certain non-standard notations to write types and code more
 concisely.
 For instance, type parameters are written as superscripts (
\begin_inset Formula $F^{A}$
\end_inset

 corresponds to the Scala syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

).
 Functions lifted via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 are denoted by arrows such as 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

.
 Matrices are used for functions working with co-product types.
 This notation has its advantages but requires getting used to.
\end_layout

\begin_layout Standard
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Reasoning-about-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

 begins with a systematic overview of the code notation, starting with the
 nine standard code constructions and then going over the function composition,
 the pipe notation, and the lifting notation.
 
\end_layout

\begin_layout Standard
The main advantage of the code notation is in making proofs shorter and
 easier to figure out.
 To build up intuition and experience with symbolic derivations, we show
 how to prove some laws for functions working with product and co-product
 types.
 We also explain some techniques for proving laws involving arbitrary unknown
 functions.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Typeclasses-and-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The concept of 
\begin_inset Quotes eld
\end_inset

typeclass
\begin_inset Quotes erd
\end_inset

 is motivated as a mechanism for constraining type parameters in generic
 functions.
 We show how a typeclass can be implemented by passing evidence values in
 extra arguments.
 We show how to define functions whose type parameters are constrained to
 belong to specific typeclasses.
 While the function body is able to use the typeclass methods, the types
 remain arbitrary and unspecified.
\end_layout

\begin_layout Standard
The verbosity of this implementation is reduced if one employs Scala's 
\begin_inset Quotes eld
\end_inset

implicit argument
\begin_inset Quotes erd
\end_inset

 feature.
 Another Scala feature is the 
\begin_inset Quotes eld
\end_inset

extension method
\begin_inset Quotes erd
\end_inset

 syntax that allows one to write code as if a new method can be added to
 an existing type at any time.
 We show that, depending on the method's type signature, some typeclass
 methods can be used as extension methods while others cannot.
\end_layout

\begin_layout Standard
In Scala, typeclasses can be declared for type constructors as well as for
 ordinary types.
 We show different ways of implementing such typeclasses.
\end_layout

\begin_layout Standard
We show some examples of simple typeclasses (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Examples-of-simple-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For each typeclass, we perform structural analysis and determine which
 type constructions may create new typeclass members from previous ones.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Typeclass name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Evidence type for 
\begin_inset Formula $T$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Summary of structural analysis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Extractor
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T\rightarrow Z$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-Extractor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eq
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T\times T\rightarrow\bbnum 2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-Eq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T\times T\rightarrow T$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-semigroup"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(T\times T\rightarrow T)\times T$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Pointed
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\forall A.\,A\rightarrow T^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-pointed-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Copointed
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\forall A.\,T^{A}\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-copointed-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Pointed contrafunctor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\forall A.\,T^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Type-constructions-for-pointed-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Examples-of-simple-typeclasses"

\end_inset

Examples of simple typeclasses from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Typeclass-derivation-via-structural-analysis"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Solved examples and exercises are given to practice defining typeclasses
 and various generic functions with typeclass constraints.
\end_layout

\begin_layout Standard
To develop a deeper understanding of typeclasses, we discuss various topics:
 
\end_layout

\begin_layout Itemize
How to determine when a recursive type has nontrivial values
\end_layout

\begin_layout Itemize
How to prove associativity of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 operation for sequences
\end_layout

\begin_layout Itemize
What are higher-order type functions, and what are 
\begin_inset Quotes eld
\end_inset

kinds
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
How to define and use typeclasses with several type parameters (
\begin_inset Quotes eld
\end_inset

type relations
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
Inheritance and automatic conversion of typeclasses
\end_layout

\begin_layout Itemize
Why many typeclasses have similar properties as regards typeclass derivation;
 the concept of 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $P$
\end_inset

-typeclasses
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
How typeclasses unify and generalize both algebraic data types and object-orient
ed interfaces
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Filterable-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Filterable functors have just one more method (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

) in addition to ordinary functors having 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 We begin by looking at practical examples of using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation.
 The standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method for sequences removes all values that do not satisfy a given condition.
 However, we can imagine different definitions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 where data items are removed in other ways.
 To figure out what qualifies as a filtering operation, we look at some
 examples and codify a programmer's expectations about how filtering should
 work.
 This allows us to derive four laws that a filter function must satisfy.
 To aid intution, we also examine a few examples of functors that 
\begin_inset Quotes eld
\end_inset

are not filterable
\begin_inset Quotes erd
\end_inset

 (do not support a lawful filtering operation).
\end_layout

\begin_layout Standard
The four laws of filter are not easy to verify, so the next step is to simplify
 those laws.
 We introduce new functions called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and prove rigorously that their logic is equivalent to the logic of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
 However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 has only three laws and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 only two.
 
\end_layout

\begin_layout Standard
Here for the first time this book embarks on rigorous proofs of laws, so
 the derivations are performed step by step and written out in full detail.
 To help the reader get used to the mathematical notation, some derivations
 are duplicated in Scala syntax as well.
\end_layout

\begin_layout Standard
Armed with a concise formulation of the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, we proceed to a structural analysis for filterable functors.
 We attempt to discover all possible type constructions that produce new
 filterable functors out of previously given ones.
\end_layout

\begin_layout Standard
In particular, we prove that the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor admits 
\emph on
two
\emph default
 lawful implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

: one corresponding to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and one corresponding to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

greedy
\begin_inset Quotes erd
\end_inset

 filtering logic of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 can be straightforwardly generalized to many recursive functors.
\end_layout

\begin_layout Standard
Structural analysis turns out to require considering filterable 
\emph on
contrafunctors
\emph default
 as well.
 Filterable functors remove data items that fail a given predicate; filterable
 contrafunctors avoid consuming such input items.
 We give some motivation and code examples for the usage of filterable contrafun
ctors.
 The results of structural analysis for filterable functors and contrafunctors
 are shown in Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Constructions-of-filterable-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

â€“
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Constructions-of-filterable-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Further discussions explore some of this chapter's topics in more depth:
\end_layout

\begin_layout Itemize
We give an explanation for 
\begin_inset Quotes eld
\end_inset

naturality laws
\begin_inset Quotes erd
\end_inset

 and a summary of various recipes for writing them.
\end_layout

\begin_layout Itemize
By examining the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

, we arrive at the concept of 
\begin_inset Quotes eld
\end_inset

Kleisli functions
\begin_inset Quotes erd
\end_inset

 and a motivation for generalizing filterable functors to 
\begin_inset Formula $M$
\end_inset

-filterable functors (where 
\begin_inset Formula $M$
\end_inset

 is any monad).
 
\end_layout

\begin_layout Itemize
We notice the similarity between the laws of several typeclasses and the
 standard functor laws, which invites us to take a first glance at category
 theory that provides a more general definition of a functor.
 We show that the laws of typeclasses can be derived from the laws of categories
 and of categorical functors.
 This gives us assurance that the typeclass laws are chosen in a consistent
 and useful way.
 We finish with a summary of issues for which category theory has been either
 helpful or not helpful in the context of functional programming.
\end_layout

\begin_layout Standard
This chapter studies filterable functors by following a pattern that all
 further chapters in Part
\begin_inset space ~
\end_inset

II also follow.
 Beginning with working Scala code involving some operation, we formulate
 a typeclass whose member types support that operation.
 Then we motivate a programmer's expectations about that operation's behavior,
 and derive the corresponding mathematical laws.
 To make the reasoning easier, we simplify those laws by introducing other,
 equivalent operations that have simpler laws.
 We proceed to structural analysis and discover what type constructions
 can support the given operation and its laws.
 As a result, we obtain many examples of types that belong to the typeclass
 (as well as examples of types that do not).
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Semimonads-and-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Semi-monads
\begin_inset Quotes erd
\end_inset

 are introduced as functors that support a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method.
 This is motivated by considering how functional programming can represent
 nested loops.
 Simple loops are translated into an application of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function to sequences; similarly, nested loops are translated into applications
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 functions.
 
\end_layout

\begin_layout Standard
Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 syntax (which is itself modeled on a mathematical notation) is equivalent
 to nested 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 calls.
 We give examples for using these functions (either directly or via the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 syntax) for implementing various iterative computations with sequences
 and other 
\begin_inset Quotes eld
\end_inset

list-like
\begin_inset Quotes erd
\end_inset

 monads such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Computations with sequences and other list-like types is the first step
 towards generalizing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 functions to other data structures.
 The next step is to consider 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 types (the 
\begin_inset Quotes eld
\end_inset

pass/fail
\begin_inset Quotes erd
\end_inset

 monads).
 Computations with those types are also expressible via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 calls, and can benefit from using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 syntax.
\end_layout

\begin_layout Standard
We then turn to tree-like monads and show how computations with binary trees
 and abstract syntax trees are naturally expressed via a special implementation
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Further generalization is motivated by the idea of viewing functions of
 type 
\begin_inset Formula $A\rightarrow L^{B}$
\end_inset

 a 
\begin_inset Quotes eld
\end_inset

computation with an 
\begin_inset Formula $L$
\end_inset

-effect
\begin_inset Quotes erd
\end_inset

.
 By that we mean not a side effect, but any extra computational work that
 is done in a function of type 
\begin_inset Formula $A\rightarrow L^{B}$
\end_inset

 other than computing a result value of type 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
With this picture in mind, we are able to derive the monad types that represent
 certain special computational situations: computing a value while reading
 another given value (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad); computing a value while writing out another value (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad); computing a value while updating another value (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad); and computing a value but passing it to a given callback function
 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

, the continuation monad).
 Finally, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

 monad represents the possibilities of computing a result eagerly or lazily.
 We look at code examples to illustrate the practical use of all those well-know
n monads.
 
\end_layout

\begin_layout Standard
Next, we consider the laws that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 operation should obey.
 To derive those laws, we look at several code patterns that a programmer
 would intuitively expect to behave in certain ways.
 Each of those code patterns gives rise to a specific law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 In this way, we derive an associativity law and two naturality laws for
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 Analogous laws for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operation were derived in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we defined functors as type constructors with a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method.
 Functors with a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method are 
\series bold
semi-monads
\series default
.
 In this way, we find that the functor type involved in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 block (in this book, we call them 
\series bold
functor blocks
\series default
) must be in general a semi-monad.
\end_layout

\begin_layout Standard
The three laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 are equivalent to just two laws if we pass to a simpler function known
 in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

.
 We derive the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 and prove that they are equivalent to the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 A formal proof of type equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-flatten-equivalent-to-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) requires assuming one naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We show how to verify the associativity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monads.
 
\end_layout

\begin_layout Standard
Almost all semi-monads we considered are in fact 
\begin_inset Quotes eld
\end_inset

full monads
\begin_inset Quotes erd
\end_inset

, as they support an additional operation called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

.
 We motivate this operation by considering an 
\begin_inset Quotes eld
\end_inset

empty effect
\begin_inset Quotes erd
\end_inset

; for instance, an iteration over a list of length 
\begin_inset Formula $1$
\end_inset

.
 Then we derive the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 by looking at how we expect functor block code to behave when using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

.
 The laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 have a simpler form when written using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 As we derive those simpler forms, we introduce Kleisli functions (of type
 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

) and the Kleisli composition operation (
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

) for a given monad 
\begin_inset Formula $M$
\end_inset

.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monad-laws-in-Kleisli"
plural "false"
caps "false"
noprefix "false"

\end_inset

 derives the laws of the Kleisli composition operation from the laws of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 and also proves a full formal equivalence between the formulations of the
 monad operations and laws via Kleisli functions and via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Formulating monads via Kleisli functions has certain advantages when verifying
 laws of monads involving function types.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Verifying-the-monad-via-Kleisli-trick"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how the 
\begin_inset Quotes eld
\end_inset

flipped / curried Kleisli
\begin_inset Quotes erd
\end_inset

 trick makes the proofs of monad laws shorter and clearer for the continuation
 monad and the state monad.
\end_layout

\begin_layout Standard
We pass on to structural analysis of semi-monads and monads.
 The resulting type constructions are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Constructions-of-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Some constructions only give semi-monads, but most create full monads.
\end_layout

\begin_layout Standard
The chapter concludes by some further theoretical developments:
\end_layout

\begin_layout Itemize
Monads must be functors: it is impossible to define nontrivial monads that
 are contrafunctors.
\end_layout

\begin_layout Itemize
In this and the previous chapters, we proved the  type isomorphisms between
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wu
\end_layout

\end_inset

 (for pointed functors), between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftOpt
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 (for filterable functors), and between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 (for semi-monads).
 It turns out that all those isomorphisms are special cases of more general
 type isomorphisms, known as the Yoneda identities.
\end_layout

\begin_layout Itemize
For monads that are not containers, a 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 is needed to extract result values.
 It turns out that 
\begin_inset Quotes eld
\end_inset

runners
\begin_inset Quotes erd
\end_inset

 are functions that need to satisfy certain laws, known as the laws of 
\begin_inset Quotes eld
\end_inset

monad morphisms
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Monad morphisms and their laws are known in category theory; they are the
 morphisms in the category of monads.
 Monad morphisms are natural transformations between monads that map one
 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 operations onto the same operations of another monad.
 We show some examples to build up intuition about monad morphisms.
\end_layout

\begin_layout Itemize
Each monad gives rise to a category we denote by 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $M$
\end_inset

-Kleisli
\begin_inset Quotes erd
\end_inset

; morphisms in that category are Kleisli functions.
\end_layout

\begin_layout Itemize
Polynomial functors are sometimes monads (but sometimes not; one example
 is 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A\times...\times A$
\end_inset

).
 We list the known type constructions that build up polynomial monads.
\end_layout

\begin_layout Itemize
One of the monad constructions involves the notion of an 
\begin_inset Formula $M$
\end_inset

-filterable contrafunctor.
 They can be motivated as generalizations of filterable contrafunctors when
 we replace the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 monad in the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 by an arbitrary monad 
\begin_inset Formula $M$
\end_inset

.
 We show formal definitions of 
\begin_inset Formula $M$
\end_inset

-filterable functors and contrafunctors, and briefly explore their structural
 analysis.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
We begin by looking at the familiar 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 operation for sequences (which are functors).
 It turns out that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 can be generalized to work with many other types.
 Type constructors that support a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method satisfying suitable laws are called 
\begin_inset Quotes eld
\end_inset

applicative
\begin_inset Quotes erd
\end_inset

.
 This chapter will develop a rigorous description of applicative functors,
 contrafunctors, and profunctors.
 
\end_layout

\begin_layout Standard
We begin with examples of practical use of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method, showing how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 can be used to combine polynomial data types, binary trees, and even some
 non-covariant type constructors.
 Other uses of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 include gathering multiple errors while validating data; performing multiple
 computations in parallel; and transposing matrices.
 We arrive at an intuition that applicative functors express combination
 of effects that are independent of previously computed values.
 For that reason, effects can be sometimes evaluated and combined in parallel.
 The condition for that is called 
\begin_inset Quotes eld
\end_inset

commutativity
\begin_inset Quotes erd
\end_inset

 of applicative functors.
 This property will be formally defined and studied later in this chapter.
\end_layout

\begin_layout Standard
Another practically useful function is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

.
 We show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

 can be expressed via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and that analogous methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map3
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map4
\end_layout

\end_inset

, etc., may be defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip3
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip4
\end_layout

\end_inset

, etc.
 We can avoid having to implement all those functions via boilerplate code
 if we instead implement a method known as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ap
\end_layout

\end_inset

.
 However, this trick works only for covariant functors.
 Non-covariant functors must define methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap3
\end_layout

\end_inset

, etc., separately.
\end_layout

\begin_layout Standard
We show further use cases for applicative functors: the applicative 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 functor; 
\begin_inset Quotes eld
\end_inset

fusion
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

-like operations into single traversals; and parsing via parsing combinators.
 To build up intuition, we show code that contrasts the applicative and
 the monadic approaches to fold fusion and to parsing combinators.
\end_layout

\begin_layout Standard
Applicative operations may be used in functor blocks as explicit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 operations.
 Scala does not have a widely accepted special syntax for applicative functor
 blocks, although some experimental proposals exist (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Functor-block-syntax-for-applicative"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
We turn to the derivation of the laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

.
 First, we show that the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 are equivalent as types if we assume suitable naturality laws.
 We prefer to define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Zippable
\end_layout

\end_inset

 typeclass via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method, for the reason that the same typeclass will be usable with non-covarian
t functors.
\end_layout

\begin_layout Standard
The laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

 follow from the monad laws if we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

 through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 Of course, applicative functors do not necessary have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

; but this derivation allows us to motivate a reasonable set of laws for
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

.
 These are the associativity law and the two identity laws.
 We then derive the corresponding laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We formally define the property of commutativity for applicative functors
 and show how it simplifies the other laws.
 Most applicative functors used in practice are commutative and are suitable
 for parallel evaluation.
 
\end_layout

\begin_layout Standard
Having derived the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, the next step is to perform structural analysis and to discover type construct
ions that create new applicative type constructors.
 The results for applicative functors are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Constructions-of-applicative-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

, for applicative contrafunctors in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Constructions-of-applicative-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and for applicative profunctors in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Constructions-of-applicative-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Usually, there will be several inequivalent but lawful implementations for
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method; so, the applicative typeclass instances are not unique.
 Another consequence of structural analysis is that all exponential-polynomial
 
\emph on
contravariant
\emph default
 functors are applicative.
 It is perhaps surprizing that a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method can be defined for a wide range of profunctors that are neither
 covariant nor contravariant.
 One practical use case for this property is shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-applicative-profunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Further theoretical developments at the end of this chapter include:
\end_layout

\begin_layout Itemize
We have previously seen several examples of methods that are equivalent
 as types: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and so on.
 Now we clarify and formulate rigorously what it means that two typeclass
 methods are 
\begin_inset Quotes eld
\end_inset

isomorphic as types assuming some laws hold
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
All monads are applicative at least in one way (but not all applicative
 functors are monads).
 In many cases, the applicative instance derived from the monad instance
 is not as useful in applications as a different, inequivalent applicative
 instance for the same type constructor.
 We show some examples illustrating this.
\end_layout

\begin_layout Itemize
We motivate and define the concept of 
\begin_inset Quotes eld
\end_inset

applicative morphism
\begin_inset Quotes erd
\end_inset

: a mapping between two applicative functors that preserves the applicative
 methods.
\end_layout

\begin_layout Itemize
The laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ap
\end_layout

\end_inset

 are easier to derive if we get some help from category theory.
 For an applicative functor 
\begin_inset Formula $L$
\end_inset

, we define the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $L$
\end_inset

-ap
\begin_inset Quotes erd
\end_inset

 category whose morphisms have type 
\begin_inset Formula $L^{A\rightarrow B}$
\end_inset

 and are composed using the special operation (
\begin_inset Formula $\odot$
\end_inset

).
 In this formulation, the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ap
\end_layout

\end_inset

 follow from the category laws of 
\begin_inset Formula $L$
\end_inset

-ap.
\end_layout

\begin_layout Itemize
We summarize various typeclass methods and laws defined in this and the
 previous chapter and examine the patterns in their type signatures (see
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:functorial-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It turns out that the laws of each typeclass are equivalent to the standard
 functor laws, if we consider a certain categorical functor defined in a
 suitable way for that typeclass.
 This provides a general and abstract picture justifying the choice of typeclass
 laws.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:9-Traversable-functors-and"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
We begin by considering the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method for sequences.
 Traversable functors are found by a generalization that we motivate in
 several steps.
 As a first step, we pass from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, which is parameterized by an arbitrary monoid 
\begin_inset Formula $M$
\end_inset

.
 The next step generalizes from sequences to functors that support an analogous
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 method.
 The final step is to replace the monoid 
\begin_inset Formula $M$
\end_inset

 by an arbitrary applicative functor with a type parameter.
 The result is a powerful operation known as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 function can be implemented for any polynomial functor (we will prove that
 rigorously later in that chapter).
 To build up intuition, we show several examples of implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for different data types, such as lists and trees.
\end_layout

\begin_layout Standard
Another useful function equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

: it extracts all data from a functor in a certain fixed order into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We illustrate the usage of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 for tasks such as depth-first or breadth-first aggregations and 
\begin_inset Quotes eld
\end_inset

decorations
\begin_inset Quotes erd
\end_inset

 on trees.
 A typical 
\begin_inset Quotes eld
\end_inset

decoration
\begin_inset Quotes erd
\end_inset

 function is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

: it adds integer labels to data according to the traversal order.
 We show how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 makes implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 simpler.
 Different traversal orders correspond to different implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

, while the 
\begin_inset Quotes eld
\end_inset

decoration
\begin_inset Quotes erd
\end_inset

 logic remains the same.
\end_layout

\begin_layout Standard
Defining the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 typeclass via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 method, we show how to implement various traversal-like operations such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 using that typeclass.
\end_layout

\begin_layout Standard
Then we give examples of tasks that cannot be performed via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 because it cannot obtain certain required information while traversing
 the data structure.
 To overcome this difficulty, we introduce a generalized 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 operation that depends on the pattern functor of a recursive type.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 operation is a 
\series bold
recursion scheme
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
recursion scheme
\end_layout

\end_inset

: a higher-order function that supplies recursive behavior and is parameterized
 by a calculation that needs to be performed repeatedly.
 We give some examples of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 for implementing tasks such as depth labeling (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithDepth
\end_layout

\end_inset

) and pretty-printing.
\end_layout

\begin_layout Standard
A recursion scheme opposite to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

: it creates a new recursive structure by following specified logic.
 We give examples of using unfold for creating lists and trees of specified
 shape.
\end_layout

\begin_layout Standard
Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 that always terminates, the termination of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 is not guaranteed, as it can go on indefinitely creating new parts of recursive
 structures.
 This problem can be avoided by using lazy data structures that delay evaluation
 of recursive parts.
 We show how to define a 
\begin_inset Quotes eld
\end_inset

lazy
\begin_inset Quotes erd
\end_inset

 binary tree that can simulate trees of unbounded depth.
\end_layout

\begin_layout Standard
We turn to investigating the laws and formal properties of folding and traversal
 operations.
 First, we show formally that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 are isomorphic as types if we assume suitable naturality laws.
 When formulating those laws, we find it necessary to introduce 
\begin_inset Quotes eld
\end_inset

monoid morphisms
\begin_inset Quotes erd
\end_inset

: functions mapping one monoid to another such that the monoid operations
 are preserved.
\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-missing-laws-of-foldMap-and-reduce"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we discuss the problem that the naturality laws alone do not guarantee
 useful behavior of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

.
 However, it does not appear possible to formulate any new laws.
 Instead, we will formulate a law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 and derive the folding operations from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The lack of laws is not a serious issue since foldable functors can be character
ized in a simple way: they are just all polynomial functors.
 We show that all polynomial functors support a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 operation (and therefore all the other equivalent operations).
\end_layout

\begin_layout Standard
We now turn to studying the laws of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 operation.
 First, we note that an equivalent simpler operation is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

.
 Then we formulate several laws of traverse: the applicative naturality
 law, the identity law, and the composition law.
 We motivate those laws by formal considerations and also show that these
 laws do not hold for certain incorrect implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Then we derive the corresponding simpler laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

.
 Using those laws, we perform structural analysis and prove that all polynomial
 functors are traversable.
 (We also explain why non-polynomial functors are not traversable.)
\end_layout

\begin_layout Standard
In that proof, we needed a notion of 
\begin_inset Quotes eld
\end_inset

bitraversable
\begin_inset Quotes erd
\end_inset

 bifunctors.
 We define that property formally and show that all polynomial bifunctors
 are bitraversable.
\end_layout

\begin_layout Standard
In the last section of the chapter, we explore some further questions:
\end_layout

\begin_layout Itemize
The recursion schemes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 generate 
\begin_inset Quotes eld
\end_inset

structure-preserving
\begin_inset Quotes erd
\end_inset

 maps between types.
 We define formally the notions of functor algebras and functor co-algebras
 to show how the property of being 
\begin_inset Quotes eld
\end_inset

structure-preserving
\begin_inset Quotes erd
\end_inset

 can be formulated via equations.
\end_layout

\begin_layout Itemize
Some laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 are still missing, as we are not able to use the existing laws for proving
 certain expected properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

.
 One needs a 
\begin_inset Quotes eld
\end_inset

representation theorem
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-Bird-representation-theorem-for-traversal"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 A detailed proof of that theorem is beyond the scope of this book.
 Using that theorem, we can prove the required properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

.
 We also show that a traversable functor always allows us to write an explicit
 indexed table for all the data it contains (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-polynomial-functors-Int-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Itemize
We show that nontrivial traversable contrafunctors and profunctors do not
 exist.
\end_layout

\begin_layout Itemize
We show how to implement traversals for nested recursive types, and illustrate
 with an example implementation of square-shaped nested lists.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Free-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:Proofs-of-naturality-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
This appendix studies 
\begin_inset Quotes eld
\end_inset

parametricity properties
\begin_inset Quotes erd
\end_inset

 that apply to all fully parametric code.
 Those properties are a mathematical expression of the idea that a fully
 parametric function works 
\begin_inset Quotes eld
\end_inset

in the same way
\begin_inset Quotes erd
\end_inset

 for all types.
 This appendix develops the necessary theory and technique in order and
 proves the following results:
\end_layout

\begin_layout Standard
A given type constructor may have one fully parametric and lawful implementation
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 typeclass instance.
 (For most other typeclasses, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, type constructors often have several inequivalent and lawful typeclass
 instances.) The unique implementations are used in the type constructions
 shown in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Contrafunctor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The lifting methods of any fully parametric bifunctor or profunctor obey
 the commutativity law such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
Any fully parametric expression 
\begin_inset Formula $t:\forall A.\,Q^{A}$
\end_inset

 satisfies the relational naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In general, the relational naturality law expresses a property of 
\emph on
relations
\emph default
 rather than functions and is not equivalent to any equation satisfied by
 
\begin_inset Formula $t$
\end_inset

.
 The chapter explains how relations are defined and what operations are
 available for relations, and shows the proof of the relational naturality
 law.
\end_layout

\begin_layout Standard
All fully parametric functions of type 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 (where 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 are profunctors) obey the dinaturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The form of the law depends only on the function's type signature and applies
 to all fully parametric implementations of that type signature.
\end_layout

\begin_layout Standard
If the type signature of 
\begin_inset Formula $t$
\end_inset

 satisfies the conditions of Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-wedge-entails-strong-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 or
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-functor-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the function 
\begin_inset Formula $t$
\end_inset

 satisfies the 
\begin_inset Quotes eld
\end_inset

strong dinaturality
\begin_inset Quotes erd
\end_inset

 law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Strong dinaturality gives more information than the ordinary dinaturality
 law and is simpler to use than the general relational naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{secnumdepth}{3}
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Restore the normal numbering of subsections and subsubsections
\end_layout

\end_inset


\end_layout

\begin_layout Section
Topics not covered in this book
\end_layout

\begin_layout Standard
This book focuses on mathematical theory that has proven its broad relevance
 to the functional programming practice.
 This section lists some topics that were omitted from this edition of the
 book, and explains why.
\end_layout

\begin_layout Subsection
Trampolines and stack-safe recursion in functor blocks
\end_layout

\begin_layout Standard
Recursion with applicative and monadic functors (say, a loop with the free
 monad) can lead to stack overflows when the nesting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods becomes too deep.
 There are certain tricks that can be used to ensure stack safety.
 One of those tricks is known as 
\begin_inset Quotes eld
\end_inset

trampolines
\begin_inset Quotes erd
\end_inset

.
 Another trick is to use stack-safe implementations of various monads.
 
\end_layout

\begin_layout Standard
Despite the practical significance of those techniques, this book does not
 discuss them in detail.
 Trampolines are already well described in the book 
\begin_inset Quotes eld
\end_inset

Functional programming in Scala
\begin_inset Quotes erd
\end_inset

.
 Stack-safe implementations of standard monads are complicated but are mathemati
cally equivalent to the same monads implemented via simple, non-stack-safe
 code.
 There is no new theory to be found and no new laws to be proved about code
 that is specially engineered to be stack-safe.
\end_layout

\begin_layout Subsection
Strictness and laziness
\end_layout

\begin_layout Standard
Scala can define values via one of the three evaluation strategies: eager
 (also known as 
\begin_inset Quotes eld
\end_inset

strict
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

call-by-value
\begin_inset Quotes erd
\end_inset

), lazy (
\begin_inset Quotes eld
\end_inset

memoized
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

call-by-need
\begin_inset Quotes erd
\end_inset

), or on-demand (
\begin_inset Quotes eld
\end_inset

call-by-name
\begin_inset Quotes erd
\end_inset

).
 Eager values are computed immediately as they are defined; lazy values
 are computed only on first use and then stored in memory; on-demand values
 are computed every time they are used.
 
\end_layout

\begin_layout Standard
In the functional programming paradigm, it is rare that an algorithm or
 a data structure works correctly only when certain values are defined as
 lazy.
 This book focuses on the properties of functional programs and their types
 that do not use strictness or laziness in an essential way.
 For instance, the laws of a functor are the same and need to be verified
 via the same proof regardless of whether the program code uses strict or
 lazy functor values.
 
\end_layout

\begin_layout Subsection
Combined typeclasses and their laws
\end_layout

\begin_layout Standard
Sequences and trees are perhaps the most frequently used data structures.
 Those data structures have at once the properties of several typeclasses:
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

.
 It turns out that the methods of various typeclasses satisfy not only the
 laws of their own typeclass but also additional laws that express a kind
 of compatibility between different typeclasses.
 For example, the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-deflate-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) expresses compatibility between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 methods.
\end_layout

\begin_layout Standard
This book does not systematically study the possible combinations between
 the major typeclasses and the relevant compatibility laws that could be
 imposed.
 There does not seem to be a general way of motivating and deriving the
 properties and laws for a typeclass defined by combining any two given
 typeclasses.
\end_layout

\begin_layout Subsection
Lenses, prisms, and other 
\begin_inset Quotes eld
\end_inset

functional optics
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

lens
\begin_inset Quotes erd
\end_inset

 is a function used for reading or updating a part of a large data structure
 while keeping all other parts unchanged.
 The theory and laws of lenses are complicated and do not seem to have been
 fully explored; for instance, it appears that lenses that violate certain
 laws are nevertheless necessary in practice.
 
\end_layout

\begin_layout Standard
Apart from lenses, a large range of other 
\begin_inset Quotes eld
\end_inset

optics
\begin_inset Quotes erd
\end_inset

 types (
\begin_inset Quotes eld
\end_inset

prisms
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

grates
\begin_inset Quotes erd
\end_inset

, etc.) has been invented.
 Practical applications of those 
\begin_inset Quotes eld
\end_inset

optics
\begin_inset Quotes erd
\end_inset

 remain to be explored.
\end_layout

\begin_layout Subsection
Comonads and comonad transformers
\end_layout

\begin_layout Standard
A comonad is a functor 
\begin_inset Formula $F$
\end_inset

 with two additional methods called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extract
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

duplicate
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{ex}_{F}:\forall A.\,F^{A}\rightarrow A\quad,\quad\quad\text{dupl}_{F}:\forall A.\,F^{A}\rightarrow F^{F^{A}}\quad.
\]

\end_inset

The type signatures of those methods are similar to the type signatures
 of the monads' methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 except that the function arrows point in the opposite direction:
\begin_inset Formula 
\[
\text{pu}_{F}:\forall A.\,A\rightarrow F^{A}\quad,\quad\quad\text{ftn}_{F}:\forall A.\,F^{F^{A}}\rightarrow F^{A}\quad.
\]

\end_inset

The comonad's methods must also satisfy the appropriate laws.
 Similarly to monads, two comonads can be combined via 
\begin_inset Quotes eld
\end_inset

comonad transformers
\begin_inset Quotes erd
\end_inset

 into a larger comonad.
 An example of a comonad is the non-empty list (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

).
 There is also a 
\begin_inset Quotes eld
\end_inset

co-free comonad
\begin_inset Quotes erd
\end_inset

 construction, similar to the free monad.
\end_layout

\begin_layout Standard
Although the properties of comonads have many similarities to those of monads,
 this book does not develop the corresponding theory because comonads do
 not appear to have nearly as wide a range of applications in practical
 programming as monads do.
\end_layout

\begin_layout Subsection
Dependent types
\end_layout

\begin_layout Standard
Scala has limited support for dependent types
\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent type
\end_layout

\end_inset

.
 While there are occasional uses for those types in some Scala libraries,
 most functional programming practice today is formulated with traditional
 types that are fully determined at compile time and do not depend on run-time
 values.
 This book does not develop the theory of dependent types as that theory
 is quite complicated and yet limited in practical applications.
\end_layout

\begin_layout Subsection
Linear types
\end_layout

\begin_layout Standard
Some programming languages include features that go beyond the type system
 described in this book.
 For example, the Rust language has special features of the type system
 (the 
\begin_inset Quotes eld
\end_inset

borrow checker
\begin_inset Quotes erd
\end_inset

) that describe memory allocation ownership and lifetimes.
 In that way, Rust programs can manage memory explicitly and verify at compile
 time that programs never attempt to deallocate memory at the wrong place
 or at the wrong time, or to write data to protected (
\begin_inset Quotes eld
\end_inset

borrowed
\begin_inset Quotes erd
\end_inset

) memory locations.
 The Rust type system uses some features of 
\series bold
linear types
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
linear types
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!linear
\end_layout

\end_inset

(describing values that can be used only once).
\end_layout

\begin_layout Standard
Features of that kind are complicated and not widely used in the functional
 programming community.
 A Scala library for linear-type programming is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

libretto
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/TomasMikula/libretto"
literal "false"

\end_inset


\end_layout

\end_inset

 This book focuses on the type system features that are both widely used
 and well-understood.
\end_layout

\begin_layout Subsection
Effect systems
\end_layout

\begin_layout Standard
Algebraic effects are currently an active topic of research and experimentation.
 The basic idea of an effect system is to use type signatures that indicate
 precisely what side effects a function may execute when it is evaluated.
 For instance, there is one effect type for printing to the console, another
 effect type for querying a database, yet another for running code via parallel
 threads, and so on.
 The type system of Scala is flexible enough to accommodate complicated
 type signatures that can mix and match effects in an application-specific
 way.
 In Scala 3, new features have been introduced for programming with effects.
\end_layout

\begin_layout Standard
Libraries such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cats-effect
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/typelevel/cats-effect"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zio
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/zio/zio"
literal "false"

\end_inset


\end_layout

\end_inset

 provide some simple ways of managing effects, mostly focusing on concurrent
 programming.
 Several advanced Scala libraries for effect-oriented programming, such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

kyo
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/getkyo/kyo"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yaes
\end_layout

\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/rcardin/yaes"
literal "false"

\end_inset


\end_layout

\end_inset

 have been created recently.
 It is perhaps too early to say what form of effect-oriented programming
 will gain wide use.
\end_layout

\begin_layout Subsection
Programming language theory
\end_layout

\begin_layout Standard
Certain theoretical questions are of interest to designers of programming
 languages but not to users of those languages.
 Here are some examples of such questions:
\end_layout

\begin_layout Itemize
Proving that type inference and type checking are terminating procedures.
\end_layout

\begin_layout Itemize
Proving that evaluation will be always error-free once an expression has
 been type-checked.
 (
\begin_inset Quotes eld
\end_inset

Soundness
\begin_inset Quotes erd
\end_inset

 of the type system.)
\end_layout

\begin_layout Itemize
Proving that evaluating an expression will always give the same results
 regardless of which part of the expression is evaluated first; or providing
 precise conditions for that to be true.
\end_layout

\begin_layout Itemize
Proving that composition of functions is associative by a rigorous description
 of what it means for functions to be equal without involving an evaluation
 of those functions.
\end_layout

\begin_layout Standard
This book does not pursue those topics.
\end_layout

\begin_layout Section
Additional exercises and open problems
\begin_inset CommandInset label
LatexCommand label
name "chap:Exercises-in-AFTT"

\end_inset


\end_layout

\begin_layout Standard
The following is a sample set of problems that can be solved using techniques
 developed in this book.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write a function for finding the smallest integer expressible as a sum of
 two cubed integers in more than one way.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

norepeat
\end_layout

\end_inset

 that removes consecutive repetitions from sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def norepeat[A]: Seq[A] => Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> norepeat(Seq(1, 2, 2, 1, 1, 3, 3, 3, 0, 3))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = Seq(1,2,1,3,0,3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Read a text file, split it by spaces into words, and print the word counts
 in decreasing order.
\begin_inset Note Comment
status collapsed

\begin_layout Enumerate
FPIS exercise 2.2: Check whether a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 is sorted according to a given ordering function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A) => Boolean
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
FPIS exercise 3.24: Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hasSubsequence
\end_layout

\end_inset

 that checks whether a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 contains another 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 as a subsequence.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2,3,4)
\end_layout

\end_inset

 would have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(2,3)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(4)
\end_layout

\end_inset

 as subsequences, among others.
 (Dynamic programming?)
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The Seasoned Schemer, chapter 13: Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def remberUptoLast[A](a: A, s: List[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

def remberBeyondLast[A](a: A, s: List[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> remberUptoLast(4, List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

List(5, 6, 7, 8)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> remberBeyondLast(4, List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

List(1, 2, 3, 4, 5)
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 removes all elements from a list up to and including the last occurrence
 of a given value.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

 removes all elements from a list starting from the last occurrence of a
 given value.
 Both functions return the original list if the given value does not occur
 in the list.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
We first define extension method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastOption
\end_layout

\end_inset

 for Scala's Iterator:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class IteratorOps[A](val it: Iterator[A]) extends AnyVal {
\end_layout

\begin_layout Plain Layout

  def lastOption: Option[A] = {
\end_layout

\begin_layout Plain Layout

   @tailrec def lastKnown(x: A): Some[A] = if (it.hasNext) lastKnown(it.next)
 else Some(x)
\end_layout

\begin_layout Plain Layout

   if (it.hasNext) lastKnown(it.next) else None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Then the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

 is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def remberUptoLast[A](a: A, s: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  s.tails.filter(_.headOption contains a).lastOption.map(_.tail).getOrElse(s)
\end_layout

\begin_layout Plain Layout

def remberBeyondLast[A](a: A, s: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  s.reverse.tails.filter(_.headOption contains a).nextOption.map(_.tail.reverse).getOrEls
e(s)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Exercise 4-1 from Hu Zhenjiang's course 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://www.prg.nii.ac.jp/course/2015/msp15/"
literal "false"

\end_inset


\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Express the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method for sequences via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(s: Seq[A]): Seq[A] = s.flatMap { a => ???
 }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a monoid of partial functions with fixed types 
\begin_inset Formula $P\rightarrow Q$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class PFM[P, Q](pf: PartialFunction[P, Q])
\end_layout

\begin_layout Plain Layout

// After defining a monoid instance, the following code must work:
\end_layout

\begin_layout Plain Layout

val p1 = PFM[Option[Int], String] { case Some(3) => 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

 }
\end_layout

\begin_layout Plain Layout

val p2 = PFM[Option[Int], String] {
\end_layout

\begin_layout Plain Layout

  case Some(20)   => 
\begin_inset Quotes eld
\end_inset

twenty
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case None       => 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

val p3 = p1 |+| p2 // Must be the same as the concatenation of all `case`
 clauses.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-6-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-6-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
This was posted in 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://cstheory.stackexchange.com/questions/53294"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Find a general type signature for the expression 
\begin_inset Formula $a\rightarrow a(y\rightarrow t\rightarrow t)(z(a))$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, show that:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 There is a natural transformation of type 
\begin_inset Formula $F^{A}\times G^{A}\rightarrow F^{A}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 There is a natural transformation of type 
\begin_inset Formula $F^{A}\rightarrow F^{A}+G^{A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
R.
\begin_inset space ~
\end_inset

Bird and O.
\begin_inset space ~
\end_inset

de Moor, 
\emph on
Algebra of programming
\emph default
 (1996), page 20.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Derive the following identity between functions 
\begin_inset Formula $F^{A}\rightarrow F^{A}$
\end_inset

, for any filterable functor 
\begin_inset Formula $F$
\end_inset

 and any predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

: 
\begin_inset Formula 
\[
\text{filt}_{F}(p)=(\Delta\bef\text{id}\boxtimes p)^{\uparrow F}\bef\text{filt}_{F}(\pi_{2})\bef\pi_{1}^{\uparrow F}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-1-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-1-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For any polynomial functor 
\begin_inset Formula $F$
\end_inset

 (not necessarily a monad), show that there exists a fully parametric function
 we call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leaf
\end_layout

\end_inset

, of type 
\begin_inset Formula $F^{F^{\bbnum 0}}\rightarrow F^{\bbnum 0}$
\end_inset

, obeying the following special identity law:
\begin_inset Formula 
\[
\text{absurd}^{\uparrow F}\bef\text{leaf}=\text{id}\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.3pc}\xyScaleX{3.5pc} & F^{F^{\bbnum 0}}\ar[rd]\sp(0.5){\ \text{leaf}}\\
F^{\bbnum 0}\ar[ru]\sp(0.5){(\text{absurd}^{:\bbnum 0\rightarrow F^{\bbnum 0}})^{\uparrow F}\ \ }\ar[rr]\sb(0.5){\text{id}\,} &  & F^{\bbnum 0}
}
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that a function of type 
\begin_inset Formula $F^{F^{\bbnum 0}}\rightarrow F^{\bbnum 0}$
\end_inset

 cannot be implemented fully parametrically for some non-polynomial functors
 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-1-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-1-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $T$
\end_inset

 be the Church encoding of the least fixpoint of a given functor 
\begin_inset Formula $F$
\end_inset

:
\begin_inset Formula 
\[
T\triangleq\forall A.\,(F^{A}\rightarrow A)\rightarrow A\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that there exists a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inT
\end_layout

\end_inset

 of type 
\begin_inset Formula $F^{\bbnum 0}\rightarrow T$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 When 
\begin_inset Formula $F$
\end_inset

 is a 
\emph on
polynomial
\emph default
 functor, show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inT
\end_layout

\end_inset

 has a left inverse (
\begin_inset Formula $\text{outT}:T\rightarrow F^{\bbnum 0}$
\end_inset

), which means that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inT
\end_layout

\end_inset

 is injective (and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outT
\end_layout

\end_inset

 is surjective).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-6-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-6-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence: L[F[A]] => F[L[A]]
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\text{seq}_{L}^{F}$
\end_inset

) that assumes a traversable functor 
\begin_inset Formula $L$
\end_inset

 and an applicative functor 
\begin_inset Formula $F$
\end_inset

.
 If we set 
\begin_inset Formula $F=\text{List}$
\end_inset

 and also 
\begin_inset Formula $L=\text{List}$
\end_inset

 then we obtain the type signature 
\begin_inset Formula $\text{seq}_{\text{List}}^{\text{List}}:\text{List}^{\text{List}^{A}}\rightarrow\text{List}^{\text{List}^{A}}$
\end_inset

.
 A data structure of type 
\begin_inset Formula $\text{List}^{\text{List}^{A}}$
\end_inset

 may be used to represent a rectangular matrix.
 Show that the function 
\begin_inset Formula $\text{seq}_{\text{List}}^{\text{List}}$
\end_inset

 transposes the rectangular matrix.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The non-empty list (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

) has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method as shown in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-non-empty-list-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 However, we may use the type equivalence:
\begin_inset Formula 
\[
\text{NEL}^{A}\cong A\times\text{List}^{A}\quad,
\]

\end_inset

which expresses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

 as a product of two monads (the identity monad and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad).
 Show that the monad product construction (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-semimonad-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

) implements a different monad structure for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-7-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-7-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monad 
\begin_inset Formula $M$
\end_inset

 and a fixed type 
\begin_inset Formula $Z$
\end_inset

, consider the functor 
\begin_inset Formula $F^{A}\triangleq(A\rightarrow M^{Z})\rightarrow Z$
\end_inset

.
 Show that 
\begin_inset Formula $F$
\end_inset

 is a semimonad but not a full monad.
 Hint: use the flipped Kleisli technique.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-7-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-7-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://cstheory.stackexchange.com/questions/54227"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A monad 
\begin_inset Formula $M$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method obeys the naturality law:
\begin_inset Formula 
\[
\text{flm}_{M}(g\bef h^{\uparrow M})=\text{flm}_{M}(g)\bef h^{\uparrow M}\quad.
\]

\end_inset

This law holds with an arbitrary function 
\begin_inset Formula $h:A\rightarrow B$
\end_inset

.
 Show that one cannot replace 
\begin_inset Formula $h^{\uparrow M}$
\end_inset

 in this law by an arbitrary function 
\begin_inset Formula $k:M^{A}\rightarrow M^{B}$
\end_inset

.
 Namely, for some monads 
\begin_inset Formula $M$
\end_inset

 and some functions 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $k$
\end_inset

 (of appropriate types) we will have 
\begin_inset Formula $\text{flm}_{M}(g\bef k)\neq\text{flm}_{M}(g)\bef k$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-18-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-18-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find fully parametric implementations of the type signatures:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def a[A, B, C]: ((C => B) => A) => B => A
\end_layout

\begin_layout Plain Layout

def b[A, B]: (((A => B) => B) => B) => A => B
\end_layout

\begin_layout Plain Layout

def c[A, B]: ((((A => B) => A) => A) => B) => B
\end_layout

\begin_layout Plain Layout

def d[A, B, C]: (((A => B) => C) => A => B) => (B => C) => A => B
\end_layout

\begin_layout Plain Layout

def e[A, B, C]: ((B => C) => A => B) => ((A => B) => C) => A => B
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-18"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-18"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following type signatures have 
\emph on
no
\emph default
 fully parametric implementations:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: Option[A] => A
\end_layout

\begin_layout Plain Layout

def g[A, B]: (A => B) => A
\end_layout

\begin_layout Plain Layout

def h[A, B]: (A => B) => B => A
\end_layout

\begin_layout Plain Layout

def k[A, B, C]: (A => B) => (B => C) => C => A
\end_layout

\begin_layout Plain Layout

def l[A, B]: ((((A => B) => B) => A) => B) => B
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: set some type parameters to the void type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 that are not known to be equivalent, consider the contrafunctors 
\begin_inset Formula $F^{A}\triangleq\left(\left(A\rightarrow P\right)\rightarrow P\right)\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $G^{A}\triangleq A\rightarrow Q$
\end_inset

.
 Show that there exist natural transformations 
\begin_inset Formula $F\leadsto G$
\end_inset

 and 
\begin_inset Formula $G\leadsto F$
\end_inset

.
 Show that these transformations are 
\emph on
not
\emph default
 isomorphisms.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 that are not known to be equivalent, show that the functor 
\begin_inset Formula $L^{A}\triangleq\left(\left(\left(A\rightarrow P\right)\rightarrow Q\right)\rightarrow Q\right)\rightarrow P$
\end_inset

 is a semimonad but not a full monad.
 (When 
\begin_inset Formula $P\cong Q$
\end_inset

, the functor 
\begin_inset Formula $L$
\end_inset

 is then equivalent to a composition of the continuation monad with itself;
 that is also only a semimonad.
 See Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-composition-mm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-9-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-9-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any fully parametric contrafunctor 
\begin_inset Formula $F$
\end_inset

 that does not explicitly use the void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 (
\begin_inset Formula $\bbnum 0$
\end_inset

) in its type expression, show that the type of fully parametric functions
 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow A$
\end_inset

 is void.
 Show that the condition of not using the void type is necessary, as the
 contrafunctor 
\begin_inset Formula $F^{A}\triangleq(\bbnum 0\rightarrow A)\rightarrow\bbnum 0$
\end_inset

 would be a counterexample:
\begin_inset Formula 
\[
\forall A.\,F^{A}\rightarrow A=\forall A.\,((\bbnum 0\rightarrow A)\rightarrow\bbnum 0)\rightarrow A\cong((\bbnum 0\rightarrow\bbnum 0)\rightarrow\bbnum 0)\rightarrow\bbnum 0\cong\bbnum 1\quad.
\]

\end_inset

The type equivalence 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow A\cong\bbnum 0$
\end_inset

 means that we cannot extract values of type 
\begin_inset Formula $A$
\end_inset

 from a value of type 
\begin_inset Formula $F^{A}$
\end_inset

.
 This agrees with the intuition that value of type 
\begin_inset Formula $F^{A}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

do not store
\begin_inset Quotes erd
\end_inset

 any values of type 
\begin_inset Formula $A$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
By Yoneda we have 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow A\cong F^{\bbnum 0}\rightarrow\bbnum 0$
\end_inset

.
 Now we need to show that 
\begin_inset Formula $F^{\bbnum 0}\not\cong\bbnum 0$
\end_inset

 for any contrafunctor 
\begin_inset Formula $F$
\end_inset

 as long as 
\begin_inset Formula $F$
\end_inset

's type expression does not use the void type explicitly as one of its constant
 types.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is any monad then 
\begin_inset Formula $L^{A}\triangleq M^{A+M^{A}}$
\end_inset

 is also a lawful monad.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is a semimonad then 
\begin_inset Formula $M\circ M\circ...\circ M$
\end_inset

 (with finitely many 
\begin_inset Formula $M$
\end_inset

) is also a lawful semimonad.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is a commutative monad then 
\begin_inset Formula $M\circ M$
\end_inset

 is also a lawful commutative monad.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Foot
status open

\begin_layout Plain Layout
This was an open problem but it was solved by Hew Wolff.
\end_layout

\end_inset

 Prove that 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+\underbrace{A\times A\times...\times A}_{n\text{ times}}$
\end_inset

 cannot be made into a monad if 
\begin_inset Formula $n\ge2$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-13-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-13-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is a commutative monad and 
\begin_inset Formula $W$
\end_inset

 is a commutative monoid then the monoid 
\begin_inset Formula $M^{W}$
\end_inset

 is commutative.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-14"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-14"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 representing 
\begin_inset Quotes eld
\end_inset

triangular matrices
\begin_inset Quotes erd
\end_inset

 with elements of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Example values 
\begin_inset Formula $t_{1}$
\end_inset

, 
\begin_inset Formula $t_{2}$
\end_inset

, 
\begin_inset Formula $t_{3}$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 are:
\begin_inset Formula 
\[
t_{1}=\left|\begin{array}{c}
a_{1}\end{array}\right|\quad,\quad\quad t_{2}=\left|\begin{array}{cc}
a_{1}\\
a_{2} & a_{3}
\end{array}\right|\quad,\quad\quad t_{3}=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{4} & a_{5} & a_{6}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad.
\]

\end_inset

Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

, it should 
\emph on
not
\emph default
 be possible to have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 that has an unexpected shape:
\begin_inset Formula 
\[
t=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad\text{is not of type }\text{Triang}^{A}\quad.
\]

\end_inset

 Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instances for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-15"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-15"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Simplify the type 
\begin_inset Formula $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow A$
\end_inset

, or in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: ((A => A) => A) => A
\end_layout

\end_inset

into a type expression that contains no quantifiers.
 Show how to implement all possible values of this type.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://cstheory.stackexchange.com/questions/53855/"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-Peirce-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-Peirce-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the functor 
\begin_inset Formula $F$
\end_inset

 defined by:
\begin_inset Formula 
\[
F^{R}\triangleq\forall A.\,((A\rightarrow R)\rightarrow A)\rightarrow A\quad,
\]

\end_inset

where all functions of type 
\begin_inset Formula $F^{R}$
\end_inset

 are assumed to be fully parametric.
 Show that 
\begin_inset Formula $F^{R}\cong R$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://cstheory.stackexchange.com/questions/51945/"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Peirce's law
\end_layout

\end_inset

Peirce's law (see Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-3-peirce-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

)) is expressed as the type 
\begin_inset Formula $\forall R.\,F^{R}$
\end_inset

.
 Peirce's law does not hold in the constructive logic.
 The Curry-Howard correspondence says that the corresponding type 
\begin_inset Formula $\forall R.\,F^{R}$
\end_inset

 should be void, and it is: 
\begin_inset Formula $\forall R.\,F^{R}=\forall R.\,R=\bbnum 0$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-Peirce-law-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-Peirce-law-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove the following type equivalences (assuming a fixed type 
\begin_inset Formula $P$
\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Quantified type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Equivalent type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,(A\rightarrow A)\rightarrow P$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,(A\rightarrow A)\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,(A\rightarrow A)\rightarrow A+P$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow P$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the type constructor 
\begin_inset Formula $F$
\end_inset

 defined by:
\begin_inset Formula 
\[
F^{R,S}\triangleq\forall A.\,((R\rightarrow A)\rightarrow S)\rightarrow A\quad,
\]

\end_inset

where all functions of type 
\begin_inset Formula $F^{R,S}$
\end_inset

 are assumed to be fully parametric.
 Show that 
\begin_inset Formula $F^{R,S}\cong\bbnum 0$
\end_inset

 unless we set 
\begin_inset Formula $R=S=\bbnum 0$
\end_inset

, in which case 
\begin_inset Formula $F^{\bbnum 0,\bbnum 0}\cong\bbnum 1$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
By the covariant Yoneda identity, 
\begin_inset Formula $F^{R,S}=((R\rightarrow\bbnum 0)\rightarrow S)\rightarrow\bbnum 0$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16-2-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Prove the type equivalence:
\begin_inset Formula 
\[
\forall A.\,F^{A}\rightarrow E+A\cong\forall B.\,F^{B}\rightarrow(E\rightarrow B)\rightarrow B\quad,
\]

\end_inset

where 
\begin_inset Formula $E$
\end_inset

 is a fixed type and 
\begin_inset Formula $F$
\end_inset

 is any covariant functor.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Use the Yoneda identities:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,F^{A}\rightarrow\gunderline{E+A}\\
\text{introduce }\forall B:\quad & \cong\forall A.\,\forall B.\,F^{A}\rightarrow\gunderline{(E+A\rightarrow B)}\rightarrow B\\
\text{curry the function}:\quad & \cong\forall B.\,\forall A.\,F^{A}\rightarrow(E\rightarrow B)\rightarrow\gunderline{(A\rightarrow B)}\rightarrow B\\
\text{swap curried arguments}:\quad & \cong\forall B.\,\forall A.\,(A\rightarrow B)\rightarrow\gunderline{F^{A}\rightarrow(E\rightarrow B)\rightarrow B}\\
\text{contravariant Yoneda}:\quad & \cong\forall B.\,F^{B}\rightarrow(E\rightarrow B)\rightarrow B\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that this type equivalence does 
\emph on
not
\emph default
 hold for non-covariant 
\begin_inset Formula $F$
\end_inset

 (e.g., if 
\begin_inset Formula $F$
\end_inset

 is contravariant or if 
\begin_inset Formula $F^{A}=A\rightarrow A$
\end_inset

).
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
If 
\begin_inset Formula $F$
\end_inset

 is contravariant then we can simplify both sides separately:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,F^{A}\rightarrow E+A\cong F^{\bbnum 0}\rightarrow E+\bbnum 0\cong F^{\bbnum 0}\rightarrow E\quad,\\
 & \forall B.\,F^{B}\rightarrow(E\rightarrow B)\rightarrow B\cong\forall B.\,(E\rightarrow B)\rightarrow F^{B}\rightarrow B\cong F^{E}\rightarrow E\quad.
\end{align*}

\end_inset

The two sides are not equivalent.
\end_layout

\begin_layout Plain Layout
If 
\begin_inset Formula $F^{A}=A\rightarrow A$
\end_inset

 then we can simplify both sides separately:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,F^{A}\rightarrow E+A\cong\forall A.\,(A\rightarrow A)\rightarrow E+A\cong E\quad,\\
 & \forall B.\,F^{B}\rightarrow(E\rightarrow B)\rightarrow B\cong\forall B.\,(E+B\rightarrow B)\rightarrow B\cong E\times\text{List}^{\bbnum 1}\quad.
\end{align*}

\end_inset

The two sides are not equivalent.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Existential types can be expressed as shown in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:existential-via-universal-Yoneda"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\exists C.\,F^{C}\cong\forall D.\,(\forall C.\,F^{C}\rightarrow D)\rightarrow D\quad.
\]

\end_inset

Show that for any covariant functor 
\begin_inset Formula $G$
\end_inset

, the following Yoneda-like formula holds:
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
Use the covariant Yoneda identity:
\begin_inset Formula 
\begin{align*}
 & \forall D.\,(\gunderline{\forall C.\,F^{C}\rightarrow D})\rightarrow G^{D}\\
\text{use Eq.~(\ref{eq:existential-via-universal})}:\quad & \cong\forall D.\,((\exists C.\,F^{C})\rightarrow D)\rightarrow G^{D}\\
\text{use Yoneda identity}:\quad & \cong G^{\exists C.\,F^{C}}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
G^{\exists C.\,F^{C}}\cong\forall D.\,(\forall C.\,F^{C}\rightarrow D)\rightarrow G^{D}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a monad transformer 
\begin_inset Formula $\text{Cod}_{F}^{L}\varangle M$
\end_inset

 for the composed codensity monad (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-combined-codensity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with type parameters 
\begin_inset Formula $F$
\end_inset

 (an arbitrary but fixed functor) and 
\begin_inset Formula $L$
\end_inset

 (an arbitrary but fixed monad).
 Find out which laws hold for that transformer.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
This exercise describes some non-standard transformers for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad.
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\end_layout

\end_inset

 Unlike the standard transformer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Transformer-for-the-List-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

), those alternative transformers do not support base lifts and are not
 covariant in the foreign monad.
\end_layout

\begin_layout Standard
Denote by 
\begin_inset Formula $G$
\end_inset

 the (non-covariant) type constructor 
\begin_inset Formula $G^{A}\triangleq A\rightarrow A$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/72490608/"
literal "false"

\end_inset


\family default
 for discussion about monads having multiple transformers.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that codensity monad on 
\begin_inset Formula $G$
\end_inset

 (denoted by 
\begin_inset Formula $\text{Cod}^{G}$
\end_inset

) is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 via monad morphisms.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the corresponding monad transformer: 
\begin_inset Formula 
\[
(\text{Cod}^{G}\varangle M)^{A}\triangleq\forall R.\,(A\rightarrow M^{G^{R}})\rightarrow M^{G^{R}}=\forall R.\,(A\rightarrow M^{R\rightarrow R})\rightarrow M^{R\rightarrow R}
\]

\end_inset

is 
\emph on
not
\emph default
 equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's standard transformer (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that the type constructor 
\begin_inset Formula $U$
\end_inset

 defined by:
\begin_inset Formula 
\[
U^{M,A}\triangleq\forall R.\,(A\rightarrow G^{M^{R}})\rightarrow G^{M^{R}}=\forall R.\,(A\rightarrow M^{R}\rightarrow M^{R})\rightarrow M^{R}\rightarrow M^{R}
\]

\end_inset

is also a lawful monad transformer (with the foreign monad 
\begin_inset Formula $M$
\end_inset

) for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad.
 Show that the transformer 
\begin_inset Formula $U$
\end_inset

 (known as the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LogicT
\end_layout

\end_inset

 monad transformer
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Bodigrim/logict"
literal "false"

\end_inset


\family default
 for an example implementation in Haskell.
\end_layout

\end_inset

) is not equivalent to that defined in 
\series bold
(b)
\series default
.
 
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 Generalize 
\series bold
(c)
\series default
 using an arbitrary (covariant) functor 
\begin_inset Formula $F$
\end_inset

 and two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\[
V^{F,P,Q,M,A}\triangleq\forall R.\,(A\rightarrow F^{M^{R}}\rightarrow P\times M^{R}+Q)\rightarrow F^{M^{R}}\rightarrow P\times M^{R}+Q\quad.
\]

\end_inset

Show that there exists a monad morphism 
\begin_inset Formula $M^{A}\rightarrow V^{F,P,Q,M,A}$
\end_inset

, and that the converse function of type 
\begin_inset Formula $V^{F,P,Q,M,A}\rightarrow M^{A}$
\end_inset

 exists when 
\begin_inset Formula $Q=\bbnum 0$
\end_inset

 (but is 
\emph on
not
\emph default
 a monad morphism).
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 Show that the Church-encoded free monoid on 
\begin_inset Formula $A$
\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Church-encodings-for-free-P-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{FM}^{A}\triangleq\forall X^{:\text{Monoid}}.\,(A\rightarrow X)\rightarrow X
\]

\end_inset

can be modified to the type constructor denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FMT
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{FMT}^{M,A}\triangleq\forall X^{:\text{Monoid}}.\,(A\rightarrow M^{X})\rightarrow M^{X}\quad,
\]

\end_inset

which is a lawful monad transformer (with the foreign monad 
\begin_inset Formula $M$
\end_inset

) for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad.
 Show that this transformer is not equivalent to the transformers defined
 in 
\series bold
(b)
\series default
, 
\series bold
(c)
\series default
.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-17"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-17"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For any fixed type 
\begin_inset Formula $Z$
\end_inset

, functor 
\begin_inset Formula $F$
\end_inset

 and lawful monad 
\begin_inset Formula $P$
\end_inset

, show that 
\begin_inset Formula $L^{A}\triangleq F^{A\rightarrow P^{Z}}\rightarrow P^{A}$
\end_inset

 is a lawful monad.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that 
\begin_inset Formula $L$
\end_inset

's monad transformer is 
\begin_inset Formula $(L\varangle M)^{A}\triangleq F^{A\rightarrow(P\varangle M)^{Z}}\rightarrow(P\varangle M)^{A}$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

's monad transformer (
\begin_inset Formula $P\varangle M$
\end_inset

) is considered known.
\end_layout

\begin_layout Subsection
Open problems
\begin_inset Index idx
status open

\begin_layout Plain Layout
open problems
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The author of this book does not know how to answer the following questions
 and also could not find any answers in existing books or papers.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-filtering-recursive-type-church"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-filtering-recursive-type-church"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the recursively defined functor 
\begin_inset Formula $F^{A}\triangleq S^{A,F^{A}}$
\end_inset

 is filterable if the bifunctor 
\begin_inset Formula $S$
\end_inset

 supports a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftE
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{liftE}_{S}^{A,B,R}:(A\rightarrow\bbnum 1+B)\rightarrow S^{A,R}\rightarrow R+S^{B,R}\quad,
\]

\end_inset

such that that suitable laws hold:
\begin_inset Formula 
\begin{align*}
\text{naturality-identity law}:\quad & \text{liftE}_{S}^{A,B,R}(f^{:A\rightarrow B}\bef\text{pu}_{\text{Opt}}^{B})=f^{\uparrow S^{\bullet,R}}\bef(s^{:S^{B,R}}\rightarrow\bbnum 0^{:R}+s)\quad,\\
\text{composition law}:\quad & \text{liftE}_{S}^{A,B,R}(f^{:A\rightarrow\bbnum 1+B})\bef\,???\,\bef\text{liftE}_{S}^{B,C,R}(g^{:B\rightarrow\bbnum 1+C})=\text{liftE}_{S}^{A,C,R}(f\diamond_{_{\text{Opt}}}g)\quad,\\
\text{naturality law in }R:\quad & (g^{:Q\rightarrow R})^{\uparrow S^{A,\bullet}}\bef\text{liftE}_{S}^{A,B,R}(f)=\text{liftE}_{S}^{A,B,Q}(f)\bef g^{\uparrow U^{B,\bullet}}\quad.
\end{align*}

\end_inset

Here, the bifunctor 
\begin_inset Formula $U$
\end_inset

 is defined by:
\begin_inset Formula 
\[
U^{B,R}\triangleq R+S^{B,R}\quad,
\]

\end_inset

and a suitable composition law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftE
\end_layout

\end_inset

 is yet unknown and must be formulated.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Attempt to prove:
\end_layout

\begin_layout Plain Layout
The lifting codes for 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $U$
\end_inset

 are:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow F}=f^{\uparrow S^{\bullet,F^{A}}}\bef f^{\uparrow F\uparrow S^{B,\bullet}}\quad,\quad\quad(g^{:Q\rightarrow R})^{\uparrow U^{B,\bullet}}=\,\begin{array}{|c||cc|}
 & R & S^{B,R}\\
\hline Q & g & \bbnum 0\\
S^{B,Q} & \bbnum 0 & g^{\uparrow S^{B,\bullet}}
\end{array}\quad.
\]

\end_inset

For convenience, we denote by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fix
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfix
\end_layout

\end_inset

 two functions that convert between equivalent types 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $S^{A,F^{A}}$
\end_inset

:
\begin_inset Formula 
\[
\text{fix}^{A}:S^{A,F^{A}}\rightarrow F^{A}\quad,\quad\quad\text{unfix}^{A}:F^{A}\rightarrow S^{A,F^{A}}\quad.
\]

\end_inset

These functions are assumed to be known, to satisfy the naturality laws
 with respect to 
\begin_inset Formula $A$
\end_inset

, and to be inverse to each other.
 We will use these functions to show clearly the places in the proof where
 values are transformed between the isomorphic types 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $S^{A,F^{A}}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
We also define a helper function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mergeE
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{mergeE}:\forall A.\,F^{A}+S^{A,F^{A}}\rightarrow F^{A}\quad,\quad\text{or equivalently}:\quad\text{mergeE}^{A}:U^{A,F^{A}}\rightarrow F^{A}\quad,\\
 & \text{mergeE}\triangleq\,\begin{array}{|c||c|}
 & F^{A}\\
\hline F^{A} & \text{id}\\
S^{A,F^{A}} & \text{fix}^{A}
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
With these definitions, the code of 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 is expressed through 
\begin_inset Formula $\text{liftE}_{S}$
\end_inset

 like this:
\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}_{F}:(A\rightarrow\bbnum 1+B)\rightarrow F^{A}\rightarrow F^{B}\quad,\\
 & \text{liftOpt}_{F}(f)\triangleq\text{unfix}^{A}\bef\text{liftE}_{S}^{A,B,F^{A}}(f)\bef\,\begin{array}{|c||c|}
 & F^{B}\\
\hline F^{A} & \overline{\text{liftOpt}_{F}}(f)\\
S^{B,F^{A}} & \big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{B,\bullet}}\bef\text{fix}^{B}
\end{array}\\
 & \quad=\text{unfix}^{A}\bef\text{liftE}_{S}^{A,B,F^{A}}(f)\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow U^{B,\bullet}}\bef\text{mergeE}^{B}\quad.
\end{align*}

\end_inset

An equivalent formulation of 
\begin_inset Formula $\text{liftOpt}_{F}$
\end_inset

 is found via the naturality law of 
\begin_inset Formula $\text{liftE}_{S}^{A,B,R}$
\end_inset

 with respect to 
\begin_inset Formula $R$
\end_inset

, where we need to set parameters as 
\begin_inset Formula $Q=F^{A}$
\end_inset

, 
\begin_inset Formula $R=F^{B}$
\end_inset

, and 
\begin_inset Formula $g=\overline{\text{liftOpt}_{F}}(f)$
\end_inset

:
\begin_inset Formula 
\[
\text{liftOpt}_{F}(f)=\text{unfix}^{A}\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{A,\bullet}}\bef\text{liftE}_{S}^{A,B,F^{B}}(f)\bef\text{mergeE}^{B}\quad.
\]

\end_inset


\end_layout

\begin_layout Plain Layout
To check the naturality-identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), begin with the left-hand side:
\begin_inset Formula 
\begin{align}
 & \text{liftOpt}_{F}(f^{:A\rightarrow B}\bef\text{pu}_{\text{Opt}}^{B})\nonumber \\
 & =\text{unfix}^{A}\bef\text{liftE}_{S}^{A,B,F^{A}}(f\bef\text{pu}_{\text{Opt}}^{B})\bef\big(\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}}^{B})\big)^{\uparrow U^{B,\bullet}}\bef\text{mergeE}^{B}\quad.\label{eq:liftopt-recursive-derivation2}
\end{align}

\end_inset

Now we can use the naturality law of 
\begin_inset Formula $\text{liftE}_{S}^{A,B,R}$
\end_inset

 with respect to 
\begin_inset Formula $R$
\end_inset

, where we need to set parameters as 
\begin_inset Formula $Q=F^{A}$
\end_inset

, 
\begin_inset Formula $R=F^{B}$
\end_inset

, and 
\begin_inset Formula $g=\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}}^{B})$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{liftE}_{S}^{A,B,F^{A}}(f\bef\text{pu}_{\text{Opt}}^{B})\bef\big(\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}}^{B})\big)^{\uparrow U^{B,\bullet}}\\
 & =\big(\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}}^{B})\big)^{\uparrow S^{A,\bullet}}\bef\text{liftE}_{S}^{A,B,F^{B}}(f\bef\text{pu}_{\text{Opt}}^{B})\quad.
\end{align*}

\end_inset

The assumed naturality-identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

liftE
\end_layout

\end_inset

 with 
\begin_inset Formula $R=F^{B}$
\end_inset

 gives:
\begin_inset Formula 
\[
\text{liftE}_{S}^{A,B,F^{B}}(f\bef\text{pu}_{\text{Opt}}^{B})=f^{\uparrow S^{\bullet,F^{B}}}\bef(s^{:S^{B,F^{B}}}\rightarrow\bbnum 0^{:F^{B}}+s)\quad.
\]

\end_inset

So, we can compute:
\begin_inset Formula 
\begin{align*}
 & \text{liftE}_{S}^{A,B,F^{B}}(f\bef\text{pu}_{\text{Opt}}^{B})\bef\text{mergeE}^{B}=s^{:S^{A,F^{B}}}\rightarrow\big(\bbnum 0^{:F^{B}}+s\triangleright f^{\uparrow S^{\bullet,F^{B}}}\big)\triangleright\,\begin{array}{|c||c|}
 & F^{B}\\
\hline F^{B} & \text{id}\\
S^{B,F^{B}} & \text{fix}^{B}
\end{array}\\
 & =s^{:S^{A,F^{B}}}\rightarrow s\triangleright f^{\uparrow S^{\bullet,F^{B}}}\triangleright\text{fix}^{B}=f^{\uparrow S^{\bullet,F^{B}}}\bef\text{fix}^{B}\quad.
\end{align*}

\end_inset

Putting the simplified sub-expressions together, we rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:liftopt-recursive-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f^{\uparrow F}:\quad & \text{liftOpt}_{F}(f^{:A\rightarrow B}\bef\text{pu}_{\text{Opt}}^{B})\\
 & =\text{unfix}^{A}\bef\big(\gunderline{\overline{\text{liftOpt}_{F}}(f\bef\text{pu}_{\text{Opt}}^{B})}\big)^{\uparrow S^{A,\bullet}}\bef f^{\uparrow S^{\bullet,F^{B}}}\bef\text{fix}^{B}\\
\text{inductive assumption}:\quad & =\text{unfix}^{A}\bef\gunderline{f^{\uparrow F\uparrow S^{A,\bullet}}\bef f^{\uparrow S^{\bullet,F^{B}}}}\bef\text{fix}^{B}\\
\text{definition of }f^{\uparrow F}:\quad & =\text{unfix}^{A}\bef\gunderline{f^{\uparrow F}\bef\text{fix}^{B}}\\
\text{naturality law of }\text{fix}:\quad & =\gunderline{\text{unfix}^{A}\bef\text{fix}^{A}}\bef f^{\uparrow F}=\text{id}\bef f^{\uparrow F}=f^{\uparrow F}\quad.
\end{align*}

\end_inset

This is now equal to the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:combined-naturality-identity-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Plain Layout
To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-liftOpt"
plural "false"
caps "false"
noprefix "false"

\end_inset

), begin with its left-hand side:
\begin_inset Formula 
\begin{align*}
 & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)\\
 & =\text{unfix}^{A}\bef\big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{A,\bullet}}\bef\text{liftE}_{S}^{A,B,F^{B}}(f)\bef\text{mergeE}^{B}\bef\text{unfix}^{B}\\
 & \quad\quad\bef\big(\overline{\text{liftOpt}_{F}}(g)\big)^{\uparrow S^{B,\bullet}}\bef\text{liftE}_{S}^{B,C,F^{C}}(g)\bef\text{mergeE}^{C}\\
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
*** & \text{liftOpt}_{F}(f)\bef\text{liftOpt}_{F}(g)=\text{unfix}^{A}\bef\text{liftE}_{S}^{A,B,F^{A}}(f)\bef\,\begin{array}{|c||c|}
 & F^{B}\\
\hline F^{A} & \overline{\text{liftOpt}_{F}}(f)\\
S^{B,F^{A}} & \big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{B,\bullet}}\bef\text{fix}^{B}
\end{array}\\
 & \quad\quad\bef\text{unfix}^{B}\bef\text{liftE}_{S}^{B,C,F^{B}}(g)\bef\,\begin{array}{|c||c|}
 & F^{C}\\
\hline F^{B} & \overline{\text{liftOpt}_{F}}(g)\\
S^{C,F^{B}} & \big(\overline{\text{liftOpt}_{F}}(g)\big)^{\uparrow S^{C,\bullet}}\bef\text{fix}^{C}
\end{array}\\
 & =\text{unfix}^{A}\bef\text{liftE}_{S}^{A,B,F^{A}}(f)\bef\,\begin{array}{|c||c|}
 & S^{B,F^{B}}\\
\hline F^{A} & \overline{\text{liftOpt}_{F}}(f)\bef\text{unfix}^{B}\\
S^{B,F^{A}} & \big(\overline{\text{liftOpt}_{F}}(f)\big)^{\uparrow S^{B,\bullet}}\bef\text{fix}^{B}\bef\text{unfix}^{B}
\end{array}\\
 & \quad\quad\bef\text{liftE}_{S}^{B,C,F^{B}}(g)\bef\,\begin{array}{|c||c|}
 & F^{C}\\
\hline F^{B} & \overline{\text{liftOpt}_{F}}(g)\\
S^{C,F^{B}} & \big(\overline{\text{liftOpt}_{F}}(g)\big)^{\uparrow S^{C,\bullet}}\bef\text{fix}^{C}
\end{array}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
*** 
\begin_inset Formula $\square$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-function-type-construction-not-applicative"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-function-type-construction-not-applicative"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are fixed but unknown types, and define the functor 
\begin_inset Formula $F$
\end_inset

 by 
\begin_inset Formula $F^{A}\triangleq(A\rightarrow P)\rightarrow Q$
\end_inset

.
 Is the functor 
\begin_inset Formula $F$
\end_inset

 applicative? Is 
\begin_inset Formula $F$
\end_inset

 a monad?
\end_layout

\begin_layout Standard
To make these questions non-trivial, assume that 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are not void and not unit types, and not isomorphic to each other.
 (In case 
\begin_inset Formula $P\cong Q$
\end_inset

, we find that 
\begin_inset Formula $F$
\end_inset

 is a continuation monad.) Specific examples are the functors 
\begin_inset Formula $(A\rightarrow\text{Int})\rightarrow\text{Bool}$
\end_inset

 and 
\begin_inset Formula $(A\rightarrow\text{Bool})\rightarrow\text{Int}$
\end_inset

.
 Are either of these functors applicative or monadic?
\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $F$
\end_inset

 will have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method if we have a value of type 
\begin_inset Formula $F^{\bbnum 1}\cong P\rightarrow Q$
\end_inset

.
 What additional data about 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 is necessary to make 
\begin_inset Formula $F$
\end_inset

 applicative or monadic when 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are 
\emph on
not
\emph default
 isomorphic as types? Is the isomorphism 
\begin_inset Formula $P\cong Q$
\end_inset

 required?
\end_layout

\begin_layout Standard
Applying the contravariant Yoneda identity to the type signature of 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

, we find: 
\begin_inset Formula 
\begin{align*}
 & \forall A.\,F^{F^{A}}\rightarrow F^{A}\\
 & =\forall A.\,\gunderline{((((A\rightarrow P)\rightarrow Q)\rightarrow P)\rightarrow Q)}\rightarrow\gunderline{(A\rightarrow P)}\rightarrow Q\\
\text{flip arguments}:\quad & \cong\forall A.\,\gunderline{(A\rightarrow P)\rightarrow}((((A\rightarrow P)\rightarrow Q)\rightarrow P)\rightarrow Q)\rightarrow Q\\
\text{Yoneda identity}:\quad & \cong((((P\rightarrow P)\rightarrow Q)\rightarrow P)\rightarrow Q)\rightarrow Q\quad.
\end{align*}

\end_inset

So, all possible implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 are in a one-to-one correspondence with all possible values of type 
\begin_inset Formula $((((P\rightarrow P)\rightarrow Q)\rightarrow P)\rightarrow Q)\rightarrow Q$
\end_inset

.
 All possible implementations of pure are in a one-to-one correspondce with
 all possible values of type 
\begin_inset Formula $P\rightarrow Q$
\end_inset

.
 It remains to see what implementations (if any) obey the monad laws.
 Note that the type 
\begin_inset Formula $((((P\rightarrow P)\rightarrow Q)\rightarrow P)\rightarrow Q)\rightarrow Q$
\end_inset

 is a fifth-order function whose cardinality is astronomically large; enumeratin
g all possible values of that type is impossible.
\end_layout

\begin_layout Standard
Applying the Yoneda identity to the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, we find:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,\forall B.\,F^{A}\times F^{B}\rightarrow F^{A\times B}\\
 & \cong\forall A.\,\forall B.\,((A\rightarrow P)\rightarrow Q)\rightarrow((B\rightarrow P)\rightarrow Q)\rightarrow\gunderline{(A\rightarrow B\rightarrow P)}\rightarrow Q\\
 & \cong\forall A.\,\forall B.\,\gunderline{(A\rightarrow B\rightarrow P)\rightarrow}((A\rightarrow P)\rightarrow Q)\rightarrow((B\rightarrow P)\rightarrow Q)\rightarrow Q\\
 & \cong\forall B.\,(((B\rightarrow P)\rightarrow P)\rightarrow Q)\rightarrow((B\rightarrow P)\rightarrow Q)\rightarrow Q\quad.
\end{align*}

\end_inset

All implementations of 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 are in a one-to-one correspondence to values of the last type above.
 The Yoneda identities cannot apply to that type.
 It is not clear how to simplify it any further.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-function-type-construction-not-applicative-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-function-type-construction-not-applicative-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $P$
\end_inset

 is a fixed but unknown type.
 Is the functor 
\begin_inset Formula $F^{A}\triangleq\left(A\rightarrow P\right)\rightarrow\bbnum 1+A$
\end_inset

 applicative or a monad?
\end_layout

\begin_layout Standard
To make these questions non-trivial, assume that 
\begin_inset Formula $P$
\end_inset

 is not void, not unit, and not pointed.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $P$
\end_inset

 is pointed (say, 
\begin_inset Formula $P\cong\bbnum 1+Q$
\end_inset

) then 
\begin_inset Formula $F$
\end_inset

 is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad of the form 
\begin_inset Formula $(A\rightarrow L^{Q})\rightarrow L^{A}$
\end_inset

 with 
\begin_inset Formula $L^{X}\triangleq\bbnum 1+X$
\end_inset

.
 (See comments about the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-generalized-search-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

.) Is 
\begin_inset Formula $F$
\end_inset

 not a monad and not applicative when 
\begin_inset Formula $P$
\end_inset

 is not a pointed type (that is, when an isomorphism 
\begin_inset Formula $P\cong\bbnum 1+Q$
\end_inset

 is not available)?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-polynomial-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows four constructions that make new monads:
\end_layout

\begin_layout Enumerate
The polynomial monad 
\begin_inset Formula $F^{A}\triangleq Z+W\times A$
\end_inset

, where 
\begin_inset Formula $W$
\end_inset

 is a monoid and 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
\end_layout

\begin_layout Enumerate
The free pointed monad 
\begin_inset Formula $L^{A}\triangleq A+F^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a monad.
\end_layout

\begin_layout Enumerate
The product monad 
\begin_inset Formula $L^{A}\triangleq F^{A}\times G^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are monads.
\end_layout

\begin_layout Enumerate
The monad 
\begin_inset Formula $L^{A}\triangleq F^{Z+W\times A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a monad, 
\begin_inset Formula $W$
\end_inset

 is a monoid, and 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
\end_layout

\begin_layout Standard
If we do not assume any existing monads and just keep applying these constructio
ns, we will obtain a number of polynomial monads.
 But are there any polynomial monads 
\emph on
not
\emph default
 obtained by a chain of these constructions?
\end_layout

\begin_layout Standard
For example, functors of the form 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times A$
\end_inset

, 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times A\times A$
\end_inset

, etc., cannot be obtained via these constructions.
 All those functors are not monads (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-co-pointed-applicative"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-co-pointed-applicative"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-pointed-applicative-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

, any co-pointed applicative functor of the form 
\begin_inset Formula $L^{A}\triangleq A\times G^{A}$
\end_inset

 satisfies the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-of-extract-and-zip"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-pointed-applicative-example-failing-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $L^{A}\triangleq Z\times\left(Z\rightarrow A\right)$
\end_inset

 is applicative and co-pointed but fails the compatibility law.
 Does there exist any co-pointed applicative functor that satisfies the
 law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-of-extract-and-zip"
plural "false"
caps "false"
noprefix "false"

\end_inset

) but is 
\emph on
not
\emph default
 of the form 
\begin_inset Formula $A\times G^{A}$
\end_inset

 with some applicative functor 
\begin_inset Formula $G$
\end_inset

? 
\begin_inset Note Note
status collapsed

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-traverse-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-traverse-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
(a)
\series default
 Show that the applicative naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 guarantee that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 collects each 
\begin_inset Formula $F$
\end_inset

-effect exactly once, or find another law that is necessary to guarantee
 that.
 (Can we use a composition of an applicative functor 
\begin_inset Formula $F$
\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad to count the number of times 
\begin_inset Formula $F$
\end_inset

-effects were collected?)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Monad transformers are defined in different ways for different monads.
 If someone comes up with a new monad, it is not certain that the new monad's
 transformer will be obtained through one of the known methods.
 Can we prove that a monad transformer will exist for every monad whose
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods are implemented via fully parametric code? Is there an algorithm
 that derives an implemenation of a monad transformer from the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 of an arbitrary given monad?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For certain monads 
\begin_inset Formula $L$
\end_inset

, the monad transformers 
\begin_inset Formula $T_{L}$
\end_inset

 can be defined using a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function.
 Is this always the case for any monad stacks built out of such monads?
 If each of the monads 
\begin_inset Formula $L_{1}$
\end_inset

, 
\begin_inset Formula $L_{2}$
\end_inset

, ..., 
\begin_inset Formula $L_{k}$
\end_inset

 admits a transformer defined via a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function, will the monad 
\begin_inset Formula $L_{1}\varangle L_{2}\varangle...\varangle L_{k}$
\end_inset

 also admit a transformer with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function? (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Does-a-composition-have-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for some partial results.)
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Rigid functors
\begin_inset Quotes erd
\end_inset

 are
\begin_inset Index idx
status open

\begin_layout Plain Layout
rigid functors!open questions
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Are there any rigid functors that are not monads? 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Are there any rigid functors that are not applicative?
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Is it true that any applicative rigid functor is a monad?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $L$
\end_inset

 be a fixed monad and 
\begin_inset Formula $H$
\end_inset

 be an 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctor.
 Then the functor 
\begin_inset Formula $F^{A}\triangleq H^{A}\rightarrow L^{A}$
\end_inset

 is a lawful monad (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-M-filterables"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 What is a monad transformer for the monad 
\begin_inset Formula $F$
\end_inset

? 
\end_layout

\begin_layout Standard
Two nontrivial examples of 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctors are 
\begin_inset Formula $H^{A}\triangleq A\rightarrow L^{Z}$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq L^{A}\rightarrow Z$
\end_inset

 (where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type).
 For these cases, the monad transformers are defined by:
\begin_inset Formula 
\begin{align*}
 & \text{monad: }(A\rightarrow L^{Z})\rightarrow L^{A}\quad,\quad\quad\text{transformer: }(A\rightarrow(L\varangle M)^{Z})\rightarrow(L\varangle M)^{A}\quad,\\
 & \text{monad: }(L^{A}\rightarrow Z)\rightarrow L^{A}\quad,\quad\quad\text{transformer: }((L\varangle M)^{A}\rightarrow Z)\rightarrow(L\varangle M)^{A}\quad,
\end{align*}

\end_inset

where the monad 
\begin_inset Formula $L$
\end_inset

's transformer (
\begin_inset Formula $L\varangle M$
\end_inset

) is considered known.
\end_layout

\begin_layout Standard
The problem is to implement the monad 
\begin_inset Formula $F$
\end_inset

's transformer for an arbitrary 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctor 
\begin_inset Formula $H$
\end_inset

 and to prove that the relevant laws hold.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume an arbitrary unknown monad 
\begin_inset Formula $M$
\end_inset

 and define recursively 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}$
\end_inset

.
 Can one define a lawful monad instance for the functor 
\begin_inset Formula $L$
\end_inset

? (This is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's transformer without the outer layer of 
\begin_inset Formula $M$
\end_inset

.
 See Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-effectful-list-not-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-2-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the monad transformer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 (here denoted just by 
\begin_inset Formula $T$
\end_inset

): 
\begin_inset Formula 
\[
T^{A}\triangleq M^{L^{A}}\quad,\quad\quad L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}\quad,
\]

\end_inset

where 
\begin_inset Formula $M$
\end_inset

 is an arbitrary foreign monad that we view as fixed.
 
\end_layout

\begin_layout Standard
Normally, we cannot implement a fully parametric base runner 
\begin_inset Formula $\text{brun}:T^{A}\rightarrow M^{A}$
\end_inset

 because we cannot have a fully parametric runner 
\begin_inset Formula $\text{List}^{A}\rightarrow A$
\end_inset

 operating on arbitrary types 
\begin_inset Formula $A$
\end_inset

.
 However, for a 
\emph on
monoid
\emph default
 type 
\begin_inset Formula $R$
\end_inset

 with binary operation 
\begin_inset Formula $\oplus_{R}$
\end_inset

 and empty element 
\begin_inset Formula $e_{R}$
\end_inset

, the type signature 
\begin_inset Formula $\text{List}^{R}\rightarrow R$
\end_inset

 is implemented by the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 operation: 
\begin_inset Formula 
\[
\text{reduce}:\text{List}^{R}\rightarrow R\quad,\quad\quad\text{reduce}\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline \bbnum 1 & 1\rightarrow e_{R}\\
R\times\text{List}^{R} & h\times t\rightarrow h\oplus_{R}\overline{\text{reduce}}\,(t)
\end{array}\quad.
\]

\end_inset

We can similarly implement a special base runner (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

) for the transformer 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 if we restrict its usage to 
\emph on
monoid
\emph default
 types 
\begin_inset Formula $R$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $M^{L^{R}}\rightarrow M^{R}$
\end_inset

 aggregates all elements of the effectful list into a single value of type
 
\begin_inset Formula $M^{R}$
\end_inset

 (which is also a monoid type):
\begin_inset Formula 
\[
\text{brunE}:M^{L^{R}}\rightarrow M^{R}\quad,\quad\quad\text{brunE}\triangleq\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{R}\\
\hline \bbnum 1 & 1\rightarrow\text{pu}_{M}(e_{R})\\
R\times M^{L^{R}} & h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brunE}}\,(t)
\end{array}\,\bigg)\quad.
\]

\end_inset

Here, we use the binary operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

 of the monoid 
\begin_inset Formula $M^{R}$
\end_inset

, which is defined by:
\begin_inset Formula 
\[
p^{:M^{R}}\oplus_{M}q^{:M^{R}}\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 a monoid morphism 
\begin_inset Formula $T^{A}\rightarrow A$
\end_inset

? (Note that 
\begin_inset Formula $T^{A}$
\end_inset

 is a monoid since 
\begin_inset Formula $T$
\end_inset

 is a lawful monad.) The monoid morphism identity law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

.
 Does the composition law hold?
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Do the monad morphism laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 hold when restricted to monoid types 
\begin_inset Formula $A$
\end_inset

?
\begin_inset Formula 
\begin{align*}
\text{for all monoid types }A:\quad & a^{:A}\triangleright\text{pu}_{T}\bef\text{brunE}=a^{:A}\triangleright\text{pu}_{M}\quad,\\
\text{composition law}:\quad & p^{:T^{T^{A}}}\triangleright\text{ftn}_{T}\bef\text{brunE }=p^{:T^{T^{A}}}\triangleright\text{brunE}\bef\text{brunE}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

(If so, Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 would show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 is also a 
\emph on
monoid
\emph default
 morphism 
\begin_inset Formula $M^{L^{A}}\rightarrow M^{A}$
\end_inset

.) 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Failed attempts to verify the composition law:
\end_layout

\begin_layout Plain Layout
Write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{T}\bef\text{brun}=\text{flm}_{M}(\text{prod})\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
\text{associativity of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}\bigg(\text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\bigg)\quad,\\
\text{right-hand side}:\quad & \text{brun}^{T^{R}}\bef\text{brun}^{\uparrow M}\bef\text{ftn}_{M}=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bigg)\bef\text{flm}_{M}(\text{brun})\\
\text{associativity of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\bigg)\quad.
\end{align*}

\end_inset

The remaining difference (under 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

) is an equation between functions of type 
\begin_inset Formula $L^{M^{L^{R}}}\rightarrow M^{R}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)=\text{prod}\bef\text{brun}\\
 & \quad\overset{?}{=}\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r^{:T^{R}}\times t^{:T^{T^{R}}}\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\quad.
\end{align*}

\end_inset

It is inconvenient to use matrices at this step because the code of 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

 is unknown.
 Instead, we will substitute into both sides an arbitrary value of type
 
\begin_inset Formula $L^{M^{L^{R}}}$
\end_inset

, which can be one of two possibilities, 
\begin_inset Formula $\text{Nil}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+h^{:T^{R}}\times t^{T^{T^{R}}}$
\end_inset

.
 Substituting 
\begin_inset Formula $\text{Nil}$
\end_inset

, we get:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \gunderline{\text{Nil}\triangleright\text{prod}}\bef\text{brun}=\text{Nil}\triangleright\text{pu}_{M}\bef\text{brun}\\
\text{use Eq.~(\ref{eq:listt-brun-derivation1})}:\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.\\
\text{right-hand side}:\quad & \text{Nil}\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=e_{T^{R}}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(\text{brun})=e_{R}\triangleright\gunderline{\text{pu}_{T}\bef\text{brun}}\\
\text{identity law of }\text{brun}:\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.
\end{align*}

\end_inset

The two sides are now equal.
 It remains to substitute the second possibility:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (\bbnum 0+h\times t)\triangleright\text{prod}\bef\text{brun}=\\
 & \quad=(\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\text{flm}_{M}(\overline{\text{prod}})
\end{array}\bef\text{brun}\\
 & \quad=\big(\text{comb}\,(h)(t\triangleright\text{flm}_{M}(\overline{\text{prod}}))\big)\triangleright\text{brun}\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\triangleright\xi\big)\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\xi\bef\text{brun}\big)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\big)\\
\text{right-hand side}:\quad & (\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=(\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t))\triangleright\text{flm}_{M}(\text{brun})\\
 & \quad=t\triangleright\overline{\text{brun}}\triangleright(v\rightarrow h\oplus_{R}v)^{\uparrow M}\triangleright\text{flm}_{M}(\text{brun})
\end{align*}

\end_inset

This is suspicious: we need to show that an expression 
\begin_inset Formula $h\triangleright\text{flm}_{M}(t\triangleright...)$
\end_inset

 is equal to 
\begin_inset Formula $t\triangleright...$
\end_inset

, and it seems impossible to convert one into another, given that 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

 are arbitrary values.
\end_layout

\begin_layout Plain Layout
Note that:
\begin_inset Formula 
\[
\text{pu}_{M}(r^{:R})\oplus_{M}q^{:M^{R}}=r\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M})=q\triangleright(v\rightarrow r\oplus_{R}v)^{\uparrow M}\quad.
\]

\end_inset

In particular,
\begin_inset Formula 
\[
\text{pu}_{M}(p)\oplus_{M}\text{pu}_{M}(q)=q\triangleright\text{pu}_{M}\triangleright(v\rightarrow p\oplus_{R}v)^{\uparrow M}=q\triangleright(v\rightarrow p\oplus_{R}v)\triangleright\text{pu}_{M}=\text{pu}_{M}(p\oplus_{R}q)\quad.
\]

\end_inset

We also have the property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \big(\text{comb}\,(p)(q)\big)\triangleright\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}(q\triangleright\xi)\bef\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}((q\triangleright\xi)\bef\text{flm}_{M}(g))\\
 & =p\triangleright\text{flm}_{M}\bigg(\begin{array}{||c|}
1\rightarrow q\\
h\times t\rightarrow\text{pu}_{M}\big(\bbnum 0+h\times\overline{\text{comb}}\,(t)(q)
\end{array}\,\bef\text{flm}_{M}(g)\bigg)
\end{align*}

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-monatron-lift-reset-and-shift"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-monatron-lift-reset-and-shift"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The continuation monad's operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reset
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shift
\end_layout

\end_inset

 are defined by:
\begin_inset Formula 
\begin{align*}
 & \text{reset}:\forall S.\,\text{Cont}^{R,R}\rightarrow\text{Cont}^{S,R}\quad,\quad\quad\text{reset}\triangleq c^{:\left(R\rightarrow R\right)\rightarrow R}\rightarrow k^{:R\rightarrow S}\rightarrow k(c(\text{id}))\quad,\\
 & \text{shift}:\forall A.\,((A\rightarrow R)\rightarrow\text{Cont}^{R,R})\rightarrow\text{Cont}^{R,A}\quad,\quad\quad\text{shift}\triangleq g^{:\left(A\rightarrow R\right)\rightarrow\text{Cont}^{R,R}}\rightarrow k^{:A\rightarrow R}\rightarrow g(k)(\text{id})\quad.
\end{align*}

\end_inset

How to lift these operations to an arbitrary monad stack 
\begin_inset Formula $P$
\end_inset

 that contains a continuation monad?
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/renormalist/pugs/blob/master/src/Pugs/AST/Eval.hs"
literal "false"

\end_inset


\family default
 for custom code (in Haskell) that lifts 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reset
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shift
\end_layout

\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT
\end_layout

\end_inset

 monad transformer.
\end_layout

\end_inset

 What are the appropriate type signatures for the lifted operations?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-unique-functor-liftings"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-unique-functor-liftings"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any fully parametric and covariant type constructor 
\begin_inset Formula $P$
\end_inset

, the lifting of a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to 
\begin_inset Formula $P$
\end_inset

 is performed via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method of 
\begin_inset Formula $P$
\end_inset

, so that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)
\end_layout

\end_inset

 is a function of type 
\begin_inset Formula $P^{A}\rightarrow P^{B}$
\end_inset

 denoted by 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 in this book.
 The standard code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is defined by induction on the type structure of 
\begin_inset Formula $P$
\end_inset

 and satisfies the functor laws, as shown in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The question is to show that there is no non-standard, alternative implementati
on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 that still satisfies the functor laws.
 If the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 is fully parametric, Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Uniqueness-of-functor-and-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 However, parametricity (or naturality) does not seem to follow from functor
 laws alone.
 Does there exist an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 that satisfies the functor laws but is 
\emph on
not
\emph default
 fully parametric?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-Peirce-law-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-Peirce-law-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove the type equivalence:
\begin_inset Formula 
\[
F^{P,Q}\triangleq\forall A.\,((A\rightarrow A)\rightarrow P)\rightarrow Q\cong P\rightarrow Q\quad,
\]

\end_inset

where functions of type 
\begin_inset Formula $F^{P,Q}$
\end_inset

 are required to be fully parametric.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://cstheory.stackexchange.com/questions/55588/"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An equivalent (but not actually simpler) question is to prove that: 
\begin_inset Formula 
\[
P\cong\exists A.\,(A\rightarrow A)\rightarrow P\quad.
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(solved by transitive closure union of relations?) Do I actually have a
 solution for this?
\end_layout

\end_inset


\end_layout

\end_body
\end_document
