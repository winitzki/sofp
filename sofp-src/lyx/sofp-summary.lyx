#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\end_layout

\begin_layout Chapter
Summary of the book
\begin_inset CommandInset label
LatexCommand label
name "chap:Summary-of-the"

\end_inset


\end_layout

\begin_layout Standard
The book has been written in a tutorial format, motivating and deriving
 the results gradually.
 This makes it easier to learn but harder to navigate.
 In this summary chapter, the results are listed without detailed explanations
 or proofs, referring to the places of the book where more detail is found.
\end_layout

\begin_layout Section
Main points and results by chapter
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{secnumdepth}{1}
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
All the following subsections will appear in the TOC but will be unnumbered.
 The koma-script package does not have addsubsec.
 Another solution could be: 
\end_layout

\begin_layout Plain Layout
% Package 'hyperref' needed for command '
\backslash
nameref'
\end_layout

\begin_layout Plain Layout

\backslash
subsection*{Introduction} 
\end_layout

\begin_layout Plain Layout

\backslash
label{subsec:intro} 
\end_layout

\begin_layout Plain Layout

\backslash
addcontentsline{toc}{subsection}{
\backslash
nameref{subsec:intro}}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:1-Values,-types,-expressions,"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Standard mathematical notation such as 
\begin_inset Formula $\sum_{n=1}^{100}(n^{2}+n)$
\end_inset

 implicitly uses nameless functions.
 Functional programming improves upon this kind of mathematical notation
 by using nameless functions explicitly and consistently.
 For example, the computation 
\begin_inset Formula $\sum_{n=1}^{100}(n^{2}+n)$
\end_inset

 is implemented in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to 100).map(n => n * n + n).sum
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

product
\end_layout

\end_inset

 are examples of 
\begin_inset Quotes eld
\end_inset

aggregations
\begin_inset Quotes erd
\end_inset

.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 selects some elements from a sequence; 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 truncates a sequence once a certain condition is achieved.
 Those methods are examples of 
\begin_inset Quotes eld
\end_inset

transformations
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Functional programming means formulating the solution of a problem as a
 mathematical expression and then translating the mathematical formula into
 code.
 Mathematical formulas do not use loops and do not modify variables.
 Instead, iteration is expressed using special operators such as 
\begin_inset Formula $\sum$
\end_inset

.
 Functional programming encodes transformations and aggregations by using
 standard library functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, etc., instead of loops.
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Disjunctive-types"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Higher-order-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:5-Curry-Howard"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Reasoning-about-code"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Typeclasses-and-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Filterable-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Semimonads-and-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:9-Traversable-functors-and"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Free-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
***
\end_layout

\begin_layout Subsection
Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:Proofs-of-naturality-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
This appendix studies 
\begin_inset Quotes eld
\end_inset

parametricity
\begin_inset Quotes erd
\end_inset

 properties that apply to all fully parametric code:
\end_layout

\begin_layout Standard
A given type constructor may have one fully parametric and lawful implementation
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Contrafunctor
\end_layout

\end_inset

 typeclass instance.
 (For most other typeclasses, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, type constructors often have several inequivalent and lawful typeclass
 instances.) The unique implementations are defined by the type constructions
 from Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Contrafunctor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The lifting methods of any fully parametric bifunctor, profunctor, or bi-contraf
unctor obey the commutativity law such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
Any fully parametric expression 
\begin_inset Formula $t:\forall A.\,Q^{A}$
\end_inset

 satisfies the relational naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In general, the relational naturality law expresses a property of 
\emph on
relations
\emph default
 rather than functions and is not equivalent to any equation satisfied by
 
\begin_inset Formula $t$
\end_inset

.
 The chapter explains how relations are defined and what operations are
 available for relations, and shows the proof of the relational naturality
 law.
\end_layout

\begin_layout Standard
All fully parametric functions of type 
\begin_inset Formula $P^{A,A}\rightarrow Q^{A,A}$
\end_inset

 (where 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 are profunctors) obey the dinaturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dinaturality-law-for-profunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The form of the law depends only on the function's type signature and applies
 to all fully parametric implementations of that type signature.
\end_layout

\begin_layout Standard
If the type signature of 
\begin_inset Formula $t$
\end_inset

 satisfies the conditions of Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-post-wedge-entails-strong-dinaturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 or
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-functor-post-pre-wedge"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the function 
\begin_inset Formula $t$
\end_inset

 satisfies the 
\begin_inset Quotes eld
\end_inset

strong dinaturality
\begin_inset Quotes erd
\end_inset

 law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:strong-dinaturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Strong dinaturality gives more information than the ordinary dinaturality
 law and is simpler to use than the general relational naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:relational-naturality-law-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{secnumdepth}{3}
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Restore the normal numbering of subsections and subsubsections
\end_layout

\end_inset


\end_layout

\begin_layout Section
Topics not covered in this book
\end_layout

\begin_layout Standard
This book focuses on mathematical theory that has proven its relevance to
 the functional programming practice.
 This section lists some topics that were omitted from this edition of the
 book, and explains why.
\end_layout

\begin_layout Subsection
Trampolines and stack-safe recursion in functor blocks
\end_layout

\begin_layout Standard
Recursion with applicative and monadic functors (say, a loop with the free
 monad) can lead to stack overflows when the nesting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods becomes too deep.
 There are certain tricks that can be used to ensure stack safety.
 One of those tricks is known as 
\begin_inset Quotes eld
\end_inset

trampolines
\begin_inset Quotes erd
\end_inset

.
 Another trick is to use stack-safe implementations of various monads.
 
\end_layout

\begin_layout Standard
This book does not discuss those tricks in detail.
 Trampolines are already well described in the book 
\begin_inset Quotes eld
\end_inset

Functional programming in Scala
\begin_inset Quotes erd
\end_inset

.
 Stack-safe implementations of standard monads have better performance but
 are mathematically equivalent to the same monads implemented via simple,
 non-stack-safe code.
 There is no new theory to be developed and no new laws to be proved about
 stack-safe code.
\end_layout

\begin_layout Subsection
Strictness and laziness
\end_layout

\begin_layout Standard
Scala can define values via one of the three evaluation policies: eager
 (also known as 
\begin_inset Quotes eld
\end_inset

strict
\begin_inset Quotes erd
\end_inset

), lazy, or on-demand.
 Eager values are computed immediately as they are defined; lazy values
 are computed only on first use and then stored in memory; on-demand values
 are computed every time they are used.
 
\end_layout

\begin_layout Standard
In the functional programming paradigm, it is rare that an algorithm or
 a data structure works correctly only when certain values are defined as
 lazy.
 This book focuses on the properties of functional programs and their types
 that do not use strictness or laziness in an essential way.
 For instance, the laws of a functor are the same and need to be verified
 via the same proof regardless of whether the program code uses strict or
 lazy functor values.
 
\end_layout

\begin_layout Subsection
Combined typeclasses and their laws
\end_layout

\begin_layout Standard
Sequences and trees are perhaps the most frequently used data structures.
 Those data structures have at once the properties of several typeclasses:
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

.
 It turns out that the methods of various typeclasses satisfy not only the
 laws of their own typeclass but also additional laws that express a kind
 of compatibility between different typeclasses.
 For example, the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-deflate-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) expresses compatibility between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Filterable
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 methods.
\end_layout

\begin_layout Standard
This book does not systematically study the possible combinations between
 the major typeclasses and the possible compatibility laws that could be
 imposed.
 There does not seem to be a general way of motivating and deriving the
 properties and laws of combined typeclasses.
\end_layout

\begin_layout Subsection
Lenses, prisms, and other 
\begin_inset Quotes eld
\end_inset

functional optics
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Lenses are a type constructor with methods that represent the operations
 of reading and updating a part of a large data structure while keeping
 all other parts unchanged.
 The theory of lenses is complicated and does not seem to have been fully
 developed, while practical applications are limited.
\end_layout

\begin_layout Subsection
Comonads and comonad transformers
\end_layout

\begin_layout Standard
A comonad is a functor 
\begin_inset Formula $F$
\end_inset

 with two additional methods called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extract
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

duplicate
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{ex}_{F}:\forall A.\,F^{A}\rightarrow A\quad,\quad\quad\text{dupl}_{F}:\forall A.\,F^{A}\rightarrow F^{F^{A}}\quad.
\]

\end_inset

The type signatures of those methods are similar to the type signatures
 of the monads' methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 except that the function arrows point in the opposite direction:
\begin_inset Formula 
\[
\text{pu}_{F}:\forall A.\,A\rightarrow F^{A}\quad,\quad\quad\text{ftn}_{F}:\forall A.\,F^{F^{A}}\rightarrow F^{A}\quad.
\]

\end_inset

The comonad's methods must also satisfy the appropriate laws.
 Similarly to monads, two comonads can be combined via 
\begin_inset Quotes eld
\end_inset

comonad transformers
\begin_inset Quotes erd
\end_inset

 into a larger comonad.
 An example of a comonad is the non-empty list (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
Although comonads are in some sense analogous to monads, this book does
 not develop the corresponding theory because comonads do not appear to
 have a wide range of applications in practical programming.
\end_layout

\begin_layout Subsection
Dependent types
\end_layout

\begin_layout Standard
Scala has limited support for dependent types
\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent type
\end_layout

\end_inset

 (or 
\begin_inset Quotes eld
\end_inset

value-to-type functions
\begin_inset Quotes erd
\end_inset

).
 While there are occasional uses for those types in some Scala libraries,
 most functional programming practice today is formulated with traditional
 types that are fully determined at compile time and do not depend on run-time
 values.
 This book does not develop the theory of dependent types as that theory
 is quite complicated and yet limited in practical applications.
\end_layout

\begin_layout Subsection
Linear types and other non-standard types
\end_layout

\begin_layout Standard
Some programming languages include features that go beyond the type system
 described in this book.
 For example, the Rust language has special features of the type system
 that describe memory allocation lifetimes.
 In that way, Rust programs can manage memory allocations explicitly and
 verify at compile time that no data is deallocated from memory at the wrong
 place.
\end_layout

\begin_layout Standard
Features of that kind are complicated and not widely used.
 This book focuses on the type system features that are both widely used
 and well-understood.
\end_layout

\begin_layout Section
Additional exercises and problems
\begin_inset CommandInset label
LatexCommand label
name "chap:Exercises-in-AFTT"

\end_inset


\end_layout

\begin_layout Standard
The following is a sample set of problems that can be solved using techniques
 developed in this book.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the smallest integer expressible as a sum of two cubed integers in
 more than one way.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-18"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-18"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following type signatures have 
\emph on
no
\emph default
 fully parametric implementations:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: Option[A] => A
\end_layout

\begin_layout Plain Layout

def g[A, B]: (A => B) => A
\end_layout

\begin_layout Plain Layout

def h[A, B]: (A => B) => (B => A)
\end_layout

\begin_layout Plain Layout

def k[A, B, C]: (A => B) => (B => C) => (C => A)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: set some type parameters to the void type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

norepeat
\end_layout

\end_inset

 that removes consecutive repetitions from sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def norepeat[A]: Seq[A] => Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> norepeat(Seq(1, 2, 2, 1, 1, 3, 3, 3, 0, 3))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = Seq(1,2,1,3,0,3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Read a text file, split it by spaces into words, and print the word counts
 in decreasing order.
\begin_inset Note Comment
status open

\begin_layout Enumerate
FPIS exercise 2.2: Check whether a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 is sorted according to a given ordering function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A) => Boolean
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
FPIS exercise 3.24: Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hasSubsequence
\end_layout

\end_inset

 that checks whether a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 contains another 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 as a subsequence.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2,3,4)
\end_layout

\end_inset

 would have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1,2)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(2,3)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(4)
\end_layout

\end_inset

 as subsequences, among others.
 (Dynamic programming?)
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The Seasoned Schemer, chapter 13: Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def remberUptoLast[A](a: A, s: List[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

def remberBeyondLast[A](a: A, s: List[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> remberUptoLast(4, List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

List(5, 6, 7, 8)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> remberBeyondLast(4, List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

List(1, 2, 3, 4, 5)
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 removes all elements from a list up to and including the last occurrence
 of a given value.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

 removes all elements from a list starting from the last occurrence of a
 given value.
 Both functions return the original list if the given value does not occur
 in the list.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
We first define extension method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lastOption
\end_layout

\end_inset

 for Scala's Iterator:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class IteratorOps[A](val it: Iterator[A]) extends AnyVal {
\end_layout

\begin_layout Plain Layout

  def lastOption: Option[A] = {
\end_layout

\begin_layout Plain Layout

   @tailrec def lastKnown(x: A): Some[A] = if (it.hasNext) lastKnown(it.next)
 else Some(x)
\end_layout

\begin_layout Plain Layout

   if (it.hasNext) lastKnown(it.next) else None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Then the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberUptoLast
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

remberBeyondLast
\end_layout

\end_inset

 is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def remberUptoLast[A](a: A, s: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  s.tails.filter(_.headOption contains a).lastOption.map(_.tail).getOrElse(s)
\end_layout

\begin_layout Plain Layout

def remberBeyondLast[A](a: A, s: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  s.reverse.tails.filter(_.headOption contains a).nextOption.map(_.tail.reverse).getOrEls
e(s)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
(Exercise 4-1 from Hu Zhenjiang's course 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://www.prg.nii.ac.jp/course/2015/msp15/"
literal "false"

\end_inset


\family default
) Express the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method for sequences via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filter[A](p: A => Boolean)(s: Seq[A]): Seq[A] = s.flatMap { a => ???
 }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a monoid of partial functions with fixed types 
\begin_inset Formula $P\rightarrow Q$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class PFM[P, Q](pf: PartialFunction[P, Q])
\end_layout

\begin_layout Plain Layout

// After defining a monoid instance, the following code must work:
\end_layout

\begin_layout Plain Layout

val p1 = PFM[Option[Int], String] { case Some(3) => 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

 }
\end_layout

\begin_layout Plain Layout

val p2 = PFM[Option[Int], String] {
\end_layout

\begin_layout Plain Layout

  case Some(20)   => 
\begin_inset Quotes eld
\end_inset

twenty
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case None       => 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

val p3 = p1 |+| p2 // Must be the same as the concatenation of all `case`
 clauses.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-6-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-6-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This was posted in 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://cstheory.stackexchange.com/questions/53294"
literal "false"

\end_inset


\end_layout

\end_inset

 a general type signature for the expression 
\begin_inset Formula $a\rightarrow a(y\rightarrow t\rightarrow t)(z(a))$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
(Bird-de Moor, page 20) Derive the following identity between functions
 
\begin_inset Formula $F^{A}\rightarrow F^{A}$
\end_inset

, for any filterable functor 
\begin_inset Formula $F$
\end_inset

 and any predicate 
\begin_inset Formula $p^{:A\rightarrow\bbnum 2}$
\end_inset

: 
\begin_inset Formula 
\[
\text{filt}_{F}(p)=(\Delta\bef\text{id}\boxtimes p)^{\uparrow F}\bef\text{filt}_{F}(\pi_{2})\bef\pi_{1}^{\uparrow F}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider a typeclass called 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Splittable
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 for functors
\begin_inset Index idx
status open

\begin_layout Plain Layout
splittable functors
\end_layout

\end_inset

 
\begin_inset Formula $F$
\end_inset

 that have an additional method:
\begin_inset Formula 
\[
\text{split}^{A,B}:F^{A+B}\rightarrow F^{A}+B\quad,
\]

\end_inset

satisfying a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
non-degeneracy law!of splittable functors
\end_layout

\end_inset

non-degeneracy law:
\begin_inset Formula 
\[
(x^{:A}\rightarrow x+\bbnum 0^{:B})^{\uparrow F}\bef\text{split}=y^{:F^{A}}\rightarrow y+\bbnum 0^{:B}\quad,
\]

\end_inset

and a special associativity law
\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of splittable functors
\end_layout

\end_inset

, which is an equation for functions of type 
\begin_inset Formula $F^{A+B+C}\rightarrow F^{A}+B+C$
\end_inset

:
\begin_inset Formula 
\[
\text{split}^{A+B,C}\bef\,\begin{array}{|c||cc|}
 & F^{A}+B & C\\
\hline F^{A+B} & \text{split}^{A,B} & \bbnum 0\\
C & \bbnum 0 & \text{id}
\end{array}\,=\text{split}^{A,B+C}\quad.
\]

\end_inset

Show that all polynomial functors 
\begin_inset Formula $F^{\bullet}$
\end_inset

 belong to this typeclass.
 Show that exponential functors such as 
\begin_inset Formula $F^{A}\triangleq Z\rightarrow A$
\end_inset

 do not belong to this typeclass.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-6-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-6-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence: L[F[A]] => F[L[A]]
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\text{seq}_{L}^{F}$
\end_inset

) that assumes a traversable functor 
\begin_inset Formula $L$
\end_inset

 and an applicative functor 
\begin_inset Formula $F$
\end_inset

.
 If we set 
\begin_inset Formula $F=\text{List}$
\end_inset

 and also 
\begin_inset Formula $L=\text{List}$
\end_inset

 then we obtain the type signature 
\begin_inset Formula $\text{seq}_{\text{List}}^{\text{List}}:\text{List}^{\text{List}^{A}}\rightarrow\text{List}^{\text{List}^{A}}$
\end_inset

.
 A data structure of type 
\begin_inset Formula $\text{List}^{\text{List}^{A}}$
\end_inset

 may be used to represent a rectangular matrix.
 Show that the function 
\begin_inset Formula $\text{seq}_{\text{List}}^{\text{List}}$
\end_inset

 transposes the rectangular matrix.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a monad 
\begin_inset Formula $M$
\end_inset

 and a fixed type 
\begin_inset Formula $Z$
\end_inset

, consider the functor 
\begin_inset Formula $F^{A}\triangleq(A\rightarrow M^{Z})\rightarrow Z$
\end_inset

.
 Show that 
\begin_inset Formula $F$
\end_inset

 is a semimonad but not a full monad.
 Hint: use the flipped Kleisli technique.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 that are not known to be equivalent, consider the contrafunctors 
\begin_inset Formula $F^{A}\triangleq\left(\left(A\rightarrow P\right)\rightarrow P\right)\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $G^{A}\triangleq A\rightarrow Q$
\end_inset

.
 Show that there exist natural transformations 
\begin_inset Formula $F^{\bullet}\leadsto G^{\bullet}$
\end_inset

 and 
\begin_inset Formula $G^{\bullet}\leadsto F^{\bullet}$
\end_inset

.
 Show that these transformations are 
\emph on
not
\emph default
 isomorphisms.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 that are not known to be equivalent, show that the functor 
\begin_inset Formula $L^{A}\triangleq\left(\left(\left(A\rightarrow P\right)\rightarrow Q\right)\rightarrow Q\right)\rightarrow P$
\end_inset

 is a semimonad but not a full monad.
 (When 
\begin_inset Formula $P\cong Q$
\end_inset

, the functor 
\begin_inset Formula $L$
\end_inset

 is also not a full monad because 
\begin_inset Formula $L$
\end_inset

 is then equivalent to a composition of the continuation monad with itself.
 See Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-composition-mm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-9-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-9-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any fully parametric contrafunctor 
\begin_inset Formula $F^{A}$
\end_inset

 that does not explicitly use the void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 (
\begin_inset Formula $\bbnum 0$
\end_inset

) in its type expression, show that the type of fully parametric functions
 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow A$
\end_inset

 is void.
 Show that the condition of not using the void type is necessary, as the
 contrafunctor 
\begin_inset Formula $F^{A}\triangleq(\bbnum 0\rightarrow A)\rightarrow\bbnum 0$
\end_inset

 would be a counterexample:
\begin_inset Formula 
\[
\forall A.\,F^{A}\rightarrow A=\forall A.\,((\bbnum 0\rightarrow A)\rightarrow\bbnum 0)\rightarrow A\cong((\bbnum 0\rightarrow\bbnum 0)\rightarrow\bbnum 0)\rightarrow\bbnum 0\cong\bbnum 1\quad.
\]

\end_inset

The type equivalence 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow A\cong\bbnum 0$
\end_inset

 means that we cannot extract values of type 
\begin_inset Formula $A$
\end_inset

 from a value of type 
\begin_inset Formula $F^{A}$
\end_inset

.
 This agrees with the intuition that a contrafunctor type (
\begin_inset Formula $F^{A}$
\end_inset

) 
\begin_inset Quotes eld
\end_inset

does not contain
\begin_inset Quotes erd
\end_inset

 any values of type 
\begin_inset Formula $A$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
By Yoneda we have 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow A\cong F^{\bbnum 0}\rightarrow\bbnum 0$
\end_inset

.
 Now we need to show that 
\begin_inset Formula $F^{\bbnum 0}\not\cong\bbnum 0$
\end_inset

 for any contrafunctor 
\begin_inset Formula $F$
\end_inset

 as long as 
\begin_inset Formula $F$
\end_inset

's type expression does not use the void type explicitly as one of its constant
 types.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is any monad then 
\begin_inset Formula $M^{A+M^{A}}$
\end_inset

 is also a lawful monad.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is a semimonad then 
\begin_inset Formula $M\circ M\circ...\circ M$
\end_inset

 (with finitely many 
\begin_inset Formula $M$
\end_inset

) is also a lawful semimonad.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

 is a commutative monad then 
\begin_inset Formula $M\circ M$
\end_inset

 is also a lawful commutative monad.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-13"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-13"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M^{\bullet}$
\end_inset

 is a commutative monad and 
\begin_inset Formula $W$
\end_inset

 is a commutative monoid then the monoid 
\begin_inset Formula $M^{W}$
\end_inset

 is commutative.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-14"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-14"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 representing 
\begin_inset Quotes eld
\end_inset

triangular matrices
\begin_inset Quotes erd
\end_inset

 with elements of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Example values 
\begin_inset Formula $t_{1}$
\end_inset

, 
\begin_inset Formula $t_{2}$
\end_inset

, 
\begin_inset Formula $t_{3}$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 are:
\begin_inset Formula 
\[
t_{1}=\left|\begin{array}{c}
a_{1}\end{array}\right|\quad,\quad\quad t_{2}=\left|\begin{array}{cc}
a_{1}\\
a_{2} & a_{3}
\end{array}\right|\quad,\quad\quad t_{3}=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{4} & a_{5} & a_{6}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad.
\]

\end_inset

Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

, it should 
\emph on
not
\emph default
 be possible to have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang[A]
\end_layout

\end_inset

 that has an unexpected shape:
\begin_inset Formula 
\[
t=\left|\begin{array}{cccc}
a_{1}\\
a_{2} & a_{3}\\
a_{7} & a_{8} & a_{9} & a_{10}
\end{array}\right|\quad\text{is not of type }\text{Triang}^{A}\quad.
\]

\end_inset

 Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Applicative
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Traversable
\end_layout

\end_inset

 instances for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Triang
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-15"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-15"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the Curry-Howard correspondence
\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

 and the algorithms LJ or LJT
\begin_inset Index idx
status open

\begin_layout Plain Layout
LJT algorithm
\end_layout

\end_inset

 to prove that there exists only one fully parametric function with type
 signature 
\begin_inset Formula $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow A$
\end_inset

, or in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: ((A => A) => A) => A
\end_layout

\end_inset

From that, prove the type equivalence 
\begin_inset Formula $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow A\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-Peirce-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-Peirce-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the functor 
\begin_inset Formula $F^{R}$
\end_inset

 defined by:
\begin_inset Formula 
\[
F^{R}\triangleq\forall A.\,((A\rightarrow R)\rightarrow A)\rightarrow A\quad,
\]

\end_inset

where all functions of type 
\begin_inset Formula $F^{R}$
\end_inset

 are assumed to be fully parametric.
 Show that 
\begin_inset Formula $F^{R}\cong R$
\end_inset

.
\end_layout

\begin_layout Standard
Note that 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Peirce's law
\end_layout

\end_inset

Peirce's law (see Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-3-peirce-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

)) is expressed as the type 
\begin_inset Formula $\forall R.\,F^{R}$
\end_inset

.
 Peirce's law does not hold in the constructive logic.
 The Curry-Howard correspondence says that the corresponding type 
\begin_inset Formula $\forall R.\,F^{R}$
\end_inset

 should be void, and it is: 
\begin_inset Formula $\forall R.\,F^{R}=\forall R.\,R=\bbnum 0$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-Peirce-law-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-Peirce-law-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the profunctor 
\begin_inset Formula $F^{R,S}$
\end_inset

 defined by:
\begin_inset Formula 
\[
F^{R,S}\triangleq\forall A.\,((A\rightarrow A)\rightarrow R)\rightarrow S\quad,
\]

\end_inset

where all functions of type 
\begin_inset Formula $F^{R,S}$
\end_inset

 are assumed to be fully parametric.
 
\end_layout

\begin_layout Standard
An equivalent (but not actually simpler) type expression is:
\begin_inset Formula 
\[
F^{R,S}\triangleq(\exists A.\,(A\rightarrow A)\rightarrow R)\rightarrow S\quad.
\]

\end_inset

So, we have 
\begin_inset Formula $F^{R,S}=G^{R}\rightarrow S$
\end_inset

, where the functor 
\begin_inset Formula $G^{R}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
G^{R}\triangleq\exists A.\,(A\rightarrow A)\rightarrow R\quad.
\]

\end_inset

Show that 
\begin_inset Formula $G^{R}\cong R$
\end_inset

 and 
\begin_inset Formula $F^{R,S}\cong R\rightarrow S$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(solved by transitive closure union of relations)
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
There exist fully parametric functions with type signatures 
\begin_inset Formula $F^{R,S}\rightarrow R\rightarrow S$
\end_inset

 and 
\begin_inset Formula $(R\rightarrow S)\rightarrow F^{R,S}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{out}:F^{R,S}\rightarrow R\rightarrow S\quad, & \quad\quad\text{out}\triangleq f^{:\forall A.\,((A\rightarrow A)\rightarrow R)\rightarrow S}\rightarrow r^{:R}\rightarrow f^{\bbnum 1}(\_^{:\bbnum 1\rightarrow\bbnum 1}\rightarrow r)\quad,\\
\text{in}:(R\rightarrow S)\rightarrow F^{R,S}\quad, & \quad\quad\text{in}\triangleq k^{:R\rightarrow S}\rightarrow\forall A.\,p^{:(A\rightarrow A)\rightarrow R}\rightarrow k(p(\text{id}^{:A\rightarrow A}))\quad.
\end{align*}

\end_inset

There exist infinitely many fully parametric functions 
\begin_inset Formula $\phi:F^{R,S}\rightarrow F^{R,S}$
\end_inset

 that are not obviously equal to an identity function.
 To see an example, consider the following functions 
\begin_inset Formula $\phi_{n}$
\end_inset

 defined for 
\begin_inset Formula $n=0,1,2,...$
\end_inset

 by:
\begin_inset Formula 
\begin{align*}
 & \phi_{n}^{R,S}:\left(\forall A.\,((A\rightarrow A)\rightarrow R)\rightarrow S\right)\rightarrow\forall B.\,((B\rightarrow B)\rightarrow R)\rightarrow S\quad,\\
 & \phi_{n}\triangleq f^{:\forall A.\,((A\rightarrow A)\rightarrow R)\rightarrow S}\rightarrow\forall B.\,p^{:\left(B\rightarrow B\right)\rightarrow R}\rightarrow f^{B}(k^{:B\rightarrow B}\rightarrow p(\underbrace{k\bef k\bef...\bef k}_{n\text{ times}}))\quad.
\end{align*}

\end_inset

When 
\begin_inset Formula $n=0$
\end_inset

 we write 
\begin_inset Formula $p(\text{id})$
\end_inset

 instead of 
\begin_inset Formula $p(k\bef k\bef...\bef k)$
\end_inset

.
 It is curious that the composition of 
\begin_inset Formula $\phi_{m}$
\end_inset

 and 
\begin_inset Formula $\phi_{n}$
\end_inset

 is equal to 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\text{compute }\phi_{3}\bef\phi_{2}:\quad & \left(f\rightarrow p\rightarrow f(k\rightarrow p(k\bef k\bef k))\right)\bef\left(g\rightarrow q\rightarrow g(l\rightarrow q(l\bef l))\right)\\
 & =f\rightarrow q\rightarrow\left(p\rightarrow f(k\rightarrow p(k\bef k\bef k))\right)\left(l\rightarrow q(l\bef l)\right)\\
 & =f\rightarrow q\rightarrow f(k\rightarrow(k\bef k\bef k)\triangleright\left(l\rightarrow q(l\bef l)\right)\\
 & =f\rightarrow q\rightarrow f(k\rightarrow q(k\bef k\bef k\bef k\bef k\bef k))\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\begin_inset Formula $\phi_{m*n}$
\end_inset

.
 The function 
\begin_inset Formula $\phi_{1}$
\end_inset

 equals identity, but it is not clear how to show that all other 
\begin_inset Formula $\phi_{n}$
\end_inset

 are also equal to identity.
 The general type signature of 
\begin_inset Formula $\phi_{n}$
\end_inset

 is 
\begin_inset Formula $\forall(R,S).\,F^{R,S}\rightarrow F^{R,S}$
\end_inset

.
 If we had the equivalence 
\begin_inset Formula $F^{R,S}\cong R\rightarrow S$
\end_inset

, all the functions 
\begin_inset Formula $\phi_{n}$
\end_inset

 would have type signature 
\begin_inset Formula $\forall(R,S).\,(R\rightarrow S)\rightarrow R\rightarrow S$
\end_inset

.
 But there exists only one fully parametric function with that type signature
 (the identity function).
 If we can show that 
\begin_inset Formula $\phi_{n}\neq\text{id}$
\end_inset

 for some 
\begin_inset Formula $n$
\end_inset

 then it will follow that 
\begin_inset Formula $F^{R,S}\not\cong R\rightarrow S$
\end_inset

.
  This is wrong, as all functions 
\begin_inset Formula $k$
\end_inset

 that we are allowed to use by parametricity are identity functions, so
 there is no difference between 
\begin_inset Formula $\text{id}$
\end_inset

, 
\begin_inset Formula $k$
\end_inset

, 
\begin_inset Formula $k\bef k$
\end_inset

, etc.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-Peirce-law-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-Peirce-law-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove the following type equivalences (assuming fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, ...):
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Quantified type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Equivalent type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,(A\rightarrow A)\rightarrow P$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,(A\rightarrow A)\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,(A\rightarrow A)\rightarrow A+P$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,(A\rightarrow A)\rightarrow A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{List}^{\bbnum 1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,((A\rightarrow A)\rightarrow A)\rightarrow P$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P$
\end_inset

?
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the type constructor 
\begin_inset Formula $F^{R,S}$
\end_inset

 defined by:
\begin_inset Formula 
\[
F^{R,S}\triangleq\forall A.\,((R\rightarrow A)\rightarrow S)\rightarrow A\quad,
\]

\end_inset

where all functions of type 
\begin_inset Formula $F^{R,S}$
\end_inset

 are assumed to be fully parametric.
 Show that 
\begin_inset Formula $F^{R,S}\cong\bbnum 0$
\end_inset

 unless we set 
\begin_inset Formula $R=S=\bbnum 0$
\end_inset

, in which case 
\begin_inset Formula $F^{\bbnum 0,\bbnum 0}\cong\bbnum 1$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
By Yoneda, 
\begin_inset Formula $F^{R,S}=((R\rightarrow\bbnum 0)\rightarrow S)\rightarrow\bbnum 0$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a monad transformer 
\begin_inset Formula $T_{\text{Cod}_{F}^{L}}^{M,A}$
\end_inset

 for the composed codensity monad (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-combined-codensity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with type parameters 
\begin_inset Formula $F$
\end_inset

 (an arbitrary but fixed functor), 
\begin_inset Formula $L$
\end_inset

 (an arbitrary but fixed monad), 
\begin_inset Formula $M$
\end_inset

 (a foreign monad), and 
\begin_inset Formula $A$
\end_inset

 (the value type).
 Find out which laws hold for that transformer.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-16-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the (non-covariant) type constructor 
\begin_inset Formula $G^{A}\triangleq A\rightarrow A$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/72490608/"
literal "false"

\end_inset


\family default
 for discussion about monads having multiple transformers.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that codensity monad on 
\begin_inset Formula $G$
\end_inset

 (
\begin_inset Formula $\text{Cod}^{G,\bullet}$
\end_inset

) is equivalent to 
\begin_inset Formula $\text{List}^{\bullet}$
\end_inset

 via monad morphisms.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the corresponding monad transformer: 
\begin_inset Formula 
\[
T_{\text{Cod}^{G}}^{M,A}\triangleq\forall R.\,(A\rightarrow M^{G^{R}})\rightarrow M^{G^{R}}=\forall R.\,(A\rightarrow M^{R\rightarrow R})\rightarrow M^{R\rightarrow R}
\]

\end_inset

is 
\emph on
not
\emph default
 equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's standard transformer (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

) shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Transformer-for-the-List-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that the type constructor 
\begin_inset Formula $U$
\end_inset

 defined by:
\begin_inset Formula 
\[
U^{M^{\bullet},A}\triangleq\forall R.\,(A\rightarrow G^{M^{R}})\rightarrow G^{M^{R}}=\forall R.\,(A\rightarrow M^{R}\rightarrow M^{R})\rightarrow M^{R}\rightarrow M^{R}
\]

\end_inset

is also a lawful monad transformer (with the foreign monad 
\begin_inset Formula $M$
\end_inset

) for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad.
 Show that the transformer 
\begin_inset Formula $U$
\end_inset

 (known as the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LogicT
\end_layout

\end_inset

 monad transformer
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Bodigrim/logict"
literal "false"

\end_inset


\family default
 for an example implementation in Haskell.
\end_layout

\end_inset

) is not equivalent to that defined in 
\series bold
(b)
\series default
.
 
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 Generalize 
\series bold
(c)
\series default
 using an arbitrary (covariant) functor 
\begin_inset Formula $F$
\end_inset

 and two fixed types 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\[
V^{F^{\bullet},P,Q,M^{\bullet},A}\triangleq\forall R.\,(A\rightarrow F^{M^{R}}\rightarrow P\times M^{R}+Q)\rightarrow F^{M^{R}}\rightarrow P\times M^{R}+Q\quad.
\]

\end_inset

Show that there exists a monad morphism 
\begin_inset Formula $M^{A}\rightarrow V^{F^{\bullet},P,Q,M^{\bullet},A}$
\end_inset

, and that the converse function of type 
\begin_inset Formula $V^{F^{\bullet},P,Q,M^{\bullet},A}\rightarrow M^{A}$
\end_inset

 exists when 
\begin_inset Formula $Q=\bbnum 0$
\end_inset

 (but is 
\emph on
not
\emph default
 a monad morphism).
\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 Show that the Church-encoded free monoid on 
\begin_inset Formula $A$
\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Church-encodings-for-free-P-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{FM}^{A}\triangleq\forall X^{:\text{Monoid}}.\,(A\rightarrow X)\rightarrow X
\]

\end_inset

can be modified to the type constructor denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FMT
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{FMT}^{M^{\bullet},A}\triangleq\forall X^{:\text{Monoid}}.\,(A\rightarrow M^{X})\rightarrow M^{X}\quad,
\]

\end_inset

which is a lawful monad transformer (with the foreign monad 
\begin_inset Formula $M$
\end_inset

) for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad.
 Show that this transformer is not equivalent to the transformers defined
 in 
\series bold
(b)
\series default
, 
\series bold
(c)
\series default
.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-additional-17"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-17"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For any fixed type 
\begin_inset Formula $Z$
\end_inset

, functor 
\begin_inset Formula $F$
\end_inset

 and lawful monad 
\begin_inset Formula $P$
\end_inset

, show that 
\begin_inset Formula $L^{A}\triangleq F^{A\rightarrow P^{Z}}\rightarrow P^{A}$
\end_inset

 is a lawful monad.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that 
\begin_inset Formula $L$
\end_inset

's monad transformer is 
\begin_inset Formula $T_{L}^{M,A}\triangleq F^{A\rightarrow T_{P}^{M,Z}}\rightarrow T_{P}^{M,A}$
\end_inset

, where 
\begin_inset Formula $T_{P}^{M,A}$
\end_inset

 is 
\begin_inset Formula $P$
\end_inset

's monad transformer.
\end_layout

\begin_layout Subsection
Open problems
\begin_inset Index idx
status open

\begin_layout Plain Layout
open problems
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The author of this book does not know how to answer the following questions
 and also could not find any answers in existing books or papers.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Do all polynomial functors of the form 
\begin_inset Formula $P_{n}^{A}\triangleq\bbnum 1+\overbrace{A\times A\times...\times A}^{n\text{ times, }n\ge2}$
\end_inset

 fail to be monads? An example is the functor 
\begin_inset Formula $P_{2}^{A}\triangleq\bbnum 1+A\times A$
\end_inset

, which is not a monad because all possible implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods for 
\begin_inset Formula $P_{2}$
\end_inset

 fail the monad laws.
\begin_inset Foot
status open

\begin_layout Plain Layout
See discussion here: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/49742377"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-polynomial-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows four constructions that make new monads:
\end_layout

\begin_layout Enumerate
The polynomial monad 
\begin_inset Formula $F^{A}\triangleq Z+W\times A$
\end_inset

, where 
\begin_inset Formula $W$
\end_inset

 is a monoid and 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
\end_layout

\begin_layout Enumerate
The free pointed monad 
\begin_inset Formula $L^{A}\triangleq A+F^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a monad.
\end_layout

\begin_layout Enumerate
The product monad 
\begin_inset Formula $L^{A}\triangleq F^{A}\times G^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are monads.
\end_layout

\begin_layout Enumerate
The monad 
\begin_inset Formula $L^{A}\triangleq F^{Z+W\times A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a monad, 
\begin_inset Formula $W$
\end_inset

 is a monoid, and 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
\end_layout

\begin_layout Standard
If we do not assume any existing monads and just keep applying these constructio
ns, we will obtain a number of polynomial monads.
 But are there any polynomial monads 
\emph on
not
\emph default
 obtained by a chain of these constructions?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-co-pointed-applicative"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-co-pointed-applicative"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-pointed-applicative-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

, any co-pointed applicative functor of the form 
\begin_inset Formula $L^{A}\triangleq A\times G^{A}$
\end_inset

 satisfies the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-of-extract-and-zip"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-pointed-applicative-example-failing-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $L^{A}\triangleq Z\times\left(Z\rightarrow A\right)$
\end_inset

 is applicative and co-pointed but fails the compatibility law.
 Does there exist any co-pointed applicative functor that satisfies the
 law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:compatibility-law-of-extract-and-zip"
plural "false"
caps "false"
noprefix "false"

\end_inset

) but is 
\emph on
not
\emph default
 of the form 
\begin_inset Formula $A\times G^{A}$
\end_inset

 with some applicative functor 
\begin_inset Formula $G^{\bullet}$
\end_inset

? 
\begin_inset Note Note
status open

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-traverse-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-traverse-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
(a)
\series default
 Show that the applicative naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-applicative-naturality-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the identity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:traverse-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-traverse"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 guarantee that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 collects each 
\begin_inset Formula $F$
\end_inset

-effect exactly once, or find another law that is necessary to guarantee
 that.
 (Can we use a composition of an applicative functor 
\begin_inset Formula $F$
\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad to count the number of times 
\begin_inset Formula $F$
\end_inset

-effects were collected?)
\end_layout

\begin_layout Plain Layout

\series bold
(b)
\series default
 For any lawful traversable functor 
\begin_inset Formula $L$
\end_inset

, define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 (denoted for brevity by 
\begin_inset Formula $\text{zwi}_{L}$
\end_inset

) via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-zwi"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Show that there exists a 
\begin_inset Quotes eld
\end_inset

tabulating
\begin_inset Quotes erd
\end_inset

 function (denoted by 
\begin_inset Formula $\text{tab}_{L}^{A}$
\end_inset

):
\begin_inset Formula 
\[
\text{tab}_{L}^{A}:L^{A\times\text{Int}}\rightarrow(\text{Int}\rightarrow A)\times L^{\text{Int}}\quad,
\]

\end_inset

such that 
\begin_inset Formula $\text{zwi}_{L}\bef\text{tab}_{L}\bef(f^{:\text{Int}\rightarrow A}\times q^{:L^{\text{Int}}}\rightarrow q\triangleright f^{\uparrow L})=\text{id}^{:L^{A}\rightarrow L^{A}}$
\end_inset

.
 So, the function 
\begin_inset Formula $\text{zwi}_{L}\bef\text{tab}_{L}$
\end_inset

 is an injective map of type 
\begin_inset Formula $L^{A}\rightarrow(\text{Int}\rightarrow A)\times L^{\text{Int}}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
It appears that this property 
\emph on
cannot
\emph default
 be proved via the three laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

.
 One reason is that the function 
\begin_inset Formula $\text{tab}_{L}$
\end_inset

 produces an 
\begin_inset Quotes eld
\end_inset

indexing
\begin_inset Quotes erd
\end_inset

 function 
\begin_inset Formula $f:\text{Int}\rightarrow A$
\end_inset

, which can be computed only by traversing the entire data structure 
\begin_inset Formula $L^{A}$
\end_inset

.
 In other words, 
\begin_inset Formula $f$
\end_inset

 is a result of a traversal operation.
 We want to prove a property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 that combines 
\begin_inset Formula $f$
\end_inset

 withanother traversal (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

).
 But there are no laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 that involve reusing a result of another traverse operation.
 What new law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

traverse
\end_layout

\end_inset

 is necessary?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Monad transformers are defined in different ways for different monads.
 If someone comes up with a new monad, it is not certain that the new monad's
 transformer will be obtained through one of the known methods.
 Can we prove that a monad transformer will exist for every monad whose
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods are implemented via fully parametric code? Given the code for an
 arbitrary monad, can we derive an implementation of the corresponding monad
 transformer?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For certain monads 
\begin_inset Formula $L$
\end_inset

, the monad transformers 
\begin_inset Formula $T_{L}$
\end_inset

 can be defined using a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function.
 Is this always the case for any monad stacks built out of such monads?
 If each of the monads 
\begin_inset Formula $L_{1}$
\end_inset

, 
\begin_inset Formula $L_{2}$
\end_inset

, ..., 
\begin_inset Formula $L_{k}$
\end_inset

 admits a transformer defined via a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function, will the monad 
\begin_inset Formula $L_{1}\varangle L_{2}\varangle...\varangle L_{k}$
\end_inset

 also admit a transformer with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function? (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Does-a-composition-have-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for some partial results.)
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-identity-natural-monad-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-identity-natural-monad-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Are there any monadically natural monad morphisms 
\begin_inset Formula $M\leadsto M$
\end_inset

 that are not identity functions? (Equivalently, any non-identical natural
 transformations 
\begin_inset Formula $\text{Id}^{\bullet}\leadsto\text{Id}^{\bullet}$
\end_inset

 between identity functors in the category of monads?) If it were possible
 to prove that any natural monad morphism 
\begin_inset Formula $M\leadsto M$
\end_inset

 equals an identity function, there would be no need to verify the non-degenerac
y law for monad transformers' base runners (see page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "par:Open-question-monad-id-trans"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
We look for a monad morphism 
\begin_inset Formula $\varepsilon^{M,A}:M^{A}\rightarrow M^{A}$
\end_inset

 that is defined for all monads 
\begin_inset Formula $M$
\end_inset

 and is monadically natural in the parameter 
\begin_inset Formula $M$
\end_inset

.
 So, the function 
\begin_inset Formula $\varepsilon$
\end_inset

 must satisfy the following laws:
\begin_inset Formula 
\begin{align*}
\text{naturality law}:\quad & \varepsilon^{M,A}\bef(f^{:A\rightarrow B})^{\uparrow M}=(f^{:A\rightarrow B})^{\uparrow M}\bef\varepsilon^{M,B}\quad,\\
\text{monad morphism laws}:\quad & \text{pu}_{M}\bef\varepsilon=\text{pu}_{M}\quad,\quad\quad\varepsilon^{\uparrow M}\bef\varepsilon\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\varepsilon\quad,\\
\text{monadic naturality law}:\quad & \varepsilon^{M,A}\bef\phi^{:M^{:A}\rightarrow N^{A}}=\phi^{:M^{A}\rightarrow N^{A}}\bef\varepsilon^{N,A}\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is an arbitrary function, 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 are arbitrary monads, and 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 is an arbitrary monad morphism.
 We need to prove that any such 
\begin_inset Formula $\varepsilon$
\end_inset

 must be an identity function, 
\begin_inset Formula $\varepsilon=\text{id}^{:M^{A}\rightarrow M^{A}}$
\end_inset

, or to find an example of such 
\begin_inset Formula $\varepsilon$
\end_inset

 not equal to identity.
\begin_inset Foot
status open

\begin_layout Plain Layout
See discussion here: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/61444425/"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Rigid functors
\begin_inset Quotes erd
\end_inset

 are
\begin_inset Index idx
status open

\begin_layout Plain Layout
rigid functors!open questions
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Are there any rigid functors that are not monads? 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Are there any rigid functors that are not applicative?
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Is it true that any applicative rigid functor is a monad?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $L$
\end_inset

 be a fixed monad and 
\begin_inset Formula $H$
\end_inset

 be an 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctor.
 Then the functor 
\begin_inset Formula $F^{A}\triangleq H^{A}\rightarrow L^{A}$
\end_inset

 is a lawful monad (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructions-of-M-filterables"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 What is a monad transformer for the monad 
\begin_inset Formula $F$
\end_inset

? 
\end_layout

\begin_layout Standard
Two nontrivial examples of 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctors are 
\begin_inset Formula $H^{A}\triangleq A\rightarrow L^{Z}$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq L^{A}\rightarrow Z$
\end_inset

 (where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type).
 For these cases, the monad transformers are defined by:
\begin_inset Formula 
\begin{align*}
 & \text{monad: }(A\rightarrow L^{Z})\rightarrow L^{A}\quad,\quad\quad\text{transformer: }(A\rightarrow T_{L}^{M,Z})\rightarrow T_{L}^{M,A}\quad,\\
 & \text{monad: }(L^{A}\rightarrow Z)\rightarrow L^{A}\quad,\quad\quad\text{transformer: }(T_{L}^{M,A}\rightarrow Z)\rightarrow T_{L}^{M,A}\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 is the monad 
\begin_inset Formula $L$
\end_inset

's transformer applied to the foreign monad 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
The problem is to implement the monad 
\begin_inset Formula $F$
\end_inset

's transformer for an arbitrary 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctor 
\begin_inset Formula $H$
\end_inset

 and to prove that the transformer laws hold.
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume an arbitrary unknown monad 
\begin_inset Formula $M$
\end_inset

 and define recursively 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}$
\end_inset

.
 Can one define a lawful monad instance for the functor 
\begin_inset Formula $L$
\end_inset

? (This is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's transformer without the outer layer of 
\begin_inset Formula $M$
\end_inset

.
 See Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-effectful-list-not-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "par:Problem-monads-5-2-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
These questions concern the monad transformer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 (here denoted just by 
\begin_inset Formula $T$
\end_inset

): 
\begin_inset Formula 
\[
T^{A}\triangleq M^{L^{A}}\quad,\quad\quad L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}\quad,
\]

\end_inset

where 
\begin_inset Formula $M$
\end_inset

 is an arbitrary foreign monad.
 Normally, we cannot implement fully parametric base runner 
\begin_inset Formula $T^{A}\rightarrow M^{A}$
\end_inset

 because we cannot have a fully parametric runner 
\begin_inset Formula $\text{List}^{A}\rightarrow A$
\end_inset

 operating on arbitrary types 
\begin_inset Formula $A$
\end_inset

.
 However, for a 
\emph on
monoid
\emph default
 type 
\begin_inset Formula $R$
\end_inset

 with binary operation 
\begin_inset Formula $\oplus_{R}$
\end_inset

 and empty element 
\begin_inset Formula $e_{R}$
\end_inset

, the type signature 
\begin_inset Formula $\text{List}^{R}\rightarrow R$
\end_inset

 is implemented by the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 operation: 
\begin_inset Formula 
\[
\text{reduce}:\text{List}^{R}\rightarrow R\quad,\quad\quad\text{reduce}\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline \bbnum 1 & 1\rightarrow e_{R}\\
R\times\text{List}^{R} & h\times t\rightarrow h\oplus_{R}\overline{\text{reduce}}\,(t)
\end{array}\quad.
\]

\end_inset

We can similarly implement a special base runner (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

) for the transformer 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 if we restrict its usage to 
\emph on
monoid
\emph default
 types 
\begin_inset Formula $R$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $M^{L^{R}}\rightarrow M^{R}$
\end_inset

 aggregates all elements of the effectful list into a single value of type
 
\begin_inset Formula $M^{R}$
\end_inset

 (which is also a monoid type):
\begin_inset Formula 
\[
\text{brunE}:M^{L^{R}}\rightarrow M^{R}\quad,\quad\quad\text{brunE}\triangleq\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{R}\\
\hline \bbnum 1 & 1\rightarrow\text{pu}_{M}(e_{R})\\
R\times M^{L^{R}} & h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brunE}}\,(t)
\end{array}\,\bigg)\quad.
\]

\end_inset

Here, we use the binary operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

 of the monoid 
\begin_inset Formula $M^{R}$
\end_inset

, which is defined by:
\begin_inset Formula 
\[
p^{:M^{R}}\oplus_{M}q^{:M^{R}}\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 a monoid morphism 
\begin_inset Formula $T^{A}\rightarrow A$
\end_inset

? (Note that 
\begin_inset Formula $T^{A}$
\end_inset

 is a monoid since 
\begin_inset Formula $T$
\end_inset

 is a lawful monad.) The monoid morphism identity law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

.
 Does the composition law hold?
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Do the monad morphism laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 hold when restricted to monoid types 
\begin_inset Formula $A$
\end_inset

?
\begin_inset Formula 
\begin{align*}
\text{for all monoid types }A:\quad & a^{:A}\triangleright\text{pu}_{T}\bef\text{brunE}=a^{:A}\triangleright\text{pu}_{M}\quad,\\
\text{composition law}:\quad & p^{:T^{T^{A}}}\triangleright\text{ftn}_{T}\bef\text{brunE }=p^{:T^{T^{A}}}\triangleright\text{brunE}\bef\text{brunE}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

(If so, Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-traversables-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 would show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brunE
\end_layout

\end_inset

 is also a 
\emph on
monoid
\emph default
 morphism 
\begin_inset Formula $M^{L^{A}}\rightarrow M^{A}$
\end_inset

.) 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Failed attempts to verify the composition law:
\end_layout

\begin_layout Plain Layout
Write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{T}\bef\text{brun}=\text{flm}_{M}(\text{prod})\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
\text{associativity of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}\bigg(\text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\bigg)\quad,\\
\text{right-hand side}:\quad & \text{brun}^{T^{R}}\bef\text{brun}^{\uparrow M}\bef\text{ftn}_{M}=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bigg)\bef\text{flm}_{M}(\text{brun})\\
\text{associativity of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\bigg)\quad.
\end{align*}

\end_inset

The remaining difference (under 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

) is an equation between functions of type 
\begin_inset Formula $L^{M^{L^{R}}}\rightarrow M^{R}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{prod}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)=\text{prod}\bef\text{brun}\\
 & \quad\overset{?}{=}\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r^{:T^{R}}\times t^{:T^{T^{R}}}\rightarrow\text{pu}_{M}(r)\oplus_{M^{T^{R}}}\overline{\text{brun}}{}^{T^{R}}(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\quad.
\end{align*}

\end_inset

It is inconvenient to use matrices at this step because the code of 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

 is unknown.
 Instead, we will substitute into both sides an arbitrary value of type
 
\begin_inset Formula $L^{M^{L^{R}}}$
\end_inset

, which can be one of two possibilities, 
\begin_inset Formula $\text{Nil}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+h^{:T^{R}}\times t^{T^{T^{R}}}$
\end_inset

.
 Substituting 
\begin_inset Formula $\text{Nil}$
\end_inset

, we get:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \gunderline{\text{Nil}\triangleright\text{prod}}\bef\text{brun}=\text{Nil}\triangleright\text{pu}_{M}\bef\text{brun}\\
\text{use Eq.~(\ref{eq:listt-brun-derivation1})}:\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.\\
\text{right-hand side}:\quad & \text{Nil}\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=e_{T^{R}}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(\text{brun})=e_{R}\triangleright\gunderline{\text{pu}_{T}\bef\text{brun}}\\
\text{identity law of }\text{brun}:\quad & \quad=e_{R}\triangleright\text{pu}_{M}\quad.
\end{align*}

\end_inset

The two sides are now equal.
 It remains to substitute the second possibility:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (\bbnum 0+h\times t)\triangleright\text{prod}\bef\text{brun}=\\
 & \quad=(\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\text{flm}_{M}(\overline{\text{prod}})
\end{array}\bef\text{brun}\\
 & \quad=\big(\text{comb}\,(h)(t\triangleright\text{flm}_{M}(\overline{\text{prod}}))\big)\triangleright\text{brun}\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\triangleright\xi\big)\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\xi\bef\text{brun}\big)\\
 & \quad=h\triangleright\text{flm}_{M}\big(t\triangleright\text{flm}_{M}(\overline{\text{prod}})\bef\big)\\
\text{right-hand side}:\quad & (\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{T^{R}})\\
h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\text{flm}_{M}(\text{brun})\\
 & \quad=(\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t))\triangleright\text{flm}_{M}(\text{brun})\\
 & \quad=t\triangleright\overline{\text{brun}}\triangleright(v\rightarrow h\oplus_{R}v)^{\uparrow M}\triangleright\text{flm}_{M}(\text{brun})
\end{align*}

\end_inset

This is suspicious: we need to show that an expression 
\begin_inset Formula $h\triangleright\text{flm}_{M}(t\triangleright...)$
\end_inset

 is equal to 
\begin_inset Formula $t\triangleright...$
\end_inset

, and it seems impossible to convert one into another, given that 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

 are arbitrary values.
\end_layout

\begin_layout Plain Layout
Note that
\begin_inset Formula 
\[
\text{pu}_{M}(r^{:R})\oplus_{M}q^{:M^{R}}=r\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M})=q\triangleright(v\rightarrow r\oplus_{R}v)^{\uparrow M}\quad.
\]

\end_inset

In particular,
\begin_inset Formula 
\[
\text{pu}_{M}(p)\oplus_{M}\text{pu}_{M}(q)=q\triangleright\text{pu}_{M}\triangleright(v\rightarrow p\oplus_{R}v)^{\uparrow M}=q\triangleright(v\rightarrow p\oplus_{R}v)\triangleright\text{pu}_{M}=\text{pu}_{M}(p\oplus_{R}q)\quad.
\]

\end_inset

We also have the property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \big(\text{comb}\,(p)(q)\big)\triangleright\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}(q\triangleright\xi)\bef\text{flm}_{M}(g)=p\triangleright\text{flm}_{M}((q\triangleright\xi)\bef\text{flm}_{M}(g))\\
 & =p\triangleright\text{flm}_{M}\bigg(\begin{array}{||c|}
1\rightarrow q\\
h\times t\rightarrow\text{pu}_{M}\big(\bbnum 0+h\times\overline{\text{comb}}\,(t)(q)
\end{array}\,\bef\text{flm}_{M}(g)\bigg)
\end{align*}

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-monatron-lift-reset-and-shift"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-monatron-lift-reset-and-shift"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The continuation monad's operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reset
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shift
\end_layout

\end_inset

 are defined by:
\begin_inset Formula 
\begin{align*}
 & \text{reset}:\forall S.\,\text{Cont}^{R,R}\rightarrow\text{Cont}^{S,R}\quad,\quad\quad\text{reset}\triangleq c^{:\left(R\rightarrow R\right)\rightarrow R}\rightarrow k^{:R\rightarrow S}\rightarrow k(c(\text{id}))\quad,\\
 & \text{shift}:\forall A.\,((A\rightarrow R)\rightarrow\text{Cont}^{R,R})\rightarrow\text{Cont}^{R,A}\quad,\quad\quad\text{shift}\triangleq g^{:\left(A\rightarrow R\right)\rightarrow\text{Cont}^{R,R}}\rightarrow k^{:A\rightarrow R}\rightarrow g(k)(\text{id})\quad.
\end{align*}

\end_inset

How to lift these operations to an arbitrary monad stack 
\begin_inset Formula $P$
\end_inset

 that contains a continuation monad?
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/renormalist/pugs/blob/master/src/Pugs/AST/Eval.hs"
literal "false"

\end_inset


\family default
 for custom code (in Haskell) that lifts 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reset
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shift
\end_layout

\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT
\end_layout

\end_inset

 monad transformer.
\end_layout

\end_inset

 What are the appropriate type signatures for the lifted operations?
\end_layout

\begin_layout Subsubsection
Problem 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Problem-unique-functor-liftings"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-unique-functor-liftings"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any fully parametric type constructor 
\begin_inset Formula $P^{A}$
\end_inset

 covariant in 
\begin_inset Formula $A$
\end_inset

, the lifting of a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to 
\begin_inset Formula $P$
\end_inset

 is performed via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method of 
\begin_inset Formula $P$
\end_inset

, so that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)
\end_layout

\end_inset

 is a function of type 
\begin_inset Formula $P^{A}\rightarrow P^{B}$
\end_inset

 denoted by 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 in this book.
 The standard code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is defined by induction on the type structure of 
\begin_inset Formula $P$
\end_inset

 and satisfies the functor laws, as shown in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The question is to show that there is no non-standard, alternative implementati
on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 that still satisfies the functor laws.
 If the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 is fully parametric, Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Uniqueness-of-functor-and-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 However, parametricity (or naturality) does not seem to follow from functor
 laws alone.
 Does there exist an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 that satisfies the functor laws but is 
\emph on
not
\emph default
 fully parametric?
\end_layout

\end_body
\end_document
