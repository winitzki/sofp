#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Mathematical formulas as code.
 II.
 Mathematical induction
\begin_inset CommandInset label
LatexCommand label
name "chap:2-Mathematical-induction"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset

We will now study more flexible ways of working with data collections in
 the functional programming paradigm.
 The Scala standard library has methods for performing general iterative
 computations, that is, computations defined by induction.
 Translating mathematical induction into code is the focus of this chapter.
\end_layout

\begin_layout Standard
First, we need to become fluent in using tuple types with Scala collections.
\end_layout

\begin_layout Section
Tuple types
\end_layout

\begin_layout Subsection
Examples: Using tuples
\end_layout

\begin_layout Standard
Many standard library methods in Scala work with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples
\end_layout

\end_inset

tuple types.
 A simple example of a tuple is a 
\emph on
pair
\emph default
 of values, e.g., a pair of an integer and a string.
 The Scala syntax for this type of pair is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val a: (Int, String) = (123, 
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

The type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

 denotes the type of this pair.
\end_layout

\begin_layout Standard
A 
\series bold
triple
\series default
 is defined in Scala like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val b: (Boolean, Int, Int) = (true, 3, 4)
\end_layout

\end_inset

Pairs and triples are examples of tuples.
 A 
\series bold
tuple
\series default
 can contain several values called 
\series bold
parts
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!parts
\end_layout

\end_inset


\series default
 or 
\series bold
fields
\series default
 of
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!fields
\end_layout

\end_inset

 a tuple.
 A tuple's parts can have different types, but the type of each part (and
 the number of parts) is fixed once and for all.
 It is a 
\series bold
type error
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

 to use incorrect types in a tuple, or an incorrect number of parts:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val bad: (Int, String) = (1, 2)
\end_layout

\begin_layout Plain Layout

<console>:11: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Int(2)
\end_layout

\begin_layout Plain Layout

 required: String
\end_layout

\begin_layout Plain Layout

       val bad: (Int, String) = (1, 2)
\end_layout

\begin_layout Plain Layout

                                    ^
\end_layout

\begin_layout Plain Layout

scala> val bad: (Int, String) = (1, "a", 3)
\end_layout

\begin_layout Plain Layout

<console>:11: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : (Int, String, Int)
\end_layout

\begin_layout Plain Layout

 required: (Int, String)
\end_layout

\begin_layout Plain Layout

       val bad: (Int, String) = (1, "a", 3)
\end_layout

\begin_layout Plain Layout

                                ^
\end_layout

\end_inset

Parts of a tuple can be accessed by number, starting from 
\begin_inset Formula $1$
\end_inset

.
 The Scala syntax for 
\series bold
tuple accessor
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!accessors
\end_layout

\end_inset


\series default
 methods looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._1
\end_layout

\end_inset

, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val a = (123, 
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

a: (Int, String) = (123,xyz)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> a._1
\end_layout

\begin_layout Plain Layout

res0: Int = 123
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> a._2
\end_layout

\begin_layout Plain Layout

res1: String = xyz 
\end_layout

\end_inset

It is a type error to access a tuple part that does not exist:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> a._0
\end_layout

\begin_layout Plain Layout

<console>:13: error: value _0 is not a member of (Int, String)
\end_layout

\begin_layout Plain Layout

       a._0
\end_layout

\begin_layout Plain Layout

         ^
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> a._5
\end_layout

\begin_layout Plain Layout

<console>:13: error: value _5 is not a member of (Int, String)
\end_layout

\begin_layout Plain Layout

       a._5
\end_layout

\begin_layout Plain Layout

         ^
\end_layout

\end_inset

Type errors
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

 are detected at compile time, before any computations begin.
\end_layout

\begin_layout Standard
Tuples can be 
\series bold
nested
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!nested
\end_layout

\end_inset

 such that any part of a tuple can be itself a tuple:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val c: (Boolean, (String, Int), Boolean) = (true, (
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

, 3), false)
\end_layout

\begin_layout Plain Layout

c: (Boolean, (String, Int), Boolean) = (true,(abc,3),false)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> c._1
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> c._2
\end_layout

\begin_layout Plain Layout

res1: (String, Int) = (abc,3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> c._2._1
\end_layout

\begin_layout Plain Layout

res2: String = abc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To define functions whose arguments are tuples, we could use the tuple accessors.
 An example of such a function is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(p: (Boolean, Int), q: Int): Boolean = p._1 && (p._2 > q) 
\end_layout

\end_inset

The first argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, of this function, has a tuple type.
 The function body uses accessor methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._2
\end_layout

\end_inset

) to compute the result value.
 Note that the second part of the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, so it is valid to compare it with an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

.
 It would be a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

type error to compare the 
\emph on
tuple
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 with an 
\emph on
integer
\emph default
 using the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p > q
\end_layout

\end_inset

.
 It would be also a type error to apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 that has a wrong type, e.g., the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Boolean, Int)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Pattern matching for tuples
\end_layout

\begin_layout Standard
Instead of using accessor methods when working with tuples, it is often
 convenient to use 
\series bold
pattern matching
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching
\end_layout

\end_inset


\series default
.
 Pattern matching occurs in Scala as:
\end_layout

\begin_layout Itemize
a destructuring definition: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

val $pattern$ = ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

case $pattern$ => ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is an example of a 
\series bold
destructuring
\begin_inset Index idx
status open

\begin_layout Plain Layout
destructuring
\end_layout

\end_inset

 definition
\series default
:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val g = (1, 2, 3)
\end_layout

\begin_layout Plain Layout

g: (Int, Int, Int) = (1,2,3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val (x, y, z) = g
\end_layout

\begin_layout Plain Layout

x: Int = 1
\end_layout

\begin_layout Plain Layout

y: Int = 2
\end_layout

\begin_layout Plain Layout

z: Int = 3
\end_layout

\end_inset

The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 is a tuple of three integers.
 After defining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

, we define the three variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 
\emph on
at once
\emph default
 in a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 definition.
 We imagine that this definition 
\begin_inset Quotes eld
\end_inset

destructures
\begin_inset Quotes erd
\end_inset

 the data structure contained in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 and decomposes it into three parts, then assigns the names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 to these parts.
 The types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 are also assigned automatically.
\end_layout

\begin_layout Standard
In the example above, the left-hand side of the destructuring definition
 contains the tuple pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y, z)
\end_layout

\end_inset

 that looks like a tuple, except that its parts are names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 that are so far 
\emph on
undefined
\emph default
.
 These names are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern variables
\end_layout

\end_inset


\series bold
pattern variables
\series default
.
 The destructuring definition checks whether the structure of the value
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

matches
\begin_inset Quotes erd
\end_inset

 the given pattern.
 (If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 does not contain a tuple with exactly three parts, the definition will
 fail.) This computation is called 
\series bold
pattern matching
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Pattern matching is often used for working with tuples.
 Look at this example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1, 2, 3) match { case (a, b, c) => a + b + c }
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset

The expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (a, b, c) => ...
 }
\end_layout

\end_inset

 is called a 
\series bold
case expression
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
case
\family default
 expression
\end_layout

\end_inset

.
 It performs pattern matching on its argument.
 The pattern matching will 
\begin_inset Quotes eld
\end_inset

destructure
\begin_inset Quotes erd
\end_inset

 (i.e., decompose) a tuple and try to match it to the given pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b, c)
\end_layout

\end_inset

.
 In this pattern, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 are as yet undefined new variables, — they are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern variables
\end_layout

\end_inset


\series bold
pattern variables
\series default
.
 If the pattern matching succeeds, the pattern variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 are assigned their values, and the function body can proceed to perform
 its computation.
 In this example, the pattern variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 will be assigned values 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $3$
\end_inset

, and so the expression evaluates to 
\begin_inset Formula $6$
\end_inset

.
\end_layout

\begin_layout Standard
Pattern matching is especially convenient for nested tuples.
 Here is an example where a nested tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 is destructured by pattern matching:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t1(p: (Int, (String, Int))): String = p match {
\end_layout

\begin_layout Plain Layout

  case (x, (str, y)) => str + (x + y).toString
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> t1((10, ("result is ", 2)))
\end_layout

\begin_layout Plain Layout

res0: String = result is 12
\end_layout

\end_inset

The type structure of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, (String, Int))
\end_layout

\end_inset

 is visually repeated in the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, (str, y))
\end_layout

\end_inset

, making it clear that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 become integers and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

str
\end_layout

\end_inset

 becomes a string after pattern matching.
\end_layout

\begin_layout Standard
If we rewrite the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t1
\end_layout

\end_inset

 using the tuple accessor methods instead of pattern matching, the code
 will look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t2(p: (Int, (String, Int))): String = p._2._1 + (p._1 + p._2._2).toString
\end_layout

\end_inset

This code is shorter but harder to read.
 For example, it is not immediately clear that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2._1
\end_layout

\end_inset

 is a string.
 It is also harder to modify this code: Suppose we want to change the type
 of the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((Int, String), Int)
\end_layout

\end_inset

.
 Then the new code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t3(p: ((Int, String), Int)): String = p._1._2 + (p._1._1 + p._2).toString
\end_layout

\end_inset

It takes time to verify, by going through every accessor method, that the
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t3
\end_layout

\end_inset

 computes the same expression as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t2
\end_layout

\end_inset

.
 In contrast, the code is changed easily when using the pattern matching
 expression instead of the accessor methods.
 We only need to change the type and the pattern:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t4(p: ((Int, String), Int)): String = p match {
\end_layout

\begin_layout Plain Layout

  case ((x, str), y) => str + (x + y).toString
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It is easy to see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t4
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

t1
\end_layout

\end_inset

 compute the same result.
 Also, the names of pattern variables may be chosen to get more clarity.
\end_layout

\begin_layout Standard
Sometimes we only need to use certain parts of a tuple in a pattern match.
 The following syntax is used to make that clear:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val (x, _, _, z) = ("abc", 123, false, true)
\end_layout

\begin_layout Plain Layout

x: String = abc
\end_layout

\begin_layout Plain Layout

z: Boolean = true
\end_layout

\end_inset

The underscore symbol (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_
\end_layout

\end_inset

) denotes the parts of the pattern that we want to ignore.
 The underscore will always match any value regardless of its type.
\end_layout

\begin_layout Standard
Scala has a shorter syntax for functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{case (x, y) => y}
\end_layout

\end_inset

 that extract elements from tuples.
 The syntax looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(t => t._2)
\end_layout

\end_inset

 or equivalently 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._2
\end_layout

\end_inset

, as illustrated here:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p: ((Int, Int )) => Int = { case (x, y) => y }
\end_layout

\begin_layout Plain Layout

p: ((Int, Int)) => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> p((1, 2))
\end_layout

\begin_layout Plain Layout

res0: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val q: ((Int, Int )) => Int = (t => t._2)
\end_layout

\begin_layout Plain Layout

q: ((Int, Int)) => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> q((1, 2))
\end_layout

\begin_layout Plain Layout

res1: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq( (1, 10), (2, 20), (3, 30) ).map(_._2)
\end_layout

\begin_layout Plain Layout

res2: Seq[Int] = List(10, 20, 30)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using tuples with collections
\end_layout

\begin_layout Standard
Tuples can be combined with any other types without restrictions.
 For instance, we can define a tuple of functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val q: (Int => Int, Int => Int) = (x => x + 1, x => x - 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> q._1(3)
\end_layout

\begin_layout Plain Layout

res0: Int = 4
\end_layout

\end_inset

We can create a list of tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val r: List[(String, Int)] = List(("apples", 3), ("oranges", 2), ("pears",
 0))
\end_layout

\end_inset

We could define a tuple of lists of tuples of functions, or any other combinatio
n.
\end_layout

\begin_layout Standard
Here is an example of using the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to transform a list of tuples.
 (As usual, we speak of 
\begin_inset Quotes eld
\end_inset

data transformation
\begin_inset Index idx
status open

\begin_layout Plain Layout
data transformation
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 even though the original list remains unchanged.) The argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 must be a function taking a tuple as its argument.
 It is convenient to use pattern matching for writing such functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val basket: List[(String, Int)] = List(("apples", 3), ("pears", 2),
 ("lemons", 0))
\end_layout

\begin_layout Plain Layout

basket: List[(String, Int)] = List((apples,3), (pears,2), (lemons,0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> basket.map { case (fruit, count) => count * 2 }
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(6, 4, 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> basket.map { case (fruit, count) => count * 2 }.sum
\end_layout

\begin_layout Plain Layout

res2: Int = 10
\end_layout

\end_inset

In this way, we can use the standard methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 to manipulate sequences of tuples.
 The names of the pattern variables (
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fruit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) are chosen to help us remember the meaning of the parts of tuples.
\end_layout

\begin_layout Standard
We can easily transform a list of tuples into a list of values of a different
 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> basket.map { case (fruit, count) =>
\end_layout

\begin_layout Plain Layout

  val isAcidic = (fruit == "lemons")
\end_layout

\begin_layout Plain Layout

  (fruit, isAcidic)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

res3: List[(String, Boolean)] = List((apples,false), (pears,false), (lemons,true
)) 
\end_layout

\end_inset

In the Scala syntax, a nameless function written with braces 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ ...
 }
\end_layout

\end_inset

 may define local values in its body.
 The return value of the function is the last expression written in the
 function body.
 In this example, the return value of the nameless function is the tuple
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(fruit, isAcidic)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Treating dictionaries as collections
\end_layout

\begin_layout Standard
In the Scala standard library, tuples are frequently used as types of intermedia
te values.
 For instance, tuples are used when iterating over dictionaries.
 The Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, V]
\end_layout

\end_inset

 represents a dictionary with keys of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 and values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

V
\end_layout

\end_inset

.
 Here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

V
\end_layout

\end_inset

 are 
\series bold
type parameters
\begin_inset Index idx
status open

\begin_layout Plain Layout
type parameter
\end_layout

\end_inset


\series default
.
 Type parameters represent unknown types that will be chosen later, when
 working with values having specific types.
\end_layout

\begin_layout Standard
In order to create a dictionary with given keys and values, we can write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map((
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

oranges
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

pears
\begin_inset Quotes erd
\end_inset

, 0))
\end_layout

\end_inset

The same result is obtained by first creating a sequence of key/value 
\emph on
pairs
\emph default
 and then converting that sequence into a dictionary via the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List((
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

oranges
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

pears
\begin_inset Quotes erd
\end_inset

, 0)).toMap
\end_layout

\end_inset

The same method works for other collection types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vector
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The Scala library defines a special infix syntax for pairs via the arrow
 symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

.
 The expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x -> y
\end_layout

\end_inset

 is equivalent to the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> 
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

 -> 3
\end_layout

\begin_layout Plain Layout

res0: (String, Int) = (apples,3)
\end_layout

\end_inset

With this syntax, the code for creating a dictionary is easier to read:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map(
\begin_inset Quotes eld
\end_inset

apples
\begin_inset Quotes erd
\end_inset

 -> 3, 
\begin_inset Quotes eld
\end_inset

oranges
\begin_inset Quotes erd
\end_inset

 -> 2, 
\begin_inset Quotes eld
\end_inset

pears
\begin_inset Quotes erd
\end_inset

 -> 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toSeq
\end_layout

\end_inset

 converts a dictionary into a sequence of pairs:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map("apples" -> 3, "oranges" -> 2, "pears" -> 0).toSeq
\end_layout

\begin_layout Plain Layout

res20: Seq[(String, Int)] = ArrayBuffer((apples,3), (oranges,2), (pears,0))
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ArrayBuffer
\end_layout

\end_inset

 is one of the many list-like data structures in the Scala library.
 All these data structures are subtypes of the common 
\begin_inset Quotes eld
\end_inset

sequence
\begin_inset Quotes erd
\end_inset

 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

.
 The methods defined in the Scala standard library sometimes return different
 implementations of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 type for reasons of performance.
\end_layout

\begin_layout Standard
The standard library has several methods that need tuple types, such as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 (when used with dictionaries), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

.
 The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sliding
\end_layout

\end_inset

 also work with most collection types, including dictionaries and sets.
 It is important to become familiar with these methods, because it will
 help writing code that uses sequences, sets, and dictionaries.
 Let us now look at these methods one by one.
\end_layout

\begin_layout Paragraph*
The methods 
\family typewriter
map
\family default
 and 
\family typewriter
toMap
\end_layout

\begin_layout Standard
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:1-Values,-types,-expressions,"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed how the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method works on sequences: the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.map(f)
\end_layout

\end_inset

 applies a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each element of the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

, gathering the results in a new sequence.
 In this sense, we can say that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method 
\begin_inset Quotes eld
\end_inset

iterates over
\begin_inset Quotes erd
\end_inset

 sequences.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method works similarly on dictionaries, except that iterating over a dictionary
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, V]
\end_layout

\end_inset

 when applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 looks like iterating over a sequence of 
\emph on
pairs
\emph default
, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(K, V)]
\end_layout

\end_inset

.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

d: Map[K, V]
\end_layout

\end_inset

 is a dictionary, the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

d.map(f)
\end_layout

\end_inset

 must be a function operating on tuples of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(K, V)
\end_layout

\end_inset

.
 Typically, such functions are written using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val fruitBasket = Map("apples" -> 3, "pears" -> 2, "lemons" -> 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fruitBasket.map { case (fruit, count) => count * 2 }
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = ArrayBuffer(6, 4, 0)
\end_layout

\end_inset

When using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to transform a dictionary into a sequence of pairs, the result is again
 a dictionary.
 But when an intermediate result is not a sequence of pairs, we may need
 to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fruitBasket.map { case (fruit, count) => (fruit, count * 2) }
\end_layout

\begin_layout Plain Layout

res1: Map[String,Int] = Map(apples -> 6, pears -> 4, lemons -> 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fruitBasket.map { case (fruit, count) => (fruit, count, count * 2)
 }.
\end_layout

\begin_layout Plain Layout

         map { case (fruit, _, count2) => (fruit, count2 / 2) }.toMap
\end_layout

\begin_layout Plain Layout

res2: Map[String,Int] = Map(apples -> 3, pears -> 2, lemons -> 0)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The method 
\family typewriter
filter
\end_layout

\begin_layout Standard
works on dictionaries by iterating on key/value pairs.
 The filtering predicate must be a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((K, V)) => Boolean
\end_layout

\end_inset

.
 For example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fruitBasket.filter { case (fruit, count) => count > 0 }
\end_layout

\begin_layout Plain Layout

res2: Map[String,Int] = Map(apples -> 3, pears -> 2)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The methods 
\family typewriter
zip
\family default
 and 
\family typewriter
zipWithIndex
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method takes 
\emph on
two
\emph default
 sequences and produces a sequence of pairs, taking one element from each
 sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3)
\end_layout

\begin_layout Plain Layout

s: List[Int] = List(1, 2, 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val t = List(true, false, true)
\end_layout

\begin_layout Plain Layout

t: List[Boolean] = List(true, false, true)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s.zip(t)
\end_layout

\begin_layout Plain Layout

res3: List[(Int, Boolean)] = List((1,true), (2,false), (3,true))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s zip t
\end_layout

\begin_layout Plain Layout

res4: List[(Int, Boolean)] = List((1,true), (2,false), (3,true)) 
\end_layout

\end_inset

In the last line, the equivalent 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 infix syntax (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s zip t
\end_layout

\end_inset

) is shown to illustrate a syntax convention of Scala that we will sometimes
 use.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 method works equally well on dictionaries: in that case, dictionaries are
 automatically converted to sequences of pairs before applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 method creates a sequence of pairs where the second value in the pair is
 a zero-based index:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List("a", "b", "c").zipWithIndex
\end_layout

\begin_layout Plain Layout

res5: List[(String, Int)] = List((a,0), (b,1), (c,2)) 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The method 
\family typewriter
flatten
\end_layout

\begin_layout Standard
converts a nested sequence type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

, into a simple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 by concatenating all inner sequences into one:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(List(1, 2), List(2, 3), List(3, 4)).flatten
\end_layout

\begin_layout Plain Layout

res6: List[Int] = List(1, 2, 2, 3, 3, 4)
\end_layout

\end_inset

In Scala, sequences and other collections (such as sets and dictionaries)
 are generally concatenated using the operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

++
\end_layout

\end_inset

.
 For example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3) ++ List(4, 5, 6) ++ List(0)
\end_layout

\begin_layout Plain Layout

res7: List[Int] = List(1, 2, 3, 4, 5, 6, 0)
\end_layout

\end_inset

So, one can say that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method inserts the operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

++
\end_layout

\end_inset

 between all the inner sequences.
\end_layout

\begin_layout Standard
Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 removes 
\emph on
only one
\emph default
 level of nesting at the 
\emph on
top
\emph default
 of the data type.
 If applied to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[List[Int]]]
\end_layout

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]]
\end_layout

\end_inset

 with inner lists unchanged:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(List(List(1), List(2)), List(List(2), List(3))).flatten
\end_layout

\begin_layout Plain Layout

res8: List[List[Int]] = List(List(1), List(2), List(2), List(3))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The method 
\family typewriter
flatMap
\end_layout

\begin_layout Standard
is closely related to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 and can be seen as a shortcut, equivalent to first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3, 4).map(n => (1 to n).toList)
\end_layout

\begin_layout Plain Layout

res9: List[List[Int]] = List(List(1), List(1, 2), List(1, 2, 3), List(1,
 2, 3, 4))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(1, 2, 3, 4).map(n => (1 to n).toList).flatten
\end_layout

\begin_layout Plain Layout

res10: List[Int] = List(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(1, 2, 3, 4).flatMap(n => (1 to n).toList)
\end_layout

\begin_layout Plain Layout

res11: List[Int] = List(1, 1, 2, 1, 2, 3, 1, 2, 3, 4)
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 operation transforms a sequence by replacing each element by some number
 (zero or more) of new elements.
\end_layout

\begin_layout Standard
At first sight it may be unclear why 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 is useful, as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 appear to be unrelated.
 (Should we also combine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 into a 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatFilter
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

?) However, we will see later in this book that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 describes nested iterations and can be generalized to many other data types.
 This chapter's examples and exercises will illustrate the use of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 with sequences.
\end_layout

\begin_layout Paragraph*
The method 
\family typewriter
groupBy
\end_layout

\begin_layout Standard
rearranges a sequence into a dictionary where some elements of the original
 sequence are grouped together into subsequences.
 For example, given a sequence of words, we can group all words that start
 with the letter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 into one subsequence, and all other words into another subsequence.
 This is accomplished by the following code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

xenon
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yogurt
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

zebra
\begin_inset Quotes erd
\end_inset

).groupBy(s => if (s startsWith 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

) 1 else 2)
\end_layout

\begin_layout Plain Layout

res12: Map[Int,Seq[String]] = Map(1 -> List(yogurt), 2 -> List(xenon, zebra))
\end_layout

\end_inset

The argument of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

 method is a 
\emph on
function
\emph default
 that computes a 
\begin_inset Quotes eld
\end_inset

key
\begin_inset Quotes erd
\end_inset

 out of each sequence element.
 The key can have an arbitrarily chosen type.
 (In the current example, that type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.) The result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

 is a dictionary that maps each key to the sub-sequence of values that have
 that key.
 (In the current example, the type of the dictionary is therefore 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Int, Seq[String]]
\end_layout

\end_inset

.) The order of elements in the sub-sequences remains the same as in the
 original sequence.
\end_layout

\begin_layout Standard
As another example of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

, the following code will group together all numbers that have the same
 remainder after division by 
\begin_inset Formula $3$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3, 4, 5).groupBy(k => k % 3)
\end_layout

\begin_layout Plain Layout

res13: Map[Int,List[Int]] = Map(2 -> List(2, 5), 1 -> List(1, 4), 0 -> List(3))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The method 
\family typewriter
sliding
\end_layout

\begin_layout Standard
creates a sequence of sliding windows of a given width:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).sliding(4).toList
\end_layout

\begin_layout Plain Layout

res14: List[IndexedSeq[Int]] = List(Vector(1, 2, 3, 4), Vector(2, 3, 4,
 5), Vector(3, 4, 5, 6), Vector(4, 5, 6, 7), Vector(5, 6, 7, 8), Vector(6,
 7, 8, 9), Vector(7, 8, 9, 10))
\end_layout

\end_inset

After creating a nested sequence, we can apply an aggregation operation
 to the inner sequences.
 For example, the following code computes a sliding-window average with
 window width 
\begin_inset Formula $50$
\end_inset

 over an array of 
\begin_inset Formula $100$
\end_inset

 numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 100).map(x => math.cos(x)).sliding(50).map(_.sum / 50).take(5).toList
\end_layout

\begin_layout Plain Layout

res15: List[Double] = List(-0.005153079196990285, -0.0011160413780774369,
 0.003947079736951305, 0.005381273944717851, 0.0018679497047270743)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
The method 
\family typewriter
sortBy
\end_layout

\begin_layout Standard
sorts a sequence according to a sorting key.
 The argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sortBy
\end_layout

\end_inset

 is a 
\emph on
function
\emph default
 that computes the sorting key from a sequence element.
 This gives us flexibility to sort elements in a custom way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).sortBy(x => -x)
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(3, 2, 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

xx
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

z
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yyy
\begin_inset Quotes erd
\end_inset

).sortBy(word => word)        // Sort alphabetically.
\end_layout

\begin_layout Plain Layout

res1: Seq[String] = List(xx, yyy, z)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

xx
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

z
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yyy
\begin_inset Quotes erd
\end_inset

).sortBy(word => word.length) // Sort by word length.
\end_layout

\begin_layout Plain Layout

res2: Seq[String] = List(z, xx, yyy)
\end_layout

\end_inset

Sorting by the elements themselves, as we have done here with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.sortBy(word => word)
\end_layout

\end_inset

, is only possible if the element's type has a well-defined ordering.
 For strings, this is the alphabetic ordering, and for integers, the standard
 arithmetic ordering.
 For such types, a convenience method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sorted
\end_layout

\end_inset

 is defined, and works equivalently to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sortBy(x => x)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(
\begin_inset Quotes eld
\end_inset

xx
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

z
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

yyy
\begin_inset Quotes erd
\end_inset

).sorted
\end_layout

\begin_layout Plain Layout

res3: Seq[String] = List(xx, yyy, z)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples: Tuples and collections
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example1-for"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example1-for"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given sequence 
\begin_inset Formula $x_{i}$
\end_inset

, compute the sequence of pairs of values 
\begin_inset Formula $\left(\cos x_{i},\,\sin x_{i}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Double]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to produce a sequence that has a pair of values corresponding to
 each element of the original sequence.
 This transformation is exactly what the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method does.
 So, the code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.map { x => (math.cos(x), math.sin(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Count how many times 
\begin_inset Formula $\cos x_{i}>\sin x_{i}$
\end_inset

 occurs in a sequence 
\begin_inset Formula $x_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

, assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Double]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution 
\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 takes a predicate and returns the number of sequence elements for which
 the predicate is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.count { x => math.cos(x) > math.sin(x) }
\end_layout

\end_inset

We could also reuse the solution of Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example1-for"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that computed the cosine and the sine values.
 The code would then become:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.map { x => (math.cos(x), math.sin(x)) }
\end_layout

\begin_layout Plain Layout

  .count { case (cosine, sine) => cosine > sine }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For given sequences 
\begin_inset Formula $a_{i}$
\end_inset

 and 
\begin_inset Formula $b_{i}$
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 values, compute the sequence of differences 
\begin_inset Formula $c_{i}=a_{i}-b_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, and assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

as
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bs
\end_layout

\end_inset

 have equal length.
\end_layout

\begin_layout Subparagraph
Solution 
\end_layout

\begin_layout Standard
We can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

as
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bs
\end_layout

\end_inset

, which gives a sequence of pairs:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

as.zip(bs): Seq[(Double, Double)]
\end_layout

\end_inset

We then compute the differences 
\begin_inset Formula $a_{i}-b_{i}$
\end_inset

 by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to this sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

as.zip(bs).map { case (a, b) => a - b }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "enu:tuples-Example4-in"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tuples-Example4-in"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
In a given sequence 
\begin_inset Formula $p_{i}$
\end_inset

, count how many times 
\begin_inset Formula $p_{i}>p_{i+1}$
\end_inset

 occurs.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps: Seq[Double]
\end_layout

\end_inset

, we can compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.tail
\end_layout

\end_inset

.
 The result is a sequence that is one element shorter than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val ps = Seq(1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

ps: Seq[Int] = List(1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ps.tail
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(2, 3, 4)
\end_layout

\end_inset

Taking a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 of the two sequences 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.tail
\end_layout

\end_inset

, we get a sequence of pairs:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ps.zip(ps.tail)
\end_layout

\begin_layout Plain Layout

res1: Seq[(Int, Int)] = List((1,2), (2,3), (3,4))
\end_layout

\end_inset

Because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.tail
\end_layout

\end_inset

 is one element shorter than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

, the resulting sequence of pairs is also one element shorter than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

.
 So, it is not necessary to truncate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps
\end_layout

\end_inset

 before computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ps.zip(ps.tail)
\end_layout

\end_inset

.
 Now apply the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

 method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ps.zip(ps.tail).count { case (a, b) => a > b }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given 
\begin_inset Formula $k>0$
\end_inset

, compute the sequence 
\begin_inset Formula $c_{i}=\max(b_{i-k},...,b_{i+k})$
\end_inset

, starting at 
\begin_inset Formula $i=k$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sliding
\end_layout

\end_inset

 method to a list gives a list of nested lists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val b = List(1, 2, 3, 4, 5)     // An example of a possible sequence `b`.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> b.sliding(3).toList
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(1, 2, 3), List(2, 3, 4), List(3, 4, 5))
 
\end_layout

\end_inset

For each 
\begin_inset Formula $i$
\end_inset

, we need to obtain a list of 
\begin_inset Formula $2k+1$
\end_inset

 nearby elements 
\begin_inset Formula $\left(b_{i-k},...,b_{i+k}\right)$
\end_inset

.
 So, we need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sliding(2 * k + 1)
\end_layout

\end_inset

 to obtain a window of the required size.
 Now we can compute the maximum of each of the nested lists by using the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method on the outer list, with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 method applied to the nested lists.
 So, the argument of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method must be the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x.max
\end_layout

\end_inset

 (where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 will have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int
\end_layout

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def c(b: List[Int], k: Int) = b.sliding(2 * k + 1).toList.map(x => x.max)
\end_layout

\end_inset

This code can be written more concisely using the syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def c(b: List[Int], k: Int) = b.sliding(2 * k + 1).toList.map(_.max)
\end_layout

\end_inset

because, in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.max
\end_layout

\end_inset

 is the same as the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x.max
\end_layout

\end_inset

.
 Test this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> c(b = List(1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1), k = 1)   // Write the
 argument names for clarity.
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(3, 4, 5, 6, 6, 6, 5, 4, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Create a 
\begin_inset Formula $10\times10$
\end_inset

 multiplication table as a dictionary having the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[(Int, Int), Int]
\end_layout

\end_inset

.
 For example, a 
\begin_inset Formula $3\times3$
\end_inset

 multiplication table would be given by this dictionary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map( (1, 1) -> 1, (1, 2) -> 2, (1, 3) -> 3, (2, 1) -> 2,
\end_layout

\begin_layout Plain Layout

  (2, 2) -> 4, (2, 3) -> 6, (3, 1) -> 3, (3, 2) -> 6, (3, 3) -> 9 )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We are required to make a dictionary that maps pairs of integers 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x * y
\end_layout

\end_inset

.
 Begin by creating the list of 
\emph on
keys
\emph default
 for that dictionary, which must be a list of pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List((1,1), (1,2), ..., (2,1), (2,2), ...)
\end_layout

\end_inset

.
 We need to iterate over a sequence of values of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

; and for each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, we then need to iterate over another sequence to provide values for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 Try this computation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).map(x => List(1, 2, 3))
\end_layout

\begin_layout Plain Layout

s: List[List[Int]] = List(List(1, 2, 3), List(1, 2, 3), List(1, 2, 3))
\end_layout

\end_inset

We would like to get 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List((1,1), (1,2), 1,3))
\end_layout

\end_inset

 etc., and so we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 on the inner list with a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => (1, y)
\end_layout

\end_inset

 that converts a number into a tuple:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3).map { y => (1, y) }
\end_layout

\begin_layout Plain Layout

res0: List[(Int, Int)] = List((1,1), (1,2), (1,3))
\end_layout

\end_inset

The curly braces in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{y => (1, y)}
\end_layout

\end_inset

 are only for clarity.
 We could also use round parentheses and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 2, 3).map(y => (1, y))
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Now, we need to have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1, y)
\end_layout

\end_inset

 in the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 iterates over 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 2, 3)
\end_layout

\end_inset

 in the outside scope:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).map(x => List(1, 2, 3).map { y => (x, y) })
\end_layout

\begin_layout Plain Layout

s: List[List[(Int, Int)]] = List(List((1,1), (1,2), (1,3)), List((2,1),
 (2,2), (2,3)), List((3,1), (3,2), (3,3)))
\end_layout

\end_inset

This is almost what we need, except that the nested lists need to be concatenate
d into a single list.
 This is exactly what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 does:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).map(x => List(1, 2, 3).map { y => (x, y) }).flatten
\end_layout

\begin_layout Plain Layout

s: List[(Int, Int)] = List((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1),
 (3,2), (3,3))
\end_layout

\end_inset

It is shorter to write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.flatMap(...)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(...).flatten
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).map { y => (x, y)
 })
\end_layout

\begin_layout Plain Layout

s: List[(Int, Int)] = List((1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1),
 (3,2), (3,3)) 
\end_layout

\end_inset

This is the list of keys for the required dictionary.
 The dictionary needs to map each 
\emph on
pair
\emph default
 of integers 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x * y
\end_layout

\end_inset

.
 To create that dictionary, we will apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toMap
\end_layout

\end_inset

 to a sequence of pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(key, value)
\end_layout

\end_inset

, which in our case needs to be of the form of a nested tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x, y), x * y)
\end_layout

\end_inset

.
 To achieve that, we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 with a function that computes the product and creates those nested tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).map { y => (x, y)
 }).
\end_layout

\begin_layout Plain Layout

  map { case (x, y) => ((x, y), x * y) }
\end_layout

\begin_layout Plain Layout

s: List[((Int, Int), Int)] = List(((1,1),1), ((1,2),2), ((1,3),3), ((2,1),2),
 ((2,2),4), ((2,3),6), ((3,1),3), ((3,2),6), ((3,3),9))
\end_layout

\end_inset

We can simplify this code if we notice that we are first mapping each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 to a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

, and later mapping each tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 to a nested tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x, y), x * y)
\end_layout

\end_inset

.
 Instead, the entire computation can be done in the inner 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = List(1, 2, 3).flatMap(x => List(1, 2, 3).map { y => ((x, y),
 x * y) } )
\end_layout

\begin_layout Plain Layout

s: List[((Int, Int), Int)] = List(((1,1),1), ((1,2),2), ((1,3),3), ((2,1),2),
 ((2,2),4), ((2,3),6), ((3,1),3), ((3,2),6), ((3,3),9))
\end_layout

\end_inset

Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toMap
\end_layout

\end_inset

, we convert this list of tuples to a dictionary.
 Also, for better readability, we use Scala's pair syntax, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

key -> value
\end_layout

\end_inset

, which is equivalent to writing the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(key, value)
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to 10).flatMap(x => (1 to 10).map { y => (x, y) -> x * y }).toMap
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given sequence 
\begin_inset Formula $x_{i}$
\end_inset

, compute the maximum of all of the numbers 
\begin_inset Formula $x_{i}$
\end_inset

, 
\begin_inset Formula $x_{i}^{2}$
\end_inset

, 
\begin_inset Formula $\cos x_{i}$
\end_inset

, 
\begin_inset Formula $\sin x_{i}$
\end_inset

.
 Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will compute the required value if we take 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 of a list containing all of the numbers.
 To do that, first map each element of the list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Double]
\end_layout

\end_inset

 into a sequence of three numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val xs = List(0.1, 0.5, 0.9)  // An example list of `Double` values.
\end_layout

\begin_layout Plain Layout

xs: List[Double] = List(0.1, 0.5, 0.9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> xs.map { x => Seq(x, x * x, math.cos(x), math.sin(x)) }
\end_layout

\begin_layout Plain Layout

res0: List[Seq[Double]] = List(List(0.1, 0.010000000000000002, 0.9950041652780258,
 0.09983341664682815), List(0.5, 0.25, 0.8775825618903728, 0.479425538604203),
 List(0.9, 0.81, 0.6216099682706644, 0.7833269096274834))
\end_layout

\end_inset

This list is almost what we need, except we need to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> res0.flatten
\end_layout

\begin_layout Plain Layout

res1: List[Double] = List(0.1, 0.010000000000000002, 0.9950041652780258, 0.099833416
64682815, 0.5, 0.25, 0.8775825618903728, 0.479425538604203, 0.9, 0.81, 0.62160996827066
44, 0.7833269096274834) 
\end_layout

\end_inset

It remains to take the maximum of the resulting numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> res1.max
\end_layout

\begin_layout Plain Layout

res2: Double = 0.9950041652780258
\end_layout

\end_inset

The final code (starting from a given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

) is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

xs.flatMap { x => Seq(x, x * x, math.cos(x), math.sin(x)) }.max
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
From a dictionary of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[String, String]
\end_layout

\end_inset

 mapping names to addresses, and assuming that the addresses do not repeat,
 compute a dictionary of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[String, String]
\end_layout

\end_inset

 mapping the addresses back to names.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Iterating over a dictionary looks like iterating over a list of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(key, value)
\end_layout

\end_inset

 pairs.
 The result is converted to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map
\end_layout

\end_inset

 automatically.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

dict.map { case (name, addr) => (addr, name) } // This has type Map[String,
 String].
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the solution of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example8"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a function with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr
\end_layout

\end_inset

 instead of the fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
In Scala, the syntax for type parameters in a function definition is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def rev[Name, Addr](...) = ...
\end_layout

\end_inset

The type of the argument is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Name, Addr]
\end_layout

\end_inset

, while the type of the result is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Addr, Name]
\end_layout

\end_inset

.
 So, we use the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr
\end_layout

\end_inset

 in the type signature of the function.
 The final code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def rev[Name, Addr](dict: Map[Name, Addr]): Map[Addr, Name] =
\end_layout

\begin_layout Plain Layout

  dict.map { case (name, addr) => (addr, name) }
\end_layout

\end_inset

The body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 remains the same as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example8"
plural "false"
caps "false"
noprefix "false"

\end_inset

; only the type signature changes.
 This is because the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 works in the same way for dictionaries of any type.
 For this reason, it was easy for us to change the specific type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 into type parameters in that function.
\end_layout

\begin_layout Standard
When the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 is applied to a dictionary of a specific type, the Scala compiler will
 automatically set the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr
\end_layout

\end_inset

 that fit the required types of the dictionary's keys and values.
 For example, if we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

 to a dictionary of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Boolean, Seq[String]]
\end_layout

\end_inset

, the type parameters will be set automatically as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Name = Boolean
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Addr = Seq[String]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val d = Map(true -> Seq("x", "y"), false -> Seq("z", "t"))
\end_layout

\begin_layout Plain Layout

d: Map[Boolean, Seq[String]] = Map(true -> List(x, y), false -> List(z,
 t))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> rev(d)
\end_layout

\begin_layout Plain Layout

res0: Map[Seq[String], Boolean] = Map(List(x, y) -> true, List(z, t) ->
 false)
\end_layout

\end_inset

Type parameters can be also set explicitly when using the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rev
\end_layout

\end_inset

.
 If the type parameters are chosen incorrectly, the program will not compile:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> rev[Boolean, Seq[String]](d)
\end_layout

\begin_layout Plain Layout

res1: Map[Seq[String],Boolean] = Map(List(x, y) -> true, List(z, t) -> false)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> rev[Int, Double](d)
\end_layout

\begin_layout Plain Layout

<console>:14: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Map[Boolean,Seq[String]]
\end_layout

\begin_layout Plain Layout

 required: Map[Int,Double]
\end_layout

\begin_layout Plain Layout

       rev[Int, Double](d)
\end_layout

\begin_layout Plain Layout

                        ^
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:tuples-Example10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words: Seq[String]
\end_layout

\end_inset

 of some 
\begin_inset Quotes eld
\end_inset

words
\begin_inset Quotes erd
\end_inset

, compute a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(Seq[String], Int)]
\end_layout

\end_inset

, where each inner sequence should contain all the words having the same
 length, paired with the integer value showing that length.
 The resulting sequence must be ordered by increasing length of words.
 So, the input 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

food
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 should produce:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Seq((Seq(
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

), 2), (Seq(
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

), 3), (Seq(
\begin_inset Quotes eld
\end_inset

food
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

), 4))
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by grouping the words by length.
 The library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

 takes a function that computes a 
\begin_inset Quotes eld
\end_inset

grouping key
\begin_inset Quotes erd
\end_inset

 from each element of a sequence.
 To group by word length (computed via the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

), we write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words.groupBy { word => word.length }
\end_layout

\end_inset

or, more concisely, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words.groupBy(_.length)
\end_layout

\end_inset

.
 The result of this expression is a dictionary that maps each length to
 the list of words having that length:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> words.groupBy(_.length)
\end_layout

\begin_layout Plain Layout

res0: Map[Int,Seq[String]] = Map(2 -> List(is), 4 -> List(food, good), 3
 -> List(the))
\end_layout

\end_inset

This is close to what we need.
 If we convert this dictionary to a sequence, we will get a list of pairs:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> words.groupBy(_.length).toSeq
\end_layout

\begin_layout Plain Layout

res1: Seq[(Int, Seq[String])] = ArrayBuffer((2,List(is)), (4,List(food,
 good)), (3,List(the))) 
\end_layout

\end_inset

It remains to swap the length and the list of words and to sort the result
 by increasing length.
 We can do this in any order: first sort, then swap; or first swap, then
 sort.
 The final code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words
\end_layout

\begin_layout Plain Layout

  .groupBy(_.length)
\end_layout

\begin_layout Plain Layout

  .toSeq
\end_layout

\begin_layout Plain Layout

  .sortBy { case (len, words) => len }
\end_layout

\begin_layout Plain Layout

  .map { case (len, words) => (words, len) }
\end_layout

\end_inset

This can be written somewhat shorter if we use the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._1
\end_layout

\end_inset

 (equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x._1
\end_layout

\end_inset

) for selecting the first parts from pairs and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 for swapping the two elements of a pair:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words.groupBy(_.length).toSeq.sortBy(_._1).map(_.swap)
\end_layout

\end_inset

However, the program may now be harder to read and to modify.
\end_layout

\begin_layout Subsection
Reasoning about type parameters in collections
\end_layout

\begin_layout Standard
In Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example10"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we have applied a chain of operations to a sequence.
 Let us add comments showing the type of the intermediate result after each
 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words // Seq[String]
\end_layout

\begin_layout Plain Layout

  .groupBy(_.length)                           // Map[Int, Seq[String]]
\end_layout

\begin_layout Plain Layout

  .toSeq                                       // Seq[ (Int, Seq[String])
 ]
\end_layout

\begin_layout Plain Layout

  .sortBy { case (len, words) => len }         // Seq[ (Int, Seq[String])
 ]
\end_layout

\begin_layout Plain Layout

  .map { case (len, words) => (words, len) }   // Seq[ (Seq[String], Int)
 ]
\end_layout

\end_inset

In computations like this, the Scala compiler verifies at each step that
 the operations are applied to values of the correct types.
 Writing down the intermediate types will help us write correct code.
\end_layout

\begin_layout Standard
For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sortBy
\end_layout

\end_inset

 is defined for sequences but not for dictionaries, so it would be a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

type error to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sortBy
\end_layout

\end_inset

 to a dictionary without first converting it to a sequence using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toSeq
\end_layout

\end_inset

.
 The type of the intermediate result after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toSeq
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[ (Int, Seq[String]) ]
\end_layout

\end_inset

, and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sortBy
\end_layout

\end_inset

 operation is applied to that sequence.
 So, the sequence element matched by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (len, words) => len }
\end_layout

\end_inset

 is a tuple having the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Seq[String])
\end_layout

\end_inset

.
 Then the pattern variables 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

len
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words
\end_layout

\end_inset

 must have types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[String]
\end_layout

\end_inset

 respectively.
\begin_inset Note Note
status open

\begin_layout Plain Layout
It would be a type error to use the sorting key function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (len, words) => words }
\end_layout

\end_inset

: the sorting key can be an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

len
\end_layout

\end_inset

, but not a string sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

words
\end_layout

\end_inset

 (because string sequences do not have an automatically defined ordering).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we visualize how the type of the sequence should change at every step,
 we can more quickly understand how to implement the required task.
 Begin by writing down the intermediate types that would be needed during
 the computation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words: Seq[String]         // After groupBy() by word length, will have
 type:
\end_layout

\begin_layout Plain Layout

Map[Int, Seq[String]]      // To sort by word length, convert to a sequence:
\end_layout

\begin_layout Plain Layout

Seq[ (Int, Seq[String]) ]  // Sort by the `Int` value; type is unchanged:
\end_layout

\begin_layout Plain Layout

Seq[ (Int, Seq[String]) ]  // It remains to swap the parts of the tuples:
\end_layout

\begin_layout Plain Layout

Seq[ (Seq[String], Int) ]  // We are done.
\end_layout

\end_inset

Having written down these types, we are better assured that the computation
 can be done correctly.
 Writing the code becomes straightforward, since we are guided by the already
 known types of the intermediate results:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

words.groupBy(_.length).toSeq.sortBy(_._1).map(_.swap)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example illustrates the main benefits of reasoning about types: it
 gives direct guidance about how to organize the computation, together with
 a greater confidence about code correctness.
\end_layout

\begin_layout Subsection
Exercises: Tuples and collections
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find all integer pairs 
\begin_inset Formula $i,j$
\end_inset

 where 
\begin_inset Formula $0\leq i\leq9$
\end_inset

 and 
\begin_inset Formula $0\leq j\leq9$
\end_inset

 and 
\begin_inset Formula $i+4*j>i*j$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find all integer triples 
\begin_inset Formula $i,j,k$
\end_inset

 where 
\begin_inset Formula $0\leq i\leq9$
\end_inset

, 
\begin_inset Formula $0\leq j\leq9$
\end_inset

, 
\begin_inset Formula $0\leq k\leq9$
\end_inset

, and 
\begin_inset Formula $i+4*j+9*k>i*j*k$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given two sequences 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Seq[String]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q: Seq[Boolean]
\end_layout

\end_inset

 of equal length, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[String]
\end_layout

\end_inset

 with those elements of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 for which the corresponding element of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Convert a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Int]
\end_layout

\end_inset

 into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(Int, Boolean)]
\end_layout

\end_inset

 where the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 if an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value is followed by a larger value.
 For example, the input 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(1, 3, 2, 4)
\end_layout

\end_inset

 must be converted into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq((1,true),(3,false),(2,true),(4,false))
\end_layout

\end_inset

.
 The last value (here, 4) has no following value and is always paired with
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Seq[String]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q: Seq[Int]
\end_layout

\end_inset

 of equal length, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[String]
\end_layout

\end_inset

 that contains the strings from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 ordered according to the corresponding numbers from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

.
 For example, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p = Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q = Seq(10, -1, 5)
\end_layout

\end_inset

 then the result must be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the solution of Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a function with type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead of the fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 The type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reorder[A](p: Seq[A], q: Seq[Int]): Seq[A] = ???    // In Scala, ???
 means 
\begin_inset Quotes eld
\end_inset

not yet implemented
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reorder(Seq(6.0,2.0,8.0,4.0), Seq(20,10,40,30))  // Test with A = Double.
\end_layout

\begin_layout Plain Layout

res0: Seq[Double] = List(2.0, 6.0, 4.0, 8.0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Seq[String]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q: Seq[Int]
\end_layout

\end_inset

 of 
\emph on
equal
\emph default
 length and assuming that values in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 do not repeat, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Int, String]
\end_layout

\end_inset

 mapping numbers from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 to the corresponding strings from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the solution of Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a function with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

 instead of the fixed types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 The function's arguments should be of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Q]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[P]
\end_layout

\end_inset

, and the return type should be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[P, Q]
\end_layout

\end_inset

.
 Run some tests using types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Double
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q = Set[Boolean]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(String, Int)]
\end_layout

\end_inset

 showing a list of purchased items (where item names may repeat), compute
 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[String, Int]
\end_layout

\end_inset

 showing the total counts.
 So, for the input: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Seq((
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

pear
\begin_inset Quotes erd
\end_inset

, 3), (
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

, 5), (
\begin_inset Quotes eld
\end_inset

lemon
\begin_inset Quotes erd
\end_inset

, 2), (
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

, 3))
\end_layout

\end_inset

the output must be: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map(
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

 -> 10, 
\begin_inset Quotes eld
\end_inset

pear
\begin_inset Quotes erd
\end_inset

 -> 3, 
\begin_inset Quotes eld
\end_inset

lemon
\begin_inset Quotes erd
\end_inset

 -> 2)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Seq[Int]]
\end_layout

\end_inset

, compute a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Seq[Int]]
\end_layout

\end_inset

 where each new inner sequence contains the 
\begin_inset Formula $3$
\end_inset

 largest elements from the corresponding old inner sequence, sorted in descendin
g order (or fewer than 
\begin_inset Formula $3$
\end_inset

 elements if the old inner sequence is shorter).
 So, for the input:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Seq(Seq(0, 50, 5, 10, 30), Seq(10, 100), Seq(1, 2, 200, 20))
\end_layout

\end_inset

the output must be:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Seq(Seq(50, 30, 10), Seq(100, 10), Seq(200, 20, 2))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sortBy
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

take
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Given two sets, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Set[Int]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q: Set[Int]
\end_layout

\end_inset

, compute a set of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[(Int, Int)]
\end_layout

\end_inset

 as the 
\series bold
Cartesian product
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Cartesian product
\end_layout

\end_inset

 of the sets 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

.
 This is the set of all pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is an element from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 is an element from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Implement this computation as a function with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

I
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

J
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cartesian[I, J](p: Set[I], q: Set[J]): Set[(I, J)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cartesian(Set(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

), Set(10, 20))
\end_layout

\begin_layout Plain Layout

res0: Set[(String, Int)] = Set((a,10), (a,20), (b,10), (b,20))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 on sets.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "tuples-Exercise-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuples-Exercise-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Map[Person, Amount]]
\end_layout

\end_inset

, showing the amounts various people paid on each day, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[Person, Seq[Amount]]
\end_layout

\end_inset

, showing the sequence of payments for each person.
 Assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Person
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Amount
\end_layout

\end_inset

 are type parameters.
 The required type signature and a sample test:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person,
 Seq[Amount]] = ???
\end_layout

\begin_layout Plain Layout

// On day 1, Tarski paid 10 and G$
\backslash
text{
\backslash
color{dkgreen}
\backslash

\begin_inset Quotes erd
\end_inset

o}$del paid 20.
 On day 2, Gentzen paid 50, etc.
\end_layout

\begin_layout Plain Layout

scala> payments(Seq(Map(
\begin_inset Quotes eld
\end_inset

Tarski
\begin_inset Quotes erd
\end_inset

 -> 10, 
\begin_inset Quotes eld
\end_inset

G$
\backslash
text{
\backslash
color{mauve}
\backslash

\begin_inset Quotes erd
\end_inset

o}$del
\begin_inset Quotes erd
\end_inset

 -> 20), Map(
\begin_inset Quotes eld
\end_inset

Gentzen
\begin_inset Quotes erd
\end_inset

 -> 50), Map(
\begin_inset Quotes eld
\end_inset

Tarski
\begin_inset Quotes erd
\end_inset

 -> 50, 
\begin_inset Quotes eld
\end_inset

Church
\begin_inset Quotes erd
\end_inset

 -> 100), Map(
\begin_inset Quotes eld
\end_inset

Banach
\begin_inset Quotes erd
\end_inset

 -> 15, 
\begin_inset Quotes eld
\end_inset

Gentzen
\begin_inset Quotes erd
\end_inset

 -> 35)))
\end_layout

\begin_layout Plain Layout

res0: Map[String, Seq[Int]] = Map(Genzten -> List(50, 35), Church -> List(100),
 Banach -> List(15), Tarski -> List(10, 50), G$
\backslash
text{
\backslash

\begin_inset Quotes erd
\end_inset

o}$del -> List(20))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 on dictionaries.
\end_layout

\begin_layout Section
Converting a sequence into a single value
\end_layout

\begin_layout Standard
Until this point, we have been working with sequences using methods such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

.
 These techniques are powerful but still insufficient for certain tasks.
\end_layout

\begin_layout Standard
A simple computation that is impossible to do using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is obtaining the sum of a sequence of numbers.
 The standard library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 already does this; but we cannot re-implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 ourselves by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
 These operations always compute 
\emph on
new
\emph default
 
\emph on
sequences
\emph default
, while we need to compute a single value (the sum of all elements) from
 a sequence.
 
\end_layout

\begin_layout Standard
We have seen a few library methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 that compute a single value from a sequence; but we still cannot implement
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 using these methods.
 What we need is a more general way of converting a sequence to a single
 value, such that we could ourselves implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, and other similar computations.
\end_layout

\begin_layout Standard
Another task not easily solved with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, etc., is to compute a floating-point number from a given sequence of decimal
 digits (including a 
\begin_inset Quotes eld
\end_inset

dot
\begin_inset Quotes erd
\end_inset

 character):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToDouble(ds: Seq[Char]): Double = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsToDouble(Seq('2', '0', '4', '.', '5'))
\end_layout

\begin_layout Plain Layout

res0: Double = 204.5
\end_layout

\end_inset

Note that the same task for integer numbers (instead of floating-point numbers)
 
\emph on
can
\emph default
 be implemented via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToInt(ds: Seq[Int]): Int = {
\end_layout

\begin_layout Plain Layout

  val n = ds.length
\end_layout

\begin_layout Plain Layout

  // Compute a sequence of powers of 10, e.g., [1000, 100, 10, 1].
\end_layout

\begin_layout Plain Layout

  val powers: Seq[Int] = (0 to n - 1).map(k => math.pow(10, n - 1 - k).toInt)
\end_layout

\begin_layout Plain Layout

  // Sum the powers of 10 with coefficients from `ds`.
\end_layout

\begin_layout Plain Layout

  (ds zip powers).map { case (d, p) => d * p }.sum                       
           
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsToInt(Seq(2, 4, 0, 5))
\end_layout

\begin_layout Plain Layout

res0: Int = 2405
\end_layout

\end_inset

For this task, the required computation can be written as the formula:
\begin_inset Formula 
\[
r=\sum_{k=0}^{n-1}d_{k}*10^{n-1-k}\quad.
\]

\end_inset

The sequence of powers of 
\begin_inset Formula $10$
\end_inset

 can be computed separately and 
\begin_inset Quotes eld
\end_inset

zipped
\begin_inset Quotes erd
\end_inset

 with the sequence of digits 
\begin_inset Formula $d_{k}$
\end_inset

.
 However, for floating-point numbers, the sequence of powers of 
\begin_inset Formula $10$
\end_inset

 depends on the position of the 
\begin_inset Quotes eld
\end_inset

dot
\begin_inset Quotes erd
\end_inset

 character.
 Methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 cannot compute a sequence whose next elements depend on previous elements
 and the dependence is described by some custom function.
\end_layout

\begin_layout Subsection
Inductive definitions of aggregation functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Inductive-definitions-of-aggregation-functions"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Mathematical induction
\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction
\end_layout

\end_inset


\series default
 is a general way of expressing the dependence of next values on previously
 computed values.
 To define a function from a sequence to a single value (e.g., an aggregation
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Seq[Int] => Int
\end_layout

\end_inset

) via mathematical induction, we need to specify two computations:
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction!base case
\end_layout

\end_inset


\series default
The 
\series bold
base case
\series default
 of the induction: We need to specify what value the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 returns for an empty sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq()
\end_layout

\end_inset

.
 The standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isEmpty
\end_layout

\end_inset

 can be used to detect empty sequences.
 In case the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is defined only for non-empty sequences, we need to specify what the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 returns for a one-element sequence such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x)
\end_layout

\end_inset

, with any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction!inductive step
\end_layout

\end_inset


\series default
The 
\series bold
inductive step
\series default
: Assuming that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is already computed for some sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 (the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction!inductive assumption
\end_layout

\end_inset

inductive assumption
\series default
), how to compute the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 for a sequence with one more element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

? The sequence with one more element is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs :+ x
\end_layout

\end_inset

.
 So, we need to specify how to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs :+ x)
\end_layout

\end_inset

 assuming that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs)
\end_layout

\end_inset

 is already known.
\end_layout

\begin_layout Standard
Once these two computations are specified, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is defined (and can in principle be computed) for an arbitrary input sequence.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
This is how induction works in mathematics, and it works in the same way
 in functional programming.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this approach, the inductive definition of the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 looks like this: The base case is that the sum of an empty sequence is
 
\begin_inset Formula $0$
\end_inset

.
 That is, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq().sum == 0
\end_layout

\end_inset

.
 The inductive step says that when the result 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.sum
\end_layout

\end_inset

 is already known for a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

, and we have a sequence that has one more element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, then the new result is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.sum + x
\end_layout

\end_inset

.
 In code, this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(xs :+ x).sum == xs.sum + x
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The inductive definition of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 goes like this: The base case is an empty sequence of digits, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq()
\end_layout

\end_inset

, and the result is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 This is a convenient base case even if we never need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 to an empty sequence.
 The inductive step: If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(xs)
\end_layout

\end_inset

 is already known for a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 of digits, and we have a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs :+ x
\end_layout

\end_inset

 with one more digit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, then:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

digitsToInt(xs :+ x) == digitsToInt(xs) * 10 + x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us write inductive definitions for the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
The method 
\family typewriter
length
\end_layout

\begin_layout Standard
Base case: The length of an empty sequence is zero, so we write: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq().length == 0
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Inductive step: if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.length
\end_layout

\end_inset

 is known then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x +: xs).length == xs.length + 1
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
The method 
\family typewriter
max
\end_layout

\begin_layout Standard
The maximum element of a sequence is undefined for empty sequences.
 
\end_layout

\begin_layout Standard
Base case: for a one-element sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x).max == x
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Inductive step: if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.max
\end_layout

\end_inset

 is known then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x +: xs).max == math.max(x, xs.max)
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
The method 
\family typewriter
count
\end_layout

\begin_layout Standard
computes the number of a sequence's elements satisfying a predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Base case: for an empty sequence, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq().count(p) == 0
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Inductive step: if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.count(p)
\end_layout

\end_inset

 is known then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x +: xs).count(p) == xs.count(p) + c
\end_layout

\end_inset

, where we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c = 1
\end_layout

\end_inset

 when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x) == true
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c = 0
\end_layout

\end_inset

 otherwise.
\end_layout

\begin_layout Standard
When a function is defined by induction, proving a property of that function
 will usually involve a 
\begin_inset Quotes eld
\end_inset

proof by induction
\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
proof by induction
\end_layout

\end_inset

 As an example, let us prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(xs ++ ys).length = xs.length + ys.length
\end_layout

\end_inset

.
 We use induction on the length of the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
  In the base case, we need to prove that the property holds for an empty
 sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 (and an arbitrary sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ys
\end_layout

\end_inset

).
 To verify the base case, we write: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq() ++ ys).length == ys.length
\end_layout

\end_inset

.
 In the inductive step of the proof, we assume that the property already
 holds for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ys
\end_layout

\end_inset

 and prove that the property will then hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x +: xs
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 To verify that, we use the associativity law of the concatenation operation
 (to be proved in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-concat-array-associativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which allows us to write: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x +: xs) ++ ys == x +: (xs ++ ys)
\end_layout

\end_inset

.
 Then:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

((x +: xs) ++ ys).length     // Expect to equal (x +: xs).length + ys.length
\end_layout

\begin_layout Plain Layout

  == (x +: (xs ++ ys)).length
\end_layout

\begin_layout Plain Layout

  == 1 + (xs.length + ys.length)
\end_layout

\begin_layout Plain Layout

  == (x +: xs).length + ys.length
\end_layout

\end_inset

In this way, we show that the property holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x +: xs
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ys
\end_layout

\end_inset

 assuming it holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ys
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
There are two main ways of translating mathematical induction into code.
 The first way is to write a recursive function.
 The second way is to use a standard library function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
 Often it is better to use library functions, but sometimes the code is
 more transparent when recursion is explicit.
 So, let us consider each of these ways in turn.
\end_layout

\begin_layout Subsection
Implementing functions by recursion
\end_layout

\begin_layout Standard
A 
\series bold
recursive function
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive function
\end_layout

\end_inset


\series default
 is any function that calls itself somewhere within its own body.
 The call to itself is the 
\series bold
recursive call
\series default
.
 Recursion may be used to implement functions defined by induction.
\end_layout

\begin_layout Standard
When the body of a recursive function is evaluated, it may repeatedly call
 itself with different arguments until a result value can be computed 
\emph on
without
\emph default
 any recursive calls.
 The repeated recursive calls correspond to inductive steps, and the last
 call corresponds to the base case of the inductive definition.
 It is an error (an infinite loop) if the base case is never reached, as
 in this example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def infiniteLoop(x: Int): Int = infiniteLoop(x + 1)
\end_layout

\begin_layout Plain Layout

infiniteLoop: (x: Int)Int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> infiniteLoop(0) // You will need to press Ctrl-C to stop this.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We translate mathematical induction into code by first writing a condition
 to decide whether we have the base case or the inductive step.
 As an example, let us define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 by recursion.
 The base case returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, while the inductive step returns a value computed from the recursive call.
 Look at this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = if (s.isEmpty) 0 else {
\end_layout

\begin_layout Plain Layout

  val x = s.head  // To split s = x +: xs, compute x
\end_layout

\begin_layout Plain Layout

  val xs = s.tail // and xs.
\end_layout

\begin_layout Plain Layout

  sum(xs) + x     // Call sum(...) recursively.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 expression separates the base case from the inductive step.
 In the inductive step, it is convenient to split the given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into its first element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

x
\end_layout

\end_inset

, or the 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

, and the remainder (
\begin_inset Quotes eld
\end_inset

tail
\begin_inset Quotes erd
\end_inset

) sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 So, we split 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = x +: xs
\end_layout

\end_inset

 rather than as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = xs :+ x
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
It is easier to remember the meaning of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x +: xs
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs :+ x
\end_layout

\end_inset

 if we note that the 
\emph on
col
\emph default
on (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

:
\end_layout

\end_inset

) always points to the 
\emph on
col
\emph default
lection (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

) and the plus sign (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+
\end_layout

\end_inset

) to a single element (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

) that is being added.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For computing the sum of a numerical sequence, the order of summation does
 not matter.
 But the order of operations 
\emph on
will
\emph default
 matter for many other computational tasks.
 We will need to choose whether the inductive step should split the sequence
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = x +: xs
\end_layout

\end_inset

 or as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s = xs :+ x
\end_layout

\end_inset

, depending on the task at hand.
\end_layout

\begin_layout Standard
Let us implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 according to the inductive definition shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Inductive-definitions-of-aggregation-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToInt(s: Seq[Int]): Int = if (s.isEmpty) 0 else {
\end_layout

\begin_layout Plain Layout

  val x = s.last                 // To split s = xs :+ x, compute x
\end_layout

\begin_layout Plain Layout

  val xs = s.init                // and xs.
\end_layout

\begin_layout Plain Layout

  digitsToInt(xs) * 10 + x       // Call digitsToInt(...) recursively.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In this example, it is important to split the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

s
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs :+ x
\end_layout

\end_inset

 and not into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x +: xs
\end_layout

\end_inset

.
 The reason is that digits increase their numerical value from right to
 left, so the correct result is computed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(xs) * 10 + x
\end_layout

\end_inset

 if we split 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

s
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs :+ x
\end_layout

\end_inset

.
 For that splitting, we use the standard library methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

last
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
These examples show how mathematical induction is converted into recursive
 code.
 This approach often works but has two technical problems.
 The first problem is that the code will fail due to a stack overflow when
 the input sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 is long enough.
 In the next subsection, we will see how this problem is solved (at least
 in some cases) using tail recursion.
 
\end_layout

\begin_layout Standard
The second problem is that all inductively defined functions will use the
 same code for checking the base case and for splitting the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into the subsequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and the extra element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 This repeated common code can be put into a library function, and the Scala
 library provides such functions.
 We will look at using them in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:implementing-general-aggregation-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Tail recursion
\begin_inset CommandInset label
LatexCommand label
name "subsec:Tail-recursion"

\end_inset


\end_layout

\begin_layout Standard
The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 will fail for large enough sequences.
 To see why, consider an inductive definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 method as a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def lengthS(s: Seq[Int]): Int = if (s.isEmpty) 0 else 1 + lengthS(s.tail)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> lengthS((1 to 1000).toList)
\end_layout

\begin_layout Plain Layout

res0: Int = 1000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val s = (1 to 100000).toList
\end_layout

\begin_layout Plain Layout

s: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> lengthS(s)
\end_layout

\begin_layout Plain Layout

java.lang.StackOverflowError
\end_layout

\begin_layout Plain Layout

  at .lengthS(<console>:12)
\end_layout

\begin_layout Plain Layout

  at .lengthS(<console>:12)
\end_layout

\begin_layout Plain Layout

  at .lengthS(<console>:12)
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset

The problem is not due to insufficient main memory: we 
\emph on
are
\emph default
 able to compute and hold in memory the entire sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

.
 The problem is with the code of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

.
 This function calls itself 
\emph on
inside
\emph default
 the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + lengthS(...)
\end_layout

\end_inset

.
 Let us visualize how the computer evaluates that code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lengthS(Seq(1, 2, ..., 100000))
\end_layout

\begin_layout Plain Layout

  = 1 + lengthS(Seq(2, ..., 100000))
\end_layout

\begin_layout Plain Layout

  = 1 + (1 + lengthS(Seq(3, ..., 100000)))
\end_layout

\begin_layout Plain Layout

  = ...
\end_layout

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 will repeat the inductive step, that is, the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 part of the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, about 
\begin_inset Formula $100000$
\end_inset

 times.
 Each time, the intermediate sub-expression with nested computations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + (1 + (...))
\end_layout

\end_inset

 will get larger.
 That sub-expression needs to be held somewhere in memory until the function
 body goes into the base case, with no more recursive calls.
 When that happens, the intermediate sub-expression will contain about 
\begin_inset Formula $100000$
\end_inset

 nested function calls still waiting to be evaluated.
 A special area of memory called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
stack memory
\end_layout

\end_inset

stack memory
\series default
 is dedicated to storing the arguments for all not-yet-evaluated nested
 function calls.
 Due to the way computer memory is managed, the stack memory has a fixed
 size and cannot grow automatically.
 So, when the intermediate expression becomes large enough, it causes an
 overflow of the stack memory and crashes the program.
\end_layout

\begin_layout Standard
One way to avoid stack overflows is to use a trick called 
\series bold
tail recursion
\begin_inset Index idx
status open

\begin_layout Plain Layout
tail recursion
\end_layout

\end_inset


\series default
.
 Using tail recursion means rewriting the code so that all recursive calls
 occur at the end positions (at the 
\begin_inset Quotes eld
\end_inset

tails
\begin_inset Quotes erd
\end_inset

) of the function body.
 In other words, each recursive call must be 
\emph on
itself
\emph default
 the last computation in the function body, rather than placed inside other
 computations.
 Here is an example of tail-recursive code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def lengthT(s: Seq[Int], res: Int): Int =
\end_layout

\begin_layout Plain Layout

  if (s.isEmpty) res
\end_layout

\begin_layout Plain Layout

  else lengthT(s.tail, res + 1)
\end_layout

\end_inset

In this code, one of the branches of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 returns a fixed value without doing any recursive calls, while the other
 branch returns the result of a recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT(...)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
It is not a problem that the recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 has some sub-expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res + 1
\end_layout

\end_inset

 as its arguments, because all these sub-expressions will be computed 
\emph on
before
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is recursively called.
 The recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is the 
\emph on
last
\emph default
 computation performed by this branch of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

.
 A tail-recursive function can have many 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match/case
\end_layout

\end_inset

 branches, with or without recursive calls; but all recursive calls must
 be always the last expressions returned.
\end_layout

\begin_layout Standard
The Scala compiler will always use tail recursion when possible.
 Additionally, Scala has a feature for verifying that a function's code
 is tail-recursive: the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tailrec
\end_layout

\end_inset

 annotation.
 If a function with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tailrec
\end_layout

\end_inset

 annotation is not tail-recursive (or is not recursive at all), the program
 will not compile.
\end_layout

\begin_layout Standard
The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tailrec
\end_layout

\end_inset

 annotation looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import scala.annotation.tailrec
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@tailrec def lengthT(s: Seq[Int], res: Int): Int = 
\end_layout

\begin_layout Plain Layout

  if (s.isEmpty) res
\end_layout

\begin_layout Plain Layout

  else lengthT(s.tail, res + 1)
\end_layout

\end_inset

(The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

import
\end_layout

\end_inset

 declaration is needed whenever the code uses the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tailrec
\end_layout

\end_inset

 annotation.) Let us trace the evaluation of this function on an example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lengthT(Seq(1, 2, 3), 0)
\end_layout

\begin_layout Plain Layout

  = lengthT(Seq(2, 3), 0 + 1) // = lengthT(Seq(2, 3), 1)
\end_layout

\begin_layout Plain Layout

  = lengthT(Seq(3), 1 + 1)    // = lengthT(Seq(3), 2)
\end_layout

\begin_layout Plain Layout

  = lengthT(Seq(), 2 + 1)     // = lengthT(Seq(), 3)
\end_layout

\begin_layout Plain Layout

  = 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
All sub-expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 + 1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2 + 1
\end_layout

\end_inset

 are computed 
\emph on
before
\emph default
 recursive calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

.
 Because of that, sub-expressions do not grow within the stack memory.
 This is the main benefit of tail recursion.
\end_layout

\begin_layout Standard
How did we rewrite the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 into the tail-recursive code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

? An important difference between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthS
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is the additional argument (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res
\end_layout

\end_inset

), called the 
\series bold
accumulator
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
accumulator argument
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive function!accumulator argument
\end_layout

\end_inset

 
\series bold
argument
\series default
.
 This argument is equal to an intermediate result of the computation.
 The next intermediate result (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res + 1
\end_layout

\end_inset

) is computed and passed on to the next recursive call via the accumulator
 argument.
 In the base case of the recursion, the function now returns the accumulated
 result (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res
\end_layout

\end_inset

) rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, because at that time the computation is finished.
\end_layout

\begin_layout Standard
Rewriting code by adding an accumulator argument to achieve tail recursion
 is called the 
\series bold
accumulator technique
\series default
 or the 
\begin_inset Quotes eld
\end_inset

accumulator trick
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
One consequence of using the accumulator trick is that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 now always needs a value for the accumulator argument.
 However, our goal is to implement a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length(s)
\end_layout

\end_inset

 with just one argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s: Seq[Int]
\end_layout

\end_inset

.
 We can define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length(s) = lengthT(s, ???)
\end_layout

\end_inset

 if we supply an initial accumulator value.
 The correct initial value for the accumulator is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

, since in the base case (an empty sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

) we need to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It appears useful to define the helper function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

) separately.
 Then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 will just call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 and specify the initial value of the accumulator argument.
 To emphasize that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is a helper function that is only used by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 to achieve tail recursion, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 as a nested function inside the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def length[A](xs: Seq[A]): Int = {
\end_layout

\begin_layout Plain Layout

  @tailrec def lengthT(s: Seq[A], res: Int): Int = {
\end_layout

\begin_layout Plain Layout

    if (s.isEmpty) res
\end_layout

\begin_layout Plain Layout

    else lengthT(s.tail, res + 1)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  lengthT(xs, 0)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 is implemented like that, users will not be able to call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 directly, because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 is only visible within the body of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
Another possibility in Scala is to use a 
\series bold
default value
\begin_inset Index idx
status open

\begin_layout Plain Layout
default value
\end_layout

\end_inset


\series default
 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

res
\end_layout

\end_inset

 argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def length[A](s: Seq[A], res: Int = 0): Int = 
\end_layout

\begin_layout Plain Layout

  if (s.isEmpty) res
\end_layout

\begin_layout Plain Layout

  else length(s.tail, res + 1)
\end_layout

\end_inset

Giving a default value for a function argument is the same as defining 
\emph on
two
\emph default
 functions: one with that argument and one without.
 For example, the syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int, y: Boolean = false): Int = ...
 // Function body.
\end_layout

\end_inset

is equivalent to defining two functions with the same name but different
 numbers of arguments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int, y: Boolean) = ...
     // Define the function body here.
\end_layout

\begin_layout Plain Layout

def f(x: Int): Int = f(Int, false)  // Call the function defined above.
\end_layout

\end_inset

Using a default argument, we can define the tail-recursive helper function
 and the main function at once, making the code shorter.
\end_layout

\begin_layout Standard
The accumulator trick works in a large number of cases, but it may be not
 obvious how to introduce the accumulator argument, what its initial value
 must be, and how to define the inductive step for the accumulator.
 In the example with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lengthT
\end_layout

\end_inset

 function, the accumulator trick works because of the special mathematical
 property of the expression being computed:
\begin_inset Formula 
\[
1+\left(1+\left(1+\left(...+0\right)\right)\right)=\left(\left(\left(0+1\right)+1\right)+...\right)+1\quad.
\]

\end_inset

This equation follows from the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of addition
\end_layout

\end_inset

associativity law
\series default
 of addition.
 So, the computation can be rearranged to group all additions to the left.
 During the evaluation, the accumulator's value corresponds to a certain
 number of left-grouped parentheses, 
\begin_inset Formula $\left(\left(0+1\right)...\right)+1$
\end_inset

.
 In code, it means that intermediate expressions are fully computed before
 making recursive calls.
 So, recursive calls always occur outside all other sub-expressions — that
 is, in tail positions.
 There are no sub-expressions that need to be stored on the stack until
 all the recursive calls are complete.
 
\end_layout

\begin_layout Standard
However, not all computations can be rearranged in that way.
 Even if a code rearrangement exists, it may not be immediately obvious
 how to find it.
\end_layout

\begin_layout Standard
An example is a tail-recursive version of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 from the previous subsection, where the sub-expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(xs) * 10 + x
\end_layout

\end_inset

 was a non-tail-recursive call.
 To transform the code into a tail-recursive form, we need to rearrange
 the computation:
\begin_inset Formula 
\[
r=d_{n-1}+10*\left(d_{n-2}+10*\left(d_{n-3}+10*\left(...+10*d_{0}\right)\right)\right)\quad,
\]

\end_inset

so that the multiplications group to the left.
 We can do this by rewriting 
\begin_inset Formula $r$
\end_inset

 as:
\begin_inset Formula 
\[
r=\left(\left(d_{0}*10+d_{1}\right)*10+...\right)*10+d_{n-1}\quad.
\]

\end_inset

It follows that the digit sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 must be split into the 
\emph on
leftmost
\emph default
 digit and the rest, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s == s.head +: s.tail
\end_layout

\end_inset

.
 So, a tail-recursive implementation of the above formula is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def fromDigits(s: Seq[Int], res: Int = 0): Int =
\end_layout

\begin_layout Plain Layout

  // `res` is the accumulator.
\end_layout

\begin_layout Plain Layout

  if (s.isEmpty) res
\end_layout

\begin_layout Plain Layout

  else fromDigits(s.tail, 10 * res + s.head)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fromDigits(Seq(1, 2, 3, 4))
\end_layout

\begin_layout Plain Layout

res0: Int = 1234
\end_layout

\end_inset

Despite a similarity between this code and the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 from the previous subsection, the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromDigits
\end_layout

\end_inset

 cannot be directly derived from the inductive definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

.
 We need a separate proof that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromDigits(s, 0)
\end_layout

\end_inset

 computes the same result as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(s)
\end_layout

\end_inset

.
 This can be proved by using the following property:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-fromdigitsT-equals-fromdigits"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-fromdigitsT-equals-fromdigits"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s: Seq[Int]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r: Int
\end_layout

\end_inset

, the following equation holds:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fromDigits(s, r) == digitsToInt(s) + r * math.pow(10, s.length)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use induction on the length of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

.
 To shorten the proof, denote sequences by 
\begin_inset Formula $\left[1,2,3\right]$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(1, 2, 3)
\end_layout

\end_inset

 and temporarily write 
\begin_inset Formula $d(s)$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt(s)
\end_layout

\end_inset

 and 
\begin_inset Formula $f(s,r)$
\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromDigitsT(s, r)
\end_layout

\end_inset

.
 Then an inductive definition of 
\begin_inset Formula $f(s,r)$
\end_inset

 is:
\begin_inset Formula 
\begin{equation}
f([],r)=r\quad,\quad\quad f([x]\pplus s,r)=f(s,10*r+x)\quad.\label{eq:stmt-fromdigitsT-expand-f}
\end{equation}

\end_inset

Denoting the length of a sequence 
\begin_inset Formula $s$
\end_inset

 by 
\begin_inset Formula $\left|s\right|$
\end_inset

, we reformulate Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-fromdigitsT-equals-fromdigits"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as:
\begin_inset Formula 
\begin{equation}
f(s,r)=d(s)+r*10^{\left|s\right|}\quad.\label{eq:stmt-fromdigitsT-reformulated}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We prove Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-fromdigitsT-reformulated"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by induction.
 For the base case 
\begin_inset Formula $s=\left[\right]$
\end_inset

, we have 
\begin_inset Formula $f(\left[\right],r)=r$
\end_inset

 and 
\begin_inset Formula $d(\left[\right])+r*10^{0}=r$
\end_inset

 since 
\begin_inset Formula $d(\left[\right])=0$
\end_inset

 and 
\begin_inset Formula $\left|s\right|=0$
\end_inset

.
 The resulting equality 
\begin_inset Formula $r=r$
\end_inset

 proves the base case.
 
\end_layout

\begin_layout Standard
To prove the inductive step, we assume that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-fromdigitsT-reformulated"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for a given sequence 
\begin_inset Formula $s$
\end_inset

.
 Then write the inductive step.
 We use the symbol 
\begin_inset Formula $\overset{?}{=}$
\end_inset

 to denote equations we still need to prove:
\begin_inset Formula 
\begin{equation}
f([x]\pplus s,r)\overset{?}{=}d([x]\pplus s)+r*10^{\left|s\right|+1}\quad.\label{eq:stmt-need-to-prove-step}
\end{equation}

\end_inset

We will transform the left-hand side and the right-hand side separately,
 hoping to obtain the same expression.
 The left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is:
\begin_inset Formula 
\begin{align*}
 & f([x]\pplus s,r)\\
\text{use Eq.~(\ref{eq:stmt-fromdigitsT-expand-f})}:\quad & =f(s,10*r+x)\\
\text{use Eq.~(\ref{eq:stmt-fromdigitsT-reformulated})}:\quad & =d(s)+\left(10*r+x\right)*10^{\left|s\right|}\quad.
\end{align*}

\end_inset

The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) contains 
\begin_inset Formula $d([x]\pplus s)$
\end_inset

, which we now need to rewrite.
 Assuming that 
\begin_inset Formula $d(s)$
\end_inset

 correctly calculates a number from its digits, we use a property of decimal
 notation: a digit 
\begin_inset Formula $x$
\end_inset

 in front of 
\begin_inset Formula $n$
\end_inset

 other digits has the value 
\begin_inset Formula $x*10^{n}$
\end_inset

.
 This property can be formulated as an equation:
\begin_inset Formula 
\begin{equation}
d([x]\pplus s)=x*10^{\left|s\right|}+d(s)\quad.\label{stmt-from-digits-property}
\end{equation}

\end_inset

So, the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be rewritten as:
\begin_inset Formula 
\begin{align*}
 & d([x]\pplus s)+r*10^{\left|s\right|+1}\\
\text{use Eq.~(\ref{stmt-from-digits-property})}:\quad & =x*10^{\left|s\right|}+d(s)+r*10^{\left|s\right|+1}\\
\text{factor out }10^{\left|s\right|}:\quad & =d(s)+\left(10*r+x\right)*10^{\left|s\right|}\quad.
\end{align*}

\end_inset

We have successfully transformed both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-need-to-prove-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to the same expression.
\end_layout

\begin_layout Standard
We have not yet proved that the function 
\begin_inset Formula $d$
\end_inset

 satisfies the property in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "stmt-from-digits-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\emph on
That
\emph default
 proof also uses induction.
 Begin by writing the code of 
\begin_inset Formula $d$
\end_inset

 in a short notation:
\begin_inset Formula 
\begin{equation}
d(\left[\right])=0\quad,\quad\quad d(s\pplus[y])=d(s)*10+y\quad.\label{eq:stmt-fromdigits-code-of-d}
\end{equation}

\end_inset

The base case is Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "stmt-from-digits-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $s=[]$
\end_inset

.
 It is proved by:
\begin_inset Formula 
\[
x=d([]\pplus[x])=d([x]\pplus[])=x*10^{0}+d(\left[\right])=x\quad.
\]

\end_inset

The inductive step assumes Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "stmt-from-digits-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for a given 
\begin_inset Formula $x$
\end_inset

 and a given sequence 
\begin_inset Formula $s$
\end_inset

, and needs to prove that for any 
\begin_inset Formula $y$
\end_inset

, the same property holds with 
\begin_inset Formula $s\pplus[y]$
\end_inset

 instead of 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula 
\begin{equation}
d([x]\pplus s\pplus[y])\overset{?}{=}x*10^{\left|s\right|+1}+d(s\pplus[y])\quad.\label{eq:stmt-from-digits-induction-step}
\end{equation}

\end_inset

The left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-from-digits-induction-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is transformed into its right-hand side like this:
\begin_inset Formula 
\begin{align*}
 & d([x]\pplus s\pplus[y])\\
\text{use Eq.~(\ref{eq:stmt-fromdigits-code-of-d})}:\quad & =d([x]\pplus s)*10+y\\
\text{use Eq.~(\ref{stmt-from-digits-property})}:\quad & =(x*10^{\left|s\right|}+d(s))*10+y\\
\text{expand parentheses}:\quad & =x*10^{\left|s\right|+1}+d(s)*10+y\\
\text{use Eq.~(\ref{eq:stmt-fromdigits-code-of-d})}:\quad & =x*10^{\left|s\right|+1}+d(s\pplus[y])\quad.
\end{align*}

\end_inset

This establishes Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:stmt-from-digits-induction-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and concludes the proof.
\end_layout

\begin_layout Subsection
Implementing general aggregation (
\family typewriter
foldLeft
\family default
)
\begin_inset CommandInset label
LatexCommand label
name "subsec:implementing-general-aggregation-foldleft"

\end_inset


\end_layout

\begin_layout Standard
As a rule, an 
\series bold
aggregation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
aggregation
\end_layout

\end_inset

 computes a single value from a sequence of values.
 In general, the type of the result may be different from the type of sequence
 elements.
 To describe that general situation, we introduce type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, so that the input sequence is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 and the aggregated value is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Then an inductive definition of any aggregation function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Seq[A] => B
\end_layout

\end_inset

 looks like this:
\end_layout

\begin_layout Itemize
(Base case.) For an empty sequence, we have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(Seq()) = b0
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b0: B
\end_layout

\end_inset

 is a given value.
\end_layout

\begin_layout Itemize
(Inductive step.) Assuming that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b = f(xs)
\end_layout

\end_inset

 is already computed, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs :+ x) = g(x, b)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 is a given function, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: (A, B) => B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is written using recursion and the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

last
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B](s: Seq[A]): B =
\end_layout

\begin_layout Plain Layout

  if (s.isEmpty) b0
\end_layout

\begin_layout Plain Layout

  else g(s.last, f(s.init))
\end_layout

\end_inset

We can now refactor this code into a generic utility function, by turning
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b0
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 into parameters.
 A possible implementation is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B](s: Seq[A], b: B, g: (A, B) => B): B =
\end_layout

\begin_layout Plain Layout

  if (s.isEmpty) b
\end_layout

\begin_layout Plain Layout

  else g(s.last, f(s.init, b, g))
\end_layout

\end_inset

However, this implementation is not tail-recursive.
 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to a sequence of, say, three elements, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x, y, z)
\end_layout

\end_inset

, will create an intermediate expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(z, g(y, g(x, b)))
\end_layout

\end_inset

.
 This expression will grow with the length of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

, which is not acceptable.
 To rearrange the computation into a tail-recursive form, we need to start
 the base case at the innermost call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(x, b)
\end_layout

\end_inset

, then compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(y, g(x, b))
\end_layout

\end_inset

 and continue.
 In other words, we need to traverse the sequence starting from its 
\emph on
leftmost
\emph default
 element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, rather than starting from the right.
 So, instead of splitting the sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.init :+ s.last
\end_layout

\end_inset

 as we did in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, we need to split 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.head +: s.tail
\end_layout

\end_inset

.
 Let us also exchange the order of the arguments of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

, in order to be more consistent with the way this code is implemented in
 the Scala library.
 The resulting code is tail-recursive:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def leftFold[A, B](s: Seq[A], b: B, g: (B, A) => B): B =
\end_layout

\begin_layout Plain Layout

  if (s.isEmpty) b
\end_layout

\begin_layout Plain Layout

  else leftFold(s.tail, g(b, s.head), g)
\end_layout

\end_inset

We call this function a 
\begin_inset Quotes eld
\end_inset

left fold
\begin_inset Quotes erd
\end_inset

 because it aggregates (or 
\begin_inset Quotes eld
\end_inset

folds
\begin_inset Quotes erd
\end_inset

) the sequence starting from the leftmost element.
\end_layout

\begin_layout Standard
In this way, we have defined a general method of computing any inductively
 defined aggregation function on a sequence.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 implements the logic of aggregation
\begin_inset Index idx
status open

\begin_layout Plain Layout
aggregation
\end_layout

\end_inset

 defined via mathematical induction.
 Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

, we can write concise implementations of methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, and many other aggregation functions.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 already contains all the code necessary to set up the base case and the
 inductive step.
 The programmer just needs to specify the expressions for the initial value
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 and for the updater function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
As a first example, let us use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 for implementing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = leftFold(s, 0, (x, y) => x + y )
\end_layout

\end_inset

To understand in detail how 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 works, let us trace the evaluation of this function when applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(1, 2, 3)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sum(Seq(1, 2, 3)) == leftFold(Seq(1, 2, 3), 0, g)
\end_layout

\begin_layout Plain Layout

                         // Here, g = (x, y) => x + y, so g(x, y) = x +
 y.
\end_layout

\begin_layout Plain Layout

  == leftFold(Seq(2, 3), g(0, 1), g)                      // g (0, 1) =
 1.
\end_layout

\begin_layout Plain Layout

  == leftFold(Seq(2, 3), 1, g)       // Now expand the code of `leftFold`.
\end_layout

\begin_layout Plain Layout

  == leftFold(Seq(3), g(1, 2), g)         // g(1, 2) = 3; expand the code.
\end_layout

\begin_layout Plain Layout

  == leftFold(Seq(), g(3, 3), g)          // g(3, 3) = 6; expand the code.
\end_layout

\begin_layout Plain Layout

  == 6
\end_layout

\end_inset

The second argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 is the accumulator argument.
 The initial value of the accumulator is specified when first calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

.
 At each iteration, the new accumulator value is computed by calling the
 updater function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

, which uses the previous accumulator value and the value of the next sequence
 element.
 To visualize the process of recursive evaluation, it is convenient to write
 a table showing the sequence elements and the accumulator values as they
 are updated:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Current element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Old accumulator value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
New accumulator value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

6
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
We implemented 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 only as an illustration.
 Scala's library has a method called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 implementing the same logic using a slightly different type signature.
 To see this difference, compare the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 using our 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

leftFold
\end_layout

\end_inset

 function and using the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = leftFold(s, 0, (x, y) => x + y )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def sum(s: Seq[Int]): Int = s.foldLeft(0) { (x, y) => x + y }
\end_layout

\end_inset

The syntax of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 makes it more convenient to use a nameless function as the updater argument
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, since curly braces separate that argument from others.
 We will use the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 method from now on.
\end_layout

\begin_layout Standard
In general, the type of the accumulator value can be different from the
 type of the sequence elements.
 An example is an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

count
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def count[A](s: Seq[A], p: A => Boolean): Int =
\end_layout

\begin_layout Plain Layout

  s.foldLeft(0) { (x, y) => x + (if (p(y)) 1 else 0) }
\end_layout

\end_inset

The accumulator has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, while the sequence elements can have an arbitrary type, parameterized
 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 method works in the same way for all types of accumulators and all types
 of sequence elements.
\end_layout

\begin_layout Standard
Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is tail-recursive, stack overflows will not occur even with long sequences.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is available in the Scala library for all collections, including dictionaries
 and sets.
\end_layout

\begin_layout Standard
It is important to gain experience using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 method.
 The Scala library contains several other methods similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldRight
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
 In the following sections, we will mostly focus on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 because the other fold-like operations are similar.
\end_layout

\begin_layout Subsection
Examples: Using 
\family typewriter
foldLeft
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-1-max-foldleft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-1-max-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for implementing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 function for integer sequences.
 Return the special value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int.MinValue
\end_layout

\end_inset

 for empty sequences.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by writing an inductive formulation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 function for sequences.
 Base case: For an empty sequence, return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int.MinValue
\end_layout

\end_inset

.
 Inductive step: If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 is already computed on a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max(xs) = b
\end_layout

\end_inset

, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 on a sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs :+ x
\end_layout

\end_inset

 is the maximum of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 So, the code is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def max(s: Seq[Int]): Int = s.foldLeft(Int.MinValue) { (b, x) => if (b > x)
 b else x }
\end_layout

\end_inset

If we are sure that the function will never be called on empty sequences,
 we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 in a simpler way by using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def max(s: Seq[Int]): Int = s.reduce { (x, y) => if (y > x) y else x }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-3-digitstoint-foldleft-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-3-digitstoint-foldleft-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given non-empty sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Double]
\end_layout

\end_inset

, compute the minimum, the maximum, and the mean as a tuple 
\begin_inset Formula $\left(x_{\min},x_{\max},x_{\text{mean}}\right)$
\end_inset

.
 The sequence should be traversed only once; i.e., the entire code must be
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.foldLeft(...)
\end_layout

\end_inset

, using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 only once.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Without the requirement of using a single traversal, we would write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(xs.min, xs.max, xs.sum / xs.length)
\end_layout

\end_inset

However, this code traverses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 at least three times, since each of the aggregations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.max
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.sum
\end_layout

\end_inset

 iterates over 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 We need to combine the four inductive definitions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

 into a single inductive definition of some function.
 What is the type of that function's return value? We need to accumulate
 intermediate values of 
\emph on
all four
\emph default
 numbers (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

length
\end_layout

\end_inset

) in a tuple.
 So, the required type of the accumulator is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double, Double, Int)
\end_layout

\end_inset

.
 To avoid repeating a long type expression, we can define a type alias
\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

 for it, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D4
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> type D4 = (Double, Double, Double, Int)
\end_layout

\begin_layout Plain Layout

defined type alias D4 
\end_layout

\end_inset

The updater updates each of the four numbers according to the definitions
 of their inductive steps:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def update(p: D4, x: Double): D4 = p match { case (min, max, sum, length)
 =>
\end_layout

\begin_layout Plain Layout

   (math.min(x, min), math.max(x, max), x + sum, length + 1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Now we can write the code of the required function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(xs: Seq[Double]): (Double, Double, Double) = {
\end_layout

\begin_layout Plain Layout

  val init: D4 = (Double.PositiveInfinity, Double.NegativeInfinity, 0.0, 0)
\end_layout

\begin_layout Plain Layout

  val (min, max, sum, length) = xs.foldLeft(init)(update)
\end_layout

\begin_layout Plain Layout

  (min, max, sum/length)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(Seq(1.0, 1.5, 2.0, 2.5, 3.0))
\end_layout

\begin_layout Plain Layout

res0: (Double, Double, Double) = (1.0,3.0,2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-foldleft-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-foldleft-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for sequences by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 The input sequence should be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 and the output sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[B]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are type parameters.
 The required type signature of the function and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> map(List(1, 2, 3)) { x => x * 10 }
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(10, 20, 30)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The required code should build a new sequence by applying the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each element.
 How can we build a new sequence using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

? The evaluation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 consists of iterating over the input sequence and accumulating some result
 value, which is updated at each iteration.
 Since the result of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is always equal to the last computed accumulator value, it follows that
 the new sequence should 
\emph on
be
\emph default
 that accumulator value.
 So, we need to update the accumulator by appending the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is the current element of the input sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Seq[B]()) { (acc, x) => acc :+ f(x) }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-3-digitstoint-foldleft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-3-digitstoint-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The inductive definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 is directly translated into code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToInt(d: Seq[Int]): Int =
\end_layout

\begin_layout Plain Layout

  d.foldLeft(0){ (n, x) => n * 10 + x }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-4-digitstodouble-foldleft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-4-digitstodouble-foldleft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 The argument is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Char]
\end_layout

\end_inset

.
 As a test, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble(Seq('3','4','.','2','5'))
\end_layout

\end_inset

 must evaluate to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

34.25
\end_layout

\end_inset

.
 Assume that all input characters are either digits or a dot (so, negative
 numbers are not supported).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The evaluation of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 on a sequence of digits will visit the sequence from left to right.
 The updating function should work as in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToInt
\end_layout

\end_inset

 until a dot character is found.
 After that, we need to change the updating function.
 So, we need to remember whether a dot character has been seen.
 The only way for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to 
\begin_inset Quotes eld
\end_inset

remember
\begin_inset Quotes erd
\end_inset

 any data is to hold that data in the accumulator value.
 We can choose the type of the accumulator according to our needs.
 So, for this task we can choose the accumulator to be a 
\emph on
tuple
\emph default
 that contains, for instance, the floating-point result constructed so far
 and a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 flag showing whether we have already seen the dot character.
\end_layout

\begin_layout Standard
Let us consider how the evaluation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble(Seq('3', '4', '.', '2', '5'))
\end_layout

\end_inset

 should go.
 We can write a table showing the intermediate result at each iteration.
 This will hopefully help us figure out what the accumulator and the updater
 function 
\begin_inset Formula $g(...)$
\end_inset

 must be:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Current digit 
\begin_inset Formula $c$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Previous result 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
New result 
\begin_inset Formula $n'=g(n,c)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'3'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $0.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $3.0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'4'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $3.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'.'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'2'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $34.0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $34.2$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'5'
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $34.2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $34.25$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
While the dot character was not yet seen, the updater function multiplies
 the previous result by 
\begin_inset Formula $10$
\end_inset

 and adds the current digit.
 After the dot character, the updater function must add to the previous
 result the current digit divided by a factor that represents increasing
 powers of 
\begin_inset Formula $10$
\end_inset

.
 In other words, the update computation 
\begin_inset Formula $n'=g(n,c)$
\end_inset

 must be defined by:
\begin_inset Formula 
\[
g(n,c)=\begin{cases}
n*10+c & \text{if the digit is before the dot}\\
n+c/f & \text{if after the dot, where }f=10,100,1000,...\text{ for each new digit}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
The updater function 
\begin_inset Formula $g$
\end_inset

 has only two arguments: the current digit and the previous accumulator
 value.
 So, the changing factor 
\begin_inset Formula $f$
\end_inset

 must be 
\emph on
part
\emph default
 
\emph on
of
\emph default
 the accumulator value, and must be multiplied by 
\begin_inset Formula $10$
\end_inset

 at each digit after the dot.
 If the factor 
\begin_inset Formula $f$
\end_inset

 is not a part of the accumulator value, the function 
\begin_inset Formula $g$
\end_inset

 will not have enough information for computing the next accumulator value
 correctly.
 So, the updater computation must be 
\begin_inset Formula $n'=g(n,c,f)$
\end_inset

, not 
\begin_inset Formula $n'=g(n,c)$
\end_inset

.
\end_layout

\begin_layout Standard
For this reason, we choose the accumulator type as a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Boolean, Double)
\end_layout

\end_inset

 where the first number is the result 
\begin_inset Formula $n$
\end_inset

 computed so far, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 flag indicates whether the dot was already seen, and the third number is
 
\begin_inset Formula $f$
\end_inset

, that is, the power of 
\begin_inset Formula $10$
\end_inset

 by which the current digit will be divided if the dot was already seen.
 Initially, the accumulator tuple will be equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(0.0, false, 10.0)
\end_layout

\end_inset

.
 Then the updater function is implemented like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def update(acc: (Double, Boolean, Double), c: Char): (Double, Boolean, Double)
 =
\end_layout

\begin_layout Plain Layout

  acc match { case (num, flag, factor) =>
\end_layout

\begin_layout Plain Layout

    if (c == '.') (num, true, factor) // Set flag to `true` after seeing
 a dot.
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      val digit = c.asDigit        // Convert a character to decimal digit.
\end_layout

\begin_layout Plain Layout

      if (flag) (num + digit / factor, flag, factor * 10) // After the dot.
\end_layout

\begin_layout Plain Layout

      else (num * 10 + digit, flag, factor)               // Before the
 dot.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

Now we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsToDouble
\end_layout

\end_inset

 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsToDouble(d: Seq[Char]): Double = {
\end_layout

\begin_layout Plain Layout

  val initAcc = (0.0, false, 10.0)
\end_layout

\begin_layout Plain Layout

  val (num, _, _) = d.foldLeft(initAcc)(update)
\end_layout

\begin_layout Plain Layout

  num
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsToDouble(Seq('3', '4', '.', '2', '5'))
\end_layout

\begin_layout Plain Layout

res0: Double = 34.25
\end_layout

\end_inset

The result of calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

d.foldLeft
\end_layout

\end_inset

 is a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(num, flag, factor)
\end_layout

\end_inset

, in which only the first part, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

num
\end_layout

\end_inset

, is needed.
 In Scala's pattern matching syntax, the underscore (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

_
\end_layout

\end_inset

) denotes pattern variables whose values are not needed in the code.
 We could get the first part using the accessor method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

._1
\end_layout

\end_inset

, but the code will be more readable if we show all parts of the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(num, _, _)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-foldleft-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-foldleft-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toPairs
\end_layout

\end_inset

 that converts a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 to a sequence of pairs, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(A, A)]
\end_layout

\end_inset

, by putting together the adjacent elements pairwise.
 If the initial sequence has an odd number of elements, a given default
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is used to fill the last pair.
 The required type signature and an example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toPairs[A](xs: Seq[A], default: A): Seq[(A, A)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toPairs(Seq(1, 2, 3, 4, 5, 6), -1)
\end_layout

\begin_layout Plain Layout

res0: Seq[(Int, Int)] = List((1,2), (3,4), (5,6))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toPairs(Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

), 
\begin_inset Quotes eld
\end_inset

<nothing>
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res1: Seq[(String, String)] = List((a,b), (c,<nothing>)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to accumulate a sequence of pairs, and each pair needs two values.
 However, we iterate over values in the input sequence one by one.
 So, a new pair can be made only once every two iterations.
 The accumulator needs to hold the information about the current iteration
 being even or odd.
 For odd-numbered iterations, the accumulator also needs to store the previous
 element that is still waiting for its pair.
 Therefore, we choose the type of the accumulator to be a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq[(A, A)], Seq(A))
\end_layout

\end_inset

.
 The first sequence is the intermediate result, and the second sequence
 is the 
\begin_inset Quotes eld
\end_inset

holdover
\begin_inset Quotes erd
\end_inset

: it holds the previous element for odd-numbered iterations and is empty
 for even-numbered iterations.
 Initially, the accumulator should be empty.
 An example evaluation is:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Current element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Previous accumulator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Next accumulator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq(), Seq())
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq(), Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq(), Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq((
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

)), Seq())
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq((
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

)), Seq())
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Seq((
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

b
\begin_inset Quotes erd
\end_inset

)), Seq(
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Now it becomes clear how to implement the updater function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Acc = (Seq[(A, A)], Seq[A])     // Type alias, for brevity.
\end_layout

\begin_layout Plain Layout

def updater(acc: Acc, x: A): Acc = acc match {
\end_layout

\begin_layout Plain Layout

    case (result, Seq())      => (result, Seq(x))
\end_layout

\begin_layout Plain Layout

    case (result, Seq(prev))  => (result :+ ((prev, x)), Seq())
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

We will call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 with this updater and then perform some post-processing to make sure we
 create the last pair in case the last iteration is odd-numbered, i.e., when
 the 
\begin_inset Quotes eld
\end_inset

holdover
\begin_inset Quotes erd
\end_inset

 is not empty after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is finished.
 In this implementation, we use pattern matching to decide whether a sequence
 is empty:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toPairs[A](xs: Seq[A], default: A): Seq[(A, A)] = {
\end_layout

\begin_layout Plain Layout

  type Acc = (Seq[(A, A)], Seq[A])     // Type alias, for brevity.
\end_layout

\begin_layout Plain Layout

  def init: Acc = (Seq(), Seq())
\end_layout

\begin_layout Plain Layout

  def updater(acc: Acc, x: A): Acc = acc match {
\end_layout

\begin_layout Plain Layout

    case (result, Seq())      => (result, Seq(x))
\end_layout

\begin_layout Plain Layout

    case (result, Seq(prev))  => (result :+ ((prev, x)), Seq())
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  val (result, holdover) = xs.foldLeft(init)(updater)
\end_layout

\begin_layout Plain Layout

  holdover match {    // May need to append the last element to the result.
\end_layout

\begin_layout Plain Layout

    case Seq()    => result
\end_layout

\begin_layout Plain Layout

    case Seq(x)   => result :+ ((x, default))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code shows examples of partial functions that are applied safely.
 One of these partial functions is used in this sub-expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

holdover match {
\end_layout

\begin_layout Plain Layout

  case Seq()    => ...
\end_layout

\begin_layout Plain Layout

  case Seq(a)   => ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code works when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

holdover
\end_layout

\end_inset

 is empty or has length 
\begin_inset Formula $1$
\end_inset

 but fails for longer sequences.
 In the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

toPairs
\end_layout

\end_inset

, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

holdover
\end_layout

\end_inset

 will always be a sequence of length at most 
\begin_inset Formula $1$
\end_inset

, so it is safe to use this partial function.
\end_layout

\begin_layout Subsection
Exercises: Using 
\family typewriter
foldLeft
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fromPairs
\end_layout

\end_inset

 that performs the inverse transformation to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toPairs
\end_layout

\end_inset

 function defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-foldleft-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required type signature and a sample test are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fromPairs[A](xs: Seq[(A, A)]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fromPairs(Seq((1, 2), (3, 4)))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(1, 2, 3, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: This can be done with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 or with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method for sequences by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 The required type signature and a sample test are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatten[A](xxs: Seq[Seq[A]]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> flatten(Seq(Seq(1, 2, 3), Seq(), Seq(4)))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(1, 2, 3, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zipWithIndex
\end_layout

\end_inset

 method for sequences.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def zipWithIndex[A](xs: Seq[A]): Seq[(A, Int)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> zipWithIndex(Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

res0: Seq[(String, Int)] = List((a, 0), (b, 1), (c, 2), (d, 3))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filterMap
\end_layout

\end_inset

 that combines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 for sequences.
 The predicate is applied to the elements of the initial sequence, and values
 that pass the predicate are mapped.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def filterMap[A, B](xs: Seq[A])(pred: A => Boolean)(f: A => B): Seq[B] =
 ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> filterMap(Seq(1, 2, 3, 4)) { x => x > 2 } { x => x * 10 }
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(30, 40)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Split a sequence into subsequences (
\begin_inset Quotes eld
\end_inset

batches
\begin_inset Quotes erd
\end_inset

) of length at most 
\begin_inset Formula $n$
\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def byLength[A](xs: Seq[A], maxLength: Int): Seq[Seq[A]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> byLength(Seq("a", "b", "c", "d"), 2)
\end_layout

\begin_layout Plain Layout

res0: Seq[Seq[String]] = List(List(a, b), List(c, d))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> byLength(Seq(1, 2, 3, 4, 5, 6, 7), 3)
\end_layout

\begin_layout Plain Layout

res1: Seq[Seq[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Split a sequence into batches by 
\begin_inset Quotes eld
\end_inset

weight
\begin_inset Quotes erd
\end_inset

 computed via a given function.
 The total weight of items in any batch should not be larger than a given
 maximum weight.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def byWeight[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]] =
 ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> byWeight((1 to 10).toList, 5.75){ x => math.sqrt(x) }
\end_layout

\begin_layout Plain Layout

res0: Seq[Seq[Int]] = List(List(1, 2, 3), List(4, 5), List(6, 7), List(8),
 List(9), List(10))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-2.2-foldleft-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-2.2-foldleft-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

 function.
 The type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> groupBy(Seq(1, 2, 3, 4, 5)){ x => x % 2 }
\end_layout

\begin_layout Plain Layout

res0: Map[Int, Seq[Int]] = Map(1 -> List(1, 3, 5), 0 -> List(2, 4))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hints: The accumulator should be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, Seq[A]]
\end_layout

\end_inset

.
 Use the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

updated
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getOrElse
\end_layout

\end_inset

 to work with dictionaries.
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getOrElse
\end_layout

\end_inset

 fetches a value from a dictionary by key but returns a default value if
 the key is not in the dictionary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 -> 1, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 -> 2).getOrElse(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 300)
\end_layout

\begin_layout Plain Layout

res0: Int = 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map("a" -> 1, "b" -> 2).getOrElse("c", 300)
\end_layout

\begin_layout Plain Layout

res1: Int = 300
\end_layout

\end_inset

The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

updated
\end_layout

\end_inset

 produces a new dictionary that contains a new value for the given key,
 whether or not that key already exists in the dictionary:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 -> 1, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 -> 2).updated(
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 300) // Key is new.
\end_layout

\begin_layout Plain Layout

res0: Map[String,Int] = Map(a -> 1, b -> 2, c -> 300)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map("a" -> 1, "b" -> 2).updated("a", 400) // Key already exists.
\end_layout

\begin_layout Plain Layout

res1: Map[String,Int] = Map(a -> 400, b -> 2) 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Generating a sequence from a single value
\begin_inset CommandInset label
LatexCommand label
name "sec:ch2Converting-a-single"

\end_inset


\end_layout

\begin_layout Standard
An aggregation converts (
\begin_inset Quotes eld
\end_inset

folds
\begin_inset Quotes erd
\end_inset

) a sequence into a single value; the opposite operation (
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

) builds a new sequence from a single value and other needed information.
 An example is computing the decimal digits of a given integer:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(x: Int): Seq[Int] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsOf(2405)
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(2, 4, 0, 5)
\end_layout

\end_inset

We cannot implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, because these methods work only if we 
\emph on
already have
\emph default
 a sequence; but the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

digitsOf
\end_layout

\end_inset

 needs to create a new sequence.
 We could create a sequence via the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n)
\end_layout

\end_inset

 if the required length of the sequence were known in advance.
 However, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

 must produce a sequence whose length is determined by a condition that
 we cannot easily evaluate in advance.
\end_layout

\begin_layout Standard
A general 
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

 operation needs to build a sequence whose length is not determined in advance.
 This kind of sequence is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
stream
\end_layout

\end_inset


\series bold
stream
\series default
.
 The elements of a stream are computed only when necessary (unlike the elements
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

, which are all computed in advance).
 The unfolding operation will compute next elements on demand; this creates
 a stream.
 We can then apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 to the stream, in order to stop it when a certain condition holds.
 Finally, if required, the truncated stream may be converted to a list or
 another type of sequence.
 In this way, we can generate a sequence of initially unknown length according
 to any given requirements.
\end_layout

\begin_layout Standard
The Scala library has a general stream-producing function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
In Scala 3, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 class is replaced by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LazyList
\end_layout

\end_inset

.
\end_layout

\end_inset

 This function has two arguments, the initial value and a function that
 computes the next value from the previous one:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(2) { x => x + 10 }
\end_layout

\begin_layout Plain Layout

res0: Stream[Int] = Stream(2, ?)
\end_layout

\end_inset

The stream is ready to start computing the next elements of the sequence
 (so far, only the first element, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2
\end_layout

\end_inset

, has been computed).
 In order to see the next elements, we need to stop the stream at a finite
 size and then convert the result to a list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(2) { x => x + 10 }.take(6).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(2, 12, 22, 32, 42, 52)
\end_layout

\end_inset

If we try to evaluate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 on a stream without first limiting its size via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

take
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

, the program will keep producing more elements until it runs out of memory
 and crashes.
\end_layout

\begin_layout Standard
Streams have methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 similar to sequences.
 For instance, the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

drop
\end_layout

\end_inset

 skips a given number of initial elements:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(10, 20, 30, 40, 50).drop(3)
\end_layout

\begin_layout Plain Layout

res2: Seq[Int] = List(40, 50)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Stream.iterate(2) { x => x + 10 }.drop(3)
\end_layout

\begin_layout Plain Layout

res3: Stream[Int] = Stream(32, ?)
\end_layout

\end_inset

This example shows that in order to evaluate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

drop(3)
\end_layout

\end_inset

, the stream had to compute its elements up to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

32
\end_layout

\end_inset

 (but the subsequent elements are still not computed).
\end_layout

\begin_layout Standard
To figure out the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

, we first write this function as a mathematical formula.
 To compute the digits of, say, 
\begin_inset Formula $n=2405$
\end_inset

, we need to divide 
\begin_inset Formula $n$
\end_inset

 repeatedly by 
\begin_inset Formula $10$
\end_inset

, getting a sequence 
\begin_inset Formula $n_{k}$
\end_inset

 of intermediate numbers (
\begin_inset Formula $n_{0}=2405$
\end_inset

, 
\begin_inset Formula $n_{1}=240$
\end_inset

, ...) and the corresponding sequence of last digits, 
\begin_inset Formula $n_{k}\,\%\,10$
\end_inset

 (in this example: 
\begin_inset Formula $5$
\end_inset

, 
\begin_inset Formula $0$
\end_inset

, ...).
 The sequence 
\begin_inset Formula $n_{k}$
\end_inset

 is defined using mathematical induction:
\end_layout

\begin_layout Itemize
Base case: 
\begin_inset Formula $n_{0}=n$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is a given initial integer.
\end_layout

\begin_layout Itemize
Inductive step: 
\begin_inset Formula $n_{k+1}=\left\lfloor \frac{n_{k}}{10}\right\rfloor \ \text{for}\ k=1,2,...$
\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\left\lfloor \frac{n_{k}}{10}\right\rfloor $
\end_inset

 is the mathematical notation for the integer division by 
\begin_inset Formula $10$
\end_inset

.
 Let us tabulate the evaluation of the sequence 
\begin_inset Formula $n_{k}$
\end_inset

 for 
\begin_inset Formula $n=2405$
\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $k=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $3$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $4$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $5$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $6$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $n_{k}=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $2405$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $240$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $24$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $n_{k}\,\%\,10=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $5$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $4$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The numbers 
\begin_inset Formula $n_{k}$
\end_inset

 will remain all zeros after 
\begin_inset Formula $k=4$
\end_inset

.
 It is clear that the useful part of the sequence is before it becomes all
 zeros.
 In this example, the sequence 
\begin_inset Formula $n_{k}$
\end_inset

 needs to be stopped at 
\begin_inset Formula $k=4$
\end_inset

.
 The sequence of digits then becomes 
\begin_inset Formula $\left[5,0,4,2\right]$
\end_inset

, and we need to reverse it to obtain 
\begin_inset Formula $\left[2,4,0,5\right]$
\end_inset

.
 For reversing a sequence, the Scala library has the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

.
 So, a complete implementation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

digitsOf
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] =
\end_layout

\begin_layout Plain Layout

  if (n == 0) Seq(0) else { // n == 0 is a special case.
\end_layout

\begin_layout Plain Layout

    Stream.iterate(n) { nk => nk / 10 }
\end_layout

\begin_layout Plain Layout

      .takeWhile { nk => nk != 0 }
\end_layout

\begin_layout Plain Layout

      .map { nk => nk % 10 }
\end_layout

\begin_layout Plain Layout

      .toList.reverse
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

We can shorten the code by using the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_ % 10)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ nk => nk % 10 }
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsOf(n: Int): Seq[Int] =
\end_layout

\begin_layout Plain Layout

  if (n == 0) Seq(0) else { // n == 0 is a special case.
\end_layout

\begin_layout Plain Layout

    Stream.iterate(n)(_ / 10)
\end_layout

\begin_layout Plain Layout

      .takeWhile(_ != 0)
\end_layout

\begin_layout Plain Layout

      .map(_ % 10)
\end_layout

\begin_layout Plain Layout

      .toList.reverse
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The type signature of the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def iterate[A](init: A)(next: A => A): Stream[A]
\end_layout

\end_inset

This shows a close correspondence to a definition by mathematical induction.
 The base case is the first value (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

) and the inductive step is a function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

) that computes the next element from the previous one.
 It is a general way of creating sequences whose length is not determined
 in advance.
\end_layout

\begin_layout Section
Transforming a sequence into another sequence
\begin_inset CommandInset label
LatexCommand label
name "sec:Transforming-a-sequence"

\end_inset


\end_layout

\begin_layout Standard
We have seen methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 that transform sequences into sequences.
 However, these methods cannot express a general transformation where the
 elements of the new sequence are defined by induction and depend on previous
 elements.
 An example of this kind is computing the partial sums of a given sequence
 
\begin_inset Formula $x_{i}$
\end_inset

, say 
\begin_inset Formula $b_{k}=\sum_{i=0}^{k-1}x_{i}$
\end_inset

.
 This formula defines 
\begin_inset Formula $b_{0}=0$
\end_inset

, 
\begin_inset Formula $b_{1}=x_{0}$
\end_inset

, 
\begin_inset Formula $b_{2}=x_{0}+x_{1}$
\end_inset

, 
\begin_inset Formula $b_{3}=x_{0}+x_{1}+x_{2}$
\end_inset

, etc.
 A definition via mathematical induction may be written like this:
\end_layout

\begin_layout Itemize
Base case: 
\begin_inset Formula $b_{0}=0$
\end_inset

.
\end_layout

\begin_layout Itemize
Inductive step: Given 
\begin_inset Formula $b_{k}$
\end_inset

, we define 
\begin_inset Formula $b_{k+1}=b_{k}+x_{k}$
\end_inset

 for 
\begin_inset Formula $k=0,1,2,...$
\end_inset


\end_layout

\begin_layout Standard
The Scala library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 implements a general sequence-to-sequence transformation defined in this
 way.
 The code implementing the partial sums is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def partialSums(xs: Seq[Int]): Seq[Int] = xs.scanLeft(0){ (x, y) => x + y
 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> partialSums(Seq(1, 2, 3, 4))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(0, 1, 3, 6, 10)
\end_layout

\end_inset

The first argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 is the base case, and the second argument is an updater function describing
 the inductive step.
\end_layout

\begin_layout Standard
In general, the type of elements of the second sequence is different from
 that of the first sequence.
 The updater function takes an element of the first sequence and a previous
 element of the second sequence, and returns the next element of the second
 sequence.
 Note that the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 is one element longer than the original sequence, because the base case
 provides an initial value.
\end_layout

\begin_layout Standard
Until now, we have seen that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is sufficient to re-implement almost every method that works on sequences,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

.
 Let us show, as an illustration, how to implement the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 In the implementation, the accumulator contains the previous element of
 the second sequence together with a growing fragment of that sequence,
 which is updated as we iterate over the first sequence.
 The code is:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def scanLeft[A, B](xs: Seq[A])(b0: B)(next: (B, A) => B): Seq[B] = {
\end_layout

\begin_layout Plain Layout

  val init: (B, Seq[B]) = (b0, Seq(b0))
\end_layout

\begin_layout Plain Layout

  val (_, result) = xs.foldLeft(init) {
\end_layout

\begin_layout Plain Layout

    case ((b, seq), x) =>
\end_layout

\begin_layout Plain Layout

      val newB = next(b, x)
\end_layout

\begin_layout Plain Layout

      (newB, seq :+ newB)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To implement the (nameless) updater function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 in lines 4–6, we used a Scala feature that makes it easier to define functions
 with several arguments containing tuples.
 In our case, the updater function in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 has two arguments: the first is a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(B, Seq[B])
\end_layout

\end_inset

, the second is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Although the pattern expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case ((b, seq), x) => ...
\end_layout

\end_inset

 appears to match a nested tuple
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!nested in pattern matching
\end_layout

\end_inset

, it is just a special syntax.
 In reality, this expression matches the two arguments of the updater function
 and, at the same time, destructures the tuple argument as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(b, seq)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
We have seen a number of ways for translating mathematical induction into
 Scala code.
 What problems can we solve now?
\end_layout

\begin_layout Itemize
Compute mathematical expressions involving arbitrary recursion.
\end_layout

\begin_layout Itemize
Use the accumulator trick to enforce tail recursion.
\end_layout

\begin_layout Itemize
Implement functions with type parameters.
\end_layout

\begin_layout Itemize
Use arbitrary inductive (i.e., recursive) formulas to:
\end_layout

\begin_deeper
\begin_layout Itemize
convert sequences to single values (aggregation or 
\begin_inset Quotes eld
\end_inset

folding
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Itemize
create new sequences from single values (
\begin_inset Quotes eld
\end_inset

unfolding
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Itemize
transform existing sequences into new sequences.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Definition by induction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala code example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(\left[\right])=b~;~~f(s\pplus[x])=g(f(s),x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs) = xs.foldLeft(b)(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(\left[\right])=b~;~~f([x]\pplus s)=g(x,f(s))$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(xs) = xs.foldRight(b)(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x_{0}=b~;~~x_{k+1}=g(x_{k})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs = Stream.iterate(b)(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $y_{0}=b~;~~y_{k+1}=g(y_{k},x_{k})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ys = xs.scanLeft(b)(g)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementing mathematical induction.
\begin_inset CommandInset label
LatexCommand label
name "tab:Implementing-mathematical-induction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Implementing-mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows Scala code implementing those tasks.
 Iterative calculations are implemented by translating mathematical induction
 directly into code.
 In the functional programming paradigm, the programmer does not need to
 write loops or use array indices.
 Instead, the programmer reasons about sequences as mathematical values:
 
\begin_inset Quotes eld
\end_inset

Starting from this value, we get that sequence, then transform it into that
 other sequence,
\begin_inset Quotes erd
\end_inset

 etc.
 This is a powerful way of working with sequences, dictionaries, and sets.
 Many kinds of programming errors (such as using an incorrect array index)
 are avoided from the outset, and the code is shorter and easier to read
 than code written via loops.
\end_layout

\begin_layout Paragraph*
What problems cannot be solved with these tools?
\end_layout

\begin_layout Standard
There is no automatic recipe for converting an arbitrary function into a
 tail-recursive one.
 The accumulator trick does not always work! In some cases, it is impossible
 to implement tail recursion in a given recursive computation.
 An example of such a computation is the 
\begin_inset Quotes eld
\end_inset

merge-sort
\begin_inset Quotes erd
\end_inset

 algorithm where the function body must contain two recursive calls within
 a single expression.
 (It is impossible to rewrite 
\emph on
two
\emph default
 recursive calls as 
\emph on
one
\emph default
 tail call.) 
\end_layout

\begin_layout Standard
What if our recursive code cannot be transformed into tail-recursive code
 via the accumulator trick, but the recursion depth is so large that stack
 overflows occur? There exist special techniques (e.g., 
\begin_inset Quotes eld
\end_inset

continuations
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
continuation-passing
\end_layout

\end_inset

 and 
\begin_inset Quotes eld
\end_inset

trampolines
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
trampolines
\end_layout

\end_inset

) that convert non-tail-recursive code into code that runs without stack
 overflows.
 Those techniques are beyond the scope of this chapter.
\end_layout

\begin_layout Subsection
Examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute the smallest 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $f(f(f(...f(1)...)\geq1000$
\end_inset

, where the function 
\begin_inset Formula $f$
\end_inset

 is applied 
\begin_inset Formula $n$
\end_inset

 times.
  Test with 
\begin_inset Formula $f(x)=2x+1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Define a stream of values 
\begin_inset Formula $\left[1,f(1),f(f(1)),...\right]$
\end_inset

 and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 to stop the stream when the values reach 
\begin_inset Formula $1000$
\end_inset

.
 The number 
\begin_inset Formula $n$
\end_inset

 is then found as the length of the resulting sequence: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(1)(x => 2 * x + 1).takeWhile(x => x < 1000).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 3, 7, 15, 31, 63, 127, 255, 511)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Stream.iterate(1)(x => 2 * x + 1).takeWhile(x => x < 1000).length
\end_layout

\begin_layout Plain Layout

res1: Int = 9
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For a given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream[Int]
\end_layout

\end_inset

, compute the stream of the largest values seen so far.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Compute the stream of 
\begin_inset Formula $k$
\end_inset

 largest values seen so far (
\begin_inset Formula $k$
\end_inset

 is a given integer parameter).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We cannot use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 or sort the entire stream, since the length of the stream is not known
 in advance.
 So, we need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

, which will build the output stream one element at a time.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Maintain the largest value seen so far in the accumulator of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxSoFar(xs: Stream[Int]): Stream[Int] =
\end_layout

\begin_layout Plain Layout

  xs.scanLeft(xs.head) { (max, x) => math.max(max, x) }.drop(1)
\end_layout

\end_inset

We use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

drop(1)
\end_layout

\end_inset

 to remove the initial value (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.head
\end_layout

\end_inset

) because it is not useful for our result but is always produced by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To test this function, let us define a stream whose values go up and down:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val s = Stream.iterate(0)(x => 1 - 2 * x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s.take(10).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(0, 1, -1, 3, -5, 11, -21, 43, -85, 171)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxSoFar(s).take(10).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(0, 1, 1, 3, 3, 11, 11, 43, 43, 171)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We again use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

, where now the accumulator needs to keep the largest 
\begin_inset Formula $k$
\end_inset

 values seen so far.
 There are two ways of maintaining this accumulator: First, to have a sequence
 of 
\begin_inset Formula $k$
\end_inset

 values that we sort and truncate each time.
 Second, to use a data structure such as a priority queue that automatically
 keeps values sorted and its length bounded.
 For the purposes of this example, let us avoid using special data structures:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxKSoFar(xs: Stream[Int], k: Int): Stream[Seq[Int]] = {
\end_layout

\begin_layout Plain Layout

  // The initial value of the accumulator is an empty Seq() of type Seq[Int].
\end_layout

\begin_layout Plain Layout

  xs.scanLeft(Seq[Int]()) { (seq, x) =>
\end_layout

\begin_layout Plain Layout

  // Sort in descending order, and take the first k values.
\end_layout

\begin_layout Plain Layout

    (seq :+ x).sorted.reverse.take(k)
\end_layout

\begin_layout Plain Layout

  }.drop(1) // Skip the undesired first value.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxKSoFar(s, 3).take(10).toList
\end_layout

\begin_layout Plain Layout

res2: List[Seq[Int]] = List(List(0), List(1, 0), List(1, 0, -1), List(3,
 1, 0), List(3, 1, 0), List(11, 3, 1), List(11, 3, 1), List(43, 11, 3),
 List(43, 11, 3), List(171, 43, 11)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the last element of a non-empty sequence.
 (Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.)
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
This function is available in the Scala library as the standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

last
\end_layout

\end_inset

 on sequences.
 Here we need to re-implement it using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

.
 Begin by writing an inductive definition:
\end_layout

\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 (Base case.) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

last(Seq(x)) == x
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\bullet$
\end_inset

 (Inductive step.) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

last(x +: xs) == last(xs)
\end_layout

\end_inset

 assuming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 is non-empty.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 method implements an inductive aggregation similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, except that for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 the base case  always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 for a 
\begin_inset Formula $1$
\end_inset

-element sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x)
\end_layout

\end_inset

.
 This is exactly what we need here, so the inductive definition is directly
 translated into code, with the updater function 
\begin_inset Formula $g(x,y)=y$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def last[A](xs: Seq[A]): A = xs.reduce { (x, y) => y }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Count the occurrences of each distinct word in a string:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countWords(s: String): Map[String, Int] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countWords(
\begin_inset Quotes eld
\end_inset

a quick a quick a brown a fox
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: Map[String, Int] = Map(a -> 4, quick -> 2, brown -> 1, fox -> 1)
\end_layout

\end_inset


\series bold
(b)
\series default
 Count the occurrences of each distinct element in a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We split the string into an array of words via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.split(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

)
\end_layout

\end_inset

 and apply a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to that array, since the computation is a kind of aggregation over the
 array of words.
 The accumulator of the aggregation will be a dictionary of word counts
 for all the words seen so far:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countWords(s: String): Map[String, Int] = {
\end_layout

\begin_layout Plain Layout

  val init: Map[String, Int] = Map()
\end_layout

\begin_layout Plain Layout

  s.split(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

).foldLeft(init) { (dict, word) =>
\end_layout

\begin_layout Plain Layout

    val newCount = dict.getOrElse(word, 0) + 1
\end_layout

\begin_layout Plain Layout

    dict.updated(word, newCount)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

An alternative, shorter implementation of the same function is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countWords(s: String): Map[String, Int] =
\end_layout

\begin_layout Plain Layout

  s.split(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

).groupBy(w => w).map { case (w, xs) => (w, xs.length) }
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

groupBy
\end_layout

\end_inset

 creates a dictionary in one function call rather than one entry at a time.
 But the resulting dictionary contains word lists instead of word counts,
 so we use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to compute the length of each word list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> "a a b b b c".split(" ").groupBy(w => w)
\end_layout

\begin_layout Plain Layout

res0: Map[String,Array[String]] = Map(b -> Array(b, b, b), a -> Array(a,
 a), c -> Array(c))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> res0.map { case (w, xs) => (w, xs.length) }
\end_layout

\begin_layout Plain Layout

res1: Map[String,Int] = Map(b -> 3, a -> 2, c -> 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The main code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

countWords
\end_layout

\end_inset

 does not depend on the fact that words are of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 It will work in the same way for any other type of keys for the dictionary.
 So, we keep the same code (except for renaming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

word
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

) and replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 by a type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countValues[A](xs: Seq[A]): Map[A, Int] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Map[A, Int]()) { (dict, x) =>
\end_layout

\begin_layout Plain Layout

    val newCount = dict.getOrElse(x, 0) + 1
\end_layout

\begin_layout Plain Layout

    dict.updated(x, newCount)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countValues(Seq(100, 100, 200, 100, 200, 200, 100))
\end_layout

\begin_layout Plain Layout

res0: Map[Int,Int] = Map(100 -> 4, 200 -> 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-binary-search-seq-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Implement the binary search
\begin_inset Index idx
status open

\begin_layout Plain Layout
binary search
\end_layout

\end_inset

 algorithm for a sorted sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Int]
\end_layout

\end_inset

 as a function returning the index of the requested value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

 (assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 always contains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def binSearch(xs: Seq[Int], goal: Int): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(Seq(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res0: Int = 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

binSearch
\end_layout

\end_inset

 using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 without explicit recursion.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The binary search algorithm splits the array into two halves and may continue
 the search recursively in one of the halves.
 We need to write the solution as a tail-recursive function with an additional
 accumulator argument.
 So, we expect that the code should look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def binSearch(xs: Seq[Int], goal: Int, acc: _ = ???): Int = {
\end_layout

\begin_layout Plain Layout

  if (???) acc  // This condition must decide whether we are finished.
\end_layout

\begin_layout Plain Layout

  else {
\end_layout

\begin_layout Plain Layout

    // Determine which half of the sequence contains `goal`.
\end_layout

\begin_layout Plain Layout

    // Then update the accumulator accordingly.
\end_layout

\begin_layout Plain Layout

    val newAcc = ???
\end_layout

\begin_layout Plain Layout

    binSearch(xs, goal, newAcc) // Tail-recursive call.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We will first figure out the type and the initial value of the accumulator,
 then implement the updater.
\end_layout

\begin_layout Standard
The information required for the recursive call must show the segment of
 the sequence where the target number is present.
 That segment is defined by two indices 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula $j$
\end_inset

 representing the left and the right bounds of the sub-sequence, such that
 the target element is 
\begin_inset Formula $x_{n}$
\end_inset

 with 
\begin_inset Formula $x_{i}\leq x_{n}\leq x_{j-1}$
\end_inset

.
 It follows that the accumulator should be a pair of two integers 
\begin_inset Formula $\left(i,j\right)$
\end_inset

.
 The initial value of the accumulator is the pair 
\begin_inset Formula $\left(0,N\right)$
\end_inset

, where 
\begin_inset Formula $N$
\end_inset

 is the length of the entire sequence.
 The search is finished when 
\begin_inset Formula $i+1=j$
\end_inset

.
 For convenience, we introduce 
\emph on
two
\emph default
 accumulator values (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

right
\end_layout

\end_inset

) for 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def binSearch(xs: Seq[Int], goal: Int)(left: Int = 0, right: Int
 = xs.length): Int = {
\end_layout

\begin_layout Plain Layout

  // Check whether `goal` is at one of the boundaries.
\end_layout

\begin_layout Plain Layout

  if (right - left <= 1 || xs(left) == goal) left
\end_layout

\begin_layout Plain Layout

  else {
\end_layout

\begin_layout Plain Layout

    val middle = (left + right) / 2
\end_layout

\begin_layout Plain Layout

    // Determine which half of the array contains `target`.
\end_layout

\begin_layout Plain Layout

    // Update the accumulator accordingly.
\end_layout

\begin_layout Plain Layout

    val (newLeft, newRight) =
\end_layout

\begin_layout Plain Layout

      if (goal < xs(middle)) (left, middle)
\end_layout

\begin_layout Plain Layout

      else (middle, right)
\end_layout

\begin_layout Plain Layout

    binSearch(xs, goal)(newLeft, newRight) // Tail-recursive call.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(0 to 10, 3)() // Default accumulator values.
\end_layout

\begin_layout Plain Layout

res0: Int = 3
\end_layout

\end_inset

Here we used a feature of Scala that allows us to set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.length
\end_layout

\end_inset

 as a default value for the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

right
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

binSearch
\end_layout

\end_inset

.
 This works because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

right
\end_layout

\end_inset

 is in a different 
\series bold
argument list
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
argument list
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 Default values in an argument list may depend on arguments in a 
\emph on
previous
\emph default
 argument list.
 However, this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def binSearch(xs: Seq[Int], goal: Int, left: Int = 0, right: Int = xs.length)
\end_layout

\end_inset

will generate an error.
 Arguments in the same argument list cannot depend on each other.
 (The error will say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

not found: value xs
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We can visualize the binary search as a procedure that generates a stream
 of progressively tighter bounds for the location of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

.
 The initial bounds are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(0, xs.length)
\end_layout

\end_inset

, and the final bounds are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k, k + 1)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

.
 We can generate the sequence of bounds using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 and stop the sequence when the bounds become sufficiently tight.
 To detect that, we use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def binSearch(xs: Seq[Int], goal: Int): Int = {
\end_layout

\begin_layout Plain Layout

  type Acc = (Int, Int)
\end_layout

\begin_layout Plain Layout

  val init: Acc = (0, xs.length)
\end_layout

\begin_layout Plain Layout

  val updater: Acc => Acc = { case (left, right) =>
\end_layout

\begin_layout Plain Layout

    if (right - left <= 1 || xs(left) == goal) (left, left + 1)
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      val middle = (left + right) / 2
\end_layout

\begin_layout Plain Layout

      // Determine which half of the array contains `target`.
\end_layout

\begin_layout Plain Layout

      // Update the accumulator accordingly.
\end_layout

\begin_layout Plain Layout

      if (goal < xs(middle)) (left, middle)
\end_layout

\begin_layout Plain Layout

      else (middle, right)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Stream.iterate(init)(updater)
\end_layout

\begin_layout Plain Layout

    .find { case (x, y) => y - x <= 1 } // Find an element with tight bounds.
\end_layout

\begin_layout Plain Layout

    .get._1                             // Take the `left` bound from that.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In this code, recursion is delegated to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 and is cleanly separated from the 
\begin_inset Quotes eld
\end_inset

business logic
\begin_inset Quotes erd
\end_inset

 (i.e., from specific computations needed in the base case, the inductive
 step, and the post-processing).
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2sumdigitsExample-seq-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2sumdigitsExample-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given positive 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

, compute the sequence 
\begin_inset Formula $\left[s_{0},s_{1},s_{2},...\right]$
\end_inset

 defined by 
\begin_inset Formula $s_{0}=SD(n)$
\end_inset

 and 
\begin_inset Formula $s_{k}=SD(s_{k-1})$
\end_inset

 for 
\begin_inset Formula $k>0$
\end_inset

, where 
\begin_inset Formula $SD(x)$
\end_inset

 is the sum of the decimal digits of the integer 
\begin_inset Formula $x$
\end_inset

, e.g., 
\begin_inset Formula $SD(123)=6$
\end_inset

.
 Stop the sequence 
\begin_inset Formula $s_{i}$
\end_inset

 when the numbers begin repeating.
 For example, 
\begin_inset Formula $SD(99)=18$
\end_inset

, 
\begin_inset Formula $SD(18)=9$
\end_inset

, 
\begin_inset Formula $SD(9)=9$
\end_inset

.
 So, for 
\begin_inset Formula $n=99$
\end_inset

, the sequence 
\begin_inset Formula $s_{i}$
\end_inset

 must be computed as 
\begin_inset Formula $\left[99,18,9\right]$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sdSeq
\end_layout

\end_inset

 having the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sdSeq(n: Int): Seq[Int]
\end_layout

\end_inset

First, we need to implement 
\begin_inset Formula $SD(x)$
\end_inset

.
 The sum of digits is obtained similarly to Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ch2Converting-a-single"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def SD(n: Int): Int = Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).sum
\end_layout

\end_inset

Let us compute the sequence 
\begin_inset Formula $\left[s_{0},s_{1},s_{2},...\right]$
\end_inset

 by repeatedly applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SD
\end_layout

\end_inset

 to some number, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

99
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(99)(SD).take(10).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(99, 18, 9, 9, 9, 9, 9, 9, 9, 9)
\end_layout

\end_inset

We need to stop the stream when the values start to repeat, keeping the
 first repeated value.
 In the example above, we need to stop the stream after the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

9
\end_layout

\end_inset

 (but include that value).
 One solution is to transform the stream via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanLeft
\end_layout

\end_inset

 into a stream of 
\emph on
pairs
\emph default
 of consecutive values, so that it becomes easier to detect repetition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Stream.iterate(99)(SD).scanLeft((0,0)) { case ((prev, x), next) =>
 (x, next) }.take(8).toList
\end_layout

\begin_layout Plain Layout

res2: List[(Int, Int)] = List((0,0), (0,99), (99,18), (18,9), (9,9), (9,9),
 (9,9), (9,9))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> res2.drop(1).takeWhile { case (x, y) => x != y }
\end_layout

\begin_layout Plain Layout

res3: List[(Int, Int)] = List((0,99), (99,18), (18,9))
\end_layout

\end_inset

This looks right; it remains to remove the first parts of the tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sdSeq(n: Int): Seq[Int] = Stream.iterate(n)(SD)        // Stream[Int]
\end_layout

\begin_layout Plain Layout

  .scanLeft((0,0)) { case ((prev, x), next) => (x, next) } // Stream[(Int,
 Int)]
\end_layout

\begin_layout Plain Layout

  .drop(1).takeWhile { case (x, y) => x != y }   // Stream[(Int, Int)]
\end_layout

\begin_layout Plain Layout

  .map(_._2)                                     // Stream[Int]
\end_layout

\begin_layout Plain Layout

  .toList                                        // List[Int]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> sdSeq(99)
\end_layout

\begin_layout Plain Layout

res3: Seq[Int] = List(99, 18, 9)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-stream"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-stream"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
unfold
\family default
 function
\end_layout

\end_inset

function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold
\end_layout

\end_inset

 with the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def unfold[A](init: A)(next: A => Option[A]): Stream[A]
\end_layout

\end_inset

The function should create a stream of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 with the initial value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

.
 Next elements are computed from previous ones via the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

 until it returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 (The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 is explained in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Standard-disjunctive-types:"
plural "false"
caps "false"
noprefix "false"

\end_inset

.) An example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> unfold(0) { x => if (x > 5) None else Some(x + 2) }
\end_layout

\begin_layout Plain Layout

res0: Stream[Int] = Stream(0, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> res0.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(0, 2, 4, 6)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We can formulate the task as an inductive definition of a stream.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next(init) == None
\end_layout

\end_inset

, the stream will have just one value (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

).
 This is the base case of the induction.
 Otherwise, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next(init) == Some(x)
\end_layout

\end_inset

 yields a new value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 So, we need to continue to 
\begin_inset Quotes eld
\end_inset

unfold
\begin_inset Quotes erd
\end_inset

 the stream with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

.
 (This is the inductive step.) To create streams with given values, we use
 the Scala library method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.cons
\end_layout

\end_inset

.
 It constructs a stream from a head value and a tail stream:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def unfold[A](init: A)(next: A => Option[A]): Stream[A] = next(init) match
 {
\end_layout

\begin_layout Plain Layout

  case None      => Stream(init)    // A stream having a single value `init`.
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Stream.cons(init, unfold(x)(next)) // `init` and then
 the tail of the stream.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given stream 
\begin_inset Formula $\left[s_{0},s_{1},s_{2},...\right]$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream[T]
\end_layout

\end_inset

, compute the 
\begin_inset Quotes eld
\end_inset

half-speed
\begin_inset Quotes erd
\end_inset

 stream 
\begin_inset Formula $h=\left[s_{0},s_{0},s_{1},s_{1},s_{2},s_{2},...\right]$
\end_inset

.
 The half-speed sequence 
\begin_inset Formula $h$
\end_inset

 is defined as 
\begin_inset Formula $h_{2k}=h_{2k+1}=s_{k}$
\end_inset

 for 
\begin_inset Formula $k=0,1,2,...$
\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to replace each element 
\begin_inset Formula $s_{i}$
\end_inset

 by a sequence containing two copies of 
\begin_inset Formula $s_{i}$
\end_inset

.
 Let us try this on a sample sequence:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).map( x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

res0: Seq[Seq[Int]] = List(List(1, 1), List(2, 2), List(3, 3))
\end_layout

\end_inset

The result is almost what we need, except we need to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 the nested list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).map( x => Seq(x, x)).flatten
\end_layout

\begin_layout Plain Layout

res1: Seq[Seq[Int]] = List(1, 1, 2, 2, 3, 3)
\end_layout

\end_inset

The composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, so the final code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def halfSpeed[T](str: Stream[T]): Stream[T] = str.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> halfSpeed(Seq(1, 2, 3).toStream)
\end_layout

\begin_layout Plain Layout

res2: Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> halfSpeed(Seq(1, 2, 3).toStream).toList
\end_layout

\begin_layout Plain Layout

res3: List[Int] = List(1, 1, 2, 2, 3, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
(
\begin_inset Index idx
status open

\begin_layout Plain Layout
loop detection
\end_layout

\end_inset

The 
\series bold
loop detection
\series default
 problem.) Stop a given stream 
\begin_inset Formula $\left[s_{0},s_{1},s_{2},...\right]$
\end_inset

 at a place 
\begin_inset Formula $k$
\end_inset

 where the sequence repeats itself; that is, an element 
\begin_inset Formula $s_{k}$
\end_inset

 equals some earlier element 
\begin_inset Formula $s_{i}$
\end_inset

 with 
\begin_inset Formula $i<k$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The trick is to create a half-speed sequence 
\begin_inset Formula $h_{i}$
\end_inset

 out of 
\begin_inset Formula $s_{i}$
\end_inset

 and then find an index 
\begin_inset Formula $k>0$
\end_inset

 such that 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

.
 (The condition 
\begin_inset Formula $k>0$
\end_inset

 is needed because we will always have 
\begin_inset Formula $h_{0}=s_{0}$
\end_inset

.) If we find such an index 
\begin_inset Formula $k$
\end_inset

, it would mean that either 
\begin_inset Formula $s_{k}=s_{k/2}$
\end_inset

 or 
\begin_inset Formula $s_{k}=s_{\left(k-1\right)/2}$
\end_inset

; in either case, we will have found an element 
\begin_inset Formula $s_{k}$
\end_inset

 that equals an earlier element.
 
\end_layout

\begin_layout Standard
As an example, for an input sequence 
\begin_inset Formula $s=\left[1,3,5,7,9,3,5,7,9,...\right]$
\end_inset

 we obtain the half-speed sequence 
\begin_inset Formula $h=\left[1,1,3,3,5,5,7,7,9,9,3,3,...\right]$
\end_inset

.
 Looking for an index 
\begin_inset Formula $k>0$
\end_inset

 such that 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

, we find that 
\begin_inset Formula $s_{7}=h_{7}=7$
\end_inset

.
 The element 
\begin_inset Formula $s_{7}$
\end_inset

 indeed repeats an earlier element (although 
\begin_inset Formula $s_{7}$
\end_inset

 is not the first such repetition).
\end_layout

\begin_layout Standard
There are in principle two ways of finding an index 
\begin_inset Formula $k>0$
\end_inset

 such that 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

: First, to iterate over a list of indices 
\begin_inset Formula $k=1,2,...$
\end_inset

 and evaluate the condition 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

 as a function of 
\begin_inset Formula $k$
\end_inset

.
 Second, to build a sequence of pairs 
\begin_inset Formula $\left(h_{i},s_{i}\right)$
\end_inset

 and use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 to stop at the required index.
 In the present case, we cannot use the first way because we do not have
 a fixed set of indices to iterate over.
 Also, the condition 
\begin_inset Formula $h_{k}=s_{k}$
\end_inset

 cannot be directly evaluated as a function of 
\begin_inset Formula $k$
\end_inset

 because 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 are streams that compute elements on demand, not lists whose elements are
 computed in advance and ready for use.
 
\end_layout

\begin_layout Standard
So, the code must iterate over a stream of pairs 
\begin_inset Formula $\left(h_{i},s_{i}\right)$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def stopRepeats[T](str: Stream[T]): Stream[T] = {
\end_layout

\begin_layout Plain Layout

  val halfSpeed = str.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

  val result = halfSpeed.zip(str) // Stream[(T, T)]
\end_layout

\begin_layout Plain Layout

  .drop(1) // Enforce the condition k > 0.
\end_layout

\begin_layout Plain Layout

  .takeWhile { case (h, s) => h != s } // Stream[(T, T)]
\end_layout

\begin_layout Plain Layout

  .map(_._2) // Stream[T]
\end_layout

\begin_layout Plain Layout

  str.head +: result // Prepend the first element that was dropped.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> stopRepeats(Seq(1, 3, 5, 7, 9, 3, 5, 7, 9).toStream).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 3, 5, 7, 9, 3, 5)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Reverse each word in a string but keep the order of words:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revWords(s: String): String = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> revWords(
\begin_inset Quotes eld
\end_inset

A quick brown fox
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: String = A kciuq nworb xof
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The standard method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

split
\end_layout

\end_inset

 converts a string into an array of words:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> "pa re ci vo mu".split(" ")
\end_layout

\begin_layout Plain Layout

res0: Array[String] = Array(pa, re, ci, vo, mu)
\end_layout

\end_inset

Each word is reversed with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

; the resulting array is concatenated into a string with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mkString
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revWords(s: String): String = s.split(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

).map(_.reverse).mkString(
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Remove adjacent repeated characters from a string:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def noDups(s: String): String = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> noDups(
\begin_inset Quotes eld
\end_inset

abbcdeeeeefddgggggh
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res0: String = abcdefdgh
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
A string is automatically converted into a sequence of characters when we
 use methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

 on it.
 So, we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.zip(s.tail)
\end_layout

\end_inset

 to get a sequence of pairs 
\begin_inset Formula $\left(s_{k},s_{k+1}\right)$
\end_inset

 where 
\begin_inset Formula $c_{k}$
\end_inset

 is the 
\begin_inset Formula $k$
\end_inset

-th character of the string 
\begin_inset Formula $s$
\end_inset

.
 A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 will then remove elements 
\begin_inset Formula $s_{k}$
\end_inset

 for which 
\begin_inset Formula $s_{k+1}=s_{k}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = "abbcd"
\end_layout

\begin_layout Plain Layout

s: String = abbcd
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s.zip(s.tail).filter { case (sk, skPlus1) => sk != skPlus1 }
\end_layout

\begin_layout Plain Layout

res0: IndexedSeq[(Char, Char)] = Vector((a,b), (b,c), (c,d))
\end_layout

\end_inset

It remains to convert this sequence of pairs into the string 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abcd
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 One way of doing this is to project the sequence of pairs onto the second
 parts of the pairs:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> res0.map(_._2).mkString
\end_layout

\begin_layout Plain Layout

res1: String = bcd
\end_layout

\end_inset

We just need to add the first character, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

'a'
\end_layout

\end_inset

.
 The resulting code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def noDups(s: String): String = if (s == 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

) 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 else {
\end_layout

\begin_layout Plain Layout

  val pairs = s.zip(s.tail).filter { case (x, y) => x != y }
\end_layout

\begin_layout Plain Layout

  pairs.head._1 +: pairs.map(_._2).mkString
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+:
\end_layout

\end_inset

 prepends an element to a sequence, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x +: xs
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq(x) ++ xs
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Example-seq-10-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-10-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

, find the longest subsequence that does not contain any adjacent duplicate
 values.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def longestNoDups[A](xs: Seq[A]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> longestNoDups(Seq(1, 2, 2, 5, 4, 4, 4, 8, 2, 3, 3))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(4, 8, 2, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
This is a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
dynamic programming
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

dynamic programming
\begin_inset Quotes erd
\end_inset

 problem.
 Many such problems are solved with a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 The accumulator represents the current state of the dynamic programming
 solution, and the state is updated with each new element of the input sequence.
\end_layout

\begin_layout Standard
We first need to determine the type of the accumulator value.
 The task is to find the longest subsequence without adjacent duplicates.
 So, the accumulator should represent the longest subsequence found so far,
 as well as any required extra information about other subsequences that
 might grow as we iterate over the elements of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 What is that extra information in our case? 
\end_layout

\begin_layout Standard
Imagine creating the set of 
\emph on
all
\emph default
 subsequences that have no adjacent duplicates.
 For the input sequence 
\begin_inset Formula $\left[1,2,2,5,4,4,4,8,2,3,3\right]$
\end_inset

, this set of all subsequences will be 
\begin_inset Formula $\{\left[1,2\right],\left[2,5,4\right],\left[4,8,2,3\right]\}$
\end_inset

.
 We can build this set incrementally in the accumulator value of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 To visualize how this set would be built, consider the partial result after
 seeing the first 
\begin_inset Formula $8$
\end_inset

 elements of the input sequence, 
\begin_inset Formula $\left[1,2,2,5,4,4,4,8\right]$
\end_inset

.
 The partial set of non-repeating subsequences is 
\begin_inset Formula $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8\right]\right\} $
\end_inset

.
 When we see the next element, 
\begin_inset Formula $2$
\end_inset

, we will update that partial set to 
\begin_inset Formula $\left\{ \left[1,2\right],\left[2,5,4\right],\left[4,8,2\right]\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
It is now clear that the subsequence 
\begin_inset Formula $\left[1,2\right]$
\end_inset

 has no chance of being the longest subsequence, since 
\begin_inset Formula $\left[2,5,4\right]$
\end_inset

 is already longer.
 However, we do not yet know whether 
\begin_inset Formula $\left[2,5,4\right]$
\end_inset

 or 
\begin_inset Formula $\left[4,8,2\right]$
\end_inset

 is the winner, because the subsequence 
\begin_inset Formula $\left[4,8,2\right]$
\end_inset

 could still grow and become the longest one (and it does become 
\begin_inset Formula $\left[4,8,2,3\right]$
\end_inset

 later).
 At this point, we need to keep both of these two subsequences in the accumulato
r, but we may already discard 
\begin_inset Formula $\left[1,2\right]$
\end_inset

.
\end_layout

\begin_layout Standard
We have deduced that the accumulator needs to keep only 
\emph on
two
\emph default
 sequences: the first sequence is already terminated and will not grow,
 the second sequence ends with the current element and may yet grow.
 The initial value of the accumulator is empty.
 The first subsequence is discarded when it becomes shorter than the second.
 The code can be written now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def longestNoDups[A](xs: Seq[A]): Seq[A] = {
\end_layout

\begin_layout Plain Layout

  val init: (Seq[A], Seq[A]) = (Seq(), Seq())
\end_layout

\begin_layout Plain Layout

  val (first, last) = xs.foldLeft(init) { case ((first, current), x) =>
\end_layout

\begin_layout Plain Layout

        // If `current` is empty, `x` is not considered to be repeated.
\end_layout

\begin_layout Plain Layout

    val xWasRepeated = current != Seq() && current.last == x
\end_layout

\begin_layout Plain Layout

    val firstIsLongerThanCurrent = first.length > current.length
\end_layout

\begin_layout Plain Layout

        // Compute the new pair `(first, current)`.
\end_layout

\begin_layout Plain Layout

        // Keep `first` only if it is longer; otherwise replace it by `current`.
\end_layout

\begin_layout Plain Layout

    val newFirst = if (firstIsLongerThanCurrent) first else current
\end_layout

\begin_layout Plain Layout

        // Append `x` to `current` if `x` is not repeated.
\end_layout

\begin_layout Plain Layout

    val newCurrent = if (xWasRepeated) Seq(x) else current :+ x
\end_layout

\begin_layout Plain Layout

    (newFirst, newCurrent)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

        // Return the longer of the two subsequences; prefer `first`.
\end_layout

\begin_layout Plain Layout

  if (first.length >= last.length) first else last
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

dsq
\end_layout

\end_inset

 that computes the sum of squared digits of a given integer; for instance,
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

dsq(123) = 14
\end_layout

\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2sumdigitsExample-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

dsq
\end_layout

\end_inset

 to take as an argument a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Int
\end_layout

\end_inset

 replacing the squaring operation.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def digitsFSum(x: Int)(f: Int => Int): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsFSum(123) { x => x * x }
\end_layout

\begin_layout Plain Layout

res0: Int = 14
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> digitsFSum(123) { x => x * x * x }
\end_layout

\begin_layout Plain Layout

res1: Int = 36
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute the 
\series bold
Collatz sequence
\begin_inset Index idx
status open

\begin_layout Plain Layout
Collatz sequence
\end_layout

\end_inset


\series default
 
\begin_inset Formula $c_{i}$
\end_inset

 as a stream defined by:
\begin_inset Formula 
\[
c_{0}=n\quad;\quad\quad c_{k+1}=\begin{cases}
c_{k}/2 & \text{if }c_{k}\text{ is even,}\\
3*c_{k}+1 & \text{if }c_{k}\text{ is odd.}
\end{cases}
\]

\end_inset

Stop the stream when it reaches 
\begin_inset Formula $1$
\end_inset

 (as one would expect
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Collatz_conjecture"
literal "false"

\end_inset


\end_layout

\end_inset

 it will).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given integer 
\begin_inset Formula $n$
\end_inset

, compute the sum of cubed digits, then the sum of cubed digits of the result,
 etc.; stop the resulting sequence when it repeats itself, and so determine
 whether it ever reaches 
\begin_inset Formula $1$
\end_inset

.
 (Use Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cubes(n: Int): Stream[Int] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubes(123).take(10).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(123, 36, 243, 99, 1458, 702, 351, 153, 153, 153)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubes(2).take(10).toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(2, 8, 512, 134, 92, 737, 713, 371, 371, 371)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubes(4).take(10).toList
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(4, 64, 280, 520, 133, 55, 250, 133, 55, 250)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def cubesReach1(n: Int): Boolean = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubesReach1(10)
\end_layout

\begin_layout Plain Layout

res3: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> cubesReach1(4)
\end_layout

\begin_layout Plain Layout

res4: Boolean = false
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[Int]
\end_layout

\end_inset

, compute the set of all sets of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set(x, y, z)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> prod3(Set(1, 2), Set(3), Set(4, 5))
\end_layout

\begin_layout Plain Layout

res0: Set[Set[Int]] = Set(Set(1,3,4), Set(1,3,5), Set(2,3,4), Set(2,3,5))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Same task as in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 but using a set of sets.
 Instead of just three sets 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

, we are given a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[Set[Int]]
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prodSet(si: Set[Set[Int]]): Set[Set[Int]] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> prodSet(Set(Set(1, 2), Set(3), Set(4, 5), Set(6)))
\end_layout

\begin_layout Plain Layout

res0: Set[Set[Int]] = Set(Set(1,3,4,6),Set(1,3,5,6),Set(2,3,4,6),Set(2,3,5,6))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
In a sorted integer array where no values are repeated, find all pairs of
 values whose sum equals a given number 
\begin_inset Formula $n$
\end_inset

.
 Use tail recursion.
 A type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pairs(goal: Int, xs: Array[Int]): Set[(Int, Int)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> pairs(10, Array(1, 2, 4, 5, 6, 8))
\end_layout

\begin_layout Plain Layout

res0: Set[(Int, Int)] = Set((2,8), (4,6), (5,5))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Reverse a sentence's word order, but keep the words unchanged:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revSentence(s: String): String = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> revSentence(
\begin_inset Quotes eld
\end_inset

A quick brown fox
\begin_inset Quotes erd
\end_inset

) // Words are separated by one space.
\end_layout

\begin_layout Plain Layout

res0: String = 
\begin_inset Quotes eld
\end_inset

fox brown quick A
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2revdigits-Exercise-seq-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2revdigits-Exercise-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Reverse an integer's digits (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2sumdigitsExample-seq-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as shown:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def revDigits(n: Int): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> revDigits(12345)
\end_layout

\begin_layout Plain Layout

res0: Int = 54321
\end_layout

\end_inset


\series bold
(b)
\series default
 A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
palindrome integer
\end_layout

\end_inset


\series bold
palindrome integer
\series default
 is an integer number 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 such that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

revDigits(n) == n
\end_layout

\end_inset

.
 Write a predicate function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Boolean
\end_layout

\end_inset

 that checks whether a given positive integer is a palindrome.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findPalindrome: Long => Long
\end_layout

\end_inset

 performing the following computation: First define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(n) = revDigits(n) + n
\end_layout

\end_inset

 for a given integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

, where the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

revDigits
\end_layout

\end_inset

 was defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2revdigits-Exercise-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(n)
\end_layout

\end_inset

 is a palindrome integer, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findPalindrome
\end_layout

\end_inset

 returns that integer.
 Otherwise, it keeps applying the same transformation and computes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(n)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(f(n))
\end_layout

\end_inset

, ..., until a palindrome integer is eventually found (this is mathematically
 guaranteed).
 A sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> findPalindrome(10101)
\end_layout

\begin_layout Plain Layout

res0: Long = 10101
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> findPalindrome(123)
\end_layout

\begin_layout Plain Layout

res0: Long = 444
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> findPalindrome(83951)
\end_layout

\begin_layout Plain Layout

res1: Long = 869363968
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-8-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-8-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Transform a given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Int]
\end_layout

\end_inset

 into a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(Int, Int)]
\end_layout

\end_inset

 of pairs that skip one neighbor.
 Implement this transformation as a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

skip1
\end_layout

\end_inset

 with a type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def skip1[A](xs: Seq[A]): Seq[(A, A)] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> skip1(List(1, 2, 3, 4, 5))
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List((1,3), (2,4), (3,5))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-8-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-8-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 For a given integer interval 
\begin_inset Formula $\left[n_{1},n_{2}\right]$
\end_inset

, find the largest integer 
\begin_inset Formula $k\in\left[n_{1},n_{2}\right]$
\end_inset

 such that the decimal representation of 
\begin_inset Formula $k$
\end_inset

 does 
\emph on
not
\emph default
 contain any of the digits 
\begin_inset Formula $3$
\end_inset

, 
\begin_inset Formula $5$
\end_inset

, or 
\begin_inset Formula $7$
\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 For a given integer interval 
\begin_inset Formula $\left[n_{1},n_{2}\right]$
\end_inset

, find the integer 
\begin_inset Formula $k\in\left[n_{1},n_{2}\right]$
\end_inset

 with the largest sum of decimal digits.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 A positive integer 
\begin_inset Formula $n$
\end_inset

 is called a 
\series bold
perfect number
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
perfect numbers
\end_layout

\end_inset

 if it is equal to the sum of its divisors (integers 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $1\leq k<n$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 divides 
\begin_inset Formula $n$
\end_inset

).
 For example, 
\begin_inset Formula $6$
\end_inset

 is a perfect number because its divisors are 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $3$
\end_inset

, and 
\begin_inset Formula $1+2+3=6$
\end_inset

, while 
\begin_inset Formula $8$
\end_inset

 is not a perfect number because its divisors are 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $2$
\end_inset

, and 
\begin_inset Formula $4$
\end_inset

, and 
\begin_inset Formula $1+2+4=7\neq8$
\end_inset

.
 Write a function that determines whether a given number 
\begin_inset Formula $n$
\end_inset

 is perfect.
 Determine all perfect numbers up to one million.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Transform a sequence by removing adjacent repeated elements when they are
 repeated more than 
\begin_inset Formula $k$
\end_inset

 times.
 Repetitions up to 
\begin_inset Formula $k$
\end_inset

 times should remain unchanged.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeDups[A](s: Seq[A], k: Int): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> removeDups(Seq(1, 1, 1, 1, 5, 2, 2, 5, 5, 5, 5, 5, 1), 3)
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(1, 1, 1, 5, 2, 2, 5, 5, 5, 1)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-9-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-9-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
unfold
\family default
 function
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

unfold2
\end_layout

\end_inset

 with the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def unfold2[A, B](init: A)(next: A => Option[(A, B)]): Stream[B]
\end_layout

\end_inset

The function should create a stream of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 by repeatedly applying the given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

 until it returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 At each iteration, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

 should be applied to the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 returned by the previous call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

.
 An example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> unfold2(0) { x => if (x > 5) None else Some((x + 2, s"had $x")) }
\end_layout

\begin_layout Plain Layout

res0: Stream[String] = Stream(had 0, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> res0.toList
\end_layout

\begin_layout Plain Layout

res1: List[String] = List(had 0, had 2, had 4) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-11"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-11"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Remove repeated elements (whether adjacent or not) from a sequence of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

.
 (This reproduces the standard library's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

distinct
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 For a sequence of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

, remove all elements that are repeated (whether adjacent or not) more than
 
\begin_inset Formula $k$
\end_inset

 times:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def removeK[A](k: Int, xs: Seq[A]): Seq[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> removeK(2, Seq(
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

res0: Seq[String] = List(a, b, a, b, c)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-10"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: Seq[Double]
\end_layout

\end_inset

, find a subsequence that has the largest sum of values.
 The sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 is not sorted, and its values may be positive or negative.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def maxsub(xs: Seq[Double]): Seq[Double] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> maxsub(Seq(1.0, -1.5, 2.0, 3.0, -0.5, 2.0, 1.0, -10.0, 2.0))
\end_layout

\begin_layout Plain Layout

res0: Seq[Double] = List(2.0, 3.0, -0.5, 2.0, 1.0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hint: use 
\begin_inset Index idx
status open

\begin_layout Plain Layout
dynamic programming
\end_layout

\end_inset

dynamic programming techniques and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch2Exercise-seq-12"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Exercise-seq-12"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using tail recursion, find all common integers between two 
\emph on
sorted
\emph default
 sequences:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def commonInt(xs: Seq[Int], ys: Seq[Int]): Seq[Int] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> commonInt(Seq(1, 3, 5, 7), Seq(2, 3, 4, 6, 7, 8))
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List(3, 7)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion and further developments
\end_layout

\begin_layout Subsection
Total and partial functions
\end_layout

\begin_layout Standard
Functions can be total or partial.
 A 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
total function
\end_layout

\end_inset

total
\series default
 function will always compute a result value, while a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset

partial
\series default
 function may fail to compute its result for certain values of its arguments.
\end_layout

\begin_layout Standard
A simple example of a partial function in Scala is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 method: it only works for non-empty sequences.
 Trying to evaluate it on an empty sequence generates an error (an 
\begin_inset Quotes eld
\end_inset

exception
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

):
\begin_inset listings
lstparams "mathescape=false"
inline false
status open

\begin_layout Plain Layout

scala> Seq(1).tail
\end_layout

\begin_layout Plain Layout

res0: Seq[Int] = List()
\end_layout

\begin_layout Plain Layout

scala> res0.max
\end_layout

\begin_layout Plain Layout

java.lang.UnsupportedOperationException: empty.max
\end_layout

\begin_layout Plain Layout

  at scala.collection.TraversableOnce$class.max(TraversableOnce.scala:229)
\end_layout

\begin_layout Plain Layout

  at scala.collection.AbstractTraversable.max(Traversable.scala:104)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided 
\end_layout

\end_inset

This kind of error may crash a program at run time.
 Unlike the type errors
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

 we saw before, which occur at compilation time (i.e., before the program
 can start), 
\series bold
run-time errors
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
run-time error
\end_layout

\end_inset

 occur while the program is running and only when an invalid situation actually
 happens — say, when some partial function gets an incorrect input.
 The incorrect input may occur at any time after the program started running,
 which may crash the program in the middle of a long computation.
\end_layout

\begin_layout Standard
So, it seems clear that we should avoid writing code that generates such
 errors.
 For instance, we will prefer to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 only to sequences that are known to be non-empty.
\end_layout

\begin_layout Standard
Sometimes, a function that uses pattern matching turns out to be a partial
 function because its pattern matching code fails on certain input data.
 
\end_layout

\begin_layout Standard
If none of the cases matches in a pattern matching expression, the code
 will throw an exception (a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MatchError
\end_layout

\end_inset

).
 In functional programming, we usually want to avoid that situation because
 reasoning about program correctness becomes hard.
 In most cases, programs can be rewritten to avoid the possibility of match
 errors.
 An example of an unsafe pattern matching expression is:
\begin_inset listings
lstparams "mathescape=false"
inline false
status open

\begin_layout Plain Layout

def h(p: (Int, Int)): Int = p match { case (x, 0) => x }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> h( (1, 0) )
\end_layout

\begin_layout Plain Layout

res0: Int = 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> h( (1, 2) )
\end_layout

\begin_layout Plain Layout

 scala.MatchError: (1,2) (of class scala.Tuple2$mcII$sp)
\end_layout

\begin_layout Plain Layout

  at .h(<console>:12)
\end_layout

\begin_layout Plain Layout

  ...
 32 elided 
\end_layout

\end_inset

Here, the pattern contains a pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and a constant 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 This pattern only matches tuples whose second part is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

.
 If the second argument is nonzero, a match error occurs and the program
 crashes.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 is a partial function.
\end_layout

\begin_layout Standard
Pattern matching errors never happen if we match a tuple of correct size
 with a pattern such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y, z)
\end_layout

\end_inset

, because each pattern variable will always match a value.
 So, pattern matching with a pattern such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y, z)
\end_layout

\end_inset

 is 
\series bold
infallible
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching!infallible
\end_layout

\end_inset

 (never fails at run time) when applied to a tuple with 
\begin_inset Formula $3$
\end_inset

 elements.
\end_layout

\begin_layout Standard
Another way in which pattern matching can be made infallible is by including
 a pattern that matches everything:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

p match {
\end_layout

\begin_layout Plain Layout

  case (x, 0)   => ...
   // This only matches certain tuples.
\end_layout

\begin_layout Plain Layout

  case _        => ...
   // This matches everything else.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If the first pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, 0)
\end_layout

\end_inset

 fails to match the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, the second pattern will be tried (and will always succeed).
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 patterns in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression are tried in the order they are written.
 So, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression may be made infallible by adding a 
\begin_inset Quotes eld
\end_inset

match-all
\begin_inset Quotes erd
\end_inset

 underscore pattern.
\end_layout

\begin_layout Subsection
Scope and shadowing of pattern matching variables
\begin_inset CommandInset label
LatexCommand label
name "subsec:Scope-and-shadowing-variables"

\end_inset


\end_layout

\begin_layout Standard
Pattern matching introduces 
\series bold
locally scoped
\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset


\series default
 variables — that is, variables accessible only within the right-hand side
 of the pattern match expression.
 As an example, consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: (Int, Int)): Int = x match { case (x, y) => x + y }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f( (2, 4) )
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset

The argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is the variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of a tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int)
\end_layout

\end_inset

, but there is also a pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in the case expression.
 The pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 matches the first part of the tuple and has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Because variables are locally scoped, the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is only defined within the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x + y
\end_layout

\end_inset

.
 The argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:(Int,Int)
\end_layout

\end_inset

 is a completely different variable that has a different type.
\end_layout

\begin_layout Standard
The code works correctly but is confusing to read because of the name clash
 between the two quite different variables, both named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 Another negative consequence of the name clash is that the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:(Int,Int)
\end_layout

\end_inset

 
\emph on
is invisible
\emph default
 within the case expression: if we write 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 in that expression, we will get the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Int
\end_layout

\end_inset

.
 One says that the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:(Int,Int)
\end_layout

\end_inset

 has been 
\begin_inset Index idx
status open

\begin_layout Plain Layout
shadowed name
\end_layout

\end_inset


\series bold
shadowed
\series default
 by the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 (which is a 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
bound variable
\end_layout

\end_inset

bound variable
\begin_inset Quotes erd
\end_inset

 inside the case expression).
\end_layout

\begin_layout Standard
This problem is easy to avoid: we can give the pattern variable another
 name.
 Since the pattern variable is locally scoped, it can be renamed within
 its scope without affecting any other code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: (Int, Int)): Int = x match { case (a, b) => a + b }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f( (2,4) )
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lazy values and sequences.
 Iterators and streams
\begin_inset CommandInset label
LatexCommand label
name "subsec:Lazy-values-iterators-and-streams"

\end_inset


\end_layout

\begin_layout Standard
We have used streams to create sequences whose length is not known in advance.
 An example is a stream containing a sequence of increasing positive integers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Stream.iterate(1)(_ + 1)
\end_layout

\begin_layout Plain Layout

p: Stream[Int] = Stream(1, ?)
\end_layout

\end_inset

At this point, we have not defined a stopping condition for this stream.
 In some sense, streams may be seen as 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

 sequences, although in practice a stream is always finite because programs
 cannot run infinitely long.
 Also, computers cannot store infinitely many values in memory.
 
\end_layout

\begin_layout Standard
More precisely, streams are 
\begin_inset Quotes eld
\end_inset

partially computed
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

.
 The main difference between arrays and streams is that a stream's elements
 are computed on demand and not all initially available, while an array's
 elements are all computed in advance and are immediately available.
\end_layout

\begin_layout Standard
Generally, there are three possible ways a value could be available:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Availability
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Explanation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Example Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset

eager
\begin_inset Index idx
status open

\begin_layout Plain Layout
eager value
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
computed immediately
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val z = f(123)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset

lazy
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
computed upon first use and stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lazy val z = f(123)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
computed each time it is needed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def z = f(123)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
lazy value
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
lazy value
\end_layout

\end_inset

 (declared as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lazy val
\end_layout

\end_inset

 in Scala) is computed only when it is needed in some other expression.
 Once computed, a lazy value stays in memory and will not be re-computed.
\end_layout

\begin_layout Standard
An 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset

 value
\begin_inset Index idx
status open

\begin_layout Plain Layout
on-call value
\end_layout

\end_inset

 is re-computed every time it is used.
 In Scala, on-call values are denoted via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 declarations as well as via call-by-name function arguments.
\end_layout

\begin_layout Standard
Most collection types in Scala (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map
\end_layout

\end_inset

) are 
\series bold
eager
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
eager collection
\end_layout

\end_inset

.
 All elements of an eager collection are already evaluated.
\end_layout

\begin_layout Standard
A stream is a 
\series bold
lazy
\begin_inset Index idx
status open

\begin_layout Plain Layout
lazy collection
\end_layout

\end_inset


\series default
 
\series bold
collection
\series default
.
 Elements of a stream are computed when first needed.
 After that, they remain in memory and will not be computed again:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val str = Stream.iterate(1)(_ + 1)
\end_layout

\begin_layout Plain Layout

str: Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.take(10).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str
\end_layout

\begin_layout Plain Layout

res1: Stream[Int] = Stream(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In many cases, it is not necessary to keep previous values of a sequence
 in memory.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1L to 1000000000L).sum    // Compute the sum from 1 to 1 billion.
\end_layout

\begin_layout Plain Layout

res0: Long = 500000000500000000
\end_layout

\end_inset

We do not actually need to store a billion numbers in memory if we only
 want to compute their sum.
 Indeed, the computation just shown does 
\emph on
not
\emph default
 store all the numbers in memory.
 The computation will fail if we use a list or a stream: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1L to 1000000000L).toStream.sum
\end_layout

\begin_layout Plain Layout

java.lang.OutOfMemoryError: GC overhead limit exceeded
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1L to 1000000000L).sum
\end_layout

\end_inset

 works because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n)
\end_layout

\end_inset

 produces a sequence whose elements are computed whenever needed but do
 not remain in memory.
 This can be seen as a sequence with the 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset

 availability of elements.
 Sequences of this sort are called 
\series bold
iterators
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
iterator
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> 1 to 5
\end_layout

\begin_layout Plain Layout

res0: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 1 until 5
\end_layout

\begin_layout Plain Layout

res1: scala.collection.immutable.Range = Range(1, 2, 3, 4)
\end_layout

\end_inset

The types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Range
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Range.Inclusive
\end_layout

\end_inset

 are defined in the Scala standard library and are iterators.
 They behave as collections and support the usual methods (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, etc.), but they do not store previously computed values in memory.
\end_layout

\begin_layout Paragraph
The 
\family typewriter
view
\family default
 method
\end_layout

\begin_layout Standard
Eager collections such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 can be converted to iterators by using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

view
\end_layout

\end_inset

 method.
 This is necessary when intermediate collections consume too much memory
 when fully evaluated.
 For example, consider the computation of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:tuples-Example7"
plural "false"
caps "false"
noprefix "false"

\end_inset

 where we used 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 to replace each element of an initial sequence by three new numbers before
 computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 of the resulting collection.
 If instead of three new numbers we wanted to compute 
\emph on
three
\emph default
 
\emph on
million
\emph default
 new numbers each time, the intermediate collection created by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 would require too much memory, and the computation would crash:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).flatMap(x => 1 to 3000000).max
\end_layout

\begin_layout Plain Layout

java.lang.OutOfMemoryError: GC overhead limit exceeded
\end_layout

\end_inset

Even though the range 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to 10)
\end_layout

\end_inset

 is an iterator, a subsequent 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 operation creates an intermediate collection that is too large for our
 computer's memory.
 We can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

view
\end_layout

\end_inset

 to avoid this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).view.flatMap(x => 1 to 3000000).max
\end_layout

\begin_layout Plain Layout

res0: Int = 3000000
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The choice between using streams and using iterators is dictated by memory
 constraints.
 Except for that, streams and iterators behave similarly to other sequences.
 We may write programs in the map/reduce style, applying standard methods
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, etc., to streams and iterators.
 Mathematical reasoning about transforming a sequence is the same, whether
 the sequence is eager, lazy, or on-call.
\end_layout

\begin_layout Paragraph
The 
\family typewriter
Iterator
\family default
 class
\end_layout

\begin_layout Standard
The Scala library class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 has methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iterate
\end_layout

\end_inset

 and others, similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

.
 However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 does not behave as a 
\emph on
value
\emph default
 in the mathematical sense
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala's 
\family typewriter
Iterator
\family default
 class
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val iter = (1 until 10).toIterator
\end_layout

\begin_layout Plain Layout

iter: Iterator[Int] = non-empty iterator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> iter.toList // Look at the elements of `iter`.
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> iter.toList // Look at those elements again...??
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> iter
\end_layout

\begin_layout Plain Layout

res2: Iterator[Int] = empty iterator
\end_layout

\end_inset

Evaluating the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter.toList
\end_layout

\end_inset

 two times produces a different result the second time.
 As we see from the Scala output, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter
\end_layout

\end_inset

 has become 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 after the first use.
\end_layout

\begin_layout Standard
This situation is impossible in mathematics: if 
\begin_inset Formula $x$
\end_inset

 is a value, such as 
\begin_inset Formula $100$
\end_inset

, and 
\begin_inset Formula $f$
\end_inset

 is a function, such as 
\begin_inset Formula $f(x)=\sqrt{x}$
\end_inset

, then 
\begin_inset Formula $f(x)$
\end_inset

 will be the same, 
\begin_inset Formula $f(100)=\sqrt{100}=10$
\end_inset

, no matter how many times we compute 
\begin_inset Formula $f(x)$
\end_inset

.
 For instance, we can compute 
\begin_inset Formula $f(x)+f(x)=20$
\end_inset

 and obtain the correct result.
 We could also set 
\begin_inset Formula $y=f(x)$
\end_inset

 and compute 
\begin_inset Formula $y+y=20$
\end_inset

, with the same result.
 This property is called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
referential transparency
\end_layout

\end_inset


\series bold
referential transparency
\series default
 or 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pure function
\end_layout

\end_inset


\series bold
functional purity
\series default
 of the function 
\begin_inset Formula $f$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
After applying a pure function, we can be sure that, for instance, no hidden
 values in memory have been modified.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When we set 
\begin_inset Formula $x=100$
\end_inset

 and compute 
\begin_inset Formula $f(x)+f(x)$
\end_inset

, the number 
\begin_inset Formula $100$
\end_inset

 does not 
\begin_inset Quotes eld
\end_inset

become empty
\begin_inset Quotes erd
\end_inset

 after the first use; its value remains the same.
 This behavior is what we expect values to have.
 So, we say that integers 
\begin_inset Quotes eld
\end_inset

are values
\begin_inset Quotes erd
\end_inset

 in the mathematical sense.
 Alternatively, one says that numbers are 
\series bold
immutable
\begin_inset Index idx
status open

\begin_layout Plain Layout
immutable value
\end_layout

\end_inset

,
\series default
 i.e., cannot be modified.
 (What would it mean to 
\begin_inset Quotes eld
\end_inset

modify
\begin_inset Quotes erd
\end_inset

 the number 
\begin_inset Formula $10$
\end_inset

?)
\end_layout

\begin_layout Standard
In programming, a type 
\series bold
has value-like behavior
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
value-like behavior
\end_layout

\end_inset

if a computation applied to it always gives the same result.
 Usually, this means that the type contains immutable data, and the computation
 is referentially transparent.
 We can see that Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Range
\end_layout

\end_inset

 is immutable and behaves as a value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x = 1 until 10
\end_layout

\begin_layout Plain Layout

x: scala.collection.immutable.Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> x.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9) 
\end_layout

\end_inset

Collections such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 are immutable.
 Some elements of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 may not be evaluated yet, but this does not affect its value-like behavior:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val str = (1 until 10).toStream
\end_layout

\begin_layout Plain Layout

str: scala.collection.immutable.Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9) 
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

view
\end_layout

\end_inset

 method produces iterators that 
\emph on
do
\emph default
 have value-like behavior:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val v = (1 until 10).view
\end_layout

\begin_layout Plain Layout

v: scala.collection.SeqView[Int,IndexedSeq[Int]] = SeqView(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> v.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> v.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to the lack of value-like behavior, programs written using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 do not obey the usual rules of mathematical reasoning.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala's 
\family typewriter
Iterator
\family default
 class
\end_layout

\end_inset

This makes it easy to write wrong code that looks correct.
\end_layout

\begin_layout Standard
To illustrate the problem, let us re-implement Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-seq-7"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by keeping the same code but using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def stopRepeatsBad[T](iter: Iterator[T]): Iterator[T] = {
\end_layout

\begin_layout Plain Layout

  val halfSpeed = iter.flatMap(x => Seq(x, x))
\end_layout

\begin_layout Plain Layout

  halfSpeed.zip(iter) // Do not prepend the first element.
 It won't help.
\end_layout

\begin_layout Plain Layout

  .drop(1).takeWhile { case (h, s) => h != s }
\end_layout

\begin_layout Plain Layout

  .map(_._2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> stopRepeatsBad(Seq(1, 3, 5, 7, 9, 3, 5, 7, 9).toIterator).toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(5, 9, 3, 7, 9)
\end_layout

\end_inset

The result 
\begin_inset Formula $\left[5,9,3,7,9\right]$
\end_inset

 is incorrect, but not in an obvious way: the sequence 
\emph on
was
\emph default
 stopped at a repetition, as we wanted, but some of the elements of the
 given sequence are missing (while other elements are present).
 It is difficult to debug a program that produces 
\emph on
partially
\emph default
 
\emph on
correct
\emph default
 numbers.
\end_layout

\begin_layout Standard
The error in this code occurs in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

halfSpeed.zip(iter)
\end_layout

\end_inset

 due to the fact that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

halfSpeed
\end_layout

\end_inset

 was itself defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter
\end_layout

\end_inset

.
 The result is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iter
\end_layout

\end_inset

 is used twice in this code, which leads to errors.
  Creating an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 and using it twice in the same expression can give wrong results or even
 fail with an exception:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = (1 until 10).toIterator
\end_layout

\begin_layout Plain Layout

s: Iterator[Int] = non-empty iterator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val t = s.zip(s).toList
\end_layout

\begin_layout Plain Layout

java.util.NoSuchElementException: next on empty iterator
\end_layout

\end_inset

It is surprising and counter-intuitive that a variable (here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

) cannot be used twice; we expect that the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.zip(s)
\end_layout

\end_inset

 would just 
\begin_inset Quotes eld
\end_inset

zip
\begin_inset Quotes erd
\end_inset

 a given sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 with itself.
 But Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 class is 
\series bold
mutable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
mutability
\end_layout

\end_inset

: it gets modified during its use.
 This breaks the value-based reasoning about code.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala's 
\family typewriter
Iterator
\family default
 class
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 can be converted to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toStream
\end_layout

\end_inset

 method.
 This restores the value-based reasoning because streams behave as values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val iter = (1 until 10).toIterator
\end_layout

\begin_layout Plain Layout

iter: Iterator[Int] = non-empty iterator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val str = iter.toStream
\end_layout

\begin_layout Plain Layout

str: Stream[Int] = Stream(1, ?)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(1, 2, 3, 4, 5, 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.toList
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(1, 2, 3, 4, 5, 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> str.zip(str).toList
\end_layout

\begin_layout Plain Layout

res2: List[(Int, Int)] = List((1,1), (2,2), (3,3), (4,4), (5,5), (6,6))
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

, we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

view
\end_layout

\end_inset

 when lazy or on-call collections are required.
 Newer versions of Scala replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LazyList
\end_layout

\end_inset

, which is a lazily evaluated (and possibly infinite) stream.
 Libraries such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scalaz
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fs2
\end_layout

\end_inset

 also provide streams with correct value-like behavior.
\end_layout

\begin_layout Standard
The mutable behavior of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Iterator
\end_layout

\end_inset

 is an example of a 
\begin_inset Quotes eld
\end_inset

side effect
\begin_inset Quotes erd
\end_inset

.
 A function has a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
side effect
\end_layout

\end_inset


\series bold
side effect
\series default
 if the function's code performs some external action in addition to computing
 a result value.
 Examples of side effects are: modifying a value stored in memory; starting
 and stopping processes or threads; reading or writing files; printing;
 sending or receiving data over a network; showing images on a display;
 playing or recording sounds; getting photos or videos from a digital camera.
 
\end_layout

\begin_layout Standard
Code that performs side effects does not behave as a value.
 Evaluating such code twice will perform the side effect twice, which is
 not the same as just re-using the result value twice.
 A function with a side effect may return different values each time it
 is called, even when the same arguments are given to the function.
 (For example, a digital camera will typically return a different image
 each time.) 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pure function
\end_layout

\end_inset


\series bold
Pure functions
\series default
 are those that contain no code with side effects.
 A pure function will always return the same result value when applied to
 the same arguments.
 So, pure functions behave similarly to functions that are used in mathematics.
\end_layout

\begin_layout Standard
This book focuses on pure functions and on mathematical reasoning about
 them.
 Statements such as 
\emph on

\begin_inset Quotes eld
\end_inset

the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method cannot implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 because it can only apply element-wise transformations to sequences
\begin_inset Quotes erd
\end_inset


\emph default
 are correct only if the code is restricted to pure functions without side
 effects.
 Otherwise we would write code like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sum(xs: Seq[Int]): Int = {
\end_layout

\begin_layout Plain Layout

  var result: Int = 0           // A mutable variable.
\end_layout

\begin_layout Plain Layout

  sum.map { x =>  result += x } // Side effect: mutation.
\end_layout

\begin_layout Plain Layout

  result
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
