#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Addchap
Essay: Software engineers and software artisans
\end_layout

\begin_layout Standard
Let us examine what we ordinarily understand by 
\emph on
engineering
\emph default
 as opposed to artisanship or craftsmanship.
 It will then become apparent that today's computer programmers must be
 viewed as 
\begin_inset Quotes eld
\end_inset

software artisans
\begin_inset Quotes erd
\end_inset

 rather than software engineers.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
The book reviewed in 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.developerdotstar.com/mag/bookreviews/bitner_craftsmanship.html"
literal "false"

\end_inset


\family default
 proposes a different definition of 
\begin_inset Quotes eld
\end_inset

software artisans
\begin_inset Quotes erd
\end_inset

 than this book, but agrees that software developers work largely as artisans.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Engineering disciplines 
\end_layout

\begin_layout Standard
Consider the way mechanical engineers, chemical engineers, or electrical
 engineers work, and look at the studies they require for becoming proficient
 in their fields.
\end_layout

\begin_layout Standard
A mechanical engineer studies calculus, linear algebra, differential geometry,
 and several areas of physics such as theoretical mechanics, thermodynamics,
 and elasticity theory,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.colorado.edu/mechanical/academics/undergraduate-program/curriculum"
literal "false"

\end_inset


\end_layout

\end_inset

 and then uses calculations to guide the design of a bridge.
 A chemical engineer studies chemistry, thermodynamics, calculus, linear
 algebra, differential equations, some areas of physics such as thermodynamics
 and kinetic theory,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.colorado.edu/engineering/sample-undergraduate-curriculum-chemical"
literal "false"

\end_inset


\end_layout

\end_inset

 and uses calculations to guide the design of a chemical process.
 An electrical engineer studies advanced calculus, linear algebra, and several
 areas of physics such as electrodynamics and quantum theory,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/XYLyE"
literal "false"

\end_inset


\end_layout

\end_inset

 and uses calculations to design an antenna or a microchip.
\end_layout

\begin_layout Standard
The common pattern is that engineers use mathematics and natural sciences
 in order to create new devices.
 Mathematical calculations and scientific reasoning are performed 
\emph on
before
\emph default
 designing or building a real machine.
\end_layout

\begin_layout Standard
Some of the studies required for engineers include arcane abstract concepts
 such as the 
\begin_inset Quotes eld
\end_inset

Fourier transform of the delta function
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.youtube.com/watch?v=KAbqISZ6SHQ"
literal "false"

\end_inset


\end_layout

\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

inverse 
\begin_inset Formula $Z$
\end_inset

-transform
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/SsJqP"
literal "false"

\end_inset


\end_layout

\end_inset

 in digital signal processing, 
\begin_inset Quotes eld
\end_inset

rank 4 tensors
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://serc.carleton.edu/NAGTWorkshops/mineralogy/mineral_physics/tensors.html"
literal "false"

\end_inset


\end_layout

\end_inset

 in calculations of elasticity of materials, 
\begin_inset Quotes eld
\end_inset

Lagrangians with non-holonomic constraints
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/abs/math/0008147"
literal "false"

\end_inset


\end_layout

\end_inset

 in robotics, and the 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

 in chemical reactor design.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://amzn.com/dp/1118368258"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To be sure, a significant part of what engineers do is not covered by any
 theory: the 
\emph on
know-how
\emph default
, the informal reasoning, the traditional knowledge passed on from expert
 to novice,  — all those skills that are hard to formalize are important.
 Nevertheless, engineering is crucially based on natural science and mathematics
 for some of its decision-making about new designs.
\end_layout

\begin_layout Addsec
Artisanship: Trades and crafts 
\end_layout

\begin_layout Standard
Now consider what kinds of things shoemakers, plumbers, or home painters
 do, and what they have to learn in order to become proficient in their
 profession.
\end_layout

\begin_layout Standard
A novice shoemaker, for example, begins by copying some drawings
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://youtu.be/cY5MY0czMAk?t=141"
literal "false"

\end_inset


\end_layout

\end_inset

 and goes on to cutting leather in a home workshop.
 Apprenticeships proceed via learning by doing, with comments and instruction
 from an expert.
 After a few years of study (for example, a painter apprenticeship in California
 can be as short as two years
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.calapprenticeship.org/programs/painter_apprenticeship.php"
literal "false"

\end_inset


\end_layout

\end_inset

), a new artisan is ready to start productive work.
 
\end_layout

\begin_layout Standard
All trades operate entirely from tradition and practical experience.
 It takes a prolonged learning effort to become a good artisan in any profession.
 But the trades do not require academic study because there is no formal
 theory from which to proceed.
 There are no Fourier transforms applied to delta functions, no Lagrangians
 with non-holonomic constraints, no fourth rank tensors to calculate, nor
 any differential equations to solve.
\end_layout

\begin_layout Standard
Artisans do not study science or mathematics because their professions do
 not make use of any formal theory for guiding their designs or processes.
\end_layout

\begin_layout Addsec
Programmers today are artisans, not engineers 
\end_layout

\begin_layout Standard
Programmers are 
\emph on
not engineers
\emph default
 in the sense normally used in the engineering professions.
\end_layout

\begin_layout Subsection*
No requirements of licensing or formal study
\end_layout

\begin_layout Standard
Mechanical, electrical, chemical engineers are required to pass a license
 exam to become certified to work.
 The license exam certifies that the person is proficient in applying a
 known set of engineering tools and methods.
 But in software engineering, no certifications or licenses are required
 for the job (although many certification programs exist).
\end_layout

\begin_layout Standard
Working software engineers are also not required to have studied software
 engineering or computer science (CS).
 According to a recent Stack Overflow survey,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://thenextweb.com/insider/2016/04/23/dont-need-go-college-anymore-programmer/"
literal "false"

\end_inset


\end_layout

\end_inset

 about 56% of working programmers have no CS degree.
 The author of this book is a self-taught programmer who has degrees in
 physics but never formally studied CS or taken any academic courses in
 algorithms, data structures, computer networks, compilers, programming
 languages, or other standard CS topics.
 
\end_layout

\begin_layout Standard
A large fraction of successful programmers have no college degrees and perhaps
 
\emph on
never
\emph default
 studied formally.
 They acquired all their knowledge and skills through self-study and practical
 work.
 A prominent example is Robert C.
\begin_inset space ~
\end_inset

Martin
\begin_inset Index idx
status open

\begin_layout Plain Layout
Robert C.
\begin_inset space ~
\end_inset

Martin
\end_layout

\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Robert_C._Martin"
literal "false"

\end_inset


\end_layout

\end_inset

 an outspoken guru in the arts of programming.
 He routinely refers to programmers as artisans
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2013/02/01/The-Humble-Craftsman.html"
literal "false"

\end_inset


\end_layout

\end_inset

 and uses the appropriate imagery: novices and masters, trade and craft,
 the honor of the guild, etc.
 He compares programmers to plumbers, electricians, lawyers, and surgeons,
 but never to mathematicians, physicists, or engineers of any kind.
 According to one of his blog posts,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2013/11/25/Novices-Coda.html"
literal "false"

\end_inset


\end_layout

\end_inset

 he started working at age 17 as a self-taught programmer.
 He never went to college and holds no degrees.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://archive.is/MNlgT"
target "https://hashnode.com/post/i-am-robert-c-martin-uncle-bob-ask-me-anything-cjr7pnh8g000k2cs18o5nhulp/2"
literal "false"

\end_inset


\end_layout

\end_inset

 It is clear that R.
\begin_inset space ~
\end_inset

C.
\begin_inset space ~
\end_inset

Martin 
\emph on
is
\emph default
 an expert craftsman and that he did 
\emph on
not
\emph default
 need academic study to master the craft of programming.
\end_layout

\begin_layout Standard
Here is another opinion
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/tAKQ3"
literal "false"

\end_inset


\end_layout

\end_inset

 (emphasis is theirs):
\end_layout

\begin_layout Quotation

\size small
Software Engineering is unique among the STEM careers in that it absolutely
 does 
\emph on
not
\emph default
 require a college degree to be successful.
 It most certainly does not require licensing or certification.
 
\emph on
It requires experience
\emph default
.
\end_layout

\begin_layout Standard
This description fits a career in crafts — but certainly not a career, say,
 in electrical engineering.
\end_layout

\begin_layout Standard
The high demand for software developers gave rise to 
\begin_inset Quotes eld
\end_inset

developer boot camps
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/GkOL9"
literal "false"

\end_inset


\end_layout

\end_inset

 — vocational schools that educate new programmers in a few months through
 purely practical training, with no formal theory or mathematics involved.
 These vocational schools are successful
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/E9FXP"
literal "false"

\end_inset


\end_layout

\end_inset

 in job placement.
 But it is unimaginable that a 
\begin_inset Formula $6$
\end_inset

-month crash course or even a 
\begin_inset Formula $2$
\end_inset

-year vocational school could prepare engineers to work successfully on
 designing, say, analog quantum computers
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.dwavesys.com/quantum-computing"

\end_inset


\end_layout

\end_inset

 without ever learning quantum physics or calculus.
\end_layout

\begin_layout Subsection*
No mathematical formalism guides software development
\end_layout

\begin_layout Standard
Most books on software engineering contain no formulas or equations, no
 mathematical derivations, and no precise definitions of the various technical
 terms they are using (such as 
\begin_inset Quotes eld
\end_inset

object-oriented
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

module's responsibilities
\begin_inset Quotes erd
\end_inset

).
 Some of those books
\begin_inset Foot
status open

\begin_layout Plain Layout
E.g., 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://amzn.com/dp/0073376256"
literal "false"

\end_inset


\end_layout

\end_inset

 also have almost no program code in them.
 Some of those books are written by practitioners such as R.
\begin_inset space \space{}
\end_inset

C.
\begin_inset space \space{}
\end_inset

Martin who do not explain their material in terms of formalisms.
 Instead, they summarize their programming experience in heuristically formulate
d “principles”.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html"
literal "false"

\end_inset


\end_layout

\end_inset

 The programmers are told: 
\begin_inset Quotes eld
\end_inset

code is about detail
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

never abandon the big picture
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

avoid tight coupling in your modules
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a class must serve a single responsibility
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

strive for good interfaces
\begin_inset Quotes erd
\end_inset

, and so on.
 
\end_layout

\begin_layout Standard
In contrast, textbooks on mechanical or electrical engineering include a
 significant amount of mathematics.
 The design of a microwave antenna is guided not by an 
\begin_inset Quotes eld
\end_inset

open and closed module principle
\begin_inset Quotes erd
\end_inset

 but by solving the relevant differential equations
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://youtu.be/8KpfVsJ5Jw4?t=447"
literal "false"

\end_inset


\end_layout

\end_inset

 of electrodynamics.
\end_layout

\begin_layout Standard
Another example of programmers' avoidance of mathematical tools is given
 by the 
\begin_inset Quotes eld
\end_inset

Liskov substitution principle
\begin_inset Index idx
status open

\begin_layout Plain Layout
Liskov substitution principle
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 for subtyping
\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Liskov_substitution_principle"
literal "false"

\end_inset


\family default
.
 The LSP always holds in functional programming if values are immutable
 and subtyping is viewed as an automatic type conversion function (see Definitio
n
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-subtyping"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 A property 
\begin_inset Formula $\phi(y)$
\end_inset

 is rewritten as 
\begin_inset Formula $\phi(c(y))$
\end_inset

 by inserting a suitable type conversion function, 
\begin_inset Formula $c:S\rightarrow T$
\end_inset

.
 Since 
\begin_inset Formula $c(y)$
\end_inset

 has type 
\begin_inset Formula $T$
\end_inset

 and 
\begin_inset Formula $\phi(x)$
\end_inset

 holds for all values 
\begin_inset Formula $x:T$
\end_inset

,  the property 
\begin_inset Formula $\phi(c(y))$
\end_inset

 holds automatically.
\end_layout

\end_inset

 Its rigorous formulation (
\begin_inset Quotes eld
\end_inset

for any property 
\begin_inset Formula $\phi(x)$
\end_inset

 that holds for all 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $T$
\end_inset

, and for any subtype 
\begin_inset Formula $S$
\end_inset

 of 
\begin_inset Formula $T$
\end_inset

, the property 
\begin_inset Formula $\phi(y)$
\end_inset

 must also hold for all 
\begin_inset Formula $y$
\end_inset

 of type 
\begin_inset Formula $S$
\end_inset


\begin_inset Quotes erd
\end_inset

) is not used by programmers.
 Instead, the literature on object-oriented programming formulates the principle
 as 
\begin_inset Quotes eld
\end_inset

objects of type 
\begin_inset Formula $T$
\end_inset

 may be substituted by objects of type 
\begin_inset Formula $S$
\end_inset

 while keeping the correctness of the program
\begin_inset Quotes erd
\end_inset

.
 This formulation 
\begin_inset Index idx
status open

\begin_layout Plain Layout
object-oriented programming
\end_layout

\end_inset

 is both vague (it does not specify how to choose the substituted objects
 of type 
\begin_inset Formula $S$
\end_inset

) and, strictly speaking, incorrect: If the program contains a function
 
\begin_inset Formula $f(t)$
\end_inset

 where 
\begin_inset Formula $t$
\end_inset

 is a value of type 
\begin_inset Formula $T$
\end_inset

, it is not always possible to find some value 
\begin_inset Formula $s$
\end_inset

 of type 
\begin_inset Formula $S$
\end_inset

 such that 
\begin_inset Formula $f(s)=f(t)$
\end_inset

.
 The reason is that some subtyping relations are not surjective, as shown
 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Subtyping-with-injective"
plural "false"
caps "false"
noprefix "false"

\end_inset

 of this book.
\end_layout

\begin_layout Standard
Donald Knuth's classic textbook 
\begin_inset Quotes eld
\end_inset


\emph on
The Art of Programming
\emph default

\begin_inset Quotes erd
\end_inset

 indeed treats programming as an art and not as a science.
 Knuth shows many algorithms and derives their mathematical properties but
 does not provide any theory that could guide programmers in actually 
\emph on
writing
\emph default
 programs (say, choosing the data types to be used).
 Knuth assumes that the reader who understands the mathematical properties
 of an algorithm will be able 
\emph on
somehow
\emph default
 to write correct code.
\end_layout

\begin_layout Standard
The books 
\begin_inset Quotes eld
\end_inset

The Science of Programming
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://amzn.com/dp/0387964800"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Program derivation
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://amzn.com/dp/0201416247"
literal "false"

\end_inset


\end_layout

\end_inset

 are attempts to provide a mathematical basis for writing programs starting
 from formal specifications.
 The books give some methods that guide programmers in writing code and
 at the same time produce a proof that the code conforms to the specification.
 However, the scope of proposed methods is limited to designing algorithms
 for iterative manipulation of data, such as sorting and searching algorithms.
 The procedures suggested in those books are far from a formal mathematical
 
\emph on
derivation
\emph default
 of a wide range of software programs from specifications.
 In any case, most programmers today are unaware of these books and do not
 use the methods explained there, even when those methods could apply.
\end_layout

\begin_layout Standard
Today's computer science courses do not teach a true engineering approach
 to software construction.
 Some courses teach analysis of programs using mathematical methods.
 Two such methods are complexity analysis
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://archive.is/6D796"
target "https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html"
literal "false"

\end_inset


\end_layout

\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

big-
\begin_inset Formula $O$
\end_inset

 notation
\begin_inset Quotes erd
\end_inset

) and formal verification.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Formal_verification"
literal "false"

\end_inset


\end_layout

\end_inset

 But programs are analyzed or verified only 
\emph on
after
\emph default
 they are somehow written.
 Theory does not guide the actual 
\emph on
process
\emph default
 of writing code: it does not define good ways of organizing the code (e.g.,
 how to decompose the code into modules, classes, or functions) and does
 not tell programmers which data structures and type signatures of functions
 will be useful to implement.
 Programmers make these design decisions on the basis of experience and
 intuition, trial-and-error, copy-paste, guesswork, and debugging.
 
\end_layout

\begin_layout Standard
In a sense, program analysis and verification is analogous to writing mathematic
al equations for the surface of a shoe made by a fashion designer.
 The resulting 
\begin_inset Quotes eld
\end_inset

shoe equations
\begin_inset Quotes erd
\end_inset

 are mathematically rigorous and could be analyzed or verified.
 But the equations are merely written after the fact, they do not guide
 the fashion designers in actually making shoes.
 It is understandable that fashion designers do not study the mathematical
 theory of geometric surfaces.
\end_layout

\begin_layout Subsection*
Programmers avoid academic terminology 
\end_layout

\begin_layout Standard
Programmers jokingly grumble about terms such as 
\begin_inset Quotes eld
\end_inset

functor
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

monad
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Quote

\size small
Those fancy words used by functional programmers purists really annoy me.
 Monads, functors...
 Nonsense!!! 
\size default

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/65K3D"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perhaps only a small minority of software developers complain about this,
 as the majority seems to be unaware of 
\begin_inset Quotes eld
\end_inset

applicative functors
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

free monads
\begin_inset Quotes erd
\end_inset

, and other arcane terminology.
 Indeed, that sort of terminology is intentionally avoided by most books
 and tutorials aimed at programmers.
\begin_inset Foot
status open

\begin_layout Plain Layout
For example, the recent book 
\begin_inset Quotes eld
\end_inset

Grokking functional programming
\begin_inset Quotes erd
\end_inset

 
\emph on
never
\emph default
 mentions 
\begin_inset Quotes eld
\end_inset

functors
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

monads
\begin_inset Quotes erd
\end_inset

.
 See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.manning.com/books/grokking-functional-programming"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
But why would an 
\emph on
engineer
\emph default
 wince at 
\begin_inset Quotes eld
\end_inset

functors
\begin_inset Quotes erd
\end_inset

 or at 
\begin_inset Quotes eld
\end_inset

free monads
\begin_inset Quotes erd
\end_inset

? Other branches of engineering use lots of terminology that is far from
 self-explanatory and requires some study.
 Chemical engineers learn about 
\begin_inset Quotes eld
\end_inset

Gibbs free energy
\begin_inset Quotes erd
\end_inset

, which is a technical term that denotes a certain function.
 (It
\begin_inset Index idx
status open

\begin_layout Plain Layout
jokes
\end_layout

\end_inset

 does not mean getting energy from J.
\begin_inset space ~
\end_inset

W.
\begin_inset space ~
\end_inset

Gibbs
\begin_inset Index idx
status open

\begin_layout Plain Layout
Josiah Willard Gibbs
\end_layout

\end_inset

 for free!) Chemical engineers accept the need for studying 
\begin_inset Quotes eld
\end_inset

phase diagrams
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Fourier's law
\begin_inset Quotes erd
\end_inset

.
 Mechanical engineers take it for granted that they have to work with 
\begin_inset Quotes eld
\end_inset

rank 4 tensors
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Lagrangians
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

non-holonomic constraints
\begin_inset Quotes erd
\end_inset

.
 Electrical engineers do not avoid 
\begin_inset Quotes eld
\end_inset

Fourier transforms
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

delta functions
\begin_inset Quotes erd
\end_inset

 just because those are weird things to say.
 The arcane terminology seems to be the least of their difficulties, as
 their textbooks are full of complicated equations and long derivations.
\end_layout

\begin_layout Standard
Textbooks on true software engineering would have been full of equations
 and derivations, teaching engineers how to perform certain calculations
 that are required 
\emph on
before
\emph default
 starting to write code.
\end_layout

\begin_layout Addsec
Towards true engineering in software
\end_layout

\begin_layout Standard
It is now clear that we do not presently have true software engineering.
 The people employed under that job title are actually artisans.
 They work using artisanal methods, and their education and design processes
 are typical of a crafts guild.
\end_layout

\begin_layout Standard
Software engineering in the proper sense would mean having a mathematical
 theory that guides the process of writing programs, — not just theory that
 describes or analyzes programs after they are 
\emph on
somehow
\emph default
 written.
\end_layout

\begin_layout Standard
It is true that numerical methods required for physics and matrix calculations
 required for data science are 
\begin_inset Quotes eld
\end_inset

mathematical
\begin_inset Quotes erd
\end_inset

.
 Those programming tasks are indeed formulated using mathematical theory.
 However, mathematical 
\emph on
subject matter
\emph default
 (aerospace control, physics simulations, or statistics) corresponds to
 a relatively small part of written code and does not by itself guide the
 process of writing code.
 Data scientists, aerospace engineers, and physicists almost always work
 as artisans when converting their computations into program code.
\end_layout

\begin_layout Standard
We expect that software engineers
\family sans
'
\family default
 textbooks should be full of equations and derivations.
 What theory would those equations represent?
\end_layout

\begin_layout Standard
This theory is what this book calls 
\series bold
applied functional type theory
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
applied functional type theory
\end_layout

\end_inset

 (see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Applied-functional-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It represents the mathematical foundation of the modern practice of functional
 programming, as implemented in languages such as OCaml, Haskell, and Scala.
 This theory is a blend of set theory, category theory, and logical proof
 theory, adapted for the needs of programmers.
 It has been in development since late 1990s and is still being actively
 worked on by a community of software practitioners and academic computer
 scientists.
\end_layout

\begin_layout Standard
To appreciate that functional programming, unlike other paradigms, is based
 on a 
\emph on
theory that guides coding
\emph default
, we can look at some recent software engineering conferences such as 
\begin_inset Quotes eld
\end_inset

Scala By the Bay
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://2015.scala.bythebay.io/"
literal "false"

\end_inset


\end_layout

\end_inset

 or BayHac,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://bayhac.org/"
literal "false"

\end_inset


\end_layout

\end_inset

 or at the numerous FP-related online tutorials and blogs.
 We cannot fail to notice that speakers devote significant time to a peculiar
 kind of applied mathematical reasoning.
 Rather than focusing on one or another API or algorithm, as it is often
 the case with other software engineering blogs or presentations, an FP
 speaker describes a 
\emph on
mathematical structure
\emph default
 — such as the 
\begin_inset Quotes eld
\end_inset

applicative functor
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.youtube.com/watch?v=bmIxIslimVY"
literal "false"

\end_inset


\end_layout

\end_inset

 or the 
\begin_inset Quotes eld
\end_inset

free monad
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.youtube.com/watch?v=U0lK0hnbc4U"
literal "false"

\end_inset


\end_layout

\end_inset

 — and illustrates its use for practical coding.
\end_layout

\begin_layout Standard
These people are not graduate students showing off their theoretical research.
 They are practitioners, software engineers who use FP on their jobs.
 It is just the nature of FP that certain mathematical tools and constructions
 are directly applicable to practical programming tasks.
\end_layout

\begin_layout Standard
These mathematical tools are not mere tricks for a specific programming
 language; they apply equally to all FP languages.
 Before starting to write code, the programmer can jot down certain calculations
 in a mathematical notation (see Fig.
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-calculation-in-type-theory"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The results of those calculations will help design the code fragment the
 programmer is about to write.
 This activity is similar to that of an engineer who performs some mathematical
 calculations before embarking on a design project.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Graphics
	filename ftt-example.jpg
	width 60line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
An imaginary programmer performs a derivation before writing Haskell code.
\begin_inset CommandInset label
LatexCommand label
name "fig:Example-calculation-in-type-theory"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A recent example of a development in applied functional type theory is the
 
\begin_inset Quotes eld
\end_inset

free applicative functor
\begin_inset Quotes erd
\end_inset

 construction.
 It was first described in a 2014 paper.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://arxiv.org/pdf/1403.0749.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 A couple of years later, a combined free applicative / free monad data
 type was designed and its implementation proposed in Scala
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/typelevel/cats/issues/983"
literal "false"

\end_inset


\end_layout

\end_inset

 as well as in Haskell.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://archive.is/kwD2a"
target "https://elvishjerricco.github.io/2016/04/08/applicative-effects-in-free-monads.html"
literal "false"

\end_inset


\end_layout

\end_inset

 This technique allows programmers to implement declarative side-effect
 computations where some parts are sequential but other parts are computed
 in parallel, and to achieve the parallelism 
\emph on
automatically
\emph default
 while maintaining the composability of the resulting programs.
 The new technique has advantages over monad transformers, which was a previousl
y known method of composing declarative side-effects.
 The combined 
\begin_inset Quotes eld
\end_inset

free applicative / free monad
\begin_inset Quotes erd
\end_inset

 code was designed and implemented by true software engineers.
 They first derived the type constructor that has the necessary algebraic
 properties.
 Guided by the resulting type formula, they wrote code that was guaranteed
 to work as intended.
\end_layout

\begin_layout Standard
Another example of using applied functional type theory is the  
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
tagless final
\end_layout

\end_inset

tagless final
\begin_inset Quotes erd
\end_inset

 encoding of effects, first described
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://okmij.org/ftp/tagless-final/index.html"

\end_inset


\end_layout

\end_inset

 in 2009.
 That technique (called 
\begin_inset Quotes eld
\end_inset

Church-encoded free monad
\begin_inset Index idx
status open

\begin_layout Plain Layout
free monad
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 in the present book) has advantages over the ordinary free monad in a number
 of cases — just as the free monad itself was used to cure certain problems
 with monad transformers.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/"
literal "false"

\end_inset


\end_layout

\end_inset

 The new encoding is not tied to a specific programming language.
 Rather, it is a language-agnostic construction that was originally described
 in OCaml and later used in Haskell and Scala, but can be made to work even
 in Java,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://oleksandrmanzyuk.wordpress.com/2014/06/18/"
literal "false"

\end_inset


\end_layout

\end_inset

 which is not an FP language.
\end_layout

\begin_layout Standard
This example shows that we may need several more years of work before the
 practical aspects of using applied functional type theory are sufficiently
 well understood by the FP community.
 The theory is in active development, and its design patterns — as well
 as the exact scope of the requisite theoretical material — are still being
 figured out.
 If the 40-year gap hypothesis
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://archive.is/kVYYt"
target "https://www.linkedin.com/pulse/40-year-gap-what-has-academic-computer-science-ever-done-winitzki"
literal "false"

\end_inset


\end_layout

\end_inset

 holds, we should expect applied functional type theory (perhaps under a
 different name) to become mainstream by 2030.
 This book is a step towards a clear designation of the scope of that theory.
\end_layout

\begin_layout Addsec
Does software need engineers, or are artisans sufficient? 
\end_layout

\begin_layout Standard
The demand for programmers is growing.
 
\begin_inset Quotes eld
\end_inset

Software developer
\begin_inset Quotes erd
\end_inset

 was #1 best job
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://money.usnews.com/money/careers/articles/how-us-news-ranks-the-best-jobs"
literal "false"

\end_inset


\end_layout

\end_inset

 in the US in 2018.
 But is there a demand for engineers or just for artisans?
\end_layout

\begin_layout Standard
We do not seem to be able to train enough software artisans.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.is/137b8"
literal "false"

\end_inset


\end_layout

\end_inset

 So, it is probably impossible to train as many software engineers in the
 true sense of the word.
 Modern computer science courses do not actually train engineers in that
 sense.
 Instead, they train academic researchers who will in most cases go on to
 work as software artisans writing code.
\end_layout

\begin_layout Standard
Looking at the situation in construction business in the U.S.A., we find that
 it employs about 
\begin_inset Formula $10$
\end_inset

 times more construction workers as architects.
 We might conclude that perhaps one software engineer is required per dozen
 software artisans.
\end_layout

\begin_layout Standard
What is the price of 
\emph on
not
\emph default
 having engineers, of replacing them with artisans?
\end_layout

\begin_layout Standard
Software practitioners have long bemoaned the permanent state of 
\begin_inset Quotes eld
\end_inset

crisis
\begin_inset Quotes erd
\end_inset

 in software development.
 Code 
\begin_inset Quotes eld
\end_inset

rots with time
\begin_inset Quotes erd
\end_inset

, its complexity grows 
\begin_inset Quotes eld
\end_inset

out of control
\begin_inset Quotes erd
\end_inset

, and operating systems have been notorious for a steady stream of new security
 flaws
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.fo/HtQzw"
literal "false"

\end_inset


\end_layout

\end_inset

 despite many thousands of programmers and testers employed.
 It appears that the growing complexity of software tends to overwhelm the
 capacity of the human brain for correct 
\emph on
artisanal
\emph default
 programming.
\end_layout

\begin_layout Standard
It is precisely in designing large and robust software systems that we would
 benefit from true engineering.
 Artisans has been building bridges and using chemical reactions by trial
 and error and via tradition, long before mechanical or chemical engineering
 disciplines were developed and founded upon rigorous theory.
 But once the theory became available, engineers were able to design unimaginabl
y more powerful and complicated structures, devices, and processes.
 So, we may expect that trial, error, and adherence to tradition is inadequate
 for some of the more complex software development tasks in front of us.
 
\end_layout

\begin_layout Standard
To build large and reliable software, such as new mobile or embedded operating
 systems or distributed peer-to-peer trust architectures, we will most likely
 need the qualitative increase in productivity and reliability that can
 only come from replacing artisanal programming by a true engineering discipline.
 Applied functional type theory and functional programming are steps in
 that direction.
\end_layout

\begin_layout Addchap
Essay: Declarative programming as a silver bullet
\end_layout

\begin_layout Standard
The main difficulty of software engineering is that programs tend to grow
 in size and to become progressively less understandable.
 As a result, bugs become hard or impossible to avoid as programmers need
 to add new features.
 
\end_layout

\begin_layout Standard
Initially, the paradigm of structural programming was supposed to solve
 this problem.
 A famous paper, 
\begin_inset Quotes eld
\end_inset

No silver bullet
\begin_inset Quotes erd
\end_inset

,
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/No_Silver_Bullet"
literal "false"

\end_inset


\end_layout

\end_inset

 rejected that view while at the same time doing little more than bemoaning
 the mysterious difficulty of writing correct programs.
 Brooks blamed it on the 
\begin_inset Quotes eld
\end_inset

inherent complexity
\begin_inset Quotes erd
\end_inset

 somehow present in all software engineering because the domain problems
 being solved are complex.
 Since then, people have claimed that object-oriented programming
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.drdobbs.com/there-is-a-silver-bullet/184407534"
literal "false"

\end_inset


\end_layout

\end_inset

 or functional programming
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://archive.li/TE9iB"
literal "false"

\end_inset


\end_layout

\end_inset

 are solutions to this difficulty; namely, that they will increase productivity
 by order of magnitude while avoiding bugs.
 Many people immediately stepped in to say that functional programming languages
 — Lisp, Haskell, and such — are not a silver bullet.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://archive.is/pA1hz"
target "https://www.slideshare.net/nashjain/no-silver-bullets-in-functional-programming-by-brian-mckenna"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I think we actually do have a silver bullet, hiding in plain sight.
 But rather than trying to argue from philosophical reasons, I would like
 to look at practical results.
 What are historical examples where a great increase in programmer productivity
 has been achieved by introducing some new paradigm that proved sufficiently
 useful for most programming languages to have adopted it later on?
\end_layout

\begin_layout Standard
After describing these past innovations, or 
\begin_inset Quotes eld
\end_inset

silver bullets
\begin_inset Quotes erd
\end_inset

, we will be able to distill an underlying principle that drives the productivit
y advantage.
 That principle is what I call declarative programming.
 
\end_layout

\begin_layout Addsec
The silver bullets we know and love
\end_layout

\begin_layout Standard
Perhaps the first real silver bullet (after Alan Turing invented the subroutine
 and the stack frame
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://people.cs.clemson.edu/~mark/subroutines.html"
literal "false"

\end_inset


\end_layout

\end_inset

) came as one of the features of the Fortran language.
 That feature of Fortran (that still survives in virtually all programming
 languages today) is the math-like syntax for arithmetic expressions.
 With Fortran, for the first time, the programmer could write a formula
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = B * C - SQRT(D)
\end_layout

\end_inset

 and the computer would generate all the necessary machine codes for computing
 that arithmetical expression.
 Before this innovation, programmers would have to write out all the required
 elementary operations and intermediate results in full, using machine instructi
ons that corresponded to the following sequence of actions:
\end_layout

\begin_layout LyX-Code
allocate memory 1 (intended for A)
\end_layout

\begin_layout LyX-Code
allocate memory 2 (intended for B * C)
\end_layout

\begin_layout LyX-Code
put B into memory 2
\end_layout

\begin_layout LyX-Code
multiply memory 2 with C and put result into memory 2
\end_layout

\begin_layout LyX-Code
allocate memory 3 (intended for SQRT(D))
\end_layout

\begin_layout LyX-Code
copy register 0 into memory 3 (to save it for later)
\end_layout

\begin_layout LyX-Code
put D into register 0
\end_layout

\begin_layout LyX-Code
call subroutine SQRT (expecting result again in register 0)
\end_layout

\begin_layout LyX-Code
swap register 0 and memory 3 (now restoring old register 0)
\end_layout

\begin_layout LyX-Code
flip sign of value in memory 3 (now have -SQRT(D) in memory 3)
\end_layout

\begin_layout LyX-Code
add memory 2 to memory 3 and put result into memory 2
\end_layout

\begin_layout LyX-Code
copy memory 2 into register 0
\end_layout

\begin_layout LyX-Code
free memory 2
\end_layout

\begin_layout LyX-Code
free memory 3
\end_layout

\begin_layout LyX-Code
free memory 1
\end_layout

\begin_layout LyX-Code
return
\end_layout

\begin_layout Standard
Instead of this quite tedious and error-prone sequence of instructions,
 Fortran programmers could simply write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = B * C - SQRT(D)
\end_layout

\end_inset

.
 The order-of-magnitude productivity increase is obvious from this example.
\end_layout

\begin_layout Standard
After Fortran, the LISP language enabled programmers to write recursive
 computations on lists and trees quite easily.
 These kinds of computations are important in two areas of computer science:
 compilers and strategy games.
 Implementing a backtracking search without a direct access to recursive
 data structures is a difficult and error-prone task.
 Most programming languages today support recursive data structures and
 recursive functions.
\end_layout

\begin_layout Standard
Another innovation was in the Prolog language.
 Prolog implemented a backtracking search as a built-in feature that the
 programmer does not even need to mention explicitly.
 A Prolog program only needs to declare the logical relationships that define
 the search space.
 The program may also specify shortcuts or speedups, to make the backtracking
 search run more efficiently.
 Prolog, however, did not find a lot of use outside the European artificial
 intelligence community of 1970–1980s.
 Its best area of application (expert systems) has had its heyday and is
 now a distant memory.
\end_layout

\begin_layout Standard
Nevertheless, the legacy of Prolog is alive and well in the form of SQL,
 the relational database language.
 SQL simplified Prolog by removing recursion, which made complicated search
 algorithms unnecessary, and instead added various convenience features
 to support table-driven accounting and reporting tasks.
 SQL is still a cornerstone of industrial data processing today.
\end_layout

\begin_layout Standard
Object-oriented programming was initially intended, as in the SIMULA language,
 for simulation of real-time interactions between systems.
 It was thought that people would simply imagine how real-world objects
 interact by sending each other requests or data, and transcribe that picture
 into code.
 Later, it was argued that OOP is especially suitable for developing a powerful
 graphical user interface, called OOUI.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Object-oriented_user_interface"
literal "false"

\end_inset


\end_layout

\end_inset

 Many programming languages today include some object-oriented features.
\end_layout

\begin_layout Standard
Functional programming languages started with Standard ML, which was a language
 for programming a mathematical proof assistant.
 Languages later developed in the spirit of Standard ML, such as OCaml and
 Haskell, were mostly used for writing compilers and verified code.
 However, basic features of Standard ML — immutable polynomial data types,
 pattern-matching, higher-order functions, and parametric polymorphism with
 a static type inference — have become standard, so that many new languages
 (such as F#, Scala, Swift, and Rust) include them by design, while older
 languages (Java, C#, Python) have retrofitted some of these features.
 
\end_layout

\begin_layout Addsec
What is 
\begin_inset Quotes eld
\end_inset

declarative programming
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
I first encountered the concept of 
\begin_inset Quotes eld
\end_inset

declarative programming
\begin_inset Quotes erd
\end_inset

 when I started studying Haskell and Prolog.
 Both languages are claimed to be declarative, as opposed to imperative
 languages such as C++ or Java.
 It was confusing, however, that two languages that are so different can
 be both deemed declarative.
 It was also clear that Prolog would be quite awkward for, say, numerical
 calculations, while Haskell would require a lot of hard-to-read, imperative
 code for tasks such as downloading a file from a Web server.
 (The book 
\begin_inset Quotes eld
\end_inset

Real World Haskell
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://amzn.com/dp/B0026OR2FY"
literal "false"

\end_inset


\end_layout

\end_inset

 shows some examples.
\family typewriter

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://book.realworldhaskell.org/read/extended-example-web-client-programming.html"
literal "false"

\end_inset


\end_layout

\end_inset

)
\end_layout

\begin_layout Standard
I tried to understand what people mean by declarative programming.
 The Wikipedia definition
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Declarative_programming"
literal "false"

\end_inset


\end_layout

\end_inset

 essentially says that declarative is 
\begin_inset Quotes eld
\end_inset

not imperative
\begin_inset Quotes erd
\end_inset

, and yet that definition is so vague that one could easily claim that Haskell
 is imperative while Visual Basic is declarative.
 Essentially, 
\begin_inset Quotes eld
\end_inset

declarative
\begin_inset Quotes erd
\end_inset

 is understood as a feature of a programming language as a whole, as if
 any programming language could be argued to be either 
\begin_inset Quotes eld
\end_inset

declarative
\begin_inset Quotes erd
\end_inset

 or not.
\end_layout

\begin_layout Standard
I was never satisfied with that definition and kept thinking about this
 question until I found a better definition, which I will explain now.
\end_layout

\begin_layout Standard
The common pattern among all the 
\begin_inset Quotes eld
\end_inset

silver bullet
\begin_inset Quotes erd
\end_inset

 paradigms is that 1) they were supposed to make programs very concise and
 easily readable when written for a specific and narrowly delineated problem
 domain, 2) they came with a new programming language designed specifically
 for that domain.
 Fortran was designed as a language for numerical mathematics; Prolog as
 a language for rule-based expert systems; and so on.
 One could plausibly argue that Fortran was as well adapted to programming
 numerical expressions as Prolog to expert systems or Haskell to compilers.
\end_layout

\begin_layout Standard
An important consequence is that the same languages were not suitable for
 other problem domains! Prolog was not suitable for matrix multiplication,
 nor Fortran for expert systems, nor Haskell for GUI programs.
\end_layout

\begin_layout Standard
Therefore, 
\begin_inset Quotes eld
\end_inset

declarativeness
\begin_inset Quotes erd
\end_inset

 is not  a property of a programming language, but a 
\emph on
relation
\emph default
 between a programming language and a problem domain.
 A language can be declarative for one specific problem domain but not for
 another.
\end_layout

\begin_layout Standard
The second important consequence is that a program in a 
\begin_inset Quotes eld
\end_inset

declarative
\begin_inset Quotes erd
\end_inset

 language must be something that is clearly understandable to humans.
 For example, the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = B * C - SQRT(D)
\end_layout

\end_inset

 is unambiguous, and its intent and effect are clear at first sight.
 This is because the program closely resembles what a person would write
 on paper in order to describe the required task.
 Similarly, Prolog programs look like declarations of facts and logical
 relations between facts or properties of some symbols.
 This is again very close to something that a human would write informally
 on paper when describing a particular task or problem.
\end_layout

\begin_layout Standard
Here is an example showing how Prolog is adapted to tasks involving logical
 relations.
 Consider the following logic puzzle:
\end_layout

\begin_layout Quotation
All jumping creatures are green.
 All small jumping creatures are martians.
 All green martians are intelligent.
 
\noun on
Ngtrks
\noun default
 is small and green.
 
\noun on
Pgvdrk
\noun default
 is a jumping martian.
 Who is intelligent? 
\emph on
(Inspired by the short story 
\begin_inset Quotes eld
\end_inset

Invasion from Aldebaran
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://de.wikipedia.org/wiki/Invasion_vom_Aldebaran"
literal "false"

\end_inset


\end_layout

\end_inset

 by S.
\begin_inset space ~
\end_inset

Lem.)
\end_layout

\begin_layout Standard
The following is the complete code of the Prolog program that solves this
 puzzle, together with an example execution command using SWI-Prolog:
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

$ cat > martians.pl
\end_layout

\begin_layout Plain Layout

small(ngtrks).
 green(ngtrks).
\end_layout

\begin_layout Plain Layout

martian(pgvdrk).
 jumping(pgvdrk).
\end_layout

\begin_layout Plain Layout

green(X) :- jumping(X).
\end_layout

\begin_layout Plain Layout

martian(X) :- small(X), jumping(X).
\end_layout

\begin_layout Plain Layout

intelligent(X) :- green(X), martian(X).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main :- intelligent(X), format('~w is intelligent.~n', X), halt.
\end_layout

\begin_layout Plain Layout

^D
\end_layout

\begin_layout Plain Layout

$ swipl -o martians -q -t main -c martians.pl
\end_layout

\begin_layout Plain Layout

$ ./martians
\end_layout

\begin_layout Plain Layout

pgvdrk is intelligent.
\end_layout

\end_inset

We could mechanically rewrite this code and replace Prolog predicates such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

green(X)
\end_layout

\end_inset

 by phrases such as 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 is green
\begin_inset Quotes erd
\end_inset

, the Prolog operator 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

:-
\end_layout

\end_inset

 by the word 
\begin_inset Quotes eld
\end_inset

when
\begin_inset Quotes erd
\end_inset

, and the comma (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

,
\end_layout

\end_inset

) by the word 
\begin_inset Quotes eld
\end_inset

and
\begin_inset Quotes erd
\end_inset

.
 Then we would find that the program code closely resembles the English-language
 description of the puzzle.
 In this sense, Prolog programs can be viewed as 
\begin_inset Quotes eld
\end_inset

executable specifications
\begin_inset Quotes erd
\end_inset

 for logic puzzles.
 
\end_layout

\begin_layout Standard
However, writing a matrix multiplication program in Prolog would require
 code that is far removed from any human-readable specification or mathematical
 notation.
\begin_inset Foot
status open

\begin_layout Plain Layout
See, e.g., 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/55687499"
literal "false"

\end_inset


\end_layout

\end_inset

 It is clear that Prolog is 
\emph on
not
\emph default
 declarative for numerical calculations.
\end_layout

\begin_layout Standard
As an illustration of why Haskell is declarative for recursive data structures,
 consider this excerpt from the book 
\begin_inset Quotes eld
\end_inset

Algorithms in C
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structures/dp/0201314525"
literal "false"

\end_inset


\end_layout

\end_inset

 and its almost mechanical translation into Haskell code:
\end_layout

\begin_layout Quotation

\series bold
Definition 5.1
\series default
 A binary tree is either an external node or an internal node connected
 to a pair of binary trees, which are called the left subtree and the right
 subtree of that node.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

data BTree a = BTNode a | BTVertex (BTree a) (BTree a)
\end_layout

\end_inset


\end_layout

\begin_layout Quotation

\series bold
Definition 5.6
\series default
 The level of a node in a tree is one higher than the level of its parent
 (with the root at level 0).
 The height of a tree is the maximum of the levels of the tree's nodes.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

heightOf :: BTree a -> Int
\end_layout

\begin_layout Plain Layout

heightOf (BTNode _) = 0
\end_layout

\begin_layout Plain Layout

heightOf (BTVertex left right) = 1 + max (heightOf left) (heightOf right)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These code snippets suggest that Haskell is declarative for the problem
 domain of manipulating tree-like data structures via recursive algorithms.
 Object-oriented implementations of these algorithms in C++ or Java require
 significantly more code, and the code will not syntactically resemble the
 specification.
 
\end_layout

\begin_layout Standard
By looking at the 
\begin_inset Quotes eld
\end_inset

silver bullet
\begin_inset Quotes erd
\end_inset

 examples, we arrive at the following definition of declarative programming:
\end_layout

\begin_layout Quote

\emph on
A program is declarative if it syntactically resembles a human-written specifica
tion of the required task, expressed in a commonly used specification language.
 
\end_layout

\begin_layout Standard
It follows that the concept of 
\begin_inset Quotes eld
\end_inset

declarative programming
\begin_inset Quotes erd
\end_inset

 is actually still narrower than a relation between a language and a problem
 domain.
 Given the same programming language, a program for the same problem domain
 can be written in different ways.
 Some of these equivalent programs will be non-declarative if they do not
 closely resemble a human-readable specification of the task.
\end_layout

\begin_layout Standard
A programming language is 
\series bold
declarative for a chosen problem domain
\series default
 if it allows us to write declarative programs for that domain.
 Declarative programs are executable but still human-readable specifications,
 written within the syntactic conventions of a specific programming language.
\end_layout

\begin_layout Addsec
Specification languages
\end_layout

\begin_layout Standard
A key question remains: what exactly is a 
\begin_inset Quotes eld
\end_inset

human-readable specification
\begin_inset Quotes erd
\end_inset

? Again, we need to look at known history to understand what specification
 languages people have been using to communicate tasks in various problem
 domains.
\end_layout

\begin_layout Standard
Mathematicians have spent millennia developing adequate notation for the
 various tasks relating to numerical calculations and logical abstractions.
 Writing the expression 
\begin_inset Formula $A=B\cdot C-\sqrt{D}$
\end_inset

 or the corresponding code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = B * C - SQRT(D)
\end_layout

\end_inset

 is as clear and unambiguous as it gets when we want to talk about numerical
 formulas.
 We do not know if another, 
\begin_inset Quotes eld
\end_inset

better
\begin_inset Quotes erd
\end_inset

 mathematical notation exists; but the one we have today seems to work well
 enough.
\end_layout

\begin_layout Standard
Each domain where humans have developed sophisticated artifacts, such as
 music, linguistics, technical drafting, and so on, has its own specialized
 notation.
 These notations do not all have the same level of formality or expressivity.
 For instance, the International Phonetic Alphabet
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/International_Phonetic_Alphabet"
literal "false"

\end_inset


\end_layout

\end_inset

 denotes pronunciation rather precisely, but there seems to be no accepted
 specification language that could denote unambiguously all the richness
 of the expressive intonation people use when actually talking.
\end_layout

\begin_layout Standard
It is safe to say that the task of developing a 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 notation — i.e., an unambiguous, expressive, and yet readable specification
 language — for a given problem domain is a difficult task that may take
 a long time for newer problem domains.
 The main reason for the difficulty is that a successful specification language
 must be convenient for human practitioners (whose detailed behavior, to
 date, has evaded a formal description).
 A person reading a description of a task in a good specification language
 must be able to understand the task quickly and should have no further
 questions or ambiguities to clarify.
\end_layout

\begin_layout Standard
It is precisely in areas where the specification language is well understood
 (for example: mathematical formulas, formal grammars, relational logic)
 that the development of a declarative programming language produced an
 order of magnitude increase in productivity.
 In all those cases, the programming language syntactically reproduces the
 specification language and, in this sense, makes the specifications 
\begin_inset Quotes eld
\end_inset

executable
\begin_inset Quotes erd
\end_inset

.
 However, blind attempts to use the same language for other problem domains
 did not bring any advantages.
 The widely expressed disappointments with structural programming, natural-langu
age programming, OOP, or functional programming is probably due to the fact
 that people expected a 
\begin_inset Quotes eld
\end_inset

declarativeness
\begin_inset Quotes erd
\end_inset

 in one domain to transfer to advantages in all other problem domains.
 But this does not seem to be the case with any of the attempts so far.
 Different problem domains are incompatible and require quite different
 specification languages.
\end_layout

\begin_layout Standard
Without an accepted specification language, there is no hope of reaping
 the full benefits of declarative programming.
 One domain where a specification language seems to be currently lacking
 is the visual logic of GUI applications.
 Several approaches — from business process management formalisms to temporal
 logic — have been tried, but so far no consensus emerged that any of those
 notations is truly declarative, — that is, unambiguously expressive and
 at the same time readily understandable to humans.
 When people design GUIs, they communicate their designs to each other informall
y and in multiple stages, gradually resolving the inevitable ambiguities.
 (
\begin_inset Quotes eld
\end_inset

And what if I now press this button in that window while the old message
 box is still visible?
\begin_inset Quotes erd
\end_inset

) As a result, GUI programming remains a difficult and error-prone exercise.
 Established GUI environments (X Window, MS Windows, macOS, iOS, Android)
 predominantly use the object-oriented paradigm, which turned out to be
 not a silver bullet for complex GUI design.
 Accordingly, programming a GUI application in these environments is a messy
 and painful affair (I am speaking from first-hand experience).
 Newer developments based on functional reactive programming are more promising
 but yet to be proven declarative, since no adequate specification language
 has emerged as yet in that area.
 
\end_layout

\begin_layout Addsec
How to use the silver bullet today: make your own DSL
\end_layout

\begin_layout Standard
In the 1980s, 1990s, and 2000s, many companies (including IBM, Microsoft,
 Sun, Apple, SAP, Bloomberg, and Workday) invented their own programming
 languages adapted to their respective business domains.
 The idea was that a specialized programming language would be necessary
 to serve their specific business.
 I think their intuition was that not merely that existing programming languages
 were not well adapted for business applications, but also that the newly
 designed programming languages would be made declarative for those domains.
 However, those companies most likely did not have a precise definition
 of their specification languages or problem domains before designing their
 new languages, which thus did not necessarily achieve the goal of being
 declarative.
\end_layout

\begin_layout Standard
Suppose you know the specification language of your problem domain, and
 you would like to create a language adapted to that domain, i.e., a domain-specif
ic language (DSL).
 It takes a great deal of work to create and support an entirely new programming
 language.
 The return on the investment is relatively small.
\end_layout

\begin_layout Standard
A better approach is to implement your DSL as a library in an established
 programming language (the 
\begin_inset Quotes eld
\end_inset

host
\begin_inset Quotes erd
\end_inset

 language).
 This produces a so-called embedded DSL (EDSL).
 The EDSL does not need to be particularly complicated or extensive.
 Its goal is to fit your problem domain so that you can express specifications
 for your tasks syntactically, more or less as you would tell them to a
 fellow human.
\end_layout

\begin_layout Standard
The immediate next question is to identify programming languages that allow
 us to easily implement domain-specific languages.
 Several language features seem to be required of a good 
\begin_inset Quotes eld
\end_inset

DSL-friendly
\begin_inset Quotes erd
\end_inset

 host language.
 One is the ability to redefine the meaning of existing operations, to fit
 the human-readable specification language.
 For example, we might want to redefine (
\begin_inset Quotes eld
\end_inset

overload
\begin_inset Quotes erd
\end_inset

) the multiplication operator (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

*
\end_layout

\end_inset

) so that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m * n
\end_layout

\end_inset

 would mean the matrix multiplication when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 are matrices.
 C++, Python, Haskell, and Scala support operator overloading, but Java
 and JavaScript do not.
\end_layout

\begin_layout Standard
Another useful feature would be the ability to make syntax shorter and more
 easily understandable.
 For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scalatest
\end_layout

\end_inset

 library for Scala defines syntax that allows programmers to write test
 conditions resembling English sentences, such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a + b should be > 0
\end_layout

\end_inset

This code is more easily readable than an equivalent Java syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(a + b).should().be().greaterThan(0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another DSL-friendly feature is the ability to generate or transform programs
 at compile time.
 For instance, a database DSL could read the database schema at compile
 time and generate the data access layer code, freeing the programmer from
 the tedious mechanical task of writing and updating the code each time
 the schema is revised.
 If a host language supports these features, a programmer can easily implement
 their own little DSL adapted specifically to the problem domain at hand,
 without modifying the host language's compiler or creating an entirely
 new programming language.
\end_layout

\begin_layout Standard
Finally, a DSL is hard to use if it is 
\begin_inset Quotes eld
\end_inset

brittle
\begin_inset Quotes erd
\end_inset

, — that is, permitting users to easily write correct-looking but buggy
 programs.
 The key to assuring correctness is to be able to verify, preferably at
 compile time (but in any case early in the development cycle), that the
 user's DSL program is consistent within the intended meaning of the DSL.
 For instance, if the DSL allows us to multiply matrices by writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m * n
\end_layout

\end_inset

, we should not be able to write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m * n
\end_layout

\end_inset

 by mistake when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is a telephone number rather than a matrix, only to discover the error
 much later when the code is running in production.
 The host language must maintain strict control over the abstractions behind
 the DSL.
\end_layout

\begin_layout Standard
Because of the importance of DSL-friendly features, some programming languages
 are more suitable to building DSLs than others.
 In particular, Scala and Haskell have outstanding abilities to redefine
 syntax, prevent user mistakes, perform compile-time code generation or
 transformation, and hide complexity behind tightly controlled abstractions,
 — all without modifying the existing compiler or tooling.
 For this reason, it is much easier to create custom DSLs in Scala and Haskell
 than in most other programming languages.
 
\end_layout

\begin_layout Addsec
Conclusion
\end_layout

\begin_layout Standard
Declarative programs are executable specifications.
 Thanks to the development of modern programming languages such as Scala
 and Haskell, the silver bullet is in our hands today.
 Just follow these easy steps and you will slay the software werewolf!
\end_layout

\begin_layout Enumerate
Discover or develop a good specification language for your problem domain.
 The specification language should be unambiguously expressive, complete
 for the problem domain, pragmatically convenient, and yet human-readable.
 It should be obvious at first reading that the specification says exactly
 what we intend to do.
\end_layout

\begin_layout Enumerate
Learn Scala and/or Haskell.
 
\end_layout

\begin_layout Enumerate
Implement the specification language syntactically as a DSL in a chosen
 host language.
 Iterate on the language as necessary to support your problem domain.
 
\end_layout

\begin_layout Enumerate
If you have different problem domains in the same project, do not mix different
 DSLs into one uber-language; this has proven to be counterproductive.
 It is best to keep DSLs separate and independent.
\end_layout

\end_body
\end_document
