#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The logic of types.
 III.
 The Curry-Howard correspondence
\begin_inset CommandInset label
LatexCommand label
name "chap:5-Curry-Howard"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset

Fully parametric functions (introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Fully-parametric-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) perform operations so general that their code works in the same way for
 all types.
 An example of a fully parametric function is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { x => g(f(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Deriving-a-function-s-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that for certain functions of this kind one can derive the code unambiguously
 from the type signature.
 There exists a mathematical theory (called the 
\series bold
Curry-Howard correspondence
\series default
) that gives precise conditions for the possibility of deriving a function's
 code from its type.
 There is also a systematic derivation algorithm that either produces the
 function's code or proves that the given type signature cannot be implemented.
 This chapter describes the main results and applications of that theory
 to functional programming.
\end_layout

\begin_layout Section
Values computed by fully parametric functions
\end_layout

\begin_layout Subsection
Motivation and outlook
\begin_inset CommandInset label
LatexCommand label
name "subsec:Motivation-and-outlook"

\end_inset


\end_layout

\begin_layout Standard
Consider the following sketch of a fully parametric function's Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B, ...]: ...
 = {
\end_layout

\begin_layout Plain Layout

  val x: Either[A, B] = ...
 // Some expression here.
\end_layout

\begin_layout Plain Layout

  ...
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

If this program compiles without type errors, it means that the types match
 and, in particular, that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is able to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is sometimes 
\emph on
impossible
\emph default
 to compute a value of a certain type in fully parametric code.
 For example, the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  val x: A = ???            // Cannot compute x here!
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The reason is that no fully parametric code can compute values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

from scratch
\begin_inset Quotes erd
\end_inset

, that is, without using any previously given value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and without applying a previously given function that returns a value of
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 are given as arguments; the given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 returns values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 must perform pattern matching on an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B)(pa: Option[A]): Option[B] = pa match {
\end_layout

\begin_layout Plain Layout

  case None       => 
\end_layout

\begin_layout Plain Layout

    val x: A = ??? // Cannot compute x here!
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

  case Some(a)    =>
\end_layout

\begin_layout Plain Layout

    val x: A = a   // Can compute x in this scope.
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Since the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 has no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we are unable to compute a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in that scope (as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 remains a fully parametric function).
 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Being able
\begin_inset Quotes erd
\end_inset

 to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 means that, if needed, the code should be able to 
\emph on
return
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a result value.
 This requires computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 in all cases, not just within one part (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case ...
\end_layout

\end_inset

) of a pattern-matching expression.
 In other words, we should be able to implement the following type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bad[A, B](f: A => B)(pa: Option[A]): A = ???
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, the question 
\begin_inset Quotes eld
\end_inset

can we compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 within a fully parametric function with arguments of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is equivalent to the question 
\begin_inset Quotes eld
\end_inset

can be implement a fully parametric function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(B, C) => A
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 From now on, we will focus on the latter kind of questions.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 also cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Since no arguments of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are given, the only way of obtaining a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 would be to apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 to 
\emph on
some
\emph default
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 But we just saw that the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 cannot compute any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\end_inset

Here are some other examples where 
\emph on
no
\emph default
 fully parametric code can implement a given type signature: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bad2[A, B](f: A => B): A = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def bad3[A, B, C](p: A => Either[B, C]): Either[A => B, A => C] = ???
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad2
\end_layout

\end_inset

 is that no data of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is given, while the given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 returns values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The problem with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad3
\end_layout

\end_inset

 is that it needs to hard-code the decision of whether to return the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 or the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 part of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

.
 That decision cannot depend on the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 because one cannot pattern-match on a function, and because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad3
\end_layout

\end_inset

 does not receive any data of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and so cannot call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 Suppose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad3
\end_layout

\end_inset

 is hard-coded to always return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(f)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

.
 It is then necessary to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

, but that is impossible: the given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 may return either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(b)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c)
\end_layout

\end_inset

 for different values of its argument (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

).
 This data is insufficient to create a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad3
\end_layout

\end_inset

 is not able to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(f)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In all these examples, we see that the impossibility of implementing a type
 signature means that the information given in a function's arguments is
 in some way insufficient for computing the result value.
\end_layout

\begin_layout Standard
The type signature inverse to that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad3
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def good3[A, B, C](q: Either[A => B, A => C]): A => Either[B, C] = ???
\end_layout

\end_inset

This type signature 
\emph on
can
\emph default
 be implemented, but only in one way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def good3[A, B, C](q: Either[A => B, A => C]): A => Either[B, C] = q match
 {
\end_layout

\begin_layout Plain Layout

  case Left(k)    => { a => Left(k(a))  }
\end_layout

\begin_layout Plain Layout

  case Right(k)   => { a => Right(k(a)) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, when working with fully parametric code and looking at some type signature
 of a function, we may ask the question â€” is that type signature implementable,
 and if so, can we derive the code by just 
\begin_inset Quotes eld
\end_inset

following the types
\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_layout Standard
It is remarkable that this question makes sense at all.
 When working with non-FP languages, the notion of fully parametric functions
 is usually not relevant, and implementations cannot be derived from types.
 But in functional programming, fully parametric functions are used often.
 It is then important for the programmer to know whether a given fully parametri
c type signature can be implemented, and if so, to be able to derive the
 code.
\end_layout

\begin_layout Standard
Can we prove rigorously that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad3
\end_layout

\end_inset

 cannot be implemented by any fully parametric code? Or, perhaps, we were
 mistaken and a clever trick 
\emph on
could
\emph default
 produce some code for those type signatures? 
\end_layout

\begin_layout Standard
So far, we only saw informal arguments about whether values of certain types
 can be computed.
 To make those arguments rigorous, we need to translate statements such
 as 
\begin_inset Quotes eld
\end_inset

a fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

 can compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C => A
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 into mathematical formulas with rules for proving them true or false.
\end_layout

\begin_layout Standard
The first step towards a rigorous mathematical formulation is to choose
 a precise notation.
 In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctions-and-conjunctions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we denoted by 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 the proposition 
\begin_inset Quotes eld
\end_inset

we 
\begin_inset Formula ${\cal C}\!$
\end_inset

an 
\begin_inset Formula ${\cal H}\!$
\end_inset

ave a value of type 
\begin_inset Formula $A$
\end_inset

 within a fully parametric function
\begin_inset Quotes erd
\end_inset

.
 When writing the code of that function, we may use the function's arguments,
 which might have types, say, 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

.
 So, we are interested in proving statements like this:
\begin_inset Formula 
\begin{align}
 & \text{a fully parametric expression can compute a value of type }A\nonumber \\
 & \text{using previously given values of types }X,Y,...,Z\quad.\label{eq:ch-CH-proposition-def}
\end{align}

\end_inset

Here 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 may be either type parameters or more complicated type expressions, such
 as 
\begin_inset Formula $B\rightarrow C$
\end_inset

 or 
\begin_inset Formula $(C\rightarrow D)\rightarrow E$
\end_inset

, built from some type parameters.
\end_layout

\begin_layout Standard
If values of types 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 are given, it means we 
\begin_inset Quotes eld
\end_inset

already have
\begin_inset Quotes erd
\end_inset

 values of those types, i.e., the propositions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 will be already true.
 So, proposition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-CH-proposition-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equivalent to 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is true assuming 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 are true
\begin_inset Quotes erd
\end_inset

.
 In mathematical logic, a statement of this form is called a 
\series bold
sequent
\series default
 and
\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)
\end_layout

\end_inset

 is denoted using the symbol 
\begin_inset Formula $\vdash$
\end_inset

 (called the 
\begin_inset Quotes eld
\end_inset


\series bold
turnstile
\series default

\begin_inset Quotes erd
\end_inset

):
\begin_inset Index idx
status open

\begin_layout Plain Layout
0@
\begin_inset Formula $\vdash$
\end_inset

 (turnstile) symbol
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
turnstile (
\begin_inset Formula $\vdash$
\end_inset

) symbol
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
\text{sequent}:\quad & {\cal CH}(X),{\cal CH}(Y),...,{\cal CH}(Z)\vdash{\cal CH}(A)\quad.\label{eq:ch-example-sequent}
\end{align}

\end_inset

The assumptions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(Y)$
\end_inset

, ..., 
\begin_inset Formula ${\cal CH}(Z)$
\end_inset

 are called 
\series bold
premises
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)!premises
\end_layout

\end_inset

 and the proposition 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is called the 
\series bold
goal
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sequent (in logic)!goal
\end_layout

\end_inset

 of the sequent.
\end_layout

\begin_layout Standard
Sequents provide a notation for the questions about types of fully parametric
 functions.
 Since our goal is to answer such questions rigorously, we will need to
 be able to 
\emph on
prove
\emph default
 sequents of the form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The following sequents correspond to the type signatures we just saw:
\begin_inset Formula 
\begin{align*}
\text{\texttt{fmap} for \texttt{Option}}:\quad & {\cal CH}(\text{\texttt{A => B}})\vdash{\cal CH}(\text{\texttt{Option[A] => Option[B]}})\\
\text{the function \texttt{before}}:\quad & {\cal CH}(\text{\texttt{A => B}}),{\cal CH}(\text{\texttt{B => C}})\vdash{\cal CH}(\text{\texttt{A => C}})\\
\text{the function }\text{\texttt{bad}}:\quad & {\cal CH}(\text{\texttt{A => B}}),{\cal CH}(\text{\texttt{Option[A]}})\vdash{\cal CH}(\text{\texttt{A}})\\
\text{the function }\text{\texttt{bad2}}:\quad & {\cal CH}(\text{\texttt{A => B}}),{\cal CH}(\text{\texttt{B => C}})\vdash{\cal CH}(\text{\texttt{A}})
\end{align*}

\end_inset

So far, we only saw informal arguments towards proving the first two sequents
 and disproving the last two.
 We will now develop tools for proving sequents rigorously.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We will then be able to prove that a given fully parametric function can
 compute values of a certain type (or that it cannot).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In formal logic, sequents are proved
\begin_inset Index idx
status open

\begin_layout Plain Layout
proof (in logic)
\end_layout

\end_inset

 by starting with certain axioms and following certain derivation rules.
 Different choices of axioms and derivation rules will give different 
\emph on
logics
\emph default
.
 We will need to discover the correct logic for reasoning about sequents
 with 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 To discover that logic's complete set of axioms and derivation rules, we
 need to examine systematically what types and code constructions are possible
 in a fully parametric function.
 The resulting logic is known under the name 
\begin_inset Quotes eld
\end_inset

constructive logic
\begin_inset Quotes erd
\end_inset

.
 That logic's axioms and derivation rules directly correspond to programming
 language constructions allowed by fully parametric code.
 For that reason, constructive logic gives correct answers about implementable
 and non-implementable type signatures of fully parametric functions.
\end_layout

\begin_layout Standard
We will then be able to borrow the results and methods already available
 in the mathematical literature on formal logic.
 The main result is an algorithm (called LJT) for finding a proof for a
 given sequent in the constructive logic.
 If a proof is found, the algorithm also provides the code of a function
 that has the type signature corresponding to the sequent.
 If a proof is not found, it means that the given type signature cannot
 be implemented by fully parametric code.
\end_layout

\begin_layout Subsection
Type notation and 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for standard type constructions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Type-notation-and-standard-type-constructions"

\end_inset


\end_layout

\begin_layout Standard
Here and in the following sections, we will be reasoning about sequents
 of the form:
\begin_inset Formula 
\[
{\cal CH}(X),{\cal CH}(Y),...,{\cal CH}(Z)\vdash{\cal CH}(A)
\]

\end_inset

that represent type signatures of fully parametric functions.
 It will be convenient to shorten the notation and to denote the set of
 all premises by the symbol 
\begin_inset Formula $\Gamma$
\end_inset

.
 We will then write just 
\begin_inset Formula $\Gamma\vdash{\cal CH}(A)$
\end_inset

 instead of 
\begin_inset Formula ${\cal CH}(X),{\cal CH}(Y),...,{\cal CH}(Z)\vdash{\cal CH}(A)$
\end_inset

.
 
\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctions-and-conjunctions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we saw examples of reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for case classes and for disjunctive types.
 We will now extend this reasoning systematically to all type constructions
 that fully parametric programs could use.
 The result will be that we rewrite 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions with arbitrary type expressions, such as 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, A), Option[B] => Either[(A, B), C]]
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

, in terms of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for simple type parameters: 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

, etc.
 A special type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation
\end_layout

\end_inset

 explained in this section will help us write type expressions more concisely.
 (See Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Appendix-Notations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 on page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "chap:Appendix-Notations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a summary of the type notation.)
\end_layout

\begin_layout Standard
There exist 
\series bold
six
\series default
 
\series bold
standard type constructions
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
six type constructions
\end_layout

\end_inset

 supported by all functional languages: primitive types, including the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type and the void type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

), tuples (also called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product types
\end_layout

\end_inset


\series bold
product types
\series default
), disjunctive types (also called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
co-product types
\end_layout

\end_inset


\series bold
co-product types
\series default
), function types, parameterized types, and recursive types.
 We will now derive the rules for writing 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for each of these type constructions except recursive types.
\end_layout

\begin_layout Paragraph
1a) Rule for the 
\family typewriter
Unit
\family default
 type
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has only a single value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, an 
\begin_inset Quotes eld
\end_inset

empty tuple
\begin_inset Quotes erd
\end_inset

.
 This value can be 
\emph on
always
\emph default
 computed since it does not need any previous data:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[...]: ...
 = {
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

  val x: Unit = () // We can always compute a `Unit` value.
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\end_inset

So, the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always true.
 In the type notation, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 We may write the rule as 
\begin_inset Formula $\mathcal{CH}(\bbnum 1)=True$
\end_inset

.
 
\end_layout

\begin_layout Standard
Named unit types
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset

 also have a single value that is always possible to compute.
 For example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class N1()
\end_layout

\end_inset

defines a named unit type.
 We can compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N1
\end_layout

\end_inset

 without using any other given values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: N1 = N1()
\end_layout

\end_inset

So, the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N1
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always true.
 In the type notation, named unit types are also denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

, just as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type itself.
\end_layout

\begin_layout Paragraph
1b) Rule for the void type
\end_layout

\begin_layout Standard
The Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has no values, so the proposition 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\begin_inset Formula $)$
\end_inset

 is always false.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\bbnum 0$
\end_inset

 in the type notation.
 So, the rule is 
\begin_inset Formula $\mathcal{CH}(\bbnum 0)=False$
\end_inset

.
\end_layout

\begin_layout Paragraph
1c) Rule for primitive types
\end_layout

\begin_layout Standard
For a specific primitive (or library-defined) type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, the corresponding 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition is 
\emph on
always true
\emph default
 because we may use a constant value, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[...]: ...
 {
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   val x: String = 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

 // We can always compute a `String` value.
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

So, the rule for primitive types is the same as that for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
 For example, 
\begin_inset Formula $\mathcal{CH}(\text{String})=True$
\end_inset

.
\end_layout

\begin_layout Paragraph
2) Rule for tuple types
\end_layout

\begin_layout Standard
To compute a value of a tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 requires computing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 
\emph on
and
\emph default
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 This is expressed by the logical formula 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\begin_inset Formula $)={\cal CH}(A)\wedge{\cal CH}(B)$
\end_inset

.
 A similar formula holds for case classes, as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:curry-howard-example-case-class"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shows.
 In the type notation, the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A\times B$
\end_inset

.
 Tuples and case classes with more than two parts are denoted by 
\begin_inset Formula $A\times B\times...\times C$
\end_inset

.
 For example, the Scala definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Person(firstName: String, lastName: String, age: Int)
\end_layout

\end_inset

is written in the type notation as 
\begin_inset Formula $\text{String}\times\text{String}\times\text{Int}$
\end_inset

.
 So, the rule for tuples is:
\begin_inset Formula 
\[
{\cal CH}\left(A\times B\times...\times C\right)={\cal CH}(A)\wedge{\cal CH}(B)\wedge...\wedge{\cal CH}(C)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
3) Rule for disjunctive types
\end_layout

\begin_layout Standard
A disjunctive type may consist of several cases.
 Having a value of a disjunctive type means to have a value of (at least)
 one of those cases.
 An example of translating this relationship into a formula was shown by
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:curry-howard-example-disjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For the standard disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, we have the logical formula 
\begin_inset Formula ${\cal CH}($
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\begin_inset Formula $)={\cal CH}(A)\vee{\cal CH}(B)$
\end_inset

.
 In the type notation, the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A+B$
\end_inset

.
 As another example, the Scala definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class NoRoots()                      extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class OneRoot(x: Double)             extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class TwoRoots(x: Double, y: Double) extends RootsOfQ
\end_layout

\end_inset

is translated to the type notation as:
\begin_inset Formula 
\[
\text{RootsOfQ}\triangleq\bbnum 1+\text{Double}+\text{Double}\times\text{Double}\quad.
\]

\end_inset

The type notation is significantly shorter because it omits all case class
 names and part names from the type definitions.
 Using the type notation, the rule for disjunctive types is written as:
\begin_inset Formula 
\[
{\cal CH}\left(A+B+...+C\right)={\cal CH}(A)\vee{\cal CH}(B)\vee...\vee{\cal CH}(C)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
4) Rule for function types
\end_layout

\begin_layout Standard
Consider now a function type such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 This type is written in the type notation as 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 To compute a value of that type, we need to write code like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: A => B = { (a: A) =>
\end_layout

\begin_layout Plain Layout

  ??? // Compute a value of type B in this scope.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The inner scope of this function needs to compute a value of type 
\begin_inset Formula $B$
\end_inset

, and the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 may be used for that.
 So, 
\begin_inset Formula ${\cal CH}(A\rightarrow B)$
\end_inset

 is true if and only if we are able to compute a value of type 
\begin_inset Formula $B$
\end_inset

 when we are given a value of type 
\begin_inset Formula $A$
\end_inset

.
 To translate this statement into the language of logical propositions,
 we need to use the logical
\begin_inset Index idx
status open

\begin_layout Plain Layout
logical implication
\end_layout

\end_inset

 
\series bold
implication
\series default
, 
\begin_inset Formula ${\cal CH}(A)\Rightarrow{\cal CH}(B)$
\end_inset

, which means that 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

 can be proved if we already have a proof of 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

.
 So, the rule for function types is:
\begin_inset Formula 
\[
{\cal CH}(A\rightarrow B)={\cal CH}(A)\Rightarrow{\cal CH}(B)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
5) Rule for parameterized types
\end_layout

\begin_layout Standard
Here is an example of a function with type parameters:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (A => B) => B = { x => g => g(x) }
\end_layout

\end_inset

Being able to define the body of such a function is the same as being able
 to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A => B) => B
\end_layout

\end_inset

 for 
\emph on
all
\emph default
 possible Scala types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 In the notation of logic, this is written as:
\begin_inset Formula 
\[
{\cal CH}\left(\forall(A,B).\,A\rightarrow(A\rightarrow B)\rightarrow B\right)\quad,
\]

\end_inset

and is equivalent to:
\begin_inset Formula 
\[
\forall(A,B).\,{\cal CH}\left(A\rightarrow(A\rightarrow B)\rightarrow B\right)\quad.
\]

\end_inset

The symbol 
\begin_inset Formula $\forall$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

for all
\begin_inset Quotes erd
\end_inset

 and is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
universal quantifier (
\begin_inset Formula $\forall$
\end_inset

)
\end_layout

\end_inset


\series bold
universal quantifier
\series default
 in logic.
 We read 
\begin_inset Formula $\forall A.\,{\cal CH}(B)$
\end_inset

 as the proposition 
\begin_inset Quotes eld
\end_inset

for all types 
\begin_inset Formula $A$
\end_inset

, we can compute a value of type 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
So, the rule for parameterized types with the type notation 
\begin_inset Formula $\forall A.\,F^{A}$
\end_inset

 is:
\begin_inset Formula 
\[
{\cal CH}(\forall A.\,F^{A})=\forall A.\,{\cal CH}(F^{A})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The type notation for the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is written in one of the following ways:
\begin_inset Formula 
\[
f^{A,B}:A\rightarrow\left(A\rightarrow B\right)\rightarrow B\quad,\quad\text{or equivalently}:\quad f:\forall(A,B).\,A\rightarrow\left(A\rightarrow B\right)\rightarrow B\quad.
\]

\end_inset

The type quantifier (
\begin_inset Quotes eld
\end_inset

for all 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\begin_inset Quotes erd
\end_inset

) indicates that 
\begin_inset Formula $f$
\end_inset

 can be used with all types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
In Scala, longer type expressions can be named, and those names (called
 
\series bold
type aliases
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

) can be used to make code shorter.
 Type aliases may also contain type parameters.
 Defining and using a type alias for the type of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A, B] = A => (A => B) => B
\end_layout

\begin_layout Plain Layout

def f[A, B]: F[A, B] = { x => g => g(x) }
\end_layout

\end_inset

This is written in the type notation by placing all type parameters into
 superscripts:
\begin_inset Formula 
\begin{align*}
F^{A,B} & \triangleq A\rightarrow\left(A\rightarrow B\right)\rightarrow B\quad,\\
f^{A,B}:F^{A,B} & \triangleq x^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(x)\quad,
\end{align*}

\end_inset

or equivalently (although somewhat less readably) as:
\begin_inset Formula 
\[
f:\big(\forall(A,B).\,F^{A,B}\big)\triangleq\forall(A,B).\,x^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(x)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In Scala 3, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 can be written as a value (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

) via this syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: [A, B] => A => (A => B) => B = {   // Valid only in Scala 3.
\end_layout

\begin_layout Plain Layout

  [A, B] => (x: A) => (g: A => B) => g(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This syntax closely corresponds to the code notation 
\begin_inset Formula $\forall(A,B).\,x^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(x)$
\end_inset

.
\end_layout

\begin_layout Standard
Case classes and disjunctive types use 
\emph on
names
\emph default
 for the types and their parts.
 However, those names only add convenience for programmers and do not affect
 the computational properties of types.
 The type notation is designed to support nameless type expressions.
\end_layout

\begin_layout Standard
The rules just shown will allow us to express 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for complicated types via 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for type parameters.
 Then any type signature can be rewritten as a sequent that contains 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions only for the individual type parameters.
 
\end_layout

\begin_layout Standard
In this way, we see a correspondence between a fully parametric type signature
 and a logical sequent that expresses the statement 
\begin_inset Quotes eld
\end_inset

the type signature can be implemented
\begin_inset Quotes erd
\end_inset

.
 This is the first part of the Curry-Howard correspondence.
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes the type notation and shows how to translate it into logic formulas
 with 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 Apart from recursive types (which we do not consider in this chapter),
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 lists all type constructions that may be used in the code of a fully parametric
 function.
\end_layout

\begin_layout Standard
The precedence
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation!operator precedence
\end_layout

\end_inset

 of operators in the type notation is chosen to have fewer parentheses in
 the type expressions that are frequently used.
 The rules of precedence are:
\end_layout

\begin_layout Itemize
The type product operator (
\begin_inset Formula $\times$
\end_inset

) groups stronger than the disjunctive operator (
\begin_inset Formula $+$
\end_inset

), so that type expressions such as 
\begin_inset Formula $A+B\times C$
\end_inset

 have the same operator precedence as in standard arithmetic.
 That is, 
\begin_inset Formula $A+B\times C$
\end_inset

 means 
\begin_inset Formula $A+\left(B\times C\right)$
\end_inset

.
 This convention makes type expressions easier to read.
\end_layout

\begin_layout Itemize
The function type arrow (
\begin_inset Formula $\rightarrow$
\end_inset

) groups weaker than the operators 
\begin_inset Formula $+$
\end_inset

 and 
\begin_inset Formula $\times$
\end_inset

, so that often-used types such as 
\begin_inset Formula $A\rightarrow\bbnum 1+B$
\end_inset

 (representing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Option[B]
\end_layout

\end_inset

) or 
\begin_inset Formula $A\times B\rightarrow C$
\end_inset

 (representing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B)) => C
\end_layout

\end_inset

) can be written without any parentheses.
 Type expressions such as 
\begin_inset Formula $\left(A\rightarrow B\right)\times C$
\end_inset

 will require parentheses but are needed less often.
\end_layout

\begin_layout Itemize
The type quantifiers group weaker than all other operators, so we can write
 types such as 
\begin_inset Formula $\forall A.\,A\rightarrow A\rightarrow A$
\end_inset

 without parentheses.
 This is helpful because type quantifiers are most often placed at the top
 level of a type expression.
 When that is not the case, parentheses are necessary, e.g., in the type expressio
n 
\begin_inset Formula $\left(\forall A.\,A\rightarrow A\rightarrow A\right)\rightarrow\bbnum 1+\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\wedge$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\vee$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 
\begin_inset Formula $\Rightarrow$
\end_inset

 
\begin_inset Formula ${\cal CH}(B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\bbnum 1)=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Int}$
\end_inset

, 
\begin_inset Formula $\text{String}$
\end_inset

, ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\text{Int})=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\cal CH}(\bbnum 0)=False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A]: F[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f^{A}:F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,{\cal CH}(F^{A})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val f: [A] => F[A]
\end_layout

\end_inset


\size small
 (Scala 3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f:\forall A.\,F^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall A.\,{\cal CH}(F^{A})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The correspondence
\begin_inset Index idx
status open

\begin_layout Plain Layout
type notation
\end_layout

\end_inset

 between types and 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\begin_inset CommandInset label
LatexCommand label
name "tab:ch-correspondence-type-notation-CH-propositions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples: Type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
From now on, we will prefer to write types in the type notation rather than
 in the Scala syntax.
 The type notation allows us to write nameless type expressions and makes
 the structure of complicated types clearer than in the Scala syntax.
 Names of types and parts of types are, of course, helpful for reminding
 programmers of the meaning of data in a program.
 However, writing names for every part of every type does not help reasoning
 about the properties of types.
 Once the programmer has finished deriving the necessary types and verifying
 their properties, the type notation can be straightforwardly translated
 into Scala code.
 Let us get some experience doing that.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-dupl-function"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-dupl-function"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 taking an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returning the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, x)
\end_layout

\end_inset

.
 Derive the most general type for this function.
 Write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 in the type notation, and translate it into a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition.
 Simplify the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition if possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the code of the function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta(x: ...) = (x, x)
\end_layout

\end_inset

To derive the most general type for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

, first assume 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is a type parameter; then the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, x)
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

.
 We do not see any constraints on the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 represents an arbitrary type and needs to be added to the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A](x: A): (A, A) = (x, x)
\end_layout

\end_inset

We find that the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A, A)
\end_layout

\end_inset

.
 We also note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

 seems to be the only way of implementing a fully parametric function with
 type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => (A, A)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We will use the letter 
\begin_inset Formula $\Delta$
\end_inset

 for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta
\end_layout

\end_inset

.
 In the type notation, the type signature of 
\begin_inset Formula $\Delta$
\end_inset

 is:
\begin_inset Formula 
\[
\Delta^{A}:A\rightarrow A\times A\quad.
\]

\end_inset

So, the proposition 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 (meaning 
\begin_inset Quotes eld
\end_inset

the function 
\begin_inset Formula $\Delta$
\end_inset

 can be implemented
\begin_inset Quotes erd
\end_inset

) is:
\begin_inset Formula 
\[
{\cal CH}(\Delta)=\forall A.{\cal \,CH}\left(A\rightarrow A\times A\right)\quad.
\]

\end_inset

In the type expression 
\begin_inset Formula $A\rightarrow A\times A$
\end_inset

, the product symbol (
\begin_inset Formula $\times$
\end_inset

) binds stronger than the function arrow (
\begin_inset Formula $\rightarrow$
\end_inset

), so the parentheses in 
\begin_inset Formula $A\rightarrow\left(A\times A\right)$
\end_inset

 may be omitted.
\end_layout

\begin_layout Standard
Using the rules for transforming 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions, we rewrite:
\begin_inset Formula 
\begin{align*}
 & {\cal CH}(A\rightarrow A\times A)\\
\text{rule for function types}:\quad & ={\cal CH}(A)\Rightarrow{\cal CH}(A\times A)\\
\text{rule for tuple types}:\quad & ={\cal CH}(A)\Rightarrow\left({\cal CH}(A)\wedge{\cal CH}(A)\right)\quad.
\end{align*}

\end_inset

Thus the proposition 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 is equivalent to:
\begin_inset Formula 
\[
{\cal CH}(\Delta)=\forall A.\,{\cal CH}(A)\Rightarrow({\cal CH}(A)\wedge{\cal CH}(A))\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It is intuitively clear that the proposition 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 is true: it just says that if 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is true then 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 is true.
 The point of writing 
\begin_inset Formula ${\cal CH}(\Delta)$
\end_inset

 in a mathematical notation is to prepare for proving this proposition rigorousl
y rather than based on intuition.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The standard types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 are written in the type notation as:
\begin_inset Formula 
\[
\text{Either}^{A,B}\triangleq A+B\quad,\quad\quad\text{Opt}^{A}\triangleq\bbnum 1+A\quad.
\]

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $A+B$
\end_inset

 by definition of the disjunctive type notation (
\begin_inset Formula $+$
\end_inset

).
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 has two disjoint cases, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

.
 The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 is a 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and is denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

 contains a single value of type 
\begin_inset Formula $A$
\end_inset

.
 So, the type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 We will also sometimes write 
\begin_inset Formula $\text{Opt}^{A}$
\end_inset

 to denote 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-1-a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-1-a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The Scala definition of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

UserAction
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait UserAction
\end_layout

\begin_layout Plain Layout

final case class SetName(first: String, last: String) extends UserAction
\end_layout

\begin_layout Plain Layout

final case class SetEmail(email: String)              extends UserAction
\end_layout

\begin_layout Plain Layout

final case class SetUserId(id: Long)                  extends UserAction
\end_layout

\end_inset

is written in the type notation as:
\begin_inset Formula 
\begin{equation}
\text{UserAction}\triangleq\text{String}\times\text{String}+\text{String}+\text{Long}\quad.\label{eq:ch-example-case-class-type-notation}
\end{equation}

\end_inset

The type operation 
\begin_inset Formula $\times$
\end_inset

 groups stronger than 
\begin_inset Formula $+$
\end_inset

, as in arithmetic.
 To derive the type notation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-case-class-type-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we first drop all names from case classes and get three nameless tuples
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String, String)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Long)
\end_layout

\end_inset

.
 Each of these tuples is then converted into a product using the operator
 
\begin_inset Formula $\times$
\end_inset

, and all products are 
\begin_inset Quotes eld
\end_inset

summed
\begin_inset Quotes erd
\end_inset

 in the type notation using the operator 
\begin_inset Formula $+$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The parameterized disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either3
\end_layout

\end_inset

 is a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Left[A, B, C](x: A)   extends Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Middle[A, B, C](x: B) extends Either3[A, B, C]
\end_layout

\begin_layout Plain Layout

final case class Right[A, B, C](x: C)  extends Either3[A, B, C]
\end_layout

\end_inset

This disjunctive type is written in the type notation as 
\begin_inset Formula $\text{Either3}^{A,B,C}\triangleq A+B+C$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 corresponding to the type notation:
\begin_inset Formula 
\[
F^{A}\triangleq\bbnum 1+\text{Int}\times A\times A+\text{Int}\times\left(\text{Int}\rightarrow A\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The formula for 
\begin_inset Formula $F^{A}$
\end_inset

 defines a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 with three parts.
 To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 in Scala, we need to choose names for each of the disjoint parts, which
 will become case classes.
 For the purposes of this example, let us choose names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F3
\end_layout

\end_inset

.
 Each of these case classes needs to have the same type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, we begin writing the code as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A](...) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F2[A](...) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F3[A](...) extends F[A]
\end_layout

\end_inset

Each of these case classes represents one part of the disjunctive type:
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F1
\end_layout

\end_inset

 represents 
\begin_inset Formula $\bbnum 1$
\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F2
\end_layout

\end_inset

 represents 
\begin_inset Formula $\text{Int}\times A\times A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F3
\end_layout

\end_inset

 represents 
\begin_inset Formula $\text{Int}\times\left(\text{Int}\rightarrow A\right)$
\end_inset

.
 It remains to choose names and define the case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait F[A]
\end_layout

\begin_layout Plain Layout

final case class F1[A]()                     extends F[A]  // Named unit
 type.
\end_layout

\begin_layout Plain Layout

final case class F2[A](n: Int, x1: A, x2: A) extends F[A]
\end_layout

\begin_layout Plain Layout

final case class F3[A](n: Int, f: Int => A)  extends F[A]
\end_layout

\end_inset

The names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x2
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 are chosen arbitrarily.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-ch-notation-function-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-ch-notation-function-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the type signature of the following function in the type notation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B]
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
This is a curried function, so we first rewrite the type signature as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B]: (A => B) => Option[A] => Option[B]
\end_layout

\end_inset

The type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 Now we can write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 as:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}^{A,B}:\left(A\rightarrow B\right)\rightarrow\bbnum 1+A\rightarrow\bbnum 1+B\quad,\\
\text{or equivalently}:\quad & \text{fmap}:\forall(A,B).\,\left(A\rightarrow B\right)\rightarrow\bbnum 1+A\rightarrow\bbnum 1+B\quad.
\end{align*}

\end_inset

We do not put parentheses around 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $\bbnum 1+B$
\end_inset

 because the function arrow (
\begin_inset Formula $\rightarrow$
\end_inset

) groups weaker than the other type operations.
 But parentheses around 
\begin_inset Formula $\left(A\rightarrow B\right)$
\end_inset

 are required.
\end_layout

\begin_layout Standard
We will usually prefer to write type parameters in superscripts rather than
 under type quantifiers.
 So, for example, we will write 
\begin_inset Formula $\text{id}^{A}\triangleq x^{:A}\rightarrow x$
\end_inset

 rather than 
\begin_inset Formula $\text{id}\triangleq\forall A.\,x^{:A}\rightarrow x$
\end_inset

.
\end_layout

\begin_layout Subsection
Exercises: Type notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[T, A]
\end_layout

\end_inset

 corresponding to this type notation:
\begin_inset Formula 
\[
Q^{T,A}\triangleq\bbnum 1+T\times A+\text{Int}\times(T\rightarrow T)+\text{String}\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Convert the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, Int), Either[(A, Char), (A, Float)]]
\end_layout

\end_inset

 from Scala syntax to the type notation.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Opt2[A, B]
\end_layout

\end_inset

 written in the type notation as 
\begin_inset Formula $\bbnum 1+A+B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-type-notation-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write a Scala type signature for the fully parametric function:
\begin_inset Formula 
\[
\text{flatMap}^{A,B}:\bbnum 1+A\rightarrow\left(A\rightarrow\bbnum 1+B\right)\rightarrow\bbnum 1+B
\]

\end_inset

and implement this function, preserving information as much as possible.
\end_layout

\begin_layout Section
The logic of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions
\begin_inset CommandInset label
LatexCommand label
name "sec:The-logic-of-ch-propositions"

\end_inset


\end_layout

\begin_layout Standard
So far, we were able to convert statements such as 
\begin_inset Quotes eld
\end_inset


\emph on
a fully parametric function can compute values of type
\emph default
 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 into logical propositions that we called 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 The next step is to determine the proof rules suitable for rigorous reasoning
 about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 Those rules will be rules of a formal logic.
\end_layout

\begin_layout Standard
This section is an extended voyage into certain aspects of formal logic
 that enable us to obtain proofs of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions and to derive program code from those proofs.
 While that theory (known as the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

Curry-Howard correspondence) is important as a technique of reasoning about
 types in functional programs, the material of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-logic-of-ch-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is used only for the discussions in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Discussion-curry-howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The rest of the book does not depend on the Curry-Howard correspondence.
\end_layout

\begin_layout Subsection
Motivation and first examples
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Motivation-and-first-examples"

\end_inset


\end_layout

\begin_layout Standard
Formal logic uses axioms and derivation rules for proving that certain formulas
 are true or false.
 We will use Greek letters (
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, etc.) to denote propositions in logic.
\end_layout

\begin_layout Standard
We will often need logical formulas that talk about properties of 
\emph on
arbitrary
\emph default
 propositions.
 This is denoted by the 
\series bold
universal quantifier
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
universal quantifier (
\begin_inset Formula $\forall$
\end_inset

)
\end_layout

\end_inset

 symbol (
\begin_inset Formula $\forall$
\end_inset

), which means 
\begin_inset Quotes eld
\end_inset

for all
\begin_inset Quotes erd
\end_inset

.
 The universal quantifier will be usually located in front of the formula,
 for example:
\begin_inset Formula 
\[
\forall(\alpha,\beta).\,\left(\alpha\Rightarrow\beta\right)\Rightarrow\alpha\Rightarrow\alpha\quad.
\]

\end_inset

The symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 denotes 
\begin_inset Index idx
status open

\begin_layout Plain Layout
implication (in logic)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
logical implication
\end_layout

\end_inset


\series bold
implication
\series default
: 
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset

 means that 
\emph on
if
\emph default
 
\begin_inset Formula $\alpha$
\end_inset

 is proved true 
\emph on
then
\emph default
 
\begin_inset Formula $\beta$
\end_inset

 will be proved true.
\end_layout

\begin_layout Standard
Formulas whose propositions are all universally quantified correspond to
 type signatures that are made entirely from type parameters.
 For instance, the formula shown above corresponds to the following type
 signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: (A => B) => A => A
\end_layout

\end_inset

The universal quantifier 
\begin_inset Formula $\forall(\alpha,\beta)$
\end_inset

 corresponds to the fact that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 works with any choice of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A simple example of a true logical formula is 
\begin_inset Quotes eld
\end_inset

any proposition 
\begin_inset Formula $\alpha$
\end_inset

 follows from itself
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{equation}
\forall\alpha.\,\alpha\Rightarrow\alpha\quad.\label{eq:ch-type-sig-1a}
\end{equation}

\end_inset

If the proposition 
\begin_inset Formula $\alpha$
\end_inset

 is a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition, that is, if 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 for some type 
\begin_inset Formula $A$
\end_inset

, we obtain from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-type-sig-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) the formula:
\begin_inset Formula 
\begin{equation}
\forall A.\,{\cal CH}(A)\Rightarrow{\cal CH}(A)\quad.\label{eq:ch-type-sig-1}
\end{equation}

\end_inset

We expect true 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions to correspond to types that 
\emph on
can
\emph default
 be computed in a fully parametric function.
 Let us see if this example fits our expectations.
 We can rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-type-sig-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,\gunderline{{\cal CH}(A)\Rightarrow{\cal CH}(A)}\\
\text{rule for function types}:\quad & =\gunderline{\forall A}.\,{\cal CH}\left(A\rightarrow A\right)\\
\text{rule for parameterized types}:\quad & ={\cal CH}\left(\forall A.\,A\rightarrow A\right)\quad.
\end{align*}

\end_inset

The last line shows a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition that corresponds to the type 
\begin_inset Formula $\forall A.\,A\rightarrow A$
\end_inset

.
 Translating this type notation into a Scala type signature, we get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => A
\end_layout

\end_inset

This type signature can be implemented by an identity function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => A = { x => x }
\end_layout

\end_inset

This example shows a true 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition that corresponds to a type signature of a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, and we see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 
\emph on
can
\emph default
 be implemented in code.
\end_layout

\begin_layout Standard
While the correctness of the formula 
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset

 may be self-evident, the point of using formal logic is to have a set of
 axioms and proof rules that allow us to verify 
\emph on
all
\emph default
 true formulas systematically, without guessing or testing.
 What axioms and proof rules are suitable for proving 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions?
\end_layout

\begin_layout Standard
A set of axioms and proof rules defines a 
\series bold
formal logic
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
formal logic
\end_layout

\end_inset

.
 Mathematicians have studied many different logics that are useful for solving
 different problems.
 We are now looking for a specific formal logic that gives correct answers
 when reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fn:Bornat-proof-book"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bornat
\end_layout

\end_inset

For an overview and more details about that logic and the necessary proof
 techniques, see the book by R.
\begin_inset space ~
\end_inset

Bornat, 
\begin_inset Quotes eld
\end_inset

Proof and disproof in formal logic: an introduction for programmers
\begin_inset Quotes erd
\end_inset

.
 An early draft version of that book is available at 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://homepages.phonecoop.coop/randj/richard/books/ProofandDisproof.pdf"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The rules of proof for 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-rules-of-proof"

\end_inset


\end_layout

\begin_layout Standard
To derive the suitable logical axioms and proof rules systematically, let
 us examine what could make a sequent with 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions true.
\end_layout

\begin_layout Standard
A sequent 
\begin_inset Formula ${\cal CH}(A)\vdash{\cal CH}(X)$
\end_inset

 is true when a value of type 
\begin_inset Formula $X$
\end_inset

 can be computed by fully parametric code that may only use a given value
 of type 
\begin_inset Formula $A$
\end_inset

.
 To describe all possible ways of computing a value of type 
\begin_inset Formula $X$
\end_inset

, we need to enumerate all possible ways of 
\emph on
writing code
\emph default
 for a fully parametric function body.
 The requirement of full parametricity means that we are not allowed to
 use any specific types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, any concrete values such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, or any library functions that work with specific (non-parametric) types.
 We are only allowed to work with values of unknown types described by the
 given type parameters.
 However, we are permitted to use fully parametric types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
In fact, we can enumerate all the allowed constructions that may be used
 by fully parametric code implementing a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition.
 There are 
\emph on
eight
\emph default
 code constructions
\begin_inset Index idx
status open

\begin_layout Plain Layout
eight code constructions
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code constructions
\end_layout

\end_inset

 as illustrated by this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B, ...](a: A, b: B): X = {   // Any given type signature.
\end_layout

\begin_layout Plain Layout

  val x1: Unit = ()                   // 1) Use a value of type Unit.
\end_layout

\begin_layout Plain Layout

  val x2: A = a                       // 2) Use a given argument value.
\end_layout

\begin_layout Plain Layout

  val x3 = { x: A => b }              // 3) Create a function.
\end_layout

\begin_layout Plain Layout

  val x4: D = x3(x2)                  // 4) Use a function.
\end_layout

\begin_layout Plain Layout

  val x5: (A, B) = (a, b)             // 5) Create a tuple.
\end_layout

\begin_layout Plain Layout

  val x6: B = x5._2                   // 6) Use a tuple.
\end_layout

\begin_layout Plain Layout

  val x7: Either[A, B] = Right(x6)    // 7) Create values of a disjunctive
 type.
\end_layout

\begin_layout Plain Layout

  val x8 = x7 match { ...
 }           // 8) Use values of a disjunctive type.
\end_layout

\begin_layout Plain Layout

}     // 9) Call f() itself recursively.
 Not included here because recursion is not supported by CH-propositions.
\end_layout

\end_inset

The proposition 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

 is true if we can create a sequence of computed values such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x2
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xN
\end_layout

\end_inset

, each using one of these eight code constructs, with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xN
\end_layout

\end_inset

 having type 
\begin_inset Formula $X$
\end_inset

.
 
\end_layout

\begin_layout Standard
So, each of the eight code constructs will give a proof rule in the logic.
\end_layout

\begin_layout Standard
It is important that there are only a finite number of allowed code construction
s.
 This defines rigorously the concept of 
\begin_inset Quotes eld
\end_inset

fully parametric code
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code|textit
\end_layout

\end_inset

 and allows us to 
\emph on
prove
\emph default
 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
\end_layout

\begin_layout Standard
Reasoning about proof rules is easier with a compact notation.
 To obtain that notation, we first need to translate the eight code constructs
 into the notation of sequents.
 A proof of a sequent, e.g., 
\begin_inset Formula $\mathcal{CH}(A)\vdash\mathcal{CH}(X)$
\end_inset

, will consist of applying some of those proof rules.
 We will then combine the code constructs corresponding to each rule and
 obtain some code that computes a value of type 
\begin_inset Formula $X$
\end_inset

 using an argument of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
Conversely, any fully parametric (and non-recursive) code computing a value
 of type 
\begin_inset Formula $X$
\end_inset

 must be a combination of some of the eight code constructs
\begin_inset Index idx
status open

\begin_layout Plain Layout
eight code constructions
\end_layout

\end_inset

.
 That code combination can be translated into a combination of logic rules,
 which will produce a proof of the proposition 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

.
\end_layout

\begin_layout Standard
In this way, we will get a correspondence between fully parametric programs
 and proofs of sequents.
 This is the second part of the Curry-Howard correspondence.
\end_layout

\begin_layout Standard
In the following text, we will need to write 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-CH-proposition-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as sequents such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 As we have seen, 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions involving complicated type expressions can be always rewritten
 via 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions for individual type parameters (
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

, etc.).
 So, we will only need sequents involving such 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions.
 For brevity, we denote 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

, 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

, etc.
 We will use the letter 
\begin_inset Formula $\Gamma$
\end_inset

 to stand for a set of premises and write a shorter formula 
\begin_inset Formula $\Gamma\vdash\alpha$
\end_inset

 instead of the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
With these notations, we list the rules for proving 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions and the corresponding code:
\end_layout

\begin_layout Paragraph
1) Use the 
\family typewriter
Unit
\family default
 value
\end_layout

\begin_layout Standard
At any place in the code, we may write the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 This expression corresponds to a proof of the proposition 
\begin_inset Formula ${\cal CH}(\bbnum 1)$
\end_inset

 with any set 
\begin_inset Formula $\Gamma$
\end_inset

 of premises (even with an empty set of premises).
 So, the sequent 
\begin_inset Formula $\Gamma\vdash{\cal CH}(\bbnum 1)$
\end_inset

 is always true.
 The code corresponding to the proof of this sequent is an expression that
 creates a value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type:
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma\vdash{\cal CH}(\bbnum 1)\big)=1\quad,
\]

\end_inset

where we denoted by 
\begin_inset Formula $1$
\end_inset

 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In formal logic, a sequent that is always true, such as our 
\begin_inset Formula $\Gamma\vdash{\cal CH}(\bbnum 1)$
\end_inset

, is called an 
\series bold
axiom
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
logical axiom
\end_layout

\end_inset

 and is written in the following notation:
\begin_inset Formula 
\[
\frac{}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{create unit})\quad\quad.
\]

\end_inset

The 
\begin_inset Quotes eld
\end_inset

fraction with a label
\begin_inset Quotes erd
\end_inset

 represents a proof rule.
 The denominator of the fraction is the target sequent that we need to prove.
 The numerator of the fraction can have zero or more other sequents that
 need to be proved before the target sequent can be proved.
 In this case, the set of previous sequents is empty: the target sequent
 is an axiom and so requires no previous sequents for its proof.
 The label 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create unit}$
\end_inset


\begin_inset Quotes erd
\end_inset

 is an arbitrary name used to refer to the rule.
\end_layout

\begin_layout Paragraph
2) Use a given value
\end_layout

\begin_layout Standard
At any place within the code of a fully parametric function, we may use
 one of the function's arguments, say 
\begin_inset Formula $x^{:A}$
\end_inset

.
 If some argument has type 
\begin_inset Formula $A$
\end_inset

, it means that we already have a value of type 
\begin_inset Formula $A$
\end_inset

.
 So, the corresponding proposition, 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

, belongs to the set of premises of the sequent we are trying to prove.
 To indicate this, we write the set of premises as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\Gamma,\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The code construct 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 computes a value of type 
\begin_inset Formula $A$
\end_inset

, i.e., shows that 
\begin_inset Formula $\alpha$
\end_inset

 is true with premises 
\begin_inset Formula $\Gamma,\alpha$
\end_inset

.
 This is expressed by the sequent 
\begin_inset Formula $\Gamma,\alpha\vdash\alpha$
\end_inset

.
 The proof code for this sequent is an expression that just returns the
 given value (which we denoted by 
\begin_inset Formula $x^{:A}$
\end_inset

):
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma,\alpha\vdash\alpha\big)_{\text{given }x^{:A}}=x\quad.
\]

\end_inset

This sequent is an axiom since its proof requires no previous sequents;
 a value of type 
\begin_inset Formula $A$
\end_inset

 is already given in the premises.
 We denote this axiom by:
\begin_inset Formula 
\[
\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use value})\quad\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
3) Create a function
\end_layout

\begin_layout Standard
At any place in the code, we may compute a nameless function of type, say,
 
\begin_inset Formula $A\rightarrow B$
\end_inset

, by writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:A) => expr
\end_layout

\end_inset

 as long as a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 of type 
\begin_inset Formula $B$
\end_inset

 can be computed in the inner scope of the function.
 The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 is also required to be fully parametric; it may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and/or other values visible in that scope.
 So, we now need to answer the question of whether a fully parametric function
 can compute a value of type 
\begin_inset Formula $B$
\end_inset

, given an argument of type 
\begin_inset Formula $A$
\end_inset

 as well as all other arguments previously given to the parent function.
 This question is answered by a sequent whose premises contain one more
 proposition, 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, in addition to all previously available premises.
 Translating this into the language of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions, we find that we will prove the sequent:
\begin_inset Formula 
\[
\Gamma\vdash{\cal CH}(A\rightarrow B)\quad=\quad\Gamma\vdash{\cal CH}(A)\Rightarrow{\cal CH}(B)\quad=\quad\Gamma\vdash\alpha\Rightarrow\beta
\]

\end_inset

if we can prove the sequent 
\begin_inset Formula $\Gamma,{\cal CH}(A)\vdash{\cal CH}(B)=\Gamma,\alpha\vdash\beta$
\end_inset

.
 In the notation of formal logic, this is a 
\series bold
derivation rule
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
derivation rule
\end_layout

\end_inset

 (rather than an axiom) and is written as:
\begin_inset Formula 
\[
\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})\quad\quad.
\]

\end_inset

The 
\series bold
turnstile
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
0@
\begin_inset Formula $\vdash$
\end_inset

 (turnstile) symbol
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
turnstile (
\begin_inset Formula $\vdash$
\end_inset

) symbol
\end_layout

\end_inset

 symbol (
\begin_inset Formula $\vdash$
\end_inset

) groups weaker than other operators.
 So, we can write sequents such as 
\begin_inset Formula $(\Gamma,\alpha)\vdash(\beta\Rightarrow\gamma)$
\end_inset

 with fewer parentheses: 
\begin_inset Formula $\Gamma,\alpha\vdash\beta\Rightarrow\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
What code corresponds to the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 rule? The proof of 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

 depends on a proof of another sequent.
 So, the corresponding code must be a 
\emph on
function
\emph default
 that takes a proof of the previous sequent as an argument and returns a
 proof of the new sequent.
 We call that function a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence!proof transformer
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
proof transformer
\end_layout

\end_inset


\series bold
proof transformer
\series default
.
\end_layout

\begin_layout Standard
By the CH correspondence, a proof of a sequent corresponds to a code expression
 of the type given by the goal of the sequent.
 That expression may use arguments of types corresponding to the premises
 of the sequent.
 So, a proof of the sequent 
\begin_inset Formula $\Gamma,\alpha\vdash\beta$
\end_inset

 is an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exprB
\end_layout

\end_inset

 of type 
\begin_inset Formula $B$
\end_inset

 that may use a given value of type 
\begin_inset Formula $A$
\end_inset

 as well as any other arguments given previously.
 Then we can write the proof code for the sequent 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

 as the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: A) => exprB
\end_layout

\end_inset

.
 This function has type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 and requires us to already have a suitable expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exprB
\end_layout

\end_inset

.
 This exactly corresponds to the proof rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 That rule's proof transformer is:
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma\vdash\alpha\Rightarrow\beta\big)=x^{:A}\rightarrow\text{Proof}\,\big(\Gamma,\alpha\vdash\beta\big)_{\text{given }x^{:A}}\quad.
\]

\end_inset

Here, the subscript 
\begin_inset Quotes eld
\end_inset

given 
\begin_inset Formula $x^{:A}$
\end_inset


\begin_inset Quotes erd
\end_inset

 indicates that the value 
\begin_inset Formula $x^{:A}$
\end_inset

 must come from the premises.
 (In this case, the set of premises is 
\begin_inset Formula $\Gamma,\alpha$
\end_inset

 and so the proposition 
\begin_inset Formula $\alpha$
\end_inset

 must have been already proved.
 The proof of 
\begin_inset Formula $\alpha$
\end_inset

 will give a value 
\begin_inset Formula $x^{:A}$
\end_inset

.)
\end_layout

\begin_layout Paragraph
4) Use a function
\end_layout

\begin_layout Standard
At any place in the code, we may apply an already defined function of type
 
\begin_inset Formula $A\rightarrow B$
\end_inset

 to an already computed value of type 
\begin_inset Formula $A$
\end_inset

.
 The result will be a value of type 
\begin_inset Formula $B$
\end_inset

.
 This corresponds to assuming 
\begin_inset Formula ${\cal CH}(A\rightarrow B)$
\end_inset

 and 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, and then deriving 
\begin_inset Formula ${\cal CH}(B)$
\end_inset

.
 The notation for this proof rule is:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})\quad\quad.
\]

\end_inset

The code corresponding to this proof rule takes previously computed values
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f:A => B
\end_layout

\end_inset

, and writes the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 This can be written as a function application:
\begin_inset Formula 
\[
\text{Proof}\,(\Gamma\vdash\beta)=\text{Proof}\left(\Gamma\vdash\alpha\Rightarrow\beta\right)(\text{Proof}\,(\Gamma\vdash\alpha))\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
5) Create a tuple
\end_layout

\begin_layout Standard
If we have already computed some values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

, we may write the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

 and so compute a value of the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

.
 The proof rule is:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})\quad\quad.
\]

\end_inset

Writing 
\begin_inset Formula $a\times b$
\end_inset

 to mean the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

, we can write the corresponding code expression as:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)=\text{Proof}\left(\Gamma\vdash\alpha\right)\times\text{Proof}\left(\Gamma\vdash\beta\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
This rule describes creating a tuple of 
\begin_inset Formula $2$
\end_inset

 values.
 A larger tuple, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(w, x, y, z)
\end_layout

\end_inset

, can be expressed via nested pairs, e.g., as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(w, (x, (y, z)))
\end_layout

\end_inset

.
 So, it suffices to have a derivation rule for creating pairs.
 That rule allows us to express the rules for creating all larger tuples,
 and so we do not need to define separate rules for, say, 
\begin_inset Formula $\Gamma\vdash\alpha\wedge\beta\wedge\gamma$
\end_inset

.
\end_layout

\begin_layout Paragraph
6) Use a tuple
\end_layout

\begin_layout Standard
If we already have a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t:(A,B)
\end_layout

\end_inset

 of a tuple type 
\begin_inset Formula $A\times B$
\end_inset

, we can extract one of the parts of the tuple and obtain a value of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 or a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 The code is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t._2
\end_layout

\end_inset

 respectively, and the corresponding sequent proof rules are:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)\quad\quad,\quad\quad\quad\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\beta}\quad(\text{use tuple-}2)\quad\quad.
\]

\end_inset

The proof code can be written as:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\alpha\right)=\pi_{1}\left(\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)\right)\quad,\quad\text{Proof}\left(\Gamma\vdash\beta\right)=\pi_{2}\left(\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)\right)\quad,
\]

\end_inset

where we introduced the notation 
\begin_inset Formula $\pi_{1}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}$
\end_inset

 to mean the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_._2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Since all tuples can be expressed through pairs, it is sufficient to have
 proof rules for pairs.
\end_layout

\begin_layout Paragraph
7) Create a disjunctive value
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 corresponding to the disjunction 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 can be used to define any other disjunctive type; e.g., a disjunctive type
 with three parts can be expressed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Either[B, C]]
\end_layout

\end_inset

.
 So, it suffices to have proof rules for a disjunction of 
\emph on
two
\emph default
 propositions.
\end_layout

\begin_layout Standard
There are two ways of creating a value of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

: the code expressions are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x: A)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y: B)
\end_layout

\end_inset

.
 The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: B
\end_layout

\end_inset

 must have been computed previously (and correspond to previously proved
 sequents).
 So, the sequent proof rules are:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Left})\quad\quad\quad\quad\quad\frac{\Gamma\vdash\beta}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create Right})\quad\quad.
\]

\end_inset

The corresponding proof transformers can be written using the case class
 names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 as:
\begin_inset Formula 
\begin{align*}
\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right) & =\text{Left}\,(\text{Proof}\left(\Gamma\vdash\alpha\right))\quad,\\
\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right) & =\text{Right}\,(\text{Proof}\left(\Gamma\vdash\beta\right))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
8) Use a disjunctive value
\end_layout

\begin_layout Standard
Pattern matching is the basic way of using a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: C = (e: Either[A, B]) match {
\end_layout

\begin_layout Plain Layout

  case Left(x: A)    => expr1(x)
\end_layout

\begin_layout Plain Layout

  case Right(y: B)   => expr2(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr1(x)
\end_layout

\end_inset

 is an expression of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

C
\end_layout

\end_inset

 computed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 and any previously computed values.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr2(y)
\end_layout

\end_inset

 is computed using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: B
\end_layout

\end_inset

 and previous values.
 The values used in computation correspond to the premises of a sequent.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr1(x)
\end_layout

\end_inset

 represents a proof of a sequent with an additional premise of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Denoting 
\begin_inset Formula $\gamma\triangleq{\cal CH}(C)$
\end_inset

, we write that sequent as: 
\begin_inset Formula $\Gamma,\alpha\vdash\gamma$
\end_inset

.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr2(y)
\end_layout

\end_inset

 is a proof of the sequent 
\begin_inset Formula $\Gamma,\beta\vdash\gamma$
\end_inset

.
 We can compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

result
\end_layout

\end_inset

 only if we can compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

e
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

expr1
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

expr2
\end_layout

\end_inset

.
 So, the proof rule is: 
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use Either})\quad\quad.
\]

\end_inset

The corresponding code can be written as:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\gamma\right)=\text{Proof}\left(\Gamma\vdash\alpha\vee\beta\right)\text{ match }\begin{cases}
\text{case }a^{:A}\rightarrow & \text{Proof}\left(\Gamma,\alpha\vdash\gamma\right)_{\text{given }a}\\
\text{case }b^{:B}\rightarrow & \text{Proof}\left(\Gamma,\beta\vdash\gamma\right)_{\text{given }b}
\end{cases}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We found eight proof rules shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These rules define the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
intuitionistic propositional logic
\end_layout

\end_inset

intuitionistic propositional logic
\series default
, also called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
constructive logic
\end_layout

\end_inset

constructive propositional logic
\series default
.
 We will call this logic 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Quotes erd
\end_inset

 for short.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "75col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset Formula 
\begin{align*}
\text{axioms}:\quad & \frac{~}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{use unit})\quad\quad\quad\quad\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use value})\\
\text{derivation rules}:\quad & \frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})\\
 & \frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})\\
 & \frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})\\
 & \frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)\quad\quad\quad\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\beta}\quad(\text{use tuple-}2)\\
 & \frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create \texttt{Left}})\quad\quad\quad\frac{\Gamma\vdash\beta}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create \texttt{Right}})\\
 & \frac{\Gamma\vdash\alpha\vee\beta\quad\quad\Gamma,\alpha\vdash\gamma\quad\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use \texttt{Either}})
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof rules for the constructive logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Proof-rules-for-constructive-logic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples: Deriving code from proofs of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example:-Proving-a-ch-proposition"

\end_inset


\end_layout

\begin_layout Standard
Using the proof rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can (in principle) derive code from type signatures of fully parametric
 functions.
 We will now show two simple examples and we perform such derivations step
 by step.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-derive-code-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-derive-code-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Derive the code for the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def d[X]: X => (X, X)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
First, we formulate the task as proving the proposition 
\begin_inset Quotes eld
\end_inset

For any type 
\begin_inset Formula $X$
\end_inset

, we can have a value of type 
\begin_inset Formula $X\rightarrow X\times X$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 This corresponds to the proposition 
\begin_inset Formula ${\cal CH}(\forall X.\,X\rightarrow X\times X)$
\end_inset

.
 That proposition will be the goal of a sequent.
 The function has no arguments, so there are no premises for the sequent.
 We denote an empty set of premises by the symbol 
\begin_inset Formula $\emptyset$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
0@
\begin_inset Formula $\emptyset$
\end_inset

 (empty set)
\end_layout

\end_inset

.
 So, the sequent is written as:
\begin_inset Formula 
\[
\emptyset\vdash{\cal CH}(\forall X.\,X\rightarrow X\times X)\quad.
\]

\end_inset

We denote 
\begin_inset Formula $\chi\triangleq{\cal CH}(X)$
\end_inset

 and rewrite this sequent using the rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The result is a sequent involving just 
\begin_inset Formula $\chi$
\end_inset

:
\begin_inset Formula 
\[
\forall\chi.\,\emptyset\vdash\chi\Rightarrow\chi\wedge\chi\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Next, we look for a proof of this sequent.
 For brevity, we will omit the quantifier 
\begin_inset Formula $\forall\chi$
\end_inset

 since it will be present in front of every sequent.
\end_layout

\begin_layout Standard
We search through the proof rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

, looking for 
\begin_inset Quotes eld
\end_inset

denominators
\begin_inset Quotes erd
\end_inset

 that match our current sequent.
 If we find such a rule, we will apply that rule to our sequent.
 Then we will need to prove the sequents in the rule's 
\begin_inset Quotes eld
\end_inset

numerator
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Beginning with 
\begin_inset Formula $\emptyset\vdash\chi\Rightarrow\chi\wedge\chi$
\end_inset

, we find a match with the rule 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula 
\[
\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})
\]

\end_inset

The denominator of that rule is 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

.
 This pattern will match our sequent (
\begin_inset Formula $\emptyset\vdash\chi\Rightarrow\chi\wedge\chi$
\end_inset

) if we set 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

, 
\begin_inset Formula $\alpha=\chi$
\end_inset

, and 
\begin_inset Formula $\beta=\chi\wedge\chi$
\end_inset

.
 So, we are allowed to apply the rule 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 with these assignments.
\end_layout

\begin_layout Standard
After these assignments, the rule 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 becomes:
\begin_inset Formula 
\[
\frac{\emptyset,\chi\vdash\chi\wedge\chi}{\emptyset\vdash\chi\Rightarrow\chi\wedge\chi}\quad.
\]

\end_inset

Now the rule says: we will prove the denominator (
\begin_inset Formula $\emptyset\vdash\chi\Rightarrow\chi\wedge\chi$
\end_inset

) if we first prove the numerator (
\begin_inset Formula $\emptyset,\chi\vdash\chi\wedge\chi$
\end_inset

).
\end_layout

\begin_layout Standard
The set of premises 
\begin_inset Formula $\emptyset,\chi$
\end_inset

 is the union of an empty set and the set having a single premise 
\begin_inset Formula $\chi$
\end_inset

.
 So, we can write the last sequent also as 
\begin_inset Formula $\chi\vdash\chi\wedge\chi$
\end_inset

 if we like.
\end_layout

\begin_layout Standard
To prove that sequent, we again look for a rule whose denominator matches
 our sequent.
 That rule is 
\begin_inset Quotes eld
\end_inset

create tuple
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\frac{\Gamma\vdash\alpha\quad\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})
\]

\end_inset

The denominator (
\begin_inset Formula $\Gamma\vdash\alpha\wedge\beta$
\end_inset

) will match our sequent (
\begin_inset Formula $\chi\vdash\chi\wedge\chi$
\end_inset

) if we assign 
\begin_inset Formula $\Gamma=\chi$
\end_inset

, 
\begin_inset Formula $\alpha=\chi$
\end_inset

, 
\begin_inset Formula $\beta=\chi$
\end_inset

.
 With these assignments, the rule says that we need to prove two sequents
 (
\begin_inset Formula $\Gamma\vdash\alpha$
\end_inset

 and 
\begin_inset Formula $\Gamma\vdash\beta$
\end_inset

), which are in fact the same sequent (
\begin_inset Formula $\chi\vdash\chi$
\end_inset

).
\end_layout

\begin_layout Standard
To prove that sequent, we apply the axiom 
\begin_inset Quotes eld
\end_inset

use value
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\frac{}{\Gamma,\alpha\vdash\alpha}\quad.
\]

\end_inset

The denominator of that axiom matches 
\begin_inset Formula $\emptyset,\chi\vdash\chi$
\end_inset

 if we set 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

 and 
\begin_inset Formula $\alpha=\chi$
\end_inset

.
 Then the axiom 
\begin_inset Quotes eld
\end_inset

use value
\begin_inset Quotes erd
\end_inset

 becomes:
\begin_inset Formula 
\[
\frac{}{\emptyset,\chi\vdash\chi}\quad.
\]

\end_inset

This axiom says that the sequent 
\begin_inset Formula $\emptyset,\chi\vdash\chi$
\end_inset

 (or equivalently 
\begin_inset Formula $\chi\vdash\chi$
\end_inset

) is already true with nothing more needed to prove.
 So, the proof is finished.
\end_layout

\begin_layout Standard
We may visualize the proof as a tree shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The tree starts with the initial sequent and applies rules that require
 us to prove other sequents.
 The tree stops with axioms in leaf positions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Preview

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ .$
\backslash
emptyset
\backslash
vdash
\backslash
chi
\backslash
Rightarrow
\backslash
chi
\backslash
wedge
\backslash
chi$ [ .{rule ``$
\backslash
text{create function}$''} [ .$
\backslash
chi
\backslash
vdash
\backslash
chi
\backslash
wedge
\backslash
chi$ [ .{rule ``$
\backslash
text{create tuple}$''} [ .$
\backslash
chi
\backslash
vdash
\backslash
chi$ [ .{axiom ``$
\backslash
text{use value}$''}   ] ] [ .$
\backslash
chi
\backslash
vdash
\backslash
chi$ {axiom ``$
\backslash
text{use value}$''} ] ] ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof tree for the sequent 
\begin_inset Formula $\emptyset\vdash\chi\Rightarrow\chi\wedge\chi$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:Proof-of-the-sequent-example-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we need to extract code from the proof.
 We begin with the leaves of the tree and trace back the proof towards the
 top.
 The axiom 
\begin_inset Quotes eld
\end_inset

use value
\begin_inset Quotes erd
\end_inset

 has the proof code 
\begin_inset Formula $x$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 is given in the premises:
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma,\alpha\vdash\alpha\big)_{\text{given }x^{:A}}=x\quad.
\]

\end_inset

The proof used this axiom twice with 
\begin_inset Formula $\alpha=\chi$
\end_inset

.
 Recall that 
\begin_inset Formula $\chi$
\end_inset

 denotes 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

, and so the value 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $X$
\end_inset

.
 So, we write:
\begin_inset Formula 
\[
\text{Proof}\,\big(\chi\vdash\chi\big)_{\text{given }x^{:X}}=x\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The previous rule used by the proof was 
\begin_inset Quotes eld
\end_inset

create tuple
\begin_inset Quotes erd
\end_inset

.
 Its proof code is:
\begin_inset Formula 
\[
\text{Proof}\left(\Gamma\vdash\alpha\wedge\beta\right)=\text{Proof}\left(\Gamma\vdash\alpha\right)\times\text{Proof}\left(\Gamma\vdash\beta\right)\quad.
\]

\end_inset

That rule was used with 
\begin_inset Formula $\Gamma=\chi$
\end_inset

, 
\begin_inset Formula $\alpha=\chi$
\end_inset

, and 
\begin_inset Formula $\beta=\chi$
\end_inset

.
 So, the proof code becomes:
\begin_inset Formula 
\begin{align*}
\text{Proof}\left(\chi\vdash\chi\wedge\chi\right)_{\text{given }x^{:X}} & =\text{Proof}\left(\chi\vdash\chi\right)_{\text{given }x^{:X}}\times\text{Proof}\left(\chi\vdash\chi\right)_{\text{given }x^{:X}}\\
 & =x\times x\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Finally, the first rule 
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

 has the proof code:
\begin_inset Formula 
\[
\text{Proof}\,\big(\Gamma\vdash\alpha\Rightarrow\beta\big)=x^{:A}\rightarrow\text{Proof}\,\big(\Gamma,\alpha\vdash\beta\big)_{\text{given }x^{:A}}\quad.
\]

\end_inset

That rule was used with 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

, 
\begin_inset Formula $A=X$
\end_inset

, 
\begin_inset Formula $\alpha=\chi$
\end_inset

, and 
\begin_inset Formula $\beta=\chi\wedge\chi$
\end_inset

.
 Using these assignments, we obtain the code:
\begin_inset Formula 
\[
\text{Proof}\,\big(\emptyset\vdash\chi\Rightarrow\chi\wedge\chi\big)=x^{:X}\rightarrow\text{Proof}\,\big(\chi\vdash\chi\times\chi\big)_{\text{given }x^{:X}}=x^{:X}\rightarrow x\times x\quad.
\]

\end_inset

In Scala, this code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def d[X]: X => (X, X) = (x: X) => (x, x) 
\end_layout

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-derive-code-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-derive-code-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Derive the code for the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def s[A, B]: ((A => A) => B) => B
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The task is to compute a value of type 
\begin_inset Formula $((A\rightarrow A)\rightarrow B)\rightarrow B$
\end_inset

 for arbitrary types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 without any arguments.
 This is written as the sequent: 
\begin_inset Formula 
\[
\emptyset\vdash{\cal CH}\big(\forall(A,B).\,((A\rightarrow A)\rightarrow B)\rightarrow B\big)\quad.
\]

\end_inset

Denote 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

, and rewrite the sequent using the rules of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to obtain a logic formula that involves just 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).~\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta\quad.\label{eq:ch-example-sequent-2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The next step is to prove the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For brevity, we will omit the quantifier 
\begin_inset Formula $\forall(\alpha,\beta)$
\end_inset

 since it will be present in front of every sequent.
\end_layout

\begin_layout Standard
Begin by looking for a proof rule whose 
\begin_inset Quotes eld
\end_inset

denominator
\begin_inset Quotes erd
\end_inset

 has a sequent similar to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), i.e., has an implication (
\begin_inset Formula $p\Rightarrow q$
\end_inset

) in the goal.
 We have only one rule with the 
\begin_inset Quotes eld
\end_inset

denominator
\begin_inset Quotes erd
\end_inset

 of the form 
\begin_inset Formula $\Gamma\vdash(p\Rightarrow q$
\end_inset

); this is the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

, which we will rewrite as:
\begin_inset Formula 
\[
\frac{\Gamma,p\vdash q}{\Gamma\vdash p\Rightarrow q}\quad(\text{create function})
\]

\end_inset

To match the denominator, we use this rule with the assignments 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

, 
\begin_inset Formula $p\triangleq(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

 and 
\begin_inset Formula $q\triangleq\beta$
\end_inset

: 
\begin_inset Formula 
\[
\frac{(\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta}{\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta}\quad\text{(create function)}
\]

\end_inset

The rule's numerator now requires us to prove the sequent 
\begin_inset Formula $(\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta$
\end_inset

.
 We may write that sequent as as 
\begin_inset Formula $\gamma\vdash\beta$
\end_inset

, where we defined 
\begin_inset Formula $\gamma\triangleq(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

 for brevity.
\end_layout

\begin_layout Standard
So, the next step is to prove the sequent 
\begin_inset Formula $\gamma\vdash\beta$
\end_inset

.
 The premise (
\begin_inset Formula $\gamma$
\end_inset

) contains an implication.
 But there is no proof rule whose denominator has a 
\emph on
premise
\emph default
 in the form of an implication (
\begin_inset Formula $p\Rightarrow q$
\end_inset

).
 Instead, we have the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 whose denominator contains an arbitrary sequent:
\begin_inset Formula 
\[
\frac{\Gamma\vdash p\quad\quad\Gamma\vdash p\Rightarrow q}{\Gamma\vdash q}\quad(\text{use function})
\]

\end_inset

This rule's denominator matches 
\begin_inset Formula $\gamma\vdash\beta$
\end_inset

 if we set 
\begin_inset Formula $\Gamma=\gamma$
\end_inset

 and 
\begin_inset Formula $q=\beta$
\end_inset

.
 But it is not clear how to choose 
\begin_inset Formula $p$
\end_inset

.
 After some trial and error, one finds that the proof will work if we set
 
\begin_inset Formula $p=(\alpha\Rightarrow\alpha)$
\end_inset

:
\begin_inset Formula 
\[
\frac{\gamma\vdash\alpha\Rightarrow\alpha\quad\quad\gamma\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta}{\gamma\vdash\beta}\quad\text{(use function)}
\]

\end_inset

This rule's numerator now requires us to prove two new sequents: 
\begin_inset Formula $\gamma\vdash\alpha\Rightarrow\alpha$
\end_inset

 and 
\begin_inset Formula $\gamma\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
 To prove the first of these sequents, apply the rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 like this:
\begin_inset Formula 
\[
\frac{\gamma,\alpha\vdash\alpha}{\gamma\vdash\alpha\Rightarrow\alpha}\quad\text{(create function)}
\]

\end_inset

The sequent in the numerator 
\begin_inset Formula $\gamma,\alpha\vdash\alpha$
\end_inset

 is proved directly by the axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use value}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The sequent 
\begin_inset Formula $\gamma\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

 is the same as 
\begin_inset Formula $\gamma\vdash\gamma$
\end_inset

 and is also proved by the axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use value}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The proof of the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is now complete and can be drawn as a tree (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The next step is to convert that proof to Scala code.
\end_layout

\begin_layout Standard
To do that, we combine the code expressions that correspond to each of the
 proof rules we used.
 We need to retrace the proof backwards, starting from the leaves of the
 tree and going towards the root.
 We will then combine the corresponding 
\begin_inset Formula $\text{Proof}\left(...\right)$
\end_inset

 code expressions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Preview

\begin_layout Standard

\size footnotesize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ .$
\backslash
emptyset
\backslash
vdash((
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta)
\backslash
Rightarrow
\backslash
beta $ [ .{rule ``$
\backslash
text{create function}$''} [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash
\backslash
beta$ [ .{rule ``$
\backslash
text{use function}$''} [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha$ [ .{rule ``$
\backslash
text{create function}$''} [ .$
\backslash
gamma,
\backslash
alpha
\backslash
vdash
\backslash
alpha$ {axiom ``$
\backslash
text{use value}$''} ] ] ] [ .$(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta
\backslash
vdash(
\backslash
alpha
\backslash
Rightarrow
\backslash
alpha)
\backslash
Rightarrow
\backslash
beta$ {axiom ``$
\backslash
text{use value}$''} ] ] ] ] ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof tree for sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset CommandInset label
LatexCommand label
name "fig:Proof-of-the-sequent-example-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Begin with the left-most leaf: 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use value}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 That rule gives the code 
\begin_inset Formula $x^{:A}$
\end_inset

:
\begin_inset Formula 
\[
\text{Proof}\left(\gamma,\alpha\vdash\alpha\right)_{\text{given }x^{:A}}=x^{:A}\quad.
\]

\end_inset

Here 
\begin_inset Quotes eld
\end_inset

given 
\begin_inset Formula $x^{:A}$
\end_inset


\begin_inset Quotes erd
\end_inset

 means that 
\begin_inset Formula $x^{:A}$
\end_inset

 must be a proof of the premise 
\begin_inset Formula $\alpha$
\end_inset

 in the sequent 
\begin_inset Formula $\gamma,\alpha\vdash\alpha$
\end_inset

 (recall that 
\begin_inset Formula $\alpha$
\end_inset

 denotes 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

, and so 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

).
 We need to use the same 
\begin_inset Formula $x^{:A}$
\end_inset

 when we write the code for the previous rule, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\text{Proof}\left(\gamma\vdash\alpha\Rightarrow\alpha\right)=\big(x^{:A}\rightarrow\text{Proof}\left(\gamma,\alpha\vdash\alpha\right)_{\text{given }x^{:A}}\big)=(x^{:A}\rightarrow x)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Note that in this code we are able to use a value 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

 even though no such value is given as an argument of our function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s[A, B]
\end_layout

\end_inset

.
 The reason is that the sequent 
\begin_inset Formula $\gamma,\alpha\vdash\alpha$
\end_inset

 has an extra premise 
\begin_inset Formula $\alpha$
\end_inset

 added to the set of premises only for this step of the proof.
 Once we are finished with this step, we again will not have any values
 of type 
\begin_inset Formula $A$
\end_inset

 available.
 In the code, this corresponds to the local scoping of the bound value 
\begin_inset Formula $x^{:A}$
\end_inset

 in the function 
\begin_inset Formula $x^{:A}\rightarrow x$
\end_inset

.
 
\end_layout

\begin_layout Standard
We continue tracing the proof tree bottom-up.
 The right-most leaf 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use value}$
\end_inset


\begin_inset Quotes erd
\end_inset

 corresponds to the code 
\begin_inset Formula $f^{:(A\rightarrow A)\rightarrow B}$
\end_inset

, where 
\begin_inset Formula $f$
\end_inset

 is the code corresponding to the premise 
\begin_inset Formula $\gamma=(\alpha\Rightarrow\alpha)\Rightarrow\beta$
\end_inset

.
 So, we can write:
\begin_inset Formula 
\[
\text{Proof}\left(\gamma\vdash\gamma\right)_{\text{given }f^{:(A\rightarrow A)\rightarrow B}}=f^{:(A\rightarrow A)\rightarrow B}\quad.
\]

\end_inset

The previous rule (
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

) combines the two preceding proofs:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\left((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta\right)_{\text{given }f^{:\left(A\rightarrow A\right)\rightarrow B}}\\
 & =\text{Proof}\,(\gamma\vdash\gamma)\left(\text{Proof}\,(\gamma\vdash\alpha\Rightarrow\alpha)\right)_{\text{given }f^{:\left(A\rightarrow A\right)\rightarrow B}}\\
 & =f(x^{:A}\rightarrow x)\quad.
\end{align*}

\end_inset

Going further backwards, we find that the rule applied before 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 was 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{create function}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 We need to provide the same 
\begin_inset Formula $f^{:\left(A\rightarrow A\right)\rightarrow B}$
\end_inset

 as in the premise above, and so we obtain the code:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\left(\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta\right)\\
 & =f^{:\left(A\rightarrow A\right)\rightarrow B}\rightarrow\text{Proof}\left((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta\right)_{\text{given }f^{:\left(A\rightarrow A\right)\rightarrow B}}\\
 & =f^{:\left(A\rightarrow A\right)\rightarrow B}\rightarrow f(x^{:A}\rightarrow x)\quad.
\end{align*}

\end_inset

This is the final code expression that implements the type 
\begin_inset Formula $((A\rightarrow A)\rightarrow B)\rightarrow B$
\end_inset

.
 In this way, we have systematically derived the code from the type signature
 of a function.
 That code can be written in Scala as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def s[A, B]: ((A => A) => B) => B = { (f : A => A) => f(x => x) }
\end_layout

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We found the proof tree in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by combining various proof rules that match our sequents.
 But we had to guess how to apply the 
\begin_inset Quotes eld
\end_inset

use function
\begin_inset Quotes erd
\end_inset

 rule: it was not obvious how to assign the rule's variable 
\begin_inset Formula $p$
\end_inset

.
 If we 
\emph on
somehow
\emph default
 find a proof tree for a sequent, we can derive the corresponding code (perform
 
\begin_inset Quotes eld
\end_inset

code inference
\begin_inset Quotes erd
\end_inset

 from type).
 As we have seen, choosing the proof rules from Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 requires guessing or trying different possibilities.
 
\end_layout

\begin_layout Standard
In other words, the rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 do not provide an algorithm for finding a proof tree automatically.
 It turns out that one can replace the rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by a different but equivalent set of derivation rules that 
\emph on
do
\emph default
 give an algorithm (called the 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
LJT algorithm
\end_layout

\end_inset

LJT algorithm
\begin_inset Quotes erd
\end_inset

, see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:The-LJT-algorithm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
 That algorithm either finds that the given formula cannot be proved, or
 it finds a proof and infers code that has the given type signature.
\end_layout

\begin_layout Standard
The library 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
curryhoward
\family default
 library
\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset


\family typewriter

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Chymyst/curryhoward"

\end_inset


\end_layout

\end_inset


\family default
 implements the LJT algorithm.
 Here are some examples of using this library for 
\begin_inset Index idx
status open

\begin_layout Plain Layout
code inference
\end_layout

\end_inset

code inference.
 We will run the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ammonite
\end_layout

\end_inset


\family typewriter

\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://ammonite.io/#Ammonite-Shell"

\end_inset


\end_layout

\end_inset


\family default
 shell to load the library more easily.
\end_layout

\begin_layout Standard
As a non-trivial (but artificial) example, consider the type signature:
\begin_inset Formula 
\[
\forall(A,B).\,\left(\left(\left(\left(A\rightarrow B\right)\rightarrow A\right)\rightarrow A\right)\rightarrow B\right)\rightarrow B\quad.
\]

\end_inset

It is not obvious whether a function with this type signature exists.
 The LJT algorithm can figure that out and derive the code automatically.
 The library does this via the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

implement
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ import $ivy.`io.chymyst::curryhoward:0.3.8`, io.chymyst.ch._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ def f[A, B]: ((((A => B) => A) => A) => B) => B  =  implement
\end_layout

\begin_layout Plain Layout

defined function f
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ println(f.lambdaTerm.prettyPrint)
\end_layout

\begin_layout Plain Layout

a => a (b => b (c => a (d => c)))
\end_layout

\end_inset

The code 
\begin_inset Formula $a\rightarrow a\left(b\rightarrow b\left(c\rightarrow a\left(d\rightarrow c\right)\right)\right)$
\end_inset

 was produced automatically for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 has been compiled and is ready to be used in any subsequent code.
\end_layout

\begin_layout Standard
A compile-time error occurs when no fully parametric function has the given
 type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def g[A, B]: ((A => B) => A) => A  =  implement
\end_layout

\begin_layout Plain Layout

cmd3.sc:1: type ((A => B) => A) => A cannot be implemented
\end_layout

\end_inset

The logical formula corresponding to this type signature is:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).\,\left(\left(\alpha\Rightarrow\beta\right)\Rightarrow\alpha\right)\Rightarrow\alpha\quad.\label{eq:ch-example-3-peirce-law}
\end{equation}

\end_inset

This formula is known as 
\series bold
Peirce's law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Peirce's law
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Peirce%27s_law"
target "https://en.wikipedia.org/wiki/Peirce%27s_law"
literal "false"

\end_inset


\end_layout

\end_inset

 and gives an example showing that the logic of types in functional programming
 languages is not Boolean (other examples are shown in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example:-Failure-of-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relationship-between-Boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Peirce's law is true in Boolean logic but does not hold in the constructive
 logic, i.e., it cannot be derived using the proof rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 If we try to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g[A, B]
\end_layout

\end_inset

 with the type signature shown above via fully parametric code, we will
 fail to write code that compiles without type errors.
 This is because no such code exists, â€” not because we are insufficiently
 clever.
 The LJT algorithm can 
\emph on
prove
\emph default
 that the given type signature cannot be implemented.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library will then print an error message, and compilation will fail.
\end_layout

\begin_layout Standard
As another example, let us verify that the type signature from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Motivation-and-outlook"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is not implementable:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def bad2[A, B, C](g: A => Either[B, C]): Either[A => B, A => C] = implement
\end_layout

\begin_layout Plain Layout

cmd4.sc:1: type (A => Either[B, C]) => Either[A => B, A => C] cannot be implement
ed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The LJT algorithm will sometimes find several inequivalent proofs of the
 same logic formula.
 In that case, each of the different proofs will be automatically translated
 into code.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library tries to select the code that has the least information loss, according
 to several heuristics.
 In many cases, the heuristics select the implementation that is most useful
 to the programmer.
\end_layout

\begin_layout Standard
The rules of constructive logic and the LJT algorithm define rigorously
 what it means to write code 
\begin_inset Quotes eld
\end_inset

guided by the types
\begin_inset Quotes erd
\end_inset

.
 However, in order to use the LJT algorithm well, a programmer needs to
 learn how to infer code from types by hand.
 We will practice doing that throughout the book.
\end_layout

\begin_layout Subsection
The LJT algorithm
\begin_inset CommandInset label
LatexCommand label
name "app:The-LJT-algorithm"

\end_inset


\end_layout

\begin_layout Standard
The LJT algorithm solves an important problem: namely, that the logic rules
 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 do not provide an algorithm for finding a proof for a given sequent.
 In the previous section, we saw an example showing that searching for a
 proof of a sequent via Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 sometimes requires guessing.
 To illustrate this difficulty on another example, let us try proving the
 sequent:
\begin_inset Formula 
\[
A,B\vee C\vdash(A\wedge B)\vee C\quad.
\]

\end_inset

We expect that this sequent is provable because we can write the corresponding
 Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B, C](a: A): Either[B, C] => Either[(A, B), C] = {
\end_layout

\begin_layout Plain Layout

  case Left(b)    => Left((a, b))
\end_layout

\begin_layout Plain Layout

  case Right(c)   => Right(c)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

How can we obtain a proof of this sequent via Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

? We could potentially apply the rules 
\begin_inset Quotes eld
\end_inset

create 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

create 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

use function
\begin_inset Quotes erd
\end_inset

.
 But we will get stuck at the next step, no matter what rule we choose.
 Let us see why:
\end_layout

\begin_layout Standard
To apply 
\begin_inset Quotes eld
\end_inset

create 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, we first need to prove the sequent 
\begin_inset Formula $A,B\vee C\vdash A\wedge B$
\end_inset

.
 But this sequent cannot be proved: we do not necessarily have values of
 both types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 if we are only given values of type 
\begin_inset Formula $A$
\end_inset

 and of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[B, C]
\end_layout

\end_inset

.
 To apply 
\begin_inset Quotes eld
\end_inset

create 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, we need to prove the sequent 
\begin_inset Formula $A,B\vee C\vdash C$
\end_inset

.
 Again, we find that this sequent cannot be proved.
 The next choice is the rule 
\begin_inset Quotes eld
\end_inset

use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 that matches any goal of the sequent as the proposition 
\begin_inset Formula $\gamma$
\end_inset

.
 But we are then required to choose two new propositions (
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

) such that we can prove 
\begin_inset Formula $A,B\vee C\vdash\alpha\vee\beta$
\end_inset

 as well as 
\begin_inset Formula $A,B\vee C,\alpha\vdash(A\wedge B)\vee C$
\end_inset

 and 
\begin_inset Formula $A,B\vee C,\beta\vdash(A\wedge B)\vee C$
\end_inset

.
 It is not clear how we should choose 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 in order to make progress with the proof.
 The remaining rule, 
\begin_inset Quotes eld
\end_inset

use function
\begin_inset Quotes erd
\end_inset

, similarly requires us to choose a new proposition 
\begin_inset Formula $\alpha$
\end_inset

 such that we can prove 
\begin_inset Formula $A,B\vee C\vdash\alpha$
\end_inset

 and 
\begin_inset Formula $A,B\vee C\vdash\alpha\Rightarrow((A\wedge B)\vee C)$
\end_inset

.
 The rules give us no guidance for choosing 
\begin_inset Formula $\alpha$
\end_inset

 appropriately.
\end_layout

\begin_layout Standard
The rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are not helpful for proof search because the rules 
\begin_inset Quotes eld
\end_inset

use function
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 require us to choose new unknown propositions and to prove sequents more
 complicated than the ones we had before.
 For instance, the rule 
\begin_inset Quotes eld
\end_inset

use function
\begin_inset Quotes erd
\end_inset

 gives a proof of 
\begin_inset Formula $\Gamma\vdash\beta$
\end_inset

 only if we first choose some other proposition 
\begin_inset Formula $\alpha$
\end_inset

 and prove the sequents 
\begin_inset Formula $\Gamma\vdash\alpha$
\end_inset

 and 
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

.
 The rule does not tell us how to choose the proposition 
\begin_inset Formula $\alpha$
\end_inset

 correctly.
 We need to guess the correct 
\begin_inset Formula $\alpha$
\end_inset

 by trial and error.
 Even after choosing 
\begin_inset Formula $\alpha$
\end_inset

 in some way, we will have to prove a more complicated sequent (
\begin_inset Formula $\Gamma\vdash\alpha\Rightarrow\beta$
\end_inset

).
 It is not guaranteed that we are getting closer to finding the proof of
 the initial sequent (
\begin_inset Formula $\Gamma\vdash\beta$
\end_inset

).
 
\end_layout

\begin_layout Standard
It is far from obvious how to overcome that difficulty.
 Mathematicians have studied the constructive logic for more than 60 years,
 trying to replace the rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by a different but equivalent set of derivation rules that require no guessing
 when looking for a proof.
 The first partial success came in 1935 with an algorithm called 
\begin_inset Quotes eld
\end_inset

LJ
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Sequent_calculus#Overview"
literal "false"

\end_inset


\end_layout

\end_inset

 The LJ algorithm works in many cases but still has a significant problem:
 one of its derivation rules may be applied infinitely many times, leading
 to an infinite loop.
 So, the LJ algorithm is not guaranteed to terminate without some heuristics
 for avoiding infinite loops.
 This problem is solved by a modification of the LJ algorithm, called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
LJT algorithm
\end_layout

\end_inset

LJT, first formulated in 1992.
\begin_inset Foot
status open

\begin_layout Plain Layout
An often cited paper by R.
\begin_inset space ~
\end_inset

Dyckhoff
\begin_inset Index idx
status open

\begin_layout Plain Layout
Roy Dyckhoff
\end_layout

\end_inset

 is 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://philpapers.org/rec/DYCCSC"
literal "false"

\end_inset


\family default
.
 For the history of that research, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://research-repository.st-andrews.ac.uk/handle/10023/8824"
literal "false"

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
We will first present the LJ algorithm.
 Although that algorithm does not guarantee termination, it is simpler to
 understand and to apply by hand.
 Then we will show how to modify the LJ algorithm in order to obtain the
 always-terminating LJT algorithm.
\end_layout

\begin_layout Subsubsection*
The LJ algorithm
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rules-of-the-LJ-algorithm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the LJ algorithm's axioms and derivation rules.
 Each rule says that the bottom sequent will be proved if proofs are given
 for sequent(s) at the top.
 For each possible sub-expression (conjunction 
\begin_inset Formula $X\wedge Y$
\end_inset

, disjunction 
\begin_inset Formula $X\vee Y$
\end_inset

, and implication 
\begin_inset Formula $X\Rightarrow Y$
\end_inset

) there is one rule where that sub-expression is a premise (at 
\begin_inset Quotes eld
\end_inset

left
\begin_inset Quotes erd
\end_inset

) and one rule where that sub-expression is the goal (at 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

).
 Those sub-expressions are shown in blue in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rules-of-the-LJ-algorithm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to help us look for a proof.
 To find out which rules apply, we match some part of the sequent with a
 blue sub-expression.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "70line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\frac{}{\Gamma,X\vdash{\color{blue}X}}~(\text{Id})\qquad & \qquad\frac{}{\Gamma\vdash{\color{blue}\top}}~(\text{True})\\
\frac{\Gamma,A\Rightarrow B\vdash A\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\Rightarrow B}\vdash C}~(\text{Left}\Rightarrow)\qquad & \qquad\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\Rightarrow B}}~(\text{Right}\Rightarrow)\\
\frac{\Gamma,A_{i}\vdash C}{\Gamma,{\color{blue}A_{1}\wedge A_{2}}\vdash C}~(\text{Left}\wedge_{i})\qquad & \qquad\frac{\Gamma\vdash A\quad\quad\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\wedge B}}~(\text{Right}\wedge)\\
\frac{\Gamma,A\vdash C\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\vee B}\vdash C}~(\text{Left}\vee)\qquad & \qquad\frac{\Gamma\vdash A_{i}}{\Gamma\vdash{\color{blue}A_{1}\vee A_{2}}}~(\text{Right}\vee_{i})
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Axioms and derivation rules of the LJ algorithm.
 Each of the rules 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\wedge_{i}$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Right}\vee_{i}$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 have two versions, with 
\begin_inset Formula $i=1$
\end_inset

 or 
\begin_inset Formula $i=2$
\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Rules-of-the-LJ-algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It turns out that the rules in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rules-of-the-LJ-algorithm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are 
\emph on
equivalent
\emph default
 to the rules in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The proof is beyond the scope of this book.
 We only remark that this equivalence is far from obvious.
 To prove it, one needs to demonstrate that any sequent derived through
 the first set of rules is also derivable through the second set, and vice
 versa.
\end_layout

\begin_layout Standard
To illustrate the LJ algorithm, let us prove the sequent
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-sequent-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Denote that sequent by 
\begin_inset Formula $S_{0}$
\end_inset

:
\begin_inset Formula 
\[
S_{0}\triangleq\emptyset\vdash\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\Rightarrow\beta\quad.
\]

\end_inset

 Since the goal of 
\begin_inset Formula $S_{0}$
\end_inset

 contains an implication, we use the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Right}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 and get a sequent 
\begin_inset Formula $S_{1}$
\end_inset

:
\begin_inset Formula 
\[
S_{1}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\vdash\beta\quad.
\]

\end_inset

Now the implication is in the premise, so we use the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 and get two new sequents:
\begin_inset Formula 
\[
S_{2}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\vdash\alpha\Rightarrow\alpha\quad,\quad\quad S_{3}\triangleq\beta\vdash\beta\quad.
\]

\end_inset

Sequent 
\begin_inset Formula $S_{3}$
\end_inset

 follows from the 
\begin_inset Quotes eld
\end_inset

(Id)
\begin_inset Quotes erd
\end_inset

 axiom, so it remains to prove 
\begin_inset Formula $S_{2}$
\end_inset

.
 Since 
\begin_inset Formula $S_{2}$
\end_inset

 contains an implication both as a premise and as the goal, we may apply
 either the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 or the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Right}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

.
 We choose to apply 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 and get two new sequents:
\begin_inset Formula 
\[
S_{4}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\vdash\alpha\Rightarrow\alpha\quad,\quad\quad S_{5}:\beta\vdash\alpha\Rightarrow\alpha\quad.
\]

\end_inset

Notice that 
\begin_inset Formula $S_{4}=S_{2}$
\end_inset

.
 So, our proof search is getting into an infinite loop trying to prove the
 same sequent 
\begin_inset Formula $S_{2}$
\end_inset

 over and over again.
 We can prove 
\begin_inset Formula $S_{5}$
\end_inset

 but this will not help us break the loop.
\end_layout

\begin_layout Standard
Once we recognize the problem, we backtrack to the point where we chose
 to apply 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Formula $S_{2}$
\end_inset

.
 That was a bad choice, so let us instead apply 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Right}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Formula $S_{2}$
\end_inset

.
 This yields a new sequent 
\begin_inset Formula $S_{6}$
\end_inset

:
\begin_inset Formula 
\[
S_{6}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta,\alpha\vdash\alpha\quad.
\]

\end_inset

This sequent follows from the 
\begin_inset Quotes eld
\end_inset

(Id)
\begin_inset Quotes erd
\end_inset

 axiom.
 There are no more sequents to prove, so the proof of 
\begin_inset Formula $S_{0}$
\end_inset

 is finished.
 It can be drawn as a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
proof tree
\end_layout

\end_inset


\series bold
proof tree
\series default
 like this:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{4pc} &  &  & (\text{Id})\\
\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){S_{1}} & (\text{Left}\Rightarrow)\ar[r]\sp(0.5){S_{2}}\ar[ru]\sp(0.6){S_{3}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.65){S_{6}} & (\text{Id})
}
\]

\end_inset

The nodes of the proof tree are axioms or derivation rules, and the edges
 are intermediate sequents required by the rules.
 Some rule nodes branch into several sequents because some rules require
 more than one new sequent to be proved.
 The leaves of the tree are axioms that do not require proving any further
 sequents.
 
\end_layout

\begin_layout Subsubsection*
Extracting code from proofs
\end_layout

\begin_layout Standard
According to the Curry-Howard correspondence, a sequent (such as 
\begin_inset Formula $A,B,...,C\vdash X$
\end_inset

) represents the task of writing a fully parametric code expression of type
 
\begin_inset Formula $X$
\end_inset

 that uses some given values of types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ..., 
\begin_inset Formula $C$
\end_inset

.
 The sequent is true (i.e., can be proved) if that code expression can be
 found.
 So, the code serves as an 
\begin_inset Quotes eld
\end_inset

evidence of proof
\begin_inset Quotes erd
\end_inset

 for the sequent.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset Formula 
\begin{align*}
\frac{}{\Gamma,A\vdash{\color{blue}A}}~(\text{Id})\quad & \quad\text{Proof}\,(\Gamma,A\vdash A)_{\text{given }p^{:\Gamma},x^{:A}}=x\\
\frac{}{\Gamma\vdash{\color{blue}\top}}~(\text{True})\quad & \quad\text{Proof}\,(\Gamma\vdash\top)_{\text{given }p^{:\Gamma}}=1\\
\frac{\Gamma,A\Rightarrow B\vdash A\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\Rightarrow B}\vdash C}~(\text{Left}\Rightarrow)\quad & \quad\text{Proof}\,(\Gamma,A\Rightarrow B\vdash C)_{\text{given }p^{:\Gamma},q^{:A\rightarrow B}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p,b^{:B}}\\
\text{where} & \quad b^{:B}\triangleq q\big(\text{Proof}\,(\Gamma,A\Rightarrow B\vdash A)_{\text{given }p,q}\big)\\
\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\Rightarrow B}}~(\text{Right}\Rightarrow)\quad & \quad\text{Proof}\,(\Gamma\vdash A\Rightarrow B)_{\text{given }p^{:\Gamma}}\\
 & \quad\quad=x^{:A}\rightarrow\text{Proof}\,(\Gamma,A\vdash B)_{\text{given }p^{:\Gamma},x^{:A}}\\
\frac{\Gamma,A\vdash C}{\Gamma,{\color{blue}A\wedge B}\vdash C}~(\text{Left}\wedge_{1})\quad & \quad\text{Proof}\,(\Gamma,A\wedge B\vdash C)_{\text{given }p^{:\Gamma},(a^{:A}\times b^{:B})}\\
 & \quad\quad=\text{Proof}\,(\Gamma,A\vdash C)_{\text{given }p^{:\Gamma},a^{:A}}\\
\frac{\Gamma,B\vdash C}{\Gamma,{\color{blue}A\wedge B}\vdash C}~(\text{Left}\wedge_{2})\quad & \quad\text{Proof}\,(\Gamma,A\wedge B\vdash C)_{\text{given }p^{:\Gamma},(a^{:A}\times b^{:B})}\\
 & \quad\quad=\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p^{:\Gamma},b^{:B}}\\
\frac{\Gamma\vdash A\quad\quad\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\wedge B}}~(\text{Right}\wedge)\quad & \quad\text{Proof}\,(\Gamma\vdash A\wedge B)_{\text{given }p^{:\Gamma}}\\
 & \quad\quad=\text{Proof}\,(\Gamma\vdash A)_{\text{given }p^{:\Gamma}}\\
 & \quad\quad\quad\times\text{Proof}\,(\Gamma\vdash B)_{\text{given }p^{:\Gamma}}\\
\frac{\Gamma,A\vdash C\quad\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\vee B}\vdash C}~(\text{Left}\vee)\quad & \quad\text{Proof}\,(\Gamma,A\vee B\vdash C)_{\text{given }p^{:\Gamma},q^{:A+B}}\\
 & \quad\quad=q\triangleright\begin{array}{|c||c|}
 & C\\
\hline A & x^{:A}\rightarrow\text{Proof}\,(\Gamma,A\vdash C)_{\text{given }p,x}\\
B & y^{:B}\rightarrow\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p,y}
\end{array}\\
\frac{\Gamma\vdash A}{\Gamma\vdash{\color{blue}A\vee B}}~(\text{Right}\vee_{1})\quad & \quad\text{Proof}\,(\Gamma\vdash A\vee B)_{\text{given }p^{:\Gamma}}=\text{Proof}\,(\Gamma\vdash A)+\bbnum 0^{:B}\\
\frac{\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\vee B}}~(\text{Right}\vee_{2})\quad & \quad\text{Proof}\,(\Gamma\vdash A\vee B)_{\text{given }p^{:\Gamma}}=\bbnum 0^{:A}+\text{Proof}\,(\Gamma\vdash B)
\end{align*}

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:proof-transformers-for-LJ-rules"

\end_inset

Proof transformers for the rules of the LJ algorithm.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the previous subsection, we have found a proof of the sequent 
\begin_inset Formula $S_{0}$
\end_inset

, which represents the task of writing a fully parametric function with
 type signature 
\begin_inset Formula $(\left(A\rightarrow A\right)\rightarrow B)\rightarrow B$
\end_inset

).
 Let us now see how we can extract the code of that function from the proof
 of the sequent 
\begin_inset Formula $S_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
We start from the leaves of the proof tree and move step by step towards
 the initial sequent.
 At each step, we shorten the proof tree by replacing some sequent by its
 corresponding evidence-of-proof code.
 Eventually we will replace the initial sequent by its corresponding code.
 Let us see how this procedure works for the proof tree of the sequent 
\begin_inset Formula $S_{0}$
\end_inset

 shown in the previous section.
\end_layout

\begin_layout Standard
Since the leaves are axioms, let us write the code corresponding to each
 axiom of LJ:
\begin_inset Formula 
\begin{align*}
 & \frac{}{\Gamma,X\vdash X}~(\text{Id})\quad:\quad\quad\text{Proof}\,(\Gamma,X\vdash X)_{\text{given }p^{:\Gamma},\,x^{:X}}=x\quad;\\
 & \frac{}{\Gamma\vdash\top}~(\text{True})\quad:\quad\quad\text{Proof}\,(\Gamma\vdash\top)_{\text{given }p^{:\Gamma}}=1\quad.
\end{align*}

\end_inset

Here we denote explicitly the values (such as 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

) given as premises to the sequent.
 The notation 
\begin_inset Formula $p^{:\Gamma}$
\end_inset

 means all values given in the set of premises 
\begin_inset Formula $\Gamma$
\end_inset

.
 Below we will assume that the propositions 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 correspond to types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

; that is, 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

.
\end_layout

\begin_layout Standard
The leaves in the proof tree for 
\begin_inset Formula $S_{0}$
\end_inset

 are the 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Id}$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 axioms used to prove the sequents 
\begin_inset Formula $S_{3}$
\end_inset

 and 
\begin_inset Formula $S_{6}$
\end_inset

.
 Let us write the code that serves as the 
\begin_inset Quotes eld
\end_inset

evidence of proof
\begin_inset Quotes erd
\end_inset

 for these sequents.
 For brevity, we denote 
\begin_inset Formula $\gamma\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta$
\end_inset

 and 
\begin_inset Formula $C\triangleq\left(A\rightarrow A\right)\rightarrow B$
\end_inset

, so that 
\begin_inset Formula $\gamma={\cal CH}(C)$
\end_inset

.
 Then we can write:
\begin_inset Formula 
\begin{align*}
 & S_{3}\triangleq\beta\vdash\beta\quad,\quad\quad\text{Proof}\,(S_{3})_{\text{given }y^{:B}}=y\quad,\\
 & S_{6}\triangleq\gamma,\alpha\vdash\alpha\quad,\quad\quad\text{Proof}\,(S_{6})_{\text{given }q^{:C},\,x^{:A}}=x\quad.
\end{align*}

\end_inset

Note that the proof of 
\begin_inset Formula $S_{6}$
\end_inset

 does not use the first given value 
\begin_inset Formula $q^{:C}$
\end_inset

 (corresponding to the premise 
\begin_inset Formula $\gamma$
\end_inset

).
\end_layout

\begin_layout Standard
We now shorten the proof tree by replacing the sequents 
\begin_inset Formula $S_{3}$
\end_inset

 and 
\begin_inset Formula $S_{6}$
\end_inset

 by their 
\begin_inset Quotes eld
\end_inset

evidence of proof
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{4.2pc} &  &  & \square\\
\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){S_{1}} & (\text{Left}\Rightarrow)\ar[r]\sp(0.5){S_{2}}\ar[ru]\sp(0.6){(y)_{\text{given }y^{:B}}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.65){(x)_{\text{given }q^{:C},x^{:A}}} & \square
}
\]

\end_inset


\end_layout

\begin_layout Standard
The next step is to consider the proof of 
\begin_inset Formula $S_{2}$
\end_inset

, which is found by applying the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Right}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

.
 This rule promises to give a proof of 
\begin_inset Formula $S_{2}$
\end_inset

 if we have a proof of 
\begin_inset Formula $S_{6}$
\end_inset

.
 In order to extract code from that rule, we can write a function that transform
s a proof of 
\begin_inset Formula $S_{6}$
\end_inset

 into a proof of 
\begin_inset Formula $S_{2}$
\end_inset

.
 That function is the proof transformer corresponding to the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Right}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

.
 That rule and its transformer are defined as:
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\vdash B}{\Gamma\vdash A\Rightarrow B}~(\text{Right}\Rightarrow)\quad: & \quad\quad\text{Proof}\,(\Gamma\vdash A\Rightarrow B)_{\text{given }p^{:\Gamma}}\\
 & \quad\quad=x^{:A}\rightarrow\text{Proof}\,(\Gamma,A\vdash B)_{\text{given }p^{:\Gamma},\,x^{:A}}\quad.
\end{align*}

\end_inset

Applying the proof transformer to the known proof of 
\begin_inset Formula $S_{6}$
\end_inset

, we obtain a proof of 
\begin_inset Formula $S_{2}$
\end_inset

:
\begin_inset Formula 
\[
\text{Proof}\,(S_{2})_{\text{given }q^{:C}}=x^{:A}\rightarrow\text{Proof}\,(S_{6})_{\text{given }q^{:C},\,x^{:A}}=(x^{:A}\rightarrow x)_{\text{given }q^{:C}}\quad.
\]

\end_inset

The proof tree can be now shortened to:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3.5pc} &  &  & \square\\
\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){S_{1}} & (\text{Left}\Rightarrow)\ar[rr]\sp(0.62){(x^{:A}\rightarrow x)_{\text{given }q^{:C}}}\ar[ru]\sp(0.6){(y)_{\text{given }y^{:B}}} &  & \square
}
\]

\end_inset


\end_layout

\begin_layout Standard
The next step is to get the proof of 
\begin_inset Formula $S_{1}$
\end_inset

 obtained by applying the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

.
 That rule requires two previous sequents, so its transformer is a function
 of two previously obtained proofs:
\begin_inset Formula 
\begin{align*}
 & \frac{\Gamma,A\Rightarrow B\vdash A\quad\quad\Gamma,B\vdash C}{\Gamma,A\Rightarrow B\vdash C}~(\text{Left}\Rightarrow)\quad:\\
 & \text{Proof}\,(\Gamma,A\Rightarrow B\vdash C)_{\text{given }p^{:\Gamma},q^{:A\rightarrow B}}=\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p^{:\Gamma},b^{:B}}\\
 & \quad\quad\text{where}\quad b^{:B}\triangleq q\big(\text{Proof}\,(\Gamma,A\Rightarrow B\vdash A)_{\text{given }p^{:\Gamma},q^{:A\rightarrow B}}\big)\quad.
\end{align*}

\end_inset

In the proof tree shown above, we obtain a proof of 
\begin_inset Formula $S_{1}$
\end_inset

 by applying that proof transformer to the proofs of 
\begin_inset Formula $S_{2}$
\end_inset

 and 
\begin_inset Formula $S_{3}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\,(S_{1})_{\text{given }q^{:C}}=\text{Proof}\,(S_{3})_{\text{given }b^{:B}}\text{ where }b^{:B}\triangleq q(\text{Proof}\,(S_{2}))_{\text{given }q^{:C}}\\
 & \quad=b\text{ where }b^{:B}\triangleq q(x^{:A}\rightarrow x)_{\text{given }q^{:C}}=q(x^{:A}\rightarrow x)_{\text{given }q^{:C}}\quad.
\end{align*}

\end_inset

Substituting this proof into the proof tree, we shorten the tree to:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{5.5pc}\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.65){q(x^{:A}\rightarrow x)_{\text{given }q^{:C}}} & \square}
\]

\end_inset


\end_layout

\begin_layout Standard
It remains to obtain the proof of 
\begin_inset Formula $S_{0}$
\end_inset

 by applying the proof transformer of the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Right}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\,(S_{0})=\text{Proof}\,(\emptyset\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta)\\
 & =q^{:(A\rightarrow A)\rightarrow B}\rightarrow\text{Proof}\,(S_{1})_{\text{given }q^{:C}}=q^{:(A\rightarrow A)\rightarrow B}\rightarrow q(x^{:A}\rightarrow x)\quad.
\end{align*}

\end_inset

The proof tree is now shortened to just the code 
\begin_inset Formula $q^{:(A\rightarrow A)\rightarrow B}\rightarrow q(x^{:A}\rightarrow x)$
\end_inset

, which has type 
\begin_inset Formula $\left(\left(A\rightarrow A\right)\rightarrow B\right)\rightarrow B$
\end_inset

.
 So, that code is an evidence of proof for 
\begin_inset Formula $S_{0}$
\end_inset

.
 In this way, we have derived the code of a fully parametric function from
 its type signature.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:proof-transformers-for-LJ-rules"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the proof transformers for all the rules of the LJ algorithm.
 Apart from the special rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

, all other rules have proof transformers using just one of the code constructio
ns (
\begin_inset Quotes eld
\end_inset

create function
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

create tuple
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

use tuple
\begin_inset Quotes erd
\end_inset

, etc.) allowed within fully parametric code.
\end_layout

\begin_layout Subsubsection*
The LJT algorithm
\end_layout

\begin_layout Standard
As we have seen, the LJ algorithm enters a loop if the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 gives a sequent we already had at a previous step.
 That rule requires us to prove two new sequents:
\begin_inset Formula 
\[
\frac{\Gamma,A\Rightarrow B\vdash A\quad\quad\Gamma,B\vdash C}{\Gamma,A\Rightarrow B\vdash C}~(\text{Left}\Rightarrow)\quad\quad.
\]

\end_inset

A sign of trouble is that the first of these sequents (
\begin_inset Formula $\Gamma,A\Rightarrow B\vdash A$
\end_inset

) does not have a simpler form than the initial sequent (
\begin_inset Formula $\Gamma,A\Rightarrow B\vdash C$
\end_inset

).
 So, it is not clear that we are getting closer to completing the proof.
 If 
\begin_inset Formula $A=C$
\end_inset

, the new sequent will simply repeat the initial sequent, immediately creating
 a loop.
\end_layout

\begin_layout Standard
In some cases, a repeated sequent will occur after more than one step.
 It is not easy to formulate rigorous conditions for stopping the loop or
 for avoiding the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The LJT algorithm solves this problem by removing the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 from the LJ algorithm.
 Instead, 
\emph on
four
\emph default
 new rules are introduced.
 Each of these rules contains a different pattern instead of 
\begin_inset Formula $A$
\end_inset

 in the premise 
\begin_inset Formula $A\Rightarrow C$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{(}A\text{ is atomic)\,}\frac{\Gamma,A,B\vdash D}{\Gamma,A,{\color{blue}A\Rightarrow B}\vdash D}~(\text{Left}\Rightarrow_{A})\qquad & \quad\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\wedge B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\wedge})\\
\frac{\Gamma,B\Rightarrow C\vdash A\Rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\Rightarrow B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\Rightarrow})\qquad & \quad\frac{\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\vee B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\vee})
\end{align*}

\end_inset

The rule 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{Left}\Rightarrow_{A}$
\end_inset


\begin_inset Quotes erd
\end_inset

 applies only if the implication starts with an 
\begin_inset Quotes eld
\end_inset

atomic
\begin_inset Quotes erd
\end_inset

 type expression, i.e., a single type parameter or a unit type.
 In all other cases, the implication must start with a conjunction, a disjunctio
n, or an implication, which means that one of the three remaining rules
 will apply.
\end_layout

\begin_layout Standard
The LJT algorithm retains all the rules in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:proof-transformers-for-LJ-rules"
plural "false"
caps "false"
noprefix "false"

\end_inset

 except the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow$
\end_inset

)
\begin_inset Quotes erd
\end_inset

, which is replaced by the four new rules.
 It is far from obvious that the new rules are equivalent to the old ones.
 It took mathematicians several decades to come up with the LJT rules and
 to prove their validity.
 This book will rely on that result and will not attempt to prove it.
\end_layout

\begin_layout Standard
The proof transformers for the new rules are shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:proof-transformers-for-LJT-rules"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Figures
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:proof-transformers-for-LJ-rules"
plural "false"
caps "false"
noprefix "false"

\end_inset

â€“
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:proof-transformers-for-LJT-rules"
plural "false"
caps "false"
noprefix "false"

\end_inset

 define the set of proof transformers sufficient for using the LJT algorithm
 in practice.
 The 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
curryhoward
\family default
 library
\end_layout

\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library
\family typewriter

\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Chymyst/curryhoward"

\end_inset


\end_layout

\end_inset


\family default
 implements these proof transformers.
\end_layout

\begin_layout Standard
The most complicated of the new rules is the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow_{\Rightarrow}$
\end_inset

)
\begin_inset Quotes erd
\end_inset

.
 It is far from obvious why the rule 
\begin_inset Formula $\text{Left}\Rightarrow_{\Rightarrow}$
\end_inset

 is useful or even correct.
 This rule is based on a non-trivial logic identity: 
\begin_inset Formula 
\[
\left(\left(A\rightarrow B\right)\rightarrow C\right)\rightarrow\left(A\rightarrow B\right)\,\Longleftrightarrow\,\left(B\rightarrow C\right)\rightarrow\left(A\rightarrow B\right)\quad.
\]

\end_inset

Consider the type at the left-hand side of this identity:
\begin_inset Formula 
\[
\left(\left(A\rightarrow B\right)\rightarrow C\right)\rightarrow B\rightarrow C\quad.
\]

\end_inset

A function with that type can be written as: 
\begin_inset Formula 
\[
f=k^{:\left(A\rightarrow B\right)\rightarrow C}\rightarrow b^{:B}\rightarrow k\,(\_^{:A}\rightarrow b)\quad.
\]

\end_inset

The function 
\begin_inset Formula $f$
\end_inset

 occurs in the proof transformer for the rule 
\begin_inset Formula $\text{Left}\Rightarrow_{\Rightarrow}$
\end_inset

 (shown below in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:proof-transformers-for-LJT-rules"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Note that this 
\begin_inset Formula $f$
\end_inset

 applies 
\begin_inset Formula $k$
\end_inset

 to a function 
\begin_inset Formula $(\_\rightarrow b)$
\end_inset

 that ignores its argument.
 We expect to be able to simplify the resulting expression at the place
 when 
\begin_inset Formula $(\_\rightarrow b)$
\end_inset

 is applied to some argument expression, which we can then ignore.
 For this reason, applying the transformer for the rule 
\begin_inset Formula $\text{Left}\Rightarrow_{\Rightarrow}$
\end_inset

 results in evidence-of-proof code that is longer than the code obtained
 via LJ's rule transformers.
 The code obtained via the LJT algorithm needs to be simplified symbolically.
\end_layout

\begin_layout Standard
As an example of using the LJT algorithm, we again prove the sequent from
 the previous section: 
\begin_inset Formula $S_{0}=\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta$
\end_inset

.
 At each step, only one LJT rule applies to each sequent.
 The initial part of the proof tree looks like this:
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{6pc} &  &  & ~\\
\ar[r]\sp(0.4){\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){(\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta} & (\text{Left}\Rightarrow_{\Rightarrow})\ar[ru]\sp(0.65){\beta\vdash\beta}\ar[r]\sp(0.65){\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha} & ~
}
\]

\end_inset

The proofs for the sequents 
\begin_inset Formula $\beta\vdash\beta$
\end_inset

 and 
\begin_inset Formula $\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha$
\end_inset

 are the same as before:
\begin_inset Formula 
\[
\text{Proof}\,(\beta\vdash\beta)_{\text{given }y^{:B}}=y\quad,\quad\quad\text{Proof}\,(\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha)_{\text{given }r^{:A\rightarrow B}}=x^{:A}\rightarrow x\quad.
\]

\end_inset

Substituting these proofs into the proof transformer of the rule 
\begin_inset Quotes eld
\end_inset

(
\begin_inset Formula $\text{Left}\Rightarrow_{\Rightarrow}$
\end_inset

)
\begin_inset Quotes erd
\end_inset

 produces this code:
\begin_inset Formula 
\begin{align*}
 & \text{Proof}\,((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta)_{\text{given }q^{:(A\rightarrow A)\rightarrow B}}=q\big(\text{Proof}\,(\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha)_{\text{given }r^{:A\rightarrow B}}\big)\\
 & \quad\quad\text{where }r^{:A\rightarrow B}=a^{:A}\rightarrow q(\_^{:A}\rightarrow a)\\
 & =q(x^{:A}\rightarrow x)\quad.
\end{align*}

\end_inset

The proof of 
\begin_inset Formula $\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha$
\end_inset

 does not actually use the intermediate value 
\begin_inset Formula $r^{:A\rightarrow B}$
\end_inset

 provided by the proof transformer.
 As a symbolic simplification step, we may simply omit the code of 
\begin_inset Formula $r$
\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library always performs symbolic simplification after applying the LJT
 algorithm.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A,B\vdash D}{\Gamma,A,{\color{blue}A\Rightarrow B}\vdash D}~(\text{Left}\Rightarrow_{A})\quad & \quad\text{Proof}\,(\Gamma,A,A\Rightarrow B\vdash D)_{\text{given }p^{:\Gamma},x^{:A},q^{:A\rightarrow B}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,A,B\vdash D)_{\text{given }p,x,q(x)}\\
\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\wedge B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\wedge})\quad & \quad\text{Proof}\,(\Gamma,(A\wedge B)\Rightarrow C\vdash D)_{\text{given }p^{:\Gamma},q^{:A\times B\rightarrow C}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,\\
 & \quad\quad\quad A\Rightarrow B\Rightarrow C\vdash D)_{\text{given }p,(a^{:A}\rightarrow b^{:B}\rightarrow q(a\times b))}\\
\frac{\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\vee B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\vee})\quad & \quad\text{Proof}\,(\Gamma,(A\vee B)\Rightarrow C\vdash D)_{\text{given }p^{:\Gamma},q^{:A+B\rightarrow C}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D)_{\text{given }p,r,s}\\
 & \quad\quad\text{where}~r\triangleq a^{:A}\rightarrow q(a+\bbnum 0)\\
 & \quad\quad\text{ and }s\triangleq b^{:B}\rightarrow q(\bbnum 0+b)\\
\frac{\Gamma,B\Rightarrow C\vdash A\Rightarrow B\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\Rightarrow B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\Rightarrow})\quad & \quad\text{Proof}\,(\Gamma,(A\Rightarrow B)\Rightarrow C\vdash D)_{\text{given }p^{:\Gamma},q^{:\left(A\rightarrow B\right)\rightarrow C}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,C\vdash D)_{\text{given }p,c}\\
 & \quad\quad\text{ where}~c^{:C}\triangleq q\big(\text{Proof}\,(\Gamma,\\
 & \quad\quad\quad\quad\quad\quad\quad\quad B\Rightarrow C\vdash A\Rightarrow B)_{\text{given }p,r}\big)\\
 & \quad\quad\text{ and }r^{:B\rightarrow C}\triangleq b^{:B}\rightarrow q(\_^{:A}\rightarrow b)
\end{align*}

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:proof-transformers-for-LJT-rules"

\end_inset

Proof transformers for the four new rules of the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
LJT algorithm|textit
\end_layout

\end_inset

LJT algorithm.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason the LJT algorithm terminates is that each rule replaces a given
 sequent by one or more sequents with simpler premises or goals.
\begin_inset Foot
status open

\begin_layout Plain Layout
The paper 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618"
literal "false"

\end_inset


\family default
 shows that the LJT algorithm terminates by giving an explicit decreasing
 measure on proof trees.
\end_layout

\end_inset

 This guarantees that the proof search will terminate either with a complete
 proof or with a sequent to which no more rules apply.
 An example of such a 
\begin_inset Quotes eld
\end_inset

dead-end
\begin_inset Quotes erd
\end_inset

 sequent is 
\begin_inset Formula $\alpha\vdash\beta$
\end_inset

 where 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are different, unrelated propositions.
 When no more rules apply, the LJT algorithm concludes that the initial
 sequent cannot be proved.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Plain Layout
Proof search V: From deduction rules to code
\end_layout

\begin_layout Plain Layout
The new rules are equivalent to the old rules, therefore...
\end_layout

\begin_layout Plain Layout
Proof of a sequent 
\begin_inset Formula $A,B,C\vdash G$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 code/expression 
\begin_inset Formula $t(a,b,c):G$
\end_inset


\end_layout

\begin_layout Plain Layout
Also can be seen as a function 
\begin_inset Formula $t$
\end_inset

 from 
\begin_inset Formula $A,B,C$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Plain Layout
Sequent in a proof follows from an axiom or from a transforming rule
\end_layout

\begin_layout Plain Layout
The two axioms are fixed expressions, 
\begin_inset Formula $x^{A}\rightarrow x$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Plain Layout
Each rule has a 
\emph on
proof transformer
\emph default
 function: 
\begin_inset Formula $\text{PT}_{R\rightarrow}$
\end_inset

 , 
\begin_inset Formula $\text{PT}_{L+}$
\end_inset

 , etc.
\end_layout

\begin_layout Plain Layout
Examples of proof transformer functions:
\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\vdash C\quad\;\Gamma,B\vdash C}{\Gamma,{\color{blue}A+B}\vdash C}\,L+\\
PT_{L+}(t_{1}^{A\rightarrow C},t_{2}^{B\rightarrow C})=x^{A+B}\rightarrow & \ x\ \text{match}\begin{cases}
a^{A}\rightarrow t_{1}(a)\\
b^{B}\rightarrow t_{2}(b)
\end{cases}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\frac{\Gamma,A\rightarrow B\rightarrow C\vdash D}{\Gamma,{\color{blue}(A\times B)\rightarrow C}\vdash D}\,L\rightarrow_{2}\\
PT_{L\rightarrow_{2}}(f^{\left(A\rightarrow B\rightarrow C\right)\rightarrow D})=g^{A\times B\rightarrow C}\rightarrow & f\,(x^{A}\rightarrow y^{B}\rightarrow g(x,y))
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
Verify that we can indeed produce PTs for every rule of LJT
\end_layout

\begin_layout Plain Layout
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Plain Layout
Proof search example II: deriving code
\end_layout

\begin_layout Plain Layout
Once a proof tree is found, start from leaves and apply PTs
\end_layout

\begin_layout Plain Layout
For each sequent 
\begin_inset Formula $S_{i}$
\end_inset

, this will derive a 
\series bold
proof expression
\series default
 
\begin_inset Formula $t_{i}$
\end_inset


\end_layout

\begin_layout Plain Layout
Example: to prove 
\begin_inset Formula $S_{0}$
\end_inset

, start from 
\begin_inset Formula $S_{6}$
\end_inset

 backwards:
\size footnotesize

\begin_inset Formula 
\begin{align*}
S_{6}:\left(R\rightarrow R\right)\rightarrow Q;R\vdash R\quad(\text{axiom }Id)\quad & t_{6}(rrq,r)=r\\
S_{2}:\left(R\rightarrow R\right)\rightarrow Q\vdash\left(R\rightarrow R\right)\quad\text{PT}_{R\rightarrow}(t_{6})\quad & t_{2}(rrq)=\left(r\rightarrow t_{6}(rrq,r)\right)\\
S_{3}:Q\vdash Q\quad(\text{axiom }Id)\quad & t_{3}(q)=q\\
S_{1}:\left(R\rightarrow R\right)\rightarrow Q\vdash Q\quad\text{PT}_{L\rightarrow}(t_{2},t_{3})\quad & t_{1}(rrq)=t_{3}(rrq(t_{2}(rrq)))\\
S_{0}:\emptyset\vdash\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q\quad\text{PT}_{R\rightarrow}(t_{1})\quad & t_{0}=\left(rrq\rightarrow t_{1}(rrq)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
The proof expression for 
\begin_inset Formula $S_{0}$
\end_inset

 is then obtained as
\begin_inset Formula 
\begin{align*}
t_{0} & =rrq\rightarrow t_{3}\left(rrq\left(t_{2}\left(rrq\right)\right)\right)=rrq\rightarrow rrq(r\rightarrow t_{6}\left(rrq,r\right)\\
 & =rrq\rightarrow rrq\left(r\rightarrow r\right)
\end{align*}

\end_inset

Simplified final code having the required type: 
\begin_inset Formula 
\[
t_{0}:\left(\left(R\rightarrow R\right)\rightarrow Q\right)\rightarrow Q=\left(rrq\rightarrow rrq\left(r\rightarrow r\right)\right)
\]

\end_inset


\end_layout

\end_inset

To 
\emph on
prove
\emph default
 that there is no proof, one needs to use methods that are beyond the scope
 of this book.
 An introduction to the required techniques is in the already mentioned
 book 
\begin_inset Quotes eld
\end_inset

Proof and Disproof in Formal Logic
\begin_inset Quotes erd
\end_inset

 by R.
\begin_inset space ~
\end_inset

Bornat
\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bornat
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Failure of Boolean logic in reasoning about 
\begin_inset Formula $\mathcal{CH}$
\end_inset

-propositions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example:-Failure-of-Boolean-logic"

\end_inset


\end_layout

\begin_layout Standard
Programmers are familiar with the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Boolean logic
\end_layout

\end_inset

Boolean logic whose operations are written in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x && y
\end_layout

\end_inset

 (conjunction), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x || y
\end_layout

\end_inset

 (disjunction), and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

!x
\end_layout

\end_inset

 (negation).
 However, it turns out that the Boolean logic does 
\emph on
not
\emph default
 always produce correct conclusions when reasoning about 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions and implementable type signatures.
 For correct reasoning about those questions, one needs to use the constructive
 logic.
\end_layout

\begin_layout Standard
Let us nevertheless briefly look at how Boolean logic would handle that
 reasoning.
 In the Boolean logic, each proposition (
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, ...) is either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 The operations are 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

 (conjunction), 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 (disjunction), and 
\begin_inset Formula $\neg\alpha$
\end_inset

 (negation).
 The 
\series bold
implication
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
implication (in logic)
\end_layout

\end_inset

 (
\begin_inset Formula $\Rightarrow$
\end_inset

) is defined through other operations by:
\begin_inset Formula 
\begin{equation}
\left(\alpha\Rightarrow\beta\right)\triangleq\left((\neg\alpha)\vee\beta\right)\quad.\label{eq:ch-definition-of-implication-in-Boolean-logic}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
To verify whether a formula is true in the Boolean logic, we can substitute
 either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

 into every variable and check if the formula has the value 
\begin_inset Formula $True$
\end_inset

 in all possible cases.
 The result can be arranged into a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
truth table
\end_layout

\end_inset

truth table.
 The formula is true if all values in its truth table are 
\begin_inset Formula $True$
\end_inset

.
\end_layout

\begin_layout Standard
Disjunction, conjunction, negation, and implication operations have the
 following truth table:
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\vee\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\neg\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\Rightarrow\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Using this table, we find that the formula 
\begin_inset Formula $\alpha\Rightarrow\alpha$
\end_inset

 has the value 
\begin_inset Formula $True$
\end_inset

 in all cases, whether 
\begin_inset Formula $\alpha$
\end_inset

 itself is 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This check is sufficient to show that 
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset

 is true in Boolean logic.
\end_layout

\begin_layout Standard
Here is the truth table for the formulas 
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset

 and 
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset

.
 The first formula is true since all values in its column are 
\begin_inset Formula $True$
\end_inset

, while the second formula is not true since one value in the last column
 is 
\begin_inset Formula $False$
\end_inset

:
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $\alpha\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows more examples of logical formulas that are true in Boolean logic.
 Each formula is first written in terms of 
\begin_inset Formula ${\cal CH}$
\end_inset

-propositions (we denote 
\begin_inset Formula $\alpha\triangleq{\cal CH}(A)$
\end_inset

 and 
\begin_inset Formula $\beta\triangleq{\cal CH}(B)$
\end_inset

 for brevity) and then as a Scala type signature of a function.
 So, all these type signatures 
\emph on
can
\emph default
 be implemented.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,A\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def id[A](x: A): A = x
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,\alpha\Rightarrow True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,A\rightarrow\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def toUnit[A](x: A): Unit = ()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\vee\beta)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\rightarrow A+B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A, B](x: A): Either[A, B] = Left(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\wedge\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\times B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A, B](p: (A, B)): A = p._1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\beta\Rightarrow\alpha)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\rightarrow(B\rightarrow A)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A, B](x: A): B => A = (_ => x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of logical formulas that are true theorems in Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-formulas-Boolean-theorems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-not-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows some examples of formulas that are 
\emph on
not true
\emph default
 in Boolean logic.
 Translated into type formulas and then into Scala, these formulas yield
 type signatures that 
\emph on
cannot
\emph default
 be implemented by fully parametric functions.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logic formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type formula
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala type signature
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall\alpha.\,True\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall A.\,\bbnum 1\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A](x: Unit): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\vee\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A+B\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](x: Either[A, B]): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,\alpha\Rightarrow(\alpha\wedge\beta)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,A\rightarrow A\times B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](p: A): (A, B)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(\alpha,\beta).\,(\alpha\Rightarrow\beta)\Rightarrow\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\forall(A,B).\,(A\rightarrow B)\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A,B](x: A => B): A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of logical formulas that are 
\emph on
not
\emph default
 true in Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-formulas-not-Boolean-theorems"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At first sight, it may appear from these examples that whenever a logical
 formula is true in Boolean logic, the corresponding type signature can
 be implemented in code, and vice versa.
 However, this is 
\emph on
incorrect
\emph default
: the rules of Boolean logic are not fully suitable for reasoning about
 types in a functional language.
 We will now show some examples of formulas that are true in Boolean logic
 but correspond to unimplementable type signatures.
\end_layout

\begin_layout Standard
The first example is given by the following type:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\rightarrow B+C\right)\rightarrow\left(A\rightarrow B\right)+\left(A\rightarrow C\right)\quad,\label{eq:ch-example-boolean-bad-type}
\end{equation}

\end_inset

which corresponds to the Scala type signature (shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Motivation-and-outlook"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def bad2[A, B, C](g: A => Either[B, C]): Either[A => B, A => C] = ???
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad2
\end_layout

\end_inset

 
\emph on
cannot
\emph default
 be implemented via fully parametric code.
 To see why, consider that the only available data is a function 
\begin_inset Formula $g^{:A\rightarrow B+C}$
\end_inset

, which returns values of type 
\begin_inset Formula $B$
\end_inset

 or 
\begin_inset Formula $C$
\end_inset

 depending (in some unknown way) on the input value of type 
\begin_inset Formula $A$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad2
\end_layout

\end_inset

 must return either a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or a function of type 
\begin_inset Formula $A\rightarrow C$
\end_inset

.
 How can the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad2
\end_layout

\end_inset

 make that decision? The only input data is the function 
\begin_inset Formula $g$
\end_inset

 that takes an argument of type 
\begin_inset Formula $A$
\end_inset

.
 We could imagine applying 
\begin_inset Formula $g$
\end_inset

 to various arguments of type 
\begin_inset Formula $A$
\end_inset

 and to see whether 
\begin_inset Formula $g$
\end_inset

 returns a 
\begin_inset Formula $B$
\end_inset

 or a 
\begin_inset Formula $C$
\end_inset

.
 However, the type 
\begin_inset Formula $A$
\end_inset

 is arbitrary, and a fully parametric function cannot produce a value of
 type 
\begin_inset Formula $A$
\end_inset

 in order to apply 
\begin_inset Formula $g$
\end_inset

 to it.
 So, the decision about whether to return 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\rightarrow C$
\end_inset

 must be independent of 
\begin_inset Formula $g$
\end_inset

.
 That decision must be hard-coded in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Suppose we hard-coded the decision to return a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 How would we create a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 in the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad2
\end_layout

\end_inset

? Given a value 
\begin_inset Formula $x^{:A}$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

, we would need to compute some value of type 
\begin_inset Formula $B$
\end_inset

.
 Since the type 
\begin_inset Formula $B$
\end_inset

 is arbitrary (it is a type parameter), we cannot produce a value of type
 
\begin_inset Formula $B$
\end_inset

 from scratch.
 The only potential source of values of type 
\begin_inset Formula $B$
\end_inset

 is the given function 
\begin_inset Formula $g$
\end_inset

.
 The only way of using 
\begin_inset Formula $g$
\end_inset

 is to apply it to 
\begin_inset Formula $x^{:A}$
\end_inset

.
 However, for some 
\begin_inset Formula $x$
\end_inset

, the value 
\begin_inset Formula $g(x)$
\end_inset

 may be of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 is of type 
\begin_inset Formula $C$
\end_inset

.
 In that case, we will have a value of type 
\begin_inset Formula $C$
\end_inset

, not 
\begin_inset Formula $B$
\end_inset

.
 So, in general, we cannot guarantee that we can always obtain a value of
 type 
\begin_inset Formula $B$
\end_inset

 from a given value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 This means we cannot build a function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 out of the function 
\begin_inset Formula $g$
\end_inset

.
 Similarly, we cannot build a function of type 
\begin_inset Formula $A\rightarrow C$
\end_inset

 out of 
\begin_inset Formula $g$
\end_inset

.
 
\end_layout

\begin_layout Standard
Whether we decide to return 
\begin_inset Formula $A\rightarrow B$
\end_inset

 or 
\begin_inset Formula $A\rightarrow C$
\end_inset

, we will not be able to return a value of the required type, as we just
 saw.
 We must conclude that we cannot implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bad
\end_layout

\end_inset

 as a fully parametric function.
\end_layout

\begin_layout Standard
We could try to switch between 
\begin_inset Formula $A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $A\rightarrow C$
\end_inset

 depending on a given value of type 
\begin_inset Formula $A$
\end_inset

.
 This idea, however, means that we are working with a different type signature:
 
\begin_inset Formula 
\[
\forall(A,B,C).\,\left(A\rightarrow B+C\right)\rightarrow A\rightarrow\left(A\rightarrow B\right)+\left(A\rightarrow C\right)\quad.
\]

\end_inset

This type signature 
\emph on
can
\emph default
 be implemented, for instance, by this Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B, C](g: A => Either[B, C]): A => Either[A => B, A => C] = { a
 =>
\end_layout

\begin_layout Plain Layout

  g(a) match {
\end_layout

\begin_layout Plain Layout

    case Left(b) => Left(_ => b)
\end_layout

\begin_layout Plain Layout

    case Right(c) => Right(_ => c)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

But this is not the required type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-bad-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Now let us convert the type signature
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-bad-type"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition:
\begin_inset Formula 
\begin{align}
 & \forall(\alpha,\beta,\gamma).\,\left(\alpha\Rightarrow\left(\beta\vee\gamma\right)\right)\Rightarrow\left(\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)\right)\quad,\label{eq:abc-example-classical-logic-bad}\\
\text{where we denoted}:\quad & \alpha\triangleq{\cal CH}(A),\quad\beta\triangleq{\cal CH}(B),\quad\gamma\triangleq{\cal CH}(C)\quad.\nonumber 
\end{align}

\end_inset

It turns out that this formula is true in Boolean logic.
 To prove this, we need to show that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equal to 
\begin_inset Formula $True$
\end_inset

 for any Boolean values of the variables 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, 
\begin_inset Formula $\gamma$
\end_inset

.
 One way is to rewrite the expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) using the rules of Boolean logic, such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \gunderline{\alpha\Rightarrow}\left(\beta\vee\gamma\right)\\
\text{definition of }\Rightarrow\text{ via Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=(\neg\alpha)\vee\beta\vee\gamma\quad,\\
 & \gunderline{\left(\alpha\Rightarrow\beta\right)}\vee\gunderline{\left(\alpha\Rightarrow\gamma\right)}\\
\text{definition of }\Rightarrow\text{ via Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=\gunderline{(\neg\alpha)}\vee\beta\vee\gunderline{(\neg\alpha)}\vee\gamma\\
\text{property }x\vee x=x\text{ in Boolean logic}:\quad & \quad=(\neg\alpha)\vee\beta\vee\gamma\quad,
\end{align*}

\end_inset

showing that 
\begin_inset Formula $\alpha\Rightarrow(\beta\vee\gamma)$
\end_inset

 is in fact 
\emph on
equal
\emph default
 to 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)$
\end_inset

 in Boolean logic.
\end_layout

\begin_layout Standard
Let us also give a proof by truth-value reasoning.
 The only possibility for an implication 
\begin_inset Formula $X\Rightarrow Y$
\end_inset

 to be 
\begin_inset Formula $False$
\end_inset

 is when 
\begin_inset Formula $X=True$
\end_inset

 and 
\begin_inset Formula $Y=False$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be 
\begin_inset Formula $False$
\end_inset

 only if 
\begin_inset Formula $\left(\alpha\Rightarrow(\beta\vee\gamma)\right)=True$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\gamma\right)=False$
\end_inset

.
 A disjunction can be false only when both parts are false; so we must have
 both 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=False$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\gamma\right)=False$
\end_inset

.
 This is only possible if 
\begin_inset Formula $\alpha=True$
\end_inset

 and 
\begin_inset Formula $\beta=\gamma=False$
\end_inset

.
 But, with these value assignments, we find 
\begin_inset Formula $\left(\alpha\Rightarrow(\beta\vee\gamma)\right)=False$
\end_inset

 rather than 
\begin_inset Formula $True$
\end_inset

 as we assumed.
 It follows that we cannot ever make Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) equal to 
\begin_inset Formula $False$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:abc-example-classical-logic-bad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is true in Boolean logic.
\end_layout

\begin_layout Section
Equivalence of types
\end_layout

\begin_layout Standard
We found a correspondence between types, code, logical propositions, and
 proofs, which is known as the 
\series bold
Curry-Howard correspondence
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Curry-Howard correspondence
\end_layout

\end_inset

.
 An example of the CH correspondence is that a proof of the logical proposition:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta).\,\alpha\Rightarrow\left(\beta\Rightarrow\alpha\right)\label{eq:ch-proposition-example-2}
\end{equation}

\end_inset

corresponds to the code of the following function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (B => A) = { x => _ => x }
\end_layout

\end_inset

With the CH correspondence in mind, we may say that the 
\emph on
existence
\emph default
 of the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => _ => x
\end_layout

\end_inset

 with the type 
\begin_inset Formula $A\rightarrow(B\rightarrow A)$
\end_inset

 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 a proof of the logical formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-proposition-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), because it shows how to compute a value of type 
\begin_inset Formula $\forall(A,B).\,A\rightarrow B\rightarrow A$
\end_inset

.
\end_layout

\begin_layout Standard
The Curry-Howard correspondence maps logic formulas such as 
\begin_inset Formula $(\alpha\vee\beta)\wedge\gamma$
\end_inset

 into type expressions such as 
\begin_inset Formula $\left(A+B\right)\times C$
\end_inset

.
 We have seen that types behave similarly to logic formulas in one respect:
 A logic formula is a true theorem of constructive logic when the corresponding
 type signature can be implemented as a fully parametric function, and vice
 versa.
\end_layout

\begin_layout Standard
It turns out that the similarity ends here.
 In other respects, type expressions behave as 
\emph on
arithmetic
\emph default
 expressions and not as logic formulas.
 For this reason, the type notation used in this book denotes disjunctive
 types by 
\begin_inset Formula $A+B$
\end_inset

 and tuples by 
\begin_inset Formula $A\times B$
\end_inset

, which is designed to remind us of arithmetic expressions (such as 
\begin_inset Formula $1+2$
\end_inset

 and 
\begin_inset Formula $2\times3$
\end_inset

) rather than of logical formulas (such as 
\begin_inset Formula $A\vee B$
\end_inset

 and 
\begin_inset Formula $A\wedge B$
\end_inset

).
 
\end_layout

\begin_layout Standard
An important use of the type notation is for writing equations with types.
 Can we use the arithmetic intuition for writing type equations such as:
\begin_inset Formula 
\begin{equation}
\left(A+B\right)\times C=A\times C+B\times C\quad?\label{eq:ch-example-distributive}
\end{equation}

\end_inset

In this section, we will learn how to check whether one type expression
 is equivalent to another.
\end_layout

\begin_layout Subsection
Logical identity does not correspond to type equivalence
\begin_inset CommandInset label
LatexCommand label
name "subsec:Logical-identity-not-type-equivalence"

\end_inset


\end_layout

\begin_layout Standard
The CH correspondence maps Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the logic formula:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\vee B\right)\wedge C=\left(A\wedge C\right)\vee\left(B\wedge C\right)\quad.\label{eq:ch-example-distributive-1}
\end{equation}

\end_inset

This formula is a well-known distributive law
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Distributive_property#Rule_of_replacement"

\end_inset


\end_layout

\end_inset

 valid in Boolean logic as well as in the constructive logic.
 Since a logical equation 
\begin_inset Formula $P=Q$
\end_inset

 means 
\begin_inset Formula $P\Rightarrow Q$
\end_inset

 and 
\begin_inset Formula $Q\Rightarrow P$
\end_inset

, the distributive law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) means that the two formulas hold:
\begin_inset Formula 
\begin{align}
 & \forall(A,B,C).\,\left(A\vee B\right)\wedge C\Rightarrow\left(A\wedge C\right)\vee\left(B\wedge C\right)\quad,\label{eq:ch-example-distributive-1a}\\
 & \forall(A,B,C).\,\left(A\wedge C\right)\vee\left(B\wedge C\right)\Rightarrow\left(A\vee B\right)\wedge C\quad.\label{eq:ch-example-distributive-1b}
\end{align}

\end_inset

The CH correspondence maps these logical formulas to fully parametric functions
 with types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: ((Either[A, B], C))    => Either[(A, C), (B, C)] = ???
\end_layout

\begin_layout Plain Layout

def f2[A, B, C]: Either[(A, C), (B, C)] => (Either[A, B], C)      = ???
\end_layout

\end_inset

In the type notation, these type signatures are written as:
\begin_inset Formula 
\begin{align*}
 & f_{1}^{A,B,C}:\left(A+B\right)\times C\rightarrow A\times C+B\times C\quad,\\
 & f_{2}^{A,B,C}:A\times C+B\times C\rightarrow\left(A+B\right)\times C\quad.
\end{align*}

\end_inset

Since the two logical formulas (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

)â€“(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1b"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are true theorems in constructive logic, we expect to be able to implement
 the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 We could use the proof rules of the LJT algorithm to obtain proofs of Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

)â€“(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1b"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and to derive implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 Instead, let us exercise our intuition and write the Scala code directly.
\end_layout

\begin_layout Standard
To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, we need to perform pattern matching on the argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: ((Either[A, B], C)) => Either[(A, C), (B, C)] = {
\end_layout

\begin_layout Plain Layout

  case (Left(a), c)   => Left((a, c))  // No other choice here.
\end_layout

\begin_layout Plain Layout

  case (Right(b), c)  => Right((b, c)) // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In both cases, we have only one possible expression of the correct type.
\end_layout

\begin_layout Standard
Similarly, the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 leaves us no choices:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B, C]: Either[(A, C), (B, C)] => (Either[A, B], C) = {
\end_layout

\begin_layout Plain Layout

  case Left((a, c))   => (Left(a), c)  // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right((b, c))  => (Right(b), c) // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 never discards any given values; in other words, these functions appear
 to preserve information.
 We can formulate this property rigorously as a requirement that an arbitrary
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: (Either[A, B], C)
\end_layout

\end_inset

 be mapped by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 to some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: Either[(A, C), (B, C)]
\end_layout

\end_inset

 and then mapped by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 back to 
\emph on
the same
\emph default
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 Similarly, any value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

y
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, C), (B, C)]
\end_layout

\end_inset

 should be transformed by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 and then by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 back to the same value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us write those conditions as equations:
\begin_inset Formula 
\[
\forall x^{:(A+B)\times C}.\,f_{2}(f_{1}(x))=x\quad,\quad\quad\forall y^{:A\times C+B\times C}.\,f_{1}\left(f_{2}(y)\right)=y\quad.
\]

\end_inset

If these equations hold, it means that all the information in a value 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 is completely preserved inside the value 
\begin_inset Formula $y\triangleq f_{1}(x)$
\end_inset

; the original value 
\begin_inset Formula $x$
\end_inset

 can be recovered as 
\begin_inset Formula $x=f_{2}(y)$
\end_inset

.
 Then the function 
\begin_inset Formula $f_{1}$
\end_inset

 is the 
\series bold
inverse
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
inverse function
\end_layout

\end_inset

 of 
\begin_inset Formula $f_{2}$
\end_inset

.
 Conversely, all the information in a value 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

 is preserved inside 
\begin_inset Formula $x\triangleq f_{2}(y)$
\end_inset

 and can be recovered by applying 
\begin_inset Formula $f_{1}$
\end_inset

.
 Since the values 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 and 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

 are arbitrary, it will follow that the 
\emph on
data types
\emph default
 themselves, 
\begin_inset Formula $\left(A+B\right)\times C$
\end_inset

 and 
\begin_inset Formula $A\times C+B\times C$
\end_inset

, carry equivalent information.
 Such types are called equivalent
\begin_inset Index idx
status open

\begin_layout Plain Layout
types!equivalent
\end_layout

\end_inset

 or isomorphic
\begin_inset Index idx
status open

\begin_layout Plain Layout
types!isomorphic
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
isomorphic types
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Generally, we say that types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are 
\series bold
equivalent
\series default
 or 
\series bold
isomorphic
\series default
 (denoted 
\begin_inset Formula $P\cong Q$
\end_inset

) 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence
\end_layout

\end_inset

when there exist functions 
\begin_inset Formula $f_{1}:P\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $f_{2}:Q\rightarrow P$
\end_inset

 that are inverses of each other.
 We can write that using the notation 
\begin_inset Formula $(f_{1}\bef f_{2})(x)\triangleq f_{2}(f_{1}(x))$
\end_inset

 as:
\begin_inset Formula 
\[
f_{1}\bef f_{2}=\text{id}\quad,\quad\quad f_{2}\bef f_{1}=\text{id}\quad.
\]

\end_inset

(In Scala, the forward composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 is the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

.
 We omit type annotations since we already checked that the types match.)
 If these conditions hold, there is a one-to-one correspondence between
 values of types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 This is the same as to say that the data types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 
\begin_inset Quotes eld
\end_inset

carry equivalent information
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
To verify that the Scala functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 defined above are inverses of each other, we first check if 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

.
 Applying 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 means to apply 
\begin_inset Formula $f_{1}$
\end_inset

 and then to apply 
\begin_inset Formula $f_{2}$
\end_inset

 to the result.
 Begin by applying 
\begin_inset Formula $f_{1}$
\end_inset

 to an arbitrary value 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

.
 A value 
\begin_inset Formula $x$
\end_inset

 of that type can be in only one of the two disjoint cases: a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 or a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

, for some values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b:B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c:C
\end_layout

\end_inset

.
 The Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 maps these tuples to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 and to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

 respectively; we can see this directly from the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

.
 We then apply 
\begin_inset Formula $f_{2}$
\end_inset

 to those values, which maps them back to a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 or to a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 respectively, according to the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 These tuples are exactly the value 
\begin_inset Formula $x$
\end_inset

 we started with.
 So, applying 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 to an arbitrary 
\begin_inset Formula $x^{:(A+B)\times C}$
\end_inset

 returns that value 
\begin_inset Formula $x$
\end_inset

.
 This is the same as to say that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To check whether 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

, we apply 
\begin_inset Formula $f_{2}$
\end_inset

 to an arbitrary value 
\begin_inset Formula $y^{:A\times C+B\times C}$
\end_inset

, which must be one of the two disjoint cases, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 maps these two cases into tuples 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 respectively.
 Then we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and map these tuples back to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

 respectively.
 It follows that applying 
\begin_inset Formula $f_{2}$
\end_inset

 and then 
\begin_inset Formula $f_{1}$
\end_inset

 will always return the initial value.
 As a formula, this is written as 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
By looking at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we can directly observe that these functions are inverses of each other:
 the tuple pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Left(a), c)
\end_layout

\end_inset

 is mapped to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left((a, c))
\end_layout

\end_inset

, and the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Right(b), c)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right((b, c))
\end_layout

\end_inset

, or vice versa.
 It is visually clear that no information is lost and that the original
 values are returned by function compositions 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 or 
\begin_inset Formula $f_{2}\bef f_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
We find that the logical identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to an equivalence of the corresponding types:
\begin_inset Formula 
\begin{equation}
\left(A+B\right)\times C\cong A\times C+B\times C\quad.\label{eq:ch-distributive-law-types}
\end{equation}

\end_inset

To get Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-distributive-law-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to convert a logical formula to an arithmetic expression by replacing
 the disjunction operations 
\begin_inset Formula $\vee$
\end_inset

 by 
\begin_inset Formula $+$
\end_inset

 and the conjunctions 
\begin_inset Formula $\wedge$
\end_inset

 by 
\begin_inset Formula $\times$
\end_inset

 everywhere.
\end_layout

\begin_layout Standard
As another example of a logical identity, consider the associativity law
 for conjunction:
\begin_inset Formula 
\begin{equation}
\left(\alpha\wedge\beta\right)\wedge\gamma=\alpha\wedge\left(\beta\wedge\gamma\right)\quad.\label{eq:ch-example-associativity-conjunction}
\end{equation}

\end_inset

The corresponding types are 
\begin_inset Formula $(A\times B)\times C$
\end_inset

 and 
\begin_inset Formula $A\times(B\times C)$
\end_inset

; in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B), C)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, (B, C))
\end_layout

\end_inset

.
 We can define functions that convert between these types without information
 loss
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f3[A, B, C]: (((A, B), C)) => (A, (B, C)) = { case ((a, b), c) =>
\end_layout

\begin_layout Plain Layout

                                                       (a, (b, c)) }
\end_layout

\begin_layout Plain Layout

def f4[A, B, C]: (A, (B, C)) => (((A, B), C)) = { case (a, (b, c)) =>
\end_layout

\begin_layout Plain Layout

                                                       ((a, b), c) }
\end_layout

\end_inset

By applying these functions to arbitrary values of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B), C)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, (B, C))
\end_layout

\end_inset

, it is easy to see that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f4
\end_layout

\end_inset

 are inverses of each other.
 This is also directly visible in the code: the nested tuple pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((a, b), c)
\end_layout

\end_inset

 is mapped to the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, (b, c))
\end_layout

\end_inset

 and back.
 So, the types 
\begin_inset Formula $\left(A\times B\right)\times C$
\end_inset

 and 
\begin_inset Formula $A\times\left(B\times C\right)$
\end_inset

 are equivalent.
 We will often write 
\begin_inset Formula $A\times B\times C$
\end_inset

 without parentheses.
\end_layout

\begin_layout Standard
Does a logical identity always correspond to an equivalence of types? This
 turns out to be 
\emph on
not
\emph default
 so.
 A simple example of a logical identity that does not correspond to a type
 equivalence is:
\begin_inset Formula 
\begin{equation}
True\vee\alpha=True\quad.\label{eq:ch-example-logic-identity-2}
\end{equation}

\end_inset

Since the CH correspondence maps the logical constant 
\begin_inset Formula $True$
\end_inset

 into the unit type 
\begin_inset Formula $\bbnum 1$
\end_inset

, the type equivalence corresponding to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-logic-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\begin_inset Formula $\bbnum 1+A\cong\bbnum 1$
\end_inset

.
 The type denoted by 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 in Scala, so the corresponding equivalence is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset


\begin_inset Formula $\cong$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 Intuitively, this type equivalence should not hold: an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 may carry a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, which cannot possibly be stored in a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 We can verify this intuition rigorously by proving that any fully parametric
 functions with type signatures 
\begin_inset Formula $g_{1}:\bbnum 1+A\rightarrow\bbnum 1$
\end_inset

 and 
\begin_inset Formula $g_{2}:\bbnum 1\rightarrow\bbnum 1+A$
\end_inset

 will not satisfy 
\begin_inset Formula $g_{1}\bef g_{2}=\text{id}$
\end_inset

.
 To verify this, we note that 
\begin_inset Formula $g_{2}:\bbnum 1\rightarrow\bbnum 1+A$
\end_inset

 must have this type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g2[A]: Unit => Option[A] = ???
\end_layout

\end_inset

This function must always return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, since a fully parametric function cannot produce values of an arbitrary
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 from scratch.
 Therefore, 
\begin_inset Formula $g_{1}\bef g_{2}$
\end_inset

 is also a function that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 The function 
\begin_inset Formula $g_{1}\bef g_{2}$
\end_inset

 has type signature 
\begin_inset Formula $\bbnum 1+A\rightarrow\bbnum 1+A$
\end_inset

 or, in Scala syntax, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[A]
\end_layout

\end_inset

, and is not equal to the identity function, because the identity function
 does 
\emph on
not
\emph default
 always return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Another example of a logical identity that does not correspond to a type
 equivalence is the distributive law:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\wedge B\right)\vee C=\left(A\vee C\right)\wedge\left(B\vee C\right)\quad,\label{eq:ch-example-distributive-2}
\end{equation}

\end_inset

which is 
\begin_inset Quotes eld
\end_inset

dual
\begin_inset Quotes erd
\end_inset

 to the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), i.e., it is obtained from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by swapping all conjunctions (
\begin_inset Formula $\wedge$
\end_inset

) with disjunctions (
\begin_inset Formula $\vee$
\end_inset

).
 In logic, a dual formula to an identity is also an identity.
 The CH correspondence maps Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the type equation:
\begin_inset Formula 
\begin{equation}
\forall(A,B,C).\,\left(A\times B\right)+C=\left(A+C\right)\times\left(B+C\right)\quad.\label{eq:ch-example-incorrect-identity-2}
\end{equation}

\end_inset

However, the types 
\begin_inset Formula $A\times B+C$
\end_inset

 and 
\begin_inset Formula $\left(A+C\right)\times\left(B+C\right)$
\end_inset

 are 
\emph on
not
\emph default
 equivalent.
 To see why, look at the possible code of a function 
\begin_inset Formula $g_{3}:\left(A+C\right)\times\left(B+C\right)\rightarrow A\times B+C$
\end_inset

:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def g3[A, B, C]: ((Either[A, C], Either[B, C])) => Either[(A, B), C] = {
\end_layout

\begin_layout Plain Layout

  case (Left(a), Left(b))      => Left((a, b)) // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Left(a), Right(c))     => Right(c)     // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Right(c), Left(b))     => Right(c)     // No other choice.
\end_layout

\begin_layout Plain Layout

  case (Right(c1), Right(c2))  => Right(c1)    // Must discard c1 or c2
 here!
\end_layout

\begin_layout Plain Layout

}   // May return Right(c2) instead of Right(c1) in the last line.
\end_layout

\end_inset

In line 5, we have a choice of returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c1)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(c2)
\end_layout

\end_inset

.
 Whichever we choose, we will lose information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 because we will have discarded one of the given values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c2
\end_layout

\end_inset

.
 After evaluating 
\begin_inset Formula $g_{3}$
\end_inset

, we will not be able to restore 
\emph on
both
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c2
\end_layout

\end_inset

, no matter what code we write.
 So, the composition 
\begin_inset Formula $g_{3}\bef g_{4}$
\end_inset

 with any 
\begin_inset Formula $g_{4}$
\end_inset

 cannot be equal to the identity function.
 The type equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-incorrect-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is incorrect.
\end_layout

\begin_layout Standard
We find that a logical identity 
\begin_inset Formula ${\cal CH}(P)={\cal CH}(Q)$
\end_inset

 guarantees, via the CH correspondence, that we can implement 
\emph on
some
\emph default
 fully parametric functions of types 
\begin_inset Formula $P\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $Q\rightarrow P$
\end_inset

.
 However, it is not guaranteed that these functions are inverses of each
 other, i.e., that the type conversions 
\begin_inset Formula $P\rightarrow Q$
\end_inset

 or 
\begin_inset Formula $Q\rightarrow P$
\end_inset

 have no information loss
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

.
 So, the type equivalence 
\begin_inset Formula $P\cong Q$
\end_inset

 does not automatically follow from the logical identity 
\begin_inset Formula ${\cal CH}(P)={\cal CH}(Q)$
\end_inset

.
\end_layout

\begin_layout Standard
The CH correspondence means that for true propositions 
\begin_inset Formula ${\cal CH}(X)$
\end_inset

 we can compute 
\emph on
some
\emph default
 value 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $X$
\end_inset

.
 However, the CH correspondence does not guarantee that the computed value
 
\begin_inset Formula $x^{:X}$
\end_inset

 will satisfy any additional properties or laws.
\end_layout

\begin_layout Subsection
Arithmetic identity corresponds to type equivalence
\end_layout

\begin_layout Standard
Looking at the examples of equivalent types, we notice that correct type
 equivalences correspond to 
\emph on
arithmetical
\emph default
 identities rather than 
\emph on
logical
\emph default
 identities.
 For instance, the logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to the type equivalence
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-distributive-law-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which looks like a standard identity of arithmetic, such as:
\begin_inset Formula 
\[
(1+10)\times20=1\times20+10\times20\quad.
\]

\end_inset

The logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-distributive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which does 
\emph on
not
\emph default
 yield a type equivalence, leads to an incorrect arithmetic equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-incorrect-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), e.g., 
\begin_inset Formula $\left(1\times10\right)+20\neq\left(1+20\right)\times\left(10+20\right)$
\end_inset

.
 Similarly, the associativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-associativity-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to a type equivalence and to the arithmetic identity:
\begin_inset Formula 
\[
\left(a\times b\right)\times c=a\times\left(b\times c\right)\quad,
\]

\end_inset

The logical identity in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-logic-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which does not yield a type equivalence, leads to an incorrect arithmetic
 statement (
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $1+a=1$
\end_inset

 for all 
\begin_inset Formula $a$
\end_inset


\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes these and other examples of logical identities and the corresponding
 type equivalences.
 In all rows, quantifiers such as 
\begin_inset Formula $\forall\alpha$
\end_inset

 or 
\begin_inset Formula $\forall(A,B)$
\end_inset

 are implied as necessary.
\end_layout

\begin_layout Standard
Because we chose the type notation to be similar to the ordinary arithmetic
 notation, it is easy to translate a possible type equivalence into an arithmeti
c equation.
 In all cases, valid arithmetic identities correspond to type equivalences,
 and failures to obtain a type equivalence correspond to incorrect arithmetic
 identities.
 With regard to type equivalence, types such as 
\begin_inset Formula $A+B$
\end_inset

 and 
\begin_inset Formula $A\times B$
\end_inset

 behave similarly to arithmetic expressions such as 
\begin_inset Formula $10+20$
\end_inset

 and 
\begin_inset Formula $10\times20$
\end_inset

 and not similarly to logical formulas such as 
\begin_inset Formula $\alpha\vee\beta$
\end_inset

 and 
\begin_inset Formula $\alpha\wedge\beta$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Logical identity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type equivalence (if it holds)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True\vee\alpha=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+A\not\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $True\wedge\alpha=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1\times A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False\vee\alpha=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $False\wedge\alpha=False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\vee\beta=\beta\vee\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A+B\cong B+A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\alpha\wedge\beta=\beta\wedge\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\times B\cong B\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\vee\gamma=\alpha\vee\left(\beta\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\wedge\beta\right)\wedge\gamma=\alpha\wedge\left(\beta\wedge\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A\times B\right)\times C\cong A\times\left(B\times C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\vee\beta\right)\wedge\gamma=\left(\alpha\wedge\gamma\right)\vee\left(\beta\wedge\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A+B\right)\times C\cong A\times C+B\times C$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\alpha\wedge\beta\right)\vee\gamma=\left(\alpha\vee\gamma\right)\wedge\left(\beta\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(A\times B\right)+C\not\cong\left(A+C\right)\times\left(B+C\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logic identities with disjunction and conjunction, and the possible type
 equivalences.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-identities-with-disjunction-and-conjunction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We already verified the first line and the last three lines of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Other identities are verified in a similar way.
 Let us begin with lines 3 and 4 of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which involve the proposition 
\begin_inset Formula $False$
\end_inset

 and the corresponding 
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

void type 
\begin_inset Formula $\bbnum 0$
\end_inset

 (Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

).
 Reasoning about the void type needs a special technique that we will now
 develop while verifying the type isomorphisms 
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset

 and 
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-0-times-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-0-times-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0\times A\cong\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 0\times A$
\end_inset

 represents the Scala tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

.
 To demonstrate that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 is equivalent to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, we need to show that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 has 
\emph on
no
\emph default
 values.
 Indeed, how could we create a value of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, Int)
\end_layout

\end_inset

? We would need to fill 
\emph on
both
\emph default
 parts of the tuple.
 We have values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, but we can never get a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 So, regardless of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, it is impossible to create any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

.
 In other words, the set of values of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 is empty.
 But that is the definition of the void type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 The types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Nothing, A)
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 0\times A$
\end_inset

) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 0$
\end_inset

) are both void and therefore equivalent.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-0-plus-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-0-plus-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0+A\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The type notation 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 corresponds to the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

.
 We need to show that any value of that type can be mapped without loss
 of information to a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and vice versa.
 This means implementing functions 
\begin_inset Formula $f_{1}:\bbnum 0+A\rightarrow A$
\end_inset

 and 
\begin_inset Formula $f_{2}:A\rightarrow\bbnum 0+A$
\end_inset

 such that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
The argument of 
\begin_inset Formula $f_{1}$
\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

.
 How can we create a value of that type? Our only choices are to create
 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:Nothing
\end_layout

\end_inset

, or to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y:A
\end_layout

\end_inset

.
 However, we cannot create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 because the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has 
\emph on
no
\emph default
 values.
 We cannot create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

.
 The only remaining possibility is to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, any values of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 must be of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

, and we can extract that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Either[Nothing, A] => A = {
\end_layout

\begin_layout Plain Layout

  case Right(y) => y
\end_layout

\begin_layout Plain Layout

  // No need for `case Left(x) => ...` since no `x` can ever be given as `Left(x)`.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

For the same reason, there is only one implementation of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A]: A => Either[Nothing, A] = { y => Right(y) }
\end_layout

\end_inset

It is clear from the code that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
\end_layout

\begin_layout Standard
We have just seen that a value of type 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: A
\end_layout

\end_inset

.
 Similarly, a value of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 is always a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 with some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

.
 So, we will use the notation 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 and 
\begin_inset Formula $\bbnum 0+A$
\end_inset

 to 
\emph on
denote
\emph default
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 parts of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

.
 This notation agrees with the behavior of the Scala compiler, which will
 infer the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Nothing] 
\end_layout

\end_inset

or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Nothing, A]
\end_layout

\end_inset

 for these parts:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toLeft[A, B]: A => Either[A, B] = x => Left(x)
\end_layout

\begin_layout Plain Layout

def toRight[A, B]: B => Either[A, B] = y => Right(y)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toLeft(123)
\end_layout

\begin_layout Plain Layout

res0: Either[Int, Nothing] = Left(123)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toRight(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

res1: Either[Nothing, String] = Right("abc")
\end_layout

\end_inset

We can write the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toRight
\end_layout

\end_inset

 in a code notation as:
\begin_inset Formula 
\[
\text{toLeft}^{A,B}\triangleq x^{:A}\rightarrow x+\bbnum 0^{:B}\quad,\quad\quad\text{toRight}^{A,B}\triangleq y^{:B}\rightarrow\bbnum 0^{:A}+y\quad.
\]

\end_inset

In this notation, a value of the disjunctive type is shown without using
 Scala class names such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

.
 This shortens the writing and speeds up code reasoning.
 
\end_layout

\begin_layout Standard
The type annotation 
\begin_inset Formula $\bbnum 0^{:A}$
\end_inset

 is helpful to remind ourselves about the type parameter 
\begin_inset Formula $A$
\end_inset

 used, e.g., by the disjunctive value 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset

 in the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toRight[A, B]
\end_layout

\end_inset

.
 Without this type annotation, 
\begin_inset Formula $\bbnum 0+y^{:B}$
\end_inset

 means a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 where the parameter 
\begin_inset Formula $A$
\end_inset

 should be determined by matching the types of other expressions.
 When it is clear what types are being used, we may omit type annotations
 and write simply 
\begin_inset Formula $\bbnum 0+y$
\end_inset

 instead of 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset

.
\end_layout

\begin_layout Standard
In the notation 
\begin_inset Formula $\bbnum 0+y^{:B}$
\end_inset

, we use the symbol 
\begin_inset Formula $\bbnum 0$
\end_inset

 rather than an ordinary zero (
\begin_inset Formula $0$
\end_inset

), to avoid suggesting that 
\begin_inset Formula $0$
\end_inset

 is a value of type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 The void type 
\begin_inset Formula $\bbnum 0$
\end_inset

 has 
\emph on
no
\emph default
 values, unlike the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, 
\begin_inset Formula $\bbnum 1$
\end_inset

, which has a value denoted by 
\begin_inset Formula $1$
\end_inset

 in the code notation.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-1xA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-1xA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\times\bbnum 1\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The corresponding Scala types are the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, Unit)
\end_layout

\end_inset

 and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 We need to implement functions 
\begin_inset Formula $f_{1}:\forall A.\,A\times\bbnum 1\rightarrow A$
\end_inset

 and 
\begin_inset Formula $f_{2}:\forall A.\,A\rightarrow A\times\bbnum 1$
\end_inset

 and to demonstrate that they are inverses of each other.
 The Scala code for these functions is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: ((A, Unit)) => A = { case (a, ()) => a }
\end_layout

\begin_layout Plain Layout

def f2[A]: A => (A, Unit) = { a => (a, ()) }
\end_layout

\end_inset

Let us first write a proof by reasoning directly with Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(f1 andThen f2)((a,())) == f2(f1((a,())) == f2(a) == (a, ())
\end_layout

\begin_layout Plain Layout

(f2 andThen f1)(a) == f1(f2(a)) == f1((a, ())) = a
\end_layout

\end_inset

Now let us write a proof in the code notation.
 The codes of 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are:
\begin_inset Formula 
\[
f_{1}\triangleq a^{:A}\times1\rightarrow a\quad,\quad\quad f_{2}\triangleq a^{:A}\rightarrow a\times1\quad,
\]

\end_inset

where we denoted by 
\begin_inset Formula $1$
\end_inset

 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
 We find:
\begin_inset Formula 
\begin{align*}
(f_{1}\bef f_{2})(a^{:A}\times1) & =f_{2}\left(f_{1}(a\times1)\right)=f_{2}\left(a\right)=a\times1\quad,\\
(f_{2}\bef f_{1})(a^{:A}) & =f_{1}(f_{2}(a))=f_{1}(a\times1)=a\quad.
\end{align*}

\end_inset

This shows that both compositions are identity functions.
 Another way of writing the proof is by computing the function compositions
 symbolically, without applying to a value 
\begin_inset Formula $a^{:A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(a\times1\rightarrow a\right)\bef\left(a\rightarrow a\times1\right)=\left(a\times1\rightarrow a\times1\right)=\text{id}^{A\times\bbnum 1}\quad,\\
f_{2}\bef f_{1} & =\left(a\rightarrow a\times1\right)\bef\left(a\times1\rightarrow a\right)=\left(a\rightarrow a\right)=\text{id}^{A}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-A+B"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-A+B"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A+B\cong B+A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The corresponding Scala types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[B, A]
\end_layout

\end_inset

.
 Use pattern matching to implement the functions required for the type equivalen
ce:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Either[A, B] => Either[B, A] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Right(a) // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Left(b)  // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A, B]: Either[B, A] => Either[A, B] = f1[B, A]
\end_layout

\end_inset

The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are implemented by code that can be derived unambiguously from the type
 signatures.
 For instance, the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Left(a) => ...
\end_layout

\end_inset

 is required to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[B, A]
\end_layout

\end_inset

 by using a given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 The only way of doing that is by returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is clear from the code that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 To verify that rigorously, we need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

 is equal to an identity function.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1 andThen f2
\end_layout

\end_inset

 applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 contains two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case ...
\end_layout

\end_inset

 lines, each returning a result.
 So, we need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 separately in each line.
 Evaluate the code symbolically:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(f1 andThen f2) == {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => f2(Right(a))
\end_layout

\begin_layout Plain Layout

  case Right(b)   => f2(Left(b))
\end_layout

\begin_layout Plain Layout

} == {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Left(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Right(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The result is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B] => Either[A, B]
\end_layout

\end_inset

 that does not change its argument; so, it is equal to the identity function.
 
\end_layout

\begin_layout Standard
Let us now write the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 in the code notation and perform the same derivation.
 We will also develop a useful notation for functions operating on disjunctive
 types.
\end_layout

\begin_layout Standard
The pattern matching construction in the Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 is similar to a pair of functions with types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Either[B, A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => Either[B, A]
\end_layout

\end_inset

.
 One of these functions is applied depending on whether the argument of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 has type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+B$
\end_inset

.
 So, we may write the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
f_{1}\triangleq x^{:A+B}\rightarrow\begin{cases}
\quad\text{if }x=a^{:A}+\bbnum 0^{:B}\quad: & \bbnum 0^{:B}+a^{:A}\\
\quad\text{if }x=\bbnum 0^{:A}+b^{:B}\quad: & b^{:B}+\bbnum 0^{:A}
\end{cases}
\]

\end_inset

Since both the argument and the result of 
\begin_inset Formula $f_{1}$
\end_inset

 are disjunctive types with 
\begin_inset Formula $2$
\end_inset

 parts each, it is convenient to write the code of 
\begin_inset Formula $f_{1}$
\end_inset

 as a 
\begin_inset Formula $2\times2$
\end_inset

 
\emph on
matrix
\emph default
 that maps the input parts to the output parts:
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type!in matrix notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
matrix notation
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Either[A, B] => Either[B, A] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Right(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => Left(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
f_{1}\triangleq\,\begin{array}{|c||cc|}
 & B & A\\
\hline A & \bbnum 0 & a^{:A}\rightarrow a\\
B & b^{:B}\rightarrow b & \bbnum 0
\end{array}\quad.
\]

\end_inset

The rows of the matrix correspond to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 rows in the Scala code.
 There is one row for each part of the disjunctive type of the argument.
 The columns of the matrix correspond to the parts of the disjunctive type
 of the result.
\begin_inset Index idx
status open

\begin_layout Plain Layout
pattern matching!in matrix notation
\end_layout

\end_inset

 The matrix element in row 
\begin_inset Formula $A$
\end_inset

 and column 
\begin_inset Formula $A$
\end_inset

 is a function of type 
\begin_inset Formula $A\rightarrow A$
\end_inset

 that corresponds to the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Left(a) => Right(a)
\end_layout

\end_inset

 in the Scala code.
 The matrix element in row 
\begin_inset Formula $A$
\end_inset

 and column 
\begin_inset Formula $B$
\end_inset

 is written as 
\begin_inset Formula $\bbnum 0$
\end_inset

 because no value of that type is returned.
 In this way, we translate all lines of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression into a code matrix.
\end_layout

\begin_layout Standard
The code of 
\begin_inset Formula $f_{2}$
\end_inset

 is written similarly.
 Let us rename arguments for clarity:
\begin_inset space \hfill{}
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: Either[B, A] => Either[A, B] = {
\end_layout

\begin_layout Plain Layout

  case Left(y)    => Right(y)
\end_layout

\begin_layout Plain Layout

  case Right(x)   => Left(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
f_{2}\triangleq\,\begin{array}{|c||cc|}
 & A & B\\
\hline B & \bbnum 0 & y^{:B}\rightarrow y\\
A & x^{:A}\rightarrow x & \bbnum 0
\end{array}\quad.
\]

\end_inset

The forward composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 is computed by the standard rules of row-by-column matrix multiplication.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Matrix_multiplication"

\end_inset


\end_layout

\end_inset

 Any terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

 are omitted, and the remaining functions are composed:
\begin_inset Formula 
\begin{align*}
 & f_{1}\bef f_{2}=\,\begin{array}{|c||cc|}
 & B & A\\
\hline A & \bbnum 0 & a^{:A}\rightarrow a\\
B & b^{:B}\rightarrow b & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & B\\
\hline B & \bbnum 0 & y^{:B}\rightarrow y\\
A & x^{:A}\rightarrow x & \bbnum 0
\end{array}\\
\text{matrix composition}:\quad & =\,\,\begin{array}{|c||cc|}
 & A & B\\
\hline A & \gunderline{(a^{:A}\rightarrow a)\bef(x^{:A}\rightarrow x)} & \bbnum 0\\
B & \bbnum 0 & \gunderline{(b^{:B}\rightarrow b)\bef(y^{:B}\rightarrow y)}
\end{array}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{function composition}:\quad & =\,\begin{array}{|c||cc|}
 & A & B\\
\hline A & \text{id} & \bbnum 0\\
B & \bbnum 0 & \text{id}
\end{array}\,=\text{id}^{:A+B\rightarrow A+B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Several features of the matrix notation are helpful in such calculations.
 The parts of the code of 
\begin_inset Formula $f_{1}$
\end_inset

 are automatically composed with the corresponding parts of the code of
 
\begin_inset Formula $f_{2}$
\end_inset

.
 To check that the types match in the function composition, we just need
 to compare the types in the output row 
\begin_inset Formula $\,\begin{array}{||cc|}
B & A\end{array}\,$
\end_inset

 of 
\begin_inset Formula $f_{1}$
\end_inset

 with the input column 
\begin_inset Formula $\,\begin{array}{|c||}
B\\
A
\end{array}\,$
\end_inset

 of 
\begin_inset Formula $f_{2}$
\end_inset

.
 Once we verified that all types match, we may omit the type annotations
 and write the same derivation more concisely as:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\,\begin{array}{||cc|}
\bbnum 0 & a^{:A}\rightarrow a\\
b^{:B}\rightarrow b & \bbnum 0
\end{array}\,\bef\,\begin{array}{||cc|}
\bbnum 0 & y^{:B}\rightarrow y\\
x^{:A}\rightarrow x & \bbnum 0
\end{array}\\
\text{matrix composition}:\quad & =\,\,\begin{array}{||cc|}
\gunderline{(a^{:A}\rightarrow a)\bef(x^{:A}\rightarrow x)} & \bbnum 0\\
\bbnum 0 & \gunderline{(b^{:B}\rightarrow b)\bef(y^{:B}\rightarrow y)}
\end{array}\\
\text{function composition}:\quad & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset

The identity function is represented by the diagonal matrix: 
\begin_inset Formula $\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}$
\end_inset


\begin_inset space ~
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-AxB"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-AxB"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\times B\cong B\times A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-A+B+C"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-A+B+C"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset

.
 Since Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Logical-identity-not-type-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset

 proved the equivalences 
\begin_inset Formula $\left(A+B\right)+C\cong A+\left(B+C\right)$
\end_inset

 and 
\begin_inset Formula $\left(A\times B\right)\times C\cong A\times\left(B\times C\right)$
\end_inset

, we may write 
\begin_inset Formula $A+B+C$
\end_inset

 and 
\begin_inset Formula $A\times B\times C$
\end_inset

 without any parentheses.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-A+B2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-A+B2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence:
\begin_inset Formula 
\[
\left(A+B\right)\times\left(A+B\right)=A\times A+\bbnum 2\times A\times B+B\times B\quad,
\]

\end_inset

where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type
\begin_inset Index idx
status open

\begin_layout Plain Layout
2@
\begin_inset Formula $\bbnum 2$
\end_inset

 (the 
\family typewriter
Boolean
\family default
 type)
\end_layout

\end_inset

 (which may be defined as 
\begin_inset Formula $\bbnum 2\triangleq\bbnum 1+\bbnum 1$
\end_inset

).
\end_layout

\begin_layout Subsection
Type cardinalities and type equivalence
\end_layout

\begin_layout Standard
To understand why type equivalences are related to arithmetic identities,
 consider the question of how many different values a given type can have.
\end_layout

\begin_layout Standard
Begin by counting the number of distinct values for simple types.
 For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type has only one distinct value; the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has zero values; the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type has two distinct values (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

); and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 has 
\begin_inset Formula $2^{32}$
\end_inset

 distinct values.
\end_layout

\begin_layout Standard
It is more difficult to count the number of distinct values in a type such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, which is equivalent to a list of unknown length, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Char]
\end_layout

\end_inset

.
 However, each computer's memory is limited, so there will exist a maximum
 length for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 So, the total number of possible different strings will be finite (but
 will depend on the computer).
\end_layout

\begin_layout Standard
For a given type 
\begin_inset Formula $A$
\end_inset

, let us denote by 
\begin_inset Formula $\left|A\right|$
\end_inset

 the number of distinct values of type 
\begin_inset Formula $A$
\end_inset

.
 The number 
\begin_inset Formula $\left|A\right|$
\end_inset

 is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
cardinality
\end_layout

\end_inset


\series bold
cardinality
\series default
 of type 
\begin_inset Formula $A$
\end_inset

.
 This is the same as the number of elements in the set of all values of
 type 
\begin_inset Formula $A$
\end_inset

.
 Since any computer's memory is finite, there will be 
\emph on
finitely
\emph default
 many different values of a given type 
\begin_inset Formula $A$
\end_inset

 that can exist in the computer.
 So, we may assume that 
\begin_inset Formula $\left|A\right|$
\end_inset

 is always a finite integer value.
 This assumption will simplify our reasoning.
 We will not actually need to compute the precise number of, say, all the
 different possible strings.
 It is sufficient to know that the set of all strings is finite, so that
 we can denote its cardinality by 
\begin_inset Formula $|\text{String}|$
\end_inset

.
\end_layout

\begin_layout Standard
The next step is to consider the cardinality of types such as 
\begin_inset Formula $A\times B$
\end_inset

 and 
\begin_inset Formula $A+B$
\end_inset

.
 If the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have cardinalities 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

, it follows that the set of all distinct pairs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 has 
\begin_inset Formula $\left|A\right|\times\left|B\right|$
\end_inset

 elements.
 So, the cardinality of the type 
\begin_inset Formula $A\times B$
\end_inset

 is equal to the (arithmetic) product of the cardinalities of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 The set of all pairs, denoted in mathematics by:
\begin_inset Formula 
\[
\left\{ (a,b)\,\,|\,\,a\in A,b\in B\right\} \quad,
\]

\end_inset

is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cartesian product
\end_layout

\end_inset


\series bold
Cartesian product
\series default
 of sets 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, and is denoted by 
\begin_inset Formula $A\times B$
\end_inset

.
 For this reason, the tuple type is also called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
product type
\end_layout

\end_inset


\series bold
product type
\series default
.
 Accordingly, the type notation adopts the symbol 
\begin_inset Formula $\times$
\end_inset

 for the product type.
\end_layout

\begin_layout Standard
The set of all distinct values of the type 
\begin_inset Formula $A+B$
\end_inset

, i.e., of the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, is a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
labeled union
\end_layout

\end_inset

labeled union of the set of values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 and the set of values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(b)
\end_layout

\end_inset

.
 It is clear that the cardinalities of these two sets are equal to 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

 respectively.
 So, the cardinality of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 is equal to 
\begin_inset Formula $\left|A\right|+\left|B\right|$
\end_inset

.
 For this reason, disjunctive types are also called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
sum type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\series bold
sum types
\series default
, and the type notation adopts the symbol 
\begin_inset Formula $+$
\end_inset

 for these types.
\end_layout

\begin_layout Standard
We can write our conclusions as:
\begin_inset Formula 
\begin{align*}
\left|A\times B\right| & =\left|A\right|\times\left|B\right|\quad,\\
\left|A+B\right| & =\left|A\right|+\left|B\right|\quad.
\end{align*}

\end_inset

The type notation, 
\begin_inset Formula $A\times B$
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B)
\end_layout

\end_inset

 and 
\begin_inset Formula $A+B$
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

, translates directly into type cardinalities.
\end_layout

\begin_layout Standard
The last step is to notice that two types can be equivalent, 
\begin_inset Formula $P\cong Q$
\end_inset

, only if their cardinalities are equal, 
\begin_inset Formula $\left|P\right|=\left|Q\right|$
\end_inset

.
 When the cardinalities are not equal, 
\begin_inset Formula $\left|P\right|\neq\left|Q\right|$
\end_inset

, it will be impossible to have a one-to-one correspondence between the
 sets of values of type 
\begin_inset Formula $P$
\end_inset

 and values of type 
\begin_inset Formula $Q$
\end_inset

.
 So, it will be impossible to convert values from type 
\begin_inset Formula $P$
\end_inset

 to type 
\begin_inset Formula $Q$
\end_inset

 and back without loss of information.
\end_layout

\begin_layout Standard
We conclude that types are equivalent when a logical identity 
\emph on
and
\emph default
 an arithmetic identity hold.
\end_layout

\begin_layout Standard
The presence of both identities does not automatically guarantee a useful
 type equivalence.
 The fact that information in one type can be identically stored in another
 type does not necessarily mean that it is helpful to do so in a given applicati
on.
\end_layout

\begin_layout Standard
For example, the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[A]]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Boolean, A]
\end_layout

\end_inset

 are equivalent because both types contain 
\begin_inset Formula $2+\left|A\right|$
\end_inset

 distinct values.
 The short notation for these types is 
\begin_inset Formula $\bbnum 1+\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $\bbnum 2+A$
\end_inset

 respectively.
 The type Boolean is denoted by 
\begin_inset Formula $\bbnum 2$
\end_inset

 since it has only 
\emph on
two
\emph default
 distinct values.
 
\end_layout

\begin_layout Standard
One could write code for converting between these types without loss of
 information:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[Option[A]] => Either[Boolean, A] = {
\end_layout

\begin_layout Plain Layout

  case None           => Left(false) // Or maybe Left(true)?
\end_layout

\begin_layout Plain Layout

  case Some(None)     => Left(true)
\end_layout

\begin_layout Plain Layout

  case Some(Some(x))  => Right(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Boolean, A] => Option[Option[A]] = {
\end_layout

\begin_layout Plain Layout

  case Left(false)    => None
\end_layout

\begin_layout Plain Layout

  case Left(true)     => Some(None)
\end_layout

\begin_layout Plain Layout

  case Right(x)       => Some(Some(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The presence of an arbitrary choice in this code is a warning sign.
 In 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, we could map 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(false)
\end_layout

\end_inset

 or to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(true)
\end_layout

\end_inset

 and adjust the rest of the code accordingly.
 The type equivalence holds with either choice.
 So, these types 
\emph on
are
\emph default
 equivalent, but there is no natural choice of the conversion functions
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 because the meaning of those data types will be application-dependent.
 We call this type equivalence 
\series bold
accidental
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!accidental
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-cardinality-option-either"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-cardinality-option-either"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Are the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 equivalent? Check whether the corresponding logic identity and arithmetic
 identity hold.
\end_layout

\begin_layout Paragraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the given types in the type notation: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is written as 
\begin_inset Formula $\bbnum 1+A$
\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 is written also as 
\begin_inset Formula $\bbnum 1+A$
\end_inset

.
 The notation already indicates that the types are equivalent.
 But let us verify explicitly that the type notation is not misleading us
 here.
\end_layout

\begin_layout Standard
To establish the type equivalence, we need to implement two functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[A] => Either[Unit, A] = ???
\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Unit, A] => Option[A] = ???
\end_layout

\end_inset

These functions must satisfy 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
 It is straightforward to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Option[A] => Either[Unit, A] = {
\end_layout

\begin_layout Plain Layout

  case None      => Left(())
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Right(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A]: Either[Unit, A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Left(())   => None
\end_layout

\begin_layout Plain Layout

  case Right(x)   => Some(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code clearly shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 This verifies the type equivalence.
\end_layout

\begin_layout Standard
The logic identity is 
\begin_inset Formula $True\vee A=True\vee A$
\end_inset

 and holds trivially.
 It remains to check the arithmetic identity, which relates the cardinalities
 of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

.
 Assume that the cardinality of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is 
\begin_inset Formula $\left|A\right|$
\end_inset

.
 Any possible value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, the number of distinct values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 is 
\begin_inset Formula $1+\left|A\right|$
\end_inset

.
 All possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 are of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(())
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(x)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, the cardinality of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 is 
\begin_inset Formula $1+\left|A\right|$
\end_inset

.
 We see that the arithmetic identity holds: the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Unit, A]
\end_layout

\end_inset

 have equally many distinct values.
\end_layout

\begin_layout Standard
This example shows that the type notation is helpful for reasoning about
 type equivalences.
 The answer was found immediately when we wrote the type notation (
\begin_inset Formula $\bbnum 1+A$
\end_inset

) for the given types.
\end_layout

\begin_layout Subsection
Type equivalence involving function types
\end_layout

\begin_layout Standard
Until now, we have looked at product types and disjunctive types.
 We now turn to type constructions involving function types.
\end_layout

\begin_layout Standard
Consider two types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 having known cardinalities 
\begin_inset Formula $\left|A\right|$
\end_inset

 and 
\begin_inset Formula $\left|B\right|$
\end_inset

.
 How many distinct values does the function type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 have? A function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 needs to select a value of type 
\begin_inset Formula $B$
\end_inset

 for each possible value of type 
\begin_inset Formula $A$
\end_inset

.
 Therefore, the number of different functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 is 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 denotes the 
\series bold
numeric exponent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
exponent
\end_layout

\end_inset

, that is, 
\begin_inset Formula $\left|B\right|$
\end_inset

 to the power 
\begin_inset Formula $\left|A\right|$
\end_inset

.
 We use the numeric exponent notation (
\begin_inset Formula $a^{b}$
\end_inset

) only when computing with numbers.
 When denoting types and code, this book uses superscripts for type parameters
 and type annotations.
\end_layout

\begin_layout Standard
For the types 
\begin_inset Formula $A=B=\text{Int}$
\end_inset

, we have 
\begin_inset Formula $\left|A\right|=\left|B\right|=2^{32}$
\end_inset

, and the exponential formula gives:
\begin_inset Formula 
\[
\left|A\rightarrow B\right|=(2^{32})^{\left(2^{32}\right)}=2^{32\times2^{32}}=2^{2^{37}}\approx10^{4.1\times10^{10}}\quad.
\]

\end_inset

This number greatly exceeds the number of atoms in the observable Universe.
\begin_inset Foot
status open

\begin_layout Plain Layout
Estimated in 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.universetoday.com/36302/atoms-in-the-universe/amp/"
literal "false"

\end_inset


\family default
 to be between 
\begin_inset Formula $10^{78}$
\end_inset

 and 
\begin_inset Formula $10^{82}$
\end_inset

.
\end_layout

\end_inset

 However, almost all of those functions will map integers to integers in
 extremely complicated (and practically useless) ways.
 The code of those functions will be much larger than the available memory
 of a realistic computer.
 So, the number of practically implementable functions of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 can be much smaller than 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

.
 Since the code of a function is a string of bytes that needs to fit into
 the computer's memory, the number of implementable functions is no larger
 than the number of possible byte strings.
\end_layout

\begin_layout Standard
Nevertheless, the formula 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 is useful since it shows the number of distinct functions that are possible
 in principle.
 When types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 have only a small number of distinct values (for example, with 
\begin_inset Formula $A=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]]
\end_layout

\end_inset

 and 
\begin_inset Formula $B=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Boolean, Boolean]
\end_layout

\end_inset

), the formula 
\begin_inset Formula $\left|B\right|^{\left|A\right|}$
\end_inset

 gives an exact and practically relevant answer.
\end_layout

\begin_layout Standard
Let us now look for logic identities and arithmetic identities involving
 function types.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 lists the available identities and the corresponding type equivalences.
 (In the last column, we defined 
\begin_inset Formula $a\triangleq\left|A\right|$
\end_inset

, 
\begin_inset Formula $b\triangleq\left|B\right|$
\end_inset

, and 
\begin_inset Formula $c\triangleq\left|C\right|$
\end_inset

 for brevity.) 
\end_layout

\begin_layout Standard
It is notable that no logic identity is available for the formula 
\begin_inset Formula $\alpha\Rightarrow\left(\beta\vee\gamma\right)$
\end_inset

, and correspondingly no type equivalence is available for the type expression
 
\begin_inset Formula $A\rightarrow B+C$
\end_inset

 (although there is an identity for 
\begin_inset Formula $A\rightarrow B\times C$
\end_inset

).
 Reasoning about types of the form 
\begin_inset Formula $A\rightarrow B+C$
\end_inset

 is more complicated because those types usually cannot be rewritten as
 simpler types.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Logical identity (if holds)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Type equivalence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Arithmetic identity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\left(True\Rightarrow\alpha\right)=\alpha$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\bbnum 1\rightarrow A\cong A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $a^{1}=a$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\left(False\Rightarrow\alpha\right)=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\bbnum 0\rightarrow A\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $a^{0}=1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\left(\alpha\Rightarrow True\right)=True$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A\rightarrow\bbnum 1\cong\bbnum 1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $1^{a}=1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\left(\alpha\Rightarrow False\right)\neq False$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A\rightarrow\bbnum 0\not\cong\bbnum 0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $0^{a}\neq0$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\left(\alpha\vee\beta\right)\Rightarrow\gamma=\left(\alpha\Rightarrow\gamma\right)\wedge\left(\beta\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A+B\rightarrow C\cong\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $c^{a+b}=c^{a}\times c^{b}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $(\alpha\wedge\beta)\Rightarrow\gamma=\alpha\Rightarrow\left(\beta\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A\times B\rightarrow C\cong A\rightarrow B\rightarrow C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $c^{a\times b}=(c^{b})^{a}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\alpha\Rightarrow\left(\beta\wedge\gamma\right)=\left(\alpha\Rightarrow\beta\right)\wedge\left(\alpha\Rightarrow\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $A\rightarrow B\times C\cong\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\left(b\times c\right)^{a}=b^{a}\times c^{a}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logical identities with implication, and the corresponding type equivalences
 and arithmetic identities.
\begin_inset CommandInset label
LatexCommand label
name "tab:Logical-identities-with-function-types"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now prove some of the type identities in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-f"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-f"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 1\rightarrow A\cong A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Recall that the type notation 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 means the Scala function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

.
 There is only one value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 The choice of a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

 is the same as the choice of a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, the type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 has 
\begin_inset Formula $\left|A\right|$
\end_inset

 distinct values, and the arithmetic identity holds.
\end_layout

\begin_layout Standard
To verify the type equivalence explicitly, we need to implement two functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: (Unit => A) => A = ???
\end_layout

\begin_layout Plain Layout

def f2[A]: A => Unit => A = ???
\end_layout

\end_inset

The first function needs to produce a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, given an argument of the function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

.
 The only possibility is to apply that function to the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 We produce that value as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: (Unit => A) => A = (h: Unit => A) => h(())
\end_layout

\end_inset

Implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is straightforward.
 We can just discard the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A]: A => Unit => A = (x: A) => _ => x
\end_layout

\end_inset

It remains to show that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are inverses of each other.
 Let us show the proof using Scala code and then using the code notation.
\end_layout

\begin_layout Standard
Writing Scala code, compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(f2(x))
\end_layout

\end_inset

 for an arbitrary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 Using the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f1(f2(x)) == f1(_ => x) == (_ => x)(()) == x
\end_layout

\end_inset

Now compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2(f1(h))
\end_layout

\end_inset

 for arbitrary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h: Unit => A
\end_layout

\end_inset

 in Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f2(f1(h)) == f2(h(())) == { _ => h(()) }
\end_layout

\end_inset

How can we show that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{_ => h(())}
\end_layout

\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

? Whenever we apply equal functions to equal arguments, they return equal
 results.
 In our case, the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, so we only need to verify that the result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 to the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 is the same as the result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{_ => h(())}
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 In other words, we need to apply both sides to an additional argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f2(f1(h))(()) == { _ => h(()) } (()) == h(())
\end_layout

\end_inset

This completes the proof.
\end_layout

\begin_layout Standard
For comparison, let us show the same proof in the code notation.
 The functions 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are:
\begin_inset Formula 
\[
f_{1}\triangleq h^{:\bbnum 1\rightarrow A}\rightarrow h(1)\quad,\quad\quad f_{2}\triangleq x^{:A}\rightarrow1\rightarrow x\quad.
\]

\end_inset

Now write the function compositions in both directions:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & f_{1}\bef f_{2}=(h^{:\bbnum 1\rightarrow A}\rightarrow h(1))\bef(x^{:A}\rightarrow1\rightarrow x)\\
\text{compute composition}:\quad & \quad=h^{:\bbnum 1\rightarrow A}\rightarrow\gunderline{1\rightarrow h(1)}\\
\text{note that }1\rightarrow h(1)\text{ is the same as }h:\quad & \quad=(h^{:\bbnum 1\rightarrow A}\rightarrow h)=\text{id}\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & f_{2}\bef f_{1}=(x^{:A}\rightarrow1\rightarrow x)\bef(h^{:\bbnum 1\rightarrow A}\rightarrow h(1))\\
\text{compute composition}:\quad & \quad=x^{:A}\rightarrow\gunderline{(1\rightarrow x)(1)}\\
\text{apply function}:\quad & \quad=(x^{:A}\rightarrow x)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 is equivalent to the type 
\begin_inset Formula $A$
\end_inset

 in the sense of carrying the same information, but these types are not
 exactly the same.
 An important difference between these types is that a value of type 
\begin_inset Formula $A$
\end_inset

 is available immediately, while a value of type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 is a function that still needs to be applied to an argument (of type 
\begin_inset Formula $\bbnum 1$
\end_inset

) before a value of type 
\begin_inset Formula $A$
\end_inset

 is obtained.
 The type 
\begin_inset Formula $\bbnum 1\rightarrow A$
\end_inset

 may represent an 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
on-call value
\end_layout

\end_inset

 value of type 
\begin_inset Formula $A$
\end_inset

.
 That value is computed on demand every time it is requested.
 (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Lazy-values-iterators-and-streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details about 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset

 values.)
\end_layout

\begin_layout Standard
The void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 
\begin_inset Formula $\bbnum 0$
\end_inset

 needs special reasoning, as the next examples show:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-0-to-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\bbnum 0\rightarrow A\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To verify that a type 
\begin_inset Formula $X$
\end_inset

 is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, we need to show that there is only one distinct value of type 
\begin_inset Formula $X$
\end_inset

.
 So, let us find out how many values the type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

 has.
 Consider a value of that type, which is a function 
\begin_inset Formula $f^{:\bbnum 0\rightarrow A}$
\end_inset

 from the type 
\begin_inset Formula $\bbnum 0$
\end_inset

 to a type 
\begin_inset Formula $A$
\end_inset

.
 Since there exist no values of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, the function 
\begin_inset Formula $f$
\end_inset

 will never be applied to any arguments and so 
\emph on
does not need
\emph default
 to compute any actual values of type 
\begin_inset Formula $A$
\end_inset

.
 So, 
\begin_inset Formula $f$
\end_inset

 is a function whose body may be 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

.
 At least, 
\begin_inset Formula $f$
\end_inset

's body does not need to contain any expressions of type 
\begin_inset Formula $A$
\end_inset

.
 In Scala, such a function can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def absurd[A]: Nothing => A = { ??? }
\end_layout

\end_inset

This code will compile without type errors.
 An equivalent code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def absurd[A]: Nothing => A = { x => ??? }
\end_layout

\end_inset

The symbol 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

???
\end_layout

\end_inset

 is defined in the Scala library and represents code that is 
\begin_inset Quotes eld
\end_inset

not implemented
\begin_inset Quotes erd
\end_inset

.
 Trying to evaluate this symbol will produce an error:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x = ???
\end_layout

\begin_layout Plain Layout

scala.NotImplementedError: an implementation is missing
\end_layout

\end_inset

Since the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd
\end_layout

\end_inset

 can never be applied to an argument, this error will never happen.
 So, one can pretend that the result value (which will never be computed)
 has any required type, e.g., the type 
\begin_inset Formula $A$
\end_inset

.
 In this way, the compiler will accept the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us now verify that there exists 
\emph on
only one
\emph default
 distinct function of type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

.
 Take any two functions of that type, 
\begin_inset Formula $f^{:\bbnum 0\rightarrow A}$
\end_inset

 and 
\begin_inset Formula $g^{:\bbnum 0\rightarrow A}$
\end_inset

.
 Are they different? The only way of showing that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are different is by finding a value 
\begin_inset Formula $x$
\end_inset

 such that 
\begin_inset Formula $f(x)\neq g(x)$
\end_inset

.
 But then 
\begin_inset Formula $x$
\end_inset

 would be of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, and there are 
\emph on
no
\emph default
 
\emph on
values
\emph default
 of type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 So, we will never be able to find the required value 
\begin_inset Formula $x$
\end_inset

.
 It follows that any two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

 are equal, 
\begin_inset Formula $f=g$
\end_inset

.
 In other words, there exists only one distinct value of type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

.
 Since the cardinality of the type 
\begin_inset Formula $\bbnum 0\rightarrow A$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

, we obtain the type equivalence 
\begin_inset Formula $\bbnum 0\rightarrow A\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-A-0"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $A\rightarrow\bbnum 0\not\cong\bbnum 0$
\end_inset

 and 
\begin_inset Formula $A\rightarrow\bbnum 0\not\cong\bbnum 1$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is an arbitrary type.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To prove that two types are 
\emph on
not
\emph default
 equivalent, it is sufficient to show that their cardinalities are different.
 Let us determine the cardinality of the type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

, assuming that the cardinality of 
\begin_inset Formula $A$
\end_inset

 is known.
 We note that a function of type, say, 
\begin_inset Formula $\text{Int}\rightarrow\bbnum 0$
\end_inset

 is impossible to implement.
 (If we had such a function 
\begin_inset Formula $f^{:\text{Int}\rightarrow\bbnum 0}$
\end_inset

, we could evaluate, say, 
\begin_inset Formula $x\triangleq f(123)$
\end_inset

 and obtain a value 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, which is impossible by definition of the type 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 It follows that 
\begin_inset Formula $\left|\text{Int}\rightarrow\bbnum 0\right|=0$
\end_inset

.
 However, Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\bbnum 0\rightarrow\bbnum 0$
\end_inset

 has cardinality 
\begin_inset Formula $1$
\end_inset

.
 So, we find that 
\begin_inset Formula $\left|A\rightarrow\bbnum 0\right|=1$
\end_inset

 if the type 
\begin_inset Formula $A$
\end_inset

 is itself 
\begin_inset Formula $\bbnum 0$
\end_inset

 but 
\begin_inset Formula $\left|A\rightarrow\bbnum 0\right|=0$
\end_inset

 for all other types 
\begin_inset Formula $A$
\end_inset

.
 We conclude that the type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 is not equivalent to 
\begin_inset Formula $\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 1$
\end_inset

 when 
\begin_inset Formula $A$
\end_inset

 is an unknown type.
 The type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 is void for non-void types 
\begin_inset Formula $A$
\end_inset

, and vice versa.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $A\rightarrow\bbnum 1\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
There is only one fully parametric function that returns 
\begin_inset Formula $\bbnum 1$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A]: A => Unit = { _ => () }
\end_layout

\end_inset

The function 
\begin_inset Formula $f$
\end_inset

 must return the fixed value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
 The argument of type 
\begin_inset Formula $A$
\end_inset

 is of no use for that.
 So, the code of 
\begin_inset Formula $f$
\end_inset

 
\emph on
must
\emph default
 discard its argument and return the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 In the code notation, this function is written as:
\begin_inset Formula 
\[
f^{:A\rightarrow\bbnum 1}\triangleq\_\rightarrow1\quad.
\]

\end_inset

We can show that there exists only 
\emph on
one
\emph default
 distinct function of type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 (that is, the type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 has cardinality 
\begin_inset Formula $1$
\end_inset

).
 Assume that 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are two such functions, and try to find a value 
\begin_inset Formula $x^{:A}$
\end_inset

 such that 
\begin_inset Formula $f(x)\neq g(x)$
\end_inset

.
 We cannot find any such 
\begin_inset Formula $x$
\end_inset

 because 
\begin_inset Formula $f(x)=1$
\end_inset

 and 
\begin_inset Formula $g(x)=1$
\end_inset

 for all 
\begin_inset Formula $x$
\end_inset

.
 So, any two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 must be equal to each other.
 The cardinality of the type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Standard
Any type having cardinality 
\begin_inset Formula $1$
\end_inset

 is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type (
\begin_inset Formula $\bbnum 1$
\end_inset

).
 So, 
\begin_inset Formula $A\rightarrow\bbnum 1\cong\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-6-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-6-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Denote by 
\begin_inset Formula $\_^{:A}\rightarrow B$
\end_inset

 the type of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset

constant functions of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 (functions that ignore their argument).
 Show that the type 
\begin_inset Formula $\_^{:A}\rightarrow B$
\end_inset

 is equivalent to the type 
\begin_inset Formula $B$
\end_inset

, as long as 
\begin_inset Formula $A\neq\bbnum 0$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
An isomorphism between the types 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $\_^{:A}\rightarrow B$
\end_inset

 is given by the two functions:
\begin_inset Formula 
\begin{align*}
 & f_{1}:B\rightarrow\_^{:A}\rightarrow B\quad,\quad\quad f_{1}\triangleq b\rightarrow\_\rightarrow b\quad;\\
 & f_{2}:(\_^{:A}\rightarrow B)\rightarrow B\quad,\quad\quad f_{2}\triangleq k^{:\_\rightarrow B}\rightarrow k(x^{:A})\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $x$
\end_inset

 is any value of type 
\begin_inset Formula $A$
\end_inset

.
 That value exists since the type 
\begin_inset Formula $A$
\end_inset

 is not void.
 The function 
\begin_inset Formula $f_{2}$
\end_inset

 does not depend on the choice of 
\begin_inset Formula $x$
\end_inset

 because 
\begin_inset Formula $k$
\end_inset

 is a constant function, so 
\begin_inset Formula $k(x)$
\end_inset

 is the same for all 
\begin_inset Formula $x$
\end_inset

.
 In other words, the function 
\begin_inset Formula $k$
\end_inset

 satisfies 
\begin_inset Formula $k=(\_\rightarrow k(x))$
\end_inset

 with any chosen 
\begin_inset Formula $x$
\end_inset

.
 To prove that 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are inverses:
\begin_inset Formula 
\begin{align*}
 & f_{1}\bef f_{2}=(b\rightarrow\_\rightarrow b)\bef(k\rightarrow k(x))=b\rightarrow(\_\rightarrow b)(x)=(b\rightarrow b)=\text{id}\quad,\\
 & f_{2}\bef f_{1}=(k\rightarrow k(x))\bef(b\rightarrow\_\rightarrow b)=k\rightarrow\_\rightarrow k(x)=k\rightarrow k=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the following type equivalence:
\begin_inset Formula 
\[
A+B\rightarrow C\cong(A\rightarrow C)\times(B\rightarrow C)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing two functions with type signatures:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: (Either[A, B] => C) => (A => C, B => C) = ???
\end_layout

\begin_layout Plain Layout

def f2[A, B, C]: ((A => C, B => C)) => Either[A, B] => C = ???
\end_layout

\end_inset

The code can be derived unambiguously from the type signatures.
 For the first function, we need to produce a pair of functions of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => C, B => C)
\end_layout

\end_inset

.
 Can we produce the first part of that pair? Computing a function of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

 means that we need to produce a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 given an arbitrary value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 The available data is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B] => C
\end_layout

\end_inset

 called, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

.
 We can apply that function to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 and obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 as required.
 So, a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

 is computed as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a => h(Left(a))
\end_layout

\end_inset

.
 We can produce a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

 similarly.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: (Either[A, B] => C) => (A => C, B => C) =
\end_layout

\begin_layout Plain Layout

  (h: Either[A, B] => C) => (a => h(Left(a)), b => h(Right(b)))
\end_layout

\end_inset

We write this function in the code notation like this:
\begin_inset Formula 
\begin{align*}
 & f_{1}:\left(A+B\rightarrow C\right)\rightarrow\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)\quad,\\
 & f_{1}\triangleq h^{:A+B\rightarrow C}\rightarrow\big(a^{:A}\rightarrow h(a+\bbnum 0^{:B})\big)\times\big(b^{:B}\rightarrow h(\bbnum 0^{:A}+b)\big)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
For the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, we need to apply pattern matching to both curried arguments and then return
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 This can be achieved in only one way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B, C](f: A => C, g: B => C): Either[A, B] => C = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => f(a)
\end_layout

\begin_layout Plain Layout

  case Right(b)   => g(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We write this function in the code notation like this:
\begin_inset Formula 
\begin{align*}
 & f_{2}:\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)\rightarrow A+B\rightarrow C\quad,\\
 & f_{2}\triangleq f^{:A\rightarrow C}\times g^{:B\rightarrow C}\rightarrow\,\begin{array}{|c||c|}
 & C\\
\hline A & a\rightarrow f(a)\\
B & b\rightarrow g(b)
\end{array}\quad.
\end{align*}

\end_inset

The matrix in the last line has only one column because the result type,
 
\begin_inset Formula $C$
\end_inset

, is not known to be a disjunctive type.
 We may also simplify the functions, e.g., replace 
\begin_inset Formula $a\rightarrow f(a)$
\end_inset

 by just 
\begin_inset Formula $f$
\end_inset

, and write:
\begin_inset Formula 
\[
f_{2}\triangleq f^{:A\rightarrow C}\times g^{:B\rightarrow C}\rightarrow\,\begin{array}{|c||c|}
 & C\\
\hline A & f\\
B & g
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 and 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

.
 To compute 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

, we write (omitting types):
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2}= & \big(h\rightarrow(a\rightarrow h(a+\bbnum 0))\times(b\rightarrow h(\bbnum 0+b))\big)\bef\bigg(f\times g\rightarrow\,\begin{array}{||c|}
f\\
g
\end{array}\,\bigg)\\
\text{compute composition}:\quad & =h\rightarrow\,\begin{array}{||c|}
a\rightarrow h(a+\bbnum 0)\\
b\rightarrow h(\bbnum 0+b)
\end{array}\quad.
\end{align*}

\end_inset

To proceed, we need to simplify the expressions 
\begin_inset Formula $h(a+\bbnum 0)$
\end_inset

 and 
\begin_inset Formula $h(\bbnum 0+b)$
\end_inset

.
 We rewrite the argument 
\begin_inset Formula $h$
\end_inset

 (an arbitrary function of type 
\begin_inset Formula $A+B\rightarrow C$
\end_inset

) in the matrix notation:
\begin_inset Formula 
\[
h\triangleq\,\begin{array}{|c||c|}
 & C\\
\hline A & a\rightarrow p(a)\\
B & b\rightarrow q(b)
\end{array}\,=\,\begin{array}{|c||c|}
 & C\\
\hline A & p\\
B & q
\end{array}\quad,
\]

\end_inset

where 
\begin_inset Formula $p^{:A\rightarrow C}$
\end_inset

 and 
\begin_inset Formula $q^{:B\rightarrow C}$
\end_inset

 are new arbitrary functions.
 Since we already checked the types, we can omit all type annotations and
 write 
\begin_inset Formula $h$
\end_inset

 as:
\begin_inset Formula 
\[
h\triangleq\,\begin{array}{||c|}
p\\
q
\end{array}\quad.
\]

\end_inset

To evaluate expressions such as 
\begin_inset Formula $h(a+\bbnum 0)$
\end_inset

 and 
\begin_inset Formula $h(\bbnum 0+b)$
\end_inset

, we need to use one of the rows of this matrix.
 The correct row will be selected 
\emph on
automatically
\emph default
 by the rules of matrix multiplication if we place a row vector to the left
 of the matrix and use the convention of omitting terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=a\triangleright p\quad,\quad\quad\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=b\triangleright q\quad.
\]

\end_inset

Here we used the symbol 
\begin_inset Formula $\triangleright$
\end_inset

 to separate an argument from a function when the argument is written to
 the 
\emph on
left
\emph default
 of the function.
 The symbol 
\begin_inset Formula $\triangleright$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
0@
\begin_inset Formula $\triangleright$
\end_inset

-notation!see 
\begin_inset Quotes eld
\end_inset

pipe notation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

) is defined by 
\begin_inset Formula $x\triangleright f\triangleq f(x)$
\end_inset

.
 In Scala, this operation is available as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 as of Scala 2.13.
\end_layout

\begin_layout Standard
We can write values of disjunctive types, such as 
\begin_inset Formula $a+\bbnum 0$
\end_inset

, as row vectors 
\begin_inset Formula $\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,$
\end_inset

:
\begin_inset Formula 
\begin{equation}
h(a+\bbnum 0)=(a+\bbnum 0)\triangleright h=\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,h\quad.\label{eq:forward-notation-}
\end{equation}

\end_inset

With these notations, we compute further.
 Omit all terms applying 
\begin_inset Formula $\bbnum 0$
\end_inset

 or applying something to 
\begin_inset Formula $\bbnum 0$
\end_inset

:
\begin_inset Formula 
\[
h(a+\bbnum 0)=\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,h=\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=a\triangleright p=p(a)\quad,
\]

\end_inset


\begin_inset Formula 
\[
h(\bbnum 0+b)=\,\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,h=\,\,\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\,=b\triangleright q=q(b)\quad.
\]

\end_inset

Now we can complete the proof of 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f_{1}\bef f_{2}=h\rightarrow\,\begin{array}{||c|}
a\rightarrow h(a+\bbnum 0)\\
b\rightarrow h(\bbnum 0+b)
\end{array}\\
\text{previous equations}:\quad & =\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
a\rightarrow p(a)\\
b\rightarrow q(b)
\end{array}\\
\text{simplify functions}:\quad & =\,\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
p\\
q
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To prove that 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

, use the notation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:forward-notation-"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
f_{2}\bef f_{1}= & \bigg(f\times g\rightarrow\,\begin{array}{||c|}
f\\
g
\end{array}\,\bigg)\bef\big(h\rightarrow(a\rightarrow(a+\bbnum 0)\triangleright h)\times(b\rightarrow(\bbnum 0+b)\triangleright h)\big)\\
\text{composition}:\quad & =f\times g\rightarrow\big(a\rightarrow\gunderline{\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\,\triangleright}\,\begin{array}{||c|}
f\\
g
\end{array}\,\big)\times\big(b\rightarrow\gunderline{\,\begin{array}{|cc|}
\bbnum 0 & b\end{array}\,\,\triangleright}\,\begin{array}{||c|}
f\\
g
\end{array}\,\big)\\
\text{apply functions}:\quad & =f\times g\rightarrow(a\rightarrow\gunderline{a\triangleright f})\times(b\rightarrow\gunderline{b\triangleright g})\\
\text{definition of }\triangleright:\quad & =f\times g\rightarrow\gunderline{\left(a\rightarrow f(a)\right)}\times\gunderline{\left(b\rightarrow g(b)\right)}\\
\text{simplify functions}:\quad & =\left(f\times g\rightarrow f\times g\right)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In this way, we have proved that 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 are mutual inverses.
 The proofs appear long because we took time to motivate and introduce new
 notation for applying matrices to row vectors.
 Once this notation is understood, a proof of 
\begin_inset Formula $f_{1}\bef f_{2}=\text{id}$
\end_inset

 can be written as:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(h\rightarrow(a\rightarrow(a+\bbnum 0)\triangleright h)\times(b\rightarrow(\bbnum 0+b)\triangleright h)\right)\bef\bigg(f\times g\rightarrow\,\begin{array}{||c|}
f\\
g
\end{array}\bigg)\\
\text{composition}:\quad & =h\rightarrow\,\begin{array}{||c|}
\,a\,\rightarrow\,\left|\begin{array}{cc}
a & \bbnum 0\end{array}\right|\triangleright h\\
b\rightarrow\left|\begin{array}{cc}
\bbnum 0 & b\end{array}\right|\triangleright h
\end{array}\,=\,\begin{array}{||c|}
p\\
q
\end{array}\rightarrow\,\begin{array}{||c|}
a\rightarrow\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}\\
b\,\rightarrow\,\begin{array}{|cc|}
\bbnum 0 & b\,\,\end{array}\,\triangleright\,\begin{array}{||c|}
p\\
q
\end{array}
\end{array}\\
\text{apply functions}:\quad & =\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
a\rightarrow a\triangleright p\\
b\rightarrow b\triangleright q
\end{array}\,=\,\begin{array}{||c|}
p\\
q
\end{array}\,\rightarrow\,\begin{array}{||c|}
p\\
q
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset

Proofs in the code notation are shorter than in Scala syntax because certain
 names and keywords (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

, etc.) are omitted.
 From now on, we will prefer to use the code notation in proofs, keeping
 in mind that one can always convert the code notation to Scala.
\end_layout

\begin_layout Standard
Note that the function arrow (
\begin_inset Formula $\rightarrow$
\end_inset

) binds weaker than the pipe operation (
\begin_inset Formula $\triangleright$
\end_inset

), so the code notation 
\begin_inset Formula $x\rightarrow y\triangleright z$
\end_inset

 means 
\begin_inset Formula $x\rightarrow(y\triangleright z)$
\end_inset

.
 We will review the code notation more systematically in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Reasoning-about-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Example-type-identity-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence:
\begin_inset Formula 
\[
A\times B\rightarrow C\cong A\rightarrow B\rightarrow C\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the two functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: (((A, B)) => C) => A => B => C = ???
\end_layout

\begin_layout Plain Layout

def f2[A, B, C]: (A => B => C) => ((A, B)) => C = ???
\end_layout

\end_inset

The Scala code can be derived from the type signatures unambiguously:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A,B,C]: (((A, B)) => C) => A => B => C = g => a => b => g((a, b))
\end_layout

\begin_layout Plain Layout

def f2[A,B,C]: (A => B => C) => ((A, B)) => C = h => { case (a, b) => h(a)(b)
 }
\end_layout

\end_inset

Write these functions in the code notation:
\begin_inset Formula 
\begin{align*}
 & f_{1}=g^{:A\times B\rightarrow C}\rightarrow a^{:A}\rightarrow b^{:B}\rightarrow g(a\times b)\quad,\\
 & f_{2}=h^{:A\rightarrow B\rightarrow C}\rightarrow\left(a\times b\right)^{:A\times B}\rightarrow h(a)(b)\quad.
\end{align*}

\end_inset

We denote by 
\begin_inset Formula $\left(a\times b\right)^{:A\times B}$
\end_inset

 the argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 with pattern matching implied.
 This notation allows us to write shorter code formulas involving tupled
 arguments.
\end_layout

\begin_layout Standard
Compute the function composition 
\begin_inset Formula $f_{1}\bef f_{2}$
\end_inset

 and show that it is equal to an identity function:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & f_{1}\bef f_{2}=(g\rightarrow\gunderline{a\rightarrow b\rightarrow g(a\times b)})\bef\left(h\rightarrow a\times b\rightarrow h(a)(b)\right)\\
\text{composition}:\quad & \quad=g\rightarrow\gunderline{a\times b\rightarrow g(a\times b)}\\
\text{simplify function}:\quad & \quad=\left(g\rightarrow g\right)=\text{id}\quad.
\end{align*}

\end_inset

Compute the function composition 
\begin_inset Formula $f_{2}\bef f_{1}$
\end_inset

 and show that it is equal to an identity function:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & f_{2}\bef f_{1}=(h\rightarrow\gunderline{a\times b\rightarrow h(a)(b)})\bef\left(g\rightarrow a\rightarrow b\rightarrow g(a\times b)\right)\\
\text{composition}:\quad & \quad=h\rightarrow a\rightarrow\gunderline{b\rightarrow h(a)(b)}\\
\text{simplify }b\rightarrow h(a)(b):\quad & \quad=h\rightarrow\gunderline{a\rightarrow h(a)}\\
\text{simplify }a\rightarrow h(a)\text{ to }h:\quad & \quad=\left(h\rightarrow h\right)=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What tasks can we perform now?
\end_layout

\begin_layout Itemize
Convert a fully parametric type signature into a logical formula and:
\end_layout

\begin_deeper
\begin_layout Itemize
Decide whether the type signature can be implemented in code.
\end_layout

\begin_layout Itemize
If possible, derive the code using the CH correspondence.
\end_layout

\end_deeper
\begin_layout Itemize
Use the type notation (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ch-correspondence-type-notation-CH-propositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for reasoning about types to:
\end_layout

\begin_deeper
\begin_layout Itemize
Decide type equivalence using the rules in Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

â€“
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Itemize
Simplify type expressions before writing code.
\end_layout

\end_deeper
\begin_layout Itemize
Use the matrix notation and the pipe notation to write code that works on
 disjunctive types.
\end_layout

\begin_layout Standard
What tasks 
\emph on
cannot
\emph default
 be performed with these tools?
\end_layout

\begin_layout Itemize
Automatically generate code for 
\emph on
recursive
\emph default
 functions.
 The CH correspondence is based on propositional logic, which cannot describe
 recursion.
 Accordingly, recursion is absent from the eight code constructions of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Recursive functions need to be coded by hand.
\end_layout

\begin_layout Itemize
Automatically generate code satisfying a property (e.g., isomorphism).
 We may generate some code, but the CH correspondence does not guarantee
 that properties will hold.
 We need to verify the required properties manually, after deriving the
 code.
\end_layout

\begin_layout Itemize
Express complicated conditions (e.g., 
\begin_inset Quotes eld
\end_inset

array is sorted
\begin_inset Quotes erd
\end_inset

) in a type signature.
 This can be done using 
\series bold
dependent types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent type
\end_layout

\end_inset

 (i.e., types that directly depend on values in some way).
 This is an advanced technique beyond the scope of this book.
 Programming languages such as Coq, Agda, and Idris fully support dependent
 types, while Scala has only limited support.
\end_layout

\begin_layout Itemize
Generate code using type constructors with known methods (e.g., the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method).
\end_layout

\begin_layout Standard
As an example of using type constructors with known methods, consider this
 type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A]: Array[A] => (A => Option[B]) => Array[Option[B]]
\end_layout

\end_inset

Can we generate the code of this function from its type signature? We know
 that the Scala library defines a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 class.
 So, an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A]: Array[A] => (A => Option[B]) => Array[Option[B]] = { arr => f
 => arr.map(f) }
\end_layout

\end_inset

However, it is hard to create an 
\emph on
algorithm
\emph default
 that can derive this implementation automatically from the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 via the Curry-Howard correspondence.
 The algorithm would have to convert the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 into this logical formula:
\begin_inset Formula 
\begin{equation}
{\cal CH}(\text{Array}^{A})\Rightarrow{\cal CH}(A\rightarrow\text{Opt}^{B})\Rightarrow{\cal CH}(\text{Array}^{\text{Opt}^{B}})\quad.\label{eq:ch-example-quantified-proposition}
\end{equation}

\end_inset

To derive an implementation, the algorithm would need to use the available
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

.
 That method has the type signature:
\begin_inset Formula 
\[
\text{map}:\forall(A,B).\,\text{Array}^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Array}^{B}\quad.
\]

\end_inset

To derive the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the algorithm will need to assume that the 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition:
\begin_inset Formula 
\begin{equation}
{\cal CH}\,\big(\forall(A,B).\,\text{Array}^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Array}^{B}\big)\label{eq:ch-example-quantified-proposition-2}
\end{equation}

\end_inset

already holds.
 In other words, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) must be one of the premises of a sequent.
 Reasoning about premises such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-quantified-proposition-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) requires 
\begin_inset Index idx
status open

\begin_layout Plain Layout
first-order logic
\end_layout

\end_inset


\series bold
first-order logic
\series default
 â€” a logic whose proof rules can handle quantified types such as 
\begin_inset Formula $\forall(A,B)$
\end_inset


\emph on
 
\emph default
inside premises.
 However, first-order logic is 
\series bold
undecidable
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
undecidable logic
\end_layout

\end_inset

: no algorithm can find a proof (or verify the absence of a proof) in all
 cases.
 
\end_layout

\begin_layout Standard
The constructive propositional logic with the rules listed in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is 
\series bold
decidable
\series default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
decidable logic
\end_layout

\end_inset

 i.e., it has an algorithm that either finds a proof or disproves any given
 formula.
 However, that logic cannot handle type constructors such as 
\begin_inset Formula $\text{Array}^{A}$
\end_inset

.
 It also cannot handle premises containing type quantifiers such as 
\begin_inset Formula $\forall(A,B)$
\end_inset

, because all the available logic rules have the quantifiers placed 
\emph on
outside
\emph default
 the premises.
 
\end_layout

\begin_layout Standard
So, code for functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 can only be derived by trial and error, informed by intuition.
 This book will help programmers to acquire the necessary intuition and
 technique.
\end_layout

\begin_layout Subsection
Examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the cardinality of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Option[Option[Boolean] => Boolean]
\end_layout

\end_inset

.
 Write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 in the type notation.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin with the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

, which can be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

 with some value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: Boolean
\end_layout

\end_inset

.
 Because the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 has 
\begin_inset Formula $2$
\end_inset

 possible values, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

 has 
\begin_inset Formula $3$
\end_inset

 possible values:
\begin_inset Formula 
\[
|\text{Opt}^{\text{Boolean}}|=\left|\bbnum 1+\text{Boolean}\right|=1+\left|\text{Boolean}\right|=1+2=3\quad.
\]

\end_inset

In the type notation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 is denoted by the symbol 
\begin_inset Formula $\bbnum 2$
\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean]
\end_layout

\end_inset

 by 
\begin_inset Formula $\bbnum 1+\bbnum 2$
\end_inset

.
 So, the type notation 
\begin_inset Formula $\bbnum 1+\bbnum 2$
\end_inset

 is consistent with the cardinality 
\begin_inset Formula $3$
\end_inset

 of that type:
\begin_inset Formula 
\[
\left|\bbnum 1+\text{Boolean}\right|=\left|\bbnum 1+\bbnum 2\right|=1+2=3\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean] => Boolean
\end_layout

\end_inset

 is denoted by 
\begin_inset Formula $\bbnum 1+\bbnum 2\rightarrow\bbnum 2$
\end_inset

.
 Compute its cardinality as:
\begin_inset Formula 
\[
|\text{Opt}^{\text{Boolean}}\rightarrow\text{Boolean}|=\left|\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right|=\left|\bbnum 2\right|^{\left|\bbnum 1+\bbnum 2\right|}=2^{3}=8\quad.
\]

\end_inset

Finally, the we write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 in the type notation as 
\begin_inset Formula $P=\bbnum 1+\left(\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right)$
\end_inset

 and find:
\begin_inset Formula 
\[
\left|P\right|=\left|\bbnum 1+\left(\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right)\right|=1+\left|\bbnum 1+\bbnum 2\rightarrow\bbnum 2\right|=1+8=9\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A]
\end_layout

\end_inset

 given by this type notation:
\begin_inset Formula 
\[
P^{A}\triangleq1+A+\text{Int}\times A+(\text{String}\rightarrow A)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To translate type notation into Scala code, begin by defining the disjunctive
 types as case classes, choosing class names for convenience.
 In this case, 
\begin_inset Formula $P^{A}$
\end_inset

 is a disjunctive type with four parts, so we need four case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](???) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P4[A](???) extends P[A]
\end_layout

\end_inset

Each of the case classes represents one part of the disjunctive type.
 Now we write the contents for each of the case classes, in order to implement
 the data in each of the disjunctive parts:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A]()                 extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](x: A)             extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](n: Int, x: A)     extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P4[A](f: String => A)   extends P[A]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-2a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find an equivalent disjunctive type for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = (Either[A, B], Either[C, D])
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by writing the given type in the type notation.
 The tuple becomes a product type, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 becomes a disjunctive type:
\begin_inset Formula 
\[
P\triangleq(A+B)\times(C+D)\quad.
\]

\end_inset

By the usual rules of arithmetic, we expand brackets and obtain an equivalent
 type:
\begin_inset Formula 
\[
P\cong A\times C+A\times D+B\times C+B\times D\quad.
\]

\end_inset

This is a disjunctive type with 
\begin_inset Formula $4$
\end_inset

 parts.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following type equivalences do 
\emph on
not
\emph default
 hold: 
\begin_inset Formula $A+A\not\cong A$
\end_inset

 and 
\begin_inset Formula $A\times A\not\cong A$
\end_inset

, although the corresponding logical identities hold.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The arithmetic equalities do not hold, 
\begin_inset Formula $A+A\neq A$
\end_inset

 and 
\begin_inset Formula $A\times A\ne A$
\end_inset

.
 This already indicates that the types are not equivalent.
 To build further intuition, consider that a value of type 
\begin_inset Formula $A+A$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

) is a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a:A
\end_layout

\end_inset

.
 In the code notation, it is either 
\begin_inset Formula $a^{:A}+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+a^{:A}$
\end_inset

.
 So, a value of type 
\begin_inset Formula $A+A$
\end_inset

 contains a value of type 
\begin_inset Formula $A$
\end_inset

 with the additional information about whether it is the first or the second
 part of the disjunctive type.
 We cannot represent that information in a single value of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
Similarly, a value of type 
\begin_inset Formula $A\times A$
\end_inset

 contains two (possibly different) values of type 
\begin_inset Formula $A$
\end_inset

, which cannot be represented by a single value of type 
\begin_inset Formula $A$
\end_inset

 without loss of information.
\end_layout

\begin_layout Standard
However, the corresponding logical identities 
\begin_inset Formula $\alpha\vee\alpha=\alpha$
\end_inset

 and 
\begin_inset Formula $\alpha\wedge\alpha=\alpha$
\end_inset

 hold.
 To see that, we could derive the four formulas:
\begin_inset Formula 
\[
\alpha\vee\alpha\Rightarrow\alpha\quad,\quad\quad\alpha\Rightarrow\alpha\vee\alpha\quad,\quad\quad\alpha\wedge\alpha\Rightarrow\alpha\quad,\quad\quad\alpha\Rightarrow\alpha\wedge\alpha\quad,
\]

\end_inset

using the proof rules of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Alternatively, we may use the CH correspondence and show that the type
 signatures:
\begin_inset Formula 
\[
\forall A.\,A+A\rightarrow A\quad,\quad\quad\forall A.\,A\rightarrow A+A\quad,\quad\quad\forall A.\,A\times A\rightarrow A\quad,\quad\quad\forall A.\,A\rightarrow A\times A\quad
\]

\end_inset

can be implemented via fully parametric functions.
 For a programmer, it is easier to write code than to guess the correct
 sequence of proof rules.
 For the first pair of type signatures, we find:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: Either[A, A] => A = {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => a   // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right(a)   => a   // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def f2[A]: A => Either[A, A] = { a => Left(a) } // Can be also Right(a).
\end_layout

\end_inset

The presence of an arbitrary choice, to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(a)
\end_layout

\end_inset

, is a warning sign showing that additional information is required to create
 a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

.
 This is precisely the information present in the type 
\begin_inset Formula $A+A$
\end_inset

 but missing in the type 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
The code notation for these functions is:
\begin_inset Formula 
\begin{align*}
f_{1} & \triangleq\,\begin{array}{|c||c|}
 & A\\
\hline A & a^{:A}\rightarrow a\\
A & a^{:A}\rightarrow a
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\quad,\\
f_{2} & \triangleq a^{:A}\rightarrow a+\bbnum 0^{:A}=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & a^{:A}\rightarrow a & \bbnum 0
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & \text{id} & \bbnum 0
\end{array}\quad.
\end{align*}

\end_inset

The composition of these functions is 
\emph on
not
\emph default
 equal to identity:
\begin_inset Formula 
\[
f_{1}\bef f_{2}=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\text{id} & \bbnum 0
\end{array}\,\quad,\quad\text{while we have}\quad\text{id}^{:A+A\rightarrow A+A}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
For the second pair of type signatures, the code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A]: ((A, A)) => A = { case (a1, a2) => a1 }   // Could be also `a2`.
\end_layout

\begin_layout Plain Layout

cef f2[A]: A => (A, A)   = { a => (a, a) }           // No other choice
 here.
\end_layout

\end_inset

It is clear that the first function loses information when it returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a1
\end_layout

\end_inset

 and discards 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a2
\end_layout

\end_inset

 (or vice versa).
\end_layout

\begin_layout Standard
The code notation for the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
f_{1}\triangleq a_{1}^{:A}\times a_{2}^{:A}\rightarrow a_{1}=\pi_{1}^{:A\times A\rightarrow A}\quad,\quad\quad f_{2}\triangleq a^{:A}\rightarrow a\times a=\Delta^{:A\rightarrow A\times A}\quad.
\]

\end_inset

Computing the compositions of these functions, we find that 
\begin_inset Formula $f_{2}\bef f_{1}=\text{id}$
\end_inset

 while 
\begin_inset Formula $f_{1}\bef f_{2}\ne\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
f_{1}\bef f_{2} & =\left(a_{1}\times a_{2}\rightarrow a_{1}\right)\bef\left(a\rightarrow a\times a\right)\\
 & =\left(a_{1}\times a_{2}\rightarrow a_{1}\times a_{1}\right)\neq\text{id}=\left(a_{1}\times a_{2}\rightarrow a_{1}\times a_{2}\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We have implemented all four type signatures as fully parametric functions,
 which shows that the corresponding logical formulas are all true (i.e., can
 be derived using the proof rules).
 However, the functions cannot be inverses of each other.
 So, the type equivalences do not hold.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $\left(\left(A\wedge B\right)\Rightarrow C\right)\neq(A\Rightarrow C)\vee(B\Rightarrow C)$
\end_inset

 in the constructive logic, but the equality holds in Boolean logic.
 This is another example where the Boolean reasoning fails to give correct
 answers about implementability of type signatures.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by rewriting the logical equality as two implications:
\begin_inset Formula 
\begin{align*}
(A\wedge B & \Rightarrow C)\Rightarrow(A\Rightarrow C)\vee(B\Rightarrow C)\\
\quad\text{ and }\quad & \left((A\Rightarrow C)\vee(B\Rightarrow C)\right)\Rightarrow\left(\left(A\wedge B\right)\Rightarrow C\right)\quad.
\end{align*}

\end_inset

It is sufficient to show that one of these implications is incorrect.
 Rather than looking for a proof tree in the constructive logic (which would
 be difficult, since we need to demonstrate that 
\emph on
no
\emph default
 proof exists), let us use the CH correspondence.
 According to the CH correspondence, an equivalent task is to implement
 fully parametric functions with the type signatures:
\begin_inset Formula 
\[
(A\times B\rightarrow C)\rightarrow(A\rightarrow C)+(B\rightarrow C)\quad\text{ and }\quad(A\rightarrow C)+(B\rightarrow C)\rightarrow A\times B\rightarrow C\quad.
\]

\end_inset

For the first type signature, the Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B, C]: (((A, B)) => C) => Either[A => C, B => C] = { k => ???
 }
\end_layout

\end_inset

We are required to return either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(g)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: A => C
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(h)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h: B => C
\end_layout

\end_inset

.
 The only given data is a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 of type 
\begin_inset Formula $A\times B\rightarrow C$
\end_inset

, so the decision of whether to return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 must be hard-coded in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 independently of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

.
 Can we produce a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

? Given a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we would need to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 The only way to obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 to some arguments.
 But to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

, we need a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, which we do not have.
 So, we cannot produce a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: A => C
\end_layout

\end_inset

.
 Similarly, we cannot produce a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We repeat the same argument in the type notation.
 Obtaining a value of type 
\begin_inset Formula $(A\rightarrow C)+(B\rightarrow C)$
\end_inset

 means to compute either 
\begin_inset Formula $g^{:A\rightarrow C}+\bbnum 0$
\end_inset

 or 
\begin_inset Formula $\bbnum 0+h^{:B\rightarrow C}$
\end_inset

.
 This decision must be hard-coded since the only data is a function 
\begin_inset Formula $k^{:A\times B\rightarrow C}$
\end_inset

.
 We can compute 
\begin_inset Formula $g^{:A\rightarrow C}$
\end_inset

 only by partially applying 
\begin_inset Formula $k^{:A\times B\rightarrow C}$
\end_inset

 to a value of type 
\begin_inset Formula $B$
\end_inset

.
 However, we have no values of type 
\begin_inset Formula $B$
\end_inset

.
 Similarly, we cannot compute a value 
\begin_inset Formula $h^{:B\rightarrow C}$
\end_inset

.
\end_layout

\begin_layout Standard
The inverse type signature 
\emph on
can
\emph default
 be implemented:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B, C]: Either[A => C, B => C] => ((A, B)) => C = {
\end_layout

\begin_layout Plain Layout

  case Left(g)    =>  { case (a, b) => g(a) }
\end_layout

\begin_layout Plain Layout

  case Right(h)   =>  { case (a, b) => h(b) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
f_{2}\triangleq\,\begin{array}{|c||c|}
 & A\times B\rightarrow C\\
\hline A\rightarrow C & g^{:A\rightarrow C}\rightarrow a\times b\rightarrow g(a)\\
B\rightarrow C & h^{:B\rightarrow C}\rightarrow a\times b\rightarrow h(b)
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Let us now show that the logical identity:
\begin_inset Formula 
\begin{equation}
((\alpha\wedge\beta)\Rightarrow\gamma)=((\alpha\Rightarrow\gamma)\vee(\beta\Rightarrow\gamma))\label{eq:ch-example-identity-boolean-not-constructive}
\end{equation}

\end_inset

holds in Boolean logic.
 A straightforward calculation is to simplify the Boolean expression using
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which only holds in Boolean logic (but not in the constructive logic).
 We find:
\begin_inset Formula 
\begin{align*}
\text{left-hand side of Eq.~(\ref{eq:ch-example-identity-boolean-not-constructive})}:\quad & \left(\alpha\wedge\beta\right)\gunderline{\Rightarrow}\,\gamma\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=\gunderline{\neg(\alpha\wedge\beta)}\vee\gamma\\
\text{use de Morgan's law}:\quad & \quad=\neg\alpha\vee\neg\beta\vee\gamma\quad.\\
\text{right-hand side of Eq.~(\ref{eq:ch-example-identity-boolean-not-constructive})}:\quad & (\gunderline{\alpha\Rightarrow\gamma})\vee(\gunderline{\beta\Rightarrow\gamma})\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & \quad=\neg\alpha\vee\gunderline{\gamma}\vee\neg\beta\vee\gunderline{\gamma}\\
\text{use identity }\gamma\vee\gamma=\gamma:\quad & \quad=\neg\alpha\vee\neg\beta\vee\gamma\quad.
\end{align*}

\end_inset

Both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are equal to the same formula, 
\begin_inset Formula $\neg\alpha\vee\neg\beta\vee\gamma$
\end_inset

, so the identity holds.
\end_layout

\begin_layout Standard
This calculation does not work in the constructive logic because its proof
 rules can derive neither the Boolean formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-definition-of-implication-in-Boolean-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

) nor the 
\series bold
law of de Morgan
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
law of de Morgan
\end_layout

\end_inset

, 
\begin_inset Formula $\neg(\alpha\wedge\beta)=\left(\neg\alpha\vee\neg\beta\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Another way of proving the Boolean identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is to enumerate all possible truth values for the variables 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

.
 The left-hand side, 
\begin_inset Formula $\left(\alpha\wedge\beta\right)\Rightarrow\gamma$
\end_inset

, can be 
\begin_inset Formula $False$
\end_inset

 only if 
\begin_inset Formula $\alpha\wedge\beta=True$
\end_inset

 (that is, both 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 are 
\begin_inset Formula $True$
\end_inset

) and 
\begin_inset Formula $\gamma=False$
\end_inset

.
 For all other truth values of 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

, the formula 
\begin_inset Formula $\left(\alpha\wedge\beta\right)\Rightarrow\gamma$
\end_inset

 is 
\begin_inset Formula $True$
\end_inset

.
 Let us determine when the right-hand side, 
\begin_inset Formula $(\alpha\Rightarrow\gamma)\vee(\beta\Rightarrow\gamma)$
\end_inset

, can be 
\begin_inset Formula $False$
\end_inset

.
 This can happen only if both parts of the disjunction are 
\begin_inset Formula $False$
\end_inset

.
 That means 
\begin_inset Formula $\alpha=True$
\end_inset

, 
\begin_inset Formula $\beta=True$
\end_inset

, and 
\begin_inset Formula $\gamma=False$
\end_inset

.
 So, the two sides of the identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are both 
\begin_inset Formula $True$
\end_inset

 or both 
\begin_inset Formula $False$
\end_inset

 with any choice of truth values of 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

, and 
\begin_inset Formula $\gamma$
\end_inset

.
 In Boolean logic, this is sufficient to prove the identity
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-identity-boolean-not-constructive"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The following example shows how to use the formulas from Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-disjunction-and-conjunction"
plural "false"
caps "false"
noprefix "false"

\end_inset

â€“
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-identities-with-function-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to derive the type equivalence of complicated type expressions without
 need for proofs.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known formulas to verify the type equivalences without direct proofs:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $A\times\left(A+\bbnum 1\right)\times\left(A+\bbnum 1+\bbnum 1\right)\cong A\times\left(\bbnum 1+\bbnum 1+A\times\left(\bbnum 1+\bbnum 1+\bbnum 1+A\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\bbnum 1+A+B\rightarrow\bbnum 1\times B\cong\left(B\rightarrow B\right)\times\left(A\rightarrow B\right)\times B$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We can expand brackets in type expressions as in arithmetic:
\begin_inset Formula 
\begin{align*}
A\times\left(A+\bbnum 1\right) & \cong A\times A+A\times\bbnum 1\cong A\times A+A\quad,\\
A\times\left(A+\bbnum 1\right)\times\left(A+\bbnum 1+\bbnum 1\right) & \cong\left(A\times A+A\right)\times\left(A+\bbnum 1+\bbnum 1\right)\\
 & \cong A\times A\times A+A\times A+A\times A\times\left(\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\\
 & \cong A\times A\times A+A\times A\times\left(\bbnum 1+\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\quad.
\end{align*}

\end_inset

The result looks like a polynomial in 
\begin_inset Formula $A$
\end_inset

, which we can now rearrange into the required form:
\begin_inset Formula 
\[
A\times A\times A+A\times A\times\left(\bbnum 1+\bbnum 1+\bbnum 1\right)+A\times\left(\bbnum 1+\bbnum 1\right)\cong A\times\left(\bbnum 1+\bbnum 1+A\times\left(\bbnum 1+\bbnum 1+\bbnum 1+A\right)\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Keep in mind that the conventions of the type notation make the function
 arrow 
\begin_inset Formula $\left(\rightarrow\right)$
\end_inset

 group weaker than other type operations.
 So, the type expression 
\begin_inset Formula $\bbnum 1+A+B\rightarrow\bbnum 1\times B$
\end_inset

 means a function from 
\begin_inset Formula $\bbnum 1+A+B$
\end_inset

 to 
\begin_inset Formula $\bbnum 1\times B$
\end_inset

.
 
\end_layout

\begin_layout Standard
Begin by using the equivalence 
\begin_inset Formula $\bbnum 1\times B\cong B$
\end_inset

 to obtain 
\begin_inset Formula $\bbnum 1+A+B\rightarrow B$
\end_inset

.
 Now we use another rule:
\begin_inset Formula 
\[
A+B\rightarrow C\cong\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)
\]

\end_inset

and derive the equivalence:
\begin_inset Formula 
\[
\bbnum 1+A+B\rightarrow B\cong\left(\bbnum 1\rightarrow B\right)\times\left(A\rightarrow B\right)\times\left(B\rightarrow B\right)\quad.
\]

\end_inset

Finally, we note that 
\begin_inset Formula $\bbnum 1\rightarrow B\cong B$
\end_inset

 and that the type product is commutative, so we can rearrange the last
 type expression into the required form:
\begin_inset Formula 
\[
B\times\left(A\rightarrow B\right)\times\left(B\rightarrow B\right)\cong\left(B\rightarrow B\right)\times\left(A\rightarrow B\right)\times B\quad.
\]

\end_inset

We obtain the required type expression: 
\begin_inset Formula $\left(B\rightarrow B\right)\times\left(A\rightarrow B\right)\times B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Reader}^{E,A}\triangleq E\rightarrow A$
\end_inset

 and implement fully parametric functions with types 
\begin_inset Formula $A\rightarrow\text{Reader}^{E,A}$
\end_inset

 and 
\begin_inset Formula $\text{Reader}^{E,A}\rightarrow(A\rightarrow B)\rightarrow\text{Reader}^{E,B}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by defining a type alias for the type constructor 
\begin_inset Formula $\text{Reader}^{E,A}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Reader[E, A] = E => A
\end_layout

\end_inset

The first type signature has only one implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[E, A]: A => Reader[E, A] = { x => _ => x }
\end_layout

\end_inset

We 
\emph on
must
\emph default
 discard the argument of type 
\begin_inset Formula $E$
\end_inset

; we cannot use it for computing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The second type signature has three type parameters.
 It is the curried version of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: Reader[E, A] => (A => B) => Reader[E, B] = ???
\end_layout

\end_inset

Expanding the type alias, we see that the two curried arguments are functions
 of types 
\begin_inset Formula $E\rightarrow A$
\end_inset

 and 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 The forward composition of these functions is a function of type 
\begin_inset Formula $E\rightarrow B$
\end_inset

, or 
\begin_inset Formula $\text{Reader}^{E,B}$
\end_inset

, which is exactly what we are required to return.
 So, the code can be written as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: (E => A) => (A => B) => E => B = { r => f => r andThen
 f }
\end_layout

\end_inset

If we did not notice this shortcut, we would reason differently: We are
 required to compute a value of type 
\begin_inset Formula $B$
\end_inset

 given 
\emph on
three
\emph default
 curried arguments 
\begin_inset Formula $r^{:E\rightarrow A}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $e^{:E}$
\end_inset

.
 Write this requirement as:
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow???^{:B}\quad,
\]

\end_inset

The symbol 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

 denotes a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
typed hole
\end_layout

\end_inset


\series bold
typed hole
\series default
.
 It stands for a value that we are still figuring out how to compute, but
 whose type is already known.
 Typed holes are supported in Scala by an experimental compiler plugin.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "https://github.com/cb372/scala-typed-holes"
target "https://github.com/cb372/scala-typed-holes"
literal "false"

\end_inset


\end_layout

\end_inset

 The plugin will print the known information about the typed hole.
\end_layout

\begin_layout Standard
To fill the typed hole 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

, we need a value of type 
\begin_inset Formula $B$
\end_inset

.
 Since no arguments have type 
\begin_inset Formula $B$
\end_inset

, the only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 to some value of type 
\begin_inset Formula $A$
\end_inset

.
 So, we write:
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow f(???^{:A})\quad.
\]

\end_inset

The only way of getting an 
\begin_inset Formula $A$
\end_inset

 is to apply 
\begin_inset Formula $r$
\end_inset

 to some value of type 
\begin_inset Formula $E$
\end_inset

:
\begin_inset Formula 
\[
\text{map}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow f(r(???^{:E}))\quad.
\]

\end_inset

We have exactly one value of type 
\begin_inset Formula $E$
\end_inset

, namely 
\begin_inset Formula $e^{:E}$
\end_inset

.
 So, the code must be:
\begin_inset Formula 
\[
\text{map}^{E,A,B}\triangleq r^{:E\rightarrow A}\rightarrow f^{:A\rightarrow B}\rightarrow e^{:E}\rightarrow f(r(e))\quad.
\]

\end_inset

Translate this to the Scala syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[E, A, B]: (E => A) => (A => B) => E => B = { r => f => e => f(r(e))
 }
\end_layout

\end_inset

We may now notice that the expression 
\begin_inset Formula $e\rightarrow f(r(e))$
\end_inset

 is a function composition 
\begin_inset Formula $r\bef f$
\end_inset

 applied to 
\begin_inset Formula $e$
\end_inset

, and simplify the code accordingly.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that one cannot implement the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader[A, T] => (A => B) => Reader[B, T]
\end_layout

\end_inset

 by a fully parametric function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Expand the type signature and try implementing this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def m[A, B, T] : (A => T) => (A => B) => B => T = { r => f => b => ??? }
\end_layout

\end_inset

Given values 
\begin_inset Formula $r^{:A\rightarrow T}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $b^{:B}$
\end_inset

, we need to compute a value of type 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\[
m=r^{:A\rightarrow T}\rightarrow f^{:A\rightarrow B}\rightarrow b^{:B}\rightarrow???^{:T}\quad.
\]

\end_inset

The only way of getting a value of type 
\begin_inset Formula $T$
\end_inset

 is to apply 
\begin_inset Formula $r$
\end_inset

 to some value of type 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
m=r^{:A\rightarrow T}\rightarrow f^{:A\rightarrow B}\rightarrow b^{:B}\rightarrow r(???^{:A})\quad.
\]

\end_inset

However, we do not have any values of type 
\begin_inset Formula $A$
\end_inset

.
 We have a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 that 
\emph on
consumes
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

, and we cannot use 
\begin_inset Formula $f$
\end_inset

 to produce any values of type 
\begin_inset Formula $A$
\end_inset

.
 So, it seems that we are unable to fill the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

 and implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In order to verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 is unimplementable, we need to prove that the logical formula:
\begin_inset Formula 
\begin{equation}
\forall(\alpha,\beta,\tau).\,(\alpha\Rightarrow\tau)\Rightarrow(\alpha\Rightarrow\beta)\Rightarrow(\beta\Rightarrow\tau)\label{eq:ch-example-boolean-formula-3}
\end{equation}

\end_inset

is not true in the constructive logic.
 We could use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library for that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ def m[A, B, T] : (A => T) => (A => B) => B => T = implement
\end_layout

\begin_layout Plain Layout

cmd1.sc:1: type (A => T) => (A => B) => B => T cannot be implemented
\end_layout

\begin_layout Plain Layout

def m[A, B, T] : (A => T) => (A => B) => B => T = implement
\end_layout

\begin_layout Plain Layout

                                                ^
\end_layout

\begin_layout Plain Layout

Compilation Failed
\end_layout

\end_inset

Another way is to check whether this formula is true in Boolean logic.
 A formula that holds in constructive logic will always hold in Boolean
 logic, because all rules shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 preserve Boolean truth values (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relationship-between-Boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a proof).
 It follows that any formula that fails to hold in Boolean logic will also
 not hold in constructive logic.
 
\end_layout

\begin_layout Standard
It is relatively easy to check whether a given Boolean formula is always
 equal to 
\begin_inset Formula $True$
\end_inset

.
 Simplifying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-formula-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with the rules of Boolean logic, we find:
\begin_inset Formula 
\begin{align*}
 & (\alpha\Rightarrow\tau)\,\gunderline{\Rightarrow}\,(\alpha\Rightarrow\beta)\,\gunderline{\Rightarrow}\,(\beta\Rightarrow\tau)\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\neg(\gunderline{\alpha\Rightarrow\tau})\vee\neg(\gunderline{\alpha\Rightarrow\beta})\vee(\gunderline{\beta\Rightarrow\tau})\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\gunderline{\neg(\neg\alpha\vee\tau)}\vee\gunderline{\neg(\neg\alpha\vee\beta)}\vee(\neg\beta\vee\tau)\\
\text{use de Morgan's law}:\quad & =\left(\alpha\wedge\neg\tau\right)\vee\gunderline{\left(\alpha\wedge\neg\beta\right)\vee\neg\beta}\vee\tau\\
\text{use identity }(p\wedge q)\vee q=q:\quad & =\gunderline{\left(\alpha\wedge\neg\tau\right)}\vee\neg\beta\vee\gunderline{\tau}\\
\text{use identity }(p\wedge\neg q)\vee q=p\vee q:\quad & =\alpha\vee\neg\beta\vee\tau\quad.
\end{align*}

\end_inset

This formula is not identically 
\begin_inset Formula $True$
\end_inset

: it is 
\begin_inset Formula $False$
\end_inset

 when 
\begin_inset Formula $\alpha=\tau=False$
\end_inset

 and 
\begin_inset Formula $\beta=True$
\end_inset

.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-boolean-formula-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is not true in Boolean logic, therefore it is also not true in constructive
 logic.
 By the CH correspondence, we conclude that the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 cannot be implemented by a fully parametric function.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define the type constructor 
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A+A$
\end_inset

 and implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for it, with the type signature 
\begin_inset Formula $\text{map}^{A,B}:P^{A}\rightarrow(A\rightarrow B)\rightarrow P^{B}$
\end_inset

.
 To check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 preserves information, verify the law 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(p)(x => x) == p
\end_layout

\end_inset

 for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: P[A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
It is implied that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 should be fully parametric and information-preserving.
 Begin by defining a Scala type constructor for the notation 
\begin_inset Formula $P^{A}\triangleq\bbnum 1+A+A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class P1[A]()     extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P2[A](x: A) extends P[A]
\end_layout

\begin_layout Plain Layout

final case class P3[A](x: A) extends P[A]
\end_layout

\end_inset

Now we can write code to implement the required type signature.
 Each time we have several choices of an implementation, we will choose
 to preserve information as much as possible.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: P[A] => (A => B) => P[B] =
\end_layout

\begin_layout Plain Layout

  p => f => p match {
\end_layout

\begin_layout Plain Layout

    case P1()    => P1() // No other choice.
\end_layout

\begin_layout Plain Layout

    case P2(x)   => ???
\end_layout

\begin_layout Plain Layout

    case P3(x)   => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

In the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(x)
\end_layout

\end_inset

, we are required to produce a value of type 
\begin_inset Formula $P^{B}$
\end_inset

 from a value 
\begin_inset Formula $x^{:A}$
\end_inset

 and a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Since 
\begin_inset Formula $P^{B}$
\end_inset

 is a disjunctive type with three parts, we can produce a value of type
 
\begin_inset Formula $P^{B}$
\end_inset

 in three different ways: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P1()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(...)
\end_layout

\end_inset

.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P1()
\end_layout

\end_inset

, we will lose the information about the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(...)
\end_layout

\end_inset

, we will preserve the information about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 but lose the information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 that the input value was a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2
\end_layout

\end_inset

 rather than a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3
\end_layout

\end_inset

.
 By returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

 in that scope, we preserve the entire input information.
 
\end_layout

\begin_layout Standard
The value under 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(...)
\end_layout

\end_inset

 must be of type 
\begin_inset Formula $B$
\end_inset

, and the only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f$
\end_inset

 to 
\begin_inset Formula $x$
\end_inset

.
 So, we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P2(f(x))
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Similarly, in the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(x)
\end_layout

\end_inset

, we should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P3(f(x))
\end_layout

\end_inset

.
 The final code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: P[A] => (A => B) => P[B] = p => f => p match {
\end_layout

\begin_layout Plain Layout

  case P1()    => P1()        // No other choice here.
\end_layout

\begin_layout Plain Layout

  case P2(x)   => P2(f(x))    // Preserve information.
\end_layout

\begin_layout Plain Layout

  case P3(x)   => P3(f(x))    // Preserve information.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify the given law, we first write a matrix notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{map}^{A,B}\triangleq p^{:\bbnum 1+A+A}\rightarrow f^{:A\rightarrow B}\rightarrow p\triangleright\,\begin{array}{|c||ccc|}
 & \bbnum 1 & B & B\\
\hline \bbnum 1 & \text{id} & \bbnum 0 & \bbnum 0\\
A & \bbnum 0 & f & \bbnum 0\\
A & \bbnum 0 & \bbnum 0 & f
\end{array}\quad.
\]

\end_inset

The required law is written as an equation 
\begin_inset Formula $\text{map}\left(p\right)(\text{id})=p$
\end_inset

, called the
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
map
\end_layout

\end_inset

 
\series bold
identity law
\series default
.
 Substituting the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we verify the law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p:\quad & \text{map}\left(p\right)(\text{id})\\
\text{apply \texttt{map()()} to arguments}:\quad & =p\triangleright\,\begin{array}{||ccc|}
\text{id} & \bbnum 0 & \bbnum 0\\
\bbnum 0 & \text{id} & \bbnum 0\\
\bbnum 0 & \bbnum 0 & \text{id}
\end{array}\\
\text{identity function in matrix notation}:\quad & =p\triangleright\text{id}\\
\triangleright\text{-notation}:\quad & =\text{id}\left(p\right)=p\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[L, R]
\end_layout

\end_inset

, applied to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For a type constructor, say, 
\begin_inset Formula $P^{A}$
\end_inset

, the standard type signatures for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 are:
\begin_inset Formula 
\[
\text{map}:P^{A}\rightarrow(A\rightarrow B)\rightarrow P^{B}\quad,\quad\quad\text{flatMap}:P^{A}\rightarrow(A\rightarrow P^{B})\rightarrow P^{B}\quad.
\]

\end_inset

If a type constructor has more than one type parameter, e.g., 
\begin_inset Formula $P^{A,S,T}$
\end_inset

, one can define the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 applied to a chosen type parameter.
 For example, when applied to the type parameter 
\begin_inset Formula $A$
\end_inset

, the type signatures are:
\begin_inset Formula 
\begin{align*}
\text{map} & :P^{A,S,T}\rightarrow(A\rightarrow B)\rightarrow P^{B,S,T}\quad,\\
\text{flatMap} & :P^{A,S,T}\rightarrow(A\rightarrow P^{B,S,T})\rightarrow P^{B,S,T}\quad.
\end{align*}

\end_inset

Being 
\begin_inset Quotes eld
\end_inset

applied to the type parameter 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 means that the other type parameters 
\begin_inset Formula $S,T$
\end_inset

 in 
\begin_inset Formula $P^{A,S,T}$
\end_inset

 remain fixed while the type parameter 
\begin_inset Formula $A$
\end_inset

 is replaced by 
\begin_inset Formula $B$
\end_inset

 in the type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[L, R]
\end_layout

\end_inset

 (in the type notation, 
\begin_inset Formula $L+R$
\end_inset

), we keep the type parameter 
\begin_inset Formula $R$
\end_inset

 fixed while 
\begin_inset Formula $L$
\end_inset

 is replaced by 
\begin_inset Formula $M$
\end_inset

.
 So, we obtain the type signatures:
\begin_inset Formula 
\begin{align*}
\text{map} & :L+R\rightarrow(L\rightarrow M)\rightarrow M+R\quad,\\
\text{flatMap} & :L+R\rightarrow(L\rightarrow M+R)\rightarrow M+R\quad.
\end{align*}

\end_inset

Implementing these functions is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[L,M,R]: Either[L, R] => (L => M) => Either[M, R] = e => f => e match
 {
\end_layout

\begin_layout Plain Layout

  case Left(x)    => Left(f(x))
\end_layout

\begin_layout Plain Layout

  case Right(y)   => Right(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def flatMap[L, M, R]: Either[L, R] => (L => Either[M, R]) => Either[M, R]
 = e => f => e match {
\end_layout

\begin_layout Plain Layout

  case Left(x)    => f(x)
\end_layout

\begin_layout Plain Layout

  case Right(y)   => Right(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code notation for these functions is:
\begin_inset Formula 
\begin{align*}
\text{map} & \triangleq e^{:L+R}\rightarrow f^{:L\rightarrow M}\rightarrow e\triangleright\,\begin{array}{|c||cc|}
 & M & R\\
\hline L & f & \bbnum 0\\
R & \bbnum 0 & \text{id}
\end{array}\quad,\\
\text{flatMap} & \triangleq e^{:L+R}\rightarrow f^{:L\rightarrow M+R}\rightarrow e\triangleright\,\begin{array}{|c||c|}
 & M+R\\
\hline L & f\\
R & y^{:R}\rightarrow\bbnum 0^{:M}+y
\end{array}\quad.
\end{align*}

\end_inset

Note that the code matrix for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 cannot be split into the 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 columns because we do not know in advance which part of the disjunctive
 type 
\begin_inset Formula $M+R$
\end_inset

 will be returned when we evaluate 
\begin_inset Formula $f(x^{:L})$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-9"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-9"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a type constructor 
\begin_inset Formula $\text{State}^{S,A}\equiv S\rightarrow A\times S$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{pure}^{S,A}:A\rightarrow\text{State}^{S,A}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{map}^{S,A,B}:\text{State}^{S,A}\rightarrow(A\rightarrow B)\rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\text{flatMap}^{S,A,B}:\text{State}^{S,A}\rightarrow(A\rightarrow\text{State}^{S,B})\rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
It is assumed that all functions must be fully parametric and preserve as
 much information as possible.
 We define the type alias:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type State[S, A] = S => (A, S)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The type signature is 
\begin_inset Formula $A\rightarrow S\rightarrow A\times S$
\end_inset

, and there is only one implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[S, A]: A => State[S, A] = a => s => (a, s)
\end_layout

\end_inset

In the code notation, this is written as:
\begin_inset Formula 
\[
\text{pu}^{S,A}\triangleq a^{:A}\rightarrow s^{:S}\rightarrow a\times s\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The type signature is:
\begin_inset Formula 
\[
\text{map}^{S,A,B}:(S\rightarrow A\times S)\rightarrow(A\rightarrow B)\rightarrow S\rightarrow B\times S\quad.
\]

\end_inset

Begin writing a Scala implementation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[S, A, B]: State[S, A] => (A => B) => State[S, B] = { t => f => s
 => ??? }
\end_layout

\end_inset

We need to compute a value of 
\begin_inset Formula $B\times S$
\end_inset

 from the curried arguments 
\begin_inset Formula $t^{:S\rightarrow A\times S}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $s^{:S}$
\end_inset

.
 We begin writing the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 using a typed hole:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow s^{:S}\rightarrow\text{???}^{:B}\times\text{???}^{:S}\quad.
\]

\end_inset

The only way of getting a value of type 
\begin_inset Formula $B$
\end_inset

 is by applying 
\begin_inset Formula $f$
\end_inset

 to a value of type 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow s^{:S}\rightarrow f(\text{???}^{:A})\times\text{???}^{:S}\quad.
\]

\end_inset

The only possibility of filling the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

 is to apply 
\begin_inset Formula $t$
\end_inset

 to a value of type 
\begin_inset Formula $S$
\end_inset

.
 We already have such a value, 
\begin_inset Formula $s^{:S}$
\end_inset

.
 Computing 
\begin_inset Formula $t(s)$
\end_inset

 yields a pair of type 
\begin_inset Formula $A\times S$
\end_inset

, from which we may take the first part (of type 
\begin_inset Formula $A$
\end_inset

) to fill the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

.
 The second part of the pair is a value of type 
\begin_inset Formula $S$
\end_inset

 that we may use to fill the second typed hole, 
\begin_inset Formula $\text{???}^{:S}$
\end_inset

.
 So, the Scala code is:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def map[S, A, B]: State[S, A] => (A => B) => State[S, B] = {
\end_layout

\begin_layout Plain Layout

  t => f => s =>
\end_layout

\begin_layout Plain Layout

    val (a, s2) = t(s)
\end_layout

\begin_layout Plain Layout

    (f(a), s2)     // We could also return `(f(a), s)` here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Why not return the original value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 in the tuple 
\begin_inset Formula $B\times S$
\end_inset

, instead of the new value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

? The reason is that we would like to preserve information as much as possible.
 If we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f(a), s)
\end_layout

\end_inset

 in line 4, we will have discarded the computed value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

, which is a loss of information.
\end_layout

\begin_layout Standard
To write the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we need to destructure the pair that 
\begin_inset Formula $t(s)$
\end_inset

 returns.
 We can write explicit destructuring code like this:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow s^{:S}\rightarrow(a^{:A}\times s_{2}^{:S}\rightarrow f(a)\times s_{2})(t(s))\quad.
\]

\end_inset

If we temporarily denote by 
\begin_inset Formula $q$
\end_inset

 the following destructuring function:
\begin_inset Formula 
\[
q\triangleq(a^{:A}\times s_{2}^{:S}\rightarrow f(a)\times s_{2})\quad,
\]

\end_inset

we will notice that the expression 
\begin_inset Formula $s\rightarrow q(t(s))$
\end_inset

 is a function composition applied to 
\begin_inset Formula $s$
\end_inset

.
 So, we rewrite 
\begin_inset Formula $s\rightarrow q(t(s))$
\end_inset

 as the composition 
\begin_inset Formula $t\bef q$
\end_inset

 and obtain shorter code:
\begin_inset Formula 
\[
\text{map}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow B}\rightarrow t\bef(a^{:A}\times s^{:S}\rightarrow f(a)\times s)\quad.
\]

\end_inset

Shorter formulas are often easier to reason about in derivations, although
 not necessarily easier to read when converted to program code.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The required type signature is:
\begin_inset Formula 
\[
\text{flatMap}^{S,A,B}:(S\rightarrow A\times S)\rightarrow(A\rightarrow S\rightarrow B\times S)\rightarrow S\rightarrow B\times S\quad.
\]

\end_inset

We perform code reasoning with typed holes:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow s^{:S}\rightarrow\text{???}^{:B\times S}\quad.
\]

\end_inset

To fill 
\begin_inset Formula $\text{???}^{:B\times S}$
\end_inset

, we need to apply 
\begin_inset Formula $f$
\end_inset

 to some arguments, since 
\begin_inset Formula $f$
\end_inset

 is the only function that returns any values of type 
\begin_inset Formula $B$
\end_inset

.
 Applying 
\begin_inset Formula $f$
\end_inset

 to two values will yield a value of type 
\begin_inset Formula $B\times S$
\end_inset

, just as we need:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow s^{:S}\rightarrow f(\text{???}^{:A})(\text{???}^{:S})\quad.
\]

\end_inset

To fill the new typed holes, we need to apply 
\begin_inset Formula $t$
\end_inset

 to an argument of type 
\begin_inset Formula $S$
\end_inset

.
 We have only one given value 
\begin_inset Formula $s^{:S}$
\end_inset

 of type 
\begin_inset Formula $S$
\end_inset

, so we must compute 
\begin_inset Formula $t(s)$
\end_inset

 and destructure it:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow s^{:S}\rightarrow\left(a\times s_{2}\rightarrow f(a)(s_{2})\right)(t(s))\quad.
\]

\end_inset

Translating this notation into Scala code, we obtain:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[S, A, B]: State[S, A] => (A => State[S, B]) => State[S, B] =
 {
\end_layout

\begin_layout Plain Layout

  t => f => s =>
\end_layout

\begin_layout Plain Layout

    val (a, s2) = t(s)
\end_layout

\begin_layout Plain Layout

    f(a)(s2)            // We could also return `f(a)(s)` here, but that
 would lose information.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In order to preserve information, we choose not to discard the computed
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The code notation for this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 can be simplified to:
\begin_inset Formula 
\[
\text{flatMap}\triangleq t^{:S\rightarrow A\times S}\rightarrow f^{:A\rightarrow S\rightarrow B\times S}\rightarrow t\bef\left(a\times s\rightarrow f(a)(s)\right)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-0"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-0"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find the cardinality of the following Scala type: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type P = Option[Boolean => Option[Boolean]]
\end_layout

\end_inset

Show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Boolean] => Boolean
\end_layout

\end_inset

, but the equivalence is accidental
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence!accidental
\end_layout

\end_inset

 and not 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-1-a"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-1-a"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalences 
\begin_inset Formula $A+A\cong\bbnum 2\times A$
\end_inset

 and 
\begin_inset Formula $A\times A\cong\bbnum 2\rightarrow A$
\end_inset

, where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $A\Rightarrow(B\vee C)\neq(A\Rightarrow B)\wedge(A\Rightarrow C)$
\end_inset

 in constructive and Boolean logic.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-solvedExample-5-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-5-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Verify the type equivalence 
\begin_inset Formula $\left(A\rightarrow B\times C\right)\cong\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)$
\end_inset

 with full proofs.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-type-identity-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-type-identity-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known rules to verify the type equivalences without need for proofs:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\left(A+B\right)\times\left(A\rightarrow B\right)\cong A\times\left(A\rightarrow B\right)+\left(\bbnum 1+A\rightarrow B\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\left(A\times(\bbnum 1+A)\rightarrow B\right)\cong\left(A\rightarrow B\right)\times\left(A\rightarrow A\rightarrow B\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $A\rightarrow\left(\bbnum 1+B\right)\rightarrow C\times D\cong\left(A\rightarrow C\right)\times\left(A\rightarrow D\right)\times\left(A\times B\rightarrow C\right)\times\left(A\times B\rightarrow D\right)\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write the type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, Int), Either[(A, Char), (A, Float)]]
\end_layout

\end_inset

.
 Transform this type into an equivalent type of the form 
\begin_inset Formula $A\times(...)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a type 
\begin_inset Formula $\text{OptE}^{T,A}\triangleq\bbnum 1+T+A$
\end_inset

 and implement information-preserving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for it, applied to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 Get the same result using the equivalent type 
\begin_inset Formula $(\bbnum 1+A)+T$
\end_inset

, i.e., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Option[A], T]
\end_layout

\end_inset

.
 The required type signatures are:
\begin_inset Formula 
\begin{align*}
\text{map}^{A,B,T} & :\text{OptE}^{T,A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{OptE}^{T,B}\quad,\\
\text{flatMap}^{A,B,T} & :\text{OptE}^{T,A}\rightarrow(A\rightarrow\text{OptE}^{T,B})\rightarrow\text{OptE}^{T,B}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[A]
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required type signature is 
\begin_inset Formula $P^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow P^{B}$
\end_inset

.
 Preserve information as much as possible.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the type constructor 
\begin_inset Formula $Q^{T,A}$
\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-type-notation-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function, preserving information as much as possible:
\begin_inset Formula 
\[
\text{map}^{T,A,B}:Q^{T,A}\rightarrow\left(A\rightarrow B\right)\rightarrow Q^{T,B}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a recursive type constructor 
\begin_inset Formula $\text{Tr}_{3}$
\end_inset

 as 
\begin_inset Formula $\text{Tr}_{3}{}^{A}\triangleq\bbnum 1+A\times A\times A\times\text{Tr}_{3}{}^{A}$
\end_inset

 and implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for it, with the standard type signature: 
\begin_inset Formula $\text{map}^{A,B}:\text{Tr}_{3}{}^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Tr}_{3}{}^{B}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement fully parametric, information-preserving functions with the following
 type signatures:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\left(A\rightarrow B\rightarrow C\right)\rightarrow A\rightarrow B\rightarrow C\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\left(A\rightarrow C\right)\rightarrow\left(B\rightarrow D\right)\rightarrow A+B\rightarrow C+D\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\left(A\rightarrow C\right)\rightarrow\left(B\rightarrow D\right)\rightarrow A\times B\rightarrow C\times D\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $((A\rightarrow A)\rightarrow A)\rightarrow A\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $\left(\left(A\rightarrow B\right)\rightarrow C\right)\rightarrow B\rightarrow C\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(f)
\series default
 
\begin_inset Formula $((A\rightarrow B)\rightarrow A)\rightarrow\left(A\rightarrow B\right)\rightarrow B\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(g)
\series default
 
\begin_inset Formula $(A\rightarrow B+C)\rightarrow(B\rightarrow C)\rightarrow A\rightarrow C\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(h)
\series default
 
\begin_inset Formula $(A+B\rightarrow C)\rightarrow(B\rightarrow C)\rightarrow A\rightarrow C\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(i)
\series default
 
\begin_inset Formula $\text{Reader}^{E,A}\rightarrow(A\rightarrow\text{Reader}^{E,B})\rightarrow\text{Reader}^{E,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(j)
\series default
 
\begin_inset Formula $\text{Reader}^{E,A}\times\text{Reader}^{E,B}\rightarrow(A\times B\rightarrow C)\rightarrow\text{Reader}^{E,C}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(k)
\series default
 
\begin_inset Formula $\text{State}^{S,A}\rightarrow\left(S\times A\rightarrow B\right)\rightarrow\text{State}^{S,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(l)
\series default
 
\begin_inset Formula $A+Z\rightarrow B+Z\rightarrow(A\rightarrow B\rightarrow C)\rightarrow C+Z\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(m)
\series default
 
\begin_inset Formula $P+A\times A\rightarrow(A\rightarrow B)\rightarrow(P\rightarrow A+Q)\rightarrow Q+B\times B\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Cont}^{R,T}\triangleq\left(T\rightarrow R\right)\rightarrow R$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{map}^{R,T,U}:\text{Cont}^{R,T}\rightarrow(T\rightarrow U)\rightarrow\text{Cont}^{R,U}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{flatMap}^{R,T,U}:\text{Cont}^{R,T}\rightarrow(T\rightarrow\text{Cont}^{R,U})\rightarrow\text{Cont}^{R,U}\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch-Exercise-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Exercise-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $\text{Sel}^{Z,T}\triangleq\left(T\rightarrow Z\right)\rightarrow T$
\end_inset

 and implement the functions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{map}^{Z,A,B}:\text{Sel}^{Z,A}\rightarrow\left(A\rightarrow B\right)\rightarrow\text{Sel}^{Z,B}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{flatMap}^{Z,A,B}:\text{Sel}^{Z,A}\rightarrow(A\rightarrow\text{Sel}^{Z,B})\rightarrow\text{Sel}^{Z,B}\quad.$
\end_inset


\end_layout

\begin_layout Section
Discussion and further developments
\begin_inset CommandInset label
LatexCommand label
name "sec:Discussion-curry-howard"

\end_inset


\end_layout

\begin_layout Subsection
Using the Curry-Howard correspondence for writing code
\end_layout

\begin_layout Standard
The CH correspondence is used in two practically important reasoning tasks:
 checking whether a type signature can be implemented as a fully parametric
 function, and determining whether two types are equivalent.
 For the first task, we map type expressions into formulas in the constructive
 logic and apply the proof rules of that logic.
 For the second task, we map type expressions into 
\emph on
arithmetic
\emph default
 formulas and apply the ordinary rules of arithmetic.
\end_layout

\begin_layout Standard
Although tools such as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library can sometimes derive code from types, it is beneficial if a programmer
 is able to derive an implementation by hand or to determine that an implementat
ion is impossible.
 For instance, the programmer should recognize that the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A, B]: A => (A => B) => B
\end_layout

\end_inset

has only one fully parametric implementation, while the following two type
 signatures have none:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def g[A, B]: A => (B => A) => B
\end_layout

\begin_layout Plain Layout

def h[A, B]: ((A => B) => A) => A
\end_layout

\end_inset

Exercises in this chapter help to build up the required technique and intuition.
 The two main guidelines for code derivation are: 
\begin_inset Quotes eld
\end_inset

values of parametric types cannot be constructed from scratch
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

one must hard-code the decision to return a chosen part of a disjunctive
 type when no other disjunctive value is given
\begin_inset Quotes erd
\end_inset

.
 These guidelines can be justified by referring to the rigorous rules of
 proof (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-for-constructive-logic"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Sequents producing a value of type 
\begin_inset Formula $A$
\end_inset

 can be proved only if there is a premise containing 
\begin_inset Formula $A$
\end_inset

 or a function that returns a value of type 
\begin_inset Formula $A$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
This is proved rigorously by R.
\begin_inset space ~
\end_inset

Dyckhoff
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Roy Dyckhoff
\end_layout

\end_inset

 as the 
\begin_inset Quotes eld
\end_inset

Theorem
\begin_inset Quotes erd
\end_inset

 in section 6 (
\begin_inset Quotes eld
\end_inset

Goal-directed pruning
\begin_inset Quotes erd
\end_inset

), see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://research-repository.st-andrews.ac.uk/handle/10023/8824"
literal "false"

\end_inset


\end_layout

\end_inset

 One can derive a disjunction without hard-coding only if one already has
 a disjunction in the premises (and then the rule 
\begin_inset Quotes eld
\end_inset

use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 could apply).
\end_layout

\begin_layout Standard
Throughout this chapter, we require all code to be fully parametric.
 This is because the CH correspondence gives useful, non-trivial results
 only for parameterized types and fully parametric code.
 For concrete, non-parameterized types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, etc.), one can always produce 
\emph on
some
\emph default
 values even with no previous data.
 So, the propositions 
\begin_inset Formula $\mathcal{CH}(\text{Int})$
\end_inset

 or 
\begin_inset Formula $\mathcal{CH}(\text{String})$
\end_inset

 are always true.
\end_layout

\begin_layout Standard
Consider the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x:Int) => x + 1
\end_layout

\end_inset

.
 Its type signature, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, may be implemented by many other functions, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x - 1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x * 2
\end_layout

\end_inset

, etc.
 So, the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 is insufficient to specify the code of the function, and deriving code
 from that type is not a meaningful task.
 Only a fully parametric type signature, such as 
\begin_inset Formula $A\rightarrow\left(A\rightarrow B\right)\rightarrow B$
\end_inset

, could give enough information for deriving the function's code.
 Additionally, we must require the code of functions to be fully parametric.
 Otherwise we will be unable to reason about code derivation from type signature
s.
\end_layout

\begin_layout Standard
Validity of a 
\begin_inset Formula ${\cal CH}$
\end_inset

-proposition 
\begin_inset Formula ${\cal CH}(T)$
\end_inset

 means that we can implement 
\emph on
some
\emph default
 value of the given type 
\begin_inset Formula $T$
\end_inset

.
 But this does not give any information about the properties of that value,
 such as whether it satisfies any laws.
 This is why type equivalence (which requires the laws of isomorphisms)
 is not determined by an equivalence of logical formulas.
\end_layout

\begin_layout Standard
It is useful for programmers to be able to transform type expressions to
 equivalent simpler types before starting to write code.
 The type notation introduced in this book is designed to help programmers
 to recognize patterns in type expressions and to reason about them more
 easily.
 We have shown that a type equivalence corresponds to 
\emph on
each
\emph default
 standard arithmetic identity such as 
\begin_inset Formula $\left(a+b\right)+c=a+\left(b+c\right)$
\end_inset

, 
\begin_inset Formula $\left(a\times b\right)\times c=a\times(b\times c)$
\end_inset

, 
\begin_inset Formula $1\times a=a$
\end_inset

, 
\begin_inset Formula $\left(a+b\right)\times c=a\times c+b\times c$
\end_inset

, and so on.
 Because of this, we are allowed to transform and simplify types as if they
 were arithmetic expressions, e.g., to rewrite:
\begin_inset Formula 
\[
\bbnum 1\times\left(A+B\right)\times C+D\cong D+A\times C+B\times C\quad.
\]

\end_inset

The type notation makes this reasoning more intuitive (for people familiar
 with arithmetic).
 
\end_layout

\begin_layout Standard
These results apply to all type expressions built up using product types,
 disjunctive types (also called 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 types because they correspond to arithmetic sums), and function types (also
 called 
\begin_inset Quotes eld
\end_inset

exponential
\begin_inset Quotes erd
\end_inset

 types because they correspond to arithmetic exponentials).
 Type expressions that contain only products and sum types are called 
\series bold
polynomial
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!polynomial types
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
These types are often called 
\begin_inset Quotes eld
\end_inset

algebraic data types
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic data types
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 but this book prefers the more precise term 
\begin_inset Quotes eld
\end_inset

polynomial types
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 Type expressions that also contain function types are called 
\series bold
exponential-polynomial
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
types!exponential-polynomial types
\end_layout

\end_inset

.
 We focus on exponential-polynomial types because they are sufficient for
 almost all design patterns used in functional programming.
\end_layout

\begin_layout Standard
There are no types corresponding to subtraction or division, so arithmetic
 equations such as:
\begin_inset Formula 
\begin{align*}
\left(1-t\right)\times\left(1+t\right) & =1-t\times t\quad,\quad\text{ and }\quad\frac{t+t\times t}{t}=1+t\quad,
\end{align*}

\end_inset

do not directly yield any type equivalences.
 However, consider this well-known formula:
\begin_inset Formula 
\[
\frac{1}{1-t}=1+t+t^{2}+t^{3}+...+t^{n}+...\quad.
\]

\end_inset

At first sight, this formula appears to involve subtraction, division, and
 an infinite series, and so cannot be directly translated into a type equivalenc
e.
 However, the formula can be rewritten as:
\begin_inset Formula 
\begin{equation}
\frac{1}{1-t}=L(t)\quad\text{ where }\quad L(t)\triangleq1+t+t^{2}+t^{3}+...+t^{n}\times L(t)\quad.\label{eq:ch-example-type-formula-list}
\end{equation}

\end_inset

The definition of 
\begin_inset Formula $L(t)$
\end_inset

 is finite and only contains additions and multiplications.
 So, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-type-formula-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be translated into a type equivalence:
\begin_inset Formula 
\begin{equation}
L^{A}\cong1+A+A\times A+A\times A\times A+...+\underbrace{A\times...\times A}_{n\text{ times}}\times\,L^{A}\quad.\label{eq:ch-example-type-expansion-list}
\end{equation}

\end_inset

This type formula (with 
\begin_inset Formula $n=1$
\end_inset

) is equivalent to a recursive definition of the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq1+A\times\text{List}^{A}\quad.
\]

\end_inset

The type equivalence
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ch-example-type-expansion-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) suggests that we may view the recursive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 heuristically as an 
\begin_inset Quotes eld
\end_inset

infinite disjunction
\begin_inset Quotes erd
\end_inset

 describing lists of zero, one, two, etc., elements.
\end_layout

\begin_layout Subsection
Implications for designing new programming languages
\end_layout

\begin_layout Standard
Today's functional programming practice assumes, at the minimum, that programmer
s will use the six standard type constructions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-notation-and-standard-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the eight standard code constructions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 These constructions are foundational in the sense that they are used to
 express all design patterns of functional programming.
 A language that does not directly support all of those constructions cannot
 be considered a functional programming language.
\end_layout

\begin_layout Standard
A remarkable result of the CH correspondence is that the type system of
 any given programming language (functional or not) is mapped into a 
\emph on
certain
\emph default
 
\emph on
logic
\emph default
, i.e., a system of logical operations and proof rules.
 A logical operation will correspond to each of the 
\emph on
type
\emph default
 constructions available in the programming language.
 A proof rule will correspond to each of the available 
\emph on
code
\emph default
 constructions.
 Programming languages that support all the standard type and code constructions
 â€” for instance, OCaml, Haskell, F#, Scala, Swift, Rust, â€” are mapped into
 the constructive logic with all standard logical operations available (
\begin_inset Formula $True$
\end_inset

, 
\begin_inset Formula $False$
\end_inset

, disjunction, conjunction, and implication).
\end_layout

\begin_layout Standard
Languages such as C, C++, Java, C#, Go are mapped into logics that do not
 have the disjunction operation or the constants 
\begin_inset Formula $True$
\end_inset

 and 
\begin_inset Formula $False$
\end_inset

.
 In other words, these languages are mapped into 
\emph on
incomplete
\emph default
 logics where some true formulas cannot be proved.
 Incompleteness of the logic of types will make a programming language unable
 to express certain computations, e.g., directly handle data that belongs
 to a disjoint domain.
 
\end_layout

\begin_layout Standard
Languages that do not enforce type checking (e.g., Python or JavaScript) are
 mapped to inconsistent logics where any proposition can be proved â€” even
 propositions normally considered 
\begin_inset Formula $False$
\end_inset

.
 The CH correspondence will map such absurd proofs to code that 
\emph on
appears
\emph default
 to compute a certain value (since the 
\begin_inset Formula $\mathcal{CH}$
\end_inset

-proposition was proved to be 
\begin_inset Formula $True$
\end_inset

) although that value is not actually available.
 In practice, such code will crash because of a value that has a wrong type
 or is 
\begin_inset Quotes eld
\end_inset

null
\begin_inset Quotes erd
\end_inset

 (a pointer to an invalid memory location).
 Those errors cannot happen in a programming language whose logic of types
 is consistent and whose compiler checks all types at compile time.
 
\end_layout

\begin_layout Standard
So, the CH correspondence gives a mathematically justified procedure for
 designing new programming languages.
 The procedure has the following steps:
\end_layout

\begin_layout Itemize
Choose a formal logic that is complete and free of inconsistencies.
\end_layout

\begin_layout Itemize
For each logical operation, provide a type construction in the language.
\end_layout

\begin_layout Itemize
For each axiom and proof rule of the logic, provide a code construction
 in the language.
\end_layout

\begin_layout Standard
Mathematicians have studied different logics, such as modal logic, temporal
 logic, or linear logic.
 Compared with the constructive logic, those other logics have some additional
 type operations.
 For instance, modal logic adds the operations 
\begin_inset Quotes eld
\end_inset

necessarily
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

possibly
\begin_inset Quotes erd
\end_inset

, and temporal logic adds the operation 
\begin_inset Quotes eld
\end_inset

until
\begin_inset Quotes erd
\end_inset

.
 For each logic, mathematicians have determined the minimal complete sets
 of operations, axioms, and proof rules that do not lead to inconsistency.
 Programming language designers can use this mathematical knowledge by choosing
 a logic and translating it into a minimal 
\begin_inset Quotes eld
\end_inset

core
\begin_inset Quotes erd
\end_inset

 of a programming language.
 Code in that language will be guaranteed 
\emph on
never to crash
\emph default
 as long as all types match.
 This mathematical guarantee (known as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type safety
\end_layout

\end_inset


\series bold
type safety
\series default
) is a powerful help for programmers since it automatically prevents a large
 number of coding errors.
 So, programmers will benefit if they use languages designed using the CH
 correspondence.
\end_layout

\begin_layout Standard
Practically useful programming languages will of course need more features
 than the minimal set of mathematically necessary features derived from
 a chosen logic.
 Language designers need to make sure that all added features are consistent
 with the core language.
 
\end_layout

\begin_layout Standard
At present, it is still not fully understood how a practical programming
 language could use, say, modal or linear logic as its logic of types.
 Experience suggests that, at least, the operations of the plain constructive
 logic should be available.
 So, it appears that the six type constructions and the eight code constructions
 will remain available in all future languages of functional programming.
 
\end_layout

\begin_layout Standard
It is possible to apply the FP paradigm while writing code in any programming
 language.
 However, some languages lack certain features that make FP techniques easier
 to use in practice.
 For example, in a language such as C++ or Java, one can easily use the
 map/reduce operations but not disjunctive types.
 More advanced FP constructions (such as typeclasses) are impractical in
 those languages: the required code becomes too hard to read and to write
 without errors, which negates the advantages of rigorous reasoning about
 functional programs.
\end_layout

\begin_layout Standard
Some programming languages, such as Haskell and OCaml, were designed specificall
y for advanced use and exploration of the FP paradigm.
 Other languages, such as F#, Scala, Swift, and Rust, have different design
 goals but still support enough FP features to be considered FP languages.
 This book uses Scala, but the same constructions may be implemented in
 other FP languages in a similar way.
 Differences between OCaml, Haskell, F#, Scala, Swift, Rust, and other FP
 languages do not play a significant role at the level of detail needed
 in this book.
\end_layout

\begin_layout Subsection
Practical uses of the void type (Scala's 
\family typewriter
Nothing
\family default
)
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

void type
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset

void
\begin_inset Quotes erd
\end_inset

 type is a type with no values.
 It is 
\emph on
not
\emph default
 the same as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

void
\end_layout

\end_inset

 keyword in Java or C that denotes functions returning 
\begin_inset Quotes eld
\end_inset

no value
\begin_inset Quotes erd
\end_inset

.
 Those functions are equivalent to Scala functions returning the (unique)
 value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
\end_layout

\end_inset

 (Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

) corresponds to the logical constant 
\begin_inset Formula $False$
\end_inset

.
 (The proposition 
\begin_inset Quotes eld
\end_inset


\emph on
the code can compute a value of the void type
\emph default

\begin_inset Quotes erd
\end_inset

 is always false.) The void type is used in some theoretical proofs but has
 few practical uses.
 One use case is for a branch of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression that throws an 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset

exception instead of returning a value.
 In this sense, returning a value of the void type corresponds to a crash
 in the program.
 So, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 expression is defined as if it returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

.
 We can then pretend to convert that 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 (which will never be actually returned) into a value of any other type.
 Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how to write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd[A]
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing => A
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To see how this trick is used, consider this code defining a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: Double = if (t >= 0.0) math.sqrt(t) else throw new Exception(
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 branch does not return a value, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is declared to have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 For this code to type-check, both branches must return values of the same
 type.
 So, the compiler needs to pretend that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 branch also returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 The compiler first assigns the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 to the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw ...
\end_layout

\end_inset

 and then automatically uses the conversion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing => Double
\end_layout

\end_inset

 to convert that type to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 In this way, types will match in the definition of the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
This book does not discuss exceptions in much detail.
 The functional programming paradigm does not use exceptions because their
 presence prevents mathematical reasoning about code.
\end_layout

\begin_layout Standard
As another example of using the void type, suppose an external library implement
s a function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def parallel_run[E, A, B](f: A => Either[E, B]): Either[E, B] = ???
\end_layout

\end_inset

We may imagine that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parallel_run(f)
\end_layout

\end_inset

 performs some parallel computations using a given function 
\begin_inset Formula $f$
\end_inset

.
 In general, functions 
\begin_inset Formula $f^{:A\rightarrow E+B}$
\end_inset

 may return an error of type 
\begin_inset Formula $E$
\end_inset

 or a result of type 
\begin_inset Formula $B$
\end_inset

.
 Suppose we know that a particular function 
\begin_inset Formula $f$
\end_inset

 never fails to compute its result.
 To express that knowledge in code, we may explicitly set the type parameter
 
\begin_inset Formula $E$
\end_inset

 to the void type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 when applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parallel_run
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

parallel_run[Nothing, A, B](f)  // Types match only when values f(a) always
 are of the form Right(b).
 
\end_layout

\end_inset

Returning an error is now impossible (the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 has no values).
 If the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

parallel_run
\end_layout

\end_inset

 is fully parametric, it will work in the same way with all types 
\begin_inset Formula $E$
\end_inset

, including 
\begin_inset Formula $E=\bbnum 0$
\end_inset

.
 The code implements our intention via type parameters, giving a compile-time
 guarantee of correct results.
\end_layout

\begin_layout Standard
So far, none of our examples involved the logical 
\series bold
negation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
negation (in logic)
\end_layout

\end_inset

 operation.
 It is defined as:
\begin_inset Formula 
\[
\neg\alpha\triangleq(\alpha\Rightarrow False)\quad.
\]

\end_inset

Its practical use in functional programming is as limited as that of 
\begin_inset Formula $False$
\end_inset

 and the void type.
 However, logical negation plays an important role in Boolean logic.
\end_layout

\begin_layout Subsection
Relationship between Boolean logic and constructive logic
\begin_inset CommandInset label
LatexCommand label
name "subsec:Relationship-between-Boolean"

\end_inset

 
\end_layout

\begin_layout Standard
We have seen that some true theorems of Boolean logic are not true in constructi
ve logic.
 For example, the Boolean identities 
\begin_inset Formula $\neg\left(\neg\alpha\right)=\alpha$
\end_inset

 and 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=(\neg\alpha\vee\beta)$
\end_inset

 do not hold in the constructive logic.
 However, as we will now show, any theorem of constructive logic is also
 a theorem of Boolean logic.
 The reason is that all eight rules of constructive logic (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

) also hold in Boolean logic.
\end_layout

\begin_layout Standard
To verify that a formula is true in Boolean logic, it is sufficient  to
 check that the value of the formula is 
\begin_inset Formula $True$
\end_inset

 for all possible truth values (
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

) of its variables.
 A sequent such as 
\begin_inset Formula $\alpha,\beta\vdash\gamma$
\end_inset

 is true in Boolean logic if and only if 
\begin_inset Formula $\gamma=True$
\end_inset

 under the assumption that 
\begin_inset Formula $\alpha=\beta=True$
\end_inset

.
 So, the sequent 
\begin_inset Formula $\alpha,\beta\vdash\gamma$
\end_inset

 is translated into the Boolean formula:
\begin_inset Formula 
\[
\alpha,\beta\vdash\gamma=\left(\left(\alpha\wedge\beta\right)\Rightarrow\gamma\right)=\left(\neg\alpha\vee\neg\beta\vee\gamma\right)\quad.
\]

\end_inset

Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 translates all proof rules of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-rules-of-proof"
plural "false"
caps "false"
noprefix "false"

\end_inset

 into Boolean formulas.
 The first two lines are axioms, while the subsequent lines are Boolean
 theorems that can be verified by calculation.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Constructive logic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Boolean logic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{}{\Gamma\vdash{\cal CH}(\bbnum 1)}\quad(\text{create unit})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\neg\Gamma\vee True=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{~}{\Gamma,\alpha\vdash\alpha}\quad(\text{use value})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\neg\Gamma\vee\neg\alpha\vee\alpha=True$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\Rightarrow\beta}\quad(\text{create function})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\neg\alpha\vee\beta\right)=\left(\neg\Gamma\vee\left(\alpha\Rightarrow\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\quad\Gamma\vdash\alpha\Rightarrow\beta}{\Gamma\vdash\beta}\quad(\text{use function})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\left(\neg\Gamma\vee\alpha\right)\wedge\left(\neg\Gamma\vee\left(\alpha\Rightarrow\beta\right)\right)\right)\Rightarrow\left(\neg\Gamma\vee\beta\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\quad\Gamma\vdash\beta}{\Gamma\vdash\alpha\wedge\beta}\quad(\text{create tuple})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\alpha\right)\wedge\left(\neg\Gamma\vee\beta\right)=\left(\neg\Gamma\vee\left(\alpha\wedge\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\wedge\beta}{\Gamma\vdash\alpha}\quad(\text{use tuple-}1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\left(\alpha\wedge\beta\right)\right)\Rightarrow\left(\neg\Gamma\vee\alpha\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\vee\beta}\quad(\text{create \texttt{Left}})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\alpha\right)\Rightarrow\left(\neg\Gamma\vee\left(\alpha\vee\beta\right)\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\frac{\Gamma\vdash\alpha\vee\beta\quad\Gamma,\alpha\vdash\gamma\quad\Gamma,\beta\vdash\gamma}{\Gamma\vdash\gamma}\quad(\text{use \texttt{Either}})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left(\neg\Gamma\vee\alpha\vee\beta\right)\wedge\left(\neg\Gamma\vee\neg\alpha\vee\gamma\right)\quad\quad$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\quad\quad\wedge\left(\neg\Gamma\vee\neg\beta\vee\gamma\right)\Rightarrow\left(\neg\Gamma\vee\gamma\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proof rules of constructive logic are true also in the Boolean logic.
\begin_inset CommandInset label
LatexCommand label
name "tab:Proof-rules-of-constructive-and-boolean"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To simplify the calculations, note that all terms in the formulas contain
 the operation 
\begin_inset Formula $\left(\neg\Gamma\vee...\right)$
\end_inset

 corresponding to the context 
\begin_inset Formula $\Gamma$
\end_inset

.
 Now, if 
\begin_inset Formula $\Gamma$
\end_inset

 is 
\begin_inset Formula $False$
\end_inset

, the entire formula becomes automatically 
\begin_inset Formula $True$
\end_inset

, and there is nothing else to check.
 So, it remains to verify the formula in case 
\begin_inset Formula $\Gamma=True$
\end_inset

, and then we can simply omit all instances of 
\begin_inset Formula $\neg\Gamma$
\end_inset

 in the formulas.
 Let us show the Boolean derivations for the rules 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use function}$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use
\begin_inset space ~
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

; other formulas are checked in a similar way:
\begin_inset Formula 
\begin{align*}
\text{formula ``use function''}:\quad & \left(\alpha\wedge\left(\alpha\Rightarrow\beta\right)\right)\Rightarrow\beta\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\gunderline{\neg}(\alpha\,\gunderline{\wedge}\,(\neg\alpha\,\gunderline{\vee}\,\beta))\vee\beta\\
\text{de Morgan's laws}:\quad & =\gunderline{\neg\alpha\vee(\alpha\wedge\neg\beta)}\vee\beta
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{identity }p\vee(\neg p\wedge q)=p\vee q\text{ with }p=\neg\alpha\text{ and }q=\beta:\quad & =\neg\alpha\vee\gunderline{\neg\beta\vee\beta}\\
\text{axiom ``use value''}:\quad & =True\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{formula ``use \texttt{Either}''}:\quad & \left(\left(\alpha\vee\beta\right)\wedge\left(\alpha\Rightarrow\gamma\right)\wedge\left(\beta\Rightarrow\gamma\right)\right)\Rightarrow\gamma\\
\text{use Eq.~(\ref{eq:ch-definition-of-implication-in-Boolean-logic})}:\quad & =\neg\left(\left(\alpha\vee\beta\right)\wedge\left(\neg\alpha\vee\gamma\right)\wedge\left(\neg\beta\vee\gamma\right)\right)\vee\gamma\\
\text{de Morgan's laws}:\quad & =\left(\neg\alpha\wedge\neg\beta\right)\vee\gunderline{\left(\alpha\wedge\neg\gamma\right)}\vee\gunderline{\left(\beta\wedge\neg\gamma\right)}\vee\gamma\\
\text{identity }p\vee(\neg p\wedge q)=p\vee q:\quad & =\gunderline{\left(\neg\alpha\wedge\neg\beta\right)\vee\alpha}\vee\beta\vee\gamma\\
\text{identity }p\vee(\neg p\wedge q)=p\vee q:\quad & =\gunderline{\neg\alpha\vee\alpha}\vee\beta\vee\gamma\\
\text{axiom ``use value''}:\quad & =True\quad.
\end{align*}

\end_inset

Since each proof rule of the constructive logic is translated into a true
 formula in Boolean logic, it follows that a proof tree in the constructive
 logic will be translated into a tree of Boolean formulas that have value
 
\begin_inset Formula $True$
\end_inset

 for each axiom or proof rule.
 The result is that any constructive proof for a sequent such as 
\begin_inset Formula $\emptyset\vdash f(\alpha,\beta,\gamma)$
\end_inset

 is translated into a chain of Boolean implications that look like this:
\begin_inset Formula 
\[
True=(...)\Rightarrow(...)\Rightarrow...\Rightarrow f(\alpha,\beta,\gamma)\quad.
\]

\end_inset

Since 
\begin_inset Formula $\left(True\Rightarrow\alpha\right)=\alpha$
\end_inset

, this chain proves the Boolean formula 
\begin_inset Formula $f(\alpha,\beta,\gamma)$
\end_inset

.
\end_layout

\begin_layout Standard
For example, the proof tree shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Proof-of-the-sequent-example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is translated into:
\begin_inset Formula 
\begin{align*}
\text{axiom ``use valuue''}:\quad & True=\left(\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\neg\alpha\vee\alpha\right)\\
\text{rule ``create function''}:\quad & \quad\Rightarrow\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\left(\alpha\Rightarrow\alpha\right)\quad.\\
\text{axiom ``use value''}:\quad & True=\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\quad.\\
\text{rule ``use function''}:\quad & True\Rightarrow\left(\neg\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\vee\beta\right)\\
\text{rule ``create function''}:\quad & \quad\Rightarrow\left(\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\Rightarrow\beta\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It is easier to check Boolean truth tables than to find a proof tree in
 constructive logic (or to establish that no proof tree exists).
 If we find that a formula is 
\emph on
not
\emph default
 true in Boolean logic, we know it is also not true in constructive logic.
 This gives us a quick way of proving that some type signatures are 
\emph on
not
\emph default
 implementable as fully parametric functions.
 However, if a formula is true in Boolean logic, it does not follow that
 the formula is also true in the constructive logic.
\end_layout

\begin_layout Standard
In addition to formulas shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Logical-formulas-not-Boolean-theorems"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

), here are three more examples of formulas that are 
\emph on
not
\emph default
 true in Boolean logic:
\begin_inset Formula 
\[
\forall\alpha.\,\alpha\quad,\quad\quad\forall(\alpha,\beta).\,\alpha\Rightarrow\beta\quad,\quad\quad\forall(\alpha,\beta).\,(\alpha\Rightarrow\beta)\Rightarrow\beta\quad.
\]

\end_inset

These formulas are also 
\emph on
not
\emph default
 true in the constructive logic.
\end_layout

\begin_layout Subsection
The constructive logic and the law of excluded middle
\end_layout

\begin_layout Standard
Computations in the Boolean logic are often performed using truth tables.
 It is perhaps surprising that the proof rules of the constructive logic
 are 
\emph on
not
\emph default
 equivalent to checking whether some propositions are 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

 via a truth table.
 A general form of this statement was proved by K.
\begin_inset space ~
\end_inset

G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\begin_inset Quotes erd
\end_inset

o
\end_layout

\end_inset

del
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kurt@Kurt G
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\begin_inset Quotes erd
\end_inset

o
\end_layout

\end_inset

del
\end_layout

\end_inset

 in 1932.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "plato.stanford.edu/entries/intuitionistic-logic-development/"
target "https://plato.stanford.edu/entries/intuitionistic-logic-development/#SomeEarlResu"
literal "false"

\end_inset


\end_layout

\end_inset

 In this sense, constructive logic does 
\emph on
not
\emph default
 imply that every proposition is either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This is not intuitive and requires getting used to.
 Reasoning in the constructive logic must use the axioms and derivation
 rules directly, instead of truth tables.
\end_layout

\begin_layout Standard
The Boolean logic can use truth tables because every Boolean proposition
 may be assumed in advance to be either 
\begin_inset Formula $True$
\end_inset

 or 
\begin_inset Formula $False$
\end_inset

.
 This can be written as the formula 
\begin_inset Formula $\forall\alpha.\,(\neg\alpha\vee\alpha=True)$
\end_inset

.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Proof-rules-of-constructive-and-boolean"
plural "false"
caps "false"
noprefix "false"

\end_inset

 uses the Boolean identity 
\begin_inset Formula $\left(\alpha\Rightarrow\beta\right)=(\neg\alpha\vee\beta)$
\end_inset

, which does not hold in the constructive logic, to translate the constructive
 axiom 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{use value}$
\end_inset


\begin_inset Quotes erd
\end_inset

 into the Boolean axiom 
\begin_inset Formula $\neg\alpha\vee\alpha=True$
\end_inset

.
 The formula 
\begin_inset Formula $\forall\alpha.\,\neg\alpha\vee\alpha=True$
\end_inset

 is known as the 
\series bold
law of excluded middle
\series default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Law_of_excluded_middle"
target "https://en.wikipedia.org/wiki/Law_of_excluded_middle"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
law of excluded middle
\end_layout

\end_inset

 It is remarkable that the constructive logic 
\emph on
does not have
\emph default
 the law of excluded middle.
 It is neither an axiom nor a derived theorem in constructive logic.
\end_layout

\begin_layout Standard
To see why, translate the constructive logic formula 
\begin_inset Formula $\forall\alpha.\,\neg\alpha\vee\alpha=True$
\end_inset

 into a type.
 The negation operation (
\begin_inset Formula $\neg\alpha$
\end_inset

) is defined as the implication 
\begin_inset Formula $\alpha\Rightarrow False$
\end_inset

.
 So, the formula 
\begin_inset Formula $\forall\alpha.\,\neg\alpha\vee\alpha$
\end_inset

 corresponds to the type 
\begin_inset Formula $\forall A.\,\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

.
 Can we compute a value of this type via fully parametric code? For that,
 we need to compute either a value of type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 or a value of type 
\begin_inset Formula $A$
\end_inset

.
 This decision needs to be made in advance independently of 
\begin_inset Formula $A$
\end_inset

, because the code of a fully parametric function must operate in the same
 way for all types.
 As we have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset

, a value of type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 exists if the type 
\begin_inset Formula $A$
\end_inset

 is itself 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 But we do not know in advance whether 
\begin_inset Formula $A=\bbnum 0$
\end_inset

.
 Since there are no values of type 
\begin_inset Formula $\bbnum 0$
\end_inset

, and the type parameter 
\begin_inset Formula $A$
\end_inset

 could be, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, we cannot compute a value of type 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

.
 For similar reasons, we cannot compute a value of type 
\begin_inset Formula $A$
\end_inset

 either.
\end_layout

\begin_layout Standard
Is it really impossible to implement a value of the type 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

? We could reason like this: the type 
\begin_inset Formula $A$
\end_inset

 is either void or not void.
 If 
\begin_inset Formula $A$
\end_inset

 is void then 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)\cong\bbnum 1$
\end_inset

 is not void (as Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-A-0"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows).
 So, one of the types in the disjunction 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

 should be non-void and have values that we can compute.
\end_layout

\begin_layout Standard
While this argument is true, it does not help implementing a value of type
 
\begin_inset Formula $\left(A\rightarrow\bbnum 0\right)+A$
\end_inset

 via fully parametric code.
 It is not enough to know that one of the two values 
\begin_inset Quotes eld
\end_inset

should exist
\begin_inset Quotes erd
\end_inset

.
 We need to know 
\emph on
which
\emph default
 of the two values exists, and we need to write code that computes that
 value.
 That code may not decide what to do depending on whether the type 
\begin_inset Formula $A$
\end_inset

 is void, because the code must work in the same way for all types 
\begin_inset Formula $A$
\end_inset

 (void or not).
 As we have seen, that code is impossible to write.
\end_layout

\begin_layout Standard
In Boolean logic, one may prove that a value 
\begin_inset Quotes eld
\end_inset

should exist
\begin_inset Quotes erd
\end_inset

 by showing that the non-existence of a value is contradictory in some way.
 However, any practically useful program needs to 
\begin_inset Quotes eld
\end_inset

construct
\begin_inset Quotes erd
\end_inset

 (i.e., to compute) actual values.
 The 
\begin_inset Quotes eld
\end_inset

constructive
\begin_inset Index idx
status open

\begin_layout Plain Layout
constructive logic
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 logic got its name from this requirement.
 So, it is the constructive logic (not the Boolean logic) that provides
 correct reasoning about the types of values computable by fully parametric
 functional programs.
\end_layout

\begin_layout Standard
If we drop the requirement of full parametricity, we 
\emph on
could
\emph default
 implement the law of excluded middle
\begin_inset Index idx
status open

\begin_layout Plain Layout
law of excluded middle
\end_layout

\end_inset

.
 Special features of Scala (reflection, type tags, and type casts) allow
 programmers to compare types as values and to determine what type was given
 to a type parameter when a function is applied:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

import scala.reflect.runtime.universe._
\end_layout

\begin_layout Plain Layout

   // Convert the type parameter T into a special value.
\end_layout

\begin_layout Plain Layout

def getType[T: TypeTag]: Type = weakTypeOf[T]
\end_layout

\begin_layout Plain Layout

   // Compare types A and B.
\end_layout

\begin_layout Plain Layout

def equalTypes[A: TypeTag, B: TypeTag]: Boolean = getType[A] =:= getType[B]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // excludedMiddle has type ${
\backslash
color{dkgreen}
\backslash
forall A.
\backslash
left(A
\backslash
rightarrow
\backslash
bbnum 0
\backslash
right)+A}$.
\end_layout

\begin_layout Plain Layout

def excludedMiddle[A: TypeTag]: Either[A, A => Nothing] =
\end_layout

\begin_layout Plain Layout

   if (equalTypes[A, Nothing]) Right((identity _).asInstanceOf[A => Nothing])
    // Return ${
\backslash
color{dkgreen}
\backslash
text{id}:
\backslash
bbnum 0
\backslash
rightarrow
\backslash
bbnum 0}$.
\end_layout

\begin_layout Plain Layout

   else if (equalTypes[A, Int]) Left(123.asInstanceOf[A])      // Produce
 some value of type Int.
\end_layout

\begin_layout Plain Layout

   else if (equalTypes[A, Boolean]) Left(true.asInstanceOf[A]) // Produce
 some value of type Boolean.
\end_layout

\begin_layout Plain Layout

   else ???        // Write more definitions to support all other Scala
 types.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> excludedMiddle[Int]
\end_layout

\begin_layout Plain Layout

res0: Either[Int,Int => Nothing] = Left(123)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> excludedMiddle[Nothing]
\end_layout

\begin_layout Plain Layout

res1: Either[Nothing,Nothing => Nothing] = Right(<function1>) 
\end_layout

\end_inset

In this code, we check whether 
\begin_inset Formula $A=\bbnum 0$
\end_inset

.
 If so, we can implement 
\begin_inset Formula $A\rightarrow\bbnum 0$
\end_inset

 as an identity function of type 
\begin_inset Formula $\bbnum 0\rightarrow\bbnum 0$
\end_inset

.
 Otherwise, we know that 
\begin_inset Formula $A$
\end_inset

 is one of the existing Scala types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

, etc.), which are not void and have values that we can simply write down
 one by one in the subsequent code.
 
\end_layout

\begin_layout Standard
Explicit
\begin_inset Index idx
status open

\begin_layout Plain Layout
type casts
\end_layout

\end_inset

 
\series bold
type casts
\series default
, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123.asInstanceOf[A]
\end_layout

\end_inset

, are needed because the Scala compiler cannot know that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 in the scope where we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(123)
\end_layout

\end_inset

.
 Without a type cast, the compiler will not accept 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset

 as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in that scope.
\end_layout

\begin_layout Standard
The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

asInstanceOf
\end_layout

\end_inset

 is dangerous because the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.asInstanceOf[T]
\end_layout

\end_inset

 disables the type checking for the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 This tells the Scala compiler to believe that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 even when the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

 is inconsistent with the actually given code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 The resulting programs compile but may give unexpected results or crash.
 These errors would have been prevented if we did not disable the type checking.
 In this book, we will avoid writing such code whenever possible.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
showing here this is equivalent in Scala just different syntax importantly
 non theorems cannot be implemented in code some on theorems are statements
 in logic that cannot be derived statements that are false or undereye verbal
 examples of these statements are these for all a from one follows a now
 this is certainly suspicious in terms of logic what if a were false then
 we would have it from true false false that's very obviously wrong and
 we cannot implement a function of this type to implement it we would have
 to take a unit argument and produce a value of type a where a is arbitrary
 type but how can we produce a value of type a of the type that we don't
 even know what it is and there is no data for us to produce that value
 so it is impossible another example of an impossible type is this type
 so from a plus B follows a if you wanted to implement this function you
 would have to take a value of disjunction type a plus B and return a value
 of type a but how can you do that what exodus Junction type happens to
 contain B and no a just B it cannot contain a if it contains a B it's a
 disjunction so then we don't have an A and then we again cannot produce
 any and having a B which is a completely different arbitrary type doesn't
 help us to produce me exactly the same reason shows why we cannot produce
 an A a and B given a because that requires a B we cannot produce and also
 this is not implementable because we are required to produce an A but all
 we have is a function from A to B this function will consume an A if given
 only this function cannot possibly produce an A for us but we are required
 to produce an A as a result so we cannot and also there is no proof of
 this formula in the logic so these examples actually lead us to a natural
 question how can we decide given a certain formula whether it is a theorem
 in logic and therefore whether it can be implemented in code it is not
 obvious consider this example can we write a function with this type in
 Scala it is not obvious can we prove this formula it is not clear not quite
 obvious right now suppose I were of the opinion that this cannot be proved
 but how do I show that this cannot be proved I certainly cannot just try
 all possible proofs that would be infinitely many possible proofs that
 would give me all kinds of other formulas and that would give me nothing
 that I can stand oh how to answer these questions so it is really a very
 hard question we are not going to try to answer it on our own we were going
 to use the results of mathematicians they have studied these questions
 for many many years for centuries logic has been studied since ancient
 Greece more than 2,000 years of study all we need to do is to find out
 by what name mathematicians call this logic they are probably already studied
 it what kind of logic is this that we are using that follows from the type
 constructions remember and the very beginning of our consideration we started
 with the type constructions that our programming languages have so that's
 set of type constructions specifies the set of rules of derivation of the
 logic mathematicians call this logic intuitionistic propositional logic
 or IPL also they call it constructive propositional logic but it is less
 frequently used most frequently used name is this and mathematicians also
 call this a non classical logic because this logic is actually different
 from the boolean logic that we are familiar with the logic of the values
 true and false and their truth tables I assume that you are familiar with
 those computations using truth tables and operations and or not in the
 boolean logic so actually this logic the logic of types as I call it or
 intuitionistic propositional logic is very different from boolean logic
 in certain ways it's similar in other ways disjunction for instance works
 very differently here's an example consider this sequence if it has given
 that from a follows B plus C then either from a follows B or from a follows
 C it sounds right from the common-sense point of it if if B plus C Falls
 a B or C if I was I'm using plus as a logical or so if B or C follows then
 it kind of makes sense either B follows or C Falls indeed this is correct
 in the boolean logic which we can find out by writing the truth table so
 we enumerate all the possibilities for a B and C to be true or false or
 eight such possibilities and for each of those possibilities we write the
 truth value of this the truth value of this and we see from the table that
 whenever this is true then this is also true in the boolean logic but this
 does not hold in the intuitionistic logic for the logic of types well why
 does it not hold that's counterintuitive well in fact there is very little
 that's intuitive about this so-called intuitionistic logic actually we
 need to think differently about this logic we need to think can we implement
 an expression of this sequent so implementing it would mean if we're given
 this expression we can build an expression of this type so we're given
 an expression of type A to B plus C let's say some F of this type can we
 build an expression of this type we can this differently by asking can
 we implement a function that takes this as an argument and returns this
 well we know that this is equivalent one of our derivation rules is that
 if you have this sequence then you can also have a sequence that is a function
 type from this to this so for the programmer it is easier to reason about
 a function taking this as an argument and returning this so how can we
 implement this function this function takes F and needs to return a value
 of this type so the body of this function if we could implement it and
 have to construct a value of type either of something there are only two
 ways of constructing a value of type either one is to construct the left
 value second is to construct the right value how do we decide whether to
 construct the left value or the right value we have to decide it somehow
 on the basis of what information can we decide it we don't actually have
 any such information what we have here is a function from a to either BC
 so given some value of a of type a we could compute f of that value and
 then we would have either B or C we could decide them whether to we could
 take them that B or that C but that's not what we need to return we don't
 need to return either of BC we need to return either of this function or
 that function and that function is not yet applied to any a it is it is
 too late for us to ask what is the a we already have to return the left
 of this or a right of that in other words this type either of something-somethi
ng is not itself a function of a it contains functions away but itself it
 cannot be decided on the basis of any assets too late so we need to supply
 a left or right so here right away immediately we have to decide whether
 this will return a left or a right and we cannot really decide that if
 we decide we return the left we must then return a function from A to B
 so there's no way for us to construct this function if we're given this
 function because this function could sometimes return C instead of B and
 then we'll be stuck we cannot do this and we can also return we cannot
 also return the right either so it is impossible to implement a function
 of this type implication also works a little differently in the intuitionistic
 logic here's an example this holds in boolean logic but not in intuitionistic
 logic again let's see why how can we compute this given this this function
 will give us an e only when given an argument of this type but how can
 we produce a value of this type we cannot we don't have information that
 will allow us to produce a value of this type a and B are some arbitrary
 types remember there is universal quantifier outside of all this for all
 a and for all B we're supposed to produce this and that is impossible we
 don't have enough data to produce some values type a and so we cannot implement
 this function conjunction works kind of the same as in boolean logic so
 here's an example this implemented and this is also in boolean logic a
 true theorem now in boolean logic the usual way of deciding whether something
 is true or something is a theorem is to write a truth table unfortunately
 the intuitionistic logic cannot have a truth table it cannot have a fixed
 number of truth values even if you allow more than two truth values such
 that the validity of formulas the truth of theorems can be decided on the
 basis of the truth table this was shown by noodle and this means we should
 not actually try to reason about this logic using truth values it is not
 very useful even an infinite infinite number of truth values will not help
 instead however it turns out that this logic has a decision procedure or
 an algorithm and this algorithm is guaranteed either to find the proof
 for any given formula of the internation intuitionistic logic or to determine
 that there is no proof for that formula the algorithm can also find several
 in equivalent proofs if there is a theorem so a theorem could have several
 in equivalent proofs and since each proof could be automatically translated
 into code of that type it means we could generate several in equivalent
 expressions of some type sometimes so that is the situation with this logic
 which we discover if we write if we read papers about intuitionistic propositio
nal logic that are available in the literature and their open source projects
 on the web such as the gen GHC which is a compiler plugin for haskell this
 is another project doing the same thing and for Scala are implemented occurred
 the Clary Howard library both of these Scala and Haskell all of these color
 and Haskell projects do the same thing they take a type of some expression
 for function and generate code for it automatic by translating the type
 into sequence finding a proof in this logic using the algorithm and translating
 that proof back into code in the way that we have seen in an example it
 is interesting that all these provers and there's a few others there's
 one more for the idris language I did not mention here they all used the
 same decision procedure or the same basic algorithm which is called ljt
 which was explained in a paper by dick off here they all side the same
 paper and I believe this is so because most other papers on this subject
 are unreadable to non-specialists they are written in a very complicated
 way or they describe algorithms that are too complicated so I will show
 how this works in the rest of this tutorial in order to find out how to
 get an algorithm we need to ask well first of all do we have the rules
 of derivation that allow us to create an algorithm already here is a summary
 of the axioms and the rules of derivation that we have found so far these
 are direct translations of the cold expressions that we held in the programming
 language in the notation of sequence now there's one other notation for
 derivation rules which looks like a fraction like this the numerator is
 one or more sequins and the denominator is a sequence and this notation
 means in order to derive what is in the denominator you have to present
 proofs for what is in the numerator so this is the convention in the literature
 this fraction like syntax or notation now we keep in mind that proofs of
 sequence are actually just called expressions that have these types as
 some variables and this type is the entire expression so these are directly
 responding to proofs of this sequence and to the proofs of these derivation
 rules and so if we have a proof that operates by combining some of these
 axioms and some of these generation rules which directly translate that
 back into code now the question is do these rules give us an algorithm
 for finding a proof the answer is no how can we use these rules to obtain
 an algorithm well suppose we need to prove some sequence like this in order
 to prove it we could first see if the sequence is one of the axioms if
 so then we have already proved if we know what expression to write now
 in this case none of the axioms match this so much means maybe a is a times
 B so B here is C and then on the Left we must have C or you must have a
 times B now we don't you don't have C on the left as we have because even
 that's not the same we also don't have a times B at the premise we have
 a but we don't have a times B so these rules don't match the other rules
 don't match the premises and the goal either but also these rules so how
 can we use them well when the writer must be an implication we don't have
 an application on the right here we could try to delete some of the premises
 because it's unused well actually it doesn't look like a good idea could
 you read a for example and we end up with an really hopeless sequence from
 B plus C we cannot get an A ever and so but sounds hopeless so this doesn't
 seem to help and changing the order doesn't seem to help much either and
 so we cannot find matching rules but actually this sequence is provable
 just a clever combination of what axiom to start with and what role to
 use and then again some axiom and so on it will give us that time sure
 because I know how to write code for this this is not difficult you have
 a function with two arguments one of them is a the other is B plus C so
 disjunction of either B C and we are supposed to produce a disjunction
 of tuple a B or C that's easy look at this disjunction if we have a B in
 this disjunction then we can produce a left of the tuple a B because we
 always have an A anyway if we have a see in this disjunction then we could
 return this part of the disjunction in the right of C and we're done but
 unfortunately we see that the rules here do not give us an algorithm for
 deciding this we need a better formulation of the logic again mathematicians
 need to save us from the situation and they have done so mathematicians
 have studied this logic for a long time starting from the early 20th of
 the last century the first algorithmic formulation of the logic that was
 found is due to Jensen who published what he called the calculus just ignore
 the word calculus it means not very much complete and sound calculus means
 that he came up with some rules of derivation which are summarized here
 such that they are equivalent to these they derive all the same theorems
 and only the same theorems so they derive all the stuff that is right and
 only that stuff they don't derive any wrong statements it's very hard to
 come up with such a system of axioms and derivation rules that are equivalent
 to another one in this sense also it's very hard to prove that these are
 actually the rules that will give you all the theorems that could be right
 in this logic that you can actually derive all the theorems that are right
 yet work is already done by mathematicians so we're not going to try to
 do it ourselves we're just going to understand how these rules work now
 the syntax here is slightly enhanced compared with this the enhancement
 is that their names pretty cool now these are just labels they don't really
 do anything in terms of sequence these help us identify which we all have
 has been applied to which sequence and that's all we do so other than that
 it is the same notation so the fraction such as this one means that there
 is a sequence in the denominator which we will prove if there are proofs
 given for sequence in the numerator in this rule there are two sequence
 of them in the numerator other rules may have one sequence in the numerator
 or no sequence in the numerator so these rules that will have no previous
 sequence required those are axioms this axiom means if you have an atomic
 X in other words it's a variable it's a type variables not not a complicated
 expression just attack variable and you can derive that same variable this
 is our accion right here now why is it important that this is atomic that
 this is type variable and not a more complicated expression actually not
 important but it's the simplest rule that you can come up with and mathematicia
ns always like the most minimal set of rules so that's why they say let's
 only consider this rule for the type variables X not for more complicated
 expressions but we can consider this rule for any expression of course
 the identity axiom well here is a truth truth axiom net which derives the
 truth which is the ste symbol which I denote it by one the format in logical
 notation this is the T symbol well let's just call this one for clarity
 so that can be derived from any premises with no previous sequence necessary
 none of these other rules now what do these other rules do they do an interesti
ng thing actually each of these rules is either about something in the sequence
 on the left to the trans time or something in the sequence to the right
 of the transplant which I here shown in blue so these are the interesting
 parts of the sequence that are being worked on or transformed by the rule
 so here's an example this rule is actually two rules the eyes the index
 so I is one or two another two rules just written for gravity like this
 with index I and each of them says you will prove this if you prove one
 of if you prove this so for example you will prove C given if you're given
 a a one A two if you will prove C given just a one which makes sense because
 if you can prove C given a one you don't need a two we can ignore this
 a T we can already proved C from anyone so in this way it would be proved
 and so all these rules work in this way you can prove what's on the bottom
 of the seat of the of the fraction if you're given proofs for what's on
 the top so these are eight derivation rules and two axioms we can use this
 now to make a proof search how do we do that I start with a sequence we
 see which rule matches that sequence so the sequence must have something
 on the left and something on the right well at least one of these it cannot
 be empty so it must be something somewhere and there are only four kinds
 of expressions in our logic type variables conjunctions implications and
 disjunctions now notice I'm using this arithmetic arithmetic all notation
 for logic just because I like it better and I will show that it has advantages
 later so we take a sequence we see which rule matches one of them won't
 match because either in the premise we have one of these expressions were
 in the goal we have one of these expressions and then we find the rule
 of match that matches we apply that rule so we now have new sequence one
 or more that we will need to be proved and if they're true then we fork
 the tree and now we have to prove both of them son-in we continue doing
 that for each of the sequence until we hit axioms so the tree will and
 this leaf or we hit a sequence to which no rule applies in which case we
 cannot prove it and the entire thing is unprovable so in the search tree
 there will be sequence at the nodes of the tree and proofs will be at the
 edges of the tree so each node sends its proof to the root of the tree
 this calculus is guaranteed by mathematicians to be such that indeed if
 you cannot find a rule that applies that means the sequence cannot be proved
 which was not the case here the sequence can be proved and yet we cannot
 find a rule that applies so in this calculus we can use bottom-up approach
 to make a proof search as a tree here we cannot that is the advantage capitaliz
ing on the mathematicians results let us look at an example suppose we want
 to prove this formula this theorem so first step we need to write a sequence
 and this needs to be proved from no premises so we write a sequence s0
 which has an empty set of premises this is a single now what rule applies
 to this sequence with your bottom up so in other words we look at these
 rules and they refine which denominator matches our sequential and our
 cylinders empty set on the left so all the rules on the left cannot be
 applied but on the right we have an expression which is an implication
 at the top level of this expression there is this implies that so this
 is of the form a implies B so this rule applies we have a sequence of the
 form something in our case this is an empty set and then a implies B so
 we apply this rule which is the right implication and we get a new sequence
 which is that what was here before the implication is now put on the left
 to the trans of the to the left of the trans time and it means that this
 expression needs to be now to the left of the turnstile so now this is
 the sequence s1 now we need to prove s1 well we see what rule applies to
 us one well on the right there is just Q so nothing can be done of these
 rules and Q is not truth so we cannot use the axiom either so let's look
 at their left rules on the Left we have now an implication so this is let's
 say a and this is B so we have a rule which has a implication B on the
 left this is the row left implication let's apply it that law will give
 us two new sequence so these two new sequence are s2 and s3 no these ones
 as you can check if you match a location B against this implication Q so
 this is a this is B so then you get these two sequence now we have to prove
 these two sequence as 2 and s 3 s 3 is easy it is just the axiom of identity
 it is this now as 2 again has an implication on the left let's again apply
 the rule left implication to that we get two more sequence as foreign s5
 as for is this because 5 is this so now actually we are in trouble because
 as 2 and s 4 is are the same sequence as 5 actually we could prove with
 some more work but that won't help because we are in a situation when to
 prove as two we need to prove again s 2 so that's it that's a loop that
 will never give us anything it means we applied the wrong rule so we need
 to backtrack this step when we apply the rule left implication to s 2 we
 erase is 4 in this 5 and try a different rule to apply to s 2 which rule
 can apply to s 2 well as to is this it actually has implication on the
 right so we can use the right implication rule and if we do that we get
 a sequence s 6 which is this and this sequence immediately follows from
 the identity axiom because it has promise are on the left and premise are
 and goal are on the right and that is this axiom whatever other premises
 and the premise X on the left premise X on the right and that is a type
 variable so that's perfect we have done the proof as 6 follows from the
 axiom and therefore we have proved s0 no more sequins need to be proved
 and because sequence s0 shows this to be derived from no premises than
 this formula is the theorem that's what the theorem means in the logic
 so that is how we use this calculus to do proof search now we notice that
 we were a bit stuck at some point we had a loop now if we are in the loop
 we don't know what to do maybe we need to continue applying the same rule
 maybe some new sequence come up or maybe we should not continue it is not
 clear what to do and just looking at the rule left implication shows us
 that it's copying this premise a implication B it is copied into the premises
 of the new sequence and so it will generate a loop assuredly after the
 second time you apply it however this sequence might be new so we might
 need to apply it second time we don't know that so that is a problem it
 will do now there have been a lot of work trying to fix this problem and
 literally decades from research by mathematicians the main ones I found
 were what are the off we published in the Soviet Union who de Meyer and
 dick Hoff who published in the United States over this time discovered
 gradually a new set of rules which is called ljt or the calculus ljt which
 cures this problem of looping the way it clears this problem is by replacing
 this rule left implication through four new rules which are listed here
 all other rules are kept the same from this calculus except the rule left
 implication which is replaced in what way so left implication was applying
 it applied to a sequence when the sequin had an implication among the premises
 or on the left to the left of the turnstile the new rules look in more
 detail at what is that implication so that implication could have one of
 the four expressions as the argument of the implication it could have an
 atomic expression as the argument it would have a conjunction as the argument
 could have a disjunction as the argument or it could have an implication
 as the argument in our logic there are no more expressions except these
 four atomic variables conjunctions disjunction and implications and so
 we have here enumerated all the possibilities for what could be to the
 left of the implication in this premise which I have here shown in the
 blue in blue and so for each of these we do certain things replacing this
 sequence with one or more other sequence again it's quite a lot of work
 to prove that these rules are equivalent to these and also that the new
 rules are somehow better they are not giving loops a lot of work which
 I am NOT going to go through because that's far too complicated for the
 scope so what we need suffice it to say that we have very smart people
 who published on this and it is reasonably sure that this is correct so
 the T in the name lgt starts stands for terminating so if we use these
 rules in the same way by by creating a proof tree the proof tree will have
 no loops and will terminate after a finite number of steps and there is
 actually this paper that is also helpful for understanding how to implement
 this algorithm and this paper shows explicitly how to construct an integer
 function from sequence to integers which is a measure of the complexity
 of the sequence and this measure decreases every time you apply a rule
 so it strictly decreases and since this is a strictly decreasing measure
 on the proof tree it means that all the next nodes in the proof tree will
 have a smaller value of this measure so eventually it will hit zero and
 the proof tree will terminate at that leaf either that or you have no more
 rules to apply and if you have no more laws to apply then again mathematicians
 have proved it means our sequence cannot be proved so this is an important
 result that we are going to use and note that this this rule is quite complicat
ed it does a very interesting thing it takes this expression which has implicati
on inside an implication and it transforms this expression in a weird way
 namely the B here is separated from the C by parenthesis but here it is
 not separated so this transformation is highly non-trivial and unexpected
 and its validity is based on this theorem that this in the intuitionistic
 logic is equivalent to this equivalent means they're both following from
 the other so from this promos that and from there follows this so this
 key theorem was attributed to rob you off my dick off in this paper and
 this is this lemma 2 which says that if this sorry that the this derivation
 is if and only if that derivations will have these two equivalences and
 the proof is trivial and the 34 is a reference to to borrow be off now
 when a mathematician says that something is trivial doesn't mean that a
 statement is easy to understand it doesn't mean that the proof is easy
 to find or that it has trees easy to understand it means none of these
 things it just means that right now for this mathematician it is not interestin
g to talk about how it is done that's all it means could be for any number
 of reasons for example mathematicians could just be lazy or have no time
 to again explain this and so they say it's trivial don't be don't be deceived
 when you see somebody says that something is trivial in a mathematical
 text so to prove this one stepping stone could be to prove this first this
 is an easier theorem and if you prove this then clearly from here you can
 get B to C B to C you can substitute in here you can get a to B and then
 you have here a to B so in this way you can show this equivalence in one
 direction now the proof of this statement is obviously trivial in order
 to show the expression of this type I will use my short notation so this
 is F which has this type the first argument of the function the second
 is B which is at this type then we need to produce a see how do we produce
 a C we apply F to an argument of this type the argument of this type is
 a function that takes a and returns a B so we take some X of type a and
 we return a B which was this B so we ignore this X we just returned that
 B and that's the argument of F so this expression is the proof of this
 sequence in other words this is the code that has this type and therefore
 the proof must be available somehow so the details of proving this theorem
 are left as an exercise for the reader again when you see in a mathematical
 text that something is left as an exercise for the reader it does not mean
 that it is easy to do it does not mean that for you it would be a useful
 exercise to do it also does not mean that the author knows how to do it
 it means none of these things it just means the author doesn't feel like
 doing it right now and showing it to you for whatever reason could be because
 they are lazy it could be because I don't know how to do it could be because
 they feel that they should know how to do it but they don't really do know
 how to do it could be any of these reasons don't be deceived when you see
 something like this but of course I had to actually produce an expression
 function of this type in order to implement my curry forward language because
 as I will show in a moment we need to be able to implement all these has
 code in order to help approver so why is that we believe the mathematicians
 that the new rules are equivalent to the old rules which means that if
 you find a proof using these rules somehow you should be able to find the
 proof also using our initial rules which means that if you found that proof
 it would easily translate that to code because each step here is directly
 corresponding to a certain code expression as we have seen at the beginning
 of this tutorial these cold expressions from each of these operations so
 in order to do this with new rules in other words in order to create code
 from proof using new rules we need to show equivalence or we need to show
 how to get code out of each of the new rules now proof of a sequence means
 that we have some expression let's say T what uses variables a B and C
 of these types and expression itself has type G and also as I have shown
 this could be conveniently seen as a function the T as a function from
 a B and C from these three arguments to the type G so for each sequencing
 a proof we should be able to show either that it follows from an axiom
 one of these or that it show it follows from a derivation rule and the
 derivations all transforms one proof into another the axioms are just fixed
 expressions as we had before the axiom that actually didn't change between
 our initial formulation of the logic and the new calculus lgt they actually
 did not change the derivation rules changed each new derivation rule means
 that you're given expressions that prove the sequence in the numerator
 one or more and you are out of these expressions somehow you have to construct
 an expression that proves this sequence now when I say an expression proves
 the sequence what it means is that expression has the type that is described
 by the sequence it's the same thing because we described types of expressions
 through sequence and only those sequence that correspond to valid and existing
 expressions in the programming language only those sequence can be proved
 by the logic this is by construction so now we need to just find what are
 these expressions that corresponds to each of the derivation rules in each
 rule has a proof transformer function as I call it and the proof transfer
 function is explicitly a function that takes one or more expressions that
 are in the numerator and converts that to the expression in the denominator
 that has this type so it has an expression as it has an explicit function
 we need to write down for each of the derivation rules so let's see how
 this is done for these two examples of derivation laws first example have
 a rule that says if you want to derive this sequence we need to derive
 these two sequence now this sequence represents an expression of type C
 which uses an expression of type A plus B so let's represent this as a
 function from a plus B to C now we will be able to just ignore these other
 premises which are common arguments and all these functions we just pass
 them and we don't write them out what is the proof transformer for this
 derivation rule the proof transformer for it is a function that has two
 arguments t1 which is the proof of this must be a function of type II to
 see and t2 which is a proof of this sequence which must be a function of
 type B to see now earlier I said that sequence represent expressions that
 use certain variables but equivalently we can say these are functions that
 take these variables and return these expressions that's more convenient
 when you implement this in code so what we need is a function that takes
 a to C and B to C and returns a function from a plus B to C and this is
 the code that does it we take an argument of type a plus B and we return
 a match expression if it's in the left we applied t1 to that value and
 we get to see if it's in the right we apply t2 to that value and we get
 a C so in any case we get a syllabus so this is a function from a plus
 B to C as required another example is the proof transformer for this rule
 this rule has one sequence going to one sequence so in order to transform
 is proof into this we need a function that takes argument of type A to
 B to C to D and returns a function of type tuple a B going to C to D so
 here's the code we take a function f of type A to B to C to D we return
 a function that takes a G of this type shown here in blue and return we
 need to return a D so how do we get a deal we apply F to a function of
 type A to B to C so we create that function out of G X of type a going
 to Y of type B going to G of x1 so this is a function of type A to B to
 C which is the argument of F as required and the result is of type D so
 that is what we write so this kind of code is the proof transformer for
 this derivation arrow and we need to produce this proof transformers for
 every rule of the calculus lgt and I have done it because I have implemented
 the Korea Howard library that uses LG T so I'll must have done it for each
 flow this is a bit tedious because there are many of those rules and you
 need to implement all this machinery of passing arguments no matter how
 many in this gamma which are emitted from this notation for brevity but
 in of course in the real code you have to deal with all that too so let's
 see how this works on an example because once the proof tree is found we
 need to start backwards from the leaves of the tree back to the root on
 each step we take the proof expression apply the proof transformer to ative
 according to the rule that was used on that step we get a new proof expression
 and so on so for each sequence we will get a proof expression and at the
 end we'll have a proof expression for the root sequence and that will be
 the answer so I will denote denote by T I the proof expressions for the
 sequence s hi so starting from s6 s6 was this sequence in our proof so
 I mean yes just just going through the proof example it was here backwards
 from a 6 back to a 0 s-six was this it followed from axiom identity it's
 proof expression t6 is a function of two variables these two variables
 of these two types and this function just returns the second variable so
 it's a function of RR q and r and just denote this by our argued and Garibaldi'
s types r RQ variable of this type is hard here so this function is very
 simple just ignores the first argument and returns or so that is what the
 axiom does the next sequence was as to as to was obtained by rule our implicati
on or right implication from s 6 so the proof transformer for right implication
 let's look at the right implication and see what the proof transformer
 must be so we are given this sequence for this expression which is the
 function body the function body that uses a variable of type a somehow
 out of this we need to produce a function expression that takes an argument
 of type a and returns that functional body so this is the code which is
 just writing a new argument returning the function body that was our proof
 transformer we need to convert function body into a function so we just
 write that argument and arrow in the function body so in our case we need
 this as a function body and so our t2 is a function of our Q and this function
 is this the sequence s 3 followed from the axiom and so it was just this
 function this is just the identity function then we used the left implication
 so this was actually still done in the calculus algae but the same thing
 works in the calculus lgt I'm just using algae because it's simpler for
 example here proof transformer for the left implication is a little more
 complicated and so if you look at it what what does it have to be it takes
 these two expressions and returns this expression so it takes a function
 from A to B to a and from B to C and it returns a function from A to B
 to see how does it do it given a function a to b you use this to derive
 a from it then you substitute that a into the function into B you get a
 B when you use this to derive see from that B and that's your C so you
 use this function a to be twice you put it in here once and then you get
 an A and substitute back into the same function when you get a B then you
 use that and that's exactly what the proof transformer does it takes this
 rrq and it uses it twice substitutes into it something that was obtained
 from one of the terms and then uses the second term on the result so then
 this is the proof transformer for the rule left implication the result
 of the proof transformation is the proof for the sequence s1 finally we
 use the right implication again which is just this function construction
 and we get the proof expression for the sequence s0 now this proof expression
 is written through these t1 t2 t3 we have to substitute all this back in
 order to get the final expression so if we substitute first of all we find
 this is our our cubone going to tea one of our cutie one of our queue is
 this so we have to put it here now t3 is just identity so we can just remove
 that so that gets you riq going to our Q of T 2 T 2 is less if I have to
 put it in T 6 is just identity on R so this is our going to our and so
 finally you have this expression so that is the final code that has the
 required type notice that we have derived this code completely algorithmic
 to it there was no guessing we found which rules applied to the sequence
 with transformed sequence according to the rules once we found the proof
 which was if we use the calculus ljt the proof will be just a finite tree
 with no loops it will terminate you can get an exhaustive depth-first search
 for it for example and you find all the possible proofs if you want as
 well well you will find many in any case in some for some expressions and
 then we use the proof transformers which are fixed functions that you can
 upfront compute for each these expressions are proof transformers applied
 to the previous proofs so these are completely fixed algorithmically fixed
 so we have derived this code completely algorithmically given this expression
 this type so it is in this way that the career Howard correspondence allows
 us to derive the code of functions from there type signatures another important
 application of the correspondence is to analyze type by some morphisms
 or type equivalences and I was led to this by asking the question so in
 this logic or in the types are these operations plus and times as I denoted
 them more like logic more like the disjunction and conjunction or are they
 more like arithmetic plus and times because this is kind of not so clear
 right away our logic is this intuitionistic logic it in any case this is
 different from boolean logic so what are the properties of these types
 really so are the properties such that it is better to think about these
 operations as plus and times rather than logical conjunction and disjunction
 can answer this question I looked at identities that we have in the water
 these are some identities from simple ones obvious ones to less obvious
 identities like this the equal sign here stands for implication in both
 directions so both this implies that and vice versa because of this each
 of the implications means a function so since these are all identities
 in logic it means that for example the implication from here to here is
 a theorem of logic and so it can be implemented as we know all our identities
 in logic can be implemented in code and we even have an algorithm now that
 can automatically produce proofs and automatically produce code so that
 means for any of these identities that has some ik some expression X on
 the left and some Y on the right so some kind of X equals y we have X implies
 Y and y implies X if we convert that to code we will have a pair of functions
 function from X to one and the function from Y to X what do these functions
 do well they convert values in some ways from type X to type Y and back
 so do these functions Express the equivalence of the types x and y so that
 any value of type X can be converted to some equivalent value type while
 and back without any loss of information is that so that was the question
 I asked I looked at some examples well first what does it mean more rigorously
 that types are equivalent for as mathematicians say isomorphic the types
 are isomorphic and we will use this notation for that if there is a one-to-one
 correspondence between the sets of values of these types and in order to
 demonstrate that we need a pair of functions one going from A to B the
 other going from B to a such that the composition of these functions in
 both directions is equal to identity function so F compose G or F value
 G will give you from A to B and then from B to a is back so that would
 be identity of a to a this will be identity of B to B if this is true if
 the composition is identity it means we indeed did not lose any information
 let's consider an example this is an identity in the logic a conjunction
 with one is equal to a in Scala the types responding to the left and the
 right hand sides of this conjunction all of this are equivalent are the
 conjunction of a and unit and a itself now we need functions with these
 types indeed we can write functions is having these types a pair of a and
 unit we need to produce an a out of that we'll just take the first element
 of the pair you are done take an X of type a will produce tuple of a and
 unit very easy just put a unit value in the tuple in here done and it's
 easy to verify that composition of these functions will not change any
 values so it will be identity in both directions another example this is
 an identity in logic if this is understood as a disjunction one or a or
 true or a is true that is an identity in logic for theorem in the logic
 are the types equivalent though the type for 1 plus a is the option in
 Scala it is option in Haskell at is called maybe this type is standard
 library type in pretty much every functional programming language now option
 of a is a disjunction of one or unit and a it is certainly not equivalent
 to just unit because this type could contain a value of a in it but this
 could not so there is no way that you could transform this type to this
 and then back without losing information you could transform so since this
 is a theorem you have functions from this type to this type and back some
 functions you have them but these functions do not compose to identity
 they cannot because what if you had a here you must map it into unit from
 this unit back you must map into this unit you cannot get an a out of unit
 and so that will erase this information and that cannot become isomorphism
 so we see that some logic identities do yield isomorphism types but others
 do not why is that let's look at some more examples to figure out why in
 all these examples we can implement functions F 1 and F 2 between the two
 sets to two types in both directions and then we can check we certainly
 can implement them because these are logical identities but then we can
 check if the compositions are identity functions and if so the types are
 isomorphic but we find that in the first three examples we can do it but
 in this last example we can note now I have written the logical identities
 logical theorems with the arithmetic notation I call this arithmetical
 notation because this suggests arithmetic operations plus and times and
 if you look at these identities this looks like a well-known algebraic
 identity from the school algebra in this too but this certainly seen your
 own as an arithmetic as an as an arithmetic identity this is certainly
 not true in arithmetic it is true in logical if you replace this with disjuncti
on and this with conjunction this is an identity in logic so this suggests
 an interesting thing if you replace disjunction by plus and conjunction
 by x and the result is an identity in arithmetic then it is an isomorphism
 of types otherwise it is not let's see why this is so indeed this is so
 I call this the arithmetic arithmetic oh very hard correspondence to see
 how it works let's consider only the types without loss of generation of
 generality that have a finite set of possible values for example a boolean
 type has only two possible true and false integer let's say in the computers
 all the integers are fine nights ago so those types have a finite set of
 possible values and this does not limit our generality because in the computer
 everything is finite all types have a finite set of possible values now
 let's consider how many values a given type has so that would be the size
 of the type or using the mathematical terminology it's called a cardinality
 of the type so let's see what is the cardinality of various type constructions
 the sum type for example if the cardinality of types a and B is known and
 the cardinality of a plus B the sum type the disjunction of a and B is
 the sum of the two cardinalities or sizes this is because a value of the
 disjunction type is constructed as either a value of the first part or
 a value of the second part and so you cannot have both together and so
 obviously the different number of values is just the sum of the two sizes
 that the number of different values of the sum type is just the sum of
 the numbers of different values of types a and B for the product type again
 we have an interesting thing it's the arithmetic product of the sizes of
 a and B because for every a value you could have an arbitrary B value so
 this is a direct product or transient product of sets and we have school
 level identities about the operations plus and times such as these identities
 or these all of these identities are valid for arithmetic and they show
 if you translate that into statements about the sizes of types they show
 that the size of the type on the left is equal to the size of the type
 on the right and that is very suggestive in other words if you take a identity
 like this and you compute the size of the type on the left and the size
 of the type on the right you get an arithmetic identity of the sizes but
 you don't get that identity here because the earth medical formula is not
 right this is very suggestive if the sizes are equal and maybe the types
 are equivalent or isomorphic when the sizes are not equal then certainly
 they cannot be equivalent the function type very interestingly also is
 described in the same way it provides the set of all maps between the two
 sets of values so for example from integer to boolean that would be all
 the functions that take some integer and return some boolean so that's
 and a number of boolean values ^ the number of integer values that's how
 many different functions you can have as a combinatorial number so it's
 an exponential and so the size of the type of function a to be is the size
 of the type of B ^ the size of type of a and again we have all the school
 identities about powers and how to multiply powers and so on and they are
 directly translated into these three identities if you take the sizes of
 the types on the left and on the right the sizes will be equal due to these
 three identities since the sizes are equal it's very likely that the type
 our actual equivalent so far haven't seen any counter examples to this
 in these constructions so this gives us a meaning of the Curie Howard correspon
dence so far we have seen three facets of the curly Howard correspondence
 one is the correspondence between types and logical formulas two is the
 correspondence between code and proofs and three the correspondence between
 the cardinality of a type or the set size of the type and the arithmetic
 identities that we have in the school algebra about these types so arithmetical
 identities signify type equivalence or isomorphism while logic identities
 only talk about how you create some value of this type out of value of
 another type so that does not guarantee that it preserves information it
 just guarantees that you can implement some function of that type it doesn't
 tell you that the function will be an isomorphism so if one type is logically
 equivalent to another it means are equally implementable if one is implementabl
e another is also implementable but no more than that whereas arithmetical
 identities actually tell you about isomorphism of types therefore if you
 look at types and write them using my preferred notation which is using
 the arithmetic all symbols instead of logical symbols instead of these
 I'll use these symbols if I do that this is very suggestive of a possible
 isomorphism of types then it becomes very easy for me to reason about types
 I can see right away that these two are isomorphic types or that these
 two are isomorphic types because I am used to looking at school algebra
 it's very obvious then that this is not an isomorphism of types because
 this doesn't make sense in the school algebra so reasoning about isomorphic
 types is basically school level algebra involving polynomials and powers
 so if you are familiar with all these identities as you should be it will
 be very easy for you the reason about what types are equivalent as long
 as all these types are made up of constants or primitive types disjunctions
 tuples or conjunctions and functions which will then directly be translated
 into exponential polynomial expressions constants sums products and expand
 powers or Exponential's so I call these exponential polynomial types that
 is types built up from these type constructions so all we have been talking
 about in this tutorial is what I call exponential polynomial types these
 are the basic type constructions that I started with tuple product function
 exponential disjunction some unit constant or 1 now just one comment that
 in the functional programming community today there is a terminology algebraic
 types so people usually call algebraic types the types that are made from
 constant types sums and products excluding Exponential's I do not find
 this terminology it's very helpful I find it confusing because what is
 particularly an algebraic about these identities these are identities of
 school algebra the properties of the function type are described by algebraic
 identities like this so it would be strange to call the function type not
 algebraic whereas these types are algebraic they are very similar to each
 other in terms of their properties being described by identity is known
 from school algebra so instead of algebraic types I would prefer to say
 polynomial types this is much more descriptive and precise and if you want
 to talk about function types as well then you just can you can just say
 exponential polynomial types or exfoli types for short so by way of summarizing
 what we have done so far what are the practical implications of the career
 Howard correspondence so one set of implications is actually for writing
 code and reason and eternal code one thing we can do now is if we're given
 a function with some type and usually this will be typed with type parameters
 all type trainers fully parametric types such as the function we have been
 considering here all these functions do not have any types that are specific
 like integer or string all the types are fully parametric and then there
 are some constructions some type expressions made out of these types so
 these are what I call fully parametric functions for these functions we
 have a decision procedure an algorithm that based on the ljt calculus which
 decides whether this function can be implemented in code and computer scientist
s a type is inhabited if you can produce a value of this type in your program
 so CH of T is this proposition which they call type is inhabited and I
 prefer to call it just that you can compute a value of this type or code
 has the type O code can create a value of this type and so we have a algorithm
 that can also generate the code from type when it is possible if it is
 not possible the algorithm will tell you so often not always but often
 this algorithm can be used actually to generate the code you want we can
 also use what I call the arithmetic of glory Harvard correspondence to
 reason about type isomorphisms and to transform types isomorphic we simplify
 type expressions just like we simplify expressions in school level algebra
 by expanding brackets by permuting the order of terms like a plus B is
 equal to B plus a or associativity a times B all times C can be expanded
 and so on so this allows us once we have written types in the short notation
 in the notation that I prefer which resembles school algebra because it
 uses the plus and times symbols instead of the logic symbols so once we
 rewrite our types and this notation which I have been doing consistently
 in this tutorial it enables us the reason very easily but which types are
 equal or isomorphic because we are all familiar with the school level algebra
 what are the problems that we cannot solve using this knowledge one thing
 we cannot do is to generate code automatically such that it will be an
 isomorphism so for instance in an example here we are able to generate
 automatically the code of these functions but it will not be an isomorphism
 and the lgt algorithm cannot check that this is nice a morphism that's
 the important thing this algorithm does not know about equations or isomorphism
s it only knows that it found some code that has the type you wanted whether
 this code is useful to you or not we don't know the algorithm doesn't know
 this also if the algorithm finds several such several proofs of a sequence
 it will generate several not in equivalent versions of your code it doesn't
 know which one is is useful maybe some of them are useless maybe not the
 algorithm cannot automatically decide that in general another thing we
 cannot do is to express complicated conditions via types such as that array
 is sorted the type system is not powerful enough in all the languages I
 listed you need a much more powerful type system such as that in the programmin
g language interests or add them or cook those are much more powerful type
 systems that can express such complicated conditions but for those type
 systems there is no algorithm that will generate code another thing we
 cannot do is to generate code that has type constructors such as the map
 function here's an example in Scala this is a map function on a list so
 there's the list of a a is a type parameter and then we say dot map and
 map has another type frame to be it takes a function from A to B for any
 B so a is fixed but now from any B we can take a function from A to B and
 generate a list of B so if we wrote this formula in the short type notation
 this would look something like this I'm writing subscript a because this
 is a type parameter so this is like an argument or a type parameter I'm
 writing it like this and then from this this is the first argument of the
 function and then there is a second argument which is this F and that is
 another quantifier for B inside parentheses so this formula has a quantifier
 inside so far we have been dealing with formulas that have all quantifiers
 outside and so we never write quantifiers explicitly but here we have to
 write them inside this is a more powerful logic which is called first-order
 logic in other words this is a logic where you have quantifiers anywhere
 in the formula including inside the formula unfortunately this logic is
 undecidable so there is no algorithm that we can use either to find the
 proof and therefore code freedom type or to show that there is no proof
 no code so we're kind of stuck in all these directions some more remarks
 about the curry Harvard correspondence first is that only with parameterize
 types we can get some interesting information out of it if we take concrete
 types like integer then the proposition CH event meaning that our code
 can have a value of type int it that's always true can always write any
 some integer value we don't need any previous data for it so for all specific
 types all these propositions are always choice completely void of information
 the only interesting part comes when we start considering type variables
 if we start asking can we make a type which is either of a B going to a
 going to B in soon for all a B once we start doing this with type parameters
 a B and so on then we get interesting information as we have seen in this
 tutorial another remark is that functions like this one are not sufficiently
 described by their type so that this is the type of integer going to integer
 now looking at this type we can put this into a sequence but we'll never
 get enough information to actually get this function so only certain class
 of functions which are fully typed biometric their type signature is informativ
e enough so that we can derive code automatically only in much more powerful
 type systems you can have type information that is enough to specify fully
 a code like this another caveat is that I don't know the proof that arithmetic
 identity guarantees the type equivalence it is certainly a necessary condition
 because if two types have different cardinality or different size of their
 sets of values that they cannot be equivalent or they cannot be isomorphic
 so this is a necessary condition but it's not a sufficient condition it
 looks like I don't know if this is sufficient I haven't seen any counter
 examples so far final remarks about type correspondence the logical constant
 false did not appear in any of my slides so far this was on purpose it
 has extremely limited practical use in programming languages because actually
 we have types corresponding to false Scala has type called nothing Haskell
 has type usually called void that corresponds to the logical constant false
 what does it mean CH of nothing is false it means your code can never have
 a value of type nothing or in Haskell void you can never compute a value
 of this type so clearly it has a very limited practical significance you
 will never be able to compute any values of this type ever in any program
 it's identically falseness this constant so if you want to add it to the
 logic it's very easy you just have one rule and you're not done you can
 derive things with it if you want but they will have almost never any use
 in practical code also we did not talk about negation none of the calculus
 calculate that I should have in logical negation as in operation again
 for the same reason we do not have a programming language construction
 that represents logical negation negation by definition is like this is
 an application from 8 to 4 so that's not a not a means from a follows falsehood
 now since you cannot ever get false in a programming language you cannot
 really implement this function in any useful sense and so i have seen some
 haskell library that used this type void as a type parameter in some way
 but certainly it's a very limited and rare use and so it is not really
 lumen 18 to include negation it could probably find some very esoteric
 uses of it but almost never useful and finally there is another set of
 important implications from the Kurihara correspondence these are implications
 for people who want to design new programming languages as we have seen
 the Karaka with correspondence maps the type system of a programming language
 into a certain logical system where prepositions follow from each other
 or can be proved from each other and this enables us to reason about programmed
 to see what kind of code can be written if some other kind of code can
 be written and logical reasoning is very powerful it's simpler than trying
 to write code and it gives you algorithms and all kinds of mathematical
 results that have been found over the centuries so languages like those
 listed here have all the five type constructions that I wasted in the beginning
 of this tutorial and mapping them into logic gives a full constructive
 logic or full intuitionistic logic with all logical operations and or so
 conjunction disjunction implication and the truth constant whereas languages
 such as C C++ Java and c-sharp and so on they're mapped to incomplete logics
 because they do not have some of these operations for instance they do
 not have type constructions of correspond to disjunction we also do not
 have the true constant or the false constant so they are mapped to a logic
 that lacks some of the foundational logical operation so it can be only
 fewer theorems can be proved in that logic and so your reasoning about
 theory types is hampered languages called scripting languages sometimes
 such as Python or JavaScript will be and so on also our belongs there in
 that line those languages only have one type they actually don't check
 types at compile time and so they're mapped to logics with only one proposition
 those logics are extremely small in terms of what kind of things you can
 reason about and so if you write a program in these languages you are completel
y unable to reason at the level of types whereas in these languages you
 are able to reason but in a limited way you're not having a complete logic
 so this suggests a principle for designing the type system in a new programming
 language the first step would be to choose a good and complete logic that
 is free of inconsistency mathematicians have studied all kinds of logics
 and they are always interested in questions such as is this logic consistent
 consistent means you cannot derive false from true is this logic complete
 can you derive all things that are true are there enough axioms and rules
 of derivation or maybe there are too many axioms and rules of derivation
 you can delete some of them and have fewer mathematicians have always been
 interested in such questions they found all kinds of interesting logics
 where you can derive a lot of interesting theorems non trivial theorems
 and they found the minimum sets of axioms and rules of derivations for
 these logics use their results take one of the logics that they do them
 and develop such as intuitionistic logic model logic temporal logic linear
 logic and so on take one of these logics for each of the basic operations
 of this logic provide type constructions in your programming language that
 are easy to use for instance your logic has disjunction implication or
 something else provide a type constructor for each of them that's easy
 to use easy to write down such as provided by the languages we have seen
 then every type will be mapped to a logical form of the OPF logical formula
 for every type and there will be a type for every logical formula and then
 for each rule of the new logic for each derivation rule there should be
 a construct in the code that corresponds to it so that you could transform
 proofs in logic into code and code into proofs if you do that your language
 will be faithful to the scorecard correspondence you will be able to use
 logic to reason about your language and one important result at this level
 while we have seen that you can sometimes generate code that is maybe nice
 but a very important result is that if your logic is free of inconsistency
 it means that no program will ever be able to derive an inconsistent an
 inconsistent type means that you had a function that requires some type
 a but it was called with a different type beam which is incompatible and
 that basically crashes so in languages like C and C++ we have all kinds
 of crashes like a segmentation fault in Java the exceptions nullpointerexceptio
n or class cast exception which happens when you call a function on the
 wrong type of argument and that happens if your logic is inconsistent if
 your logic can derive incorrect statements from correct premises then if
 you translate that derivation into code and the that code will derive incompati
ble type at the wrong place and it will crash the crash will happen at runtime
 the compiler will not catch this inconsistency because the compiler only
 checks the logic of types and the logic checks out you have followed the
 rules of derivation of the logic the compiler can check out all these logical
 rules but the compiler does not know that your logic is inconsistent maybe
 and then it will deep have derived an inconsistent result falsehood from
 truth for example and that will crash at runtime now we know that crashing
 at runtime is not a good outcome so in fact languages like Oh camel have
 been studied and for other languages some subsets of Haskell I believe
 called safe Haskell have been studied and it has been shown that they cannot
 crash and they're the way to show it mathematically is to use the fact
 that they are based on a complete and consistent logic and then all you
 need to show is that your compiler does not have some critical bugs that
 allow it to oversee that you have not followed the derivation rules of
 the logic that is an extremely valuable feature of functional programming
 languages that are based on the Curie habit correspondence you can prove
 their safety at compile time or at least exclude a large number of possible
 bugs and errors certainly these languages are quite large and they include
 features that are not covered by the Carey Hart correspondence type constructor
s that I have not considered in this tutorial and those might may not be
 safe but at least the foundation of these languages the foundation of the
 type system will be safe so that is the final lesson from the great Howard
 correspondence this concludes the tutorial
\end_layout

\end_inset


\end_layout

\end_body
\end_document
