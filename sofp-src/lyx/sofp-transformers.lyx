#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{{\color{teal}#1}}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\pplus}{{\displaystyle }{+\negmedspace+}}
{{\color{lime}++}}
\end_inset


\end_layout

\begin_layout Chapter
Computations in functor blocks.
 III.
 Monad transformers
\begin_inset CommandInset label
LatexCommand label
name "chap:monad-transformers"

\end_inset


\end_layout

\begin_layout Section
Practical use
\end_layout

\begin_layout Subsection
Combining monadic effects via functor composition
\end_layout

\begin_layout Standard
Monads describe effects that depend on previously computed values.
 It is often necessary to combine effects of several monads in one.
 For example, the effect of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 is to compute values concurrently, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 represents a possibly missing value.
 We would like to describe a possibly missing value that is computed concurrentl
y.
 The type constructors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 are not compatible (not subtypes of each other), so we cannot simply use
 them together in one functor block:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {
\end_layout

\begin_layout Plain Layout

  x <- Future(1)
\end_layout

\begin_layout Plain Layout

  y <- Option(x + 1) // Type error.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One solution is to combine the effects of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 in a single 
\begin_inset Quotes eld
\end_inset

larger
\begin_inset Quotes erd
\end_inset

 monad.
 Perhaps the type constructor of that monad is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Option[A]]
\end_layout

\end_inset

? However, we run into a problem if we want to use this nested type directly
 in a functor block.
 For instance, this code will not compile:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {
\end_layout

\begin_layout Plain Layout

  xOpt <- Future(Option(1)) // We have xOpt: Option[Int] here.
\end_layout

\begin_layout Plain Layout

  x    <- xOpt              // Type error.
\end_layout

\end_inset

We cannot mix source lines of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 types because the source types must be compatible throughout the entire
 functor block.
 We could work with the nested type using code like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: Future[Option[Int]] = for {
\end_layout

\begin_layout Plain Layout

  xOpt <- Future(Option(1))  // xOpt: Option[Int]
\end_layout

\begin_layout Plain Layout

  tOpt <- xOpt match {       // yOpt: Option[Int]
\end_layout

\begin_layout Plain Layout

    case None      => Future.successful(None)     // This expression must
 be a Future[Option[Int]].
\end_layout

\begin_layout Plain Layout

    case Some(x)   => for {
\end_layout

\begin_layout Plain Layout

        yOpt <- Future(Option(x + 1))
\end_layout

\begin_layout Plain Layout

        zOpt <- yOpt match { // zOpt: Option[Int]
\end_layout

\begin_layout Plain Layout

          case None      => Future.successful(None) // Must return a Future[Optio
n[Int]] everywhere.
\end_layout

\begin_layout Plain Layout

          case Some(y)   => Future(Option(y + 3))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } yield zOpt
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

} yield tOpt
\end_layout

\end_inset

The type constructor forces us to use pattern matching with nested functor
 blocks, since that is the only way of getting access to values of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 within 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Option[A]]
\end_layout

\end_inset

.
 The code is repetitive and deeply nested, which makes it hard to read and
 to change.
 
\end_layout

\begin_layout Standard
The first step towards solving the problem is to rewrite this monadic program
 as a direct chain of computations depending on the results of previous
 ones:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: Future[Option[Int]] = for { // This will not compile!
\end_layout

\begin_layout Plain Layout

  x <- Future(Option(1))                // The type is x: Option[Int], although
 we wanted x: Int.
\end_layout

\begin_layout Plain Layout

  y <- Future(Option(x + 1))            // Type error: x + 1 is undefined.
\end_layout

\begin_layout Plain Layout

  z <- Future(Option(y + 3))
\end_layout

\begin_layout Plain Layout

} yield z
\end_layout

\end_inset

To be able to write code in this way, we need to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 operation directly on the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Option[A]]
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 To achieve that, let us wrap the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Option[A]]
\end_layout

\end_inset

 into a new class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FutOpt
\end_layout

\end_inset

 and implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods for that class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class FutOpt[A](nested: Future[Option[A]]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B)(implicit ec: ExecutionContext): FutOpt[B] = FutOpt(neste
d.map(_.map(f)))
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => FutOpt[B])(implicit ec: ExecutionContext): FutOpt[B]
 =
\end_layout

\begin_layout Plain Layout

    FutOpt(nested.flatMap {      // Provide a function Option[A] => Future[Option
[B]].
\end_layout

\begin_layout Plain Layout

      case None    => Future.successful(None) // Must return a Future[Option[B]]
 here.
\end_layout

\begin_layout Plain Layout

      case Some(x) => f(x).nested
\end_layout

\begin_layout Plain Layout

    })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import scala.concurrent.ExecutionContext.Implicits.global
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val result: FutOpt[Int] = for {      // This code compiles now.
\end_layout

\begin_layout Plain Layout

  x <- FutOpt(Future(Option(1)))     // x: Int
\end_layout

\begin_layout Plain Layout

  y <- FutOpt(Future(Option(x + 1))) // y: Int
\end_layout

\begin_layout Plain Layout

  z <- FutOpt(Future(Option(y + 3))) // z: Int
\end_layout

\begin_layout Plain Layout

} yield z
\end_layout

\end_inset

To shorten the code, we define conversions (
\begin_inset Quotes eld
\end_inset

lifts
\begin_inset Quotes erd
\end_inset

) from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FutOpt
\end_layout

\end_inset

 and from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FutOpt
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class FutOptLift1[A](fut: Future[A])(implicit ec: ExecutionContext)
 {
\end_layout

\begin_layout Plain Layout

  def up: FutOpt[A] = FutOpt(fut.map(x => Some(x)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class FutOptLift2[A](opt: Option[A]) {
\end_layout

\begin_layout Plain Layout

  def up: FutOpt[A] = FutOpt(Future.successful(opt))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now rewrite the previous code in a more readable form:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: FutOpt[Int] = for {
\end_layout

\begin_layout Plain Layout

  x <- Option(1).up     // x: Int
\end_layout

\begin_layout Plain Layout

  y <- Future(x + 1).up // y: Int
\end_layout

\begin_layout Plain Layout

  z <- Option(y + 3).up // z: Int
\end_layout

\begin_layout Plain Layout

} yield z  // This eventually evaluates to `FutOpt(Future.Successful(Some(5)))`.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We may hope to apply the same technique when mixing effects of arbitrary
 monads, such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: SomeBigMonad[Int] = for {  // After some definitions, this code
 should work:
\end_layout

\begin_layout Plain Layout

  x <- (1 to n).up                     // x: Int
\end_layout

\begin_layout Plain Layout

  y <- Future { computation(x) }.up    // y: Int
\end_layout

\begin_layout Plain Layout

  z <- Try { maybeError(y) }.up        // z: Int
\end_layout

\begin_layout Plain Layout

} yield z
\end_layout

\end_inset

This code will work if we somehow create a new monad that combines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.
 But it turns out that a simple composition of these type constructors in
 a certain chosen order (say, as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Future[Try[A]]]
\end_layout

\end_inset

, or as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Try[Seq[A]]]
\end_layout

\end_inset

, etc.) cannot be made into a lawful monad.
\end_layout

\begin_layout Standard
No simple recipe is known for combining two or more arbitrary monads into
 a 
\begin_inset Quotes eld
\end_inset

larger
\begin_inset Quotes erd
\end_inset

 monad.
 Certain techniques are known to work for specific kinds of monads.
 This chapter focuses on developing these techniques.
\end_layout

\begin_layout Standard
We have seen that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 are combined in a new monad as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Option[A]]
\end_layout

\end_inset

.
 Does functor composition always work? For some monads 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

, one of the compositions (
\begin_inset Formula $M_{1}\circ M_{2}$
\end_inset

 or 
\begin_inset Formula $M_{2}\circ M_{1}$
\end_inset

) may turn out to be a monad.
 However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Future[A]]
\end_layout

\end_inset

 is not a monad.
 By trial and error, we find further examples where the functor composition
 works and where it does not (see Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Correct-and-incorrect-compositions"
plural "false"
caps "false"
noprefix "false"

\end_inset

; incorrect choices are marked with a strike-through line).
\end_layout

\begin_layout Standard
It turns out that some monads do not compose in either order, while others
 have a 
\begin_inset Quotes eld
\end_inset

preferred
\begin_inset Quotes erd
\end_inset

 order.
 For instance, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad (
\begin_inset Formula $M^{A}\triangleq R\rightarrow A$
\end_inset

) always composes on the outside (as Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-construction-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows) but not necessarily on the inside.
 On the other hand, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad (
\begin_inset Formula $M^{A}\triangleq Z+A$
\end_inset

) always composes on the inside (we will prove that in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:transformers-linear-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

), but not necessarily on the outside.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-either-reader-not-compose"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-either-reader-not-compose"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Show that a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad does not compose inside of an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method's type signature cannot be implemented for the type constructor
 
\begin_inset Formula $F^{A}\triangleq Z+\left(R\rightarrow A\right)$
\end_inset

, where 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 are fixed (but otherwise unknown) types.
 Begin writing the code:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def flatMap[A, B](fa: Either[Z, R => A])(f: A => Either[Z, R => B]): Either[Z,
 R => B] = fa match {
\end_layout

\begin_layout Plain Layout

  case Left(z)    => Left(z)     // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Right(h)   => Right(r =>  // Cannot return a Left() here, since we
 have no values of type Z.
\end_layout

\begin_layout Plain Layout

      val x: Either[Z, R => B] = f(ra(r))     // Can compute a value `x`
 of type Either[Z, R => B].
\end_layout

\begin_layout Plain Layout

      ???                 )      // Need to return a value of type B here,
 using only r, ra, and f.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In line
\begin_inset space ~
\end_inset

3, we must decide whether to return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(...)
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(...)
\end_layout

\end_inset

, given only values 
\begin_inset Formula $h^{:R\rightarrow A}$
\end_inset

 and 
\begin_inset Formula $f^{:A\rightarrow Z+\left(R\rightarrow B\right)}$
\end_inset

.
 The decision must be hard-coded since at that point we have no values of
 type 
\begin_inset Formula $R$
\end_inset

 or 
\begin_inset Formula $A$
\end_inset

, so we cannot apply the functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 to any arguments.
 The only possible decision is to return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(...)
\end_layout

\end_inset

.
 But then we are not able to compute a value of type 
\begin_inset Formula $B$
\end_inset

 in the scope of lines
\begin_inset space ~
\end_inset

3–5 because we cannot guarantee that the value 
\begin_inset Formula $x^{:Z+\left(R\rightarrow B\right)}$
\end_inset

 contains a function 
\begin_inset Formula $R\rightarrow B$
\end_inset

 rather than a value of type 
\begin_inset Formula $Z$
\end_inset

.
 So, the typed hole 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

 in line
\begin_inset space ~
\end_inset

5 cannot be filled.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
When the monad composition works both ways, the two resulting monads are
 usually not equivalent: the effects combined in different order behave
 differently.
 For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad 
\begin_inset Formula $W\times A$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

appending a log message
\begin_inset Quotes erd
\end_inset

) and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad 
\begin_inset Formula $Z+A$
\end_inset

 (allowing failure) can be composed in two ways.
 The monad 
\begin_inset Formula $M^{A}\triangleq W\times\left(Z+A\right)$
\end_inset

 describes a computation that may fail but always appends a message.
 The monad 
\begin_inset Formula $M^{A}\triangleq Z+W\times A$
\end_inset

 will not append any message on failure.
\end_layout

\begin_layout Standard
Throughout this chapter, we will see other examples of monads whose effects
 can be combined in different order.
 The programmer needs to choose carefully the order of composition, according
 to the desired behavior of the effects.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Monad 
\begin_inset Formula $M_{1}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Monad 
\begin_inset Formula $M_{2}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $M_{1}\circ M_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
\begin_inset Formula $M_{2}\circ M_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Future}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Future}^{Z+A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\strikeout on
\begin_inset Formula $Z+\text{Future}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Future[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
State[S, A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\strikeout on
Future[State[S, A]]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\strikeout on
State[S, Future[A]]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
State[S, A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\strikeout on
State[S, Z => A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Z => State[S, A]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
State[S, A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
State[S, Either[Z, A]]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\strikeout on
Either[Z, State[S, A]]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\strikeout on
\begin_inset Formula $\text{List}^{Z\rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z\rightarrow\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{List}^{Z+A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\strikeout on
\begin_inset Formula $Z+\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\bbnum 1+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\strikeout on
\begin_inset Formula $\bbnum 1+\left(Z\rightarrow A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z\rightarrow\bbnum 1+A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $W\times A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $W\times\left(Z+A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $Z+W\times A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Correct-and-incorrect-compositions"

\end_inset

Correct and incorrect compositions of monads.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When functor composition works, implementing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

up
\end_layout

\end_inset

 methods is straightforward:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-lift-for-List-Try-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-lift-for-List-Try-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 monads for use in functor blocks.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 is a pass/fail monad, we must compose it 
\emph on
inside
\emph default
 other monads.
 So, we define the combined monad type as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Try[A]]
\end_layout

\end_inset

.
 We wrap the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Try[A]]
\end_layout

\end_inset

 into a class, implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 as methods, and then define the two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

up
\end_layout

\end_inset

 functions (the 
\begin_inset Quotes eld
\end_inset

lifts
\begin_inset Quotes erd
\end_inset

) as extension methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ListTry[A](value: List[Try[A]]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): ListTry[B] = ListTry(value.map(_.map(f)))
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => ListTry[B]): ListTry[B] = ListTry(
\end_layout

\begin_layout Plain Layout

    value.flatMap {        // Need to provide a function Try[A] => List[Try[B]]
 here.
\end_layout

\begin_layout Plain Layout

      case Failure(t)   => List(Failure(t))
\end_layout

\begin_layout Plain Layout

      case Success(a)   => f(a).value
\end_layout

\begin_layout Plain Layout

    })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def pure[A](a: A): ListTry[A] = ListTry(List(Success(a)))
\end_layout

\begin_layout Plain Layout

implicit class ListTryLift1[A](l: List[A]) { def up: ListTry[A] = ListTry(l.map(S
uccess(_))) }
\end_layout

\begin_layout Plain Layout

implicit class ListTryLift2[A](t: Try[A]) { def up: ListTry[A] = ListTry(List(t)
) }
\end_layout

\end_inset

After these definitions, we can write functor blocks that use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 and/or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 as needed:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for {
\end_layout

\begin_layout Plain Layout

         x <- List(1, 2, 3).up
\end_layout

\begin_layout Plain Layout

         y <- Try(x + 100).up
\end_layout

\begin_layout Plain Layout

       } yield y
\end_layout

\begin_layout Plain Layout

res0: ListTry[Int] = ListTry(List(Success(101), Success(102), Success(103)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for { x <- List(1, 2, 3).up; y <- Try(x + 100).up } yield y
\end_layout

\begin_layout Plain Layout

res0: ListTry[Int] = ListTry(List(Success(101), Success(102), Success(103)))
\end_layout

\end_inset


\end_layout

\end_inset

The following examples show that the functor composition does not always
 work.
 For instance, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad does not always compose with other monads in either order.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-state-monad-composition-fails-with-option"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-state-monad-composition-fails-with-option"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad fails to compose inside the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
There is no lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 function for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[State[S, A]]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type OpSt[A] = Option[S => (A, S)]                 // Here, the fixed type
 S must be already defined.
\end_layout

\begin_layout Plain Layout

def flatMap[A, B](fa: OpSt[A])(f: A => OpSt[B]): OpSt[B] = fa match {
\end_layout

\begin_layout Plain Layout

  case None      => None         // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Some(sta) => Some( s =>   // If we return `None` here, we will violate
 the monad identity law.
\end_layout

\begin_layout Plain Layout

         // We need to return a value of type (S, B) in this scope, using
 given values f, sta, and s.
\end_layout

\begin_layout Plain Layout

    val (s1, a) = sta(s) // We can compute another value of type s.
 But can we get a value of type B?
\end_layout

\begin_layout Plain Layout

    val b: B = f(a) match {     // The only way of possibly getting `b:
 B` is to apply `f` to an `A`.
\end_layout

\begin_layout Plain Layout

        case Some(stb)   => stb(s2)._2                         // Here, we
 can get a value of type B.
\end_layout

\begin_layout Plain Layout

        case None        => ??? // We are stuck: there is no way of returning
 a value of type B here.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ???                 )
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-state-monad-composition-fails-with-reader"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-state-monad-composition-fails-with-reader"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad fails to compose outside the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, R => A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type StR[A] = S => (R => A, S) // Here, the fixed types R and S must be
 already defined.
\end_layout

\begin_layout Plain Layout

def pure[A](a: A): StR[A] = { s => (_ => a, s) }
\end_layout

\begin_layout Plain Layout

def flatMap[A, B](fa: StR[A])(f: A => StR[B]): StR[B] = { s =>  // Need
 a value of type (R => B, S).
\end_layout

\begin_layout Plain Layout

  val (s1, ra): (S, R => A) = fa(s)                  // We now have two
 values (s and s1) of type S.
\end_layout

\begin_layout Plain Layout

  val rb: R => B = { r =>  // We can compute a value of type R => B.
 Trying to preserve information.
\end_layout

\begin_layout Plain Layout

    val a: A = ra(r)
\end_layout

\begin_layout Plain Layout

    val (s2, rb): (S, R => B) = f(a)(s1)
\end_layout

\begin_layout Plain Layout

    rb(r)   // We must discard s2 here.
 This loses information since we could not use `f` elsewhere.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  (rb, s1)  // We can only return (rb, s1) or (rb, s) here, since `s2` is
 not visible in this scope!
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

There is a problem with this implementation: The new state value 
\begin_inset Formula $s_{1}$
\end_inset

 is computed without using the function argument 
\begin_inset Formula $f$
\end_inset

.
 The only usage of 
\begin_inset Formula $f$
\end_inset

 (producing 
\begin_inset Formula $s_{2}$
\end_inset

) is hidden within the scope of the nameless function of type 
\begin_inset Formula $R\rightarrow B$
\end_inset

.
 So, even though we have tried to preserve information as much as possible,
 the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 must discard the second monad's effect.
 This will violate the identity law 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(x).flatMap(f) == f(x)
\end_layout

\end_inset

.
 That law cannot possibly hold if the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 ignores the function 
\begin_inset Formula $f$
\end_inset

 when computing the new state:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pure(x).flatMap(f)
\end_layout

\begin_layout Plain Layout

  == flatMap { s => (_ => x, s) } (f)
\end_layout

\begin_layout Plain Layout

  == { s =>
\end_layout

\begin_layout Plain Layout

  val (ra, s) = (_ => x, s)
\end_layout

\begin_layout Plain Layout

  val rb = ...
\end_layout

\begin_layout Plain Layout

  (rb, s)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The result always has the initial unmodified 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 as the second element of the pair.
 However, 
\begin_inset Formula $f$
\end_inset

 is an arbitrary function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

A => StR[B]
\end_layout

\end_inset

, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x): StR[B]
\end_layout

\end_inset

 could equal the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ s => (...
 , p(x, s)) }
\end_layout

\end_inset

, where the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(x, s)
\end_layout

\end_inset

 is not necessarily equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

s
\end_layout

\end_inset

.
 Therefore, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure(x).flatMap(f)
\end_layout

\end_inset

 is not equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 for arbitrary functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Combining monads via monad transformers
\end_layout

\begin_layout Standard
Not all monads combine with others via functor composition.
 But even for those that do, the method of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-lift-for-List-Try-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 requires us to write custom wrapper classes for each
\emph on
 pair
\emph default
 of monads.
 The length of the required code is then quadratic in the number of supported
 monads.
 
\begin_inset Quotes eld
\end_inset

Monad transformers
\begin_inset Quotes erd
\end_inset

 is the name of an approach for organizing the monad-combining code where
 the code size is only linear in the number of monads.
\end_layout

\begin_layout Standard
In that approach, we fix the first monad 
\begin_inset Formula $L$
\end_inset

 (the 
\begin_inset Quotes eld
\end_inset


\series bold
base
\series default

\begin_inset Quotes erd
\end_inset

 monad) and write code that combines 
\begin_inset Formula $L$
\end_inset

 with an 
\emph on
arbitrary
\emph default
 second monad 
\begin_inset Formula $M$
\end_inset

 (the 
\begin_inset Quotes eld
\end_inset


\series bold
foreign
\series default

\begin_inset Quotes erd
\end_inset

 monad).
 This implements a new monad denoted by 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 It turns out that the code of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 can be made fully parametric in the monad 
\begin_inset Formula $M$
\end_inset

: the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 will use only 
\begin_inset Formula $M$
\end_inset

's monad methods (
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

) and will work in the same way for all foreign monads 
\begin_inset Formula $M$
\end_inset

.
 The monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 is called 
\begin_inset Quotes eld
\end_inset

the monad 
\begin_inset Formula $L$
\end_inset

's transformer applied to 
\begin_inset Formula $M$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 So, the 
\series bold
monad
\series default
 
\begin_inset Formula $L$
\end_inset

's
\series bold
 transformer
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers
\end_layout

\end_inset

is the type constructor 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 viewed as a function of its type parameters 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

.
 We say 
\emph on
the
\emph default
 transformer 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 (rather than 
\emph on
a
\emph default
 transformer) because, as a rule, there is only one way of defining 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 (but see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-monads-with-two-different-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below for some exceptions to that rule).
\end_layout

\begin_layout Standard
To illustrate this approach, let us implement the transformer for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 monad.
 We begin with Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-lift-for-List-Try-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that combines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, but we now view 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 as the base monad and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 as the foreign monad.
 The goal is to replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 by an arbitrary foreign monad 
\begin_inset Formula $M$
\end_inset

, so that the resulting code works in the same way for all monads 
\begin_inset Formula $M$
\end_inset

.
 Begin by commenting the code of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-lift-for-List-Try-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to indicate the usage of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ListTry[A](value: List[Try[A]]) { // We will use List.map,
 List.pure, List.flatMap.
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): ListTry[B] = ListTry(value.map(_.map(f)))       
    // Using List.map here.
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => ListTry[B]): ListTry[B] = ListTry(
\end_layout

\begin_layout Plain Layout

    value.flatMap {         // Using List.flatMap here.
\end_layout

\begin_layout Plain Layout

      case Failure(t)   => List(Failure(t)) // This is List.pure(Failure(t)).
\end_layout

\begin_layout Plain Layout

      case Success(a)   => f(a).value
\end_layout

\begin_layout Plain Layout

    })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def pure[A](a: A): ListTry[A] = ListTry(List(Success(a)))          // This
 is List.pure(Success(a)).
\end_layout

\end_inset

It is now straightforward to generalize that code to an arbitrary foreign
 monad 
\begin_inset Formula $M$
\end_inset

:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

final case class TryT[M[_]: Monad : Functor, A](value: M[Try[A]]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): TryT[M, B] = TryT(value.map(_.map(f)))         //
 Using M$
\backslash
color{dkgreen}
\backslash
texttt{'}$s `map` here.
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => TryT[M, B]): TryT[M, B] = TryT(
\end_layout

\begin_layout Plain Layout

    value.flatMap {                                                 // Using
 M$
\backslash
color{dkgreen} 
\backslash
texttt{'}$s `flatMap` here.
\end_layout

\begin_layout Plain Layout

      case Failure(t)   => Monad[M].pure(Failure(t)) // Use Monad[M].pure(x)
 instead of List(x).
\end_layout

\begin_layout Plain Layout

      case Success(a)   => f(a).value
\end_layout

\begin_layout Plain Layout

    })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def pure[A](a: A): ListTry[A] = ListTry(Monad[M].pure(Success(a)))     //
 Using M$
\backslash
color{dkgreen} 
\backslash
texttt{'}$s `pure` here.
\end_layout

\end_inset

The 
\begin_inset Quotes eld
\end_inset

foreign lift
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

base lift
\begin_inset Quotes erd
\end_inset

 also use the methods of the foreign monad 
\begin_inset Formula $M$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class TryTLift[M[_]: Monad : Functor, A](m: M[A]) {
\end_layout

\begin_layout Plain Layout

  def up: TryT[M, A] = TryT(m.map(Success(_)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class TryTBaseLift[M[_]: Monad : Functor, A](t: Try[A]) {
\end_layout

\begin_layout Plain Layout

  def up: TryT[M, A] = TryT(Monad[M].pure(t))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

 After these definitions, we are able to combine 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 with any other monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

, as long as an implicit values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad[M]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Functor[M]
\end_layout

\end_inset

 are in scope.
 The code will look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val functorList: Functor[List] = ...
 // Create a Functor typeclass instance for List.
\end_layout

\begin_layout Plain Layout

implicit val monadList: Monad[List] = ...
     // Create a Monad typeclass instance for List.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val result = for {
\end_layout

\begin_layout Plain Layout

         x <- List(1, 2, 3).up
\end_layout

\begin_layout Plain Layout

         y <- Try(x + 100).up
\end_layout

\begin_layout Plain Layout

       } yield y
\end_layout

\begin_layout Plain Layout

res0: TryT[List, Int] = TryT(List(Success(101), Success(102), Success(103)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example defines a type constructor denoted by 
\begin_inset Formula $T_{\text{Try}}^{M,\bullet}$
\end_inset

 that works parametrically in the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 We can use 
\begin_inset Formula $T_{\text{Try}}^{M,A}$
\end_inset

 as a monad with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 (The foreign monad 
\begin_inset Formula $M$
\end_inset

 is the first type parameter in the transformer.) We will later implement
 transformers for other monads, such as 
\begin_inset Formula $T_{\text{Reader}}^{M}$
\end_inset

, 
\begin_inset Formula $T_{\text{Writer}}^{M}$
\end_inset

, 
\begin_inset Formula $T_{\text{State}}^{M}$
\end_inset

, etc.
 The advantage of the transformer approach is that the code for 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 needs to be written once for every base monad 
\begin_inset Formula $L$
\end_inset

, not for every pair of monads 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Subsection
Monad transformers for standard monads
\begin_inset CommandInset label
LatexCommand label
name "subsec:Monad-transformers-for-standard-monads"

\end_inset


\end_layout

\begin_layout Standard
While the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TryT
\end_layout

\end_inset

 works, it leads to more questions.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TryT
\end_layout

\end_inset

 is specific to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 monad and uses its internal structure (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Success
\end_layout

\end_inset

 subtypes).
 It is not obvious how to implement a monad transformer 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 for an arbitrary given base monad 
\begin_inset Formula $L$
\end_inset

.
 We expect the code for 
\begin_inset Formula $T_{L}^{M}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
's
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 methods to be parametric in 
\begin_inset Formula $M$
\end_inset

 but not in 
\begin_inset Formula $L$
\end_inset

.
 This is shown by the notation 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 where 
\begin_inset Formula $L$
\end_inset

 is a 
\emph on
subscript
\emph default
.
 Changing the base monad 
\begin_inset Formula $L$
\end_inset

 to another monad will require a complete rewrite of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

's code.
\end_layout

\begin_layout Standard
There is no general recipe for implementing a monad transformer 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 given the code for a monad 
\begin_inset Formula $L$
\end_inset

.
 Nevertheless, monad transformers are known for every monad defined by fully
 parametric code.
 Transformers for some monads are obtained via functor composition; for
 other monads, transformers need to be defined in special ways.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Known-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 lists the types of some known monad transformers.
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Base monad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Transformer type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq R\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq R\rightarrow M^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq Z+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq M^{Z+A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq A\times W$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq M^{A\times W}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times L^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq M^{\bbnum 1+A\times T_{L}^{M,A}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq A+\left(\bbnum 1\rightarrow A\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq M^{A+(\bbnum 1\rightarrow M^{A})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq S\rightarrow A\times S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq S\rightarrow M^{A\times S}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq\left(A\rightarrow R\right)\rightarrow R$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq(A\rightarrow M^{R})\rightarrow M^{R}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq\left(A\rightarrow R\right)\rightarrow A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}\triangleq(M^{A}\rightarrow R)\rightarrow M^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Known-monad-transformers"

\end_inset

Known monad transformers for some monads.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on the monad, the corresponding transformer is defined by composing
 inside the foreign monad (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

); by composing outside the foreign monad (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

); by wrapping a recursive definition inside the foreign monad (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

); or by mixing the foreign monad in a special way with the base monad (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

Eval
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
It is not always easy to determine the type of a monad transformer.
\begin_inset Foot
status open

\begin_layout Plain Layout
The difficulty of that task is illustrated by the history of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 transformer in the Haskell standard library.
 The transformer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 was implemented incorrectly in 2002; the code violated the monad laws.
 The faulty transformer remained in the library until 2007.
 See the discussion in 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://wiki.haskell.org/index.php?title=ListT_done_right"
literal "false"

\end_inset


\end_layout

\end_inset

 A justification for the types shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Known-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is that they work and obey the required laws, while no simpler transformers
 are known.
 Later in this chapter, we will prove that those and other monad transformers
 are correct.
 For now, we accept the results of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Known-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and turn to the practical use of monad transformers.
 
\end_layout

\begin_layout Standard
The first task is to obtain the code of monad methods and lifts for the
 transformers in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Known-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The type constructors for monad transformers are conventionally named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherT
\end_layout

\end_inset

, etc.
 
\end_layout

\begin_layout Paragraph
The 
\family typewriter
ReaderT
\family default
 transformer
\end_layout

\begin_layout Standard
The corresponding monad was already derived in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-construction-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ReaderT[M[_]: Monad : Functor, R, A](run: R => M[A]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): ReaderT[M, R, B] = ReaderT(r => run(r).map(f))
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => ReaderT[M, R, B]): ReaderT[M, R, B] = ReaderT {
\end_layout

\begin_layout Plain Layout

    r => run(r)            // Type is M[A].
\end_layout

\begin_layout Plain Layout

           .map(f)     // Type is M[ReaderT[M, R, B]].
\end_layout

\begin_layout Plain Layout

           .flatMap(_.run(r))  // Type is M[B].
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def pure[M[_]: Monad, A](a: A): ReaderT[M, A] = ReaderT(_ => Monad[M].pure(a))
\end_layout

\end_inset

The 
\begin_inset Quotes eld
\end_inset

foreign lift
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

base lift
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

 are implemented by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class ReaderTLift[M[_]: Monad : Functor, R, A](m: M[A]) {
\end_layout

\begin_layout Plain Layout

  def up: ReaderT[M, R, A] = ReaderT(_ => m) // This is the `pure` method
 of the Reader monad.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

implicit class ReaderTBaseLift[M[_]: Monad : Functor, R, A](t: R => A) {
\end_layout

\begin_layout Plain Layout

  def up: ReaderT[M, R, A] = ReaderT(r => Monad[M].pure(t(r)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The lifts are written in the code notation as:
\begin_inset Formula 
\begin{align*}
\text{foreign lift}:\quad & \text{flift}:M^{A}\rightarrow T_{\text{Reader}}^{M,A}\quad, & \text{flift}\,(m^{:M^{A}})\triangleq\_^{:R}\rightarrow m=\text{pu}_{\text{Reader}}(m)\quad,\quad~\\
\text{base lift}:\quad & \text{blift}:(R\rightarrow A)\rightarrow T_{\text{Reader}}^{M,A}\quad, & \text{blift}\,(t^{:R\rightarrow A})\triangleq r^{:R}\rightarrow\text{pu}_{M}(t(r))=t\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We have seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Reader-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that getting data out of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad requires a runner (
\begin_inset Formula $\theta_{\text{Reader}}$
\end_inset

), which is a function that calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run
\end_layout

\end_inset

 on some value of type 
\begin_inset Formula $R$
\end_inset

 (i.e., injects 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

's dependency value).
 In later sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-State-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-continuation-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we have seen other monads that need runners.
 Generally, a runner for a monad 
\begin_inset Formula $M$
\end_inset

 is a function of type 
\begin_inset Formula $M^{A}\rightarrow A$
\end_inset

.
 So, we may expect that the foreign monad 
\begin_inset Formula $M$
\end_inset

 could have its own runner (
\begin_inset Formula $\theta_{M}:M^{A}\rightarrow A$
\end_inset

).
 How can we combine 
\begin_inset Formula $M$
\end_inset

's runner (
\begin_inset Formula $\theta_{M}$
\end_inset

) with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

's runner? Since the type of 
\begin_inset Formula $T_{\text{Reader}}^{M}$
\end_inset

 is a functor composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, the runners can be used independently of each other.
 We can first run the effect of 
\begin_inset Formula $M$
\end_inset

 and then run the effect of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

:
\begin_inset Formula 
\[
(\theta_{M}^{\uparrow\text{Reader}}\bef\theta_{\text{Reader}}):(R\rightarrow M^{A})\rightarrow A\quad.
\]

\end_inset

Alternatively, we can run 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

's effect first (injecting the dependency) and then run 
\begin_inset Formula $M$
\end_inset

's effect:
\begin_inset Formula 
\[
(\theta_{\text{Reader}}\bef\theta_{M}):(R\rightarrow M^{A})\rightarrow A\quad.
\]

\end_inset

These runners commute because of the naturality law of 
\begin_inset Formula $\theta_{\text{Reader}}$
\end_inset

, which holds for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

:
\begin_inset Formula 
\[
f^{\uparrow\text{Reader}}\bef\theta_{\text{Reader}}=\theta_{\text{Reader}}\bef f\quad,\quad\text{so}\quad\theta_{M}^{\uparrow\text{Reader}}\bef\theta_{\text{Reader}}=\theta_{\text{Reader}}\bef\theta_{M}\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
The 
\family typewriter
EitherT
\family default
 transformer
\end_layout

\begin_layout Standard
is similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TryT
\end_layout

\end_inset

 since the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Throwable, A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
The 
\family typewriter
WriterT
\family default
 transformer
\end_layout

\begin_layout Standard
It is easier to begin with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method for the transformed monad 
\begin_inset Formula $T^{A}\triangleq M^{A\times W}$
\end_inset

, which has type signature:
\begin_inset Formula 
\[
\text{ftn}_{T}:M^{M^{A\times W}\times W}\rightarrow M^{A\times W}\quad,\quad\quad\text{ftn}_{T}\big(t^{:M^{M^{A\times W}\times W}}\big)=\text{???}^{:M^{A\times W}}\quad.
\]

\end_inset

Since 
\begin_inset Formula $M$
\end_inset

 is an unknown, arbitrary monad, the only way of computing a value of type
 
\begin_inset Formula $M^{A\times W}$
\end_inset

 is by using the given value 
\begin_inset Formula $t$
\end_inset

 somehow.
 The only way to get a value of type 
\begin_inset Formula $A$
\end_inset

 wrapped in 
\begin_inset Formula $M^{A\times W}$
\end_inset

 is by extracting the type 
\begin_inset Formula $A$
\end_inset

 from inside 
\begin_inset Formula $M^{M^{A...}...}$
\end_inset

.
 So, we need to flatten the two layers of 
\begin_inset Formula $M$
\end_inset

 that are present in the type of 
\begin_inset Formula $t$
\end_inset

.
 However, we cannot immediately apply 
\begin_inset Formula $M$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method to 
\begin_inset Formula $t$
\end_inset

 because 
\begin_inset Formula $t$
\end_inset

's type is not of the form 
\begin_inset Formula $M^{M^{X}}$
\end_inset

 with some 
\begin_inset Formula $X$
\end_inset

.
 To bring it to that form, we use 
\begin_inset Formula $M$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method:
\begin_inset Formula 
\[
t\triangleright(m^{:M^{A\times W}}\times w^{:W}\rightarrow m\triangleright(p^{:A\times W}\rightarrow p\times w)^{\uparrow M})^{\uparrow M}:M^{M^{A\times W\times W}}\quad.
\]

\end_inset

Now the type is well adapted to using both 
\begin_inset Formula $M$
\end_inset

's and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

's flatten methods:
\begin_inset Formula 
\begin{align*}
\text{ftn}_{T}\big(t^{:M^{M^{A\times W}\times W}}\big) & =t\triangleright(m^{:M^{A\times W}}\times w^{:W}\rightarrow m\triangleright(p^{:A\times W}\rightarrow p\times w)^{\uparrow M})^{\uparrow M}\triangleright\text{ftn}_{M}\triangleright(\text{ftn}_{\text{Writer}})^{\uparrow M}\quad,\\
\text{ftn}_{T} & =(m^{:M^{A\times W}}\times w^{:W}\rightarrow m\triangleright(p^{:A\times W}\rightarrow p\times w)^{\uparrow M})^{\uparrow M}\bef\text{ftn}_{M}\bef(\text{ftn}_{\text{Writer}})^{\uparrow M}\\
 & =\text{flm}_{M}(m\times w\rightarrow m\triangleright(p\rightarrow p\times w)^{\uparrow M}\bef\text{ftn}_{\text{Writer}}^{\uparrow M})\\
 & =\text{flm}_{M}(m\times w\rightarrow m\triangleright(a\times w_{2}\rightarrow a\times(w\oplus w_{2})))\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Translating this formula to Scala, we obtain the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class WriterT[M[_]: Monad : Functor, W: Monoid, A](t: M[(A, W)])
 {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): WriterT[M, W, B] = WriterT(t.map { case (a, w) =>
 (f(a), w) })
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => WriterT[M, W, B]): WriterT[M, W, B] = WriterT(
\end_layout

\begin_layout Plain Layout

    t.flatMap { case (a, w) => f(a).t.map { case (b, w2) => (b, w |+| w2) }
  
\end_layout

\begin_layout Plain Layout

  })
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[M[_]: Monad, W: Monoid, A](a: A): WriterT[M, W, A] =
\end_layout

\begin_layout Plain Layout

  WriterT(Monad[M].pure((a, Monoid[W].empty))
\end_layout

\end_inset

The 
\begin_inset Quotes eld
\end_inset

foreign lift
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

base lift
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

WriterT
\end_layout

\end_inset

 are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flift[A]: M[A] => M[(A, W)] = _.map { a => (a, Monoid[W].empty) }
\end_layout

\begin_layout Plain Layout

def blift[A]: ((A, W)) => M[(A, W)] = { t => Monad[M].pure(t) }
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{foreign lift}:\quad & \text{flift}:M^{A}\rightarrow T_{\text{Writer}}^{M,A}\quad,\quad\quad m^{:M^{A}}\triangleright\text{flift}\triangleq m\triangleright(a\rightarrow a\times e_{w})^{\uparrow M}\quad,\\
\text{base lift}:\quad & \text{blift}:\text{Writer}^{W,A}\rightarrow T_{\text{Writer}}^{M,A}\quad,\quad\quad\text{blift}\triangleq\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Comparing the lifts for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

WriterT
\end_layout

\end_inset

, we notice some common features of lifts for compositional transformers
 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherT
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

WriterT
\end_layout

\end_inset

): one of the lifts is equal to a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method, and the other is equal to a lifted 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method.
 We will see later that this pattern applies to all monad transformers defined
 via functor composition.
\end_layout

\begin_layout Paragraph
The 
\family typewriter
ListT
\family default
 transformer
\end_layout

\begin_layout Standard
is more complicated because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 is a recursive type.
 To shorten the code, we use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type to represent 
\begin_inset Formula $\bbnum 1+A\times T_{\text{List}}^{M,A}$
\end_inset

 in the recursive type 
\begin_inset Formula $T_{\text{List}}^{M,A}\triangleq M^{\bbnum 1+A\times T_{\text{List}}^{M,A}}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ListT[M[_]: Monad : Functor, A](value: M[Option[(A, ListT[M,
 A])]])
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad was implemented in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-flatten-verify-for-monad-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using the list concatenation function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

; 
\begin_inset Quotes eld
\end_inset

flattening
\begin_inset Quotes erd
\end_inset

 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[A]]
\end_layout

\end_inset

 means concatenating all nested lists.
 If the ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 were defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 would be:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ListO[A](value: Option[(A, ListO[A])])
\end_layout

\begin_layout Plain Layout

def concat[A](t1: ListO[A], t2: ListO[A]): ListO[A] = t1.value match {
\end_layout

\begin_layout Plain Layout

  case None => t2
\end_layout

\begin_layout Plain Layout

  case Some((a, tail)) => Some((a, concat(tail, t2))) // Recursive call.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We need to implement the analogous concatenation function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

.
 To visualize the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

, consider an example where the foreign monad is 
\begin_inset Formula $M^{A}\triangleq R\rightarrow A$
\end_inset

.
 Expand a few steps of recursion:
\begin_inset Formula 
\[
T_{\text{List}}^{M,A}=R\rightarrow\bbnum 1+A\times(R\rightarrow\bbnum 1+A\times(R\rightarrow...(R\rightarrow\bbnum 1+A\times T_{\text{List}}^{M,A})...))\quad.
\]

\end_inset

This type describes an 
\begin_inset Formula $M$
\end_inset

-effect wrapped around each next value of type 
\begin_inset Formula $A$
\end_inset

 in the list.
 To extract further values in the list, we need to run the nested effects.
\end_layout

\begin_layout Standard
This understanding helps us implement the concatenation function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

, called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def comb[M[_]: Monad : Functor, A](t1: ListT[M, A], t2: ListT[M, A]): ListT[M,
 A] = ListT( for {
\end_layout

\begin_layout Plain Layout

  first <- t1.value           // Run the first effect and get `first: Option[(A,
 ListT[M, A])]`.
\end_layout

\begin_layout Plain Layout

  rest  = first match {       // Compute `rest: M[Option[(A, ListT[M, A])]]`.
\end_layout

\begin_layout Plain Layout

           case None => t2.value
\end_layout

\begin_layout Plain Layout

           case Some((a, tail)) => Monad[M].pure(Some((a, comb(tail, t2))))
   // Recursive call.
\end_layout

\begin_layout Plain Layout

  y     <- rest
\end_layout

\begin_layout Plain Layout

} yield y)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are now ready to write the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ListT[M[_]: Monad : Functor, A](value: M[Option[(A, ListT[M,
 A])]]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): ListT[M, B] = ListT(t.map(_.map { // Use the map
 methods of M and Option.
\end_layout

\begin_layout Plain Layout

    case (head, tail) => (f(head), tail.map(f))
\end_layout

\begin_layout Plain Layout

  }))
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => ListT[M, B]): ListT[M, B] = ListT(
\end_layout

\begin_layout Plain Layout

    t.flatMap {    // Here we need a function of type Option[(A, ListT)]
 => M[Option[(A, ListT)]].
\end_layout

\begin_layout Plain Layout

      case None => Monad[M].pure(None)
\end_layout

\begin_layout Plain Layout

      case Some((head, tail)) => comb(f(head), tail).value       // Type
 is M[Option[(A, ListT)]].
\end_layout

\begin_layout Plain Layout

  })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 creates a single-element list, which uses a pair of an 
\begin_inset Formula $a^{:A}$
\end_inset

 and an empty list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[M[_]: Monad, A](a: A): ListT[M, A] =
\end_layout

\begin_layout Plain Layout

  ListT(Monad[M].pure(Some((a, ListT(Monad[M].pure(None))))))
\end_layout

\end_inset

The lifts for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flift[M[_]: Monad, A]: M[A] => ListT[M, A] = ListT(a => m.flatMap(ListT.pure(a
).value))
\end_layout

\begin_layout Plain Layout

def blift[M[_]: Monad, A]: List[A] => ListT[M, A] =
\end_layout

\begin_layout Plain Layout

  _.foldRight(Monad[M].pure(None)){ case (a, tail) => Monad[M].pure(Some((a,
 blift(tail)))) }
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{foreign lift}:\quad & \text{flift}:M^{A}\rightarrow T_{\text{List}}^{M,A}\quad,\quad\quad m^{:M^{A}}\triangleright\text{flift}\triangleq m\triangleright(a\rightarrow\bbnum 0+a\times\text{pu}_{M}(1+\bbnum 0))^{\uparrow M}\quad,\\
\text{base lift}:\quad & \text{blift}:\text{List}^{A}\rightarrow T_{\text{List}}^{M,A}\quad,\quad\quad\text{blift}\triangleq\,\begin{array}{|c||c|}
 & M^{\bbnum 1+A\times T_{\text{List}}^{M,A}}\\
\hline \bbnum 1 & 1\rightarrow\text{pu}_{M}(1+\bbnum 0)\\
A\times\text{List}^{A} & a\times t\rightarrow\text{pu}_{M}(\bbnum 0+a\times\overline{\text{blift}}\,(t))
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Finally, we turn to runners for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

.
 List-like monads usually represent 
\emph on
several
\emph default
 useful results rather than a single result.
 So, they may not need runners of type 
\begin_inset Formula $\text{List}^{A}\rightarrow A$
\end_inset

.
 Also, a list may be empty, which makes a fully parametric function of type
 
\begin_inset Formula $\text{List}^{A}\rightarrow A$
\end_inset

 impossible.
 However, the foreign monad 
\begin_inset Formula $M$
\end_inset

 may come with its runner 
\begin_inset Formula $\theta_{M}$
\end_inset

.
 We can use 
\begin_inset Formula $\theta_{M}$
\end_inset

 to run the 
\begin_inset Formula $M$
\end_inset

's effects and extract values from a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 into an ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 This is accomplished by a runner (call it 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

runListT
\end_layout

\end_inset

) that applies 
\begin_inset Formula $M$
\end_inset

's runner (
\begin_inset Formula $\theta_{M}$
\end_inset

) to a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT[M, A]
\end_layout

\end_inset

 and obtains a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

.
 The code may be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def runListT[A](runner: M[A] => A)(listT: ListT[M, A]): List[A] = runner(listT.va
lue) match {
\end_layout

\begin_layout Plain Layout

  case None                => List()
\end_layout

\begin_layout Plain Layout

  case Some((head, tail))  => head :: runListT(runner)(tail)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

However, this code will not always terminate.
 The reason is that the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 contains a layer of 
\begin_inset Formula $M$
\end_inset

 in every recursive step.
 So, extracting a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 from a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT[M, A]
\end_layout

\end_inset

 involves applying 
\begin_inset Formula $\theta_{M}$
\end_inset

 once per list value.
 When 
\begin_inset Formula $M$
\end_inset

 is of function type, a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT[M, A]
\end_layout

\end_inset

 is an 
\begin_inset Quotes eld
\end_inset

on-call
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
on-call value
\end_layout

\end_inset

 sequence whose elements are not available in advance but will be evaluated
 on demand when 
\begin_inset Formula $\theta_{M}$
\end_inset

 is applied.
 So, the total number of elements in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 may not be known in advance and may be infinite.
 Here is an example of an 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

 collection that uses the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad as 
\begin_inset Formula $M$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def ascend(n: Int): ListT[Reader[Int, *], Int] = ListT(Lazy(k => Some((n,
 ascend(n + k)))))
\end_layout

\end_inset

Evaluating 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ascend(n)
\end_layout

\end_inset

 gives a well-defined value representing the sequence 
\begin_inset Formula $\left[n,n+k,n+2k,...\right]$
\end_inset

.
 The parameter 
\begin_inset Formula $k$
\end_inset

 is passed via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad's dependency injection.
 It is clear that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

runListT
\end_layout

\end_inset

 will not terminate when applied to such a sequence.
 
\end_layout

\begin_layout Standard
This example shows how to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 for creating effectful streams of unbounded length.
 If we need to run the effects of 
\begin_inset Formula $M$
\end_inset

 for an unbounded-length stream, the target should be a stream type (i.e.,
 an on-call or a lazy list) rather than an eagerly evaluated 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type.
\end_layout

\begin_layout Standard
Another way of running the effects of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT[M, A]
\end_layout

\end_inset

 is to assume that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is a monoid type.
 For monoid types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we can implement the type signature 
\begin_inset Formula $\text{List}^{A}\rightarrow A$
\end_inset

 as a standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 operation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reduce[A: Monoid]: List[A] => A = {
\end_layout

\begin_layout Plain Layout

  case Nil            => Monoid[A].empty
\end_layout

\begin_layout Plain Layout

  case head :: tail   => head |+| reduce(tail)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Similar code gives a runner 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 that transforms 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT[M, A]
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M[A]
\end_layout

\end_inset

 for monoid types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def brun[M[_]: Monad, A: Monoid](listT: ListT[M, A]): M[A] = listT.value.flatMap
 {
\end_layout

\begin_layout Plain Layout

  case None                  => Monad[M].pure(Monoid[A].empty)
\end_layout

\begin_layout Plain Layout

  case Some((head, tail))    => Monad[M].pure(head) |+| brun(tail) // Monoid
 M[A].
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

For this code to work, we need a monoid instance for 
\begin_inset Formula $M^{A}$
\end_inset

 (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-of-monoid-is-monoid"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def monoidMA[M[_]: Functor : Monad, A: Monoid]: Monoid[M[A]] =
 ...
\end_layout

\end_inset

However, it remains unknown
\begin_inset Foot
status open

\begin_layout Plain Layout
This book does not have a proof.
 See Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details.
\end_layout

\end_inset

 whether this special version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 is a lawful monad morphism 
\begin_inset Formula $T_{\text{List}}^{M}\leadsto M$
\end_inset

 or even just a monoid morphism 
\begin_inset Formula $T_{\text{List}}^{M,A}\rightarrow M^{A}$
\end_inset

.
\end_layout

\begin_layout Paragraph
The 
\family typewriter
StateT
\family default
 transformer
\end_layout

\begin_layout Standard
The formula for that transformer's type, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT[M, S, A] = S => M[(S, A)]
\end_layout

\end_inset

, puts the foreign monad 
\begin_inset Formula $M$
\end_inset

 at a specific place within the type of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 Let us implement the monad methods for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class StateT[M[_]: Monad : Functor, S, A](run: S => M[(A, S)])
 {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): StateT[M, S, B] = StateT(s1 => run(s1).map { //
 Use the map method of M.
\end_layout

\begin_layout Plain Layout

    case (a, s2) => (f(a), s2)
\end_layout

\begin_layout Plain Layout

  })
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => StateT[M, S, B]): StateT[M, S, B] = StateT(s1 =>
 run(s1).flatMap {
\end_layout

\begin_layout Plain Layout

      case (a, s2) => f(a).run(s2)                // Use the updated intermediate
 state s2.
\end_layout

\begin_layout Plain Layout

  })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def pure[M[_]: Monad, S, A](a: A): StateT[M, S, A] = StateT(s => Monad[M].pure((a
, s)))
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
 & T_{\text{State}}^{M,A}\triangleq T^{A}\triangleq S\rightarrow M^{A\times S}\quad,\quad\quad\text{pu}_{T}\triangleq a^{:A}\rightarrow s^{:S}\rightarrow\text{pu}_{M}(a\times s)\quad,\label{eq:pure-for-stateT-transformer}\\
 & \text{flm}_{T}(f^{:A\rightarrow T^{B}})\triangleq t^{:T^{A}}\rightarrow s_{1}^{:S}\rightarrow t(s_{1})\triangleright\text{flm}_{M}(a\times s_{2}\rightarrow f(a)(s_{2}))\quad.\label{eq:flatmap-for-stateT-transformer}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The implementations of the lift functions for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 are:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flift[M[_]: Functor, S, A](m: M[A]): StateT[M, S, A] = StateT(s => m.map
 { a => (a, s) })
\end_layout

\begin_layout Plain Layout

def blift[M[_]: Monad, S, A](p: State[S, A]): StateT[M, S, A] = StateT(s
 => Monad[M].pure(p.run(s)))
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{foreign lift}:\quad & \text{flift}:M^{A}\rightarrow T_{\text{State}}^{M,A}\quad,\quad\quad m^{:M^{A}}\triangleright\text{flift}\triangleq s\rightarrow m\triangleright(a\rightarrow a\times s)^{\uparrow M}\quad,\\
\text{base lift}:\quad & \text{blift}:(S\rightarrow A\times S)\rightarrow T_{\text{State}}^{M,A}\quad,\quad\quad\text{blift}\triangleq p^{:S\rightarrow A\times S}\rightarrow p\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's runner (
\begin_inset Formula $\theta_{\text{State}}$
\end_inset

) substitutes a given initial state (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

) and extracts the final value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def runState[S, A](init: S)(p: State[S, A]): A = p.run(init)._1
\end_layout

\end_inset


\begin_inset Formula 
\[
\theta_{\text{State}}(i^{:S})\triangleq p^{:S\rightarrow A\times S}\rightarrow i\triangleright p\triangleright\pi_{1}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The transformer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 does not have a general base runner of the form 
\begin_inset Formula $\text{brun}\,(\theta_{\text{State}})$
\end_inset

: we cannot convert an 
\emph on
arbitrary
\emph default
 runner 
\begin_inset Formula $\theta_{\text{State}}:\text{State}^{S,A}\rightarrow A$
\end_inset

 into a function of type 
\begin_inset Formula $T_{\text{State}}^{M,A}\rightarrow M^{A}$
\end_inset

.
 Instead, we need to implement a specialized base runner that converts 
\begin_inset Formula $T_{\text{State}}^{M,A}$
\end_inset

 into 
\begin_inset Formula $M^{A}$
\end_inset

 by running the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's effects while keeping the effects of the foreign monad 
\begin_inset Formula $M$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def brunStateT[M[_]: Functor, S, A](init: S)(t: StateT[M, S, A]): M[A] =
 t.run(init).map(_._1)
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{brun}_{\text{State}}(i^{:S})\triangleq t^{S\rightarrow M^{A\times S}}\rightarrow i\triangleright t\triangleright\pi_{1}^{\uparrow M}\quad.
\]

\end_inset

If we need to run only the effects of 
\begin_inset Formula $M$
\end_inset

 but keep the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's effect, we need the following code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def frunStateT[M[_], S, A](runner: M[A] => A)(t: StateT[M, S, A]): State[S,
 A] = State { s =>
\end_layout

\begin_layout Plain Layout

  val m: M[(A, S)] = t.run(s)
\end_layout

\begin_layout Plain Layout

  runner(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{frun}_{\text{State}}(\theta^{:M^{A}\rightarrow A})\triangleq t^{:S\rightarrow M^{A\times S}}\rightarrow\left(s\rightarrow s\triangleright t\bef\theta\right)=t^{:S\rightarrow M^{A\times S}}\rightarrow t\bef\theta\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
The 
\family typewriter
ContT
\family default
 transformer
\end_layout

\begin_layout Standard
For the continuation monad (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont[R, A]
\end_layout

\end_inset

), the transformer's type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT[M, R, A]
\end_layout

\end_inset

 has a peculiar formula where the foreign monad's constructor 
\begin_inset Formula $M$
\end_inset

 wraps the type 
\begin_inset Formula $R$
\end_inset

 but is not applied to any values of the main value type 
\begin_inset Formula $A$
\end_inset

.
 The code for the monad methods is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ContT[M[_], R, A](run: (A => M[R]) => M[R]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): ContT[M, R, B] = ContT { (k: B => M[R]) => run(f
 andThen k) }
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => ContT[M, R, B]): ContT[M, R, B] = ContT { (k: B
 => M[R]) =>
\end_layout

\begin_layout Plain Layout

    val g: A => M[R] = a => f(a).run(k)
\end_layout

\begin_layout Plain Layout

    run(g) 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def pure[M[_], R, A](a: A): ContT[M, R, A] = ContT(k => k(a))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Turning now to the code for lifts, we can easily write the 
\begin_inset Quotes eld
\end_inset

foreign lift
\begin_inset Quotes erd
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flift[M[_]: Monad, R, A](m: M[A]): ContT[M, R, A] = ContT { (k: A =>
 M[R]) => m.flatMap(k) }
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{flift}:M^{A}\rightarrow(A\rightarrow M^{R})\rightarrow M^{R}=\text{flm}_{M}\quad.
\]

\end_inset

However, implementing the 
\begin_inset Quotes eld
\end_inset

base lift
\begin_inset Quotes erd
\end_inset

 is impossible: the required type signature
\begin_inset Formula 
\[
\text{blift}:(\left(A\rightarrow R\right)\rightarrow R)\rightarrow(A\rightarrow M^{R})\rightarrow M^{R}
\]

\end_inset

has no implementation parametric in the monad 
\begin_inset Formula $M$
\end_inset

.
 The reason is that we cannot produce a value of type 
\begin_inset Formula $R$
\end_inset

 out of 
\begin_inset Formula $M^{R}$
\end_inset

 parametrically (some monads have no runners), and so we cannot convert
 
\begin_inset Formula $A\rightarrow M^{R}$
\end_inset

 into 
\begin_inset Formula $A\rightarrow R$
\end_inset

.
 This prevents us from using the first argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 (a function of type 
\begin_inset Formula $(A\rightarrow R)\rightarrow R$
\end_inset

).
 Also, creating a value of type 
\begin_inset Formula $(A\rightarrow M^{R})\rightarrow M^{R}$
\end_inset

 from scratch is impossible.
 
\end_layout

\begin_layout Standard
To produce an explicit example where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 cannot be implemented, we use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curryhoward
\end_layout

\end_inset

 library
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
curryhoward
\family default
 library
\end_layout

\end_inset

 and choose a monad 
\begin_inset Formula $M^{R}$
\end_inset

 that has no fully parametric runner, e.g., 
\begin_inset Formula $M^{R}\triangleq Z+R$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import io.chymyst.ch._
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def blift[R, A]: Cont[R, A] => ContT[Either[Int, *], R, A] = implement
\end_layout

\begin_layout Plain Layout

Error:(43, 65) type ((A => R) => R) => (A => Either[<c>Int,R]) => Either[<c>Int,
R] cannot be implemented
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The absence of 
\begin_inset Quotes eld
\end_inset

base lift
\begin_inset Quotes erd
\end_inset

 for the continuation monad transformer means that we cannot use the continuatio
n monad in a functor block as freely as other monads.
 We cannot lift an arbitrary given value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont[R, A]
\end_layout

\end_inset

 into the transformed monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT[M, R, A]
\end_layout

\end_inset

.
 Values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont[R, A]
\end_layout

\end_inset

 may come from third-party libraries implemented in non-fully-parametric
 code.
 It may be impossible to rewrite that code to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT[M, R, A]
\end_layout

\end_inset

 with an arbitrary monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

.
 This deficiency of the continuation monad makes it unsuitable for certain
 applications.
 
\end_layout

\begin_layout Standard
The continuation monad also does not support foreign runners or base runners.
 The type signature of the method 
\begin_inset Formula $\text{frun}:T_{\text{Cont}}^{M,A}\rightarrow T_{\text{Cont}}^{N,A}$
\end_inset

 cannot be implemented with arbitrary monads 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 because the type 
\begin_inset Formula $T_{\text{Cont}}^{M,A}\triangleq(A\rightarrow M^{R})\rightarrow M^{R}$
\end_inset

 is not covariant in the type parameter 
\begin_inset Formula $M$
\end_inset

.
 The base runner's type signature, 
\begin_inset Formula $\text{brun}:((A\rightarrow M^{R})\rightarrow M^{R})\rightarrow M^{A}$
\end_inset

, cannot be implemented because there is no way of constructing a value
 of type 
\begin_inset Formula $M^{A}$
\end_inset

 out of a value of type 
\begin_inset Formula $M^{R}$
\end_inset

 (the type 
\begin_inset Formula $A$
\end_inset

 is arbitrary).
\end_layout

\begin_layout Paragraph
The 
\family typewriter
SelT
\family default
 transformer
\end_layout

\begin_layout Standard
Although the selector monad, 
\begin_inset Formula $\text{Sel}^{Z,A}\triangleq\left(A\rightarrow Z\right)\rightarrow A$
\end_inset

, resembles the continuation monad, its transformer is simpler because it
 consists of composing outside the foreign monad 
\begin_inset Formula $M$
\end_inset

 (i.e., we replace 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $M^{A}$
\end_inset

 in the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

).
 Only one implementation fits the type signatures:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class SelT[M[_]: Monad : Functor, Z, A](run: (M[A] => Z) => M[A])
 {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): SelT[M,Z,B] = SelT { (mbz: M[B] => Z) => run(ma
 => mbz(ma.map(f))).map(f) }
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => Sel[M, Z, B]): Sel[M, Z, B] = SelT { (mbz: M[B]
 => Z) =>
\end_layout

\begin_layout Plain Layout

    val amb: A => M[B] = a => f(a).run(mbz)
\end_layout

\begin_layout Plain Layout

    val maz: M[A] => Z = ma => mbz(ma.flatMap(amb))
\end_layout

\begin_layout Plain Layout

    run(maz).flatMap(amb)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def pure[M[_]: Monad, Z, A](a: A): SelT[M, Z, A] = SelT(_ => Monad[M].pure(a))
\end_layout

\end_inset

Since 
\begin_inset Formula $T_{\text{Sel}}^{M}=\text{Sel}\circ M$
\end_inset

 is a functor composition, the lifts and the runners work as in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flift[A](m: M[A]): SelT[M, Z, A] = SelT(_ => m)   // Using the `pure`
 method of the Sel monad.
\end_layout

\begin_layout Plain Layout

def blift[A](sel: Sel[Z, A]): SelT[M, Z, A] = SelT { (k: M[A] => Z) =>
\end_layout

\begin_layout Plain Layout

  val az: A => Z = Monad[M].pure andThen k
\end_layout

\begin_layout Plain Layout

  Monad[M].pure(sel(az))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
The 
\family typewriter
EvalT
\family default
 transformer
\end_layout

\begin_layout Standard
The evaluation monad 
\begin_inset Formula $\text{Eval}^{A}\triangleq A+\left(\bbnum 1\rightarrow A\right)$
\end_inset

 described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-eager-lazy-evaluation-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

 represents a choice of eager or lazy evaluation.
 The corresponding transformer is defined by:
\begin_inset Formula 
\[
T_{\text{Eval}}^{M,A}\triangleq M^{A+(\bbnum 1\rightarrow M^{A})}\quad.
\]

\end_inset

Let us implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EvalT
\end_layout

\end_inset

 monad using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 and write the monad methods.
 The code for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

 monad in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-eager-lazy-evaluation-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

 used a helper function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get: Eval[A] => A
\end_layout

\end_inset

.
 We see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

's runner.
 A similar function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

) plays the role of the 
\begin_inset Quotes eld
\end_inset

base runner
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EvalT
\end_layout

\end_inset

: it runs 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

's effect (converting lazy values into eager ones) but keeps 
\begin_inset Formula $M$
\end_inset

's effects intact.
 We use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class EvalT[M[_]: Monad : Functor, A](value: M[Either[A, Unit
 => M[A]]]) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): EvalT[M, B] = EvalT(value.map {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => Left(f(a))
\end_layout

\begin_layout Plain Layout

    case Right(g)   => Right(_ => g(()).map(f))
\end_layout

\begin_layout Plain Layout

  })
\end_layout

\begin_layout Plain Layout

  def flatMap[B](f: A => EvalT[M, B]): EvalT[M, B] = EvalT(value.flatMap
 {
\end_layout

\begin_layout Plain Layout

    case Left(a)   => f(a).value
\end_layout

\begin_layout Plain Layout

    case Right(g)  => Monad[M].pure(Right { _ => g(()).flatMap(a => EvalT.brun(f(a).
value)) })
\end_layout

\begin_layout Plain Layout

  })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

object EvalT {
\end_layout

\begin_layout Plain Layout

  def pure[M[_]: Monad, A](a: A): EvalT[M, A] = EvalT(Monad[M].pure(Left(a)))
\end_layout

\begin_layout Plain Layout

  def brun[M[_]: Monad, A]: EvalT[M, A] => M[A] = _.value.flatMap { // Either[A,
 Unit=>M[A]] => M[A]
\end_layout

\begin_layout Plain Layout

    case Left(a)   => Monad[M].pure(a)
\end_layout

\begin_layout Plain Layout

    case Right(g)  => g(())
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The lifts are implemented straightforwardly:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flift[A](m: M[A]): EvalT[M, A] = EvalT(m.map(a => Left(a))) // `Left(a)`
 means `Eval.pure(a)`.
\end_layout

\begin_layout Plain Layout

def blift[A](e: Either[A, Unit => A]): EvalT[M, A] = EvalT(Monad[M].pure(e
 match {
\end_layout

\begin_layout Plain Layout

  case Left(a)   => Left(a)
\end_layout

\begin_layout Plain Layout

  case Right(g)  => Right { _ => Monad[M].pure(g(())) } 
\end_layout

\begin_layout Plain Layout

}))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a runner for 
\begin_inset Formula $M$
\end_inset

, we can run 
\begin_inset Formula $M$
\end_inset

's effects while keeping 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

's effects intact:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def runEvalT[A](runner: M[A] => A)(t: EvalT[M, A]): Eval[A] = runner(t)
 match {
\end_layout

\begin_layout Plain Layout

  case Left(a)    => Eager(a)                     // An eager value is ready.
\end_layout

\begin_layout Plain Layout

  case Right(g)   => Lazy(_ => runner(g(())))     // A lazy value remains
 lazy.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Combining more than two monads: monad stacks
\begin_inset CommandInset label
LatexCommand label
name "subsec:Combining-more-than-monad-stacks"

\end_inset


\end_layout

\begin_layout Standard
How can we combine 
\emph on
three or more
\emph default
 monads in a single functor block? For example, we may want somehow to make
 the following code work:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {   // Could this code compile?
\end_layout

\begin_layout Plain Layout

  i <- List(1, 2, 3).up
\end_layout

\begin_layout Plain Layout

  j <- Writer(...).up
\end_layout

\begin_layout Plain Layout

  x <- Try(i + j + 100).up
\end_layout

\begin_layout Plain Layout

  y <- Future(x / 2).up
\end_layout

\begin_layout Plain Layout

  z <- Reader(...).up
\end_layout

\begin_layout Plain Layout

} yield z
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A monad transformer combines a base monad 
\begin_inset Formula $L$
\end_inset

 with any given foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The result is a new, 
\begin_inset Quotes eld
\end_inset

larger
\begin_inset Quotes erd
\end_inset

 monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 that can describe the effects of both 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 To combine the monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 with a third monad (say, 
\begin_inset Formula $K$
\end_inset

), we could use 
\begin_inset Formula $K$
\end_inset

's transformer and obtain the monad 
\begin_inset Formula $T_{K}^{T_{L}^{M}}$
\end_inset

 that describes the effects of 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

.
 This technique is known as making a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!stack of
\end_layout

\end_inset


\series bold
stack
\series default
 of monads.
\end_layout

\begin_layout Standard
As an example, let us build a stack of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monads.
 We set 
\begin_inset Formula $K^{\bullet}=\text{Reader}^{R,\bullet}$
\end_inset

, 
\begin_inset Formula $L^{\bullet}=\text{Writer}^{W,\bullet}$
\end_inset

, and 
\begin_inset Formula $M^{\bullet}=\text{State}^{S,\bullet}$
\end_inset

, and begin with 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

's transformer composes inside the foreign monad, we write 
\begin_inset Formula $T_{\text{Writer}}^{\text{State},A}=S\rightarrow A\times W\times S$
\end_inset

.
 Now we apply the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

's transformer, which composes outside the foreign monad:
\begin_inset Formula 
\[
T_{\text{Reader}}^{T_{\text{Writer}}^{\text{State},A}}=R\rightarrow S\rightarrow A\times W\times S\quad.
\]

\end_inset

This monad has an injected dependency of type 
\begin_inset Formula $R$
\end_inset

, an internally maintained state of type 
\begin_inset Formula $S$
\end_inset

, and an output value of type 
\begin_inset Formula $W$
\end_inset

.
 A value of type 
\begin_inset Formula $R\rightarrow S\rightarrow A\times W\times S$
\end_inset

 describes all three effects at once.
\end_layout

\begin_layout Standard
If the transformers 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

WriterT
\end_layout

\end_inset

 are already implemented, we may write the Scala type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type RWS[R, W, S, A] = ReaderT[WriterT[State[S, *], W, *], R, A] // Equivalent
 to R => S => (A, W, S)
\end_layout

\end_inset

A nested transformer is substituted into the 
\emph on
first
\emph default
 argument of the outer transformer, which has the type constructor kind.
 We use the 
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Index idx
status open

\begin_layout Plain Layout
kind@
\begin_inset Quotes eld
\end_inset

kind projector
\begin_inset Quotes erd
\end_inset

 plugin
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 plugin for type constructors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, *]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Note that the transformer composition does not necessarily represent functor
 composition.
 For instance, the plain functor composition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader[R, Writer[W, State[S, A]]]
\end_layout

\end_inset

 is not a monad.
\end_layout

\begin_layout Standard
We could stack the monads 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

 in a different order, e.g., 
\begin_inset Formula $T_{L}^{T_{M}^{K}}$
\end_inset

 or 
\begin_inset Formula $T_{M}^{T_{K}^{L}}$
\end_inset

.
 In general, different orders will produce inequivalent monads, although
 in certain cases the stacking order does not matter.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Examples-of-monad-stacks"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the following examples illustrate stacking monads in different orders.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Monad 
\begin_inset Formula $L^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Monad 
\begin_inset Formula $M^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Monad 
\begin_inset Formula $T_{M}^{L}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Same?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader[R, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[E, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}=R\rightarrow E+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{M}^{L,A}=R\rightarrow E+A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader[R, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer[W, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}=R\rightarrow A\times W$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{M}^{L,A}=R\rightarrow A\times W$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader[R, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}=R\rightarrow\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{M}^{L,A}\triangleq R\rightarrow\bbnum 1+A\times T_{M}^{L,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader[R, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}=R\rightarrow S\rightarrow A\times S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{M}^{L,A}=S\rightarrow R\rightarrow A\times S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[E, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}=S\rightarrow(E+A)\times S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{M}^{L,A}=S\rightarrow E+A\times S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[E, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont[R, A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{L}^{M,A}=\left(E+A\rightarrow R\right)\rightarrow R$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $T_{M}^{L,A}=\left(A\rightarrow E+R\right)\rightarrow E+R$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Examples-of-monad-stacks"

\end_inset

Examples of monads stacked in different orders.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-reader-state-transformed"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-reader-state-transformed"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $T_{\text{State}}^{\text{Reader}}$
\end_inset

 is equivalent to that of 
\begin_inset Formula $T_{\text{Reader}}^{\text{State}}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The types of the transformers are equivalent: the only difference is the
 flipped order of curried arguments.
 We will verify that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 in these transformers also differ only by the order of curried arguments.
 Begin by writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monads:
\begin_inset Formula 
\begin{align*}
 & \text{flm}_{\text{Reader}}(g^{:A\rightarrow R\rightarrow B})=p^{:R\rightarrow A}\rightarrow r^{:R}\rightarrow(p(r)\triangleright g)(r)\quad,\\
 & \text{flm}_{\text{State}}(g^{:A\rightarrow\text{State}^{S,B}})=p^{:S\rightarrow A\times S}\rightarrow s_{1}^{:S}\rightarrow p(s_{1})\triangleright(a\times s_{2}\rightarrow g(a)(s_{2}))\quad.
\end{align*}

\end_inset

Now we write the code for 
\begin_inset Formula $T_{\text{Reader}}^{\text{State}}$
\end_inset

's methods:
\begin_inset Formula 
\begin{align*}
 & T_{\text{Reader}}^{\text{State},A}\triangleq T_{1}^{A}=R\rightarrow S\rightarrow A\times S\quad,\\
 & \text{pu}_{T_{1}}=a^{:A}\rightarrow\_^{:R}\rightarrow\text{pu}_{\text{State}}(a)=a^{:A}\rightarrow\_^{:R}\rightarrow s^{:S}\rightarrow a\times s\quad,\\
 & \text{flm}_{T_{1}}(f^{:A\rightarrow T_{1}^{B}})=t^{:T_{1}^{A}}\rightarrow r^{:R}\rightarrow t(r)\triangleright\text{flm}_{\text{State}}(a^{:A}\rightarrow f(a)(r))\\
 & \quad=t\rightarrow r\rightarrow t(r)\triangleright\big(p^{:\text{State}^{S,A}}\rightarrow s_{1}^{:S}\rightarrow p(s_{1})\triangleright(a\times s_{2}\rightarrow f(a)(r)(s_{2}))\big)\\
 & \quad=t\rightarrow r\rightarrow s_{1}\rightarrow t(r)(s_{1})\triangleright(a\times s_{2}\rightarrow f(a)(r)(s_{2}))\quad.
\end{align*}

\end_inset

The code for 
\begin_inset Formula $T_{\text{State}}^{\text{Reader}}$
\end_inset

 is found by using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:flatmap-for-stateT-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & T_{\text{State}}^{\text{Reader},A}\triangleq T_{2}^{A}=S\rightarrow R\rightarrow A\times S\quad,\\
 & \text{pu}_{T_{2}}=a^{:A}\rightarrow s^{:S}\rightarrow\text{pu}_{\text{Reader}}(a\times s)=a^{:A}\rightarrow s^{:S}\rightarrow\_^{:R}\rightarrow a\times s\quad,\\
 & \text{flm}_{T_{2}}(f^{:A\rightarrow T_{2}^{B}})=t^{:T^{A}}\rightarrow s_{1}^{:S}\rightarrow t(s_{1})\triangleright\text{flm}_{\text{Reader}}(a\times s_{2}\rightarrow f(a)(s_{2}))\\
 & \quad=t\rightarrow s_{1}\rightarrow t(s_{1})\triangleright\big(p\rightarrow r\rightarrow(p(r)\triangleright(a\times s_{2}\rightarrow f(a)(s_{2})))(r)\big)\\
 & \quad=t\rightarrow s_{1}\rightarrow r\rightarrow(t(s_{1})(r)\triangleright(a\times s_{2}\rightarrow f(a)(s_{2})))(r)\quad.
\end{align*}

\end_inset

We see that the codes indeed differ only by flipping the curried arguments
 
\begin_inset Formula $r^{:R}$
\end_inset

 and 
\begin_inset Formula $s_{1}^{:S}$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-reader-list-transformed"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-reader-list-transformed"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the monads 
\begin_inset Formula $T_{\text{Reader}}^{\text{List}}$
\end_inset

 and 
\begin_inset Formula $T_{\text{List}}^{\text{Reader}}$
\end_inset

 are not equivalent.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The difference becomes clear once we write out the types:
\begin_inset Formula 
\[
T_{\text{Reader}}^{\text{List},A}\triangleq R\rightarrow\text{List}^{A}\quad,\quad\quad T_{\text{List}}^{\text{Reader},A}\triangleq R\rightarrow\bbnum 1+A\times T_{\text{List}}^{\text{Reader},A}\quad.
\]

\end_inset

In a value of type 
\begin_inset Formula $T_{\text{Reader}}^{\text{List}}$
\end_inset

, the injected dependency (of type 
\begin_inset Formula $R$
\end_inset

) is used to produce an 
\begin_inset Quotes eld
\end_inset

eager
\begin_inset Quotes erd
\end_inset

 list.
 The length of the resulting list, as well as all its elements, are computed
 at once from the injected value of type 
\begin_inset Formula $R$
\end_inset

.
 In contrast, a data structure of type 
\begin_inset Formula $T_{\text{List}}^{\text{Reader}}$
\end_inset

 represents a 
\begin_inset Quotes eld
\end_inset

lazy
\begin_inset Quotes erd
\end_inset

 (on-call) sequence: getting the value of each next element requires calling
 a function of type 
\begin_inset Formula $R\rightarrow\bbnum 1+A\times T_{\text{List}}^{\text{Reader}}$
\end_inset

 (possibly, a different function each time).
 The resulting on-call sequence may be unlimited in length.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The next example shows that effects of the two monads are not always independent
 within the larger transformed monad.
 An effect of one monad will sometimes 
\begin_inset Quotes eld
\end_inset

cancel
\begin_inset Quotes erd
\end_inset

 an effect of the other.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-either-state-transformed-cancels-effect"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-either-state-transformed-cancels-effect"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the monads 
\begin_inset Formula $T_{\text{State}}^{\text{Either}}$
\end_inset

 and 
\begin_inset Formula $T_{\text{Either}}^{\text{State}}$
\end_inset

 are not equivalent.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The effect of 
\begin_inset Formula $\text{State}^{S,A}=S\rightarrow A\times S$
\end_inset

 is to produce an updated internal state (of type 
\begin_inset Formula $S$
\end_inset

) together with a result value of type 
\begin_inset Formula $A$
\end_inset

.
 Write the types of the transformed monads:
\begin_inset Formula 
\[
T_{\text{State}}^{\text{Either},A}=S\rightarrow E+A\times S\quad,\quad\quad T_{\text{Either}}^{\text{State},A}=S\rightarrow\left(E+A\right)\times S\quad.
\]

\end_inset

A computation of type 
\begin_inset Formula $T_{\text{State}}^{\text{Either},A}$
\end_inset

 may fail with an error (of type 
\begin_inset Formula $E$
\end_inset

) and produce 
\emph on
no
\emph default
 new state.
 So, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad is able to 
\begin_inset Quotes eld
\end_inset

cancel
\begin_inset Quotes erd
\end_inset

 the state-updating effect of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 But a computation of type 
\begin_inset Formula $T_{\text{Either}}^{\text{State},A}$
\end_inset

 never fails to update the state (although it could fail to give a result
 of type 
\begin_inset Formula $A$
\end_inset

).
 Because of this difference, the two transformed monads cannot be equivalent.
 To show this more rigorously, set all type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type and observe that the types 
\begin_inset Formula $S\rightarrow E+A\times S$
\end_inset

 and 
\begin_inset Formula $S\rightarrow\left(E+A\right)\times S$
\end_inset

 have a different number of distinct values: 
\begin_inset Formula $\left|\bbnum 2\rightarrow\bbnum 2+\bbnum 2\times\bbnum 2\right|=36$
\end_inset

 but 
\begin_inset Formula $\left|\bbnum 2\rightarrow\left(\bbnum 2+\bbnum 2\right)\times\bbnum 2\right|=64$
\end_inset

.
\end_layout

\begin_layout Paragraph
Transformers for stacks
\end_layout

\begin_layout Standard
The stack 
\begin_inset Formula $T_{K}^{T_{L}^{M}}$
\end_inset

 is a monad whose code is parametric in 
\begin_inset Formula $M$
\end_inset

.
 So, we can decide to use it as the monad transformer 
\emph on
for the monad
\emph default
 
\begin_inset Formula $T_{K}^{L}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
T_{T_{K}^{L}}^{M}\triangleq T_{K}^{T_{L}^{M}}\quad.\label{eq:monad-transformers-associativity-of-combination}
\end{equation}

\end_inset


\begin_inset VSpace -120baselineskip%
\end_inset


\end_layout

\begin_layout Standard
To combine 
\begin_inset Formula $T_{K}^{T_{L}^{M}}$
\end_inset

 with a new monad 
\begin_inset Formula $N$
\end_inset

, we write the stack 
\begin_inset Formula $T_{K}^{T_{L}^{T_{M}^{N}}}$
\end_inset

 (where 
\begin_inset Formula $T_{M}$
\end_inset

 is 
\begin_inset Formula $M$
\end_inset

's transformer).
 With this technique, we may combine any number of monads in a monad stack,
 as long as the transformers for all monads are known (except for the last
 one).
\end_layout

\begin_layout Standard
Monad stacking can be viewed as a binary operation (which we denote by 
\begin_inset Formula $\varangle$
\end_inset

) that combines monads 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 into a new monad 
\begin_inset Formula $K\varangle L\triangleq T_{K}^{L}$
\end_inset

.
 This operation is associative 
\emph on
by definition
\emph default
: the transformer for the monad 
\begin_inset Formula $T_{K}^{L}$
\end_inset

 is defined via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monad-transformers-associativity-of-combination"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which we can rewrite as:
\begin_inset Formula 
\[
\left(K\varangle L\right)\varangle M\triangleq K\varangle\left(L\varangle M\right)\quad.
\]

\end_inset

 A monad stack is then denoted unambiguously by, e.g., 
\begin_inset Formula $K\varangle L\varangle M\varangle N$
\end_inset

, without need for parentheses.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-monad-stack"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-monad-stack"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Define type constructors for these monad stacks and for their transformers:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, *]
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 To define the type constructor for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, *]
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

, set 
\begin_inset Formula $M=\text{Eval}$
\end_inset

 in the formula for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's transformer:
\begin_inset Formula 
\[
T_{\text{State}}^{M,A}=S\rightarrow M^{A\times S}=S\rightarrow\text{Eval}^{A\times S}\quad.
\]

\end_inset

Now translate the type notation into code, assuming that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 is defined previously:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type StateEval[A] = S => Either[(A, S), Unit => (A, S)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The transformer for this monad is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, *]
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset


\begin_inset Formula $\varangle M$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is an arbitrary foreign monad.
 By definition, 
\begin_inset Formula 
\[
\text{State}^{S,\bullet}\varangle\text{Eval}^{\bullet}\varangle M^{\bullet}\triangleq\text{State}^{S,\bullet}\varangle\big(\text{Eval}^{\bullet}\varangle M^{\bullet}\big)\quad,
\]

\end_inset

so we need to start with the monad stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset


\begin_inset Formula $\varangle M$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type EvalM[A] = M[Either[A, Unit => M[A]]
\end_layout

\end_inset

Now we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

's transformer to the foreign monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EvalM
\end_layout

\end_inset

 and find:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type StateEvalT[M[_], A] = S => M[Either[(A, S), Unit => M[(A, S)]]
\end_layout

\end_inset

This type constructor is the monad transformer of the monad 
\begin_inset Formula $\text{State}^{S}\varangle\text{Eval}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 is defined as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's transformer applied to the stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.
 So, we first define the type constructor for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, which is a functor composition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type OptionTry[A] = Try[Option[A]]
\end_layout

\end_inset

We now apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 to the monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OptionTry
\end_layout

\end_inset

, which gives a recursive type definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ListOptionTry[A](value: Try[Option[Option[(A, ListOptionTry[A])
]]])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To define the transformer for the monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListOptionTry
\end_layout

\end_inset

, we need to start with the innermost nested monad (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

) and apply its transformer (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TryT
\end_layout

\end_inset

) to the foreign monad 
\begin_inset Formula $M$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type TryM[A] = M[Try[A]]   // TryT[M, A] is defined as M[Try[A]].
\end_layout

\end_inset

The next step is to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

's transformer to the foreign monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TryM
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type OptionTryM[A] = M[Try[Option[A]]  // OptionT[TryM, A] is defined as
 TryM[Option[A]].
\end_layout

\end_inset

Finally, we apply the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

 transformer to the last monad:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class ListOptionTryT[M[_], A](value: M[Try[Option[Option[(A,
 ListOptionTryT[M, A])]]]])
\end_layout

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Does the stacking operation (
\begin_inset Formula $\varangle$
\end_inset

) have a unit? We notice from Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Known-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that each transformer 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 somehow mixes the foreign monad 
\begin_inset Formula $M$
\end_inset

 with the type of the base monad 
\begin_inset Formula $L$
\end_inset

.
 In every example, if we set 
\begin_inset Formula $M$
\end_inset

 to the identity monad 
\begin_inset Formula $\text{Id}$
\end_inset

 (defined by 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

), the transformed type will become equivalent to the base monad 
\begin_inset Formula $L$
\end_inset

.
 So, we may expect this property to hold for every transformer:
\begin_inset Formula 
\[
T_{L}^{\text{Id}}\cong L\quad,\quad\text{equivalently written as:}\quad\quad L\varangle\text{Id}\cong L\quad.
\]

\end_inset

Intuitively, the identity monad has a 
\begin_inset Quotes eld
\end_inset

trivial effect
\begin_inset Quotes erd
\end_inset

.
 Combining a trivial effect with another monad should not change that monad's
 effects.
 So, it is also natural to 
\emph on
define
\emph default
 the monad transformer for the identity monad as equal to the foreign monad:
\begin_inset Formula 
\[
T_{\text{Id}}^{M}\triangleq M\quad,\quad\text{equivalently written as:}\quad\quad\text{Id}\varangle M\triangleq M\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Due to these properties of the identity monad, the base monad 
\begin_inset Formula $L$
\end_inset

 can be recovered as 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 if we know the code for the transformer 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 So, if we already have an implementation for a monad 
\begin_inset Formula $L$
\end_inset

's transformer 
\begin_inset Formula $T_{L}$
\end_inset

, we do not need to define the monad 
\begin_inset Formula $L$
\end_inset

's type and methods separately.
 This saves time when implementing monad code in libraries (but may decrease
 performance).
\end_layout

\begin_layout Standard
With these definitions, we find that the monad stacking operation (
\begin_inset Formula $\varangle$
\end_inset

) resembles the binary operation of a monoid: it is associative and has
 a unit (the monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Id
\end_layout

\end_inset

).
 However, the monad 
\begin_inset Formula $L\varangle M$
\end_inset

 is defined only if the monad 
\begin_inset Formula $L$
\end_inset

 has a transformer.
 It is unknown
\begin_inset Foot
status open

\begin_layout Plain Layout
For a discussion, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/24515876/"
literal "false"

\end_inset


\end_layout

\end_inset

 whether a transformer exists for every monad relevant to functional programming.
 The question is open (Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) even if restricted to monads whose methods are implemented by fully parametric
 code.
\end_layout

\begin_layout Standard
Transformers certainly cannot exist for monads defined using code that executes
 side effects.
 Examples of that kind are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 monad and other 
\begin_inset Quotes eld
\end_inset

task-like
\begin_inset Quotes erd
\end_inset

 monads that create new threads.
 Transformers also cannot exist for external side-effect monads, such as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IO
\end_layout

\end_inset

 from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cats-effect
\end_layout

\end_inset

 library or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ZIO
\end_layout

\end_inset

 from the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zio
\end_layout

\end_inset

 library.
 The reason is that a transformer must allow a foreign monad to cancel the
 effects of the base monad, as we have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-either-state-transformed-cancels-effect"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 But side effects often cannot be undone once they are run, because changes
 in the external world may be irreversible.
\begin_inset Foot
status open

\begin_layout Plain Layout
For a discussion, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/11792275/"
literal "false"

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Throughout this chapter, we will build transformers for every exponential-polyno
mial monad considered in this book (although some transformers will only
 partially satisfy the required laws).
\end_layout

\begin_layout Subsection
A typeclass for monad transformers
\end_layout

\begin_layout Standard
Transformers such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherT
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 are type constructors that depend on an arbitrary foreign monad 
\begin_inset Formula $M$
\end_inset

 and have the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 with known type signatures.
 We may specify these properties via a typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MTrans[T]
\end_layout

\end_inset

 that describes what is required for 
\begin_inset Formula $T$
\end_inset

 to be a monad transformer.
 A simple definition of the monad transformer typeclass can look like this:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

type Id[A] = A        // The identity monad$
\backslash
color{dkgreen}
\backslash
texttt{'}$s typeclass instance must be defined elsewhere.
\end_layout

\begin_layout Plain Layout

trait MTrans[T[_[_]]] {    // The type parameter T is a type constructor
 with 2 parameters.
\end_layout

\begin_layout Plain Layout

  def monadT[M[_]: Monad]: Monad[T[M, *]]       // A monad instance must
 exist for T[M, *].
\end_layout

\begin_layout Plain Layout

  def flift[M[_]: Monad, A]: M[A] => T[M, A]
\end_layout

\begin_layout Plain Layout

  def blift[M[_]: Monad, A]: T[Id, A] => T[M, A] = frun[Id, M, A](Monad[M].pure)
\end_layout

\begin_layout Plain Layout

  def frun[M[_]: Monad, N[_]: Monad, A](phi: M[A] => N[A]): T[M, A] => T[N,
 A]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The transformer's code is parametric in the foreign monad 
\begin_inset Formula $M$
\end_inset

 (but not in the base monad 
\begin_inset Formula $L$
\end_inset

).
 Although 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 can be implemented via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 as 
\begin_inset Formula $\text{blift}_{L}^{M}\triangleq\text{frun}_{L}^{\text{Id},M}(\text{pu}_{M})$
\end_inset

, it is convenient to keep all three methods defined separately in the typeclass.
\end_layout

\begin_layout Standard
Here is a schematic example of defining an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MTrans
\end_layout

\end_inset

 typeclass instance for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Reader[A](run: R => A)     // The fixed type R must be
 already defined.
\end_layout

\begin_layout Plain Layout

final case class ReaderT[M[_], A](run: Reader[M[A]])
\end_layout

\begin_layout Plain Layout

implicit val mTransReaderT = new MTrans[ReaderT] {
\end_layout

\begin_layout Plain Layout

  def monadT[M[_] : Monad]: Monad[ReaderT[M, *]] = ...
\end_layout

\begin_layout Plain Layout

  def flift[M[_] : Monad, A]: M[A] => ReaderT[M, A] = { ma => ReaderT(Reader(_
 => ma)) }
\end_layout

\begin_layout Plain Layout

  def frun[M[_] : Monad, N[_] : Monad, A](phi: M[A] => N[A]): ReaderT[M,
 A] => ReaderT[N, A] =
\end_layout

\begin_layout Plain Layout

    t => ReaderT(Reader(r => phi(t.run.run(r))))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lifts and runners for monad stacks
\end_layout

\begin_layout Standard
Working with a monad stack, such as 
\begin_inset Formula $K\varangle L\varangle M\varangle N$
\end_inset

, requires using the effects of all the monads 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

.
 The code should appear to be able to compose any combination of Kleisli
 functions, e.g.:
\begin_inset Formula 
\[
p^{:A\rightarrow(K\varangle L\varangle M\varangle N)^{F}}\triangleq f_{1}^{:A\rightarrow L^{B}}\diamond f_{2}^{:B\rightarrow N^{C}}\diamond f_{3}^{:C\rightarrow(L\varangle M)^{D}}\diamond f_{4}^{:D\rightarrow(K\varangle L)^{E}}\diamond f_{5}^{:E\rightarrow K^{F}}\quad,
\]

\end_inset

where the 
\begin_inset Quotes eld
\end_inset

universal
\begin_inset Quotes erd
\end_inset

 composition operation 
\begin_inset Formula $\diamond$
\end_inset

 should somehow apply to Kleisli functions involving any of the given monads
 or sub-stacks.
 We also expect to be able to run the effects of any one of the monads while
 keeping the effects of others.
 To achieve all that, we need to define the lifts and the runners for the
 monad stack.
\end_layout

\begin_layout Paragraph
Lifts
\end_layout

\begin_layout Standard
Any monad contained in a stack, such as 
\begin_inset Formula $K^{A}$
\end_inset

, 
\begin_inset Formula $L^{A}$
\end_inset

, 
\begin_inset Formula $M^{A}$
\end_inset

, 
\begin_inset Formula $N^{A}$
\end_inset

, 
\begin_inset Formula $(K\varangle L)^{A}$
\end_inset

, 
\begin_inset Formula $(L\varangle M)^{A}$
\end_inset

, etc., can be lifted to the stack type 
\begin_inset Formula $(K\varangle L\varangle M\varangle N)^{A}$
\end_inset

 by some combination of lifts.
 Assume that we have the base lifts, foreign lifts, and the runners of the
 relevant transformers, such as:
\begin_inset Formula 
\[
\text{flift}_{K}^{P}:P\leadsto(K\varangle P)\quad,\quad\text{blift}_{L}^{P}:L\leadsto(L\varangle P)\quad,\quad\text{frun}_{M}^{P,Q}(f^{:P\leadsto Q}):M\varangle P\leadsto M\varangle Q\quad,\quad\text{etc.,}
\]

\end_inset

for any monad 
\begin_inset Formula $P$
\end_inset

.
 Keep in mind that the transformer for 
\begin_inset Formula $K\varangle L$
\end_inset

 is defined by stacking the transformers for 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
 As an example, let us compute the lifts 
\begin_inset Formula $P\leadsto K\varangle L\varangle P$
\end_inset

 and 
\begin_inset Formula $L\varangle M\leadsto L\varangle M\varangle P$
\end_inset

: 
\begin_inset Formula 
\[
\text{flift}_{K\varangle L}^{P}:P\leadsto K\varangle L\varangle P=\text{flift}_{L}^{P}\bef\text{flift}_{K}^{L\varangle P}\quad,\quad\text{blift}_{L\varangle M}^{P}:L\varangle M\leadsto L\varangle M\varangle P=\text{frun}_{L}^{M,M\varangle P}(\text{blift}_{M}^{P})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Lifting a monad value from a given monad from the middle of the stack into
 the full monad stack can require composing several lifts.
 For example, consider the task of lifting a value of type 
\begin_inset Formula $M^{A}$
\end_inset

 to the stack 
\begin_inset Formula $(K\varangle L\varangle M\varangle N)^{A}$
\end_inset

.
 We may first lift 
\begin_inset Formula $M^{A}$
\end_inset

 to 
\begin_inset Formula $(M\varangle N)^{A}$
\end_inset

 using 
\begin_inset Formula $\text{blift}_{M}^{N}$
\end_inset

, then lift the result to 
\begin_inset Formula $(L\varangle M\varangle N)^{A}$
\end_inset

 using 
\begin_inset Formula $\text{flift}_{L}^{M\varangle N}$
\end_inset

, and finally lift the last result to 
\begin_inset Formula $(K\varangle L\varangle M\varangle N)^{A}$
\end_inset

 via 
\begin_inset Formula $\text{flift}_{K}^{L\varangle M\varangle N}$
\end_inset

.
 So, we obtain the following function composition:
\begin_inset Formula 
\[
\big(\text{blift}_{M}^{N}\bef\text{flift}_{L}^{M\varangle N}\bef\text{flift}_{K}^{L\varangle M\varangle N}\big):M^{A}\rightarrow(K\varangle L\varangle M\varangle N)^{A}\quad.
\]

\end_inset

Equivalently, we may first lift 
\begin_inset Formula $M^{A}$
\end_inset

 to 
\begin_inset Formula $(L\varangle M)^{A}$
\end_inset

 via 
\begin_inset Formula $\text{flift}_{L}^{M}$
\end_inset

, then lift to 
\begin_inset Formula $(K\varangle L\varangle M)^{A}$
\end_inset

 via 
\begin_inset Formula $\text{flift}_{K}^{L\varangle M}$
\end_inset

, and finally use 
\begin_inset Formula $\text{blift}_{K\varangle L\varangle M}^{N}$
\end_inset

, which is defined as:
\begin_inset Formula 
\[
\text{blift}_{K\varangle L\varangle M}^{N}:K\varangle L\varangle M\leadsto K\varangle L\varangle M\varangle N\triangleq\text{frun}_{K}^{L\varangle M,L\varangle M\varangle N}(\text{frun}_{L}^{M,M\varangle N}(\text{blift}_{M}^{N}))\quad.
\]

\end_inset

With these techniques, we can construct all required liftings in any monad
 stack, as long as every monad transformer in the stack has the methods
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Transformers for certain monads (e.g., the continuation and the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!codensity monad
\end_layout

\end_inset

codensity monads) have neither the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 nor the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 methods.
 Also, task-like monads (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

) and the external side-effect monads (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IO
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ZIO
\end_layout

\end_inset

) have no transformers at all.
 Values of those monads can be lifted to a monad stack only when the problematic
 monad is located at the deep end of the stack, so that its transformer
 is not needed.
 For example, the monad 
\begin_inset Formula $N$
\end_inset

 at the end of the stack 
\begin_inset Formula $K\varangle L\varangle M\varangle N$
\end_inset

 can be lifted to the stack without need for 
\begin_inset Formula $N$
\end_inset

's transformer:
\begin_inset Formula 
\[
\text{flift}_{K\varangle L\varangle M}^{N}:N^{A}\rightarrow(K\varangle L\varangle M\varangle N)^{A}\triangleq\text{flift}_{M}^{N}\bef\text{flift}_{L}^{M\varangle N}\bef\text{flift}_{K}^{L\varangle M\varangle N}\quad.
\]

\end_inset

For this reason, the external side-effect monads and the task-like monads
 are usually placed at the deep end of the stack.
 This workaround limits the use of those monads in stacks; for instance,
 a stack cannot contain both an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IO
\end_layout

\end_inset

 and a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 monad.
 To provide adequate functionality for applications, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IO
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ZIO
\end_layout

\end_inset

 monads include special methods for running concurrent computations on multiple
 threads, which makes it unnecessary to add a task-like monad to the same
 monad stack.
\end_layout

\begin_layout Standard
While we solved the lifting problem in principle for most monad stacks,
 it is impractical for the programmer to have to write manually a composition
 of several lifts for every source line in a functor block.
 Even if we implement all the lift functions as extension methods and abbreviate
 the type annotations as much as possible, the code would have to be written
 similarly to this:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

for {    // Using a stack $
\backslash
color{dkgreen} K
\backslash
varangle L
\backslash
varangle M
\backslash
varangle N$.
\end_layout

\begin_layout Plain Layout

  x <- valueM.blift[N].flift[L].flift[K]
\end_layout

\begin_layout Plain Layout

  y <- valueK.blift[TL[TM[N]]]
\end_layout

\begin_layout Plain Layout

  z <- valueL.blift[TM[N]].flift[K]
\end_layout

\begin_layout Plain Layout

} yield ...
\end_layout

\end_inset

If a monad stack 
\begin_inset Formula $K\varangle L\varangle M\varangle N$
\end_inset

 needs to be changed to 
\begin_inset Formula $M\varangle L\varangle N\varangle K\varangle P$
\end_inset

 because of new program requirements, all source lines in all functor blocks
 will have to be modified to accommodate the required changes in the lifts.
 Productive practical use of deep monad stacks needs better techniques.
 One such technique, the 
\begin_inset Quotes eld
\end_inset

lift relation
\begin_inset Quotes erd
\end_inset

, is described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Constructing-lifts-via-type-relations"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Another technique is an 
\begin_inset Quotes eld
\end_inset

MTL-style
\begin_inset Quotes erd
\end_inset

 monad stack (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Combining-monads-via-mtl-style"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Both techniques are based on creating special typeclasses that produce
 the required lifts automatically.
\end_layout

\begin_layout Paragraph
Runners
\end_layout

\begin_layout Standard
Having computed a value of type, say, 
\begin_inset Formula $(K\varangle L\varangle M\varangle N)^{A}$
\end_inset

, we may want to run the effects of a chosen monad (say 
\begin_inset Formula $M$
\end_inset

) using a known runner 
\begin_inset Formula $\theta_{M}:M^{A}\rightarrow A$
\end_inset

 but keep the effects of other monads in the stack.
 If all the monad transformers in the stack support the foreign and base
 runners, we can run the effects of any chosen monad, e.g., like this:
\begin_inset Formula 
\[
\text{frun}_{K}^{L\varangle M\varangle N}(\text{frun}_{L}^{M\varangle N}(\text{brun}_{M}^{N}(\theta_{M}))):K\varangle L\varangle M\varangle N\leadsto K\varangle L\varangle N\quad.
\]

\end_inset

As in the case of lifts, the implementations of the runners depend on the
 order of monads in the stack and will have to be changed if the stack changes.
 It does not seem possible to define a 
\begin_inset Quotes eld
\end_inset

stack runner
\begin_inset Quotes erd
\end_inset

 parametric in the chosen monad, allowing the programmer simply to indicate
 which monad's effects need to be run.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For instance, given the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

resultStack3
\end_layout

\end_inset

 computed by the code shown above, we would like to write simply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

resultStack3.run[Reader](...)
\end_layout

\end_inset

 and obtain a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherT[Option, Int]
\end_layout

\end_inset

.
\end_layout

\end_inset

 To see why, consider a monad stack of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherT[E, ReaderT[R, Option, *], A]
\end_layout

\end_inset

.
 If we wish to run the effects of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad alone, the result type must be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherT[E, Option, A]
\end_layout

\end_inset

.
 But there is no simple way of obtaining that result type from the type
 of the stack: the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherT[E, Option, A]
\end_layout

\end_inset

 cannot be expressed as a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q[Reader, ...]
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 is just one of the type parameters.
 This is because the type of the stack is not parametric in the type of
 the base monad.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To create the runners automatically, we need to define a single 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run
\end_layout

\end_inset

 method parameterized by the types of the stack and the monad whose effects
 we need to run.
 It is convenient to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run
\end_layout

\end_inset

 as an extension method on a monad stack:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit class RunMethod[S[_]: Monad, A](s: S[A]) { // `S[_]` is a monad
 stack's constructor.
\end_layout

\begin_layout Plain Layout

  def run[M[_]: Monad](r: M ~> Id) = ???  // This should work as resultStack3.run
[Reader](...)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

So far it is not clear what the return type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run
\end_layout

\end_inset

 should be.
 The result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run
\end_layout

\end_inset

 is a value of a monad stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 without the monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M
\end_layout

\end_inset

.
 will depend on :
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def run[S[_]: Monad, M[_]: Monad, A](s: S[A])(t: M[A] => A)
\end_layout

\begin_layout Plain Layout

  (implicit r: Runner[S, M]): Result[S, M, A] = ???
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we will see in this chapter, some monad transformers do not support base
 runners at all.
 Monad stacks containing such transformers are still usable, but their effects
 will have to be run in a specific order, so that the missing base runners
 are not needed.
\end_layout

\begin_layout Subsection
Constructing lifts via type relations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Constructing-lifts-via-type-relations"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!lift@
\begin_inset Quotes eld
\end_inset

lift relation
\begin_inset Quotes erd
\end_inset

 technique
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

lift relation
\begin_inset Quotes erd
\end_inset

 technique creates a type relation
\begin_inset Index idx
status open

\begin_layout Plain Layout
type relation
\end_layout

\end_inset

 that describes all the possible liftings within a given monad stack.
 Two monads 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are 
\series bold
in a lift relation
\series default
 if there exists a monad morphism 
\begin_inset Formula $P\leadsto Q$
\end_inset

.
 If 
\begin_inset Formula $Q$
\end_inset

 is itself a monad stack containing the monad 
\begin_inset Formula $P$
\end_inset

, we can implement the lift relation 
\begin_inset Formula $P\leadsto Q$
\end_inset

 by using the stack 
\begin_inset Formula $Q$
\end_inset

's monad transformers.
 For instance, the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $K\varangle L\varangle M$
\end_inset

 are in a lift relation because we can construct a monad morphism 
\begin_inset Formula $L\leadsto K\varangle L\varangle M$
\end_inset

 as:
\begin_inset Formula 
\[
\big(\text{blift}_{L}^{M}\bef\text{flift}_{K}^{L\varangle M}\big):L\leadsto K\varangle L\varangle M\quad.
\]

\end_inset

At the same time, the monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $K\varangle L$
\end_inset

 will 
\emph on
not
\emph default
 be in a lift relation (for arbitrary monads 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

) since, in general, there will not be any monad morphisms 
\begin_inset Formula $M\leadsto K$
\end_inset

 or 
\begin_inset Formula $M\leadsto L$
\end_inset

, so we will have no way of lifting the effects of the monad 
\begin_inset Formula $M$
\end_inset

 into the monad 
\begin_inset Formula $K\varangle L$
\end_inset

.
\end_layout

\begin_layout Standard
The lift relation is implemented as a type relation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MM[P, Q]
\end_layout

\end_inset

 for the monads' type constructors (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

).
 A value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MM[P, Q]
\end_layout

\end_inset

 will contain the required monad morphism between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait MM[P[_], Q[_]] { def up[A]: P[A] => Q[A] } // This function must be
 a monad morphism.
\end_layout

\end_inset

We define the lift relation recursively.
 Any monad is always in a lift relation with itself:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def liftableId[P[_]]: MM[P, P] = new MM[P, P] { def up[A] = identity
 }
\end_layout

\end_inset

A stack 
\begin_inset Formula $L\varangle M$
\end_inset

 has two lifts, 
\begin_inset Formula $L\leadsto L\varangle M$
\end_inset

 and 
\begin_inset Formula $M\leadsto L\varangle M$
\end_inset

.
 A relation instance for the foreign lift is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def foreignMonadToTransformer[KT[_[_], _], M[_] : Monad]
\end_layout

\begin_layout Plain Layout

  (implicit kt: MTrans[KT]): MM[M, KT[M, *]] = new MM[M, KT[M, *]] {
\end_layout

\begin_layout Plain Layout

    override def apply[A]: M[A] => KT[M, A] = kt.flift[M, A]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It requires more work to define a relation instance for the base lift, because
 the type constructor for the base monad cannot be automatically derived
 from the transformer's type.
 To make the base monad known to the Scala compiler, we define another type
 relation that designates base monads of monad transformers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class BaseMonad[L[_], KT[_[_], _]](iso: MM[L, KT[Id, *]])
\end_layout

\end_inset

It is assumed that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

iso
\end_layout

\end_inset

 should be a monad isomorphism.
 We need a relation instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BaseMonad
\end_layout

\end_inset

 for each supported transformer.
 As an example, the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

 looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val readerBase: BaseMonad[Reader, ReaderT] = BaseMonad(new MM[Reader,
 ReaderT[Id, *]] {
\end_layout

\begin_layout Plain Layout

    def apply[A]: Reader[A] => ReaderT[Id, A] = ReaderT[Id, A](_)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we can implement a relation instance for the base lift of an arbitrary
 monad stack:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def baseMonadToTransformer[KT[_[_], _], M[_] : Monad, L[_] : Monad]
\end_layout

\begin_layout Plain Layout

  (implicit kt: MTrans[KT], isBase: BaseMonad[L, KT]): MM[L, KT[M, *]] =
 new MM[L, KT[M, *]] {
\end_layout

\begin_layout Plain Layout

    override def apply[A]: L[A] => KT[M, A] = isBase.iso.apply andThen kt.blift[M,
 A]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The typeclass constraint 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BaseMonad[L, KT]
\end_layout

\end_inset

 permits the Scala compiler to direct the search for implicits towards finding
 the base monad of a given transformer.
\end_layout

\begin_layout Standard
Finally, given a stack 
\begin_inset Formula $K\varangle M$
\end_inset

 and a monad 
\begin_inset Formula $L$
\end_inset

, we may lift 
\begin_inset Formula $L\leadsto K\varangle M$
\end_inset

 if there is already a lift 
\begin_inset Formula $L\leadsto K$
\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def monadToTransformer[KT[_[_], _], L[_] : Monad, M[_] : Monad]
\end_layout

\begin_layout Plain Layout

  (implicit kt: MTrans[KT], lm: MM[L, M]): MM[L, KT[M, *]] = new MM[L, KT[M,
 *]] {
\end_layout

\begin_layout Plain Layout

    override def apply[A]: L[A] => KT[M, A] = lm.apply andThen kt.flift
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

This relation instance needs to have lower priority than the foreign and
 base liftings: the Scala compiler should look for simpler liftings before
 trying to find a relation instance recursively.
\end_layout

\begin_layout Standard
With appropriate syntax definitions and typeclass instances, we may now
 write code like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Stack3[A] = EitherT[ReaderT[Option, *], A]            // A stack having
 3 monads.
\end_layout

\begin_layout Plain Layout

implicit val mTrEitherT: MTrans[EitherT] = ...
\end_layout

\begin_layout Plain Layout

implicit val baseEither: BaseMonad[Either[E, *], EitherT] = ...
\end_layout

\begin_layout Plain Layout

implicit val mTrReaderT: MTrans[ReaderT] = ...
\end_layout

\begin_layout Plain Layout

implicit val baseReader: BaseMonad[Reader, ReaderT] = ...
\end_layout

\begin_layout Plain Layout

def toEither(x: Int, r: Int): Either[E, Int] = ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val resultStack3: Stack3[Int] = for { // Lift each value to Stack3 with
 a single `up`.
 
\end_layout

\begin_layout Plain Layout

  x <- Option(5).up[Stack3]
\end_layout

\begin_layout Plain Layout

  r <- Reader(identity).up[Stack3]
\end_layout

\begin_layout Plain Layout

  t <- toEither(x, r).up[Stack3]
\end_layout

\begin_layout Plain Layout

} yield t
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To implement the automatic lifts via lift relations, the programmer needs
 to create three implicit values for each monad: a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monad
\end_layout

\end_inset

 typeclass instance, a monad transformer (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MTrans
\end_layout

\end_inset

) typeclass instance, and an instance of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BaseMonad
\end_layout

\end_inset

 type relation.
 Those instances can be defined as implicit values in a monad transformer
 library.
 So, the length of code is linear in the number of supported monad types.
 Then the user may declare an arbitrary monad stack 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MyStack
\end_layout

\end_inset

 and use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

up[MyStack]
\end_layout

\end_inset

 method as an automatic lift from any level within the stack to the top
 of the stack.
\end_layout

\begin_layout Subsection
Constructing lifts via operation typeclasses (
\begin_inset Quotes eld
\end_inset

MTL-style
\begin_inset Quotes erd
\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "subsec:Combining-monads-via-mtl-style"

\end_inset


\end_layout

\begin_layout Standard
The MTL-style
\begin_inset Index idx
status open

\begin_layout Plain Layout
MTL-style monadic programs
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
The name MTL stands for 
\begin_inset Quotes eld
\end_inset

monad transformer library
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 monadic
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
monadic program!MTL-style
\end_layout

\end_inset

 programming is another way of achieving automatic lifting of monadic values
 in arbitrary monad stacks.
 The MTL approach has two main ingredients:
\end_layout

\begin_layout Itemize
For a chosen set of widely used monads (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad, etc.), define some typeclasses (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderMonadOps
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

, etc.) encapsulating all the 
\begin_inset Quotes eld
\end_inset

effectful operations
\begin_inset Quotes erd
\end_inset

 specific to each monad.
 Refactor all monadic code to use only the operations from the provided
 typeclasses.
 
\end_layout

\begin_layout Itemize
Provide appropriate typeclass instances for all monad transformers and all
 their combinations.
 For instance, all monad stacks that contain the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad will need to have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 typeclass instance.
 After that, all code written using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

's methods will automatically work under any monad stack that contains the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 
\end_layout

\begin_layout Standard
First, we need to define the 
\begin_inset Quotes eld
\end_inset

effectful operations
\begin_inset Quotes erd
\end_inset

 corresponding to each monad.
 As an example, consider the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad (
\begin_inset Formula $\text{State}^{S,A}\triangleq S\rightarrow A\times S$
\end_inset

).
 Its effect is to manipulate an internal state value (of type 
\begin_inset Formula $S$
\end_inset

).
 The state can be read or updated; the updated state value is automatically
 passed on to the next computation.
 We may define the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

 that work with the state value:
\begin_inset Formula 
\[
\text{get}:\text{State}^{S,S}\quad,\quad\quad\text{get}\triangleq s^{:S}\rightarrow s\times s\quad,\quad\quad\text{set}:S\rightarrow\text{State}^{S,\bbnum 1}\quad,\quad\quad\text{set}\triangleq s^{:S}\rightarrow\_^{:S}\rightarrow1\times s\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {
\end_layout

\begin_layout Plain Layout

  s1 <- get     // Get the initial state.
\end_layout

\begin_layout Plain Layout

  s2  = f(s1)   // Do some computations.
\end_layout

\begin_layout Plain Layout

  _  <- set(s2) // Store the new state.
\end_layout

\begin_layout Plain Layout

} yield g(s2)   // Compute a result value.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

-monadic program can then be written as shown at left, without referring
 to the type signature 
\begin_inset Formula $S\rightarrow A\times S$
\end_inset

.
 The two functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

 appear to be sufficient to manipulate the internal state in an arbitrary
 way.
 So, we regard these two functions as the 
\begin_inset Quotes eld
\end_inset

effectful operations
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!effectful operations
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 Any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

-monadic program may be expressed via these two operations (together with
 the standard monad methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

).
 To see this formally, consider an arbitrary monadic program 
\begin_inset Formula $q:\text{State}^{S,A}$
\end_inset

 and define functions 
\begin_inset Formula $f_{1}$
\end_inset

 and 
\begin_inset Formula $f_{2}$
\end_inset

 by:
\begin_inset Formula 
\[
f_{1}:S\rightarrow A\triangleq q\bef\pi_{1}\quad,\quad\quad f_{2}:S\rightarrow S\triangleq q\bef\pi_{2}\quad.
\]

\end_inset

These two functions compute the result value and the final updated state
 value.
 Now we can express 
\begin_inset Formula $q$
\end_inset

 equivalently as a monadic program involving only 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and the operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

q == for {
\end_layout

\begin_layout Plain Layout

  s  <- get
\end_layout

\begin_layout Plain Layout

  res = f1(s)
\end_layout

\begin_layout Plain Layout

  _  <- set(f2(s))
\end_layout

\begin_layout Plain Layout

} yield res
\end_layout

\end_inset


\begin_inset Formula 
\[
q=\text{get}\triangleright\text{flm}_{\text{State}}\big(s_{1}\rightarrow f_{2}(s_{1})\triangleright\text{set}\triangleright(\_\rightarrow f_{1}(s_{1}))^{\uparrow\text{State}}\big)\quad.
\]

\end_inset

We may refactor 
\emph on
any
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

-monadic code so that it only uses the operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

 but does not directly refer to the type 
\begin_inset Formula $S\rightarrow A\times S$
\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 For instance, the refactored code will not 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 a monadic value by applying it to an argument of type 
\begin_inset Formula $S$
\end_inset

 because that would require the knowledge of the type 
\begin_inset Formula $S\rightarrow A\times S$
\end_inset

.
 Usually, a monadic program is run only at the end of the computations.
\end_layout

\begin_layout Standard
Another example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad, for which we define an operation called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

raise
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{raise}:E\rightarrow E+A\quad,\quad\quad\text{raise}\triangleq e^{:E}\rightarrow e+\bbnum 0^{:A}\quad.
\]

\end_inset

Any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

-monadic program is a value of type 
\begin_inset Formula $E+A$
\end_inset

 and can always be expressed through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

raise
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

.
 We may then refactor any monadic code so that it uses only the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

raise
\end_layout

\end_inset

 operation and does not refer to the type 
\begin_inset Formula $E+A$
\end_inset

 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad.
 For instance, the refactored code may not apply pattern matching directly
 to a monad value of type 
\begin_inset Formula $E+A$
\end_inset

.
\end_layout

\begin_layout Standard
The second ingredient of the MTL-style programming involves 
\begin_inset Quotes eld
\end_inset

lifting
\begin_inset Quotes erd
\end_inset

 the monad operations to arbitrary monad stacks.
 For example, consider the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad with the operations 
\begin_inset Formula $\text{get}:\text{State}^{S,S}$
\end_inset

 and 
\begin_inset Formula $\text{set}:S\rightarrow\text{State}^{S,\bbnum 1}$
\end_inset

.
 For any monad stack 
\begin_inset Formula $P$
\end_inset

 containing the monad 
\begin_inset Formula $\text{State}^{S,\bullet}$
\end_inset

, we need to define the 
\begin_inset Quotes eld
\end_inset

lifted
\begin_inset Quotes erd
\end_inset

 operations 
\begin_inset Formula $\text{get}_{P}:P^{S}$
\end_inset

 and 
\begin_inset Formula $\text{set}_{P}:S\rightarrow P^{\bbnum 1}$
\end_inset

.
 By assumption, 
\begin_inset Formula $P$
\end_inset

 contains 
\begin_inset Formula $\text{State}{}^{S,\bullet}$
\end_inset

, so a certain composition of lift functions will give a monad morphism
 
\begin_inset Formula $p:\text{State}^{S,\bullet}\leadsto P^{\bullet}$
\end_inset

.
 Once 
\begin_inset Formula $p$
\end_inset

 is known, the new operations 
\begin_inset Formula $\text{get}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{set}_{P}$
\end_inset

 are expressed as:
\begin_inset Formula 
\[
\text{get}_{P}:P^{S}\triangleq\text{get}\triangleright p\quad,\quad\quad\text{set}_{P}:S\rightarrow P^{\bbnum 1}\triangleq\text{set}\bef p\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Similarly, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

raise
\end_layout

\end_inset

 operation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad can be lifted to any monad stack 
\begin_inset Formula $P$
\end_inset

 that contains the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad.
 For any such 
\begin_inset Formula $P$
\end_inset

, there exists a monad morphism 
\begin_inset Formula $p:E+A\rightarrow P^{A}$
\end_inset

, and the lifted operation (
\begin_inset Formula $\text{raise}_{P}$
\end_inset

) is defined by:
\begin_inset Formula 
\[
\text{raise}_{P}:P^{A}\quad,\quad\quad\text{raise}_{P}\triangleq\text{raise}\triangleright p\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Lifting operations from a monad to a stack usually requires having a lift
 function (
\begin_inset Formula $p$
\end_inset

) that maps values of the specific monad to the stack.
 The lift function 
\begin_inset Formula $p$
\end_inset

 will be different for each monad and each stack, and we would like to avoid
 implementing 
\begin_inset Formula $p$
\end_inset

 by hand each time.
 In MTL-style programming, this is achieved by refactoring the code to use
 special typeclasses that encapsulate the effectful operations of all the
 required monads.
 For the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad, the typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 is defined as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait StateMonadOps[F[_], S] { // `F` is any monad that has `State`-like
 operations.
\end_layout

\begin_layout Plain Layout

  def get: F[S]
\end_layout

\begin_layout Plain Layout

  def set: S => F[Unit]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

-monadic programs by using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 typeclass:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val ops = implicitly[StateMonadOps[F, S]] // Must be defined before.
\end_layout

\begin_layout Plain Layout

val program: F[A] = for {
\end_layout

\begin_layout Plain Layout

  s1 <- ops.get
\end_layout

\begin_layout Plain Layout

  s2 = f2(s1)
\end_layout

\begin_layout Plain Layout

  _ <- ops.set(s2)
\end_layout

\begin_layout Plain Layout

} yield f1(s2)
\end_layout

\end_inset

This code does 
\emph on
not
\emph default
 assume that the monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 has the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's type signature, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S => (A, S)
\end_layout

\end_inset

.
 So, it will work unmodified with any monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 that has the required typeclass instance.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad itself, of course, admits an instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val stateMonadOps: StateMonadOps[State[S, *], S] = new StateMonadOps[St
ate[S, *], S] {
\end_layout

\begin_layout Plain Layout

  def get: State[S, S] = State(s => (s, s))
\end_layout

\begin_layout Plain Layout

  def set: S => State[S, Unit] = s => State(_ => ((), s)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad, the typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherMonadOps
\end_layout

\end_inset

 is defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

trait EitherMonadOps[F[_], E] { // `F` is any monad that has `Either`-like
 operations.
\end_layout

\begin_layout Plain Layout

  def raise[A]: E => F[A]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

An instance of this typeclass can be implemented for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit val eitherMonadOps: EitherMonadOps[Either[E, *], E] = new EitherMonadOp
s[Either[E, *], E] {
\end_layout

\begin_layout Plain Layout

  def raise[A]: E => Either[E, A] = e => Left(e)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once all monadic code is refactored to use the monad operations via typeclasses,
 it remains to define the relevant typeclass instances for monad stacks.
 After that, the refactored code will work unchanged under any monad stack;
 the effectful operations will be lifted automatically through appropriate
 typeclass functions.
 Let us see in more detail how this works for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Standard
The goal is to implement a typeclass instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 for any monad stack containing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad; a typeclass instance of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EitherMonadOps
\end_layout

\end_inset

 for any stack containing the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad; and so on, for other monads.
 To proceed, we need a rigorous definition of what it means that a monad
 stack 
\begin_inset Formula $P$
\end_inset

 
\begin_inset Quotes eld
\end_inset

contains
\begin_inset Quotes erd
\end_inset

 some monad 
\begin_inset Formula $L$
\end_inset

.
 Intuitively, the stack 
\begin_inset Formula $P$
\end_inset

 should have the form 
\begin_inset Formula $P=M_{1}\varangle M_{2}\varangle...\varangle L\varangle...\varangle M_{k}$
\end_inset

 for some monads 
\begin_inset Formula $M_{1}$
\end_inset

, ..., 
\begin_inset Formula $M_{k}$
\end_inset

.
 We can write a definition by induction: 
\end_layout

\begin_layout Itemize
Base cases: 
\begin_inset Formula $P$
\end_inset

 contains 
\begin_inset Formula $L$
\end_inset

 when 
\begin_inset Formula $P=L$
\end_inset

 or 
\begin_inset Formula $P=L\varangle Q$
\end_inset

 for some other monad stack 
\begin_inset Formula $Q$
\end_inset

.
 (The stack 
\begin_inset Formula $P=L$
\end_inset

 can be seen as a special case of 
\begin_inset Formula $P=L\varangle Q$
\end_inset

 with 
\begin_inset Formula $Q=\text{Id}$
\end_inset

.) The lift function (
\begin_inset Formula $p_{L,P}$
\end_inset

) is:
\begin_inset Formula 
\[
p_{L,P}:L\leadsto L\varangle Q\quad,\quad\quad p_{L,P}\triangleq\text{blift}_{L}^{Q}\quad.
\]

\end_inset


\end_layout

\begin_layout Itemize
Inductive step: 
\begin_inset Formula $P$
\end_inset

 contains 
\begin_inset Formula $L$
\end_inset

 when 
\begin_inset Formula $P=N\varangle Q$
\end_inset

, where 
\begin_inset Formula $N$
\end_inset

 is some base monad and 
\begin_inset Formula $Q$
\end_inset

 is another monad stack that contains 
\begin_inset Formula $L$
\end_inset

.
 The lift function is:
\begin_inset Formula 
\[
p_{L,P}:L\leadsto N\varangle Q\quad,\quad\quad p_{L,P}\triangleq p_{L,Q}\bef\text{flift}_{N}\quad,
\]

\end_inset

where 
\begin_inset Formula $p_{L,Q}$
\end_inset

 is the lift function for the stack 
\begin_inset Formula $Q$
\end_inset

.
 (By the inductive assumption, 
\begin_inset Formula $p_{L,Q}$
\end_inset

 is known.)
\end_layout

\begin_layout Standard
As an example, we will implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 instance for all monad stacks that contain a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
 Begin with the base cases: The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad itself already has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 instance.
 If we have a stack of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT[Q, S, *]
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

 is any monad, we use the base lift of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 transformer to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 typeclass:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def stateTMonadOps[S, Q[_]: Monad] = new StateMonadOps[StateT[Q,
 S, *], S] {
\end_layout

\begin_layout Plain Layout

  def get: StateT[Q, S, S] = StateT(s => Monad[Q].pure((s, s)))
\end_layout

\begin_layout Plain Layout

  def set: S => StateT[Q, S, Unit] = s => StateT(_ => Monad[Q].pure(((),
 s)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the inductive step, the stack is of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OtherT[Q, *]
\end_layout

\end_inset

 where 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OtherT
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a monad transformer for the base monad 
\begin_inset Formula $N$
\end_inset

.
 By the inductive assumption, we already have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

 typeclass instance for the monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q
\end_layout

\end_inset

.
 Using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 method of the transformer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OtherT
\end_layout

\end_inset

, we write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

implicit def otherTMonadOps[OtherT[_[_], _], Q[_], S](implicit val qMonadOps:
 StateMonadOps[Q, S], otherT: MTrans[OtherT]): StateMonadOps[OtherT[Q, *]]
 = new StateMonadOps[OtherT[Q, *]] {
\end_layout

\begin_layout Plain Layout

  def get: OtherT[Q, S] = otherT.flift(qMonadOps.get)
\end_layout

\begin_layout Plain Layout

  def set: S => OtherT[Q, Unit] = qMonadOps.set andThen otherT]].flift
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To use the MTL-style monad stacks in practice, one needs a library (such
 as 
\family typewriter
cats-mtl
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://typelevel.org/blog/2018/10/06/intro-to-mtl.html"
literal "false"

\end_inset


\end_layout

\end_inset

) that defines typeclasses for monad operations.
 The library must support sufficiently many operations and monads, so that
 any desired monadic program may be expressed via those operations without
 using explicit monad types.
 The library must also implement instances of those typeclasses for all
 supported monad stacks.
 
\end_layout

\begin_layout Standard
While the MTL style does provide automatic liftings, some problems remain.
 
\end_layout

\begin_layout Standard
The first problem is the lack of general principles for the choice of effectful
 operations.
 We have seen that the operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

 are sufficient to express any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

-monadic programs.
 However, it may not be adequate to write code just with those two operations.
 As an example, look at 
\emph on
updating
\emph default
 the state using a given function of type 
\begin_inset Formula $S\rightarrow S$
\end_inset

.
 In many cases, updating is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

ting the current state value and immediately 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

ting a new value.
 However, certain kinds of updates need special handling.
 Examples are: atomic updates in a concurrent program; updates wrapped in
 a database transaction; and updates that must be run on a designated CPU
 thread (e.g., the thread that drives the GUI events).
 Such special handling of updates cannot be implemented via monadic programs
 with just 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

.
 A new effectful operation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

update
\end_layout

\end_inset

) must be provided to the programmer.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="middle" width="1.6cm">
<column alignment="center" valignment="middle" width="8.5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Monad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Operations
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{State}^{S,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{get}:\text{State}^{S,S}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{set}:S\rightarrow\text{State}^{S,\bbnum 1}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{update}:(S\rightarrow S)\rightarrow\text{State}^{S,\bbnum 1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Reader}^{R,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{ask}:\text{Reader}^{R,R}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{local}:R\times\text{Reader}^{R,A}\rightarrow\text{Reader}^{R,A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Either}^{E,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{raise}:E\rightarrow\text{Either}^{E,A}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{handle}:(E\rightarrow\text{Either}^{E,A})\times\text{Either}^{E,A}\rightarrow\text{Either}^{E,A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{empty}:\text{List}^{A}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{append}:\text{List}^{A}\times\text{List}^{A}\rightarrow\text{List}^{A}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{filter}:\text{List}^{A}\times(A\rightarrow\bbnum 2)\rightarrow\text{List}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Writer}^{W,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{log}:W\rightarrow\text{Writer}^{W,\bbnum 1}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{collect}:\text{Writer}^{W,A}\rightarrow\text{Writer}^{W,A\times W}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{process}:\text{Writer}^{W,A\times(W\rightarrow W)}\rightarrow\text{Writer}^{W,A}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{clear}:\text{Writer}^{W,A}\rightarrow\text{Writer}^{W,A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{Cont}^{R,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{abort}:R\rightarrow\text{Cont}^{R,A}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\text{callcc}:((A\rightarrow\text{Cont}^{R,B})\rightarrow\text{Cont}^{R,A})\rightarrow\text{Cont}^{R,A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
A table column's width must be set in order to allow multi-line cells in
 a column.
\end_layout

\end_inset

Known operations for some monads.
\begin_inset CommandInset label
LatexCommand label
name "tab:effectful-operations-for-some-monads"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:effectful-operations-for-some-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows a number of operations for some monads.
 Operations were gathered from the 
\family typewriter
cats-mtl
\family default
 documentation as well as the papers 
\begin_inset Quotes eld
\end_inset


\emph on
Monad transformers and modular interpreters
\emph default

\begin_inset Quotes erd
\end_inset

 
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://web.cecs.pdx.edu/~mpj/pubs/modinterp.html"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\emph on
Modular monad transformers
\emph default

\begin_inset Quotes erd
\end_inset

 
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.219.5365"
literal "false"

\end_inset


\end_layout

\end_inset

.
 The choice of operations is heuristic and does not follow any principle
 or system.
 It is not easy to decide what operations will be necessary in practical
 tasks involving a given monad.
 (Do we need a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad? How can we decide?) 
\end_layout

\begin_layout Standard
Different libraries choose different sets of supported operations.
 Adding a new operation to a monad in an MTL-style library means updating
 all typeclasses related to that monad.
 Users who cannot modify the library code will be unable to add new operations.
\end_layout

\begin_layout Standard
The second problem is the lack of a general method for lifting effectful
 operations to arbitrary monad transformers.
\begin_inset Foot
status open

\begin_layout Plain Layout
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monatron"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows a technique that can lift effectful operations systematically to
 almost all monad stacks.
\end_layout

\end_inset

 So far, the examples in this subsection were limited to operations with
 type signatures of the form 
\begin_inset Formula $L^{A}$
\end_inset

 or 
\begin_inset Formula $A\rightarrow L^{B}$
\end_inset

.
 All operations of this form are lifted from the monad 
\begin_inset Formula $L$
\end_inset

 to a monad stack 
\begin_inset Formula $P$
\end_inset

 by composing with a lift function 
\begin_inset Formula $p:L^{A}\rightarrow P^{A}$
\end_inset

.
 However, some operations have significantly different type signatures and
 cannot be lifted to arbitrary monad stacks by composing with a lift.
 For instance, an operation called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

local
\end_layout

\end_inset

 (defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad) has the type signature 
\begin_inset Formula $R\rightarrow\text{Reader}^{R,A}\rightarrow\text{Reader}^{R,A}$
\end_inset

.
 In that type signature, some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 values are used as arguments (that is, in a contravariant position).
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

local
\end_layout

\end_inset

 cannot be converted to a function of type 
\begin_inset Formula $R\rightarrow P^{A}\rightarrow P^{A}$
\end_inset

 by composing with a lift function 
\begin_inset Formula $p:\text{Reader}^{R,A}\rightarrow P^{A}$
\end_inset

.
 Another example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 operation that has the type 
\begin_inset Formula $\text{Writer}^{W,A}\rightarrow\text{Writer}^{W,A}$
\end_inset

.
 Knowing only a lift function 
\begin_inset Formula $p:\text{Writer}^{W,A}\rightarrow P^{A}$
\end_inset

 is not sufficient for transforming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 into a function of type 
\begin_inset Formula $P^{A}\rightarrow P^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
Lifting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 to a given monad stack 
\begin_inset Formula $P$
\end_inset

 (say, 
\begin_inset Formula $P\triangleq\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 or 
\begin_inset Formula $P\triangleq\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

) requires custom code.
 Let us see how to write that code.
 For the stack 
\begin_inset Formula $P=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

, we need to implement a function 
\begin_inset Formula $\text{clear}_{P}$
\end_inset

 of type 
\begin_inset Formula $P^{A}\rightarrow P^{A}$
\end_inset

 given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 with type signature:
\begin_inset Formula 
\[
\text{clear}:\text{Writer}^{W,A}\rightarrow\text{Writer}^{W,A}=W\times A\rightarrow W\times A\quad.
\]

\end_inset

Since the stack type is 
\begin_inset Formula $P^{A}\triangleq T_{\text{State}}^{\text{Writer},A}=S\rightarrow W\times A\times S$
\end_inset

, the code for 
\begin_inset Formula $\text{clear}_{P}$
\end_inset

 is:
\begin_inset Formula 
\[
\text{clear}_{P}:\left(S\rightarrow W\times A\times S\right)\rightarrow S\rightarrow W\times A\times S\quad,\quad\quad\text{clear}_{P}\triangleq p^{:S\rightarrow W\times A\times S}\rightarrow p\bef(\text{clear}\boxtimes\text{id}^{S})\quad.
\]

\end_inset

For the stack 
\begin_inset Formula $P=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset


\begin_inset Formula $\varangle$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

, or more verbosely:
\begin_inset Formula 
\[
P^{A}\triangleq T_{\text{Writer}}^{\text{Cont},A}=(W\times A\rightarrow R)\rightarrow R\quad,
\]

\end_inset

the lifted operation 
\begin_inset Formula $\text{clear}_{P}$
\end_inset

 of type 
\begin_inset Formula $\left((W\times A\rightarrow R)\rightarrow R\right)\rightarrow(W\times A\rightarrow R)\rightarrow R$
\end_inset

 is implemented as:
\begin_inset Formula 
\[
\text{clear}_{P}\triangleq p^{:(W\times A\rightarrow R)\rightarrow R}\rightarrow q^{:W\times A\rightarrow R}\rightarrow p(\text{clear}\bef q)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
These examples show that lifting an operation to a specific monad transformer
 will require custom code adapted to every combination of a monad and an
 operation.
 The length of required custom code is quadratic in the number of supported
 monads.
\end_layout

\begin_layout Standard
The third problem is the large number of typeclass instances that MTL libraries
 need to maintain.
 As we have seen in the example with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateMonadOps
\end_layout

\end_inset

, just two implicit functions per monad type are in principle sufficient
 to define the operation typeclasses for all monad stacks.
 This would make the number of typeclass instances linear in the number
 of supported monads.
 However, to make the code run faster, libraries provide typeclass instances
 for every combination of monads (say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

, and so on).
 This makes the required number of typeclass instances quadratic in the
 number of supported monads.
 Adding a new monad to an MTL library requires adding many new typeclass
 instances.
\end_layout

\begin_layout Standard
For these reasons, MTL libraries usually support only a limited number of
 monads and operations.
\end_layout

\begin_layout Section
Laws of monad transformers
\end_layout

\begin_layout Subsection
Motivation for the laws of lifts
\end_layout

\begin_layout Standard
A monad transformer creates a new monad that combines the effects of other
 monads.
 Our next goal is to derive the properties required for the new monad to
 work well in practice.
 So, let us look at the programmer's intuitions about monadic programs written
 using transformers.
\end_layout

\begin_layout Standard
To be specific, assume that we have combined two monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 into a transformed monad 
\begin_inset Formula $T\triangleq L\varangle M\triangleq T_{L}^{M}$
\end_inset

 and defined the necessary lifts, 
\begin_inset Formula $\text{up}_{L}:L^{A}\rightarrow T^{A}$
\end_inset

 and 
\begin_inset Formula $\text{up}_{M}:M^{A}\rightarrow T^{A}$
\end_inset

.
 After these definitions, a programmer should be able to write functor blocks
 with lifted values of 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 
\end_layout

\begin_layout Standard
Programmers will certainly expect all previously accepted properties of
 functor blocks to remain valid after lifting all monadic values of types
 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 to the transformed monad 
\begin_inset Formula $T$
\end_inset

.
 A monadic program in 
\begin_inset Formula $T$
\end_inset

 could look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {
\end_layout

\begin_layout Plain Layout

  i <- someValueL.up
\end_layout

\begin_layout Plain Layout

  x <- someValueT(i)
\end_layout

\begin_layout Plain Layout

  y <- anotherValueT(y)
\end_layout

\begin_layout Plain Layout

  z <- someValueM(x).up
\end_layout

\begin_layout Plain Layout

} yield z
\end_layout

\end_inset

This program combines values of 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 lifted to 
\begin_inset Formula $T$
\end_inset

 with some directly available values of the monad 
\begin_inset Formula $T$
\end_inset

 (say, obtained from other monadic programs).
 Refactoring such programs involves, as a special case, refactoring of functor
 blocks in the monad 
\begin_inset Formula $T$
\end_inset

 alone.
 It follows that 
\begin_inset Formula $T$
\end_inset

 must itself satisfy the monad laws, — the laws we derived in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Semimonads-and-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by analyzing various functor block refactorings.
 
\end_layout

\begin_layout Standard
There are some additional code refactorings specific to lifted monadic values.
 Lifted values may occur before or after a source line with an arbitrary
 value of 
\begin_inset Formula $T$
\end_inset

.
 Similarly to the standard monadic refactorings, we consider three cases:
 a lifted 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method before a source line, a lifted 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method after a source line, and refactoring two adjacent lifted source
 lines into a separate functor block.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method is used before a source line, we expect the following refactoring
 to work:
\end_layout

\begin_layout Standard
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family roman
\size footnotesize
\color darkgray
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

           // Anywhere inside a for/yield:
\end_layout

\begin_layout Plain Layout

  y <- Monad[L].pure(x).up // Assume x: A
\end_layout

\begin_layout Plain Layout

  z <- f(y)                // f: A => T[B]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Must be equivalent to...
\end_layout

\begin_layout Plain Layout

  y = x     // x: A
\end_layout

\begin_layout Plain Layout

  z <- f(y) // f: A => T[B]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
The corresponding law is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

pure(x).up.flatMap(f) == f(x)
\end_layout

\end_inset

 or:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\text{blift}\bef\text{flm}_{T}(f)=f\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method is used after a source line, we expect the following code equivalence:
\end_layout

\begin_layout Standard
\begin_inset VSpace -50baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family roman
\size footnotesize
\color darkgray
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

           // Anywhere inside a for/yield:
\end_layout

\begin_layout Plain Layout

  x <- t   // Assume t: T[A]
\end_layout

\begin_layout Plain Layout

  y <- Monad[L].pure(x).up
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 // Must be equivalent to...
\end_layout

\begin_layout Plain Layout

  x <- t   // Assume t: T[A]
\end_layout

\begin_layout Plain Layout

  y = x
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
The corresponding law is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

t.flatMap(x => L.pure(x).up) == t
\end_layout

\end_inset

 or:
\begin_inset Formula 
\[
\text{flm}_{T}(\text{pu}_{L}\bef\text{blift})=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The third law comes from refactoring a functor block when two adjacent source
 lines are lifted from 
\begin_inset Formula $L$
\end_inset

.
 We may equivalently put these lines in a functor block in 
\begin_inset Formula $L$
\end_inset

 and then lift its result to 
\begin_inset Formula $T$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset VSpace -40baselineskip%
\end_inset


\end_layout

\begin_layout Standard
\noindent

\family typewriter
\size footnotesize
\color blue
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family roman
\size footnotesize
\color darkgray
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

            // Anywhere inside a for/yield:
\end_layout

\begin_layout Plain Layout

  x <- p.up      // Assume p: L[A]
\end_layout

\begin_layout Plain Layout

  y <- q(x).up   // q: A => L[B]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "48col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\color blue
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 // Must be equivalent to...
\end_layout

\begin_layout Plain Layout

  pq = for { x <- p; y <- q(x) } yield y
\end_layout

\begin_layout Plain Layout

  y <- pq.up // Lift a refactored block.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
The corresponding law is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

p.up.flatMap(x => q(x).up) == p.flatMap(q).up
\end_layout

\end_inset

 or:
\begin_inset Formula 
\[
\text{blift}\bef\text{flm}_{T}(q\bef\text{blift})=\text{flm}_{L}(q)\bef\text{blift}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The form of these three laws can be simplified if we rewrite them in terms
 of the Kleisli composition operations 
\begin_inset Formula $\diamond_{_{L}}$
\end_inset

 and 
\begin_inset Formula $\diamond_{_{T}}$
\end_inset

.
 Recall that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 is related to the Kleisli composition by:
\begin_inset Formula 
\[
f^{:A\rightarrow T^{B}}\diamond_{_{T}}g^{:B\rightarrow T^{C}}=f\bef\text{flm}_{T}(g)\quad.
\]

\end_inset

The first law is then written as:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\text{blift}\bef\text{flm}_{T}(f)=(\text{pu}_{L}\bef\text{blift})\diamond_{_{T}}f\overset{!}{=}f\quad.
\]

\end_inset

The second law is not of the form 
\begin_inset Formula $f\bef\text{flm}\left(...\right)$
\end_inset

, so let us pre-compose it with an arbitrary 
\begin_inset Formula $f^{:A\rightarrow T^{B}}$
\end_inset

:
\begin_inset Formula 
\[
f\bef\text{flm}_{T}(\text{pu}_{L}\bef\text{blift})=f\diamond_{_{T}}(\text{pu}_{L}\bef\text{blift})\overset{!}{=}f\bef\text{id}=f\quad.
\]

\end_inset

Pre-compose also the third law with an arbitrary function 
\begin_inset Formula $p^{:A\rightarrow L^{B}}$
\end_inset

:
\begin_inset Formula 
\[
p\bef\text{blift}\bef\text{flm}_{T}(q\bef\text{blift})=(p\bef\text{blift})\diamond_{_{T}}(q\bef\text{blift})\overset{!}{=}p\bef\text{flm}_{L}(q)\bef\text{blift}=(p\diamond_{_{L}}q)\bef\text{blift}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The first two laws are now easier to interpret: they require the function
 (
\begin_inset Formula $\text{pu}_{L}\bef\text{blift}$
\end_inset

) to be both a left and a right unit for the Kleisli composition 
\begin_inset Formula $\diamond_{_{T}}$
\end_inset

.
 However, the monad laws of 
\begin_inset Formula $T$
\end_inset

 already provide such a unit, namely 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

.
 An associative operation can have only one two-sided unit, so (
\begin_inset Formula $\text{pu}_{L}\bef\text{blift}$
\end_inset

) must be equal to 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

.
 To see that, it is sufficient to write the equation:
\begin_inset Formula 
\[
(\text{pu}_{L}\bef\text{blift})=(\text{pu}_{L}\bef\text{blift})\diamond_{_{T}}\text{pu}_{T}=\text{pu}_{T}\quad.
\]

\end_inset

So, the first two laws are equivalent to a single
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of monad transformer's lift
\end_layout

\end_inset

 
\series bold
identity law
\series default
:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\text{blift}=\text{pu}_{T}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The third law says that the post-composition with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 will map a Kleisli composition in 
\begin_inset Formula $L$
\end_inset

 to a Kleisli composition in 
\begin_inset Formula $T$
\end_inset

.
 This is the 
\series bold
composition law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of monad transformer's lift
\end_layout

\end_inset

 of lifts.
 This law is sometimes easier to verify when expressed through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

, although the formulation of the law becomes less visually clear:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.6pc}\xyScaleX{2.0pc}L^{L^{A}}\ar[d]\sb(0.45){\text{ftn}_{L}}\ar[r]\sb(0.5){\text{blift}} & T^{L^{A}}\ar[r]\sb(0.5){\text{blift}^{\uparrow T}} & T^{T^{A}}\ar[d]\sp(0.45){\text{ftn}_{T}}\\
L^{A}\ar[rr]\sp(0.5){\text{blift}} &  & T^{A}
}
\]

\end_inset


\begin_inset Formula 
\[
\text{blift}\bef\text{blift}^{\uparrow T}\bef\text{ftn}_{T}=\text{ftn}_{L}\bef\text{blift}\quad.
\]

\end_inset

The identity and composition law enforce a certain compatibility of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 with the monad methods of 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 Laws of this form were introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monads-in-category-theory-monad-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

 where we considered monad morphisms
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad morphism
\end_layout

\end_inset

 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 between two monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 So, we have now shown that the expected properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 in functor blocks are equivalent to the requirement that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 should be a monad morphism of type 
\begin_inset Formula $L\leadsto T_{L}^{M}$
\end_inset

.
\end_layout

\begin_layout Standard
Since we expect to be able to use the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 equally well within a functor block, the same refactorings must be possible
 with values of type 
\begin_inset Formula $M$
\end_inset

 instead of 
\begin_inset Formula $L$
\end_inset

.
 Thus, the laws of monad morphisms must hold also for the foreign lift function
 (
\begin_inset Formula $\text{flift}_{L}:M\leadsto T_{L}^{M}$
\end_inset

).
\end_layout

\begin_layout Standard
Since monad morphisms are natural transformations (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-flatMap-formulation-of-monad-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

), both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 obey the corresponding naturality laws.
 The naturality laws can be also motivated by considering functor blocks
 where a source line with a lift occurs next to a non-source line.
 We will omit the details, keeping in mind that naturality laws always hold
 for fully parametric code.
\end_layout

\begin_layout Subsection
Motivation for the laws of runners
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
runner!for monads
\end_layout

\end_inset

A monad's runner (
\begin_inset Formula $\theta_{M}:M^{A}\rightarrow A$
\end_inset

) extracts results of type 
\begin_inset Formula $A$
\end_inset

 from monadic values of type 
\begin_inset Formula $M^{A}$
\end_inset

.
 The use of a runner will agree with programmer's intuition if the runner
 obeys the laws of monad morphisms (see Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-monad-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 A runner 
\begin_inset Formula $\theta_{M}$
\end_inset

 must be a monad morphism of type 
\begin_inset Formula $M\leadsto\text{Id}$
\end_inset

 (between 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $\text{Id}$
\end_inset

, the identity monad).
 Heuristically, a runner 
\begin_inset Quotes eld
\end_inset

executes
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

runs
\begin_inset Quotes erd
\end_inset

 the effects of the monad 
\begin_inset Formula $M$
\end_inset

 and delivers an effect-free value as a result.
\end_layout

\begin_layout Standard
How can we extract effect-free values from a monad stack that combines the
 effects of several monads? Let us try to create a runner 
\begin_inset Formula $\theta_{T}:T_{L}^{M,A}\rightarrow A$
\end_inset

 for the transformed monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

, provided that both 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 have known runners 
\begin_inset Formula $\theta_{L}$
\end_inset

 and 
\begin_inset Formula $\theta_{M}$
\end_inset

.
\end_layout

\begin_layout Standard
As a first example, assume a compositional transformer such as 
\begin_inset Formula $T_{L}^{M}=L\circ M$
\end_inset

; this is the case for 
\begin_inset Formula $L=$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 and some other monads.
 Given a runner 
\begin_inset Formula $\theta_{M}$
\end_inset

, we may first run 
\begin_inset Formula $M$
\end_inset

's effects by using 
\begin_inset Formula $\theta_{M}^{\uparrow L}$
\end_inset

:
\begin_inset Formula 
\[
\theta_{M}^{\uparrow L}:L^{M^{A}}\rightarrow L^{A}\quad.
\]

\end_inset

A value of type 
\begin_inset Formula $A$
\end_inset

 can be now extracted by using 
\begin_inset Formula $L$
\end_inset

's runner.
 So, we may express 
\begin_inset Formula $\theta_{T}$
\end_inset

 as:
\begin_inset Formula 
\[
\theta_{T}\triangleq\theta_{M}^{\uparrow L}\bef\theta_{L}\quad.
\]

\end_inset

If we first run the effects of 
\begin_inset Formula $L$
\end_inset

 and then those of 
\begin_inset Formula $M$
\end_inset

, the result will be the same: 
\begin_inset Formula $\theta_{L}^{\uparrow L}\bef\theta_{M}=\theta_{M}\bef\theta_{L}$
\end_inset

 by the (assumed) naturality of 
\begin_inset Formula $\theta_{L}$
\end_inset

.
 So, the runners commute.
 This is intuitively to be expected because the two runners work on different
 effects that are separately present in a value of type 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
\end_layout

\begin_layout Standard
A similar situation occurs for pass/fail monads that have composed-inside
 transformers.
 We may run the effects of only one of the monads, or both if needed; the
 runners commute.
\end_layout

\begin_layout Standard
Now consider a non-compositional transformer such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

:
\begin_inset Formula 
\[
T_{\text{State}}^{M,A}=S\rightarrow M^{A\times S}\quad.
\]

\end_inset

In this case, we cannot run the effects of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 using 
\begin_inset Formula $\theta_{\text{State}}$
\end_inset

 or the effects of 
\begin_inset Formula $M$
\end_inset

 using 
\begin_inset Formula $\theta_{M}^{\uparrow\text{State}}$
\end_inset

: the types do not match.
 Compare the types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

, 
\begin_inset Formula $\theta_{\text{State}}$
\end_inset

, and 
\begin_inset Formula $\theta_{M}^{\uparrow\text{State}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{brun}:T_{\text{State}}^{M,A}\rightarrow M^{A}=(S\rightarrow M^{A\times S})\rightarrow M^{A}\quad\quad\text{vs.}\quad\theta_{\text{State}}:\left(S\rightarrow A\times S\right)\rightarrow A\quad,\\
 & \text{frun}:T_{\text{State}}^{M,A}\rightarrow\text{State}^{S,A}=(S\rightarrow M^{A\times S})\rightarrow S\rightarrow A\times S\quad\quad\text{vs.}\quad\theta_{M}^{\uparrow\text{State}}:(S\rightarrow M^{A}\times S)\rightarrow S\rightarrow A\times S\quad.
\end{align*}

\end_inset

We need to use new runners specially adapted to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

, as shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monad-transformers-for-standard-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The foreign runner (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

) is a function of 
\begin_inset Formula $\theta_{M}$
\end_inset

 and works for all foreign monads 
\begin_inset Formula $M$
\end_inset

.
 The base runner 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

, however, is not a function of 
\begin_inset Formula $\theta_{\text{State}}$
\end_inset

 but has custom code.
 So, the commutativity of runners,
\begin_inset Formula 
\[
\text{frun}_{\text{State}}(\theta_{M})\bef\theta_{\text{State}}(i)\overset{?}{=}\text{brun}_{\text{State}}(i)\bef\theta_{M}\quad,
\]

\end_inset

is no longer automatic and needs to be verified.
 Apply both sides to a value 
\begin_inset Formula $t^{:T_{\text{State}}^{M,A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & t\triangleright\text{frun}_{\text{State}}(\theta_{M})\bef\theta_{\text{State}}(i)=t\triangleright(t\rightarrow t\bef\theta_{M})\bef(t\rightarrow i\triangleright t\triangleright\pi_{1})\\
\text{compute composition}:\quad & \quad=i\triangleright(t\bef\theta_{M})\triangleright\pi_{1}=i\triangleright t\bef\theta_{M}\bef\pi_{1}\quad,\\
\text{left-hand side}:\quad & t\triangleright\text{brun}_{\text{State}}(i)\bef\theta_{M}=t\triangleright(t\rightarrow i\triangleright t\triangleright\pi_{1}^{\uparrow M})\triangleright\theta_{M}=i\triangleright t\bef\gunderline{\pi_{1}^{\uparrow M}\bef\theta_{M}}\\
\text{naturality law of }\theta_{M}:\quad & \quad=i\triangleright t\bef\theta_{M}\bef\pi_{1}\quad.
\end{align*}

\end_inset

Both sides are now equal, which proves the commutativity of runners for
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
These examples motivate the requirement that a monad transformer should
 come equipped 
\begin_inset Index idx
status open

\begin_layout Plain Layout
runner!for monad transformers
\end_layout

\end_inset

with
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!base runner
\end_layout

\end_inset

 a
\series bold
 base runner
\series default
, 
\begin_inset Formula $\text{brun}_{L}:T_{L}^{M}\leadsto M$
\end_inset

, and
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!foreign runner
\end_layout

\end_inset

 a 
\series bold
foreign runner
\series default
, 
\begin_inset Formula $\text{frun}_{L}(\theta_{M}):T_{L}^{M}\leadsto L$
\end_inset

 (as long as the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 have runners 
\begin_inset Formula $\theta_{L}$
\end_inset

 and 
\begin_inset Formula $\theta_{M}$
\end_inset

.
 The foreign runner must be a function of 
\begin_inset Formula $\theta_{M}$
\end_inset

, but the base runner is not necessarily expressed as a function of 
\begin_inset Formula $\theta_{L}$
\end_inset

.
 The effects of the base monad and of the foreign monad may be run in any
 order, and the results must be the same:
\begin_inset Formula 
\[
\text{brun}_{L}\bef\theta_{M}=\text{frun}_{L}(\theta_{M})\bef\theta_{L}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Some monads 
\begin_inset Formula $M$
\end_inset

 do not admit monad morphisms 
\begin_inset Formula $M\leadsto\text{Id}$
\end_inset

 but instead have useful monad morphisms 
\begin_inset Formula $M\leadsto N$
\end_inset

 with suitable target monads 
\begin_inset Formula $N$
\end_inset

.
 A monad morphism 
\begin_inset Formula $M\leadsto N$
\end_inset

 may partially run the effects of 
\begin_inset Formula $M$
\end_inset

 and represent the results using 
\begin_inset Formula $N$
\end_inset

's effects.
 For example, the continuation monad can be mapped to a task monad such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

; the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 monad can be mapped to an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Standard
When a foreign monad 
\begin_inset Formula $M$
\end_inset

 requires a runner of the form 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 with a target monad 
\begin_inset Formula $N\not\cong\text{Id}$
\end_inset

, we would like to be able to map the monad stacks accordingly as 
\begin_inset Formula $T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

, possibly running some of 
\begin_inset Formula $M$
\end_inset

's effects but keeping 
\begin_inset Formula $L$
\end_inset

's effects unchanged.
 It is natural to expect that the same foreign runner (
\begin_inset Formula $\text{frun}_{L}$
\end_inset

) should be able to use 
\begin_inset Formula $\phi$
\end_inset

 instead of 
\begin_inset Formula $\theta_{M}$
\end_inset

.
 We can then compute a map 
\begin_inset Formula $\text{frun}_{L}\left(\phi\right):T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

 that runs the stacks as required.
\end_layout

\begin_layout Standard
When the base monad 
\begin_inset Formula $L$
\end_inset

 requires a runner with a target monad 
\begin_inset Formula $K$
\end_inset

, we will similarly need a monad morphism 
\begin_inset Formula $T_{L}^{M}\leadsto T_{K}^{M}$
\end_inset

 that can partially run the effects of 
\begin_inset Formula $L$
\end_inset

.
 Since 
\begin_inset Formula $T_{K}^{M}$
\end_inset

 depends on 
\begin_inset Formula $K$
\end_inset

 non-parametrically, we cannot expect to have a 
\begin_inset Quotes eld
\end_inset

universal
\begin_inset Quotes erd
\end_inset

 base runner that uses 
\begin_inset Formula $\phi:L\leadsto K$
\end_inset

 as a parameter.
 The extended base runner (
\begin_inset Formula $\text{brun}_{L,K}:T_{L}^{M}\leadsto T_{K}^{M}$
\end_inset

) will work for all foreign monads 
\begin_inset Formula $M$
\end_inset

 but needs to have custom code specially adapted to the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Standard
The pass/fail monads (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

) show one example where a universal base runner
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!universal base runner
\end_layout

\end_inset

 exists.
 Recall that the monad transformers for pass/fail monads work by functor
 composition.
 If 
\begin_inset Formula $L^{A}=\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $K^{A}\triangleq E+A$
\end_inset

 (where 
\begin_inset Formula $E$
\end_inset

 is a fixed type representing error information), we can choose an arbitrary
 runner 
\begin_inset Formula $\phi:L\leadsto K$
\end_inset

 and compute the universal base runner as:
\begin_inset Formula 
\[
\text{brun}_{L,K}(\phi):(T_{L}^{M}\leadsto T_{K}^{M})\triangleq\phi^{\uparrow M}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Apart from the laws of monad morphisms, do 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 need additional properties? For intuition, recall the example with the
 continuation monad's runner (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-continuation-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that works by first mapping 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

 
\begin_inset Formula $\leadsto$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 
\begin_inset Formula $\leadsto$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Id
\end_layout

\end_inset

.
 Denote the two runners by:
\begin_inset Formula 
\[
\phi_{1}:\text{Cont}^{R,A}\rightarrow\text{Future}^{A}\quad,\quad\quad\phi_{2}:\text{Future}^{A}\rightarrow A\quad.
\]

\end_inset

The runner for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

 is then defined by 
\begin_inset Formula $\theta_{\text{Cont}}\triangleq\phi_{1}\bef\phi_{2}$
\end_inset

.
 Now consider how we would run a monad stack 
\begin_inset Formula $T_{L}^{\text{Cont}}$
\end_inset

.
 We may use the foreign runner with 
\begin_inset Formula $\theta_{\text{Cont}}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{frun}_{L}(\theta_{\text{Cont}}):T_{L}^{\text{Cont}}\leadsto L\quad.
\]

\end_inset

We could also use those runners to map 
\begin_inset Formula $T_{L}^{\text{Cont}}\leadsto T_{L}^{\text{Future}}$
\end_inset

 and then 
\begin_inset Formula $T_{L}^{\text{Future}}\leadsto T_{L}^{\text{Id}}\cong L$
\end_inset

:
\begin_inset Formula 
\[
\text{frun}_{L}(\phi_{1}):T_{L}^{\text{Cont}}\leadsto T_{L}^{\text{Future}}\quad,\quad\quad\text{frun}_{L}(\phi_{2}):T_{L}^{\text{Future}}\leadsto L\quad.
\]

\end_inset

Intuitively, we would expect that the composition of these two runners should
 be the same as when running 
\begin_inset Formula $T_{L}^{\text{Cont}}$
\end_inset

 directly into 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\[
\text{frun}_{L}(\phi_{1})\bef\text{frun}_{L}(\phi_{2})\overset{!}{=}\text{frun}_{L}(\theta_{\text{Cont}})=\text{frun}_{L}(\phi_{1}\bef\phi_{2})\quad.
\]

\end_inset

The composition 
\begin_inset Formula $\phi_{1}\bef\phi_{2}$
\end_inset

 of any two monad morphisms 
\begin_inset Formula $\phi_{1}$
\end_inset

 and 
\begin_inset Formula $\phi_{2}$
\end_inset

 is again a monad morphism (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This suggests the 
\series bold
composition law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of foreign runner (
\family typewriter
frun
\family default
)
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{frun}_{L}(\phi_{1})\bef\text{frun}_{L}(\phi_{2})\overset{!}{=}\text{frun}_{L}(\phi_{1}\bef\phi_{2})\quad.\label{eq:composition-law-of-frun}
\end{equation}

\end_inset

This law is similar to the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 By analogy, we also impose the 
\series bold
identity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of foreign runner (
\family typewriter
frun
\family default
)
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{frun}_{L}(\text{id}^{:M^{A}\rightarrow M^{A}})\overset{!}{=}\text{id}^{:T_{L}^{M,A}\rightarrow T_{L}^{M,A}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Finally, let us consider how to use a monad stack 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 within a functor block.
 Typically, we would lift some values of types 
\begin_inset Formula $L^{A}$
\end_inset

 or 
\begin_inset Formula $M^{A}$
\end_inset

 to the stack.
 At the end of the computation, we may run some (or all) of the effects.
 After lifting a monadic value, there are two possible cases: we then run
 the effects of the same monad, or we run the effects of the other monad.
 
\end_layout

\begin_layout Standard
In the first case, we lift a value 
\begin_inset Formula $m:M^{A}$
\end_inset

 to the stack 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 and then run the effects of 
\begin_inset Formula $M$
\end_inset

 using 
\begin_inset Formula $\text{frun}_{L}(\theta_{M})$
\end_inset

, getting a value of type 
\begin_inset Formula $L^{A}$
\end_inset

.
 The result is a transformation:
\begin_inset Formula 
\[
\text{flift}_{L}\bef\text{frun}_{L}(\theta_{M}):M^{A}\rightarrow L^{A}\quad.
\]

\end_inset

Note that both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 are monad morphisms, so their composition is again a monad morphism 
\begin_inset Formula $M\leadsto L$
\end_inset

.
 Since 
\begin_inset Formula $M$
\end_inset

 is an arbitrary foreign monad, we cannot expect the monad 
\begin_inset Formula $L$
\end_inset

 to describe any effects of the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 So, the result value of type 
\begin_inset Formula $L^{A}$
\end_inset

 must have an empty 
\begin_inset Formula $L$
\end_inset

-effect, that is, it must be created from a value 
\begin_inset Formula $a^{:A}$
\end_inset

 via 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

.
 The only way to obtain a value 
\begin_inset Formula $a^{:A}$
\end_inset

 is by applying a runner 
\begin_inset Formula $\theta_{M}$
\end_inset

 to the value 
\begin_inset Formula $m:M^{A}$
\end_inset

.
 So, we motivate a 
\begin_inset Quotes eld
\end_inset

purity
\begin_inset Quotes erd
\end_inset

 law:
\begin_inset Formula 
\[
m\triangleright\text{flift}_{L}\triangleright\text{frun}_{L}(\theta_{M})=m\triangleright\theta_{M}\triangleright\text{pu}_{L}\quad,\quad\text{or equivalently:}\quad\quad\text{flift}_{L}\bef\text{frun}_{L}(\theta_{M})=\theta_{M}\bef\text{pu}_{L}\quad.
\]

\end_inset

An analogous purity law
\begin_inset Index idx
status open

\begin_layout Plain Layout
purity laws!of monad transformer runners
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{blift}\bef\text{brun}=\theta_{L}\bef\text{pu}_{M}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In the second case, we lift a foreign value 
\begin_inset Formula $m:M^{A}$
\end_inset

 to the stack, obtaining a value 
\begin_inset Formula $t\triangleq\text{flift}\left(m\right)$
\end_inset

, and then apply the 
\emph on
base
\emph default
 
\emph on
runner
\emph default
 to 
\begin_inset Formula $t$
\end_inset

 (running just the effects of 
\begin_inset Formula $L$
\end_inset

).
 This yields a monad morphism 
\begin_inset Formula $M^{A}\rightarrow M^{A}$
\end_inset

.
 We expect this morphism to be an identity function
\begin_inset Foot
status open

\begin_layout Plain Layout
Are there any non-identity monad morphisms of type 
\begin_inset Formula $M^{A}\rightarrow M^{A}$
\end_inset

 and parametric in the monad 
\begin_inset Formula $M$
\end_inset

? See Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-identity-natural-monad-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 because the monad 
\begin_inset Formula $M$
\end_inset

 is arbitrary, and the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 must be parametric in 
\begin_inset Formula $M$
\end_inset

.
 This requirement is written as the law:
\begin_inset Formula 
\[
m\triangleright\text{flift}\triangleright\text{brun}\overset{!}{=}m\quad,\quad\text{or equivalently:}\quad\quad\text{flift}\bef\text{brun}\overset{!}{=}\text{id}\quad,
\]

\end_inset

called the 
\series bold
nondegeneracy law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nondegeneracy law!of base runner (
\family typewriter
brun
\family default
)
\end_layout

\end_inset

 of  
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

.
 The law requires 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 to preserve all information about 
\begin_inset Formula $M$
\end_inset

-effects.
 The analogous 
\begin_inset Index idx
status open

\begin_layout Plain Layout
nondegeneracy law!of foreign runner (
\family typewriter
frun
\family default
)
\end_layout

\end_inset

nondegeneracy law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{blift}\bef\text{frun}_{L}(\theta_{M})=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsection
Simplifying the laws of lifts and runners via category theory
\begin_inset CommandInset label
LatexCommand label
name "subsec:Category-theoretic-properties-of-lifts-and-runners-functors-in-category-of-monads"

\end_inset


\end_layout

\begin_layout Standard
We have motivated many laws of lifts and runners by heuristic considerations.
 Let us turn to category theory for guidance about obtaining a simplified
 and coherent picture of those laws.
\end_layout

\begin_layout Standard
The composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-frun"
plural "false"
caps "false"
noprefix "false"

\end_inset

) suggests that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 is a lifting from monad morphisms 
\begin_inset Formula $M\leadsto N$
\end_inset

 to monad morphisms 
\begin_inset Formula $T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

.
 In the language of category theory, a monad morphism is a morphism in the
 category of monads.
 The category of monads has all possible monads (
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

, ...) as its objects and all possible monad morphisms (of type 
\begin_inset Formula $M\leadsto N$
\end_inset

) as its morphisms.
 
\end_layout

\begin_layout Standard
Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 obeys the laws of identity and composition; these are the laws of a (categorica
l) functor.
 Looking at the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-frun"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we find that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 maps morphisms between monads (
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

, etc.) to morphisms between monad stacks with base 
\begin_inset Formula $L$
\end_inset

 (such as 
\begin_inset Formula $T_{L}^{M}$
\end_inset

, 
\begin_inset Formula $T_{L}^{N}$
\end_inset

, etc.).
 
\end_layout

\begin_layout Standard
So, let us consider the category of monad
\begin_inset Index idx
status open

\begin_layout Plain Layout
category of monads
\end_layout

\end_inset

 stacks with a fixed base monad 
\begin_inset Formula $L$
\end_inset

.
 The objects of that category are all monad stacks 
\begin_inset Formula $T_{L}^{M}$
\end_inset

, 
\begin_inset Formula $T_{L}^{N}$
\end_inset

, etc., with the same base monad.
 The morphisms of that category are all monad morphisms between those monad
 stacks.
 (Since monad stacks are themselves monads, the category of monad stacks
 with base 
\begin_inset Formula $L$
\end_inset

 is a sub-category of the category of monads
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!category of
\end_layout

\end_inset

.) 
\end_layout

\begin_layout Standard
Observe that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 plays the role of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function for a (categorical) functor from the category of monads to the
 category of monad stacks with base 
\begin_inset Formula $L$
\end_inset

.
 That functor (which we may denote by 
\begin_inset Formula $T_{L}^{\bullet}$
\end_inset

) maps each monad 
\begin_inset Formula $M$
\end_inset

 to the stack 
\begin_inset Formula $T_{L}^{M}$
\end_inset

, and each monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 to a monad morphism 
\begin_inset Formula $\text{frun}_{L}(\phi):T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

.
 We may view the functor 
\begin_inset Formula $T_{L}^{\bullet}$
\end_inset

 as the 
\begin_inset Quotes eld
\end_inset

bare
\begin_inset Quotes erd
\end_inset

 monad transformer, not yet applied to a foreign monad 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
Note that the functor 
\begin_inset Formula $T_{L}$
\end_inset

 maps the monad 
\begin_inset Formula $M$
\end_inset

 to the stack 
\begin_inset Formula $T_{L}^{M}$
\end_inset

; it maps objects of one category to objects of another.
 It is not a function from 
\emph on
values
\emph default
 of type 
\begin_inset Formula $M^{A}$
\end_inset

 to values of type 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

.
 That function is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

.
 What is the role of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 in the category of monads? The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 works in the same way for any foreign monad 
\begin_inset Formula $M$
\end_inset

 (because the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is parametric in the type constructor 
\begin_inset Formula $M$
\end_inset

).
 So, let us look at the relationship between the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 applied to different foreign monads.
\end_layout

\begin_layout Standard
Assume 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 are some monads for which a monad morphism 
\begin_inset Formula $\phi:M^{A}\leadsto N^{A}$
\end_inset

 exists.
 We may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 to transform 
\begin_inset Formula $M^{A}$
\end_inset

 into 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 and to transform 
\begin_inset Formula $N^{A}$
\end_inset

 into 
\begin_inset Formula $T_{L}^{N,A}$
\end_inset

.
 But we can also obtain a monad morphism 
\begin_inset Formula $T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

 as 
\begin_inset Formula $\text{frun}_{L}\left(\phi\right)$
\end_inset

.
 Those monad morphisms can be drawn as a square diagram.
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.6pc}\xyScaleX{2.1pc}M^{A}\ar[d]\sb(0.45){\phi}\ar[r]\sp(0.5){\text{flift}} & T_{L}^{M,A}\ar[d]\sp(0.45){\text{frun}_{L}(\phi)}\\
N^{A}\ar[r]\sp(0.5){\text{flift}} & T_{L}^{N,A}
}
\]

\end_inset

The diagram will commute if the following 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law!of 
\family typewriter
flift
\end_layout

\end_inset


\series bold
monadic naturality law
\series default
 holds:
\begin_inset Formula 
\begin{equation}
\text{flift}_{L}^{M,A}\bef\text{frun}_{L}(\phi^{:M^{A}\rightarrow N^{A}})=\phi\bef\text{flift}_{L}^{N,A}\quad.\label{eq:monadic-naturality-law-of-flift}
\end{equation}

\end_inset

Is it reasonable to require this law? To get some intuition, consider three
 special cases where the law is simplified, namely 
\begin_inset Formula $M=\text{Id}$
\end_inset

, 
\begin_inset Formula $N=\text{Id}$
\end_inset

, or 
\begin_inset Formula $M=N$
\end_inset

.
 
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $M=\text{Id}$
\end_inset

, we must choose 
\begin_inset Formula $\phi$
\end_inset

 as the monad morphism 
\begin_inset Formula $\phi\triangleq\text{pu}_{N}:\text{Id}\leadsto N$
\end_inset

.
 (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that there are no other monad morphisms between 
\begin_inset Formula $\text{Id}$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.) The monad stack 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 is simplified to 
\begin_inset Formula $T_{L}^{\text{Id}}\cong L$
\end_inset

.
 The function 
\begin_inset Formula $\text{flift}_{L}^{M,A}$
\end_inset

 has type signature 
\begin_inset Formula $\text{Id}^{A}\rightarrow T_{L}^{M,A}$
\end_inset

, which is the same as 
\begin_inset Formula $A\rightarrow L^{A}$
\end_inset

.
 For a general monad 
\begin_inset Formula $L$
\end_inset

, there is no other function of this type except 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

.
 So, 
\begin_inset Formula $\text{flift}_{L}^{\text{Id}}$
\end_inset

 must be equal to 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

.
 The monad morphism 
\begin_inset Formula $\text{frun}_{L}(\phi)$
\end_inset

 has type signature 
\begin_inset Formula $T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

, which is the same as 
\begin_inset Formula $L\leadsto T_{L}^{N}$
\end_inset

, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

.
 Since the monad 
\begin_inset Formula $N$
\end_inset

 is arbitrary, it is reasonable to assume that:
\begin_inset Formula 
\[
\text{frun}_{L}(\phi)=\text{frun}_{L}(\text{pu}_{N})=\text{blift}_{L}^{N}\quad.
\]

\end_inset

In this way, the monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-flift"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives the equation:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\text{blift}_{L}^{N}=\text{pu}_{N}\bef\text{flift}_{L}^{N}\quad.
\]

\end_inset

This equation holds due to the identity laws of lifts:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\text{blift}_{L}^{N}=\text{pu}_{T_{L}^{N}}\quad,\quad\quad\text{pu}_{N}\bef\text{flift}_{L}^{N}=\text{pu}_{T_{L}^{N}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
When 
\begin_inset Formula $N=\text{Id}$
\end_inset

, we choose 
\begin_inset Formula $\phi=\theta_{M}$
\end_inset

, assuming that 
\begin_inset Formula $M$
\end_inset

 has a runner.
 The monad stack 
\begin_inset Formula $T_{L}^{N}$
\end_inset

 is simplified to 
\begin_inset Formula $T_{L}^{\text{Id}}\cong L$
\end_inset

.
 The function 
\begin_inset Formula $\text{flift}_{L}^{N}$
\end_inset

 has type signature 
\begin_inset Formula $A\rightarrow L^{A}$
\end_inset

 and is equal to 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

.
 So, we get:
\begin_inset Formula 
\[
\text{flift}_{L}^{M}\bef\text{frun}_{L}(\theta_{M})=\theta_{M}\bef\text{pu}_{L}\quad.
\]

\end_inset

This is the 
\begin_inset Quotes eld
\end_inset

purity
\begin_inset Quotes erd
\end_inset

 law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 that we derived earlier.
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $M=N$
\end_inset

, we may choose 
\begin_inset Formula $\phi=\text{id}$
\end_inset

.
 The monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-flift"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes:
\begin_inset Formula 
\[
\text{flift}\bef\text{frun}_{L}(\text{id})=\text{flift}\quad.
\]

\end_inset

This equation holds as long as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 satisfies the identity law of monad morphisms (
\begin_inset Formula $\text{frun}_{L}(\text{id})=\text{id}$
\end_inset

).
\end_layout

\begin_layout Standard
So, we found that the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-flift"
plural "false"
caps "false"
noprefix "false"

\end_inset

) agrees with previously derived laws and, moreover, covers one of the laws
 of runners.
 The interpretation of the monadic naturality law becomes clear from viewing
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 as a lifting (
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) corresponding to the functor 
\begin_inset Formula $T_{L}$
\end_inset

.
 Denoting that lifting temporarily by 
\begin_inset Formula $^{\uparrow T_{L}}$
\end_inset

, we rewrite the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-flift"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as:
\begin_inset Formula 
\[
\text{flift}\bef\phi^{\uparrow T_{L}}=\phi\bef\text{flift}\quad.
\]

\end_inset

This is a standard form of a naturality law if we view 
\begin_inset Formula $\text{flift}^{M}:M\leadsto T_{L}^{M}$
\end_inset

 as a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
natural transformation!in the category of monads
\end_layout

\end_inset

natural transformation between the identity functor 
\begin_inset Formula $\text{Id}^{M}\triangleq M$
\end_inset

 (in the category of monads) to the functor 
\begin_inset Formula $T_{L}^{\bullet}$
\end_inset

, the monad transformer functor with the base monad 
\begin_inset Formula $L$
\end_inset

.
 The law expresses the property that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 works in the same way for all foreign monads 
\begin_inset Formula $M$
\end_inset

.
 We call it a 
\begin_inset Quotes eld
\end_inset


\series bold
monadic
\series default

\begin_inset Quotes erd
\end_inset

 naturality law
\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law!of foreign runner (
\family typewriter
frun
\family default
)
\end_layout

\end_inset

 because 
\begin_inset Formula $\text{flift}_{L}^{M,A}:M^{A}\rightarrow T_{L}^{M,A}$
\end_inset

 also satisfies the ordinary naturality law with respect to the type parameter
 
\begin_inset Formula $A$
\end_inset

, for a fixed monad 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
What other runners have monadic naturality properties? Suppose that the
 monad 
\begin_inset Formula $L$
\end_inset

's transformer has a base runner, 
\begin_inset Formula $\text{brun}_{L}:T_{L}^{M}\leadsto M$
\end_inset

.
 Viewed in the category of monads, this function is a natural transformation
 between the functor 
\begin_inset Formula $T_{L}^{\bullet}$
\end_inset

 and the identity functor (going in the opposite way compared with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

).
 The corresponding 
\series bold
monadic naturality law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law!of base runner (
\family typewriter
brun
\family default
)
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{brun}_{L}^{M}\bef\phi^{:M\leadsto N}=\text{frun}_{L}(\phi)\bef\text{brun}_{L}^{N}\quad.
\]

\end_inset

To see whether it is reasonable to assume this law, let us derive some consequen
ces of this law by making specific choices of 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
\end_layout

\begin_layout Standard
With 
\begin_inset Formula $M=\text{Id}$
\end_inset

, the function 
\begin_inset Formula $\phi$
\end_inset

 must be 
\begin_inset Formula $\phi=\text{pu}_{N}$
\end_inset

 (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer"
plural "false"
caps "false"
noprefix "false"

\end_inset

), while 
\begin_inset Formula $\text{frun}_{L}(\phi):T_{L}^{\text{Id}}\leadsto T_{L}^{N}$
\end_inset

 is equal to the base lift function (
\begin_inset Formula $\text{blift}_{L}^{N}$
\end_inset

).
 We also have 
\begin_inset Formula $\text{brun}_{L}^{\text{Id}}:T_{L}^{\text{Id}}\leadsto\text{Id}$
\end_inset

, so this function is equal to 
\begin_inset Formula $L$
\end_inset

's runner (
\begin_inset Formula $\text{brun}_{L}^{\text{Id}}=\theta_{L}$
\end_inset

).
 The resulting equation is the purity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\theta_{L}\bef\text{pu}_{N}=\text{blift}_{L}^{N}\bef\text{brun}_{L}^{N}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $N=\text{Id}$
\end_inset

, the function 
\begin_inset Formula $\phi$
\end_inset

 must be a runner (
\begin_inset Formula $\theta_{M}$
\end_inset

), while 
\begin_inset Formula $\text{brun}_{L}^{\text{Id}}=\theta_{L}$
\end_inset

 as before.
 We get:
\begin_inset Formula 
\[
\text{brun}_{L}^{M}\bef\theta_{M}=\text{frun}_{L}(\theta_{M})\bef\theta_{L}\quad.
\]

\end_inset

This is the commutativity law of runners we obtained earlier.
\end_layout

\begin_layout Standard
So, the monadic naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 covers two of the previously formulated laws.
\end_layout

\begin_layout Standard
The monadic naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

's composition law:
\begin_inset Foot
status open

\begin_layout Plain Layout
This is similar to the fact that the naturality law and the composition
 law are the same for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{frun}_{L}(\phi^{:M\leadsto N})\bef\chi^{\uparrow T_{L}}=\text{frun}_{L}(\phi)\bef\text{frun}_{L}(\chi)=\text{frun}_{L}(\phi\bef\chi)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Since the category of monad stacks is a sub-category of the category of
 monads, 
\begin_inset Formula $T_{L}$
\end_inset

 is an 
\emph on
endofunctor
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
endofunctor!in the category of monads
\end_layout

\end_inset

 in the category of monads, such that a natural transformation 
\begin_inset Formula $\text{flift}_{L}:\text{Id}^{M}\leadsto T_{L}^{M}$
\end_inset

 exists (in the sense of the category of monads, i.e., parametric in the monad
 
\begin_inset Formula $M$
\end_inset

 and obeying the monad morphism laws).
 
\end_layout

\begin_layout Standard
Endofunctors 
\begin_inset Formula $F^{A}$
\end_inset

 having a natural transformation 
\begin_inset Formula $\text{pu}_{F}:\text{Id}^{A}\rightarrow F^{A}$
\end_inset

 are 
\begin_inset Quotes eld
\end_inset

pointed
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
pointed functor!in the category of monads
\end_layout

\end_inset

; those with a natural transformation 
\begin_inset Formula $\text{ex}_{F}:F^{A}\rightarrow\text{Id}^{A}$
\end_inset

 are 
\begin_inset Quotes eld
\end_inset

co-pointed
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
co-pointed functor!in the category of monads
\end_layout

\end_inset

.
 Naturality forces the nondegeneracy law 
\begin_inset Formula $\text{pu}_{F}\bef\text{ex}_{F}=\text{id}$
\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Co-pointed-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We find that 
\begin_inset Formula $T_{L}$
\end_inset

 is a pointed endofunctor in the category of monads.
 If the transformer 
\begin_inset Formula $T_{L}$
\end_inset

 has a base runner (
\begin_inset Formula $\text{brun}_{L}:T_{L}^{M}\leadsto\text{Id}^{M}$
\end_inset

) then 
\begin_inset Formula $T_{L}$
\end_inset

 will be also co-pointed.
\end_layout

\begin_layout Standard
It is remarkable that all the laws of monad transformers can be derived
 from a single (but more abstract) definition: a monad transformer 
\begin_inset Formula $T$
\end_inset

 is 
\emph on
just a pointed and (perhaps) co-pointed endofunctor in the category of monads
\emph default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\emph on
What's the big deal?
\emph default

\begin_inset Quotes erd
\end_inset

 as one
\begin_inset CommandInset label
LatexCommand label
name "fn:Whats-the-big-deal-monad-transformers"

\end_inset

 would joke
\begin_inset Index idx
status open

\begin_layout Plain Layout
jokes
\end_layout

\end_inset

 similarly to the well-known monad joke in footnote
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fn:A-monad-is-a-monoid-in-category-of-endofunctors-big-deal"
plural "false"
caps "false"
noprefix "false"

\end_inset

 on page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "fn:A-monad-is-a-monoid-in-category-of-endofunctors-big-deal"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\end_inset

 Such a endofunctor 
\begin_inset Formula $T$
\end_inset

 maps monads 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

, etc., to monads 
\begin_inset Formula $T^{M}$
\end_inset

, 
\begin_inset Formula $T^{N}$
\end_inset

, etc.
 
\end_layout

\begin_layout Standard
Suppose we are given such a 
\begin_inset Formula $T$
\end_inset

 not knowing that it is a monad transformer for some base monad.
 Then we can recover 
\begin_inset Formula $T$
\end_inset

's base monad 
\begin_inset Formula $L$
\end_inset

 as the image of the identity monad:
\begin_inset Formula 
\[
L\triangleq T^{\text{Id}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The definition of 
\begin_inset Formula $T$
\end_inset

 already specifies functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 as the natural transformations:
\begin_inset Formula 
\[
\text{flift}_{T}^{M}:\text{Id}^{M}\leadsto T^{M}\quad,\quad\quad\text{brun}_{T}^{M}:T^{M}\leadsto\text{Id}^{M}\quad,\quad\quad\text{frun}_{T}^{M,N}:(M\leadsto N)\rightarrow T^{M}\leadsto T^{N}\quad.
\]

\end_inset

The functor laws and the monadic naturality laws for those transformations
 will then enforce the 18 laws of monad transformers.
 In this way, a single definition expresses all monad transformer laws.
\end_layout

\begin_layout Standard
This definition also explains why monad transformers compose while monads
 do not.
 Monad transformers compose because they are pointed endofunctors (in the
 category of monads).
 The composition of two or more pointed endofunctors (in any category) is
 again a pointed endofunctor.
\end_layout

\begin_layout Paragraph
Open question
\family typewriter
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "par:Open-question-monad-id-trans"

\end_inset

Does the nondegeneracy law 
\begin_inset Formula $\text{flift}_{T}\bef\text{brun}_{T}=\text{id}$
\end_inset

 follow from the monadic naturality of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 or other properties? This book does not have a proof.
 The composition (
\begin_inset Formula $\text{flift}_{T}\bef\text{brun}_{T}$
\end_inset

) is a natural transformation of type 
\begin_inset Formula $\text{Id}^{\bullet}\leadsto\text{Id}^{\bullet}$
\end_inset

; but it is a natural transformation 
\emph on
in the category of monads
\emph default
.
 One would need to prove that there are no non-identity natural transformations
 between identity functors in the category of monads.
\end_layout

\begin_layout Standard
A natural transformation of type 
\begin_inset Formula $\text{Id}^{\bullet}\leadsto\text{Id}^{\bullet}$
\end_inset

 means, by definition, a family of monad morphisms 
\begin_inset Formula $\varepsilon^{M}:M\leadsto M$
\end_inset

 that work the same way for every monad 
\begin_inset Formula $M$
\end_inset

.
 One such morphism is the identity function, 
\begin_inset Formula $\varepsilon=\text{id}$
\end_inset

.
 However, it is not clear (Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-identity-natural-monad-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

) whether there exist non-identity monad morphisms 
\begin_inset Formula $M\leadsto M$
\end_inset

 that work the same way for every monad 
\begin_inset Formula $M$
\end_inset

.
 For instance, Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows a failed attempt to define such a monad morphism.
\end_layout

\begin_layout Standard
Since we have not shown that the nondegeneracy law for base runners automaticall
y follows from monadic naturality, we will need to verify that law separately
 whenever the base runner exists.
\end_layout

\begin_layout Subsection
Summary of the laws of monad transformers
\begin_inset CommandInset label
LatexCommand label
name "subsec:Laws-of-monad-transformers"

\end_inset


\end_layout

\begin_layout Standard
We have found that a 
\series bold
monad transformer
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!full definition
\end_layout

\end_inset

 
\series bold
for a base monad
\series default
 
\begin_inset Formula $L$
\end_inset

 is a type constructor 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 with a type parameter 
\begin_inset Formula $A$
\end_inset

 and a monad parameter 
\begin_inset Formula $M$
\end_inset

, such that the following laws hold:
\end_layout

\begin_layout Enumerate

\series bold
Monad laws
\series default
: 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 is a lawful monad for any monad 
\begin_inset Formula $M$
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!monad laws
\end_layout

\end_inset

 (The functor 
\begin_inset Formula $T_{L}^{M,\bullet}$
\end_inset

 has methods 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 that satisfy the monad laws.)
\end_layout

\begin_layout Enumerate

\series bold
Identity laws
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!identity laws
\end_layout

\end_inset

 
\begin_inset Formula $T_{L}^{\text{Id},\bullet}\cong L^{\bullet}$
\end_inset

 via a monad isomorphism, where 
\begin_inset Formula $\text{Id}$
\end_inset

 is the identity monad (
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

).
\end_layout

\begin_layout Enumerate

\series bold
Lifting laws
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!lifting law
\end_layout

\end_inset

 There is a function 
\begin_inset Formula $\text{flift}_{L}:M^{A}\rightarrow T_{L}^{M,A}$
\end_inset

 (in a shorter notation, 
\begin_inset Formula $\text{flift}_{L}:M\leadsto T_{L}^{M}$
\end_inset

) that works parametrically in the monad 
\begin_inset Formula $M$
\end_inset

 and obeys the laws of monad morphisms.
\end_layout

\begin_layout Enumerate

\series bold
Runner laws
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!runner laws
\end_layout

\end_inset

 There is a 
\series bold
foreign runner
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
This function is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hoist
\end_layout

\end_inset

 in Haskell standard libraries and in 
\family typewriter
scalaz
\family default
.
\end_layout

\end_inset

 
\begin_inset Formula $\text{frun}\left(\phi\right)$
\end_inset

 such that for any monads 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 and any monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

, the function 
\begin_inset Formula $\text{frun}\left(\phi\right):T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

 is a monad morphism.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 lifts monad morphisms from 
\begin_inset Formula $M\leadsto N$
\end_inset

 to 
\begin_inset Formula $T_{L}^{M}\leadsto T_{L}^{N}$
\end_inset

 and must satisfy the corresponding 
\series bold
functor laws
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!functor laws of runner
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{frun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{frun}\left(\phi\right)\bef\text{frun}\left(\chi\right)=\text{frun}\left(\phi\bef\chi\right)\quad.
\]

\end_inset

It follows from the identity law 
\begin_inset Formula $T_{L}^{\text{Id}}\cong L$
\end_inset

 that the base monad 
\begin_inset Formula $L$
\end_inset

 can be lifted into 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 Namely, by computing 
\begin_inset Formula $\text{frun}\left(\phi\right)$
\end_inset

 with 
\begin_inset Formula $\phi\triangleq\text{pu}_{M}:\text{Id}\leadsto M$
\end_inset

, we obtain a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!base lift
\end_layout

\end_inset


\series bold
base lift
\series default
 function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

):
\begin_inset Formula 
\[
\text{blift}:T_{L}^{\text{Id}}\leadsto T_{L}^{M}\cong L\leadsto T_{L}^{M}\quad,\quad\quad\text{blift}\triangleq\text{frun}\,(\text{pu}_{M})\quad.
\]

\end_inset

The base lift and the foreign runner automatically satisfy a 
\series bold
nondegeneracy law
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
nondegeneracy law!of base lift (
\family typewriter
blift
\family default
)
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{blift}\bef\text{frun}\,(\phi^{:M\leadsto\text{Id}})=\text{id}\quad,
\]

\end_inset

for any monad morphism 
\begin_inset Formula $\phi:M\leadsto\text{Id}$
\end_inset

, because the left-hand side equals 
\begin_inset Formula $\text{frun}\,(\text{pu}_{M}\bef\phi)$
\end_inset

, and the composition law for monad morphisms gives 
\begin_inset Formula $\text{pu}_{M}\bef\phi=\text{pu}_{\text{Id}}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Base runner laws
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!base runner laws
\end_layout

\end_inset

 There is a 
\series bold
base runner
\series default
, a monad morphism 
\begin_inset Formula $\text{brun}_{L}^{M}:T_{L}^{M}\leadsto M$
\end_inset

 defined parametrically in the monad 
\begin_inset Formula $M$
\end_inset

.
 The base runner must also satisfy a 
\series bold
nondegeneracy law
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
nondegeneracy law!of base runners (
\family typewriter
brun
\family default
)
\end_layout

\end_inset

 
\begin_inset Formula 
\[
\text{flift}_{L}^{M}\bef\text{brun}_{L}^{M}=\text{id}\quad.
\]

\end_inset

Since monad transformers are specific to their base monad and do not support
 a transition to another base monad, there are no functor laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

, unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

.
 Some monads have a general base runner, 
\begin_inset Formula $\text{brun}\,(\theta_{L})$
\end_inset

, parameterized by an arbitrary runner 
\begin_inset Formula $\theta_{L}:L\leadsto\text{Id}$
\end_inset

.
 If so, the function 
\begin_inset Formula $\text{brun}\,(\theta_{L})$
\end_inset

 must obey the base runner laws for any fixed 
\begin_inset Formula $\theta_{L}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Monadic naturality laws
\series default
: 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law
\end_layout

\end_inset

 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 must satisfy the monadic naturality law with respect to the monad parameter
 
\begin_inset Formula $M$
\end_inset

.
 For an arbitrary monad morphism 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{monadic naturality law of }\text{flift}:\quad & \text{flift}^{M}\bef\text{frun}\,(\phi^{:M\leadsto N})=\phi^{:M\leadsto N}\bef\text{flift}^{N}\quad,\\
\text{monadic naturality law of }\text{brun}:\quad & \text{brun}^{M}\bef\phi^{:M\leadsto N}=\text{frun}\,(\phi^{:M\leadsto N})\bef\text{brun}^{N}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In this chapter, we will prove a stronger monadic naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 that requires 
\begin_inset Formula $\phi:M^{A}\rightarrow N^{A}$
\end_inset

 to be merely an arbitrary natural transformation, not necessarily a monad
 morphism.
\end_layout

\begin_layout Standard
In total, we found 18 laws for monad transformers.
 Are all these laws necessary? 
\end_layout

\begin_layout Standard
The main use of the laws is to verify correctness of the code.
 The next section shows some examples of incorrect implementations of monad
 transformers and indicates the laws that are violated.
\end_layout

\begin_layout Subsection
Examples of invalid monad transformers
\end_layout

\begin_layout Standard
The laws of monad transformers guarantee that the transformed monad is able
 to represent, without loss of information, the operations of the base monad
 as well as the operations of the foreign monad.
 If some of these laws are omitted, we risk accepting a transformer that
 has all the methods with the required type signatures but does not work
 correctly.
\end_layout

\begin_layout Standard
The simplest example of an invalid monad transformer is obtained by defining
 the new monad to be the unit monad (
\begin_inset Formula $T_{L}^{M,A}\triangleq\bbnum 1$
\end_inset

) for any monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 This 
\begin_inset Quotes eld
\end_inset

fake transformer
\begin_inset Quotes erd
\end_inset

 cannot possibly describe the effects of 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, because the methods of the unit monad discard 
\emph on
all
\emph default
 information and return 
\begin_inset Formula $1$
\end_inset

.
 However, the type constructor 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 has the required methods 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

, 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

, and 
\begin_inset Formula $\text{frun}_{L}$
\end_inset

 (they are constant functions returning 
\begin_inset Formula $1$
\end_inset

).
 All these functions are automatically monad morphisms, since a function
 from any monad to the unit monad is always a monad morphism.
 So, the 
\begin_inset Quotes eld
\end_inset

fake transformer
\begin_inset Quotes erd
\end_inset

 actually satisfies many of the monad transformer laws! However, the identity
 law 
\begin_inset Formula $T_{L}^{\text{Id}}\cong L$
\end_inset

 is violated since 
\begin_inset Formula $T_{L}^{\text{Id}}=\bbnum 1\not\cong L$
\end_inset

.
 For this reason, 
\begin_inset Formula $T_{L}^{M,A}\triangleq\bbnum 1$
\end_inset

 is not a lawful monad transformer.
\end_layout

\begin_layout Standard
Other examples of incorrect 
\begin_inset Quotes eld
\end_inset

transformers
\begin_inset Quotes erd
\end_inset

 violating some of the laws are 
\begin_inset Formula $T_{L}^{M}\triangleq L$
\end_inset

 (no lifting law) and 
\begin_inset Formula $T_{L}^{M}\triangleq M$
\end_inset

 (no identity law).
\end_layout

\begin_layout Standard
These examples demonstrate the importance of the monad transformer laws.
 A wrong implementation of a 
\begin_inset Quotes eld
\end_inset

transformer
\begin_inset Quotes erd
\end_inset

 could fail to represent properly the effects of the monads, even though
 the transformer's methods with the correct type signatures are provided.
 The only way for us to detect the problem is to establish a violation of
 some of the required laws.
\end_layout

\begin_layout Standard
In these cases, it is intuitively clear that the transformer definitions
 are incorrect because the information about either 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 is missing in the type 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 A valid definition of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 must be a type constructor that somehow combines the type constructors
 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 Many such definitions are possible, but few will satisfy the monad transformer
 laws, as the next subsection shows.
\end_layout

\begin_layout Subsection
Examples of failure to define a general monad transformer
\begin_inset CommandInset label
LatexCommand label
name "subsec:Examples-of-failure-of-generic-monad-transformer"

\end_inset


\end_layout

\begin_layout Standard
No type construction is known that works in the same way for all monad pairs
 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

 and correctly combines the effects of both monads (i.e., satisfies the laws
 of monad transformers).
 We will now consider a few general ways of combining the type constructors
 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 In all cases, we will find that some monad transformer laws are violated.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Simple ways of combining two type constructors 
\begin_inset Formula $L^{\bullet}$
\end_inset

 and 
\begin_inset Formula $M^{\bullet}$
\end_inset

 are functor composition (
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

 or 
\begin_inset Formula $M^{L^{\bullet}}$
\end_inset

), product (
\begin_inset Formula $L^{\bullet}\times M^{\bullet}$
\end_inset

), and co-product (
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Functor composition
\end_layout

\begin_layout Standard
As we have seen, the functor composition works only for certain monads and
 only in a certain order, so it cannot serve as a general monad transformer.
 A simple counterexample is 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq A\times A$
\end_inset

 where 
\begin_inset Formula $M^{L^{A}}=\left(\bbnum 1+A\right)\times\left(\bbnum 1+A\right)$
\end_inset

 is a monad but 
\begin_inset Formula $L^{M^{A}}=\bbnum 1+A\times A$
\end_inset

 is not (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-7-not-a-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Another counterexample is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad, 
\begin_inset Formula $\text{State}_{S}^{A}\triangleq S\rightarrow S\times A$
\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad does not compose with arbitrary monads 
\begin_inset Formula $M$
\end_inset

 in either order.
 For instance, 
\begin_inset Formula $\bbnum 1+\text{State}_{S}^{A}$
\end_inset

 and 
\begin_inset Formula $\text{State}_{S}^{Z\rightarrow A}$
\end_inset

 are not monads (see Examples
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-state-monad-composition-fails-with-option"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-state-monad-composition-fails-with-reader"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Paragraph
Functor product
\end_layout

\begin_layout Standard
We know from Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Semimonads-and-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the functor product 
\begin_inset Formula $M_{1}^{A}\times M_{2}^{A}$
\end_inset

 is a monad when 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are themselves monads.
 However, the product 
\begin_inset Formula $M_{1}^{A}\times M_{2}^{A}$
\end_inset

 describes two separate computations with two separate effects.
 Instead, we need a single computation with a combined effect.
 Formally, we find that there is no naturally defined 
\begin_inset Formula $\text{flift}:M^{A}\rightarrow L^{A}\times M^{A}$
\end_inset

 because we cannot create values of type 
\begin_inset Formula $L^{A}$
\end_inset

 out of values of type 
\begin_inset Formula $M^{A}$
\end_inset

 when monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are arbitrary.
\end_layout

\begin_layout Paragraph
Functor co-product
\end_layout

\begin_layout Standard
The co-product 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

 is in general not a monad when 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are arbitrary monads.
 A counterexample is found by using two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monads, 
\begin_inset Formula $L^{A}\triangleq P\rightarrow A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq Q\rightarrow A$
\end_inset

: the co-product 
\begin_inset Formula $\left(P\rightarrow A\right)+\left(Q\rightarrow A\right)$
\end_inset

 is not a monad (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-6"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 But even when 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

 is a monad, the identity law is violated: with 
\begin_inset Formula $M=\text{Id}$
\end_inset

, the monad 
\begin_inset Formula $L+\text{Id}$
\end_inset

 is not equivalent to 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Paragraph
Using the free monad
\end_layout

\begin_layout Standard
The functor composition 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

 and the co-product 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

 may not always be monads, but they are always functors.
 We can make monads out of those functors via the free monad construction.
 We obtain 
\begin_inset Formula $\text{Free}^{L^{M^{\bullet}}}$
\end_inset

, the free monad on 
\begin_inset Formula $L^{M^{\bullet}}$
\end_inset

, and 
\begin_inset Formula $\text{Free}^{L^{\bullet}+M^{\bullet}}$
\end_inset

, the free monad on 
\begin_inset Formula $L^{\bullet}+M^{\bullet}$
\end_inset

.
 Many laws of the monad transformers are satisfied by these constructions.
 However, the identity laws fail:
\begin_inset Formula 
\[
\text{Free}^{L^{\text{Id}^{\bullet}}}\cong\text{Free}^{L^{\bullet}}\not\cong L\quad,\quad\quad\text{Free}^{L^{\bullet}+\text{Id}^{\bullet}}\not\cong L\quad.
\]

\end_inset

The lifting laws are also violated because 
\begin_inset Formula $\text{flift}:M^{A}\rightarrow\text{Free}^{L^{\bullet}+M^{\bullet},A}$
\end_inset

 is not a monad morphism (it maps 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 into a non-pure value of the free monad).
 Nevertheless, these constructions are not useless.
 Once we run the free monad into a concrete (non-free) monad, we will no
 longer observe any violations of those laws, as long as we only look at
 the values in the resulting (non-free) monad.
\end_layout

\begin_layout Paragraph
\begin_inset Quotes eld
\end_inset

Day convolution
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The construction called 
\series bold
Day convolution
\begin_inset Index idx
status open

\begin_layout Plain Layout
Day convolution
\end_layout

\end_inset


\series default
 defines a new functor 
\begin_inset Formula $L\star M$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
\left(L\star M\right)^{A}\triangleq\exists P.\,\exists Q.\,\left(P\times Q\rightarrow A\right)\times L^{P}\times M^{Q}\quad.\label{eq:definition-of-monoidal-convolution}
\end{equation}

\end_inset

This formula can be seen as a modified application of the co-Yoneda identities:
\begin_inset Formula 
\[
L^{A}\cong\exists P.\,L^{P}\times\left(P\rightarrow A\right)\quad,\quad\quad M^{A}\cong\exists Q.\,M^{Q}\times\left(Q\rightarrow A\right)\quad.
\]

\end_inset

The functor product 
\begin_inset Formula $L^{A}\times M^{A}$
\end_inset

 is equivalent to 
\begin_inset Formula $\exists P.\,\exists Q.\,L^{P}\times M^{Q}\times\left(P+Q\rightarrow A\right)$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & L^{A}\times M^{A}\nonumber \\
\text{co-Yoneda identities for }L^{A}\text{ and }M^{A}:\quad & \cong\exists P.\,L^{P}\times\gunderline{\left(P\rightarrow A\right)}\times\exists Q.\,M^{Q}\times\gunderline{\left(Q\rightarrow A\right)}\nonumber \\
\text{equivalence in Eq.~(\ref{eq:equivalence-pq-a-for-monoidal-convolution})}:\quad & \cong\exists P.\,\exists Q.\,L^{P}\times M^{Q}\times\left(P+Q\rightarrow A\right)\label{eq:product-l-m-for-monoidal-convolution}
\end{align}

\end_inset

where we used the type equivalence:
\begin_inset Formula 
\begin{equation}
\left(P\rightarrow A\right)\times\left(Q\rightarrow A\right)\cong P+Q\rightarrow A\quad.\label{eq:equivalence-pq-a-for-monoidal-convolution}
\end{equation}

\end_inset

If we (arbitrarily) replace 
\begin_inset Formula $P+Q$
\end_inset

 by 
\begin_inset Formula $P\times Q$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:product-l-m-for-monoidal-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we will obtain Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-monoidal-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The Day convolution is associative
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Day_convolution"
literal "false"

\end_inset


\end_layout

\end_inset

 and always produces a functor since Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-monoidal-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is covariant in 
\begin_inset Formula $A$
\end_inset

.
 An example where the Day convolution fails to produce a monad transformer
 is 
\begin_inset Formula $L^{A}\triangleq1+A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq R\rightarrow A$
\end_inset

.
 We can compute the functor 
\begin_inset Formula $L\star M$
\end_inset

 explicitly:
\begin_inset Formula 
\begin{align*}
 & \left(L\star M\right)^{A}\\
\text{definitions of }L,M,\star:\quad & \cong\exists P.\,\exists Q.\,\gunderline{\left(P\times Q\rightarrow A\right)}\times\left(\bbnum 1+P\right)\times\left(R\rightarrow Q\right)\\
\text{curry the arguments, move a quantifier}:\quad & \cong\exists P.\left(\bbnum 1+P\right)\times\gunderline{\exists Q.\left(Q\rightarrow P\rightarrow A\right)\times\left(R\rightarrow Q\right)}\\
\text{co-Yoneda identity with }\exists Q:\quad & \cong\exists P.\left(\bbnum 1+P\right)\times\left(\gunderline{R\rightarrow P}\rightarrow A\right)\\
\text{swap curried arguments}:\quad & \cong\exists P.\left(\bbnum 1+P\right)\times\left(P\rightarrow R\rightarrow A\right)\\
\text{co-Yoneda identity with }\exists P:\quad & \cong\bbnum 1+\left(R\rightarrow A\right)\quad.
\end{align*}

\end_inset

This functor is not a monad (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-7-not-a-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

), so the transformer's monad law fails.
\end_layout

\begin_layout Standard
The Day convolution works because the type-level operations 
\begin_inset Formula $P+Q$
\end_inset

 and 
\begin_inset Formula $P\times Q$
\end_inset

 are both monoidal, in a suitable sense.
 We could generalize the Day convolution to use another monoidal type-level
 operation, such as 
\begin_inset Formula $P+Q+Z\times P\times Q$
\end_inset

 (where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type), instead of 
\begin_inset Formula $P\times Q$
\end_inset

.
 The result is a different 
\begin_inset Quotes eld
\end_inset

monoidal convolution
\begin_inset Quotes erd
\end_inset

 (
\begin_inset Formula $\star_{Z}$
\end_inset

):
\begin_inset Formula 
\[
\left(L\star_{Z}M\right)^{A}\triangleq\exists P.\,\exists Q.\,\left(P+Q+Z\times P\times Q\rightarrow A\right)\times L^{P}\times M^{Q}\quad.
\]

\end_inset

But this construction also fails to produce a lawful monad transformer.
\end_layout

\begin_layout Paragraph
Universally quantified reader
\end_layout

\begin_layout Standard
The following type appears to be a general monad transformer:
\begin_inset Formula 
\[
T_{L}^{M,A}\triangleq\big(\forall B.\,M^{B}\rightarrow L^{B}\big)_{\text{monad morphism}}\rightarrow L^{A}\quad.
\]

\end_inset

Here, it is required that the argument of type 
\begin_inset Formula $R\triangleq\forall B.\,M^{B}\rightarrow L^{B}$
\end_inset

 must be a lawful monad morphism between the base monad 
\begin_inset Formula $L$
\end_inset

 and the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The type 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 has the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

-like form 
\begin_inset Formula $R\rightarrow L^{A}$
\end_inset

 where 
\begin_inset Formula $R$
\end_inset

 is a universally quantified type that depends on 
\begin_inset Formula $M$
\end_inset

.
 One finds that 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 is a monad with the monad morphisms (lifts) 
\begin_inset Formula $M^{A}\rightarrow T_{L}^{M,A}$
\end_inset

 and 
\begin_inset Formula $L^{A}\rightarrow T_{L}^{M,A}$
\end_inset

.
 We have 
\begin_inset Formula $T_{L}^{\text{Id},A}\cong L$
\end_inset

, so the transformer identity law holds.
 A foreign runner can be implemented as well (but not a base runner).
 The problem with 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 is that for some 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 the type 
\begin_inset Formula $R=\forall B.\,M^{B}\rightarrow L^{B}$
\end_inset

 is 
\emph on
void
\emph default
 (for example, with 
\begin_inset Formula $M^{A}\triangleq\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $L^{A}\triangleq A$
\end_inset

).
 In that case, 
\begin_inset Formula $T_{L}^{M,A}\cong\bbnum 0\rightarrow L^{A}\cong\bbnum 1$
\end_inset

, which is not a useful transformer.
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Using a codensity monad
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!codensity monad
\end_layout

\end_inset


\series bold
codensity monad
\series default
 on a type constructor 
\begin_inset Formula $K$
\end_inset

 is defined by:
\begin_inset Formula 
\[
\text{Cod}^{K,A}\triangleq\forall B.\,(A\rightarrow K^{B})\rightarrow K^{B}
\]

\end_inset

Although 
\begin_inset Formula $\text{Cod}^{K,A}$
\end_inset

 is a monad even when 
\begin_inset Formula $K$
\end_inset

 is not, the codensity construction does not give usable monad transformers.
 Here are some failed attempts:
\end_layout

\begin_layout Standard

\series bold
(1)
\series default
 The codensity monad on 
\begin_inset Formula $L\circ M$
\end_inset

 yields the following type constructor:
\begin_inset Formula 
\[
F^{A}\triangleq\forall B.\,\big(A\rightarrow L^{M^{B}}\big)\rightarrow L^{M^{B}}\quad.
\]

\end_inset

It has no lift 
\begin_inset Formula $M^{A}\rightarrow F^{A}$
\end_inset

.
 Intuitively, the reason is that we can combine values of types 
\begin_inset Formula $M^{A}$
\end_inset

 and 
\begin_inset Formula $A\rightarrow L^{M^{B}}$
\end_inset

 only by using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to transform 
\begin_inset Formula $M^{A}$
\end_inset

 into 
\begin_inset Formula $M^{L^{M^{B}}}$
\end_inset

.
 We cannot exchange the layers of 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 when those monads are arbitrary, and so we cannot obtain a value of type
 
\begin_inset Formula $L^{M^{B}}$
\end_inset

.
 A simple counterexample is found with 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq Z\rightarrow A$
\end_inset

 for a fixed type 
\begin_inset Formula $Z$
\end_inset

.
 The type signature:
\begin_inset Formula 
\[
(Z\rightarrow A)\rightarrow(A\rightarrow\bbnum 1+(Z\rightarrow B))\rightarrow\bbnum 1+(Z\rightarrow B)
\]

\end_inset

can be implemented only as a function that returns a constant unit value
 (
\begin_inset Formula $1+\bbnum 0^{:Z\rightarrow B}$
\end_inset

), which loses information and violates the identity law of monad morphisms.
\end_layout

\begin_layout Standard

\series bold
(2)
\series default
 The composition of 
\begin_inset Formula $\text{Cod}^{L,\bullet}$
\end_inset

 and 
\begin_inset Formula $M^{\bullet}$
\end_inset

 yields the following type constructor:
\begin_inset Formula 
\[
F^{A}\triangleq\forall B.\,(M^{A}\rightarrow L^{B})\rightarrow L^{B}\quad.
\]

\end_inset

However, 
\begin_inset Formula $F^{A}$
\end_inset

 fails to be a monad for all 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 A counterexample is 
\begin_inset Formula $L^{A}\triangleq S\rightarrow A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq R\rightarrow A$
\end_inset

, for which the Yoneda identity gives:
\begin_inset Formula 
\begin{align*}
 & F^{A}=\forall B.\,(\gunderline{(R\rightarrow A)\rightarrow S}\rightarrow B)\rightarrow S\rightarrow B\cong\forall B.\,(\gunderline{(R\rightarrow A)\times S}\rightarrow B)\rightarrow L^{B}\\
 & \cong L^{(R\rightarrow A)\times S}=S\rightarrow\left(R\rightarrow A\right)\times S\quad.
\end{align*}

\end_inset

The last type constructor is not a monad: it is a composition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monads in the wrong order (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-state-monad-composition-fails-with-reader"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard

\series bold
(3)
\series default
 The 
\series bold
composed codensity monad
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!composed codensity monad
\end_layout

\end_inset

 is defined by:
\begin_inset Formula 
\[
\text{Cod}_{L}^{M,A}\triangleq\forall X.\,(A\rightarrow L^{X})\rightarrow L^{M^{X}}\quad.
\]

\end_inset

This type constructor can be viewed as the continuation monad transformer
 for the base monad 
\begin_inset Formula $\forall X.\,(A\rightarrow X)\rightarrow M^{X}\cong M^{A}$
\end_inset

 (this equivalence is a Yoneda identity).
 Although 
\begin_inset Formula $\text{Cod}_{L}^{M,A}$
\end_inset

 is a lawful monad, it cannot serve as a monad transformer because the foreign
 lift 
\begin_inset Formula $M^{A}\rightarrow\text{Cod}_{L}^{M,A}$
\end_inset

 does not exist for some 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-combined-codensity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Functor compositions of monads with their transformers
\end_layout

\begin_layout Standard
Suppose we are working with a base monad 
\begin_inset Formula $L$
\end_inset

 and a foreign monad 
\begin_inset Formula $M$
\end_inset

, and we have constructed the transformed monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 In this section, let us denote the transformed monad simply by 
\begin_inset Formula $T$
\end_inset

.
 
\end_layout

\begin_layout Standard
The main feature of a monad transformer is that the monad 
\begin_inset Formula $T$
\end_inset

 adequately describes the effects of both monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 at the same time.
 Suppose we have a deeply nested type constructor involving many functor
 layers of monads 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, and 
\begin_inset Formula $T$
\end_inset

 such as:
\begin_inset Formula 
\[
T^{M^{T^{L^{M^{L^{A}}}}}}=\left(T\circ M\circ T\circ L\circ M\circ L\right)^{A}\quad.
\]

\end_inset

It turns out that we can convert this type to just 
\begin_inset Formula $T^{A}$
\end_inset

 via a natural transformation:
\begin_inset Formula 
\[
\left(T\circ M\circ T\circ L\circ M\circ L\right)^{A}\rightarrow T^{A}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To achieve this, we first use the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 to convert each layer of 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 to a layer of 
\begin_inset Formula $T$
\end_inset

, lifting into functors as needed.
 The result will be a number of nested layers of 
\begin_inset Formula $T$
\end_inset

.
 Second, we use 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 as many times as needed to flatten all nested layers of 
\begin_inset Formula $T$
\end_inset

 into a single layer.
 The result will be a value of type 
\begin_inset Formula $T^{A}$
\end_inset

.
 Due to the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

, the result does not depend on the order in which the different layers
 are converted and flattened.
\end_layout

\begin_layout Subsection
Stacking two monads.
 Proofs
\begin_inset CommandInset label
LatexCommand label
name "subsec:Stacking-two-monads"

\end_inset


\end_layout

\begin_layout Standard
Suppose we know the transformers 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

 for some given monads 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 We can transform 
\begin_inset Formula $Q$
\end_inset

 with 
\begin_inset Formula $P$
\end_inset

 and obtain a monad 
\begin_inset Formula $R^{A}\triangleq T_{P}^{Q,A}$
\end_inset

.
 The monad transformer 
\begin_inset Formula $T_{R}$
\end_inset

 for the monad 
\begin_inset Formula $R$
\end_inset

 is defined to be the following monad stack (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Combining-more-than-monad-stacks"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
T_{R}^{M,A}\triangleq T_{P}^{T_{Q}^{M,\bullet},A}\triangleq(P\varangle Q\varangle M)^{A}\quad.
\]

\end_inset

Here, it is important that the monad 
\begin_inset Formula $T_{Q}^{M,\bullet}$
\end_inset

 is substituted into 
\begin_inset Formula $T_{P}^{M,A}$
\end_inset

 as the foreign monad 
\begin_inset Formula $M$
\end_inset

 (not as the type parameter 
\begin_inset Formula $A$
\end_inset

).
 This way of composition is called 
\series bold
stacking
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!stacking
\end_layout

\end_inset

 the monad transformers.
 
\end_layout

\begin_layout Standard
In Scala code, this 
\begin_inset Quotes eld
\end_inset

stacking
\begin_inset Quotes erd
\end_inset

 construction is written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type RT[M, A] = PT[QT[M, *], A]
\end_layout

\end_inset

The resulting monad is a 
\series bold
stack
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!stack of
\end_layout

\end_inset

 of three monads 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

.
 The order of monads in the stack is significant: in general, there will
 be no monad isomorphism between differently ordered stacks.
\end_layout

\begin_layout Standard
We will now prove that the transformer 
\begin_inset Formula $T_{R}$
\end_inset

 is lawful (satisfies the laws stated in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

), as long as both 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

 satisfy the same laws.
 To shorten the notation, we talk about a 
\begin_inset Quotes eld
\end_inset

monad 
\begin_inset Formula $T_{P}^{M}$
\end_inset


\begin_inset Quotes erd
\end_inset

 meaning the monad defined as 
\begin_inset Formula $T_{P}^{M,\bullet}$
\end_inset

 or, more verbosely, the monad 
\begin_inset Formula $G^{A}\triangleq T_{P}^{M,A}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $T_{P}^{T_{Q}^{M}}$
\end_inset

 is a monad for any monad 
\begin_inset Formula $M$
\end_inset

.
 The monad laws for 
\begin_inset Formula $T_{Q}$
\end_inset

 say that 
\begin_inset Formula $T_{Q}^{M}$
\end_inset

 is a monad.
 The monad laws for 
\begin_inset Formula $T_{P}$
\end_inset

 say that 
\begin_inset Formula $T_{P}^{S}$
\end_inset

 is a monad for any monad 
\begin_inset Formula $S$
\end_inset

; in particular, for 
\begin_inset Formula $S=T_{Q}^{M}$
\end_inset

.
 Therefore, 
\begin_inset Formula $T_{P}^{S}=T_{P}^{T_{Q}^{M}}$
\end_inset

 is a monad.
\end_layout

\begin_layout Paragraph
Identity law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $T_{P}^{T_{Q}^{\text{Id}}}\cong T_{P}^{Q}$
\end_inset

 via a monad isomorphism.
 The identity law for 
\begin_inset Formula $T_{Q}$
\end_inset

 says that 
\begin_inset Formula $T_{Q}^{\text{Id}}\cong Q$
\end_inset

 via a monad isomorphism.
 So, we already have a monad morphism 
\begin_inset Formula $\phi:Q\leadsto T_{Q}^{\text{Id}}$
\end_inset

 and its inverse, 
\begin_inset Formula $\chi:T_{Q}^{\text{Id}}\leadsto Q$
\end_inset

.
 The runner 
\begin_inset Formula $\text{frun}_{P}$
\end_inset

 for 
\begin_inset Formula $T_{P}$
\end_inset

 can be applied to both 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

 since they are monad morphisms.
 So, we obtain two new monad morphisms:
\begin_inset Formula 
\[
\text{frun}_{P}\left(\phi\right):T_{P}^{Q}\leadsto T_{P}^{T_{Q}^{\text{Id}}}\quad;\quad\quad\text{frun}_{P}\left(\chi\right):T_{P}^{T_{Q}^{\text{Id}}}\leadsto T_{P}^{Q}\quad.
\]

\end_inset

Are these two monad morphisms inverses of each other? To show this, we need
 to verify:
\begin_inset Formula 
\[
\text{frun}_{P}\left(\phi\right)\bef\text{frun}_{P}\left(\chi\right)=\text{id}\quad,\quad\quad\text{frun}_{P}\left(\chi\right)\bef\text{frun}_{P}\left(\phi\right)=\text{id}\quad.
\]

\end_inset

By the runner laws for 
\begin_inset Formula $T_{P}$
\end_inset

, we have 
\begin_inset Formula $\text{frun}_{P}\left(\text{id}\right)=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{frun}_{P}\left(f\right)\bef\text{frun}_{P}\left(g\right)=\text{frun}_{P}\left(f\bef g\right)$
\end_inset

 for any two monad morphisms 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 So, we have:
\begin_inset Formula 
\begin{align*}
\text{frun}_{P}\left(\phi\right)\bef\text{frun}_{P}\left(\chi\right) & =\text{frun}_{P}\left(\phi\bef\chi\right)=\text{frun}_{P}\left(\text{id}\right)=\text{id}\quad,\\
\text{frun}_{P}\left(\chi\right)\bef\text{frun}_{P}\left(\phi\right) & =\text{frun}_{P}\left(\chi\bef\phi\right)=\text{frun}_{P}\left(\text{id}\right)=\text{id}\quad.
\end{align*}

\end_inset

We have indeed obtained a monad isomorphism between 
\begin_inset Formula $T_{P}^{Q}$
\end_inset

 and 
\begin_inset Formula $T_{P}^{T_{Q}^{\text{Id}}}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Lifting law
\end_layout

\begin_layout Standard
We need to show that there exists a monad morphism 
\begin_inset Formula $\text{flift}_{R}:M\leadsto T_{P}^{T_{Q}^{M}}$
\end_inset

 for any monad 
\begin_inset Formula $M$
\end_inset

.
 The lifting law for 
\begin_inset Formula $T_{Q}$
\end_inset

 gives a monad morphism 
\begin_inset Formula $\text{flift}_{Q}:M\leadsto T_{Q}^{M}$
\end_inset

.
 The lifting law for 
\begin_inset Formula $T_{P}$
\end_inset

 can be applied to the monad 
\begin_inset Formula $T_{Q}^{M}$
\end_inset

, which gives a monad morphism 
\begin_inset Formula $\text{flift}_{P}:T_{Q}^{M}\leadsto T_{P}^{T_{Q}^{M}}$
\end_inset

.
 The composition 
\begin_inset Formula $\text{flift}_{R}\triangleq\text{flift}_{Q}\bef\text{flift}_{P}$
\end_inset

 has the required type 
\begin_inset Formula $M\leadsto T_{P}^{T_{Q}^{M}}$
\end_inset

 and is a monad morphism by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Runner law
\end_layout

\begin_layout Standard
We need to show that there exists a lifting:
\begin_inset Formula 
\[
\text{frun}_{R}:\left(M\leadsto N\right)\rightarrow T_{P}^{T_{Q}^{M}}\leadsto T_{P}^{T_{Q}^{N}}\quad.
\]

\end_inset

First, we have to define 
\begin_inset Formula $\text{frun}_{R}(\phi)$
\end_inset

 for any given 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

.
 We use the lifting law for 
\begin_inset Formula $T_{Q}$
\end_inset

 to get a monad morphism:
\begin_inset Formula 
\[
\text{frun}_{Q}(\phi):T_{Q}^{M}\leadsto T_{Q}^{N}\quad.
\]

\end_inset

Now we can apply the lifting law for 
\begin_inset Formula $T_{P}$
\end_inset

 to this monad morphism and obtain:
\begin_inset Formula 
\[
\text{frun}_{P}\big(\text{frun}_{Q}(\phi)\big):T_{P}^{T_{Q}^{M}}\leadsto T_{P}^{T_{Q}^{N}}\quad.
\]

\end_inset

This function has the correct type signature.
 So, we can define:
\begin_inset Formula 
\[
\text{frun}_{R}\triangleq\text{frun}_{Q}\bef\text{frun}_{P}\quad.
\]

\end_inset

It remains to prove that 
\begin_inset Formula $\text{frun}_{R}$
\end_inset

 is a lawful lifting.
 We use the fact that both 
\begin_inset Formula $\text{flift}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{flift}_{Q}$
\end_inset

 are lawful liftings; we need to show that their composition is also a lawful
 lifting.
 To verify the identity law of lifting, apply 
\begin_inset Formula $\text{flift}_{R}$
\end_inset

 to an identity function 
\begin_inset Formula $\text{id}:M\leadsto M$
\end_inset

,
\begin_inset Formula 
\begin{align*}
 & \text{frun}_{R}(\text{id}^{:M\leadsto M})=\text{frun}_{P}\gunderline{\big(\text{frun}_{Q}(\text{id}^{:M\leadsto M})\big)}\\
\text{identity law of }\text{frun}_{Q}:\quad & =\text{frun}_{P}\big(\text{id}^{:T_{Q}^{M}\leadsto T_{Q}^{M}}\big)\\
\text{identity law of }\text{frun}_{P}:\quad & =\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law of lifting, apply 
\begin_inset Formula $\text{frun}_{R}$
\end_inset

 to a composition of two monad morphisms 
\begin_inset Formula $\phi:L\leadsto M$
\end_inset

 and 
\begin_inset Formula $\chi:M\leadsto N$
\end_inset

,
\begin_inset Formula 
\begin{align*}
\text{frun}_{R}\left(\phi\bef\chi\right) & =\text{frun}_{P}\gunderline{(\text{frun}_{Q}(\phi\bef\chi))}\\
\text{composition law of }\text{frun}_{Q}:\quad & =\gunderline{\text{frun}_{P}}(\text{frun}_{Q}(\phi)\bef\text{frun}_{Q}(\chi))\\
\text{composition law of }\text{frun}_{P}:\quad & =\gunderline{\text{frun}_{P}(\text{frun}_{Q}(\phi))}\bef\gunderline{\text{frun}_{P}(\text{frun}_{Q}(\phi))}\\
\text{definition of }\text{frun}_{R}:\quad & =\text{frun}_{R}(\phi)\bef\text{frun}_{R}(\chi)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Base runner law
\end_layout

\begin_layout Standard
We need to show that for any monad morphism 
\begin_inset Formula $\theta:T_{P}^{Q}\leadsto\text{Id}$
\end_inset

 and for any monad 
\begin_inset Formula $M$
\end_inset

, there exists a monad morphism 
\begin_inset Formula $\text{brun}_{R}(\theta):T_{P}^{T_{Q}^{M}}\leadsto M$
\end_inset

.
 To define this morphism for a given 
\begin_inset Formula $\theta$
\end_inset

, we will need to use the base runners for 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

.
 The base runner for 
\begin_inset Formula $T_{Q}$
\end_inset

 has the type signature:
\begin_inset Formula 
\[
\text{brun}_{Q}:\left(Q\leadsto\text{Id}\right)\rightarrow(T_{Q}^{M}\leadsto M)\quad.
\]

\end_inset

We can apply the base runner for 
\begin_inset Formula $T_{P}$
\end_inset

 with the foreign monad 
\begin_inset Formula $T_{Q}^{M}$
\end_inset

,
\begin_inset Formula 
\[
\text{brun}_{P}:\left(P\leadsto\text{Id}\right)\rightarrow\big(T_{P}^{T_{Q}^{M}}\leadsto T_{Q}^{M}\big)\quad.
\]

\end_inset

It is now clear that we could obtain a monad morphism 
\begin_inset Formula $T_{P}^{T_{Q}^{M}}\leadsto M$
\end_inset

 if we had some monad morphisms 
\begin_inset Formula $\phi:P\leadsto\text{Id}$
\end_inset

 and 
\begin_inset Formula $\chi:Q\leadsto\text{Id}$
\end_inset

,
\begin_inset Formula 
\[
\text{brun}_{P}(\phi)\bef\text{brun}_{Q}(\chi):T_{P}^{T_{Q}^{M}}\leadsto M\quad.
\]

\end_inset

However, we are only given a single monad morphism 
\begin_inset Formula $\theta:T_{P}^{Q}\leadsto\text{Id}$
\end_inset

.
 How can we compute 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

 out of 
\begin_inset Formula $\theta$
\end_inset

? We can use the liftings 
\begin_inset Formula $\text{blift}_{P}:P\leadsto T_{P}^{Q}$
\end_inset

 and 
\begin_inset Formula $\text{flift}_{P}:Q\leadsto T_{P}^{Q}$
\end_inset

, which are both monad morphisms, and compose them with 
\begin_inset Formula $\theta$
\end_inset

:
\begin_inset Formula 
\[
\left(\text{blift}_{P}\bef\theta\right):P\leadsto\text{Id}\quad;\quad\quad\left(\text{flift}_{P}\bef\theta\right):Q\leadsto\text{Id}\quad.
\]

\end_inset

So, we can define the monad morphism 
\begin_inset Formula $\text{brun}_{R}(\theta)$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
\text{brun}_{R}(\theta) & :T_{P}^{T_{Q}^{M}}\leadsto M\quad,\\
\text{brun}_{R}(\theta) & \triangleq\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)\bef\text{brun}_{Q}\left(\text{flift}_{P}\bef\theta\right)\quad.
\end{align*}

\end_inset

Since we have defined 
\begin_inset Formula $\text{brun}_{R}(\theta)$
\end_inset

 as a composition of monad morphisms, 
\begin_inset Formula $\text{brun}_{R}(\theta)$
\end_inset

 is itself a monad morphism by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
To verify the nondegeneracy law of the base runner, 
\begin_inset Formula $\text{flift}_{R}\bef\text{brun}_{R}(\theta)=\text{id}$
\end_inset

, we need to use the nondegeneracy laws for the base runners of 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{Q}$
\end_inset

, which are: 
\begin_inset Formula 
\[
\text{flift}_{P}\bef\text{brun}_{P}(\chi^{:P\leadsto\text{Id}})=\text{id}\quad,\quad\quad\text{flift}_{Q}\bef\text{brun}_{Q}(\psi^{:Q\leadsto\text{Id}})=\text{id}\quad.
\]

\end_inset

Then we can write:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{flift}_{R}}\bef\gunderline{\text{brun}_{R}(\theta)}\\
\text{expand definitions}:\quad & =\text{flift}_{Q}\bef\gunderline{\text{flift}_{P}\bef\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)}\bef\text{brun}_{Q}\left(\text{flift}_{P}\bef\theta\right)\\
\text{non-degeneracy law of }\text{brun}_{P}:\quad & =\gunderline{\text{flift}_{Q}\bef\text{brun}_{Q}\left(\text{flift}_{P}\bef\theta\right)}\\
\text{non-degeneracy law of }\text{brun}_{Q}:\quad & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
The monadic naturality law of 
\begin_inset Formula $\text{flift}_{R}$
\end_inset

 is:
\begin_inset Formula 
\[
\text{flift}_{R}\bef\text{frun}_{R}(\phi)=\phi\bef\text{flift}_{R}\quad.
\]

\end_inset

We have defined 
\begin_inset Formula $\text{flift}_{R}\triangleq\text{flift}_{Q}\bef\text{flift}_{P}$
\end_inset

, and we may assume that the monadic naturality laws hold for 
\begin_inset Formula $\text{flift}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{flift}_{Q}$
\end_inset

.
 A composition of natural transformations is again a natural transformation;
 this holds for any category, including the category of monads.
 We can also verify this law directly:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\phi\bef\text{flift}_{R}:\quad & \text{flift}_{R}\bef\text{frun}_{R}(\phi)=\text{flift}_{Q}\bef\gunderline{\text{flift}_{P}\bef\text{frun}_{P}}(\text{frun}_{Q}(\phi))\\
\text{monadic naturality of }\text{flift}_{P}:\quad & =\gunderline{\text{flift}_{Q}\bef\text{frun}_{Q}(\phi)}\bef\text{flift}_{P}\\
\text{monadic naturality of }\text{flift}_{Q}:\quad & =\phi\bef\text{flift}_{Q}\bef\text{flift}_{P}=\phi\bef\text{flift}_{R}\quad.
\end{align*}

\end_inset

The monadic naturality of 
\begin_inset Formula $\text{brun}_{R}$
\end_inset

 is verified similarly, assuming the same law for 
\begin_inset Formula $\text{brun}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{brun}_{Q}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect }\text{brun}_{R}(\theta)\bef\phi:\quad & \text{frun}_{R}(\phi)\bef\text{brun}_{R}(\theta)=\gunderline{\text{frun}_{P}(\text{frun}_{Q}(\phi))\bef\text{brun}_{P}}\left(\text{blift}_{P}\bef\theta\right)\bef\text{brun}_{Q}\left(\text{flift}_{P}\bef\theta\right)\\
\text{same law for }\text{brun}_{P}:\quad & =\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)\bef\gunderline{\text{frun}_{Q}(\phi)\bef\text{brun}_{Q}}\left(\text{flift}_{P}\bef\theta\right)\\
\text{same law for }\text{brun}_{Q}:\quad & =\text{brun}_{P}\left(\text{blift}_{P}\bef\theta\right)\bef\text{brun}_{Q}\left(\text{flift}_{P}\bef\theta\right)\bef\phi=\text{brun}_{R}(\theta)\bef\phi\quad.
\end{align*}

\end_inset

 
\end_layout

\begin_layout Subsection
Stacking any number of monads.
 Proofs
\begin_inset CommandInset label
LatexCommand label
name "subsec:Stacking-any-number-of-monads"

\end_inset


\end_layout

\begin_layout Standard
If the monad transformer for 
\begin_inset Formula $T_{P}^{Q}$
\end_inset

 is applied to another monad 
\begin_inset Formula $K$
\end_inset

, we obtain a new monad 
\begin_inset Formula $S$
\end_inset

:
\begin_inset Formula 
\[
S^{A}\triangleq T_{P}^{T_{Q}^{K},A}=(P\varangle Q\varangle K)^{A}.
\]

\end_inset

What is the monad transformer 
\begin_inset Formula $T_{S}$
\end_inset

 for the monad 
\begin_inset Formula $S$
\end_inset

? Assuming that the monad transformer 
\begin_inset Formula $T_{K}$
\end_inset

 is known, we may stack the monads one level higher:
\begin_inset Formula 
\[
T_{S}^{M,A}\triangleq T_{P}^{T_{Q}^{T_{K}^{M}},A}=(P\varangle Q\varangle K\varangle M)^{A}\quad.
\]

\end_inset

The result is a stack of four monads 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $K$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

.
 Note that the type parameter 
\begin_inset Formula $A$
\end_inset

 is used as 
\begin_inset Formula $T_{P}^{(...),A}$
\end_inset

, that is, it belongs to the 
\emph on
outer
\emph default
 transformer (
\begin_inset Formula $T_{P}$
\end_inset

).
\end_layout

\begin_layout Standard
We can now define a transformer stack for any number of monads 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

, ..., 
\begin_inset Formula $Z$
\end_inset

 in a similar way:
\begin_inset Formula 
\begin{equation}
T_{S}^{M,A}\triangleq T_{P}^{T_{Q}^{\iddots^{T_{Z}^{M}}},A}=(P\varangle Q\varangle...\varangle Z\varangle M)^{A}\quad.\label{eq:general-transformer-stack}
\end{equation}

\end_inset

The type parameter 
\begin_inset Formula $A$
\end_inset

 will always remain at the outer transformer level, while the foreign monad
 
\begin_inset Formula $M$
\end_inset

 will be in the innermost nested position.
\end_layout

\begin_layout Standard
It turns out that 
\begin_inset Formula $T_{S}$
\end_inset

 is a lawful monad transformer for 
\emph on
any
\emph default
 number of stacked monads.
 We can prove this by induction on the number of monads.
 In the previous section, we have proved the transformer laws for any 
\emph on
three
\emph default
 stacked monads.
 Now we need to prove the same laws for a general transformer stack, such
 as that in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:general-transformer-stack"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Let us temporarily denote by 
\begin_inset Formula $J$
\end_inset

 the monad:
\begin_inset Formula 
\[
J\triangleq T_{Q}^{\iddots^{T_{Z}^{\text{Id}}}}=Q\varangle...\varangle Z\varangle\text{Id}\cong Q\varangle...\varangle Z\quad,
\]

\end_inset

where we used the identity monad 
\begin_inset Formula $\text{Id}$
\end_inset

 in the place normally taken by a foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The monad 
\begin_inset Formula $J$
\end_inset

 is a shorter transformer stack than 
\begin_inset Formula $S$
\end_inset

, so the inductive assumption tells us that the transformer laws already
 hold for the transformer 
\begin_inset Formula $T_{J}$
\end_inset

 defined as:
\begin_inset Formula 
\[
T_{J}^{M}\triangleq T_{Q}^{\iddots^{T_{Z}^{M}}}=\left(Q\varangle...\varangle Z\right)\varangle M\quad.
\]

\end_inset

Since both 
\begin_inset Formula $T_{P}$
\end_inset

 and 
\begin_inset Formula $T_{J}$
\end_inset

 are lawful transformers, their stacking composition 
\begin_inset Formula $T_{P}^{T_{J}^{\bullet}}$
\end_inset

 is also a lawful transformer (this was shown in the Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In our notation, 
\begin_inset Formula $T_{S}^{M,A}=T_{P}^{T_{J}^{M},A}$
\end_inset

, and so we have shown that 
\begin_inset Formula $T_{S}$
\end_inset

 is a lawful transformer.
\end_layout

\begin_layout Section
Common properties of compositional transformers 
\begin_inset CommandInset label
LatexCommand label
name "sec:Monad-transformers-that-use-composition"

\end_inset


\end_layout

\begin_layout Standard
We have seen examples of monad transformers built via functor composition,
 either as composed-inside or as composed-outside.
 The simplest examples are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OptionT
\end_layout

\end_inset

 transformer:
\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A,\quad\quad T_{L}^{M,A}\triangleq M^{L^{A}}=M^{\bbnum 1+A}\quad,
\]

\end_inset

which puts the base monad 
\begin_inset Formula $L$
\end_inset

 
\emph on
inside
\emph default
 the monad 
\begin_inset Formula $M$
\end_inset

, and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ReaderT
\end_layout

\end_inset

 transformer:
\begin_inset Formula 
\[
L^{A}\triangleq R\rightarrow A,\quad\quad T_{L}^{M,A}\triangleq L^{M^{A}}=R\rightarrow M^{A}\quad,
\]

\end_inset

which puts the base monad 
\begin_inset Formula $L$
\end_inset

 
\emph on
outside
\emph default
 the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 
\end_layout

\begin_layout Standard
We can prove many properties of both kinds of monad transformers via a single
 derivation if we temporarily drop the distinction between the base monad
 and the foreign monad.
 We simply assume that two different monads, 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, have a functor composition 
\begin_inset Formula $T^{\bullet}\triangleq L^{M^{\bullet}}$
\end_inset

 that also happens to be a monad.
 Since the assumptions on the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are the same, the resulting properties of the composed monad 
\begin_inset Formula $T$
\end_inset

 will apply equally to both kinds of monad transformers.
\end_layout

\begin_layout Standard
To interpret the results, we will assume that 
\begin_inset Formula $L$
\end_inset

 is the base monad for the composed-outside transformers, and that 
\begin_inset Formula $M$
\end_inset

 is the base monad for the composed-inside transformers.
 For instance, we will be able to prove the laws of liftings 
\begin_inset Formula $L\leadsto T$
\end_inset

 and 
\begin_inset Formula $M\leadsto T$
\end_inset

 regardless of the choice of the base monad.
\end_layout

\begin_layout Standard
What properties of monad transformers will 
\emph on
not
\emph default
 be derivable in this way? Monad transformers depend on the structure on
 the base monad, but not on the structure of the foreign monad; the transformer'
s methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 are parametric in the foreign monad.
 This is expressed via the monad transformer laws for the runners 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

, which we will need to derive separately for each of the two kinds of transform
ers.
\end_layout

\begin_layout Subsection
Motivation for the 
\family typewriter
swap
\family default
 function
\end_layout

\begin_layout Standard
The first task is to verify the monad laws; that is, to show that 
\begin_inset Formula $T^{\bullet}\triangleq L^{M^{\bullet}}$
\end_inset

 is a lawful monad.
 For that, we need to define the methods for the monad 
\begin_inset Formula $T$
\end_inset

, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{pu}_{T}$
\end_inset


\begin_inset Quotes erd
\end_inset

) and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{ftn}_{T}$
\end_inset


\begin_inset Quotes erd
\end_inset

), with the type signatures:
\begin_inset Formula 
\[
\text{pu}_{T}:A\rightarrow L^{M^{A}}\quad,\quad\quad\text{ftn}_{T}:L^{M^{L^{M^{A}}}}\rightarrow L^{M^{A}}\quad.
\]

\end_inset

How can we implement these methods? 
\emph on
All we know
\emph default
 about 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 is that they are monads with their own methods 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

, 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

, and 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

.
 We can easily implement 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{3pc}A\ar[r]\sp(0.5){\text{pu}_{M}}\ar[rd]\sb(0.45){\text{pu}_{T}\triangleq} & M^{A}\ar[d]\sp(0.45){\text{pu}_{L}}\\
 & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{pu}_{T}\triangleq\text{pu}_{M}\bef\text{pu}_{L}\quad.\label{eq:def-of-pure-T}
\end{equation}

\end_inset

It remains to implement 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 In the type 
\begin_inset Formula $L^{M^{L^{M^{A}}}}$
\end_inset

, we have two layers of the functor 
\begin_inset Formula $L$
\end_inset

 and two layers of the functor 
\begin_inset Formula $M$
\end_inset

.
 We could use the available method 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 to flatten the two layers of 
\begin_inset Formula $L$
\end_inset

 if we could 
\emph on
somehow
\emph default
 bring these nested layers together.
 However, these layers are separated by a layer of the functor 
\begin_inset Formula $M$
\end_inset

.
 To show this layered structure in an easier way, let us use another notation
 for the functor composition:
\begin_inset Formula 
\[
(L\circ M)^{A}\triangleq L^{M^{A}}\quad.
\]

\end_inset

In this notation, the type signature for 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 is written as:
\begin_inset Formula 
\[
\text{ftn}_{T}:L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

If we had 
\begin_inset Formula $L\circ L\circ M\circ M$
\end_inset

 here, we would have applied 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 and flattened the two layers of the functor 
\begin_inset Formula $L$
\end_inset

.
 Then we would have flattened the remaining two layers of the functor 
\begin_inset Formula $M$
\end_inset

.
 How can we proceed with 
\begin_inset Formula $L\circ M\circ L\circ M$
\end_inset

? The trick is to assume that we have a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (short notation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{sw}$
\end_inset


\begin_inset Quotes erd
\end_inset

), which will interchange the order of the layers.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{sw}:M\circ L\leadsto L\circ M\quad,\quad\text{or more verbosely:}\quad\quad\text{sw}_{L,M}^{A}:M^{L^{A}}\rightarrow L^{M^{A}}\quad.
\]

\end_inset

If the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 operation were 
\emph on
somehow
\emph default
 defined for the two monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, we could implement 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 by first swapping the order of the inner layers 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 as:
\begin_inset Formula 
\[
\text{sw}_{L,M}^{\uparrow L}:L\circ M\circ L\circ M\leadsto L\circ L\circ M\circ M\quad,
\]

\end_inset

and then applying the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 methods of the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 The resulting code for the function 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and the corresponding type diagram are:
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{2.0pc}L^{M^{L^{M^{A}}}}\ar[r]\sp(0.5){\text{sw}^{\uparrow L}}\ar[rrd]\sb(0.5){\text{ftn}_{T}\triangleq} & L^{L^{M^{M^{A}}}}\ar[r]\sp(0.5){\text{ftn}_{L}} & L^{M^{M^{A}}}\ar[d]\sp(0.4){\text{ftn}_{M}^{\uparrow L}}\\
 &  & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{ftn}_{T}\triangleq\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:define-flatten-via-swap}
\end{equation}

\end_inset

In this way, the new monad's 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 method can be defined through the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation in 
\emph on
both
\emph default
 cases (the composed-inside and the composed-outside transformers).
 For the two kinds of transformers, the required type signatures of those
 functions are:
\begin_inset Formula 
\begin{align*}
\text{composed-inside}:\quad\text{ftn}_{T}:M^{L^{M^{L^{A}}}}\rightarrow M^{L^{A}}\quad, & \quad\text{sw}_{M,L}^{A}:L^{M^{A}}\rightarrow M^{L^{A}}\quad,\\
\text{composed-outside}:\quad\text{ftn}_{T}:L^{M^{L^{M^{A}}}}\rightarrow L^{M^{A}}\quad, & \quad\text{sw}_{L,M}^{A}:M^{L^{A}}\rightarrow L^{M^{A}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
The difference between 
\family typewriter
swap
\family default
 and 
\family typewriter
sequence
\end_layout

\begin_layout Standard
There is a certain similarity between the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation introduced here and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 operation introduced in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:9-Traversable-functors-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for traversable functors.
 Indeed, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{seq}:L^{F^{A}}\rightarrow F^{L^{A}}\quad,
\]

\end_inset

where 
\begin_inset Formula $L$
\end_inset

 is a traversable functor and 
\begin_inset Formula $F$
\end_inset

 is an arbitrary applicative functor (which could be 
\begin_inset Formula $M$
\end_inset

, since all monads are also applicative functors).
 However, the similarity ends here.
 If we wish 
\begin_inset Formula $M\circ L$
\end_inset

 to be a monad, the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation must obey special laws (to be derived next) that are quite different
 from the laws of traversable functors.
 In particular, it is not true that 
\begin_inset Formula $M\circ L$
\end_inset

 is a monad whenever the monad 
\begin_inset Formula $L$
\end_inset

 is a traversable functor.
 A counterexample is found with 
\begin_inset Formula $L^{A}\triangleq A\times A$
\end_inset

 and 
\begin_inset Formula $M^{A}\triangleq\bbnum 1+A$
\end_inset

.
 Both monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are traversable (since they are polynomial functors), but their functor
 composition 
\begin_inset Formula $Q^{A}\triangleq\bbnum 1+A\times A$
\end_inset

 is not a monad (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-7-not-a-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Another difference between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 is that the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation needs to be parametric in the foreign monad (which may be either
 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 according to the type of the monad transformer), whereas 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sequence
\end_layout

\end_inset

 is always parametric in the applicative functor 
\begin_inset Formula $F$
\end_inset

.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout

\emph on
This is actually confusing! Let's not do this and always write 
\begin_inset Formula $\text{sw}_{L}^{M}:M^{L^{A}}\rightarrow L^{M^{A}}$
\end_inset


\end_layout

\begin_layout Plain Layout
To denote more clearly the monad with respect to which 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is parametric, we may write
\begin_inset Formula 
\begin{align*}
\text{sw}_{L}^{M}:L^{M^{A}}\rightarrow M^{L^{A}}\quad & \text{for the composed-inside transformers,}\\
\text{sw}_{L}^{M}:M^{L^{A}}\rightarrow L^{M^{A}}\quad & \text{for the composed-outside transformers.}
\end{align*}

\end_inset

The superscript 
\begin_inset Formula $M$
\end_inset

 in 
\begin_inset Formula $\text{sw}_{L}^{M}$
\end_inset

 shows that 
\begin_inset Formula $M$
\end_inset

 is a 
\emph on
type parameter
\emph default
 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

; that is, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is parametric in the monad 
\begin_inset Formula $M$
\end_inset

.
 The subscript 
\begin_inset Formula $L$
\end_inset

 in 
\begin_inset Formula $\text{sw}_{L}^{M}$
\end_inset

 shows that the implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 may need to use completely different code for different monads 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To avoid confusion, we call the function 
\begin_inset Formula $\text{sw}_{L,M}:M^{L^{\bullet}}\leadsto L^{M^{\bullet}}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

swap
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

sequence
\begin_inset Quotes erd
\end_inset

.
 Let us now find out what laws are required for the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 operation.
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 operation was studied in the paper 
\begin_inset Quotes eld
\end_inset


\emph on
Composing monads
\emph default

\begin_inset Quotes erd
\end_inset

: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Deriving the necessary laws for 
\family typewriter
swap
\end_layout

\begin_layout Standard
The first law is that 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 must be a natural transformation.
 Since 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 has only one type parameter, there is one naturality law: for any function
 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

,
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.3pc}\xyScaleX{2.5pc}M^{L^{A}}\ar[r]\sp(0.5){f^{\uparrow L\uparrow M}}\ar[d]\sb(0.45){\text{sw}} & M^{L^{B}}\ar[d]\sp(0.45){\text{sw}}\\
L^{M^{A}}\ar[r]\sp(0.5){f^{\uparrow M\uparrow L}} & L^{M^{B}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
f^{\uparrow L\uparrow M}\bef\text{sw}_{L,M}=\text{sw}_{L,M}\bef f^{\uparrow M\uparrow L}\quad.\label{eq:swap-law-0-naturality}
\end{equation}

\end_inset

To derive further laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

, consider the requirement that the transformed monad 
\begin_inset Formula $T$
\end_inset

 should satisfy the monad laws:
\begin_inset Formula 
\[
\text{pu}_{T}\bef\text{ftn}_{T}=\text{id}\quad,\quad\quad\text{pu}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\text{id}\quad,\quad\quad\text{ftn}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\text{ftn}_{T}\bef\text{ftn}_{T}\quad.
\]

\end_inset

We will now discover the laws for 
\family typewriter
swap
\family default
 that make the laws for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 hold automatically, as long as 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 is derived from 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
We substitute Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the left identity law for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and simplify:
\begin_inset Formula 
\begin{align}
\text{expect to equal }\text{id}:\quad & \text{pu}_{T}\bef\gunderline{\text{ftn}_{T}}\nonumber \\
\text{replace }\text{ftn}_{T}\text{ using Eq.~(\ref{eq:define-flatten-via-swap})}:\quad & =\text{pu}_{T}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{replace }\text{pu}_{T}\text{ using Eq.~(\ref{eq:def-of-pure-T})}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{naturality law of }\text{pu}_{L}:\quad & =\text{pu}_{M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{left identity law for }L:\quad & =\text{pu}_{M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:left-identity-ftn-T}
\end{align}

\end_inset

How could the last expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-identity-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) be equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity
\end_layout

\end_inset

? We know nothing about the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 methods of the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, except that these methods obey the monad laws.
 We could satisfy Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-identity-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) if we somehow reduce that expression to:
\begin_inset Formula 
\[
\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=\left(\text{pu}_{M}\bef\text{ftn}_{M}\right)^{\uparrow L}=\text{id}\quad.
\]

\end_inset

This will be possible only if we are able to interchange the order of function
 compositions with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 and eliminate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 from the expression.
 So, we must require the 
\begin_inset Quotes eld
\end_inset

outer identity law
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{2.5pc}L^{A}\ar[r]\sp(0.5){\text{pu}_{M}}\ar[rd]\sb(0.4){\text{pu}_{M}^{\uparrow L}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
 & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow L}\quad.\label{eq:swap-law-1-M-identity}
\end{equation}

\end_inset

Intuitively, this law says that a pure layer of the monad 
\begin_inset Formula $M$
\end_inset

 remains pure after interchanging the order of layers with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
With this law, we can finish the derivation in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:left-identity-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{pu}_{M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{outer identity law of }\text{sw}:\quad & =\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=(\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})^{\uparrow L}=\text{id}^{\uparrow L}=\text{id}\quad.
\end{align*}

\end_inset

So, the 
\begin_inset Formula $M$
\end_inset

-identity law for 
\family typewriter
swap
\family default
 entails the left identity law for 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
In the same way, we motivate the 
\begin_inset Quotes eld
\end_inset

inner identity
\begin_inset Quotes erd
\end_inset

 law for 
\family typewriter
swap
\family default
:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1pc}\xyScaleX{2.5pc}M^{A}\ar[r]\sp(0.5){\text{pu}_{L}^{\uparrow M}}\ar[rd]\sb(0.45){\text{pu}_{L}} & M^{L^{A}}\ar[d]\sp(0.4){\text{sw}}\\
 & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{pu}_{L}^{\uparrow M}\bef\text{sw}=\text{pu}_{L}\quad.\label{eq:swap-law-2-L-identity}
\end{equation}

\end_inset

This law requires that a 
\begin_inset Quotes eld
\end_inset

pure
\begin_inset Quotes erd
\end_inset

 layer of the functor 
\begin_inset Formula $L$
\end_inset

 should remain 
\begin_inset Quotes eld
\end_inset

pure
\begin_inset Quotes erd
\end_inset

 after swapping the order of layers.
\end_layout

\begin_layout Standard
Assuming this law, we can derive the right identity law for 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{pu}_{T}^{\uparrow T}\bef\text{ftn}_{T}\\
\text{by definition, }f^{\uparrow T}\triangleq f^{\uparrow M\uparrow L}:\quad & =(\text{pu}_{T})^{\uparrow M\uparrow L}\bef\text{ftn}_{T}\\
\text{definitions of }\text{pu}_{T}\text{ and }\text{ftn}_{T}:\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{inner identity law of }\text{sw},\text{ under }^{\uparrow L}:\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{right identity law of }L:\quad & =\text{pu}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=\gunderline{(\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M})}^{\uparrow L}=\text{id}^{\uparrow L}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Deriving the monad associativity law for 
\begin_inset Formula $T$
\end_inset

,
\begin_inset Formula 
\[
\text{ftn}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\text{ftn}_{T}\bef\text{ftn}_{T}\quad,
\]

\end_inset

turns out to require 
\emph on
two
\emph default
 further laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 Let us see why.
\end_layout

\begin_layout Standard
Substituting the definition of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 into the associativity law, we get:
\begin_inset Formula 
\begin{align}
 & \big(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\big)^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
 & \quad\overset{?}{=}\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:t-assoc-law-expanded}
\end{align}

\end_inset

The only hope of proving this law is being able to interchange 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 as well as 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

 with 
\begin_inset Formula $\text{sw}$
\end_inset

.
 In other words, the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 function should be in some way adapted to the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 methods of both 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
Let us look for such interchange laws.
 One possibility is to have a law involving 
\begin_inset Formula $\text{ftn}_{M}\bef\text{sw}$
\end_inset

, which is a function of type 
\begin_inset Formula $M^{M^{L^{A}}}\rightarrow L^{M^{A}}$
\end_inset

 or, in equivalent but shorter notation, 
\begin_inset Formula $M\circ M\circ L\leadsto L\circ M$
\end_inset

.
 This function first flattens the two adjacent layers of 
\begin_inset Formula $M$
\end_inset

, obtaining 
\begin_inset Formula $M\circ L$
\end_inset

, and then swaps the two remaining layers, moving the 
\begin_inset Formula $L$
\end_inset

 layer outside.
 Let us think about what law could exist for this kind of transformation.
 It is plausible that we may obtain the same result if we first swap the
 layers twice, so that the 
\begin_inset Formula $L$
\end_inset

 layer moves to the outside, obtaining 
\begin_inset Formula $L\circ M\circ M$
\end_inset

, and then flatten the two inner 
\begin_inset Formula $M$
\end_inset

 layers.
 Writing this assumption in code, we obtain the 
\begin_inset Quotes eld
\end_inset

outer interchange
\begin_inset Quotes erd
\end_inset

 law:
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.8pc}\xyScaleX{2.5pc} & M^{M^{L^{A}}}\ar[r]\sp(0.5){\text{ftn}_{M}}\ar[ld]\sb(0.45){\text{sw}^{\uparrow M}} & M^{L^{A}}\ar[d]\sb(0.45){\text{sw}}\\
M^{L^{M^{A}}}\ar[r]\sp(0.5){\text{sw}} & L^{M^{M^{A}}}\ar[r]\sp(0.5){\text{ftn}_{M}^{\uparrow L}} & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:swap-law-3-M-interchange}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The analogous 
\begin_inset Quotes eld
\end_inset

inner interchange
\begin_inset Quotes erd
\end_inset

 law involving two layers of 
\begin_inset Formula $L$
\end_inset

 and a transformation 
\begin_inset Formula $M\circ L\circ L\leadsto L\circ M$
\end_inset

 is written as:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.8pc}\xyScaleX{2.5pc} & M^{L^{L^{A}}}\ar[r]\sb(0.5){\text{ftn}_{L}^{\uparrow M}}\ar[ld]\sb(0.45){\text{sw}} & M^{L^{A}}\ar[d]\sb(0.45){\text{sw}}\\
L^{M^{L^{A}}}\ar[r]\sp(0.55){\text{sw}^{\uparrow L}} & L^{L^{M^{A}}}\ar[r]\sp(0.5){\text{ftn}_{L}} & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{ftn}_{L}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\quad.\label{eq:swap-law-4-L-interchange}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
At this point, we have simply written down two plausible laws, hoping that
 they will help us derive the associativity law for 
\begin_inset Formula $T$
\end_inset

.
 We will now verify that this is indeed so.
\end_layout

\begin_layout Standard
Both sides of the law in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) involve compositions of several 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s.
 The heuristic idea of the proof is to use various laws to move all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s to right of the composition, while moving all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s to the left.
 In this way we will rewrite both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to a similar form, hoping to prove that they are equal.
\end_layout

\begin_layout Standard
We begin with the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) since it is simpler than the left-hand side, and look for ways of using
 the interchange laws.
 At every step of the calculation, there happens to be only one place where
 some law can be applied:
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{composition for }L:\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{(\text{ftn}_{M}\bef\text{sw})}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{outer interchange law of }\text{sw}:\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{(\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L})}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{composition under }^{\uparrow L}:\quad & =\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{sw}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\gunderline{\text{ftn}_{M}^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{ftn}_{L}:\quad & =\text{sw}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef(\text{sw}^{\uparrow M}\bef\text{sw})^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{ftn}_{L}:\quad & =\text{sw}^{\uparrow L}\bef\gunderline{(\text{sw}^{\uparrow M}\bef\text{sw})^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

Now all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s are on the left and all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s on the right of the expression.
\end_layout

\begin_layout Standard
Transform the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:t-assoc-law-expanded"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in the same way as:
\begin_inset Formula 
\begin{align*}
 & \big(\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}}\big)^{\uparrow M\uparrow L}\gunderline{\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{functor composition}:\quad & =(\text{sw}^{\uparrow L}\bef\text{ftn}_{L})^{\uparrow M\uparrow L}\bef\gunderline{(\text{ftn}_{M}^{\uparrow L\uparrow M}\bef\text{sw})}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{sw}:\quad & =(\text{sw}^{\uparrow L}\bef\text{ftn}_{L})^{\uparrow M\uparrow L}\bef\big(\text{sw}\bef\gunderline{\text{ftn}_{M}^{\uparrow M\uparrow L}}\big)^{\uparrow L}\gunderline{\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{ftn}_{L}:\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{L}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}}\\
\text{associativity of }\text{ftn}_{M}:\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{(\text{ftn}_{L}^{\uparrow M}\bef\text{sw})}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{inner interchange law of }\text{sw}:\quad & =\text{sw}^{\uparrow L\uparrow M\uparrow L}\bef\big(\text{sw}\bef\text{sw}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}}\big)^{\uparrow L}\gunderline{\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{associativity law of }\text{ftn}_{L}:\quad & =\big(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L}\big)^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

We have again managed to move all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s to the left and all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s to the right of the expression.
 
\end_layout

\begin_layout Standard
Comparing now the two sides of the associativity law, we see that all the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s occur in the same combination: 
\begin_inset Formula $\text{ftn}_{L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}$
\end_inset

.
 It remains to show that:
\begin_inset Formula 
\[
\text{sw}^{\uparrow L}\bef(\text{sw}^{\uparrow M}\bef\text{sw})^{\uparrow L\uparrow L}\overset{?}{=}(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L})^{\uparrow L}\quad,
\]

\end_inset

or equivalently:
\begin_inset Formula 
\[
(\text{sw}\bef\text{sw}^{\uparrow M\uparrow L}\bef\text{sw}^{\uparrow L})^{\uparrow L}\overset{?}{=}(\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}\bef\text{sw}^{\uparrow L})^{\uparrow L}\quad.
\]

\end_inset

The two sides are equal due to the naturality law of 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
:
\begin_inset Formula 
\[
\text{sw}\bef\text{sw}^{\uparrow M\uparrow L}=\text{sw}^{\uparrow L\uparrow M}\bef\text{sw}.
\]

\end_inset


\end_layout

\begin_layout Standard
We have proved the following statement:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "sec:Statement-swap-laws-to-monad-transformer-first-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For two monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, assume that there exists a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{sw}_{L,M}:M^{L^{A}}\rightarrow L^{M^{A}}\quad,
\]

\end_inset

which is a natural transformation satisfying four additional laws:
\begin_inset Formula 
\begin{align*}
\text{outer identity}:\quad & \text{pu}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{pu}_{L}\quad,\\
\text{inner identity}:\quad & \text{pu}_{M}\bef\text{sw}_{L,M}=\text{pu}_{M}^{\uparrow L}\quad,\\
\text{outer interchange}:\quad & \text{ftn}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{sw}_{L,M}\bef\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\quad,\\
\text{inner interchange}:\quad & \text{ftn}_{M}\bef\text{sw}_{L,M}=\text{sw}_{L,M}^{\uparrow M}\bef\text{sw}_{L,M}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

Then the functor composition of 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, denoted by 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\[
T^{A}\triangleq L^{M^{A}}=\left(L\circ M\right)^{A}
\]

\end_inset

is a monad with the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 defined by:
\begin_inset Formula 
\begin{align}
\text{pu}_{T} & \triangleq\text{pu}_{M}\bef\text{pu}_{L}\quad,\label{eq:def-pure-T-via-pure-L-and-pure-M}\\
\text{ftn}_{T} & \triangleq\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:def-flatten-T-via-sw-and-flatten-L-M}
\end{align}

\end_inset


\end_layout

\begin_layout Paragraph
Intuition behind 
\family typewriter
swap
\family default
's interchange laws
\end_layout

\begin_layout Standard
Those laws guarantee that any functor composition built up from 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, e.g.:
\begin_inset Formula 
\[
M\circ M\circ L\circ M\circ L\circ L\circ M\circ M\circ L\quad,
\]

\end_inset

can be simplified to a value of type 
\begin_inset Formula $T^{A}=L^{M^{A}}$
\end_inset

 by flattening the layers using 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

, or 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

, or by interchanging the layers with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 We may apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 in any order, and we will always get the same final value of type 
\begin_inset Formula $T^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
In other words, the monadic effects of the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 can be arbitrarily interleaved, swapped, and flattened in any order, with
 no change to the final results.
 The programmer is free to refactor a monadic program, say, by first computing
 some 
\begin_inset Formula $L$
\end_inset

-effects in a separate functor block of 
\begin_inset Formula $L$
\end_inset

-
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

s and only then combining the result with the rest of the computation in
 the monad 
\begin_inset Formula $T$
\end_inset

.
 Regardless of the refactoring, the monad 
\begin_inset Formula $T$
\end_inset

 computes all the effects correctly.
 This is what programmers would expect of the monad 
\begin_inset Formula $T$
\end_inset

, if it is to be regarded as a useful monad transformer.
\end_layout

\begin_layout Standard
We will now derive the properties of the monad 
\begin_inset Formula $T$
\end_inset

 that follow from the interchange laws.
 We will find that it is easier to formulate these laws in terms of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 than in terms of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 In practice, all known examples of compositional monad transformers (the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad, the pass/fail monads, and the 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

 monads) are defined via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Subsection
Deriving 
\family typewriter
swap
\family default
 from 
\family typewriter
flatten
\family default

\begin_inset CommandInset label
LatexCommand label
name "subsec:Deriving-swap-from-flatten"

\end_inset


\end_layout

\begin_layout Standard
We have shown that the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 method of the monad 
\begin_inset Formula $T^{\bullet}=L^{M^{\bullet}}$
\end_inset

 can be defined via the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 method.
 However, we have seen examples of some composable monads (such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

) where we already know the definitions of the 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 method for the composed monad 
\begin_inset Formula $T$
\end_inset

.
 Does a suitable 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 function exist for these examples? In other words, if a 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 function for the monad 
\begin_inset Formula $T=L\circ M$
\end_inset

 is already known, can we find out whether a 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\family default
 function exists such that the
\emph on
 given
\emph default
 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 function is expressed via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

)? 
\end_layout

\begin_layout Standard
To answer this question, let us look at the type signature of 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset


\family default
 for 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{T}:L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

This type signature is different from 
\begin_inset Formula $\text{sw}:M\circ L\leadsto L\circ M$
\end_inset

 in that the argument of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 has extra layers of the functors 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 outside the 
\begin_inset Formula $M\circ L$
\end_inset

 composition.
 We can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 methods of 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 to add such extra layers to a value of type 
\begin_inset Formula $M\circ L$
\end_inset

, without modifying any monadic effects present in 
\begin_inset Formula $M\circ L$
\end_inset

.
 This will allow us to apply 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and to obtain a value of type 
\begin_inset Formula $L\circ M$
\end_inset

.
 The resulting code for the function 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and the corresponding type diagram are:
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){\text{pu}_{M}^{\uparrow L\uparrow M}}\ar[rrd]\sb(0.5){\text{sw}\triangleq} & M^{L^{M^{A}}}\ar[r]\sp(0.5){\text{pu}_{L}} & L^{M^{L^{M^{A}}}}\ar[d]\sb(0.45){\text{ftn}_{T}}\\
 &  & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{sw}=\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\text{ftn}_{T}\quad.\label{eq:define-swap-via-flatten}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We have related 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{L,M}$
\end_inset

 to each other.
 Are these functions always equivalent? 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-swap-equivalence-to-flatten"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-swap-equivalence-to-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The equivalence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 holds under the following conditions:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Given an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 that obeys the naturality law, we define 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then substitute that 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to define a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function.
 The new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function will be equal to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function given initially.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Given an implementation of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 satisfying the 
\begin_inset Quotes eld
\end_inset

compatibility laws
\begin_inset Quotes erd
\end_inset


\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ftn-first-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ftn-second-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 via Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and then substitute that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to define a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 function.
 The new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 function will be equal to the 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 function given initially.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Substitute 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{sw}:\quad & \text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\gunderline{\text{ftn}_{T}}=\text{pu}_{M}^{\uparrow L\uparrow M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{pu}_{L}:\quad & =\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{left identity law of }L:\quad & =\gunderline{\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{sw}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{sw}:\quad & =\text{sw}\bef\gunderline{\text{pu}_{M}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}}=\text{sw}\bef\gunderline{(\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M})}^{\uparrow L}=\text{sw}\quad.
\end{align*}

\end_inset

We recovered the initial 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
 & \gunderline{\text{sw}}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}=\gunderline{(\text{pu}_{M}^{\uparrow L\uparrow M}\bef\text{pu}_{L}\bef\text{ftn}_{T})^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\nonumber \\
\text{functor composition }:\quad & =\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.\label{eq:deriv-sw-from-ftn-a}
\end{align}

\end_inset

At this point, we are stuck: we cannot transform the last expression into
 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 Without assuming additional laws, it 
\emph on
does not follow
\emph default
 that the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deriv-sw-from-ftn-a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is equal to 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 Let us now derive those additional laws.
 
\end_layout

\begin_layout Standard
The only sub-expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deriv-sw-from-ftn-a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that we could possibly transform is the composition 
\begin_inset Formula $\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}$
\end_inset

.
 So, we need to assume a law involving the expression:
\begin_inset Formula 
\[
(\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}):L\circ L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

This function flattens the two layers of 
\begin_inset Formula $\left(L\circ M\right)$
\end_inset

 and then flattens the remaining two layers of 
\begin_inset Formula $L$
\end_inset

.
 Another function with the same type signature could first flatten the two
 
\emph on
outside
\emph default
 layers of 
\begin_inset Formula $L$
\end_inset

 and then flatten the two remaining layers of 
\begin_inset Formula $\left(L\circ M\right)$
\end_inset

:
\begin_inset Formula 
\[
(\text{ftn}_{L}\bef\text{ftn}_{T}):L\circ L\circ M\circ L\circ M\leadsto L\circ M\quad.
\]

\end_inset

We see that a possibly useful additional law for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 is:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{2.5pc}L^{L^{M^{L^{M^{A}}}}}\ar[r]\sp(0.5){\text{ftn}_{L}}\ar[d]\sb(0.45){\text{ftn}_{T}^{\uparrow L}} & L^{M^{L^{M^{A}}}}\ar[d]\sb(0.45){\text{ftn}_{T}}\\
L^{L^{M^{A}}}\ar[r]\sb(0.5){\text{ftn}_{L}} & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{ftn}_{L}\bef\text{ftn}_{T}=\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\quad.\label{eq:ftn-first-compatibility-law}
\end{equation}

\end_inset

This law expresses a certain kind of 
\begin_inset Quotes eld
\end_inset

compatibility
\begin_inset Quotes erd
\end_inset

 between the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
With this law, the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:deriv-sw-from-ftn-a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{right identity law of }L:\quad & =\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

Again, we cannot proceed unless we assume a new law involving the expression:
\begin_inset Formula 
\[
\big(\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\big):L\circ M\circ L\circ M\circ M\leadsto L\circ M\quad.
\]

\end_inset

This function first flattens the two layers of 
\begin_inset Formula $\left(L\circ M\right)$
\end_inset

 and then flattens the remaining two layers of 
\begin_inset Formula $M$
\end_inset

.
 An alternative order of flattenings is to first flatten the 
\emph on
innermost
\emph default
 two layers of 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Formula 
\[
\big(\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\big):L\circ M\circ L\circ M\circ M\leadsto L\circ M\quad.
\]

\end_inset

So, the second law to be assumed is:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.4pc}\xyScaleX{2.5pc}L^{M^{L^{M^{M^{A}}}}}\ar[r]\sp(0.5){\text{ftn}_{T}}\ar[d]\sb(0.5){\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}} & L^{M^{M^{A}}}\ar[d]\sb(0.5){\text{ftn}_{M}^{\uparrow L}}\\
L^{M^{L^{M^{A}}}}\ar[r]\sb(0.5){\text{ftn}_{T}} & L^{M^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\quad.\label{eq:ftn-second-compatibility-law}
\end{equation}

\end_inset

This law expresses a certain kind of 
\begin_inset Quotes eld
\end_inset

compatibility
\begin_inset Quotes erd
\end_inset

 between the monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
Assuming this law, we can finally complete the derivation:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{T}:\quad & \text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{substitute the second conjecture}:\quad & =\gunderline{\text{pu}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}}\bef\text{ftn}_{T}\\
\text{functor composition }:\quad & =\gunderline{(\text{pu}_{M}\bef\text{ftn}_{M})}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\\
\text{left identity law of }M:\quad & =\text{ftn}_{T}\quad.
\end{align*}

\end_inset

We recovered the initial 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 by assuming two additional laws.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
It turns out that those laws will always hold when 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-1-interchange-laws-for-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
It may be hard to verify directly the monad laws for 
\begin_inset Formula $L\circ M$
\end_inset

 because of deeply nested type constructors, e.g., 
\begin_inset Formula $L\circ M\circ L\circ M\circ L\circ M$
\end_inset

.
 If the monad 
\begin_inset Formula $L\circ M$
\end_inset

 has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method, it is simpler first to verify the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 and then to obtain the monad laws of 
\begin_inset Formula $L\circ M$
\end_inset

 via Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Monad transformer identity law.
 Proofs
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-composition-transformer-identity-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-composition-transformer-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 are defined by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and that the two identity laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 hold (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{outer identity law}:\quad & \text{pu}_{L}^{\uparrow M}\bef\text{sw}_{L,M}=\text{pu}_{L}\quad,\\
\text{inner identity law}:\quad & \text{pu}_{M}\bef\text{sw}_{L,M}=\text{pu}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset

Then the identity law holds, 
\begin_inset Formula $T_{L}^{M}\cong L$
\end_inset

 for 
\begin_inset Formula $M=\text{Id}$
\end_inset

, via monad isomorphisms.
 
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
First consider what happens to 
\begin_inset Formula $\text{sw}_{L,M}$
\end_inset

 when 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 are set to the identity monad (
\begin_inset Formula $\text{Id}$
\end_inset

).
 For composed-outside transformers (
\begin_inset Formula $T_{L}^{M}=L\circ M$
\end_inset

) the foreign monad is 
\begin_inset Formula $M$
\end_inset

.
 Setting 
\begin_inset Formula $M=\text{Id}$
\end_inset

 in the inner identity law, we obtain: 
\begin_inset Formula 
\[
\text{pu}_{\text{Id}}\bef\text{sw}_{L,\text{Id}}=\text{pu}_{\text{Id}}^{\uparrow L}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{pu}_{\text{Id}}=\text{id}$
\end_inset

, it follows that 
\begin_inset Formula $\text{sw}_{L,\text{Id}}=\text{id}$
\end_inset

.
 In a similar way, for composed-inside transformers (
\begin_inset Formula $T_{L}^{M}=M\circ L$
\end_inset

) we need to switch the roles of 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 in the same computation and substitute 
\begin_inset Formula $L=\text{id}$
\end_inset

 into the outer identity law:
\begin_inset Formula 
\[
\text{pu}_{\text{Id}}^{\uparrow M}\bef\text{sw}_{\text{Id},M}=\text{pu}_{\text{Id}}\quad.
\]

\end_inset

We obtain 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Note that 
\begin_inset Formula $\text{sw}_{L,\text{Id}}:L^{A}\rightarrow L^{A}$
\end_inset

 is a natural transformation for a monad 
\begin_inset Formula $L$
\end_inset

, so one may heuristically expect 
\begin_inset Formula $\text{sw}_{L,\text{Id}}$
\end_inset

 to be equal to the identity map (the only natural transformation 
\begin_inset Formula $L^{A}\rightarrow L^{A}$
\end_inset

 that exists for all monads 
\begin_inset Formula $L$
\end_inset

).
 Similarly, one may expect that 
\begin_inset Formula $\text{sw}_{\text{Id},M}:M^{A}\rightarrow M^{A}=\text{id}$
\end_inset

 since it is a natural transformation.
 But these are only heuristic expectations, while we have just shown that
 the properties 
\begin_inset Formula $\text{sw}_{L,\text{Id}}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

 follow from the previously established laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 without any new assumptions.
 These properties will be needed in the proofs below.
 
\end_layout

\end_inset

To demonstrate a monadic isomorphism between the monads 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

, we will consider separately the cases of composed-inside and composed-outside
 transformers.
\end_layout

\begin_layout Standard
For composed-inside transformers 
\begin_inset Formula $T_{L}^{M}=M\circ L$
\end_inset

, we set 
\begin_inset Formula $M=\text{Id}$
\end_inset

 and find that the monad 
\begin_inset Formula $T_{L}^{\text{Id}}=\text{Id}\circ L=L$
\end_inset

 is the same type constructor as 
\begin_inset Formula $L$
\end_inset

.
 So, the isomorphism maps between 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are simply the identity maps in both directions, 
\begin_inset Formula $\text{id}:T_{L}^{\text{Id},A}\rightarrow L^{A}$
\end_inset

 and 
\begin_inset Formula $\text{id}:L^{A}\rightarrow T_{L}^{\text{Id},A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
For composed-outside transformers 
\begin_inset Formula $T_{L}^{M}=L\circ M$
\end_inset

, the monad 
\begin_inset Formula $T_{L}^{\text{Id}}=L\circ\text{Id}=L$
\end_inset

 is again the same type constructor as 
\begin_inset Formula $L$
\end_inset

.
 The isomorphisms between 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 are again the identity maps in both directions, 
\begin_inset Formula $\text{id}:T_{L}^{\text{Id},A}\rightarrow L^{A}$
\end_inset

 and 
\begin_inset Formula $\text{id}:L^{A}\rightarrow T_{L}^{\text{Id},A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We have found the isomorphism maps between 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
 However, we still need to verify that the monad structure of 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 is the same as that of 
\begin_inset Formula $L$
\end_inset

; otherwise the isomorphism would not be a 
\emph on
monad
\emph default
 morphism (i.e., an isomorphism that preserves the structure of the monads).
 To verify this, it is sufficient to show that the methods 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 defined by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for the monad 
\begin_inset Formula $T_{L}^{\text{Id}}$
\end_inset

 are 
\emph on
the same functions
\emph default
 as the given methods 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 of the monad 
\begin_inset Formula $L$
\end_inset

.
 If the monad's methods are the same functions, i.e.
\begin_inset space ~
\end_inset


\begin_inset Formula $\text{pu}_{L}=\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}=\text{ftn}_{T}$
\end_inset

, then the identity map 
\begin_inset Formula $\text{id}:T^{A}\rightarrow L^{A}$
\end_inset

 will satisfy the laws of the monad morphisms:
\begin_inset Formula 
\[
\text{pu}_{T}\bef\text{id}=\text{pu}_{L}\quad,\quad\quad\text{ftn}_{T}\bef\text{id}=\text{id}^{\uparrow T}\bef\text{id}\bef\text{ftn}_{L}\quad.
\]

\end_inset

In the same way, the laws of the monad morphisms will hold for 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{id}$
\end_inset


\begin_inset Quotes erd
\end_inset

 in the direction 
\begin_inset Formula $L\leadsto T$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
For composed-inside transformers:
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{M}=\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{M}=\text{ftn}_{T}$
\end_inset

.
 Designate 
\begin_inset Formula $L$
\end_inset

 as the foreign monad and 
\begin_inset Formula $M$
\end_inset

 as the base monad in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

), as appropriate for the composed-inside transformer 
\begin_inset Formula $T_{L}^{M}=M\circ L$
\end_inset

.
 Setting the foreign monad to identity, 
\begin_inset Formula $L=\text{Id}$
\end_inset

, in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives:
\begin_inset Formula 
\[
\text{pu}_{T}=\text{pu}_{M}\bef\text{pu}_{\text{Id}}=\text{pu}_{M}.
\]

\end_inset


\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{ftn}_{M}=\text{ftn}_{T}$
\end_inset

, we use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $L=\text{Id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:\quad & \text{ftn}_{T}=\text{sw}_{\text{Id},M}^{\uparrow\text{Id}}\bef\text{ftn}_{\text{Id}}\bef\text{ftn}_{M}^{\uparrow\text{Id}}\\
\text{use }\text{ftn}_{\text{Id}}=\text{id}\text{ and }\text{sw}_{\text{Id},M}=\text{id}:\quad & =\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
For composed-outside transformers:
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{L}=\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}=\text{ftn}_{T}$
\end_inset

.
 Designate 
\begin_inset Formula $M$
\end_inset

 as the foreign monad and 
\begin_inset Formula $L$
\end_inset

 as the base monad in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

), as appropriate for the composed-outside transformer 
\begin_inset Formula $T_{L}^{M}=L\circ M$
\end_inset

.
 Setting the foreign monad to identity, 
\begin_inset Formula $M=\text{Id}$
\end_inset

, in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives:
\begin_inset Formula 
\[
\text{pu}_{T}=\text{pu}_{\text{Id}}\bef\text{pu}_{L}=\text{pu}_{L}.
\]

\end_inset


\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{ftn}_{L}=\text{ftn}_{T}$
\end_inset

, use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $M=\text{Id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:\quad & \text{ftn}_{T}=\text{sw}_{L,\text{Id}}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{\text{Id}}^{\uparrow L}\\
\text{use }\text{ftn}_{\text{Id}}=\text{id}\text{ and }\text{sw}_{L,\text{Id}}=\text{id}:\quad & =\text{ftn}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Monad transformer lifting laws.
 Proofs
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-transformer-lifting-laws-from-swap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-transformer-lifting-laws-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The monad transformer lifting laws hold if the monad methods of 
\begin_inset Formula $T$
\end_inset

 are defined using Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function obeys the laws defined in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
To be specific, let us assume that 
\begin_inset Formula $L$
\end_inset

 is the base monad of the transformer.
 For the other choice of the base monad, we only need to interchange the
 definitions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The lift functions of a compositional monad transformer are:
\begin_inset Formula 
\[
\text{flift}=\text{pu}_{L}:M^{A}\rightarrow L^{M^{A}}\quad,\quad\quad\text{blift}=\text{pu}_{M}^{\uparrow L}:L^{A}\rightarrow L^{M^{A}}\quad.
\]

\end_inset

Their laws of monad morphisms (the identity and the composition laws) are:
\begin_inset Formula 
\begin{align*}
\text{pu}_{M}\bef\text{flift}=\text{pu}_{T}\quad,\quad & \quad\text{pu}_{L}\bef\text{blift}=\text{pu}_{T}\quad,\\
\text{ftn}_{M}\bef\text{flift}=\text{flift}^{\uparrow M}\bef\text{flift}\bef\text{ftn}_{T}\quad,\quad & \quad\text{ftn}_{L}\bef\text{blift}=\text{blift}^{\uparrow L}\bef\text{blift}\bef\text{ftn}_{T}\quad.
\end{align*}

\end_inset

The identity laws are verified quickly:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{T}:\quad & \text{pu}_{M}\bef\text{flift}=\text{pu}_{M}\bef\text{pu}_{L}=\text{pu}_{T}\quad,\\
\text{expect to equal }\text{pu}_{T}:\quad & \text{pu}_{L}\bef\text{blift}=\text{pu}_{L}\bef\text{pu}_{M}^{\uparrow L}=\text{pu}_{M}\bef\text{pu}_{L}=\text{pu}_{T}\quad.
\end{align*}

\end_inset

To verify the composition laws, we need to start from their right-hand sides
 because the left-hand sides cannot be simplified.
 We then substitute the definition of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 in terms of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The composition law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{M}\bef\text{pu}_{L}:\quad & \text{flift}^{\uparrow M}\bef\text{flift}\bef\text{ftn}_{T}\\
\text{definitions of }\text{flift}\text{ and }\text{ftn}_{T}:\quad & =\text{pu}_{L}^{\uparrow M}\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{pu}_{L}:\quad & =\text{pu}_{L}^{\uparrow M}\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{left identity law of }L:\quad & =\gunderline{\text{pu}_{L}^{\uparrow M}\bef\text{sw}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{inner identity law of }\text{sw}:\quad & =\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{M}\bef\text{pu}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The composition law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{L}\bef\text{pu}_{M}^{\uparrow L}:\quad & \text{blift}^{\uparrow L}\bef\text{blift}\bef\text{ftn}_{T}\\
\text{definitions of }\text{blift}\text{ and }\text{ftn}_{T}:\quad & =\text{pu}_{M}^{\uparrow L\uparrow L}\bef\gunderline{\text{pu}_{M}^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{functor composition in }L:\quad & =\text{pu}_{M}^{\uparrow L\uparrow L}\bef\gunderline{\left(\text{pu}_{M}\bef\text{sw}\right)}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{outer identity law of }\text{sw}:\quad & =\gunderline{\big(\text{pu}_{M}^{\uparrow L\uparrow L}\bef\text{pu}_{M}^{\uparrow L\uparrow L}\big)}\bef\gunderline{\text{ftn}_{L}}\bef\text{ftn}_{M}^{\uparrow L}\\
\text{naturality law of }\text{ftn}_{L}:\quad & =\text{ftn}_{L}\bef\big(\text{pu}_{M}^{\uparrow L}\bef\gunderline{\text{pu}_{M}^{\uparrow L}\big)\bef\text{ftn}_{M}^{\uparrow L}}\\
\text{right identity law of }M:\quad & =\text{ftn}_{L}\bef\text{pu}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
So, the lifting laws for 
\begin_inset Formula $T$
\end_inset

 follow from the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Monad transformer runner laws.
 Proofs
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monad-transformer-runner-laws-from-swap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-transformer-runner-laws-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The runners (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

) satisfy the runner laws and the base runner laws, as long as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function is monadically natural as given by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-of-sw-l-m"
plural "false"
caps "false"
noprefix "false"

\end_inset

) or
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-sw-n-m"
plural "false"
caps "false"
noprefix "false"

\end_inset

) below.
 Compositional monad transformers have general base runners, 
\begin_inset Formula $\text{brun}\left(\theta\right)$
\end_inset

, that satisfy the laws for any runner 
\begin_inset Formula $\theta:L\leadsto\text{Id}$
\end_inset

.
 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 also satisfy the monadic naturality laws.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The laws of runners are not symmetric with respect to the base monad and
 the foreign monad: the runners are parametric in the foreign monad but
 not in the base monad.
 In each case, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function must be monadically natural with respect to the 
\emph on
foreign
\emph default
 monad.
 So, the laws need to be written differently, depending on the choice of
 the base monad.
 Let us consider separately the cases where either 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

 is the base monad.
\end_layout

\begin_layout Paragraph
(a) If the base monad is 
\begin_inset Formula $L$
\end_inset

, 
\end_layout

\begin_layout Standard
the runners are defined by:
\begin_inset Formula 
\begin{align*}
\text{frun}\,(\phi^{:M\leadsto N}) & :L\circ M\leadsto L\circ N\quad,\quad\quad\text{frun}\,(\phi)=\phi^{\uparrow L}\quad;\\
\text{brun}\,(\theta^{:L\leadsto\text{Id}}) & :L\circ M\leadsto M\quad,\quad\quad\text{brun}\,(\theta)=\theta\quad.
\end{align*}

\end_inset

The laws of runners require that 
\begin_inset Formula $\text{frun}\,(\phi)$
\end_inset

 and 
\begin_inset Formula $\text{brun}\,(\theta)$
\end_inset

 must be monad morphisms, i.e., the identity and composition laws must hold:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{L\circ M}\bef\text{frun}\,(\phi)=\text{pu}_{L\circ N}\quad,\quad\quad\text{ftn}_{L\circ M}\bef\text{frun}\,(\phi)=\left(\text{frun}\,(\phi)\right)^{\uparrow M\uparrow L}\bef\text{frun}\,(\phi)\bef\text{ftn}_{L\circ N}\quad,\\
 & \text{pu}_{L\circ M}\bef\text{brun}\,(\theta)=\text{pu}_{M}\quad,\quad\quad\text{ftn}_{L\circ M}\bef\text{brun}\,(\theta)=\left(\text{brun}\,(\theta)\right)^{\uparrow M\uparrow L}\bef\text{brun}\,(\theta)\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

To derive these laws, we may use the identity and composition laws of monad
 morphisms for 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

.
 We also use Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as definitions of the monad 
\begin_inset Formula $T$
\end_inset

.
 Additionally, we assume the 
\series bold
monadic naturality
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law!of 
\family typewriter
swap
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 with respect to 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{sw}_{L,M}\bef\phi^{\uparrow L}=\phi\bef\text{sw}_{L,N}\quad,\quad\quad\text{sw}_{L,M}\bef\theta=\theta^{\uparrow M}\quad.\label{eq:monadic-naturality-of-sw-l-m}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.3pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[d]\sb(0.4){\phi} & L^{M^{A}}\ar[d]\sp(0.4){\phi^{\uparrow L}} & M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[rd]\sb(0.45){\theta^{\uparrow M}} & L^{M^{A}}\ar[d]\sp(0.4){\theta}\\
N^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,N}} & L^{N^{A}} &  & M^{A}
}
\]

\end_inset


\end_layout

\begin_layout Standard
The first law to be shown is the identity law of 
\begin_inset Formula $\text{frun}\,(\phi)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{L\circ N}:\quad & \text{pu}_{L\circ M}\bef\text{frun}\,(\phi)\\
\text{definitions of }\text{frun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\phi^{\uparrow L}}\\
\text{naturality law of }\text{pu}_{L}:\quad & =\gunderline{\text{pu}_{M}\bef\phi}\bef\text{pu}_{L}\\
\text{identity law of }\phi:\quad & =\text{pu}_{N}\bef\text{pu}_{L}\\
\text{definition of }\text{pu}_{L\circ N}:\quad & =\text{pu}_{L\circ N}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The next law to be verified is the composition law of 
\begin_inset Formula $\text{frun}\,(\phi)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{T}\bef\phi^{\uparrow L}:\quad & (\text{frun}\,(\phi))^{\uparrow M\uparrow L}\bef\text{frun}\,(\phi)\bef\text{ftn}_{L\circ N}\\
\text{definitions of }\text{frun}\text{ and }\text{ftn}_{L\circ N}:\quad & =\phi^{\uparrow L\uparrow M\uparrow L}\bef\gunderline{\phi^{\uparrow L}\bef\text{sw}_{L,N}^{\uparrow L}}\bef\text{ftn}_{L}\bef\text{ftn}_{N}^{\uparrow L}\\
\text{monadic naturality law of }\text{sw}_{L,M}:\quad & =\gunderline{\phi^{\uparrow L\uparrow M\uparrow L}\bef\text{sw}_{L,M}^{\uparrow L}}\bef\phi^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{N}^{\uparrow L}\\
\text{naturality law of }\text{sw}_{L,M}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\phi^{\uparrow M\uparrow L\uparrow L}\bef\phi^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\bef\text{ftn}_{N}^{\uparrow L}\\
\text{naturality law of }\text{ftn}_{L}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{(\phi^{\uparrow M}\bef\phi\bef\text{ftn}_{N})}^{\uparrow L}\\
\text{composition law of }\phi:\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\bef\phi^{\uparrow L}\\
\text{definition of }\text{ftn}_{T}:\quad & =\gunderline{\text{ftn}_{T}}\bef\phi^{\uparrow L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The next law is the identity law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{L\circ M}\bef\text{brun}\,\theta\\
\text{definitions of }\text{brun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\theta}\\
\text{identity law of }\theta:\quad & =\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The last law is the composition law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

.
 Begin with its right-hand side since it is longer:
\begin_inset Formula 
\begin{align*}
 & \left(\text{brun}\,(\theta)\right)^{\uparrow M\uparrow L}\bef\text{brun}\,(\theta)\bef\text{ftn}_{M}\\
\text{definition of }\text{brun}:\quad & =\theta^{\uparrow M\uparrow L}\bef\theta\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

We cannot simplify this expression any more, and yet it is still different
 from the left-hand side.
 So, let us transform the left-hand side, hoping to obtain the same expression.
 In particular, we need to move 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

 to the right and 
\begin_inset Formula $\theta$
\end_inset

 to the left: 
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{L\circ M}\bef\text{brun}\,(\theta)\\
\text{definitions of }\text{ftn}_{L\circ M}\text{ and }\text{brun}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\theta}\\
\text{naturality law of }\theta:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\theta}\bef\text{ftn}_{M}\\
\text{composition law of }\theta:\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\theta^{\uparrow L}}\bef\theta\bef\text{ftn}_{M}\\
\text{functor composition}:\quad & =\gunderline{\left(\text{sw}_{L,M}\bef\theta\right)^{\uparrow L}}\bef\theta\bef\text{ftn}_{M}\\
\text{monadic naturality law of }\text{sw}_{L,M}:\quad & =\gunderline{\theta^{\uparrow M\uparrow L}}\bef\theta\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

We have transformed both sides of the law into the same expression.
\end_layout

\begin_layout Standard
The functor laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 are:
\begin_inset Formula 
\[
\text{frun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{frun}\left(\phi\right)\bef\text{frun}\left(\chi\right)=\text{frun}\left(\phi\bef\chi\right)\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{frun}\left(\phi\right)=\phi^{\uparrow L}$
\end_inset

 in our case, these laws hold because they are the same as the functor laws
 of 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the nondegeneracy law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{flift}\bef\text{brun}\left(\theta\right)\\
\text{definitions of }\text{flift}\text{ and }\text{brun}:\quad & =\text{pu}_{L}\bef\theta\\
\text{identity law of }\theta:\quad & =\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Finally, we need to check the monadic naturality laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\phi^{:M\leadsto N}\bef\text{flift}_{L}^{N}=\text{flift}_{L}^{M}\bef(\phi^{:M\leadsto N})^{\uparrow L}\quad,\quad\quad(\phi^{:M\leadsto N})^{\uparrow L}\bef\text{brun}_{L}^{N}(\theta_{L})=\text{brun}_{L}^{M}(\theta_{L})\bef\phi^{:M\leadsto N}\quad.
\]

\end_inset

To verify these laws, use the naturality laws of 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

 and 
\begin_inset Formula $\theta_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \phi\bef\text{flift}=\gunderline{\phi\bef\text{pu}_{L}}=\text{pu}_{L}\bef\phi^{\uparrow L}=\text{flift}\bef\phi^{\uparrow L}\quad,\\
 & \phi^{\uparrow L}\bef\text{brun}\,(\theta_{L})=\gunderline{\phi^{\uparrow L}\bef\theta_{L}}=\theta_{L}\bef\phi=\text{brun}\,(\theta_{L})\bef\phi\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
(b) If the base monad is 
\begin_inset Formula $M$
\end_inset

, 
\end_layout

\begin_layout Standard
the runners are defined by:
\begin_inset Formula 
\begin{align*}
\text{frun}\,(\phi^{:L\leadsto N}) & :L\circ M\leadsto N\circ M\quad,\quad\quad\text{frun}\,(\phi)=\phi\quad;\\
\text{brun}\,(\theta^{:M\leadsto\text{Id}}) & :L\circ M\leadsto L\quad,\quad\quad\text{brun}\,(\theta)=\theta^{\uparrow L}\quad.
\end{align*}

\end_inset

The laws of runners require that 
\begin_inset Formula $\text{frun}\,(\phi)$
\end_inset

 and 
\begin_inset Formula $\text{brun}\,(\theta)$
\end_inset

 must be monad morphisms, i.e., the identity and composition laws must hold:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{L\circ M}\bef\text{frun}\,(\phi)=\text{pu}_{N\circ M}\quad,\quad\quad\text{ftn}_{L\circ M}\bef\text{frun}\,(\phi)=\left(\text{frun}\,(\phi)\right)^{\uparrow M\uparrow L}\bef\text{frun}\,(\phi)\bef\text{ftn}_{N\circ M}\quad,\\
 & \text{pu}_{L\circ M}\bef\text{brun}\,(\theta)=\text{pu}_{L}\quad,\quad\quad\text{ftn}_{L\circ M}\bef\text{brun}\,(\theta)=\left(\text{brun}\,(\theta)\right)^{\uparrow M\uparrow L}\bef\text{brun}\,(\theta)\bef\text{ftn}_{L}\quad.
\end{align*}

\end_inset

The monadic naturality laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 with respect to 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\chi$
\end_inset

 are:
\begin_inset Formula 
\begin{equation}
\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad.\label{eq:monadic-naturality-sw-n-m}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc}M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[d]\sb(0.4){\phi^{\uparrow M}} & L^{M^{A}}\ar[d]\sp(0.4){\phi} & M^{L^{A}}\ar[r]\sp(0.5){\text{sw}_{L,M}}\ar[rd]\sb(0.45){\theta} & L^{M^{A}}\ar[d]\sp(0.4){\theta^{\uparrow L}}\\
M^{N^{A}}\ar[r]\sp(0.5){\text{sw}_{N,M}} & N^{M^{A}} &  & L^{A}
}
\]

\end_inset


\end_layout

\begin_layout Standard
The first law to be proved is the identity law of 
\begin_inset Formula $\text{frun}\,(\phi)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{N\circ M}:\quad & \text{pu}_{L\circ M}\bef\text{frun}\,(\phi)\\
\text{definitions of }\text{frun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\phi}\\
\text{identity law of }\phi:\quad & =\text{pu}_{M}\bef\text{pu}_{N}\\
\text{definition of }\text{pu}_{N\circ M}:\quad & =\text{pu}_{N\circ M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The next law is the composition law of 
\begin_inset Formula $\text{frun}\,(\phi)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{T}\bef\phi:\quad & \left(\text{frun}\,(\phi)\right)^{\uparrow M\uparrow L}\bef\text{frun}\,(\phi)\bef\text{ftn}_{N\circ M}\\
\text{definitions of }\text{frun}\text{ and }\text{ftn}_{N\circ M}:\quad & =\phi^{\uparrow M\uparrow L}\bef\gunderline{\phi\bef\text{sw}_{N,M}^{\uparrow N}}\bef\text{ftn}_{N}\bef\text{ftn}_{M}^{\uparrow N}\\
\text{naturality law of }\phi:\quad & =\gunderline{\phi^{\uparrow M\uparrow L}\bef\text{sw}_{N,M}^{\uparrow L}}\bef\phi\bef\text{ftn}_{N}\bef\text{ftn}_{M}^{\uparrow N}\\
\text{monadic naturality of }\text{sw}_{N,M}\text{ raised to }L:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\phi^{\uparrow L}\bef\phi\bef\text{ftn}_{N}}\bef\text{ftn}_{M}^{\uparrow N}\\
\text{composition law of }\phi:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\phi\bef\text{ftn}_{M}^{\uparrow N}}\\
\text{naturality law of }\phi:\quad & =\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\bef\phi\\
\text{definition of }\text{ftn}_{T}:\quad & =\gunderline{\text{ftn}_{T}}\bef\phi\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The next law is the identity law of 
\begin_inset Formula $\text{brun}\left(\theta\right)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{L}:\quad & \text{pu}_{L\circ M}\bef\text{brun}\,(\theta)\\
\text{definitions of }\text{brun}\text{ and }\text{pu}_{L\circ M}:\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{L}\bef\theta^{\uparrow L}}=\gunderline{\text{pu}_{M}\bef\theta}\bef\text{pu}_{L}\\
\text{identity law of }\theta:\quad & =\text{pu}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The last law is the composition law of 
\begin_inset Formula $\text{brun}\left(\theta\right)$
\end_inset

.
 Begin with its right-hand side:
\begin_inset Formula 
\begin{align*}
 & \left(\text{brun}\,(\theta)\right)^{\uparrow M\uparrow L}\bef\text{brun}\,(\theta)\bef\text{ftn}_{L}\\
\text{definition of }\text{brun}:\quad & =\theta^{\uparrow L\uparrow M\uparrow L}\bef\theta^{\uparrow L}\bef\text{ftn}_{L}\\
\text{functor composition}:\quad & =(\theta^{\uparrow L\uparrow M}\bef\theta)^{\uparrow L}\bef\text{ftn}_{L}\\
\text{naturality law of }\theta:\quad & =(\theta\bef\theta^{\uparrow L})^{\uparrow L}\bef\text{ftn}_{L}\quad.
\end{align*}

\end_inset

We now transform the left-hand side, aiming to obtain the same expression.
 We need to move 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

 to the right and 
\begin_inset Formula $\theta$
\end_inset

 to the left: 
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\theta^{\uparrow L}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}:\quad & \text{ftn}_{L\circ M}\bef\text{brun}\,(\theta)\\
\text{definitions of }\text{ftn}_{L\circ M}\text{ and }\text{brun}:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\text{ftn}_{L}\bef\gunderline{\text{ftn}_{M}^{\uparrow L}\bef\theta^{\uparrow L}}\\
\text{composition law of }\theta:\quad & =\text{sw}_{L,M}^{\uparrow L}\bef\gunderline{\text{ftn}_{L}\bef\left(\theta\bef\theta\right)^{\uparrow L}}=\gunderline{\text{sw}_{L,M}^{\uparrow L}\bef\left(\theta\bef\theta\right)^{\uparrow L\uparrow L}}\bef\text{ftn}_{L}\\
\text{functor composition}:\quad & =\gunderline{(\text{sw}_{L,M}\bef\theta^{\uparrow L})}^{\uparrow L}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\\
\text{monadic naturality law of }\text{sw}_{L,M}:\quad & =\gunderline{\theta^{\uparrow L}}\bef\theta^{\uparrow L\uparrow L}\bef\text{ftn}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The functor laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 are:
\begin_inset Formula 
\[
\text{frun}\left(\text{id}\right)=\text{id}\quad,\quad\quad\text{frun}\left(\phi\right)\bef\text{frun}\left(\chi\right)=\text{frun}\left(\phi\bef\chi\right)\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{frun}\left(\phi\right)=\phi$
\end_inset

 in our case, these laws are satisfied.
\end_layout

\begin_layout Standard
To verify the nondegeneracy law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{flift}\bef\text{brun}\left(\theta\right)\\
\text{definitions of }\text{flift}\text{ and }\text{brun}:\quad & =\text{pu}_{M}^{\uparrow L}\bef\theta^{\uparrow L}=\text{id}^{\uparrow L}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Finally, we need to check the monadic naturality laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\phi^{:L\leadsto K}\bef\text{flift}_{M}^{K}=\text{flift}_{M}^{L}\bef\phi^{:L\leadsto K}\quad,\quad\quad\phi^{:L\leadsto K}\bef\text{brun}_{M}^{K}(\theta_{M})=\text{brun}_{M}^{L}(\theta_{M})\bef\phi^{:L\leadsto K}\quad.
\]

\end_inset

To verify these laws, use the naturality law of 
\begin_inset Formula $\phi^{:L\leadsto K}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \phi\bef\text{flift}_{M}^{K}=\gunderline{\phi\bef\text{pu}_{M}^{\uparrow K}}=\text{pu}_{M}^{\uparrow L}\bef\phi=\text{flift}_{N}^{L}\bef\phi\quad,\\
 & \phi\bef\text{brun}_{M}^{K}(\theta_{M})=\gunderline{\phi\bef\theta_{M}^{\uparrow K}}=\theta_{M}^{\uparrow L}\bef\phi=\text{brun}_{M}^{L}(\theta_{M})\bef\phi\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Summary of results
\end_layout

\begin_layout Standard
The following two statements summarize the derivations in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Monad-transformers-that-use-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-outside-transformer-swap-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (composed-outside)
\end_layout

\begin_layout Standard
For a base monad 
\begin_inset Formula $L$
\end_inset

 and a foreign monad 
\begin_inset Formula $M$
\end_inset

, the functor composition 
\begin_inset Formula $L\circ M$
\end_inset

 is a lawful monad transformer if a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function 
\begin_inset Formula $\text{sw}_{L,M}:M\circ L\leadsto L\circ M$
\end_inset

 exists, satisfying the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the monadic naturality laws:
\begin_inset Formula 
\[
\text{sw}_{L,M}\bef\phi^{\uparrow L}=\phi\bef\text{sw}_{L,N}\quad,\quad\quad\text{sw}_{L,M}\bef\theta=\theta^{\uparrow M}\quad,
\]

\end_inset

with arbitrary monad morphisms 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:L\leadsto\text{Id}$
\end_inset

.
 An additional law, 
\begin_inset Formula $\text{sw}_{L,\text{Id}}=\text{id}$
\end_inset

, follows from the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-inside-transformer-swap-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (composed-inside)
\end_layout

\begin_layout Standard
For a base monad 
\begin_inset Formula $M$
\end_inset

 and a foreign monad 
\begin_inset Formula $L$
\end_inset

, the functor composition 
\begin_inset Formula $L\circ M$
\end_inset

 is a lawful monad transformer if a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function 
\begin_inset Formula $\text{sw}_{L,M}:M\circ L\leadsto L\circ M$
\end_inset

 exists, satisfying the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the monadic naturality laws:
\begin_inset Formula 
\[
\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad,
\]

\end_inset

with respect to arbitrary monad morphisms 
\begin_inset Formula $\phi:L\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:M\leadsto\text{Id}$
\end_inset

.
 An additional law, 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

, follows from the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
In many cases, Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 make monad transformer proofs quicker because the 6 laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 use simpler types and replace the 18 monad transformer laws.
\end_layout

\begin_layout Section
Composed-inside transformers.
 Linear monads
\begin_inset CommandInset label
LatexCommand label
name "sec:transformers-linear-monads"

\end_inset


\end_layout

\begin_layout Standard
In the previous section, we derived a number of properties common to all
 compositional transformers.
 We will now use those properties to prove the laws of composed-inside transform
ers.
 All those transformers have a 
\begin_inset Quotes eld
\end_inset

linear
\begin_inset Quotes erd
\end_inset

 monad as their base monad.
\end_layout

\begin_layout Standard
A monad 
\begin_inset Formula $M$
\end_inset

 is
\series bold
 linear
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!linear
\end_layout

\end_inset

 if its type is of the form 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are fixed types and 
\begin_inset Formula $Q$
\end_inset

 is a monoid.
 (The name 
\begin_inset Quotes eld
\end_inset

linear
\begin_inset Quotes erd
\end_inset

 is motivated by considering the polynomial 
\begin_inset Formula $P+Q\times A$
\end_inset

, which is linear in the parameter 
\begin_inset Formula $A$
\end_inset

.) Well-known examples of linear monads are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

.
 The effect of the monad 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

 combines the effects of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monads: a computation that can either succeed and append a log message
 (of type 
\begin_inset Formula $Q$
\end_inset

), or fail (with an error of type 
\begin_inset Formula $P$
\end_inset

).
\end_layout

\begin_layout Standard
A different (but also linear) monad is obtained from the composition of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

.
 The type constructor of this monad is 
\begin_inset Formula $Q\times\left(P+A\right)$
\end_inset

.
 This monad's effect is to append to a monoid 
\begin_inset Formula $Q$
\end_inset

 and, at the same time, to compute a value of type 
\begin_inset Formula $A$
\end_inset

 or to fail with an error of type 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
A composition of two linear monads 
\begin_inset Formula $M_{1}^{A}\triangleq P_{1}+Q_{1}\times A$
\end_inset

 and 
\begin_inset Formula $M_{2}^{A}\triangleq P_{2}+Q_{2}\times A$
\end_inset

 is again linear:
\begin_inset Formula 
\begin{align*}
 & P_{1}+Q_{1}\times\left(P_{2}+Q_{2}\times A\right)\\
\text{expand brackets}:\quad & \cong\gunderline{P_{1}+Q_{1}\times P_{2}}+\gunderline{Q_{1}\times Q_{2}}\times A\\
\text{define new }P\text{ and }Q:\quad & \cong P+Q\times A\quad.
\end{align*}

\end_inset

By assumption, 
\begin_inset Formula $Q_{1}$
\end_inset

 and 
\begin_inset Formula $Q_{2}$
\end_inset

 are monoids, so 
\begin_inset Formula $Q\triangleq Q_{1}\times Q_{2}$
\end_inset

 is also a monoid.
\end_layout

\begin_layout Standard
For a linear monad 
\begin_inset Formula $M$
\end_inset

 and any foreign monad 
\begin_inset Formula $L$
\end_inset

, the functor composition 
\begin_inset Formula $L\circ M$
\end_inset

 is a monad.
 For example, the type constructor for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OptionT
\end_layout

\end_inset

 monad transformer can be written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type OptionT[L[_], A] = L[Option[A]]
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type constructor must be composed 
\emph on
inside
\emph default
 the foreign monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

.
 This is the case for all linear monads.
 Also, linear monads are the only known examples of monads whose transformers
 are defined by composing inside the foreign monad.
\end_layout

\begin_layout Subsection
Definitions of 
\family typewriter
swap
\family default
 and 
\family typewriter
flatten
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $T_{M}^{L,A}=L^{M^{A}}$
\end_inset

 is a lawful monad transformer for the base monad 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

, we will implement a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function having the type signature:
\begin_inset Formula 
\[
\text{sw}_{L,M}:M^{L^{A}}\rightarrow L^{M^{A}}\quad,
\]

\end_inset

for the base monad 
\begin_inset Formula $M$
\end_inset

 and an arbitrary foreign monad 
\begin_inset Formula $L$
\end_inset

.
 We will then prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 satisfies all the laws given in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This will guarantee that 
\begin_inset Formula $T_{M}^{L,A}$
\end_inset

 is a lawful monad transformer.
\end_layout

\begin_layout Standard
Expanding the definition of the type constructor 
\begin_inset Formula $M^{\bullet}$
\end_inset

, we can write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 as: 
\begin_inset Formula 
\[
\text{sw}_{L,M}:P+Q\times L^{A}\rightarrow L^{P+Q\times A}\quad.
\]

\end_inset

We can map 
\begin_inset Formula $P$
\end_inset

 to 
\begin_inset Formula $L^{P}$
\end_inset

 by applying 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

.
 We can also map 
\begin_inset Formula $Q\times L^{A}\rightarrow L^{Q\times A}$
\end_inset

 since 
\begin_inset Formula $L$
\end_inset

 is a functor:
\begin_inset Formula 
\[
q\times l\rightarrow l\triangleright\left(a\rightarrow q\times a\right)^{\uparrow L}\quad.
\]

\end_inset

 It remains to combine these two functions.
 In the matrix notation, we write:
\begin_inset Formula 
\begin{equation}
\text{sw}_{L,M}=\,\begin{array}{|c||c|}
 & L^{P+Q\times A}\\
\hline P & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
Q\times L^{A} & q\times l\rightarrow l\triangleright(a^{:A}\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\quad.\label{eq:single-valued-monad-def-of-swap}
\end{equation}

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type M[A, P, Q] = Either[P, (Q, A)]
\end_layout

\begin_layout Plain Layout

def swap[L[_]: Monad, A, P, Q]: M[L[A]] => L[M[A]] = {
\end_layout

\begin_layout Plain Layout

  case Left(p) => Monad[L].pure(Left(p))
\end_layout

\begin_layout Plain Layout

  case Right((q, la)) => la.map(a => Right((q, a)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function, we define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 methods for the transformed monad 
\begin_inset Formula $T$
\end_inset

 (short notation 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

) by the standard formulas:
\begin_inset Formula 
\[
\text{pu}_{T}=\text{pu}_{M}\bef\text{pu}_{L}\quad,\quad\quad\text{ftn}_{T}=\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\bef\text{ftn}_{M}^{\uparrow L}\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pure[L[_]: Monad, A, P, Q: Monoid](x: A): L[M[A]] =
\end_layout

\begin_layout Plain Layout

  Monad[L].pure(Right((Monoid[Q].empty, x)))
\end_layout

\begin_layout Plain Layout

def flatten[L[_]: Monad, A, P, Q: Monoid](tt: L[M[L[M[A]]]]): L[M[A]] =
\end_layout

\begin_layout Plain Layout

  tt.map(swap).flatten.map(_.flatten) // Assuming suitable implicits in scope.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The laws of 
\family typewriter
swap
\family default
.
 Proofs
\end_layout

\begin_layout Standard
To verify that the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 hold, we will need to use the code for the methods 
\begin_inset Formula $\text{fmap}_{M}$
\end_inset

, 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

, and 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 of the monad 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & f^{\uparrow M}=\,\begin{array}{|c||cc|}
 & P & Q\times B\\
\hline P & \text{id} & \bbnum 0\\
Q\times A & \bbnum 0\enskip & q\times a\rightarrow q\times f(a)
\end{array}\quad,\\
 & \text{pu}_{M}(a^{:A})=0^{:P}+q_{0}\times a\quad,\quad\text{or equivalently:}\quad\quad\text{pu}_{M}=\,\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline A & \bbnum 0\enskip & a\rightarrow q_{0}\times a
\end{array}\quad,
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{M}^{:M^{M^{A}}\rightarrow M^{A}}=\,\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline P & \text{id} & \bbnum 0\\
Q\times P & q\times p\rightarrow p & \bbnum 0\\
Q\times Q\times A & \bbnum 0 & q_{1}\times q_{2}\times a\rightarrow\left(q_{1}\oplus q_{2}\right)\times a
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
f^{\uparrow M} & =\,\begin{array}{|c||cc|}
 & P & Q\times B\\
\hline P & \text{id} & \bbnum 0\\
Q\times A & \bbnum 0\enskip & q\times a\rightarrow q\times f(a)
\end{array}\quad,\\
\text{pu}_{M}(a^{:A}) & =0^{:P}+q_{0}\times a\quad,\quad\text{or equivalently:}\quad\quad\text{pu}_{M}=\,\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline A & \bbnum 0\enskip & a\rightarrow q_{0}\times a
\end{array}\quad,\\
\text{ftn}_{M}^{:M^{M^{A}}\rightarrow M^{A}} & =\,\begin{array}{|c||cc|}
 & P & Q\times A\\
\hline P & \text{id} & \bbnum 0\\
Q\times P & q\times p\rightarrow p & \bbnum 0\\
Q\times Q\times A & \bbnum 0 & q_{1}\times q_{2}\times a\rightarrow\left(q_{1}\oplus q_{2}\right)\times a
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We do not have to verify naturality since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is defined as a fully parametric function.
\end_layout

\begin_layout Paragraph
The inner identity law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{L}^{\uparrow M}\bef\text{sw}=\text{pu}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{L}^{\uparrow M}\bef\text{sw}=\,\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times a\rightarrow q\times\text{pu}_{L}(a)
\end{array}\right|\,\bef\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(a^{:A}\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\right|\\
\text{composition}:\quad & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times a\rightarrow a\triangleright\gunderline{\text{pu}_{L}\bef(a^{:A}\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}}
\end{array}\right|\\
\text{pu}_{L}\text{'s naturality}:\quad & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
(q\times a\rightarrow\bbnum 0^{:P}+q\times a)\bef\text{pu}_{L}
\end{array}\right|\,=\,\begin{array}{|c||c|}
P & x^{:P}\rightarrow x+\bbnum 0^{:Q\times A}\\
Q\times A & q\times a\rightarrow\bbnum 0^{:P}+q\times a
\end{array}\,\bef\text{pu}_{L}\\
\text{matrix notation}:\quad & =\text{id}\bef\text{pu}_{L}=\text{pu}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
The outer identity law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}\bef\text{sw}=\,\left\Vert \begin{array}{cc}
\bbnum 0 & l^{:L^{A}}\rightarrow q_{0}\times l\end{array}\right|\,\bef\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(x^{:A}\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}
\end{array}\right|\\
\text{composition}:\quad & =l^{:L^{A}}\rightarrow l\triangleright(\gunderline{x^{:A}\rightarrow\bbnum 0^{:P}+q_{0}\times x})^{\uparrow L}\\
\text{definition of }\text{pu}_{M}:\quad & =l\rightarrow l\triangleright\text{pu}_{M}^{\uparrow L}=\text{pu}_{M}^{\uparrow L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
The inner interchange law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{ftn}_{L}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align}
\text{ftn}_{L}^{\uparrow M}\bef\text{sw}= & \,\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\rightarrow q\times(l\triangleright\text{ftn}_{L})
\end{array}\right|\,\bef\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\right|\nonumber \\
 & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright\text{ftn}_{L}\bef(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\right|\quad,\label{eq:l-interchange-derivation1}\\
\text{sw}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}= & \,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\right|\,\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\nonumber \\
 & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\\
\big(q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\big)\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}
\end{array}\right|\quad.\nonumber 
\end{align}

\end_inset

Let us simplify each expression in the last column separately and then compare
 with the column in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Simplify the upper expression:
\begin_inset Formula 
\begin{align*}
 & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\\
\text{pu}_{L}\text{'s naturality}:\quad & =(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{sw}\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{L}}\\
\text{identity law of }L:\quad & =(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{sw}=x\rightarrow\gunderline{(x^{:P}+\bbnum 0^{:Q\times A})\triangleright\text{sw}}\\
\text{definition of }\text{sw}:\quad & =x\rightarrow(x+\bbnum 0)\triangleright\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\right|\,=(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\quad.
\end{align*}

\end_inset

This equals the upper expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Simplify the lower expression:
\begin_inset Formula 
\begin{align}
 & \big(q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\big)\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\nonumber \\
\triangleright\text{-notation}:\quad & =q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}\bef\text{ftn}_{L}\quad.\label{eq:l-interchange-simplify-2}
\end{align}

\end_inset

Simplify the expression 
\begin_inset Formula $(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}$
\end_inset

 separately:
\begin_inset Formula 
\begin{align}
 & (a\rightarrow\bbnum 0^{:P}+q\times a)\bef\text{sw}\nonumber \\
\text{compute composition}:\quad & =a\rightarrow\gunderline{(\bbnum 0^{:P}+q\times a)\triangleright\text{sw}}\nonumber \\
\text{definition of }\text{sw}:\quad & =\gunderline{a\rightarrow a\triangleright(}x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\nonumber \\
\text{unexpand function}:\quad & =(x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\quad.\label{eq:l-interchange-simplify-3}
\end{align}

\end_inset

Then we continue simplifying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-simplify-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & q\times l\rightarrow l\triangleright\gunderline{(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\text{sw}^{\uparrow L}}\bef\text{ftn}_{L}\\
\text{use Eq.~(\ref{eq:l-interchange-simplify-3})}:\quad & =q\times l\rightarrow l\triangleright\gunderline{(x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L\uparrow L}\bef\text{ftn}_{L}}\\
\text{naturality law of }\text{ftn}_{L}:\quad & =q\times l\rightarrow l\triangleright\text{ftn}_{L}\bef(x\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\quad.
\end{align*}

\end_inset

This equals the lower expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:l-interchange-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) after renaming the bound variable 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Paragraph
The outer interchange law
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}$
\end_inset

.
 The left-hand side is written using the matrices for 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{ftn}_{M}\bef\text{sw}=\,\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
q\times p\rightarrow p & \bbnum 0\\
\bbnum 0 & q_{1}\times q_{2}\times a\rightarrow\left(q_{1}\oplus q_{2}\right)\times a
\end{array}\right|\,\bef\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(x\rightarrow\bbnum 0+q\times x)^{\uparrow L}
\end{array}\right|\nonumber \\
 & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
\left(q\times p\rightarrow p+\bbnum 0\right)\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times a\rightarrow a\triangleright(x\rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}
\end{array}\right|\quad.\label{eq:m-interchange-law-of-swap-linear-monads-left-hand-side}
\end{align}

\end_inset

We cannot simplify this matrix, so we hope to transform the right-hand side
 (
\begin_inset Formula $\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L}$
\end_inset

) to the same matrix.
 Begin by writing the matrix for 
\begin_inset Formula $\text{sw}^{\uparrow M}$
\end_inset

, expanding the rows for the input type 
\begin_inset Formula $M^{M^{L^{A}}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow M}=\,\begin{array}{|c||cc|}
 & P & Q\times L^{M^{A}}\\
\hline P & \text{id} & \bbnum 0\\
Q\times P & \bbnum 0 & q\times p\rightarrow q\times\text{sw}\left(p+\bbnum 0\right)\\
Q\times Q\times L^{A} & \bbnum 0 & q_{1}\times q_{2}\times l\rightarrow q_{1}\times\text{sw}\left(\bbnum 0+q_{2}\times l\right)
\end{array}\\
 & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times p\rightarrow q\times\text{pu}_{L}\left(p+\bbnum 0\right)\\
\bbnum 0 & q_{1}\times q_{2}\times l\rightarrow q_{1}\times(l\triangleright(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L})
\end{array}\quad.
\end{align*}

\end_inset

Then compute the composition 
\begin_inset Formula $\text{sw}^{\uparrow M}\bef\text{sw}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow M}\bef\text{sw}=\,\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times p\rightarrow q\times\text{pu}_{L}\left(p+\bbnum 0\right)\\
\bbnum 0 & q_{1}\times q_{2}\times l\rightarrow q_{1}\times(l\triangleright(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L})
\end{array}\right|\,\bef\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times l\rightarrow(l\triangleright(x\rightarrow\bbnum 0+q\times x)^{\uparrow L})
\end{array}\right|\\
 & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\rightarrow\left(p+\bbnum 0\right)\triangleright\text{pu}_{L}\bef(x^{:M^{A}}\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0^{:P}+q_{1}\times x)^{\uparrow L}\bef(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}
\end{array}\right|
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
 & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\rightarrow(\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\triangleright\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x))^{\uparrow L}
\end{array}\right|\quad.
\end{align*}

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow M}\bef\text{sw}=\,\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times p\rightarrow q\times\text{pu}_{L}\left(p+\bbnum 0\right)\\
\bbnum 0 & q_{1}\times q_{2}\times l\rightarrow q_{1}\times(l\triangleright(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L})
\end{array}\right|\,\bef\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times l\rightarrow(l\triangleright(x\rightarrow\bbnum 0+q\times x)^{\uparrow L})
\end{array}\right|\\
 & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\rightarrow\left(p+\bbnum 0\right)\triangleright\text{pu}_{L}\bef(x^{:M^{A}}\rightarrow\bbnum 0^{:P}+q\times x)^{\uparrow L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0^{:P}+q_{1}\times x)^{\uparrow L}\bef(x\rightarrow\bbnum 0+q_{2}\times x)^{\uparrow L}
\end{array}\right|\\
 & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
q\times p\rightarrow(\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\triangleright\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x))^{\uparrow L}
\end{array}\right|\quad.
\end{align*}

\end_inset


\end_layout

\end_inset

Now we need to post-compose 
\begin_inset Formula $\text{ftn}_{M}^{\uparrow L}$
\end_inset

 with this column:
\begin_inset Formula 
\begin{align*}
\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow L} & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\\
(q\times p\rightarrow\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\bef\gunderline{\text{pu}_{L}\bef\text{ftn}_{M}^{\uparrow L}}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x))^{\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}
\end{array}\right|\\
\text{naturality law of }\text{pu}_{L}:\quad & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{ftn}_{M}\bef\text{pu}_{L}\\
(q\times p\rightarrow\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))\bef\text{ftn}_{M}\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\gunderline{\text{ftn}_{M}\left(\bbnum 0+q_{1}\times(\bbnum 0+q_{2}\times x)\right)})^{\uparrow L}
\end{array}\right|\\
\text{compute }\text{ftn}_{M}(...):\quad & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow\text{ftn}_{M}(x+\bbnum 0))\bef\text{pu}_{L}\\
(q\times p\rightarrow\gunderline{\text{ftn}_{M}(\bbnum 0^{:P}+q\times\left(p+\bbnum 0\right))})\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}
\end{array}\right|\\
\text{compute }\text{ftn}_{M}(...):\quad & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0)\bef\text{pu}_{L}\\
(q\times p\rightarrow p+\bbnum 0)\bef\text{pu}_{L}\\
q_{1}\times q_{2}\times l\rightarrow l\triangleright(x^{:M^{A}}\rightarrow\bbnum 0+\left(q_{1}\oplus q_{2}\right)\times x)^{\uparrow L}
\end{array}\right|\quad.
\end{align*}

\end_inset

After renaming 
\begin_inset Formula $l$
\end_inset

 to 
\begin_inset Formula $a$
\end_inset

, this is the same as the column in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:m-interchange-law-of-swap-linear-monads-left-hand-side"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which proves the law.
\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
We need to verify the laws of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-inside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
\text{sw}_{\text{Id},M}=\text{id}\quad,\quad\quad\text{sw}_{L,M}\bef\phi=\phi^{\uparrow M}\bef\text{sw}_{N,M}\quad,\quad\quad\text{sw}_{L,M}\bef\theta^{\uparrow L}=\theta\quad,
\]

\end_inset

for arbitrary monad morphisms 
\begin_inset Formula $\phi:L\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:M\leadsto\text{Id}$
\end_inset

.
\end_layout

\begin_layout Standard
The first law is the swap identity law, 
\begin_inset Formula $\text{sw}_{\text{Id},M}=\text{id}$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{\text{Id},M}\\
\text{Eq.~(\ref{eq:single-valued-monad-def-of-swap}) with }L=\text{Id}:\quad & =\,\begin{array}{|c||c|}
P & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{\text{Id}}\\
Q\times\text{Id}^{A} & q\times l\rightarrow l\triangleright(a^{:A}\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow\text{Id}}
\end{array}\\
\text{matrix notation}:\quad & =\,\,\begin{array}{|c||c|}
P & x^{:P}\rightarrow x+\bbnum 0^{:Q\times A}\\
Q\times A & q\times a\rightarrow\bbnum 0^{:P}+q\times a
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Begin with the left-hand side of the second law:
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{L,M}\bef\phi\\
\text{definition of }\text{sw}_{L,M}:\quad & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\right|\gunderline{\bef\phi}\\
\text{compose with }\phi:\quad & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\bef\phi\\
q\times l\rightarrow l\triangleright\gunderline{(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\phi}
\end{array}\right|
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{naturality law of }\phi:\quad & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times l\rightarrow l\triangleright\phi\bef(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{sw}_{L,M}\bef\phi\\
\text{definition of }\text{sw}_{L,M}:\quad & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}
\end{array}\right|\gunderline{\bef\phi}\\
\text{compose with }\phi:\quad & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{L}\bef\phi\\
q\times l\rightarrow l\triangleright\gunderline{(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\phi}
\end{array}\right|\\
\text{naturality law of }\phi:\quad & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times l\rightarrow l\triangleright\phi\bef(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\quad.
\end{align*}

\end_inset

The right-hand side is:
\begin_inset Formula 
\begin{align*}
 & \phi^{\uparrow M}\bef\text{sw}_{N,M}=\,\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\rightarrow q\times\left(l\triangleright\phi\right)
\end{array}\right|\,\bef\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times n\rightarrow n\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\\
\text{composition}:\quad & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\text{pu}_{N}\\
q\times l\rightarrow l\triangleright\phi\bef(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow N}
\end{array}\right|\quad.
\end{align*}

\end_inset

Both sides of the second law are now shown to be equal.
\end_layout

\begin_layout Standard
The left-hand side of the third law is:
\begin_inset Formula 
\begin{align}
 & \text{sw}_{L,M}\bef\theta^{\uparrow L}\nonumber \\
\text{compose with }\theta^{\uparrow L}:\quad & =\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}\bef\theta^{\uparrow L}}\\
q\times l\rightarrow l\triangleright(a\rightarrow\bbnum 0^{:P}+q\times a)^{\uparrow L}\bef\theta^{\uparrow L}
\end{array}\right|\nonumber \\
\text{naturality law of }\text{pu}_{L}:\quad & =\,\,\left\Vert \begin{array}{c}
(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\theta\bef\text{pu}_{L}\\
q\times l\rightarrow l\triangleright\big(a\rightarrow\theta(\bbnum 0^{:P}+q\times a)\big)^{\uparrow L}
\end{array}\right|\quad.\label{eq:linear-monads-monadic-naturality-of-swap-2}
\end{align}

\end_inset

We expect this to equal the right-hand side, which we write as:
\begin_inset Formula 
\begin{align}
 & m^{:M^{L^{A}}}\rightarrow\theta(m)\nonumber \\
\text{matrix notation}:\quad & =\,\left\Vert \begin{array}{c}
x^{:P}\rightarrow\theta(x+\bbnum 0^{:Q\times L^{A}})\\
q\times l\rightarrow\theta(\bbnum 0^{:P}+q\times l)
\end{array}\right|\quad.\label{eq:linear-monads-monadic-naturality-of-swap-1}
\end{align}

\end_inset

Now consider each line in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) separately.
 The upper line can be transformed as:
\begin_inset Formula 
\begin{align*}
 & (x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\theta\bef\text{pu}_{L}}\\
\text{naturality law of }\theta:\quad & =(x^{:P}\rightarrow x+\bbnum 0^{:Q\times A})\bef\gunderline{\text{pu}_{L}^{\uparrow M}}\bef\theta\\
\text{definition of }^{\uparrow M}:\quad & =x^{:P}\rightarrow\,\left|\begin{array}{cc}
x\enskip & \bbnum 0\end{array}\right|\,\triangleright\,\left\Vert \begin{array}{cc}
\text{id} & \bbnum 0\\
\bbnum 0 & q\times l\rightarrow q\times\text{pu}_{L}(l)
\end{array}\right|\,\bef\theta\\
\text{matrix composition}:\quad & =x^{:P}\rightarrow(x+\bbnum 0^{:Q\times L^{A}})\triangleright\theta\quad.
\end{align*}

\end_inset

This is now equal to the upper line of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
To proceed with the proof for the lower line of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to evaluate the monad morphism 
\begin_inset Formula $\theta:M^{A}\rightarrow A$
\end_inset

 on a specific value of type 
\begin_inset Formula $M^{A}$
\end_inset

 of the form 
\begin_inset Formula $\bbnum 0+q\times a$
\end_inset

.
 We note that the value 
\begin_inset Formula $\theta(\bbnum 0+q\times a)$
\end_inset

 must be of type 
\begin_inset Formula $A$
\end_inset

 and must be computed in the same way for all types 
\begin_inset Formula $A$
\end_inset

, because 
\begin_inset Formula $\theta$
\end_inset

 is a natural transformation.
 It seems clear that the result cannot depend on the value 
\begin_inset Formula $q^{:Q}$
\end_inset

 since 
\begin_inset Formula $Q$
\end_inset

 is a type unrelated to 
\begin_inset Formula $A$
\end_inset

.
 In other words, we expect that 
\begin_inset Formula $\theta(\bbnum 0+q\times a)=a$
\end_inset

 as a consequence of naturality of 
\begin_inset Formula $\theta$
\end_inset

.
 To derive this formally, we use the trick of starting with a unit type
 (
\begin_inset Formula $\bbnum 1$
\end_inset

) and then mapping it to 
\begin_inset Formula $A$
\end_inset

 within the naturality law.
 For any values 
\begin_inset Formula $q^{:Q}$
\end_inset

 and 
\begin_inset Formula $a^{:A}$
\end_inset

, we define:
\begin_inset Formula 
\[
m^{:P+Q\times A}\triangleq\bbnum 0^{:P}+q\times a\quad,\quad\quad m_{1}^{:P+Q\times\bbnum 1}\triangleq\bbnum 0^{:P}+q\times1\quad.
\]

\end_inset

We can compute 
\begin_inset Formula $m$
\end_inset

 from 
\begin_inset Formula $m_{1}$
\end_inset

 if we replace 
\begin_inset Formula $1$
\end_inset

 by 
\begin_inset Formula $a$
\end_inset

 under the functor 
\begin_inset Formula $M$
\end_inset

.
 To write this as a formula, define the function 
\begin_inset Formula $f^{:\bbnum 1\rightarrow A}$
\end_inset

 as 
\begin_inset Formula $f\triangleq\left(\_\rightarrow a\right)$
\end_inset

 using the fixed value 
\begin_inset Formula $a$
\end_inset

.
 Then we have 
\begin_inset Formula $m=m_{1}\triangleright f^{\uparrow M}$
\end_inset

.
 Now we apply both sides of the naturality law 
\begin_inset Formula $f^{\uparrow M}\bef\theta=\theta\bef f$
\end_inset

 to the value 
\begin_inset Formula $m_{1}$
\end_inset

:
\begin_inset Formula 
\[
m_{1}\triangleright f^{\uparrow M}\bef\theta=m_{1}\triangleright\theta\bef f\quad.
\]

\end_inset

Simplify the left-hand side to:
\begin_inset Formula 
\[
\gunderline{m_{1}\triangleright f^{\uparrow M}}\bef\theta=m\triangleright\theta=\theta(\bbnum 0^{:P}+q\times a)\quad.
\]

\end_inset

Simplify the right-hand side to:
\begin_inset Formula 
\[
m_{1}\triangleright\theta\bef f=f\left(\theta\left(m_{1}\right)\right)=a\quad,
\]

\end_inset

since the function 
\begin_inset Formula $f$
\end_inset

 always returns 
\begin_inset Formula $a$
\end_inset

.
 So, we have:
\begin_inset Formula 
\begin{equation}
\theta(\bbnum 0^{:P}+q\times a)=a\quad.\label{eq:runner-on-linear-monads}
\end{equation}

\end_inset

We can now compute the second line in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as:
\begin_inset Formula 
\begin{align*}
 & q\times l\rightarrow l\triangleright\big(a\rightarrow\theta(\bbnum 0^{:P}+q\times a)\big)^{\uparrow L}\\
\text{use Eq.~(\ref{eq:runner-on-linear-monads})}:\quad & =q\times l\rightarrow l\,\gunderline{\triangleright\,\big(a\rightarrow a\big)^{\uparrow L}}=q\times l\rightarrow l\triangleright\text{id}^{\uparrow L}=q\times l\rightarrow l\quad.
\end{align*}

\end_inset

The second line in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:linear-monads-monadic-naturality-of-swap-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is the same function, namely 
\begin_inset Formula $q\times l\rightarrow l$
\end_inset

.
\end_layout

\begin_layout Standard
This concludes the proof of the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 for linear monads.
 It follows that all linear monads have lawful monad transformers that compose
 inside the foreign monad.
\end_layout

\begin_layout Subsection
Composition of transformers for linear monads
\end_layout

\begin_layout Standard
We have just shown that any linear monad 
\begin_inset Formula $M^{A}\triangleq P+Q\times A$
\end_inset

 has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function obeying the laws necessary for a composed-inside transformer.
 The other type of linear monad is 
\begin_inset Formula $W^{A}\triangleq Q\times\left(P+A\right)$
\end_inset

.
 Do we need to show separately that the monad 
\begin_inset Formula $W$
\end_inset

 has a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function? No; instead we may use the stacking property of monad transformers
 (see Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-any-number-of-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The monad 
\begin_inset Formula $W$
\end_inset

 is a functor composition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad 
\begin_inset Formula $Q\times A$
\end_inset

 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad 
\begin_inset Formula $P+A$
\end_inset

, which is the same as applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad's transformer to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad.
 Because of the transformer stacking property, the monad transformer of
 
\begin_inset Formula $W$
\end_inset

 works as a composed-inside transformer.
\end_layout

\begin_layout Standard
We can show that the functor composition of any two linear monads has a
 composed-inside transformer.
 Suppose 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are linear monads, so their transformers are also composed-inside:
\begin_inset Formula 
\[
M_{1}\varangle N=T_{M_{1}}^{N}=N\circ M_{1}\quad,\quad\quad M_{2}\varangle N=T_{M_{2}}^{N}=N\circ M_{2}\quad.
\]

\end_inset

The functor composition of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be seen as a monad stack:
\begin_inset Formula 
\[
M_{1}\circ M_{2}=T_{M_{2}}^{M_{1}}=M_{2}\varangle M_{1}\quad.
\]

\end_inset

What is the transformer for the monad 
\begin_inset Formula $M_{1}\circ M_{2}$
\end_inset

? For any foreign monad 
\begin_inset Formula $N$
\end_inset

, we have:
\begin_inset Formula 
\[
(M_{1}\circ M_{2})\varangle N=(M_{2}\varangle M_{1})\varangle N=M_{2}\varangle(M_{1}\varangle N)=M_{2}\varangle(N\circ M_{1})=N\circ M_{1}\circ M_{2}\quad.
\]

\end_inset

This is a lawful monad transformer, as we have seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So, this is the transformer for 
\begin_inset Formula $M_{1}\circ M_{2}$
\end_inset

, and it is of the composed-inside kind.
\end_layout

\begin_layout Section
Composed-outside transformers.
 Rigid monads
\begin_inset CommandInset label
LatexCommand label
name "sec:transformers-rigid-monads"

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:transformers-linear-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that the composed-inside transformers are available for monads
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!linear
\end_layout

\end_inset

 of the form 
\begin_inset Formula $M^{A}=P+Q\times A$
\end_inset

 and 
\begin_inset Formula $M^{A}=Q\times\left(P+A\right)$
\end_inset

, called 
\begin_inset Quotes eld
\end_inset

linear
\begin_inset Quotes erd
\end_inset

.
 No other examples of composed-inside transformers are known.
 It turns out that the composed-
\emph on
outside
\emph default
 transformers are available for a significantly wider range of monads.
 Those monads are called 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

 in this book
\begin_inset Foot
status open

\begin_layout Plain Layout
Monads of this kind do not seem to have an already accepted name.
\end_layout

\end_inset

 because one of their general properties is having a single, fixed 
\begin_inset Quotes eld
\end_inset

data shape
\begin_inset Quotes erd
\end_inset

 (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-wrapped-unit-is-unit"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!rigid
\end_layout

\end_inset

 
\end_layout

\begin_layout Paragraph
Definition
\end_layout

\begin_layout Standard
A monad 
\begin_inset Formula $R$
\end_inset

 is 
\series bold
rigid
\series default
 if it has a lawful composed-outside monad transformer, 
\begin_inset Formula $T_{R}^{M}=R\circ M$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is a foreign monad.
 
\end_layout

\begin_layout Standard
This definition states the required properties but does not explain which
 monads are rigid (or how to recognize a non-rigid monad).
 We will answer these questions below.
\end_layout

\begin_layout Standard
Two examples of rigid monads are the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

 (selector)
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Sel
\family default
 (selector) monad
\end_layout

\end_inset

 monad:
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
name "http://math.andrej.com/2008/11/21/"
target "http://math.andrej.com/2008/11/21/"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{(the \texttt{Reader} monad)} & :\quad\quad\text{Reader}^{Z,A}\triangleq Z\rightarrow A\quad,\\
\text{(the \texttt{Sel} monad)} & :\quad\quad\text{Sel}^{Z,A}\triangleq\left(A\rightarrow Z\right)\rightarrow A\quad,
\end{align*}

\end_inset

where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type.
 These monads have composed-outside transformers:
\begin_inset Formula 
\begin{align*}
\text{(the \texttt{ReaderT} transformer)} & :\quad\quad T_{\text{Reader}}^{M,A}\triangleq Z\rightarrow M^{A}\quad,\\
\text{(the \texttt{SelT} transformer)} & :\quad\quad T_{\text{Sel}}^{M,A}\triangleq(M^{A}\rightarrow Z)\rightarrow M^{A}\quad.
\end{align*}

\end_inset

To build intuition for rigid monads, we will perform structural analysis
 looking for general constructions that create new rigid monads or combine
 existing rigid monads into new ones.
 In this section, we will prove that the following three constructions produce
 rigid monads:
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

Product
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula $P^{A}\times R^{A}$
\end_inset

 is a rigid monad if 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 are rigid monads.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

Composition
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula $P\circ R$
\end_inset

 is a rigid monad if 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 are rigid monads.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

Choice
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula $C^{A}\triangleq H^{A}\rightarrow A$
\end_inset

 is a rigid monad if 
\begin_inset Formula $H$
\end_inset

 is any contrafunctor.
\end_layout

\begin_layout Standard
It is not known whether these constructions are the only possible ways of
 creating new rigid monads.
 Other open questions about rigid monads are listed in Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Rigid monad construction 1 (product)
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-product-rigid-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The product of rigid monads, 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

, is a rigid monad.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
If we show that 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

 has a composed-outside transformer, it will follow (by definition) that
 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

 is a rigid monad.
 Due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-of-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (whose proof does not depend on any of the results of this section), a
 lawful monad transformer 
\begin_inset Formula $T_{R_{1}\times R_{2}}^{M,A}$
\end_inset

 for the product monad 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

 is the product of transformers: for any foreign monad 
\begin_inset Formula $M$
\end_inset

,
\begin_inset Formula 
\[
T_{R_{1}}^{M,A}\times T_{R_{2}}^{M,A}=R_{1}^{M^{A}}\times R_{2}^{M^{A}}\quad.
\]

\end_inset

This is the required composed-outside transformer (
\begin_inset Formula $T_{R_{1}\times R_{2}}^{M,A}$
\end_inset

) for the monad 
\begin_inset Formula $R_{1}^{A}\times R_{2}^{A}$
\end_inset

.
\end_layout

\begin_layout Subsection
Rigid monad construction 2 (composition)
\end_layout

\begin_layout Standard
Functor composition is the second construction that produces rigid monads.
 This is a consequence of the properties of monad transformer stacks.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-composition-rigid-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-composition-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The composition 
\begin_inset Formula $R_{1}^{R_{2}^{\bullet}}$
\end_inset

 of two rigid monads 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 is also a rigid monad.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $R_{1}$
\end_inset

 is rigid, its outside-composition 
\begin_inset Formula $R_{1}\circ M$
\end_inset

 with any other monad 
\begin_inset Formula $M$
\end_inset

 is a monad.
 So 
\begin_inset Formula $R_{1}\circ R_{2}$
\end_inset

 is a monad.
 To show that 
\begin_inset Formula $R_{1}\circ R_{2}$
\end_inset

 is a rigid monad, we need to show that its monad transformer is of the
 composed-outside kind.
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Stacking-two-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the stacking of monad transformers 
\begin_inset Formula $T_{R_{1}}$
\end_inset

and 
\begin_inset Formula $T_{R_{2}}$
\end_inset

 is a lawful monad transformer.
 Since the transformers for 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 are of the composed-outside kind, 
\begin_inset Formula $T_{R_{1}}^{M}=R_{1}\circ M$
\end_inset

 and 
\begin_inset Formula $T_{R_{2}}^{M}=R_{2}\circ M$
\end_inset

, the stack of transformers is expressed as
\begin_inset Formula 
\[
T_{R_{1}}^{T_{R_{2}}^{M}}=R_{1}\circ T_{R_{2}}^{M}=R_{1}\circ(R_{2}\circ M)=R_{1}\circ R_{2}\circ M\quad.
\]

\end_inset

Therefore 
\begin_inset Formula $T^{M}\triangleq R_{1}\circ R_{2}\circ M$
\end_inset

 is a lawful monad transformer applied to the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 This shows, by definition of a rigid monad, that 
\begin_inset Formula $R_{1}\circ R_{2}$
\end_inset

 is a rigid monad.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-rigid-composition-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-rigid-composition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the functor composition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

 monad 
\begin_inset Formula $R_{1}^{A}\triangleq\left(A\rightarrow Q\right)\rightarrow A$
\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad 
\begin_inset Formula $R_{2}^{A}\triangleq Z\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
P^{A}\triangleq((Z\rightarrow A)\rightarrow Q)\rightarrow Z\rightarrow A\quad.
\]

\end_inset

It follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-composition-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the functor 
\begin_inset Formula $P$
\end_inset

 is a rigid monad; so 
\begin_inset Formula $P$
\end_inset

's transformer is of the composed-outside kind.
 The the transformed monad for any foreign monad 
\begin_inset Formula $M$
\end_inset

 is:
\begin_inset Formula 
\[
T^{A}\triangleq((Z\rightarrow M^{A})\rightarrow Q)\rightarrow Z\rightarrow M^{A}\quad.
\]

\end_inset

To define the monad methods for 
\begin_inset Formula $T$
\end_inset

, we need to have the definitions of the transformers 
\begin_inset Formula $T_{R_{1}}^{M}$
\end_inset

 and 
\begin_inset Formula $T_{R_{2}}^{M}$
\end_inset

.
 Since both the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monads are special cases of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Choice
\end_layout

\end_inset

 monad construction (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-monad-construction-1-choice"
plural "false"
caps "false"
noprefix "false"

\end_inset

) where the contrafunctor 
\begin_inset Formula $H$
\end_inset

 is chosen to be 
\begin_inset Formula $H^{A}\triangleq A\rightarrow Q$
\end_inset

 and 
\begin_inset Formula $H^{A}\triangleq Z$
\end_inset

 respectively, we can use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-T-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods for the transformers 
\begin_inset Formula $T_{R_{1}}^{M}$
\end_inset

 and 
\begin_inset Formula $T_{R_{2}}^{M}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type R1[A] = (A => Q) => A
\end_layout

\begin_layout Plain Layout

def map_R1[A, B](r1: R1[A])(f: A => B): R1[B] = { (b2q: B => Q) => f(r1(f
 andThen b2q)) }
\end_layout

\begin_layout Plain Layout

def flatMap_R1[A, B, M[_]: Monad](r1: R1[M[A]])(f: A => R1[M[B]]): R1[M[B]]
 = {
\end_layout

\begin_layout Plain Layout

  (q: M[B] => Q) => map_R1(r1){ (m: M[A]) => m.flatMap(x => f(x)(q)) }(q)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type R2[A] = Z => A
\end_layout

\begin_layout Plain Layout

def map_R2[A, B](r2: R2[A])(f: A => B): R2[B] = { r2 andThen f }
\end_layout

\begin_layout Plain Layout

def flatMap_R2[A, B, M[_]: Monad](r2: R2[M[A]])(f: A => R2[M[B]]): R2[M[B]]
 = {
\end_layout

\begin_layout Plain Layout

  z => map_R2(r2){ (m: M[A]) => m.flatMap(x => f(x)(z)) }(z)
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\end_inset

Now we can define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method for 
\begin_inset Formula $T$
\end_inset

 by using the monad 
\begin_inset Formula $T_{R_{2}}^{M}$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method for 
\begin_inset Formula $T_{R_{1}}^{M}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type T[A] = R1[R2[A]]
\end_layout

\begin_layout Plain Layout

def flatMap_T[A, B, M[_]: Monad](t: T[M[A]])(f: A => T[M[B]]): T[M[B]] =
 {
\end_layout

\begin_layout Plain Layout

  (q: R2[M[B]] => Q) => map_R1(t){ (m: R2[M[A]]) => flatMap_R2(m)(x => f(x)(q))
 }(q)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rigid monad construction 3 (choice)
\begin_inset CommandInset label
LatexCommand label
name "subsec:Rigid-monad-construction-1-choice"

\end_inset


\end_layout

\begin_layout Standard
The construction called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!choice monad
\end_layout

\end_inset

the 
\series bold
choice
\series default
 monad, 
\begin_inset Formula $R^{A}\triangleq H^{A}\rightarrow A$
\end_inset

, defines a rigid monad 
\begin_inset Formula $R$
\end_inset

 for any given contrafunctor 
\begin_inset Formula $H$
\end_inset

.
 This monad somehow 
\begin_inset Quotes eld
\end_inset

chooses
\begin_inset Quotes erd
\end_inset

 a value of type 
\begin_inset Formula $A$
\end_inset

.
 The contrafunctor 
\begin_inset Formula $H$
\end_inset

 may 
\emph on
consume
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

 (and could check some conditions on those values).
 For example, 
\begin_inset Formula $H$
\end_inset

 could be a constant contrafunctor (
\begin_inset Formula $H^{A}\triangleq Q$
\end_inset

), a function (
\begin_inset Formula $H^{A}\triangleq A\rightarrow Q$
\end_inset

), or a more complicated contrafunctor.
\end_layout

\begin_layout Standard
Different contrafunctors 
\begin_inset Formula $H$
\end_inset

 give various rigid monads such as 
\begin_inset Formula $R^{A}\triangleq\bbnum 1$
\end_inset

 (the unit monad), 
\begin_inset Formula $R^{A}\triangleq A$
\end_inset

 (the identity monad), 
\begin_inset Formula $R^{A}\triangleq Z\rightarrow A$
\end_inset

 (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

), and 
\begin_inset Formula $\text{Sel}^{Q,A}\triangleq\left(A\rightarrow Q\right)\rightarrow A$
\end_inset

 (the selector monad).
 
\end_layout

\begin_layout Standard
The selector monad represents the effect of somehow 
\begin_inset Quotes eld
\end_inset

selecting
\begin_inset Quotes erd
\end_inset

 a value of type 
\begin_inset Formula $A$
\end_inset

 using a function of type 
\begin_inset Formula $A\rightarrow Q$
\end_inset

.
 A simple example of a selector monad is found by setting 
\begin_inset Formula $Q\triangleq\bbnum 2$
\end_inset

 (where 
\begin_inset Formula $\bbnum 2$
\end_inset

 denotes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 type).
 One may implement a function of type 
\begin_inset Formula $\left(A\rightarrow\bbnum 2\right)\rightarrow A$
\end_inset

 that 
\emph on
somehow
\emph default
 finds a value of type 
\begin_inset Formula $A$
\end_inset

 that might satisfy the given predicate of type 
\begin_inset Formula $A\rightarrow\bbnum 2$
\end_inset

.
 The intention is to return, if possible, a value that satisfies the predicate.
 If no such value can be found, some value of type 
\begin_inset Formula $A$
\end_inset

 is still returned.
\end_layout

\begin_layout Standard
A closely related monad is the 
\series bold
search
\series default
 
\series bold
monad
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Search
\family default
 monad
\end_layout

\end_inset

, 
\begin_inset Formula $\text{Search}^{Q,A}\triangleq\left(A\rightarrow\bbnum 1+P\right)\rightarrow\bbnum 1+A$
\end_inset

.
 This (non-rigid) monad returns an empty value 
\begin_inset Formula $1+\bbnum 0^{:A}$
\end_inset

 if no value satisfying the 
\begin_inset Quotes eld
\end_inset

predicate
\begin_inset Quotes erd
\end_inset

 (a function of type 
\begin_inset Formula $A\rightarrow\bbnum 1+P$
\end_inset

) is found.
 There is a mapping from the selector monad to the search monad, implemented
 by checking whether the value returned by the selector monad does actually
 satisfy the predicate.
 However, that mapping is not a monad morphism (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-search-and-selector-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The selector monad is superficially similar to the continuation monad, and
 there is a monad morphism in one direction between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sel
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

 (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-selector-and-continuation-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $H$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $M$
\end_inset

 is a monad, and denote for brevity:
\begin_inset Formula 
\[
R^{A}\triangleq H^{A}\rightarrow A\quad,\quad\quad T^{A}\triangleq R^{M^{A}}=H^{M^{A}}\rightarrow M^{A}\quad.
\]

\end_inset

Let us now implement a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function and verify its laws.
 Then the results of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Monad-transformers-that-use-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will ensure that 
\begin_inset Formula $T$
\end_inset

 is a lawful monad transformer.
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-choice-monad-definition-of-flm"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-definition-of-flm"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function and the monad methods for 
\begin_inset Formula $T$
\end_inset

 can be written as:
\begin_inset Formula 
\begin{align}
 & \text{sw}_{R,M}:M^{R^{A}}\rightarrow R^{M^{A}}\quad,\quad\quad\text{sw}_{R,M}\triangleq m^{:M^{R^{A}}}\rightarrow q^{:H^{M^{A}}}\rightarrow m\triangleright(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}\quad,\label{eq:rigid-monad-short-formula-for-swap}\\
 & \text{pu}_{T}:A\rightarrow H^{M^{A}}\rightarrow M^{A}\quad,\quad\quad\text{pu}_{T}\triangleq\text{pu}_{M}\bef\text{pu}_{R}=a^{:A}\rightarrow\_^{:H^{M^{A}}}\rightarrow\text{pu}_{M}(a)\quad,\nonumber \\
 & \text{ftn}_{T}\triangleq t^{:T^{T^{A}}}\rightarrow k^{:H^{M^{A}}}\rightarrow k\triangleright\big(t\triangleright(\text{flm}_{M}(r^{:R^{M^{A}}}\rightarrow r(k)))^{\uparrow R}\big)=\text{flm}_{R}\left(t\rightarrow q\rightarrow t\triangleright\text{flm}_{M}(r\rightarrow r(q))\right)\quad,\nonumber \\
 & \text{flm}_{T}(f)=\text{flm}_{R}\big(y\rightarrow q\rightarrow y\triangleright\text{flm}_{M}(x\rightarrow q\triangleright(x\triangleright f))\big)\label{eq:rigid-monad-def-flm-t-via-flm-r}\\
 & \quad=t^{:R^{M^{A}}}\rightarrow q^{:H^{M^{B}}}\rightarrow q\triangleright\big(t\triangleright\big(\text{flm}_{M}(x^{:A}\rightarrow q\triangleright(x\triangleright f))\big)^{\uparrow R}\big)\quad.\label{eq:rigid-monad-flm-T-def}
\end{align}

\end_inset

The monad 
\begin_inset Formula $R$
\end_inset

's methods may be defined by:
\begin_inset Formula 
\begin{align}
 & \text{pu}_{R}:A\rightarrow H^{A}\rightarrow A\quad,\quad\quad\text{pu}_{R}\triangleq a\rightarrow\_^{:H^{A}}\rightarrow a\quad,\nonumber \\
 & \text{ftn}_{R}:(H^{H^{A}\rightarrow A}\rightarrow A\big)\rightarrow H^{A}\rightarrow A\quad,\quad\quad\text{ftn}_{R}\triangleq r^{:R^{R^{A}}}\rightarrow k^{:H^{A}}\rightarrow r\triangleright(q^{:R^{A}}\rightarrow q(k))^{\uparrow R}\quad,\nonumber \\
 & \text{flm}_{R}(g^{:A\rightarrow R^{B}})\triangleq r^{:R^{A}}\rightarrow k^{:H^{B}}\rightarrow k\triangleright\big(r\triangleright(a^{:A}\rightarrow g(a)(k))^{\uparrow R}\big)\quad.\label{eq:rigid-monad-flm-R-def}
\end{align}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We begin by deriving the code for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function.
 The monad 
\begin_inset Formula $T$
\end_inset

's methods depend on the monad 
\begin_inset Formula $R$
\end_inset

, whose code we will need to write next.
 Finally, we will obtain alternative formulas for 
\begin_inset Formula $\text{flm}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{flm}_{R}$
\end_inset

 that will be useful in derivations.
 
\end_layout

\begin_layout Paragraph
The code for 
\family typewriter
swap
\end_layout

\begin_layout Standard
Throughout the proof, we assume 
\begin_inset Formula $M$
\end_inset

 to be a fixed, lawful monad.
 Begin implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 by using typed holes:
\begin_inset Formula 
\[
\text{sw}_{R,M}:M^{R^{A}}\rightarrow H^{M^{A}}\rightarrow M^{A}\quad,\quad\quad\text{sw}_{R,M}\triangleq m^{:M^{H^{A}\rightarrow A}}\rightarrow q^{:H^{M^{A}}}\rightarrow\text{???}^{:M^{A}}\quad.
\]

\end_inset

Since the monad 
\begin_inset Formula $M$
\end_inset

 is arbitrary and no values of type 
\begin_inset Formula $A$
\end_inset

 are given, the only way of computing a value of type 
\begin_inset Formula $M^{A}$
\end_inset

 is by using the given value 
\begin_inset Formula $m$
\end_inset

.
 We could transform 
\begin_inset Formula $m:M^{H^{A}\rightarrow A}$
\end_inset

 to a value of type 
\begin_inset Formula $M^{A}$
\end_inset

 if we could transform a value of type 
\begin_inset Formula $H^{A}\rightarrow A$
\end_inset

 into a value of type 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
\text{sw}_{R,M}\triangleq m^{:M^{H^{A}\rightarrow A}}\rightarrow q^{:H^{M^{A}}}\rightarrow m\triangleright\big(r^{:H^{A}\rightarrow A}\rightarrow\text{???}^{:A}\big)^{\uparrow M}\quad.
\]

\end_inset

Lacking any given values of type 
\begin_inset Formula $A$
\end_inset

, we have to apply 
\begin_inset Formula $r$
\end_inset

 to a value of type 
\begin_inset Formula $H^{A}$
\end_inset

:
\begin_inset Formula 
\[
\text{sw}_{R,M}\triangleq m^{:M^{H^{A}\rightarrow A}}\rightarrow q^{:H^{M^{A}}}\rightarrow m\triangleright\big(r^{:H^{A}\rightarrow A}\rightarrow r(\text{???}^{:H^{A}})\big)^{\uparrow M}\quad.
\]

\end_inset

We have a value 
\begin_inset Formula $q:H^{M^{A}}$
\end_inset

 and a method 
\begin_inset Formula $\text{pu}_{M}:A\rightarrow M^{A}$
\end_inset

.
 This gives us the solution:
\begin_inset Formula 
\[
\text{sw}_{R,M}\triangleq m^{:M^{H^{A}\rightarrow A}}\rightarrow q^{:H^{M^{A}}}\rightarrow m\triangleright\big(r^{:H^{A}\rightarrow A}\rightarrow r(q\triangleright\text{pu}_{M}^{\downarrow H})\big)^{\uparrow M}\quad.
\]

\end_inset

Rewrite the formula in the 
\begin_inset Formula $\triangleright$
\end_inset

-notation to obtain Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\text{sw}_{R,M}:M^{R^{A}}\rightarrow R^{M^{A}}\quad,\quad\quad\text{sw}_{R,M}\triangleq m^{:M^{R^{A}}}\rightarrow q^{:H^{M^{A}}}\rightarrow m\triangleright(r^{:H^{A}\rightarrow A}\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}\quad.
\]

\end_inset

Equivalently, we may write the code of 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
q\triangleright\big(m\triangleright\text{sw}_{R,M}\big)=m\triangleright(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}\quad.\label{eq:rigid-monad-choice-swap-short}
\end{equation}

\end_inset

We will use these formulas for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 in proofs of its various laws.
\end_layout

\begin_layout Paragraph
The code for the monad 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Standard
We now derive the code for the monad 
\begin_inset Formula $R$
\end_inset

's methods.
 That monad's laws were proved in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-construction-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using flipped types of Kleisli morphisms and the flipped Kleisli composition
 (
\begin_inset Formula $\tilde{\diamond}_{_{R}}$
\end_inset

).
 To restore the standard type signatures for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, we begin by flipping the arguments of 
\begin_inset Formula $\tilde{\text{pu}}_{R}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{use Eq.~(\ref{eq:def-of-pure-for-exp-construction-h-a-a})}:\quad & \text{pu}_{R}\triangleq\text{flip}\,(\tilde{\text{pu}}_{R})=\text{flip}\,(\_^{:H^{A}}\rightarrow a^{:A}\rightarrow a)=a^{:A}\rightarrow\_^{:H^{A}}\rightarrow a\quad.
\end{align*}

\end_inset

To recover the Kleisli composition (
\begin_inset Formula $\diamond_{_{R}}$
\end_inset

), we need to flip both arguments of 
\begin_inset Formula $\tilde{\diamond}_{_{R}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & f^{:A\rightarrow H^{B}\rightarrow B}\diamond_{_{R}}g^{:B\rightarrow H^{C}\rightarrow C}\triangleq\text{flip}\big(\text{flip}\,(f)\,\tilde{\diamond}_{_{R}}\text{flip}\,(g)\big)\\
\text{use Eq.~(\ref{eq:def-of-Kleisli-for-exp-construction-h-a-a})}:\quad & =\text{flip}\big(k^{:H^{C}}\rightarrow\tilde{f}\big(k\triangleright(\tilde{g}(k))^{\downarrow H}\big)\bef\tilde{g}(k)\big)\\
\text{expand function}:\quad & =\text{flip}\big(k^{:H^{C}}\rightarrow a^{:A}\rightarrow a\triangleright\tilde{f}\big(k\triangleright(\tilde{g}(k))^{\downarrow H}\big)\bef\tilde{g}(k)\big)\\
\text{definition of }\text{flip}:\quad & =a^{:A}\rightarrow k^{:H^{C}}\rightarrow a\triangleright\tilde{f}\big(k\triangleright(\tilde{g}(k))^{\downarrow H}\big)\bef\tilde{g}(k)\quad,
\end{align*}

\end_inset

where the flipped versions of the functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 are defined by:
\begin_inset Formula 
\begin{align*}
 & \tilde{f}:H^{B}\rightarrow A\rightarrow B\quad,\quad\quad\tilde{f}\triangleq h^{:H^{B}}\rightarrow a^{:A}\rightarrow f(a)(h)\quad,\quad\quad a\triangleright\tilde{f}(h)=f(a)(h)\quad,\\
 & \tilde{g}:H^{C}\rightarrow B\rightarrow C\quad,\quad\quad\tilde{g}\triangleq h^{:H^{C}}\rightarrow b^{:B}\rightarrow g(b)(h)\quad,\quad\quad b\triangleright\tilde{g}(h)=g(b)(h)\quad.
\end{align*}

\end_inset

Substituting these definitions, we compute:
\begin_inset Formula 
\begin{align*}
 & f\diamond_{_{R}}g=a^{:A}\rightarrow k^{:H^{C}}\rightarrow a\triangleright\tilde{f}\big(k\triangleright(\tilde{g}(k))^{\downarrow H}\big)\,\gunderline{\bef}\,\tilde{g}(k)\\
\triangleright\text{-notation}:\quad & =a\rightarrow k\rightarrow a\triangleright\gunderline{\tilde{f}}\big(k\triangleright(\tilde{g}(k))^{\downarrow H}\big)\triangleright\tilde{g}(k)\\
 & =a\rightarrow k\rightarrow f(a)(k\,\gunderline{\triangleright\,(\tilde{g}(k)})^{\downarrow H})\,\gunderline{\triangleright\,\tilde{g}(k)}=a\rightarrow k\rightarrow g\big(f(a)(k\triangleright(b\rightarrow g(b)(k))^{\downarrow H})\big)(k)\quad.
\end{align*}

\end_inset

This code can be shortened by defining a helper function 
\begin_inset Formula $\gamma(g,k)$
\end_inset

, also denoted 
\begin_inset Formula $\gamma_{g,k}$
\end_inset

 for brevity:
\begin_inset Formula 
\begin{align*}
 & \gamma_{g,k}:B\rightarrow C\quad,\quad\quad\gamma_{g,k}\triangleq b\rightarrow g(b)(k)=\tilde{g}(k)\quad,\\
\text{then write}:\quad & f\diamond_{_{R}}g=a^{:A}\rightarrow k^{:H^{C}}\rightarrow f(a)(k\triangleright\gamma_{g,k}^{\downarrow H})\triangleright\gamma_{g,k}\quad.
\end{align*}

\end_inset

The next step is to derive the code for 
\begin_inset Formula $\text{flm}_{R}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{flm}_{R}(g^{:A\rightarrow R^{B}})\triangleq\text{id}^{:R^{A}\rightarrow R^{A}}\diamond_{_{R}}g=r^{:R^{A}}\rightarrow k^{:H^{B}}\rightarrow\text{id}\left(r\right)(k\triangleright\gamma_{g,k}^{\downarrow H})\triangleright\gamma_{g,k}\\
 & =r\rightarrow k\rightarrow r(k\triangleright\gamma_{g,k}^{\downarrow H})\triangleright\gamma_{g,k}=r\rightarrow k\rightarrow g\big(r(k\triangleright(b\rightarrow g(b)(k))^{\downarrow H})\big)(k)\quad.
\end{align*}

\end_inset

Finally, we find 
\begin_inset Formula $\text{ftn}_{R}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{ftn}_{R}\triangleq\text{flm}_{R}(\text{id}^{:R^{A}\rightarrow R^{A}})=r^{:R^{R^{A}}}\rightarrow k^{:H^{A}}\rightarrow r(k\triangleright(q^{:R^{A}}\rightarrow q(k))^{\downarrow H})\big)(k)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The last two formulas may be shortened if we notice that the lifting to
 
\begin_inset Formula $R$
\end_inset

 is expressed as:
\begin_inset Formula 
\[
f^{\uparrow R}=r^{:H^{A}\rightarrow A}\rightarrow k^{:H^{B}}\rightarrow f(r(k\triangleright f^{\downarrow H}))=r^{:R^{A}}\rightarrow f^{\downarrow H}\bef r\bef f\quad.
\]

\end_inset

So, we may equivalently write the code for 
\begin_inset Formula $\text{flm}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{R}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{flm}_{R}(g^{:A\rightarrow R^{B}})\triangleq r^{:R^{A}}\rightarrow k^{:H^{B}}\rightarrow k\triangleright\big(r\triangleright\gamma_{g,k}^{\uparrow R}\big)\quad,\quad\text{ftn}_{R}\triangleq r^{:R^{R^{A}}}\rightarrow k^{:H^{B}}\rightarrow k\triangleright\big(r\triangleright(q^{:R^{A}}\rightarrow q(k))^{\uparrow R}\big)\quad.
\]

\end_inset

This corresponds to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-R-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Deriving 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 from 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset


\end_layout

\begin_layout Standard
Given the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we can recover the code of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 by using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

), where we need to use the monad 
\begin_inset Formula $R$
\end_inset

 instead of 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{ftn}_{T}=\gunderline{\text{sw}^{\uparrow R}\bef\text{ftn}_{R}}\bef\text{ftn}_{M}^{\uparrow R}=\text{flm}_{R}(\text{sw})\bef\text{ftn}_{M}^{\uparrow R}\nonumber \\
\text{naturality law of }\text{flm}_{R}:\quad & =\text{flm}_{R}(\text{sw}\bef\text{ftn}_{M}^{\uparrow R})\quad.\label{eq:rigid-monad-ftn-derivation-4a}
\end{align}

\end_inset

To proceed, we need to simplify 
\begin_inset Formula $\text{sw}\bef\text{ftn}_{M}^{\uparrow R}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{sw}\bef\text{ftn}_{M}^{\uparrow R}\nonumber \\
\text{definitions}:\quad & =\big(m\rightarrow q\rightarrow m\triangleright\big((r\rightarrow\gunderline q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef(\gunderline{r\rightarrow\text{ftn}_{M}^{\downarrow H}\bef r\bef\text{ftn}_{M}})\nonumber \\
\text{composition}:\quad & =m\rightarrow\gunderline{\text{ftn}_{M}^{\downarrow H}}\bef\big(q\rightarrow m\triangleright\big((r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\nonumber \\
\text{expansion}:\quad & =m\rightarrow\big(q\rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}}\big)\bef\big(q\rightarrow m\triangleright\big((r\rightarrow\gunderline q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\nonumber \\
\text{composition}:\quad & =m\rightarrow\big(q\rightarrow m\triangleright\big((r\rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r)\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-swap-ftn-derivation4}
\end{align}

\end_inset

We can transform the sub-expression 
\begin_inset Formula $(r\rightarrow q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}\bef r)$
\end_inset

 to:
\begin_inset Formula 
\begin{align}
\triangleright\text{-notation}:\quad & r\rightarrow q\triangleright\gunderline{\text{ftn}_{M}^{\downarrow H}\bef\text{pu}_{M}^{\downarrow H}}\bef r\nonumber \\
\text{composition law of }H:\quad & =r\rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})^{\downarrow H}\bef r\nonumber \\
\text{left identity law of }M:\quad & =r\rightarrow\gunderline{q\triangleright r}=r\rightarrow r(q)\quad.\label{eq:rigid-monad-swap-ftn-derivation5}
\end{align}

\end_inset

Using this simplification, we continue transforming Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-swap-ftn-derivation4"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{sw}\bef\text{ftn}_{M}^{\uparrow R}=m\rightarrow\big(q\rightarrow m\triangleright\big((r\rightarrow\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}\bef r})\big)^{\uparrow M}\big)\bef\text{ftn}_{M}\\
\text{use Eq.~(\ref{eq:rigid-monad-swap-ftn-derivation5})}:\quad & =m\rightarrow\gunderline{\big(}q\rightarrow m\triangleright(r\rightarrow r(q))^{\uparrow M}\gunderline{\big)\bef}\text{ftn}_{M}\\
\text{composition}:\quad & =m\rightarrow q\rightarrow m\triangleright(r\rightarrow r(q)\gunderline{)^{\uparrow M}\bef\text{ftn}_{M}}=m\rightarrow q\rightarrow m\triangleright\text{flm}_{M}\left(r\rightarrow r(q)\right)\quad.
\end{align*}

\end_inset

It follows that:
\begin_inset Formula 
\begin{equation}
(\text{sw}\bef\text{ftn}_{M}^{\uparrow R})(x)(y)=x\triangleright\text{flm}_{M}(r\rightarrow r(y))\quad.\label{eq:rigid-monad-swap-ftn-derivation6}
\end{equation}

\end_inset

Now we rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-ftn-derivation-4a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and get:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{T}=\text{flm}_{R}(\text{sw}\bef\text{ftn}_{M}^{\uparrow R})\\
\text{use Eq.~(\ref{eq:rigid-monad-flm-R-def})}:\quad & =t\rightarrow k\rightarrow k\triangleright\big(t\triangleright(a\rightarrow(\gunderline{\text{sw}\bef\text{ftn}_{M}^{\uparrow R}})(a)(k))^{\uparrow R}\big)\\
\text{use Eq.~(\ref{eq:rigid-monad-swap-ftn-derivation6})}:\quad & =t\rightarrow k\rightarrow k\triangleright\big(t\triangleright(\gunderline{a\rightarrow a\,\triangleright}\,\text{flm}_{M}(r\rightarrow r(k)))^{\uparrow R}\big)\\
\text{unexpand function}:\quad & =t\rightarrow k\rightarrow k\triangleright\big(t\triangleright(\text{flm}_{M}(r\rightarrow r(k)))^{\uparrow R}\big)\quad.
\end{align*}

\end_inset

It is sometimes convenient to express the code of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 in terms of 
\begin_inset Formula $\text{flm}_{R}$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{T}=\text{flm}_{R}(\text{sw}\bef\text{ftn}_{M}^{\uparrow R})=\text{flm}_{R}\big(m\rightarrow q\rightarrow m\triangleright\text{flm}_{M}(r\rightarrow r(q))\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
Deriving 
\begin_inset Formula $\text{flm}_{T}$
\end_inset

 from 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset


\end_layout

\begin_layout Standard
We use the formula for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 just derived above:
\begin_inset Formula 
\begin{align*}
 & \text{flm}_{T}(g)=g^{\uparrow T}\bef\gunderline{\text{ftn}_{T}}=\gunderline{g^{\uparrow M\uparrow R}\bef\text{flm}_{R}}\big(m\rightarrow q\rightarrow m\triangleright\text{flm}_{M}(r\rightarrow r(q)\big)\\
\text{left naturality law of }\text{flm}_{R}:\quad & =\text{flm}_{R}\big(\gunderline{g^{\uparrow M}\bef(m}\rightarrow q\rightarrow m\triangleright\text{flm}_{M}(r\rightarrow r(q)))\big)\\
\text{compute composition}:\quad & =\text{flm}_{R}\big(m\rightarrow q\rightarrow m\triangleright\gunderline{g^{\uparrow M}\triangleright\text{flm}_{M}}(r\rightarrow r(q))\big)\\
\text{naturality law of }\text{flm}_{M}:\quad & =\text{flm}_{R}\big(m\rightarrow q\rightarrow m\triangleright\text{flm}_{M}\big(\gunderline{g\bef(r\rightarrow r(q))}\big)\big)\\
\text{compute composition}:\quad & =\text{flm}_{R}\big(m\rightarrow q\rightarrow m\triangleright\text{flm}_{M}\big(r\rightarrow g(r)(q))\big)\big)\\
\text{obtain Eq.~(\ref{eq:rigid-monad-def-flm-t-via-flm-r})}:\quad & =\text{flm}_{R}\big(m\rightarrow q\rightarrow m\triangleright\text{flm}_{M}(\gamma_{g,q})\big)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This concludes the derivation of the formulas listed in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-definition-of-flm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-choice-monad-swap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-choice-monad-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (short notation 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

) defined in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-short-formula-for-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) satisfies the four laws of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the monadic naturality laws of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We will verify each of the laws in turn.
\end_layout

\begin_layout Paragraph
The inner identity law
\end_layout

\begin_layout Standard
is 
\begin_inset Formula $\text{pu}_{R}^{\uparrow M}\bef\text{sw}=\text{pu}_{R}$
\end_inset

.
 To verify this law, compute:
\begin_inset Formula 
\begin{align}
\text{expect to equal }\text{pu}_{R}:\quad & \text{pu}_{R}^{\uparrow M}\bef\gunderline{\text{sw}}\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})}:\quad & =\big(m\rightarrow\gunderline{m\triangleright\text{pu}_{R}^{\uparrow M}}\big)\bef\big(m\rightarrow q\rightarrow\gunderline m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\big)\nonumber \\
\text{function composition}:\quad & =m\rightarrow q\rightarrow m\triangleright\gunderline{\text{pu}_{R}^{\uparrow M}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}}\nonumber \\
\text{composition under }^{\uparrow M}:\quad & =m\rightarrow q\rightarrow m\triangleright\big(\text{pu}_{R}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}\quad.\label{eq:swap-laws-derivation1a}
\end{align}

\end_inset

To proceed, we simplify the expression 
\begin_inset Formula $\text{pu}_{R}\bef(r\rightarrow...)$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{pu}_{R}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)=(m\rightarrow m\triangleright\text{pu}_{R})\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright r\big)\nonumber \\
\text{compute composition}:\quad & =m\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\left(m\triangleright\text{pu}_{R}\right)\quad.\label{eq:swap-laws-derivation1}
\end{align}

\end_inset

We now have to use the definition of 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

, which is 
\begin_inset Formula $\text{pu}_{R}=x\rightarrow y\rightarrow x$
\end_inset

, or in the pipe notation:
\begin_inset Formula 
\begin{equation}
y\triangleright\left(x\triangleright\text{pu}_{R}\right)=x\quad.\label{eq:rigid-monad-pure-t-simplification-1}
\end{equation}

\end_inset

With this simplification at hand, we continue from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-laws-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to:
\begin_inset Formula 
\begin{align*}
 & m\rightarrow\gunderline{q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\left(m\triangleright\text{pu}_{R}\right)}\\
\text{use Eq.~(\ref{eq:rigid-monad-pure-t-simplification-1})}:\quad & =m\rightarrow m=\text{id}\quad.
\end{align*}

\end_inset

Therefore, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-laws-derivation1a"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes:
\begin_inset Formula 
\[
m\rightarrow q\rightarrow m\triangleright\gunderline{\big(\text{pu}_{R}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}}=(m\rightarrow q\rightarrow\gunderline{m\triangleright\text{id}})=(m\rightarrow q\rightarrow m)=\text{pu}_{R}\quad.
\]

\end_inset

This proves the inner identity law.
\end_layout

\begin_layout Paragraph
The outer identity law
\end_layout

\begin_layout Standard
is 
\begin_inset Formula $\text{pu}_{M}\bef\text{sw}=\text{pu}_{M}^{\uparrow R}$
\end_inset

.
 To verify this law, write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}^{\uparrow R}:\quad & \text{pu}_{M}\bef\gunderline{\text{sw}}\\
\text{use Eq.~(\ref{eq:rigid-monad-short-formula-for-swap})}:\quad & =\big(m\rightarrow\gunderline{m\triangleright\text{pu}_{M}}\big)\bef\big(m\rightarrow q\rightarrow\gunderline m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\big)\\
\text{compute composition}:\quad & =m\rightarrow q\rightarrow m\triangleright\gunderline{\text{pu}_{M}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}}\\
\text{naturality law of }\text{pu}_{M}:\quad & =m\rightarrow q\rightarrow m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\bef\text{pu}_{M}\\
\triangleright\text{-notation}:\quad & =m\rightarrow q\rightarrow\gunderline{m\triangleright\big(r\rightarrow}q\triangleright\text{pu}_{M}^{\downarrow H}\bef\gunderline r\bef\text{pu}_{M}\big)\\
\text{apply function to }m:\quad & =m\rightarrow\gunderline{q\rightarrow q}\triangleright\text{pu}_{M}^{\downarrow H}\bef m\bef\text{pu}_{M}\\
\text{unexpand function}:\quad & =m\rightarrow\text{pu}_{M}^{\downarrow H}\bef m\bef\text{pu}_{M}\\
\text{definition of }{}^{\uparrow R}:\quad & =\text{pu}_{M}^{\uparrow R}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
The inner interchange law
\end_layout

\begin_layout Standard
is written as:
\begin_inset Formula 
\begin{equation}
\text{ftn}_{R}^{\uparrow M}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow R}\bef\text{ftn}_{R}\quad.\label{eq:swap-law-3-formulation-R-M}
\end{equation}

\end_inset

We will apply both sides of the law to arbitrary 
\begin_inset Formula $m:M^{R^{R^{A}}}$
\end_inset

 and 
\begin_inset Formula $q:H^{M^{A}}$
\end_inset

, then rewrite both sides to the same expression.
 
\end_layout

\begin_layout Standard
Below, we will need a simplified formula for 
\begin_inset Formula $\text{ftn}_{R}$
\end_inset

 derived from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-flm-R-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align}
\text{ftn}_{R} & =\text{flm}_{R}(\text{id})\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-flm-R-def})}:\quad & =t\rightarrow q\rightarrow q\triangleright(t\triangleright(x\rightarrow x(q))^{\uparrow R})\nonumber \\
\text{definition of }^{\uparrow R}:\quad & =t\rightarrow q\rightarrow q\triangleright\big(t\triangleright\gunderline{\big(r\rightarrow}(x\rightarrow x(q))^{\downarrow H}\bef r\bef(x\rightarrow x(q))\big)\big)\nonumber \\
\text{apply to argument}:\quad & =t\rightarrow q\rightarrow q\triangleright\big((x\rightarrow x(q))^{\downarrow H}\bef t\bef(x\gunderline{\rightarrow x(q)})\big)\nonumber \\
\text{use }\triangleright\text{-notation}:\quad & =t\rightarrow q\rightarrow\gunderline{q\triangleright\big(q\triangleright(}x\rightarrow q\triangleright x)^{\downarrow H}\bef t\big)\quad.\label{eq:ftn-R-simplified}
\end{align}

\end_inset

We first apply the left-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-law-3-formulation-R-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (\text{ftn}_{R}^{\uparrow M}\bef\text{sw})(m)(q)=q\triangleright\big(m\triangleright\text{ftn}_{R}^{\uparrow M}\gunderline{\bef}\text{sw}\big)=q\triangleright\big(m\triangleright\text{ftn}_{R}^{\uparrow M}\triangleright\gunderline{\text{sw}}\big)\\
\text{use Eq.~(\ref{eq:rigid-monad-choice-swap-short})}:\quad & =m\triangleright\gunderline{\text{ftn}_{R}^{\uparrow M}\bef(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)^{\uparrow M}}\\
\text{composition law of }M:\quad & =m\triangleright\big(\text{ftn}_{R}\bef(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.
\end{align*}

\end_inset

We now need to simplify the sub-expression under 
\begin_inset Formula $(...)^{\uparrow M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{R}\gunderline{\bef(r}\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright r)\\
\text{compute composition}:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\gunderline{\text{ftn}_{R}(r)}\\
\text{use Eq.~(\ref{eq:ftn-R-simplified})}:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright\big(q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}\triangleright(x\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\triangleright x)^{\downarrow H}}\bef r\big)\\
\text{composition law of }H:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\rightarrow q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}\bef x\bef\text{pu}_{M}})^{\downarrow H}\bef r\big)\\
\text{definition of }^{\uparrow R}:\quad & =r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x))^{\downarrow H}\bef r\big)\quad.
\end{align*}

\end_inset

The left-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-law-3-formulation-R-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) then becomes:
\begin_inset Formula 
\[
m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef\big(q\triangleright(x\rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x))^{\downarrow H}\bef r\big)\big)^{\uparrow M}\quad.
\]

\end_inset

Now apply the right-hand side of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-law-3-formulation-R-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & q\triangleright\big(m\triangleright\text{sw}\bef\gunderline{\text{sw}^{\uparrow R}}\bef\text{ftn}_{R}\big)\nonumber \\
\text{definition of }^{\uparrow R}:\quad & =q\triangleright\big(\gunderline{m\triangleright\text{sw}\triangleright(x}\rightarrow\text{sw}^{\downarrow H}\bef x\bef\text{sw})\triangleright\text{ftn}_{R}\big)\nonumber \\
\text{apply to arguments}:\quad & =q\triangleright\big(\gunderline{\text{ftn}_{R}(}\text{sw}^{\downarrow H}\bef\text{sw}(m)\bef\text{sw})\big)\nonumber \\
\text{use Eq.~(\ref{eq:ftn-R-simplified})}:\quad & =q\triangleright\big(q\triangleright\gunderline{(x\rightarrow q\triangleright x)^{\downarrow H}\bef\text{sw}^{\downarrow H}}\bef\text{sw}(m)\bef\text{sw}\big)\nonumber \\
\text{composition under }^{\downarrow H}:\quad & =q\triangleright\big(q\triangleright\big(\gunderline{\text{sw}\bef(x\rightarrow q\triangleright x)}\big)^{\downarrow H}\bef\text{sw}(m)\bef\text{sw}\big)\quad.\label{eq:swap-laws-derivation2}
\end{align}

\end_inset

To proceed, we simplify the sub-expression 
\begin_inset Formula $\text{sw}(m)\bef\text{sw}$
\end_inset

 by computing the function compositions:
\begin_inset Formula 
\begin{align*}
 & \text{sw}(m)\bef\text{sw}\\
 & =(q_{1}\rightarrow m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\gunderline{)\bef(}y\rightarrow q_{2}\rightarrow y\triangleright\big(r\rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\\
 & =q_{1}\rightarrow q_{2}\rightarrow(m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M})\triangleright\big(}r\rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M}}\\
 & =q_{1}\rightarrow q_{2}\rightarrow m\triangleright\big(\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\bef\big(}r\rightarrow q_{2}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\big)^{\uparrow M}}\quad.
\end{align*}

\end_inset

Using this formula, we can write, for any 
\begin_inset Formula $z$
\end_inset

 of a suitable type:
\begin_inset Formula 
\begin{align}
q\triangleright(z\triangleright\text{sw}(m)\bef\text{sw}) & =m\triangleright\big(\big(r\rightarrow z\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)\bef\big(r\rightarrow}\,q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)\big)^{\uparrow M}\nonumber \\
\text{compute composition}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(z\triangleright\text{pu}_{M}^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.\label{eq:swap-law-3-derivation-1}
\end{align}

\end_inset

Now we can substitute this into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-laws-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(q\triangleright\big(\text{sw}\bef(x\rightarrow q\triangleright x)\big)^{\downarrow H}\triangleright\gunderline{\text{sw}(m)\bef\text{sw}}\big)\\
\text{use Eq.~(\ref{eq:swap-law-3-derivation-1})}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\gunderline{\big(\text{sw}\bef(x\rightarrow q\triangleright x)\big)^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r)\big)^{\uparrow M}\\
\text{composition under }^{\downarrow H}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(\gunderline{\text{pu}_{M}\bef\text{sw}}\bef(x\rightarrow q\triangleright x)\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\\
\text{outer identity law of }\text{sw}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(\gunderline{\text{pu}_{M}^{\uparrow R}\bef(x\rightarrow q\triangleright x)}\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\\
\text{compute composition}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef(q\triangleright\big(x\rightarrow q\triangleright\text{pu}_{M}^{\uparrow R}(x)\big)^{\downarrow H}\bef r)\big)^{\uparrow M}\quad.
\end{align*}

\end_inset

We arrived at the same expression as the left-hand side of the law.
\end_layout

\begin_layout Paragraph
The outer interchange law
\end_layout

\begin_layout Standard
is written as:
\begin_inset Formula 
\begin{equation}
\text{ftn}_{M}\bef\text{sw}=\text{sw}^{\uparrow M}\bef\text{sw}\bef\text{ftn}_{M}^{\uparrow R}\quad.\label{eq:swap-law-4-formulation-R-M}
\end{equation}

\end_inset

We will apply both sides of the law to arbitrary 
\begin_inset Formula $m^{:M^{M^{R^{A}}}}$
\end_inset

 and 
\begin_inset Formula $q^{:H^{M^{A}}}$
\end_inset

, and transform both sides to the same expression.
 We begin with the more complicated right-hand side and use the pipe notation:
\begin_inset Formula 
\begin{align}
 & q\triangleright\big(m\triangleright\text{sw}^{\uparrow M}\gunderline{\bef}\text{sw}\gunderline{\bef}\text{ftn}_{M}^{\uparrow R}\big)=q\triangleright\big((m\triangleright\text{sw}^{\uparrow M}\triangleright\text{sw})\triangleright\gunderline{\text{ftn}_{M}^{\uparrow R}}\big)\nonumber \\
\text{definition of }^{\uparrow R}:\quad & =q\triangleright\big(\text{ftn}_{M}^{\downarrow H}\gunderline{\bef}(m\triangleright\text{sw}^{\uparrow M}\triangleright\text{sw})\gunderline{\bef}\text{ftn}_{M}\big)\nonumber \\
\triangleright\text{-notation}:\quad & =\big(\gunderline{q\triangleright\text{ftn}_{M}^{\downarrow H}}\triangleright(\gunderline{m\triangleright\text{sw}^{\uparrow M}}\triangleright\gunderline{\text{sw}})\big)\triangleright\text{ftn}_{M}\nonumber \\
\text{use Eq.~(\ref{eq:rigid-monad-choice-swap-short})}:\quad & =\big(m\triangleright\gunderline{\text{sw}^{\uparrow M}}\triangleright\big(r\rightarrow q\triangleright\gunderline{\text{ftn}_{M}^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\gunderline{\big)^{\uparrow M}}\big)\triangleright\text{ftn}_{M}\nonumber \\
\text{composition under }^{\downarrow H}\text{ and }^{\uparrow M}:\quad & =m\triangleright\big(\text{sw}\bef\big(r\rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})^{\downarrow H}\bef r\big)\big)^{\uparrow M}\bef\text{ftn}_{M}\nonumber \\
\text{left identity law of }M:\quad & =m\triangleright\big(\text{sw}\bef(r\rightarrow q\triangleright r)\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.\label{eq:rigid-monad-1-swap-law-4-derivation-5}
\end{align}

\end_inset

Let us simplify the sub-expression 
\begin_inset Formula $\text{sw}\bef(r\rightarrow q\triangleright r)$
\end_inset

 separately:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{sw}}\bef\big(r\rightarrow q\triangleright r\big)=(x\rightarrow x\triangleright\text{sw}\gunderline{)\bef(}r\rightarrow q\triangleright r)=x\rightarrow\gunderline{q\triangleright(x\triangleright\text{sw})}\\
\text{use Eq.~(\ref{eq:rigid-monad-choice-swap-short})}:\quad & =\gunderline{x\rightarrow x\triangleright\big(}r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}=\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}

\end_inset

Substituting this expression into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-1-swap-law-4-derivation-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we get:
\begin_inset Formula 
\begin{align*}
 & m\triangleright\big(\gunderline{\text{sw}\bef(r\rightarrow q\triangleright r)}\big)^{\uparrow M}\bef\text{ftn}_{M}=m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\\
\text{naturality law of }\text{ftn}_{M}:\quad & =m\triangleright\text{ftn}_{M}\bef\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Now write the left-hand side of the law:
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(m\triangleright\text{ftn}_{M}\gunderline{\bef}\text{sw}\big)=q\triangleright\big(m\triangleright\text{ftn}_{M}\triangleright\gunderline{\text{sw}}\big)\\
\text{use Eq.~(\ref{eq:rigid-monad-choice-swap-short})}:\quad & =m\triangleright\text{ftn}_{M}\triangleright\big(r\rightarrow q\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\quad.
\end{align*}

\end_inset

The two sides of the law are now equal.
\end_layout

\begin_layout Paragraph
The monadic naturality laws
\end_layout

\begin_layout Standard
are written as:
\begin_inset Formula 
\[
\text{sw}_{R,\text{Id}}=\text{id}\quad,\quad\quad\text{sw}_{R,M}\bef\phi^{\uparrow R}=\phi\bef\text{sw}_{R,N}\quad,\quad\quad\text{sw}_{R,M}\bef\theta=\theta^{\uparrow M}\quad,
\]

\end_inset

where 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:R\leadsto\text{Id}$
\end_inset

 are arbitrary monad morphisms.
 
\end_layout

\begin_layout Standard
To verify the first law, set 
\begin_inset Formula $M=\text{Id}$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-choice-swap-short"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and get:
\begin_inset Formula 
\begin{align*}
 & q\triangleright(m\triangleright\text{sw}_{R,\text{Id}})\\
\text{use Eq.~(\ref{eq:rigid-monad-choice-swap-short})}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\gunderline{\text{pu}_{M}^{\downarrow H}}\bef r\gunderline{\big)^{\uparrow M}}\\
\text{use }M=\text{Id}\text{ and }\text{pu}_{M}=\text{id}:\quad & =\gunderline{m\triangleright(r\rightarrow}\,q\triangleright r)\\
\text{apply to argument }m:\quad & =q\triangleright\gunderline m=q\triangleright(m\triangleright\text{id})\quad.
\end{align*}

\end_inset

So, 
\begin_inset Formula $\text{sw}_{R,\text{Id}}=\text{id}$
\end_inset

 when applied to arbitrary argument values 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the second law, apply both sides to arbitrary 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 The left-hand side:
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big(m\triangleright\text{sw}_{R,M}\gunderline{\bef}\phi^{\uparrow R}\big)=q\triangleright\big(m\triangleright\text{sw}_{R,M}\triangleright\gunderline{\phi^{\uparrow R}}\big)\\
\text{definition of }^{\uparrow R}:\quad & =q\triangleright\big(\phi^{\downarrow H}\bef(m\triangleright\text{sw}_{R,M})\bef\phi\big)\\
\triangleright\text{-notation}:\quad & =\gunderline{(q\triangleright\phi^{\downarrow H})}\triangleright(m\triangleright\gunderline{\text{sw}_{R,M}})\triangleright\phi\\
\text{use Eq.~(\ref{eq:rigid-monad-choice-swap-short})}:\quad & =m\triangleright\big(r\rightarrow q\triangleright\gunderline{\phi^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\big)^{\uparrow M}\triangleright\phi\\
\text{composition law of }H:\quad & =m\triangleright\big(r\rightarrow q\triangleright(\gunderline{\text{pu}_{M}\bef\phi})^{\downarrow H}\bef r\big)^{\uparrow M}\bef\phi\\
\text{identity law of }\phi:\quad & =m\triangleright\big(r\rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\gunderline{\big)^{\uparrow M}\bef\phi}\\
\text{naturality law of }\phi:\quad & =m\triangleright\phi\bef\big(r\rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\big)^{\uparrow N}\quad.
\end{align*}

\end_inset

The right-hand side, when applied to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

, gives the same expression:
\begin_inset Formula 
\begin{align*}
 & q\triangleright(m\triangleright\phi\bef\text{sw}_{R,N})=q\triangleright(m\triangleright\phi\triangleright\gunderline{\text{sw}_{R,N})}\\
\text{use Eq.~(\ref{eq:rigid-monad-choice-swap-short})}:\quad & =m\triangleright\phi\triangleright\big(r\rightarrow q\triangleright\text{pu}_{N}^{\downarrow H}\bef r\big)^{\uparrow N}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To argue that the third law holds,
\begin_inset Foot
status open

\begin_layout Plain Layout
The present proof needs an additional assumption about 
\begin_inset Formula $\theta$
\end_inset

, which will be indicated below.
\end_layout

\end_inset

 apply the left-hand side to 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & q\triangleright(m\triangleright\text{sw}_{R,M}\bef\theta)=q\triangleright(m\triangleright\text{sw}_{R,M}\triangleright\theta)\nonumber \\
 & =q\triangleright\big((q_{1}\rightarrow m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\triangleright\theta\big)\quad.\label{eq:rigid-monad-1-derivation7}
\end{align}

\end_inset

This expression cannot be simplified any further; and neither can the right-hand
 side, 
\begin_inset Formula $q\triangleright(m\triangleright\theta^{\uparrow M})$
\end_inset

.
 We need more detailed information about the function 
\begin_inset Formula $\theta$
\end_inset

.
 The type of 
\begin_inset Formula $\theta$
\end_inset

 is:
\begin_inset Formula 
\[
\theta:\forall A.\,(H^{A}\rightarrow A)\rightarrow A\quad.
\]

\end_inset

To implement a function of this type, we need to write code that takes an
 argument of type 
\begin_inset Formula $H^{A}\rightarrow A$
\end_inset

 and returns a value of type 
\begin_inset Formula $A$
\end_inset

.
 Since the type 
\begin_inset Formula $A$
\end_inset

 is arbitrary, the code of 
\begin_inset Formula $\theta$
\end_inset

 cannot store a fixed value of type 
\begin_inset Formula $A$
\end_inset

 to use as the return value.
 It appears that the only possibility of implementing a function 
\begin_inset Formula $\theta$
\end_inset

 is by substituting a value of type 
\begin_inset Formula $H^{A}$
\end_inset

 into the given argument of type 
\begin_inset Formula $H^{A}\rightarrow A$
\end_inset

.
 So,
\begin_inset Foot
status open

\begin_layout Plain Layout
We did not prove that the type 
\begin_inset Formula $\forall A.\,(H^{A}\rightarrow A)\rightarrow A$
\end_inset

 is 
\emph on
equivalent
\emph default
 to 
\begin_inset Formula $\forall A.\,H^{A}$
\end_inset

.
 Later steps in the proof assume that 
\begin_inset Formula $\theta$
\end_inset

 has the form shown in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-base-runner-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Up to that assumption, the proof is rigorous.
\end_layout

\end_inset

 we need to produce a value of type 
\begin_inset Formula $H^{A}$
\end_inset

 for an arbitrary type 
\begin_inset Formula $A$
\end_inset

, that is, a value of type 
\begin_inset Formula $\forall A.\,H^{A}$
\end_inset

.
 Using the contravariant Yoneda identity, we can simplify this type expression
 to the type 
\begin_inset Formula $H^{\bbnum 1}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,H^{A}\cong\forall A.\,\gunderline{\bbnum 1}\rightarrow H^{A}\\
\text{use identity }(A\rightarrow\bbnum 1)\cong\bbnum 1:\quad & \cong\forall A.\,(A\rightarrow\bbnum 1)\rightarrow H^{A}\\
\text{contravariant Yoneda identity}:\quad & \cong H^{\bbnum 1}\quad.
\end{align*}

\end_inset

So, we can construct a 
\begin_inset Formula $\theta$
\end_inset

 if we take a value 
\begin_inset Formula $h_{1}$
\end_inset

 of type 
\begin_inset Formula $H^{\bbnum 1}$
\end_inset

 and compute 
\begin_inset Formula $h:H^{A}$
\end_inset

 as:
\begin_inset Formula 
\[
h^{:H^{A}}=h_{1}^{:H^{1}}\triangleright(a^{:A}\rightarrow1)^{\downarrow H}\quad.
\]

\end_inset

For any given value 
\begin_inset Formula $h_{1}:H^{\bbnum 1}$
\end_inset

, we can implement a runner 
\begin_inset Formula $\theta$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
\big(r^{:H^{A}\rightarrow A}\big)\triangleright\theta\triangleq h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright r\quad.\label{eq:rigid-monad-base-runner-1}
\end{equation}

\end_inset

Let us check whether this 
\begin_inset Formula $\theta$
\end_inset

 is a monad morphism 
\begin_inset Formula $R\leadsto\text{Id}$
\end_inset

.
 We need to verify the laws:
\begin_inset Formula 
\[
\text{pu}_{R}\bef\theta=\text{id}\quad,\quad\quad\text{ftn}_{R}\bef\theta=\theta^{\uparrow R}\bef\theta=\theta\bef\theta\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law, apply its both sides to an arbitrary 
\begin_inset Formula $x^{:A}$
\end_inset

 and simplify:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }x:\quad & x\triangleright\text{pu}_{R}\bef\theta=(x\triangleright\text{pu}_{R}\gunderline{)\triangleright\theta}\\
\text{definition of }r\triangleright\theta:\quad & =h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright(\gunderline{x\triangleright\text{pu}_{R}})\\
\text{definition of }x\triangleright\text{pu}_{R}:\quad & =\big(h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\gunderline{\big)\triangleright(\_\rightarrow}\,x)\\
\text{compute composition}:\quad & =x\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The composition law, applied to an arbitrary 
\begin_inset Formula $r:R^{R^{A}}$
\end_inset

, simplifies to:
\begin_inset Formula 
\begin{align*}
 & r\triangleright\text{ftn}_{R}\bef\theta=\gunderline{r\triangleright\text{ftn}_{R}}\,\triangleright\theta\\
\text{definition of }\text{ftn}_{R}:\quad & =\gunderline{r\triangleright\big(t\rightarrow}q\rightarrow q\triangleright\big(q\triangleright(x\rightarrow q\triangleright x)^{\downarrow H}\bef t\big)\big)\triangleright\theta\\
\text{apply to }r:\quad & =\big(q\rightarrow q\triangleright\big(q\triangleright(x\rightarrow q\triangleright x)^{\downarrow H}\bef r\big)\gunderline{\big)\triangleright\theta}\\
\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:\quad & =h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright\gunderline{\big(q\rightarrow}\,q\triangleright\big(q\triangleright(x\rightarrow q\triangleright x)^{\downarrow H}\bef r\big)\big)\\
\text{apply to }h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}:\quad & =h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright\big(h_{1}\triangleright\gunderline{(\_\rightarrow1)^{\downarrow H}\bef(x\rightarrow...)^{\downarrow H}}\bef r\big)\\
\text{composition under }^{\downarrow H}:\quad & =\gunderline{h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}}\triangleright\big(\gunderline{h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}}\triangleright r\big)\\
\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:\quad & =r\triangleright\theta\triangleright\theta=r\triangleright\theta\bef\theta\quad.
\end{align*}

\end_inset

This verifies the composition law.
 So, 
\begin_inset Formula $\theta$
\end_inset

 is indeed a monad morphism.
\end_layout

\begin_layout Standard
Using the code of 
\begin_inset Formula $\theta$
\end_inset

 defined in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-base-runner-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we can now verify the monadic naturality law of 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 (with respect to the runners 
\begin_inset Formula $\theta$
\end_inset

 of that form).
 The left-hand side of the law is given by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-1-derivation7"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & q\triangleright\big((q_{1}\rightarrow m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M}\gunderline{)\triangleright\theta}\big)\\
\text{definition of }\theta:\quad & =q\triangleright\big(h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\,\gunderline{\triangleright\,(q_{1}\rightarrow}m\triangleright\big(r\rightarrow q_{1}\triangleright\text{pu}_{M}^{\downarrow H}\bef r\big)^{\uparrow M})\big)\\
\text{apply to argument}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright\gunderline{(\_\rightarrow1)^{\downarrow H}\triangleright\text{pu}_{M}^{\downarrow H}}\bef r\big)^{\uparrow M}\big)\\
\text{composition under }^{\downarrow H}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright(\gunderline{\text{pu}_{M}\bef(\_\rightarrow1)})^{\downarrow H}\bef r\big)^{\uparrow M}\big)\\
\text{compute composition}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright(\gunderline{\_\rightarrow1})^{\downarrow H}\triangleright r\big)^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

The right-hand side is:
\begin_inset Formula 
\begin{align*}
 & q\triangleright(m\triangleright\gunderline{\theta}^{\uparrow M})\\
\text{expand function}:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow\gunderline{r\triangleright\theta}\big)^{\uparrow M}\big)\\
\text{definition~(\ref{eq:rigid-monad-base-runner-1}) of }\theta:\quad & =q\triangleright\big(m\triangleright\big(r\rightarrow h_{1}\triangleright(\_\rightarrow1)^{\downarrow H}\triangleright r\big)^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

This expression is now the same as the left-hand side.
\end_layout

\begin_layout Standard
This concludes the proof of the laws for the 
\begin_inset Quotes eld
\end_inset

choice
\begin_inset Quotes erd
\end_inset

 monad's transformer.
\end_layout

\begin_layout Section
Transformers for some monad constructions
\end_layout

\begin_layout Subsection
Transformer for products of monads.
 Proofs
\end_layout

\begin_layout Standard
The product of any two monads is again a monad (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-semimonad-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 If the two monads have known transformers, the product of the two transformers
 is the transformer for the product monad.
 
\end_layout

\begin_layout Standard
For instance, the product of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monads, 
\begin_inset Formula $L^{A}\triangleq(E+A)\times(R\rightarrow A)$
\end_inset

, has the transformer:
\begin_inset Formula 
\[
T_{L}^{M,A}\triangleq M^{E+A}\times(R\rightarrow M^{A})\quad.
\]

\end_inset

Note that this monad transformer is neither composed-outside nor composed-inside.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-product-of-monad-transformers"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-of-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The product of two lawful monad transformers satisfies all transformer laws.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Given two monads 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

 whose transformers 
\begin_inset Formula $T_{G}$
\end_inset

 and 
\begin_inset Formula $T_{H}$
\end_inset

 are known, we need to show that a lawful transformer for the monad 
\begin_inset Formula $L^{\bullet}\triangleq G^{\bullet}\times H^{\bullet}$
\end_inset

 is given by:
\begin_inset Formula 
\[
T_{L}^{M,A}\triangleq T_{G}^{M,A}\times T_{H}^{M,A}\quad.
\]

\end_inset

We will assume that all monad transformer laws already hold for 
\begin_inset Formula $T_{G}$
\end_inset

 and 
\begin_inset Formula $T_{H}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $T_{G}^{M}$
\end_inset

 and 
\begin_inset Formula $T_{H}^{M}$
\end_inset

 are (by assumption) lawful monads, 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 is a lawful monad by the product construction (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-semimonad-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
With 
\begin_inset Formula $M=\text{Id}$
\end_inset

, we have 
\begin_inset Formula $T_{L}^{\text{Id}}=T_{G}^{\text{Id}}\times T_{H}^{\text{Id}}$
\end_inset

.
 The equivalence 
\begin_inset Formula $T_{G}^{\text{Id}}\times T_{H}^{\text{Id}}\cong G\times H$
\end_inset

 is found via the pair product of the monad morphisms 
\begin_inset Formula $T_{G}^{\text{Id}}\cong G$
\end_inset

 and 
\begin_inset Formula $T_{H}^{\text{Id}}\cong H$
\end_inset

.
 The pair product of two monad morphisms is again a monad morphism (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Lifting laws
\end_layout

\begin_layout Standard
We define the foreign lift function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

) via the pair product:
\begin_inset Formula 
\[
\text{flift}_{L}^{:M\leadsto T_{G}^{M}\times T_{H}^{M}}\triangleq\Delta\bef(\text{flift}_{G}\boxtimes\text{flift}_{H})\quad.
\]

\end_inset

To show that 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

 is a monad morphism, we use the properties that 
\begin_inset Formula $\Delta:M\leadsto M\times M$
\end_inset

 is a monad morphism (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-M-to-M-times-M-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

), that the pair product preserves monad morphisms (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and that function composition also preserves monad morphisms (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Runner laws
\end_layout

\begin_layout Standard
We need to define the foreign runner (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

):
\begin_inset Formula 
\[
\text{frun}_{L}(\phi^{:M\leadsto N}):T_{G}^{M,A}\times T_{H}^{M,A}\leadsto T_{G}^{N,A}\times T_{H}^{N,A}\quad,\quad\quad\text{frun}_{L}(\phi)\triangleq\text{frun}_{G}(\phi)\boxtimes\text{frun}_{H}(\phi)\quad.
\]

\end_inset

The function returned by 
\begin_inset Formula $\text{frun}_{L}(\phi)$
\end_inset

 is a monad morphism by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The functor laws hold due to the properties of the pair product:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{frun}_{L}(\text{id})=\text{frun}_{G}(\text{id})\boxtimes\text{frun}_{H}(\text{id})=\text{id}\boxtimes\text{id}=\text{id}\quad,\\
\text{expect to equal }\text{frun}_{L}(\phi\bef\chi):\quad & \text{frun}_{L}(\phi)\bef\text{frun}_{L}(\chi)=\big(\gunderline{\text{frun}_{G}(\phi)\bef\text{frun}_{G}(\chi)}\big)\boxtimes\big(\gunderline{\text{frun}_{H}(\phi)\bef\text{frun}_{H}(\chi)}\big)\\
\text{functor laws of }\text{frun}_{G},\,\text{frun}_{H}:\quad & \quad=\text{frun}_{G}(\phi\bef\chi)\boxtimes\text{frun}_{H}(\phi\bef\chi)=\text{frun}_{L}(\phi\bef\chi)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Base runner laws
\end_layout

\begin_layout Standard
We may define a base runner in two different ways, by dropping either the
 first or the second part of the product.
 Both base runners are lawful.
 Consider the first one:
\begin_inset Formula 
\[
\text{brun}_{L}:T_{G}^{M}\times T_{H}^{M}\leadsto M\quad,\quad\quad\text{brun}_{L}\triangleq\pi_{1}\bef\text{brun}_{G}\quad.
\]

\end_inset

It is a monad morphism because it is a composition of a projection (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-projection-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and a monad morphism 
\begin_inset Formula $\text{brun}_{G}$
\end_inset

.
 Function composition preserves monad morphisms (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The nondegeneracy law holds because it holds for 
\begin_inset Formula $\text{brun}_{G}$
\end_inset

:
\begin_inset Formula 
\[
\text{flift}_{L}\bef\text{brun}_{L}=\Delta\bef\gunderline{(\text{flift}_{G}\boxtimes\text{flift}_{H})\bef\pi_{1}}\bef\text{brun}_{G}=\gunderline{\Delta\bef\pi_{1}}\bef\gunderline{\text{flift}_{G}\bef\text{brun}_{G}}=\text{id}\quad.
\]

\end_inset

Analogous proofs work for the other definition, 
\begin_inset Formula $\text{brun}_{L}\triangleq\pi_{2}\bef\text{brun}_{H}$
\end_inset

.
\end_layout

\begin_layout Standard
A deficiency of these base runners is that the effects of one of the monads
 (
\begin_inset Formula $G$
\end_inset

 or 
\begin_inset Formula $H$
\end_inset

) are being ignored, which loses information.
 If we would like to run the effects of both monads 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $H$
\end_inset

, we can instead implement a base runner into the monad 
\begin_inset Formula $M\times M$
\end_inset

.
 This corresponds to running the monad 
\begin_inset Formula $G\times H$
\end_inset

 into the 
\begin_inset Quotes eld
\end_inset

double-valued
\begin_inset Quotes erd
\end_inset

 monad 
\begin_inset Formula $D^{A}\triangleq A\times A$
\end_inset

, since 
\begin_inset Formula $T_{D}^{M}=M\times M$
\end_inset

.
 Define the base runner as:
\begin_inset Formula 
\[
\text{brun}_{L}:T_{G}^{M}\times T_{H}^{M}\leadsto M\times M\quad,\quad\quad\text{brun}_{L}\triangleq\text{brun}_{G}\boxtimes\text{brun}_{H}\quad.
\]

\end_inset

This is a monad morphism due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The nondegeneracy law has the form:
\begin_inset Formula 
\[
\text{flift}_{L}\bef\text{brun}_{L}=\Delta^{:M\leadsto M\times M}\quad,
\]

\end_inset

since the target monad is now 
\begin_inset Formula $M\times M$
\end_inset

.
 To verify the nondegeneracy law:
\begin_inset Formula 
\begin{align*}
 & \text{flift}_{L}\bef\text{brun}_{L}=\Delta\bef(\text{flift}_{G}\boxtimes\text{flift}_{H})\bef(\text{brun}_{G}\boxtimes\text{brun}_{H})\\
 & =\Delta\bef(\gunderline{\text{flift}_{G}\bef\text{brun}_{G}})\boxtimes(\gunderline{\text{flift}_{H}\bef\text{brun}_{H}})=\Delta\bef(\text{id}\boxtimes\text{id})=\Delta\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
To verify the monadic naturality law of 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{flift}_{L}\bef\text{frun}_{L}(\phi)=\Delta\bef(\text{flift}_{G}\boxtimes\text{flift}_{H})\bef(\text{frun}_{G}(\phi)\boxtimes\text{frun}_{H}(\phi))\\
 & =\Delta\bef(\gunderline{\text{flift}_{G}\bef\text{frun}_{G}}(\phi))\boxtimes(\gunderline{\text{flift}_{H}\bef\text{frun}_{H}(\phi)})=\Delta\bef(\gunderline{\phi}\bef\text{flift}_{G})\boxtimes(\gunderline{\phi}\bef\text{flift}_{H})\\
 & =\gunderline{\Delta\bef(\phi\boxtimes\phi)}\bef(\text{flift}_{G}\boxtimes\text{flift}_{H})=\phi\bef\gunderline{\Delta\bef(\text{flift}_{G}\boxtimes\text{flift}_{H})}=\phi\bef\text{flift}_{L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the monadic naturality law of an information-losing definition
 of 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{frun}_{L}(\phi)\bef\text{brun}_{L}=\gunderline{(\text{frun}_{G}(\phi)\boxtimes\text{frun}_{H}(\phi))\bef\pi_{1}}\bef\text{brun}_{G}=\pi_{1}\bef\text{frun}_{G}(\phi)\bef\text{brun}_{G}\quad,\\
 & \text{brun}_{L}\bef\phi=\pi_{1}\bef\gunderline{\text{brun}_{G}\bef\phi}=\pi_{1}\bef\text{frun}_{G}(\phi)\bef\text{brun}_{G}\quad.
\end{align*}

\end_inset

The runner 
\begin_inset Formula $\text{brun}_{L}:T_{L}^{M}\leadsto M\times M$
\end_inset

 also obeys a monadic naturality law involving 
\begin_inset Formula $\phi\boxtimes\phi$
\end_inset

 instead of 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{frun}_{L}(\phi)\bef\text{brun}_{L}=(\text{frun}_{G}(\phi)\boxtimes\text{frun}_{H}(\phi))\bef(\text{brun}_{G}\boxtimes\text{brun}_{H})\\
 & =(\gunderline{\text{frun}_{G}(\phi)\bef\text{brun}_{G}})\boxtimes(\gunderline{\text{frun}_{H}(\phi)\bef\text{brun}_{H}})=(\text{brun}_{G}\bef\phi)\boxtimes(\text{brun}_{H}\bef\phi)\\
 & =(\text{brun}_{G}\boxtimes\text{brun}_{H})\bef(\phi\boxtimes\phi)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Transformer for free pointed monads.
 Proofs
\end_layout

\begin_layout Standard
For an arbitrary monad 
\begin_inset Formula $K$
\end_inset

, a 
\series bold
free pointed monad
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
free pointed monad
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!free pointed
\end_layout

\end_inset


\series bold
on
\series default
 
\begin_inset Formula $K$
\end_inset

 is defined as the monad 
\begin_inset Formula $L^{A}\triangleq A+K^{A}$
\end_inset

 (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-product-with-identity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 An example of a free pointed monad is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

 monad (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-eager-lazy-evaluation-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) having the type 
\begin_inset Formula $A+(\bbnum 1\rightarrow A)$
\end_inset

, which is of the form 
\begin_inset Formula $A+K^{A}$
\end_inset

 with 
\begin_inset Formula $K^{A}\triangleq\bbnum 1\rightarrow A$
\end_inset

 being a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad.
 
\end_layout

\begin_layout Standard
Assuming that a given monad 
\begin_inset Formula $K$
\end_inset

 has a lawful transformer, we will now show that the free pointed monad
 on 
\begin_inset Formula $K$
\end_inset

 also has a monad transformer satisfying all laws.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-free-pointed-monad-transformer"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-free-pointed-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The monad 
\begin_inset Formula $L$
\end_inset

's transformer is defined by the type formula:
\begin_inset Formula 
\[
T_{L}^{M,A}\triangleq M^{A+T_{K}^{M,A}}\quad,
\]

\end_inset

where 
\begin_inset Formula $T_{K}$
\end_inset

 is the monad 
\begin_inset Formula $K$
\end_inset

's transformer, which is assumed to be known.
 
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We will define the necessary methods for 
\begin_inset Formula $T_{L}$
\end_inset

 when we need them in the course of the proof.
\end_layout

\begin_layout Standard
To verify the monad transformer laws for 
\begin_inset Formula $T_{L}$
\end_inset

, we begin by observing that 
\begin_inset Formula $A+T_{K}^{M,A}$
\end_inset

 is a free pointed monad on 
\begin_inset Formula $T_{K}^{M}$
\end_inset

.
 Let us denote for brevity:
\begin_inset Formula 
\[
N^{A}\triangleq T_{K}^{M,A}\quad,\quad\quad P^{A}\triangleq A+T_{K}^{M,A}=A+N^{A}\quad,\quad\quad T_{L}^{M,A}\triangleq M^{P^{A}}=\left(M\circ P\right)^{A}\quad.
\]

\end_inset

We know from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-co-product-with-identity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that 
\begin_inset Formula $P$
\end_inset

's monad methods are defined by:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{P}\triangleq a^{:A}\rightarrow a+\bbnum 0^{:N^{A}}\quad,\quad\text{ftn}_{P}\triangleq\,\begin{array}{|c||cc|}
 & A & N^{A}\\
\hline A & \text{id} & \bbnum 0\\
N^{A} & \bbnum 0 & \text{id}\\
N^{P^{A}} & \bbnum 0 & \gamma^{\uparrow N}\bef\text{ftn}_{N}
\end{array}\quad,\\
 & \quad\text{where}\quad\gamma^{:P^{A}\rightarrow N^{A}}\triangleq\,\begin{array}{|c||c|}
 & N^{A}\\
\hline A & \text{pu}_{N}\\
N^{A} & \text{id}
\end{array}\quad.
\end{align*}

\end_inset

The transformer 
\begin_inset Formula $T_{L}$
\end_inset

 is a composition of the foreign monad 
\begin_inset Formula $M$
\end_inset

 outside 
\begin_inset Formula $P$
\end_inset

.
 To show that 
\begin_inset Formula $T_{L}$
\end_inset

 is a monad, we may use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which requires a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function (denoted by 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{sw}$
\end_inset


\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\begin{equation}
\text{sw}:P^{M^{A}}\rightarrow M^{P^{A}}\quad,\quad\quad\text{sw}\triangleq\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0^{:A}+\text{merge}\,(t))\bef\text{pu}_{M}
\end{array}\quad.\label{eq:def-of-swap-for-free-pointed-monad-transformer}
\end{equation}

\end_inset

Here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 is a helper function that combines all effects contained within 
\begin_inset Formula $N^{M^{A}}$
\end_inset

 into one 
\begin_inset Formula $N$
\end_inset

-effect represented by a value of type 
\begin_inset Formula $N^{A}$
\end_inset

:
\begin_inset Formula 
\[
\text{merge}:N^{M^{A}}\rightarrow N^{A}\quad,\quad\quad\text{merge}\triangleq\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\quad.
\]

\end_inset

We will now verify all monad transformer laws for 
\begin_inset Formula $T_{L}.$
\end_inset


\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
The monad methods of 
\begin_inset Formula $T_{L}$
\end_inset

 are defined as in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
\text{pu}_{T}\triangleq\text{pu}_{P}\bef\text{pu}_{M}=(a^{:A}\rightarrow a+\bbnum 0^{:N^{A}})\bef\text{pu}_{M}\quad,\quad\quad\text{ftn}_{T}\triangleq\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{P}^{\uparrow M}\quad.
\]

\end_inset

The composition 
\begin_inset Formula $T_{L}^{M}\triangleq M\circ P$
\end_inset

 is a monad as long as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function obeys the naturality law and the four laws given in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

, if we replace 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 by 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

.
 Let us verify those laws.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function is a natural transformation because it is a combination of various
 natural transformations such as 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The outer identity law is 
\begin_inset Formula $\text{pu}_{M}^{\uparrow P}\bef\text{sw}=\text{pu}_{M}$
\end_inset

.
 We rewrite the left-hand side, expecting to obtain 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}^{\uparrow P}\bef\text{sw}=\,\begin{array}{|c||cc|}
 & M^{A} & N^{M^{A}}\\
\hline A & \text{pu}_{M} & \bbnum 0\\
N^{A} & \bbnum 0 & \text{pu}_{M}^{\uparrow N}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline M^{A} & (a\rightarrow a+\bbnum 0^{:N^{A}})^{\uparrow M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0^{:A}+\text{merge}\,(t))\bef\text{pu}_{M}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline A & \text{pu}_{M}\bef(a\rightarrow a+\bbnum 0^{:N^{A}})^{\uparrow M}\\
N^{A} & \text{pu}_{M}^{\uparrow N}\bef(t\rightarrow\bbnum 0^{:A}+\text{merge}\,(t))\bef\text{pu}_{M}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline A & (a\rightarrow a+\bbnum 0^{:N^{A}})\bef\text{pu}_{M}\\
N^{A} & (n\rightarrow\bbnum 0^{:A}+\text{merge}\,(n\triangleright\text{pu}_{M}^{\uparrow N}))\bef\text{pu}_{M}
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & A+N^{A}\\
\hline A & a\rightarrow a+\bbnum 0^{:N^{A}}\\
N^{A} & n\rightarrow\bbnum 0^{:A}+n\triangleright\text{pu}_{M}^{\uparrow N}\bef\text{merge}
\end{array}\,\bef\text{pu}_{M}=\,\begin{array}{|c||cc|}
 & A & N^{A}\\
\hline A & \text{id} & \bbnum 0\\
N^{A} & \bbnum 0 & \text{pu}_{M}^{\uparrow N}\bef\text{merge}
\end{array}\,\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

It remains to show that the matrix element 
\begin_inset Formula $\text{pu}_{M}^{\uparrow N}\bef\text{merge}$
\end_inset

 is equal to the identity function:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{pu}_{M}^{\uparrow N}\bef\text{merge}=\gunderline{\text{pu}_{M}^{\uparrow N}\bef\text{flift}_{K}^{\uparrow N}}\bef\text{ftn}_{N}\\
\text{monad morphism law of }\text{flift}_{K}:\quad & =\text{pu}_{N}^{\uparrow N}\bef\text{ftn}_{N}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The inner identity law is 
\begin_inset Formula $\text{pu}_{P}\bef\text{sw}=\text{pu}_{P}^{\uparrow M}$
\end_inset

.
 Begin with the left-hand side:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{P}\bef\text{sw}=(m^{:M^{A}}\rightarrow m+\bbnum 0^{:N^{M^{A}}})\bef\text{sw}\\
 & =\,\begin{array}{|c||cc|}
 & M^{A} & N^{M^{A}}\\
\hline M^{A} & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\\
N^{M^{A}} & (n\rightarrow\bbnum 0^{:A}+\text{merge}\,(n))\bef\text{pu}_{M}
\end{array}\,=\text{pu}_{P}^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The outer interchange law is:
\begin_inset Formula 
\[
\text{ftn}_{M}^{\uparrow P}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

Begin with the right-hand side since it is more complicated, and use the
 identity law we just proved:
\begin_inset Formula 
\begin{align*}
 & \text{sw}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline M^{M^{A}} & \gunderline{\text{pu}_{P}^{\uparrow M}\bef\text{sw}^{\uparrow M}}\bef\text{ftn}_{M}\\
N^{M^{M^{A}}} & (n\rightarrow\bbnum 0+\text{merge}\,(t))\bef\gunderline{\text{pu}_{M}\bef\text{sw}^{\uparrow M}}\bef\text{ftn}_{M}
\end{array}\\
 & =\,\begin{array}{||c|}
\gunderline{\text{pu}_{P}^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\\
(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{sw}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}
\end{array}\,=\,\begin{array}{||c|}
\text{ftn}_{M}\bef\text{pu}_{P}^{\uparrow M}\\
(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{sw}
\end{array}\quad.
\end{align*}

\end_inset

The left-hand side of the law is written as:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{M}^{\uparrow P}\bef\text{sw}=\,\begin{array}{|c||cc|}
 & M^{A} & N^{M^{A}}\\
\hline M^{M^{A}} & \text{ftn}_{M} & \bbnum 0\\
N^{M^{M^{A}}} & \bbnum 0 & \text{ftn}_{M}^{\uparrow N}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & M^{A+N^{A}}\\
\hline M^{M^{A}} & \text{ftn}_{M}\bef\text{pu}_{P}^{\uparrow M}\\
N^{M^{M^{A}}} & \text{ftn}_{M}^{\uparrow N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}
\end{array}\quad.
\end{align*}

\end_inset

The first rows of the matrices for the two sides of the law are now equal
 (to 
\begin_inset Formula $\text{ftn}_{M}\bef\text{pu}_{P}^{\uparrow M}$
\end_inset

).
 It remains to show that  the second rows of the matrices are also equal:
\begin_inset Formula 
\begin{align*}
 & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{sw}\overset{?}{=}\text{ftn}_{M}^{\uparrow N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\quad,\\
\text{apply both sides to }t:\quad & (\bbnum 0+t\triangleright\text{merge})\,\gunderline{\triangleright\,\text{sw}}\overset{?}{=}\big(\bbnum 0+t\triangleright\text{ftn}_{M}^{\uparrow N}\triangleright\text{merge}\big)\triangleright\text{pu}_{M}\quad,\\
\text{apply }\text{sw}:\quad & (\bbnum 0+t\triangleright\text{merge}\triangleright\text{merge})\triangleright\text{pu}_{M}\overset{?}{=}\big(\bbnum 0+t\triangleright\text{ftn}_{M}^{\uparrow N}\triangleright\text{merge}\big)\triangleright\text{pu}_{M}\quad.
\end{align*}

\end_inset

We will prove the last equality if we show that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 has the following property:
\begin_inset Formula 
\[
\text{merge}\bef\text{merge}=\text{ftn}_{M}^{\uparrow N}\bef\text{merge}\quad,\quad\text{or}:\quad\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}=\text{ftn}_{M}^{\uparrow N}\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\quad.
\]

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{3.5pc}N^{M^{M^{A}}}\ar[r]\sp(0.55){\text{merge}^{M^{A}}}\ar[d]\sb(0.45){\text{ftn}_{M}^{\uparrow N}} & N^{M^{A}}\ar[d]\sb(0.45){\text{merge}^{A}}\\
N^{M^{A}}\ar[r]\sp(0.55){\text{merge}^{A}} & N^{A}
}
\]

\end_inset

We know nothing about the transformer 
\begin_inset Formula $T_{K}$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 function except for its laws.
 The law connecting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 is the lifting law:
\begin_inset Formula 
\begin{equation}
\text{flift}_{K}\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}=\text{ftn}_{M}\bef\text{flift}_{K}\quad.\label{eq:free-pointed-transformer-use-lifting-derivation1}
\end{equation}

\end_inset

To make use of that law, we use other laws to transform the expression 
\begin_inset Formula $\text{merge}\bef\text{merge}$
\end_inset

, so that the two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 functions are composed together and are followed by 
\begin_inset Formula $\text{ftn}_{N}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{M}^{\uparrow N}\bef\text{merge}:\quad & \text{merge}\bef\text{merge}=\text{flift}_{K}^{\uparrow N}\bef\gunderline{\text{ftn}_{N}\bef\text{flift}_{K}^{\uparrow N}}\bef\text{ftn}_{N}\\
\text{naturality of }\text{ftn}_{N}:\quad & =\text{flift}_{K}^{\uparrow N}\bef\text{flift}_{K}^{\uparrow N\uparrow N}\bef\gunderline{\text{ftn}_{N}\bef\text{ftn}_{N}}\\
\text{associativity law of }\text{ftn}_{N}:\quad & =\gunderline{\text{flift}_{K}^{\uparrow N}\bef\text{flift}_{K}^{\uparrow N\uparrow N}\bef\text{ftn}_{N}^{\uparrow N}}\bef\text{ftn}_{N}=(\gunderline{\text{flift}_{K}\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}})^{\uparrow N}\bef\text{ftn}_{N}\\
\text{lifting law~(\ref{eq:free-pointed-transformer-use-lifting-derivation1})}:\quad & =\gunderline{(\text{ftn}_{M}\bef\text{flift}_{K})^{\uparrow N}}\bef\text{ftn}_{N}=\text{ftn}_{M}^{\uparrow N}\bef\gunderline{\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}}=\text{ftn}_{M}^{\uparrow N}\bef\text{merge}\quad.
\end{align*}

\end_inset

This completes the proof of the outer interchange law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The inner interchange law is:
\begin_inset Formula 
\[
\text{ftn}_{P}\bef\text{sw}=\text{sw}^{\uparrow P}\bef\text{sw}\bef\text{ftn}_{P}^{\uparrow M}\quad.
\]

\end_inset

The left-hand side of that law is rewritten as:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{P}\bef\text{sw}=\,\begin{array}{|c||cc|}
 & M^{A} & N^{M^{A}}\\
\hline M^{A} & \text{id} & \bbnum 0\\
N^{M^{A}} & \bbnum 0 & \text{id}\\
N^{P^{M^{A}}} & \bbnum 0 & \gamma^{\uparrow N}\bef\text{ftn}_{N}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{P^{A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & M^{P^{A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\\
N^{P^{M^{A}}} & \gamma^{\uparrow N}\bef\text{ftn}_{N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}
\end{array}\quad.
\end{align*}

\end_inset

The right-hand side is rewritten using the identity law of 
\begin_inset Formula $\text{ftn}_{P}$
\end_inset

 and the naturality law of 
\begin_inset Formula $\text{pu}_{P}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow P}\bef\text{sw}\bef\text{ftn}_{P}^{\uparrow M}\\
 & =\,\begin{array}{|c||cc|}
 & M^{P^{A}} & N^{M^{P^{A}}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M} & \bbnum 0\\
N^{M^{A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M} & \bbnum 0\\
N^{P^{M^{A}}} & \bbnum 0 & \text{sw}^{\uparrow N}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{P^{A}}\\
\hline M^{P^{A}} & \gunderline{\text{pu}_{P}^{\uparrow M}\bef\text{ftn}_{P}^{\uparrow M}}\\
N^{M^{P^{A}}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{P}^{\uparrow M}}
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & M^{P^{A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\\
N^{P^{M^{A}}} & \text{sw}^{\uparrow N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{ftn}_{P}\bef\text{pu}_{M}
\end{array}\quad.
\end{align*}

\end_inset

The difference between the two sides is only in the third rows of the matrices:
\begin_inset Formula 
\[
\gamma^{\uparrow N}\bef\text{ftn}_{N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\overset{?}{=}\text{sw}^{\uparrow N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{ftn}_{P}\bef\text{pu}_{M}\quad.
\]

\end_inset

We can omit the composition with 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 if we can prove a stronger condition:
\begin_inset Formula 
\begin{equation}
\gamma^{\uparrow N}\bef\text{ftn}_{N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\overset{?}{=}\text{sw}^{\uparrow N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{ftn}_{P}\quad.\label{free-pointed-transformer-derivation0}
\end{equation}

\end_inset

Apply both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "free-pointed-transformer-derivation0"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary 
\begin_inset Formula $n:N^{P^{M^{A}}}$
\end_inset

.
 The left-hand side becomes:
\begin_inset Formula 
\begin{align*}
 & n\triangleright\gamma^{\uparrow N}\bef\text{ftn}_{N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))=\bbnum 0+n\triangleright\gamma^{\uparrow N}\triangleright\text{ftn}_{N}\triangleright\text{merge}\quad.
\end{align*}

\end_inset

The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "free-pointed-transformer-derivation0"
plural "false"
caps "false"
noprefix "false"

\end_inset

) applied to 
\begin_inset Formula $n$
\end_inset

 is:
\begin_inset Formula 
\begin{align*}
 & n\triangleright\text{sw}^{\uparrow N}\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{ftn}_{P}=(\bbnum 0+n\triangleright\text{sw}^{\uparrow N}\triangleright\text{merge})\triangleright\text{ftn}_{P}\\
 & =(\bbnum 0+n\triangleright\text{sw}^{\uparrow N}\bef\text{merge})\triangleright\,\begin{array}{|c||cc|}
 & A & N^{A}\\
\hline A & \text{id} & \bbnum 0\\
N^{A} & \bbnum 0 & \text{id}\\
N^{P^{A}} & \bbnum 0 & \gamma^{\uparrow N}\bef\text{ftn}_{N}
\end{array}\,=\bbnum 0+n\triangleright\text{sw}^{\uparrow N}\bef\text{merge}\bef\gamma^{\uparrow N}\bef\text{ftn}_{N}\quad.
\end{align*}

\end_inset

The remaining difference is between two functions of type 
\begin_inset Formula $N^{P^{M^{A}}}\rightarrow N^{A}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\gamma^{\uparrow N}\bef\text{ftn}_{N}\bef\text{merge}\overset{?}{=}\text{sw}^{\uparrow N}\bef\text{merge}\bef\gamma^{\uparrow N}\bef\text{ftn}_{N}\quad.\label{eq:free-pointed-transformer-derivation1}
\end{equation}

\end_inset

The left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-transformer-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) can be rewritten as:
\begin_inset Formula 
\begin{align*}
 & \gamma^{\uparrow N}\bef\text{ftn}_{N}\bef\text{merge}=\gamma^{\uparrow N}\bef\gunderline{\text{ftn}_{N}\bef\text{flift}_{K}^{\uparrow N}}\bef\text{ftn}_{N}\\
\text{naturality of }\text{ftn}_{N}:\quad & =\gamma^{\uparrow N}\bef\text{flift}_{K}^{\uparrow N\uparrow N}\bef\gunderline{\text{ftn}_{N}\bef\text{ftn}_{N}}\\
\text{associativity law of }\text{ftn}_{N}:\quad & =\gamma^{\uparrow N}\bef\text{flift}_{K}^{\uparrow N\uparrow N}\bef\text{ftn}_{N}^{\uparrow N}\bef\text{ftn}_{N}=\big(\gamma\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\big)^{\uparrow N}\bef\text{ftn}_{N}\quad.
\end{align*}

\end_inset

The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-transformer-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow N}\bef\text{merge}\bef\gamma^{\uparrow N}\bef\text{ftn}_{N}\\
\text{naturality of }\text{merge}:\quad & =\text{sw}^{\uparrow N}\bef\gamma^{\uparrow M\uparrow N}\bef\text{merge}\bef\text{ftn}_{N}=\text{sw}^{\uparrow N}\bef\gamma^{\uparrow M\uparrow N}\bef\text{flift}_{K}^{\uparrow N}\bef\gunderline{\text{ftn}_{N}\bef\text{ftn}_{N}}\\
\text{associativity law of }\text{ftn}_{N}:\quad & =\big(\text{sw}\bef\gamma^{\uparrow M}\bef\text{flift}_{K}\bef\text{ftn}_{N}\big)^{\uparrow N}\bef\text{ftn}_{N}\quad.
\end{align*}

\end_inset

The remaining difference is now between two functions of type 
\begin_inset Formula $P^{M^{A}}\rightarrow N^{A}$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
\gamma\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\overset{?}{=}\text{sw}\bef\gamma^{\uparrow M}\bef\text{flift}_{K}\bef\text{ftn}_{N}\quad.\label{eq:free-pointed-transformer-derivation2}
\end{equation}

\end_inset

The left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-transformer-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is:
\begin_inset Formula 
\begin{align*}
 & \gamma\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}=\,\begin{array}{|c||c|}
 & N^{M^{A}}\\
\hline M^{A} & \text{pu}_{N}\\
N^{M^{A}} & \text{id}
\end{array}\,\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}=\,\begin{array}{|c||c|}
 & N^{A}\\
\hline M^{A} & \gunderline{\text{pu}_{N}\bef\text{flift}_{K}^{\uparrow N}}\bef\text{ftn}_{N}\\
N^{M^{A}} & \text{id}\bef\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & N^{A}\\
\hline M^{A} & \text{flift}_{K}\bef\gunderline{\text{pu}_{N}\bef\text{ftn}_{N}}\\
N^{M^{A}} & \text{id}\bef\gunderline{\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}}
\end{array}\,=\,\begin{array}{|c||c|}
 & N^{A}\\
\hline M^{A} & \text{flift}_{K}\\
N^{M^{A}} & \text{merge}
\end{array}\quad.
\end{align*}

\end_inset

To proceed with the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-transformer-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we compute some intermediate expressions:
\begin_inset Formula 
\begin{align*}
 & \text{sw}\bef\gamma^{\uparrow M}=\,\begin{array}{|c||c|}
 & M^{N^{A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\bef\gamma^{\uparrow M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\bef\gamma^{\uparrow M}
\end{array}\quad,\\
 & \text{pu}_{P}\bef\gamma=(a^{:A}\rightarrow a+\bbnum 0)\bef\,\begin{array}{|c||c|}
 & N^{A}\\
\hline A & \text{pu}_{N}\\
N^{A} & \text{id}
\end{array}\,=a^{:A}\rightarrow\text{pu}_{N}(a)=\text{pu}_{N}\quad,\\
 & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\bef\gamma^{\uparrow M}=(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\gamma\bef\text{pu}_{M}\\
 & \quad=(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\,\begin{array}{|c||c|}
 & N^{A}\\
\hline A & \text{pu}_{N}\\
N^{A} & \text{id}
\end{array}\,\bef\text{pu}_{M}=t\rightarrow\text{merge}\,(t)\triangleright\text{pu}_{M}=\text{merge}\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

Now we can reduce the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-transformer-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to:
\begin_inset Formula 
\begin{align*}
 & \text{sw}\bef\gamma^{\uparrow M}\bef\text{flift}_{K}\bef\text{ftn}_{N}=\,\begin{array}{|c||c|}
 & N^{A}\\
\hline M^{A} & \gunderline{\text{pu}_{N}^{\uparrow M}\bef\text{flift}_{K}}\bef\text{ftn}_{N}\\
N^{M^{A}} & \text{merge}\bef\gunderline{\text{pu}_{M}\bef\text{flift}_{K}}\bef\text{ftn}_{N}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & N^{A}\\
\hline M^{A} & \text{flift}_{K}\bef\gunderline{\text{pu}_{N}^{\uparrow N}\bef\text{ftn}_{N}}\\
N^{M^{A}} & \text{merge}\bef\gunderline{\text{pu}_{N}\bef\text{ftn}_{N}}
\end{array}\,=\,\begin{array}{|c||c|}
 & N^{A}\\
\hline M^{A} & \text{flift}_{K}\\
N^{M^{A}} & \text{merge}
\end{array}\quad.
\end{align*}

\end_inset

This equals the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-transformer-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
The identity laws hold: setting 
\begin_inset Formula $M=\text{Id}$
\end_inset

 in the type of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 gives the isomorphism:
\begin_inset Formula 
\[
T_{L}^{\text{Id},A}\triangleq\text{Id}^{A+T_{K}^{\text{Id},A}}\cong A+K^{A}\triangleq L^{A}\quad.
\]

\end_inset

The two directions of the isomorphism 
\begin_inset Formula $A+T_{K}^{\text{Id},A}\cong A+K^{A}$
\end_inset

 are monad morphisms due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-composition-transformer-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

, assuming that the identity law already holds for the transformer 
\begin_inset Formula $T_{K}$
\end_inset

.
 We also need the property that the free pointed construction preserves
 monad morphisms (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then the assumed monad isomorphism 
\begin_inset Formula $T_{K}^{\text{Id}}\cong K$
\end_inset

 extends to a monad isomorphism 
\begin_inset Formula $A+T_{K}^{\text{Id},A}\cong A+K^{A}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Lifting laws
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 for 
\begin_inset Formula $T_{L}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
\text{flift}_{L}:M^{A}\rightarrow M^{P^{A}}\quad,\quad\quad\text{flift}_{L}\triangleq\text{pu}_{P}^{\uparrow M}\quad.
\]

\end_inset

To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is a monad morphism, we refer to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-transformer-lifting-laws-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and consider 
\begin_inset Formula $P$
\end_inset

 as the base monad and 
\begin_inset Formula $M$
\end_inset

 as the foreign monad.
\end_layout

\begin_layout Paragraph
Implementation of runners
\end_layout

\begin_layout Standard
We cannot use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-transformer-runner-laws-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to verify the runner laws for 
\begin_inset Formula $T_{L}$
\end_inset

, because the transformer 
\begin_inset Formula $T_{L}^{M}=M\circ P$
\end_inset

 is not compositional: the monad 
\begin_inset Formula $P$
\end_inset

 uses in its definition the monad 
\begin_inset Formula $M$
\end_inset

 as 
\begin_inset Formula $P^{A}\triangleq A+T_{K}^{M,A}$
\end_inset

.
 Mapping the monad 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $M^{\prime}$
\end_inset

 requires us also to map 
\begin_inset Formula $P$
\end_inset

 to 
\begin_inset Formula $P^{\prime}\triangleq A+T_{K}^{M^{\prime},A}$
\end_inset

.
 So, the runners (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

) must be defined differently from those in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-transformer-runner-laws-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{frun}_{L}^{M,M^{\prime}}\!:(M\leadsto M^{\prime})\rightarrow M^{P^{A}}\rightarrow M^{\prime P^{\prime A}}\!\quad,\quad\text{frun}_{L}^{M,M^{\prime}}\!(\phi^{:M\leadsto M^{\prime}})\triangleq\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}^{\uparrow M}\bef\phi\quad,
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{brun}_{L}:(L\leadsto\text{Id})\rightarrow M^{P^{A}}\rightarrow M^{A}\quad,\quad\text{brun}_{L}(\theta^{:L\leadsto\text{Id}})\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
T_{K}^{M,A} & \text{brun}_{K}((k\rightarrow\bbnum 0+k)\bef\theta)
\end{array}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \text{frun}_{L}^{M,M^{\prime}}\!:(M\leadsto M^{\prime})\rightarrow M^{P^{A}}\rightarrow M^{\prime P^{\prime A}}\!\quad,\quad\text{frun}_{L}^{M,M^{\prime}}\!(\phi^{:M\leadsto M^{\prime}})\triangleq\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}^{\uparrow M}\bef\phi\quad,\\
 & \text{brun}_{L}:(L\leadsto\text{Id})\rightarrow M^{P^{A}}\rightarrow M^{A}\quad,\quad\text{brun}_{L}(\theta^{:L\leadsto\text{Id}})\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
T_{K}^{M,A} & \text{brun}_{K}((k\rightarrow\bbnum 0+k)\bef\theta)
\end{array}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\end_inset

The function 
\begin_inset Formula $(k\rightarrow\bbnum 0+k)\bef\theta$
\end_inset

 is a runner 
\begin_inset Formula $K\leadsto\text{Id}$
\end_inset

 as shown by Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

(d).
 If the transformer 
\begin_inset Formula $T_{K}^{M}$
\end_inset

 does not have a general base runner, the definition of 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 above will need to use any available base runner 
\begin_inset Formula $\text{brun}_{K}$
\end_inset

 instead of 
\begin_inset Formula $\text{brun}_{K}((k\rightarrow\bbnum 0+k)\bef\theta)$
\end_inset

.
\end_layout

\begin_layout Standard
If the transformer 
\begin_inset Formula $T_{K}$
\end_inset

 has no base runner, we will be unable to define a base runner for 
\begin_inset Formula $T_{L}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Monadic naturality of 
\family typewriter
swap
\end_layout

\begin_layout Standard
The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is the same for any foreign monad 
\begin_inset Formula $M$
\end_inset

; it means that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is natural in the monad parameter 
\begin_inset Formula $M$
\end_inset

.
 However, since the monad 
\begin_inset Formula $P$
\end_inset

 depends on 
\begin_inset Formula $M$
\end_inset

, the monadic naturality of 
\begin_inset Formula $\text{sw}_{M,P}$
\end_inset

 with respect to the monad 
\begin_inset Formula $M$
\end_inset

 is not simply the monadic naturality of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap[M[_], P[_], A]
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

M[_]
\end_layout

\end_inset

.
 For any monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

, we need to use the corresponding monad morphism between 
\begin_inset Formula $P\leadsto P^{\prime}$
\end_inset

 (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which we will temporarily denote by 
\begin_inset Formula $\psi$
\end_inset

:
\begin_inset Formula 
\[
\psi\triangleq\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\quad.
\]

\end_inset

We now write the monadic naturality law relating 
\begin_inset Formula $\text{sw}_{M,P}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{M^{\prime},P^{\prime}}$
\end_inset

 like this:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{2.3pc}P^{M^{A}}\ar[d]\sb(0.45){\text{sw}_{M,P}}\ar[r]\sp(0.5){\phi^{\uparrow P}} & P^{M^{\prime A}}\ar[r]\sp(0.45){\psi} & P^{\prime M^{\prime A}}\ar[d]\sb(0.45){\,\text{sw}_{M^{\prime},P^{\prime}}}\\
M^{P^{A}}\ar[r]\sp(0.5){\psi^{\uparrow M}} & M^{P^{\prime A}}\ar[r]\sp(0.45){\phi} & M^{\prime P^{\prime A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{sw}_{M,P}\bef\psi^{\uparrow M}\bef\phi=\phi^{\uparrow P}\bef\psi\bef\text{sw}_{M^{\prime},P^{\prime}}\quad.\label{eq:monadic-naturality-free-pointed-swap}
\end{equation}

\end_inset

To verify this law, substitute the definition of 
\begin_inset Formula $\text{sw}_{M,P}$
\end_inset

 into its two sides:
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{M,P}\bef\psi^{\uparrow M}\bef\phi=\,\begin{array}{|c||c|}
 & M^{\prime P^{\prime A}}\\
\hline M^{A} & \text{pu}_{P}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi\\
N^{M^{A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\bef\psi^{\uparrow M}\bef\phi
\end{array}\\
 & \quad=\,\begin{array}{||c|}
\text{pu}_{P}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi\\
(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M}\bef\psi^{\uparrow M}\bef\phi
\end{array}\\
 & \quad=\,\begin{array}{||c|}
\phi\bef(\text{pu}_{P}\bef\psi)^{\uparrow M^{\prime}}\\
(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\psi\bef\text{pu}_{M}\bef\phi
\end{array}\,=\,\begin{array}{||c|}
\phi\bef\text{pu}_{P^{\prime}}^{\uparrow M^{\prime}}\\
(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\psi\bef\text{pu}_{M^{\prime}}
\end{array}\quad,\\
 & \phi^{\uparrow P}\bef\psi\bef\text{sw}_{M^{\prime},P^{\prime}}=\,\begin{array}{|c||cc|}
 & M^{\prime A} & N^{M^{\prime A}}\\
\hline M^{A} & \phi & \bbnum 0\\
N^{M^{A}} & \bbnum 0 & \phi^{\uparrow N}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & M^{\prime A} & T_{K}^{M^{\prime},M^{\prime A}}\\
\hline M^{\prime A} & \text{id} & \bbnum 0\\
T_{K}^{M,M^{\prime A}} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\,\bef\text{sw}_{M^{\prime},P^{\prime}}\\
 & \quad=\,\begin{array}{|c||cc|}
 & M^{\prime A} & T_{K}^{M^{\prime},M^{\prime A}}\\
\hline M^{A} & \phi & \bbnum 0\\
T_{K}^{M,M^{A}} & \bbnum 0 & \phi^{\uparrow N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{\prime P^{\prime A}}\\
\hline M^{\prime A} & \text{pu}_{P^{\prime}}^{\uparrow M^{\prime}}\\
T_{K}^{M^{\prime},M^{\prime A}} & (t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M^{\prime}}
\end{array}\\
 & \quad=\,\,\begin{array}{|c||c|}
 & M^{\prime P^{\prime A}}\\
\hline M^{A} & \phi\bef\text{pu}_{P^{\prime}}^{\uparrow M^{\prime}}\\
T_{K}^{M,M^{A}} & \phi^{\uparrow N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\text{pu}_{M^{\prime}}
\end{array}\quad.
\end{align*}

\end_inset

It remains to show the equality of two functions of type 
\begin_inset Formula $T_{K}^{M,M^{A}}\rightarrow A+T_{K}^{M^{\prime},A}=N^{M^{A}}\rightarrow A+T_{K}^{M^{\prime},A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \phi^{\uparrow N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef(t\rightarrow\bbnum 0+\text{merge}\,(t))\overset{?}{=}(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\psi\\
 & =(t\rightarrow\bbnum 0+\text{merge}\,(t))\bef\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\,=t\rightarrow\bbnum 0+t\triangleright\text{merge}\triangleright\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\quad.
\end{align*}

\end_inset

Since both functions produce results of type 
\begin_inset Formula $\bbnum 0^{:A}+T_{K}^{M^{\prime},A}$
\end_inset

, we need to compare the following two functions of type 
\begin_inset Formula $N^{M^{A}}\rightarrow N^{\prime A}$
\end_inset

, where we denote for brevity 
\begin_inset Formula $N^{\prime A}\triangleq T_{K}^{M^{\prime},A}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \phi^{\uparrow N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef\text{merge}\overset{?}{=}\text{merge}\bef\text{frun}_{K}^{M,M^{\prime}}(\phi)\quad,\nonumber \\
\text{or equivalently}:\quad & \phi^{\uparrow N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef\text{flift}_{K}^{\uparrow N^{\prime}}\bef\text{ftn}_{N^{\prime}}\overset{?}{=}\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\bef\text{frun}_{K}^{M,M^{\prime}}(\phi)\quad.\label{eq:free-pointed-sw-monadic-naturality-derivation1}
\end{align}

\end_inset

Rewrite the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-sw-monadic-naturality-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) so that 
\begin_inset Formula $\text{frun}\left(\phi\right)$
\end_inset

 is moved to the right in the composition:
\begin_inset Formula 
\begin{align*}
 & \phi^{\uparrow N}\bef\gunderline{\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef\text{flift}_{K}^{\uparrow N^{\prime}}}\bef\text{ftn}_{N^{\prime}}=(\gunderline{\phi\bef\text{flift}_{K}})^{\uparrow N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef\text{ftn}_{N^{\prime}}\\
\text{use law~(\ref{eq:monadic-naturality-law-of-flift})}:\quad & =\text{flift}_{K}^{\uparrow N}\bef\gunderline{\big(\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\big)^{\uparrow N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef\text{ftn}_{N^{\prime}}}\\
\text{composition law of }\text{frun}_{K}:\quad & =\text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\bef\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\quad.
\end{align*}

\end_inset

This equals the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-pointed-sw-monadic-naturality-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), proving the monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-free-pointed-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Runner laws
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{frun}_{L}^{M,M^{\prime}}(\phi)$
\end_inset

 is a monad morphism, first verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M^{\prime}\circ P^{\prime}}:\quad & \text{pu}_{M\circ P}\bef\text{frun}_{L}^{M,M^{\prime}}\!(\phi)=\text{pu}_{P}\bef\gunderline{\text{pu}_{M}\bef\psi^{\uparrow M}}\bef\phi\\
\text{naturality law of }\text{pu}_{M}:\quad & =\gunderline{\text{pu}_{P}\bef\psi}\bef\gunderline{\text{pu}_{M}\bef\phi}\\
\text{identity laws of }\phi\text{ and }\psi:\quad & =\text{pu}_{P^{\prime}}\bef\text{pu}_{M^{\prime}}=\text{pu}_{M^{\prime}\circ P^{\prime}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law, express 
\begin_inset Formula $\text{frun}_{L}^{M,M^{\prime}}=\psi^{\uparrow M}\bef\phi$
\end_inset

 and recall that 
\begin_inset Formula $f^{\uparrow(M\circ P)}=f^{\uparrow P\uparrow M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (\psi^{\uparrow M}\bef\phi)^{\uparrow(M\circ P)}\bef\psi^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}\circ P^{\prime}}\\
\text{definition of }\text{ftn}_{M^{\prime}\circ P^{\prime}}:\quad & \quad=(\psi^{\uparrow M}\bef\phi)^{\uparrow(M\circ P)}\bef\psi^{\uparrow M}\bef\phi\bef\text{sw}_{M^{\prime},P^{\prime}}^{\uparrow M^{\prime}}\bef\text{ftn}_{M^{\prime}}\bef\text{ftn}_{P^{\prime}}^{\uparrow M^{\prime}}\quad,\\
\text{right-hand side}:\quad & \text{ftn}_{M\circ P}\bef\psi^{\uparrow M}\bef\phi=\text{sw}_{M,P}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{P}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi\quad.
\end{align*}

\end_inset

We need to use various laws to rewrite the left-hand side so that the functions
 
\begin_inset Formula $\psi$
\end_inset

 and 
\begin_inset Formula $\phi$
\end_inset

 are moved to the right in the function composition:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (\psi^{\uparrow M}\bef\phi)^{\uparrow(M\circ P)}\bef\psi^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}\circ P^{\prime}}\\
\text{definition of }\text{ftn}_{M^{\prime}\circ P^{\prime}}:\quad & =(\psi^{\uparrow M}\bef\phi)^{\uparrow(M\circ P)}\bef\psi^{\uparrow M}\bef\gunderline{\phi\bef\text{sw}_{M^{\prime},P^{\prime}}^{\uparrow M^{\prime}}}\bef\text{ftn}_{M^{\prime}}\bef\text{ftn}_{P^{\prime}}^{\uparrow M^{\prime}}\\
\text{naturality law of }\phi:\quad & =\gunderline{(\psi^{\uparrow M}\bef\phi)^{\uparrow P\uparrow M}\bef\psi^{\uparrow M}\bef\text{sw}_{M^{\prime},P^{\prime}}^{\uparrow M}}\bef\phi\bef\text{ftn}_{M^{\prime}}\bef\text{ftn}_{P^{\prime}}^{\uparrow M^{\prime}}\\
\text{composition under }^{\uparrow M}:\quad & =\big(\psi^{\uparrow M\uparrow P}\bef\gunderline{\phi^{\uparrow P}\bef\psi\bef\text{sw}_{M^{\prime},P^{\prime}}}\big)^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}\bef\text{ftn}_{P^{\prime}}^{\uparrow M^{\prime}}\\
\text{use Eq.~(\ref{eq:monadic-naturality-free-pointed-swap}) for }\text{sw}_{M^{\prime},P^{\prime}}:\quad & =\big(\psi^{\uparrow M\uparrow P}\bef\text{sw}_{M,P}\bef\psi^{\uparrow M}\bef\gunderline{\phi\big)^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}}\bef\text{ftn}_{P^{\prime}}^{\uparrow M^{\prime}}\\
\text{composition law of }\phi:\quad & =\big(\gunderline{\psi^{\uparrow M\uparrow P}\bef\text{sw}_{M,P}}\bef\gunderline{\psi^{\uparrow M}\big)^{\uparrow M}\bef\text{ftn}_{M}}\bef\gunderline{\phi\bef\text{ftn}_{P^{\prime}}^{\uparrow M^{\prime}}}\\
\text{naturality of }\text{sw}\text{, }\phi\text{, and }\text{ftn}_{M}:\quad & =\big(\text{sw}_{M,P}\bef\gunderline{\psi^{\uparrow P\uparrow M}\big)^{\uparrow M}\bef\text{ftn}_{M}}\bef\psi^{\uparrow M}\bef\text{ftn}_{P^{\prime}}^{\uparrow M}\bef\phi\\
\text{naturality law of }\text{ftn}_{M}:\quad & =\text{sw}_{M,P}^{\uparrow P}\bef\text{ftn}_{M}\bef\big(\gunderline{\psi^{\uparrow P}\bef\psi\bef\text{ftn}_{P^{\prime}}}\big)^{\uparrow M}\bef\phi\\
\text{composition law of }\psi:\quad & =\text{sw}_{M,P}^{\uparrow P}\bef\text{ftn}_{M}\bef(\text{ftn}_{P}\bef\psi)^{\uparrow M}\bef\phi=\text{sw}_{M,P}^{\uparrow P}\bef\text{ftn}_{M}\bef\text{ftn}_{P}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi\quad.
\end{align*}

\end_inset

Both sides are now equal, which concludes the proof of the monad morphism
 laws of 
\begin_inset Formula $\text{frun}_{L}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Functor laws of 
\family typewriter
frun
\end_layout

\begin_layout Standard
To verify the functor laws of 
\begin_inset Formula $\text{frun}_{L}$
\end_inset

, we assume that the functor laws already hold for 
\begin_inset Formula $\text{frun}_{K}$
\end_inset

.
 The identity law of 
\begin_inset Formula $\text{frun}_{L}$
\end_inset

 is:
\begin_inset Formula 
\[
\text{frun}_{L}^{M,M}(\text{id})=\,\begin{array}{|c||cc|}
 & A & T_{K}^{M,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M}(\text{id})
\end{array}^{\uparrow M}\bef\text{id}=\,\begin{array}{|c||cc|}
 & A & T_{K}^{M,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{id}
\end{array}^{\uparrow M}=\text{id}^{\uparrow M}=\text{id}\quad.
\]

\end_inset

To verify the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-of-frun"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for any monad morphisms 
\begin_inset Formula $\phi_{1}:Q\leadsto R$
\end_inset

 and 
\begin_inset Formula $\phi_{2}:R\leadsto S$
\end_inset

, where 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 are some monads, denote temporarily by 
\begin_inset Formula $\psi_{1}$
\end_inset

 and 
\begin_inset Formula $\psi_{2}$
\end_inset

 the following monad morphisms:
\begin_inset Formula 
\begin{align*}
 & \psi_{1}:A+T_{K}^{Q,A}\leadsto A+T_{K}^{R,A}\quad,\quad\quad\psi_{1}\triangleq\,\begin{array}{|c||cc|}
 & A & T_{K}^{R,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{Q,A} & \bbnum 0 & \text{frun}_{K}^{Q,R}(\phi_{1})
\end{array}\quad,\\
 & \psi_{2}:A+T_{K}^{R,A}\leadsto A+T_{K}^{S,A}\quad,\quad\quad\psi_{2}\triangleq\,\begin{array}{|c||cc|}
 & A & T_{K}^{S,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{R,A} & \bbnum 0 & \text{frun}_{K}^{R,S}(\phi_{2})
\end{array}\quad.
\end{align*}

\end_inset

With these notations, we write the left side of the functor composition
 law:
\begin_inset Formula 
\begin{align*}
\text{composition law of }\text{frun}_{L}:\quad & \text{frun}_{L}^{Q,R}(\phi_{1})\bef\text{frun}_{L}^{R,S}(\phi_{2})=\psi_{1}^{\uparrow Q}\bef\gunderline{\phi_{1}\bef\psi_{2}^{\uparrow R}}\bef\phi_{2}\\
\text{naturality of }\phi_{1}:\quad & =\psi_{1}^{\uparrow Q}\bef\psi_{2}^{\uparrow Q}\bef\phi_{1}\bef\phi_{2}=(\psi_{1}\bef\psi_{2})^{\uparrow Q}\bef\phi\bef\phi_{2}\quad.
\end{align*}

\end_inset

Compute the composition 
\begin_inset Formula $\psi_{1}\bef\psi_{2}$
\end_inset

 separately, using the composition law of 
\begin_inset Formula $\text{frun}_{K}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \psi_{1}\bef\psi_{2}=\,\begin{array}{|c||cc|}
 & A & T_{K}^{R,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{Q,A} & \bbnum 0 & \text{frun}_{K}^{Q,R}(\phi_{1})
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & T_{K}^{S,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{R,A} & \bbnum 0 & \text{frun}_{K}^{R,S}(\phi_{2})
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{|c||cc|}
 & A & T_{K}^{S,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{Q,A} & \bbnum 0 & \gunderline{\text{frun}_{K}^{Q,R}(\phi_{1})\bef\text{frun}_{K}^{R,S}\!(\phi_{2})}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & T_{K}^{S,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{Q,A} & \bbnum 0 & \text{frun}_{K}^{Q,S}(\phi_{1}\bef\phi_{2})
\end{array}\quad.
\end{align*}

\end_inset

We can now finish verifying the composition law:
\begin_inset Formula 
\begin{align*}
 & \text{frun}_{L}^{Q,R}(\phi_{1})\bef\text{frun}_{L}^{R,S}(\phi_{2})=(\psi_{1}\bef\psi_{2})^{\uparrow Q}\bef\phi_{1}\bef\phi_{2}\\
 & =\,\begin{array}{|c||cc|}
 & A & T_{K}^{S,A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{Q,A} & \bbnum 0 & \text{frun}_{K}^{Q,S}(\phi_{1}\bef\phi_{2})
\end{array}^{\uparrow Q}\bef\phi_{1}\bef\phi_{2}=\text{frun}_{L}^{Q,S}(\phi_{1}\bef\phi_{2})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The derivation of the base runner laws used the following property:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monad-morphism-composition-theorem"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-morphism-composition-theorem"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 are two monads such that the functor composition 
\begin_inset Formula $M\circ N$
\end_inset

 is a monad defined via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function (
\begin_inset Formula $\text{sw}_{M,N}:N\circ M\leadsto M\circ N$
\end_inset

) according to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (where the two monads are denoted by 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 instead of 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

).
 Let 
\begin_inset Formula $\phi:N\leadsto M$
\end_inset

 be a monad morphism such that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function obeys the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-special-law-monad-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shown below.
 That law can be seen as a weaker version of a monadic naturality law of
 
\begin_inset Formula $\text{sw}_{M,N}$
\end_inset

 with respect to the parameter 
\begin_inset Formula $N$
\end_inset

 (where the monad 
\begin_inset Formula $N$
\end_inset

 is transformed by 
\begin_inset Formula $\phi$
\end_inset

 to the fixed monad 
\begin_inset Formula $M$
\end_inset

 rather than to arbitrary new monad):
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.3pc}\xyScaleX{2.8pc}N^{M^{A}}\ar[r]\sp(0.5){\phi}\ar[d]\sp(0.45){\text{sw}_{M,N}\ } & M^{M^{A}}\ar[rd]\sp(0.5){\ \text{ftn}_{M}}\\
M^{N^{A}}\ar[r]\sp(0.5){\phi^{\uparrow M}} & M^{M^{A}}\ar[r]\sp(0.5){\text{ftn}_{M}} & M^{A}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\phi\bef\text{ftn}_{M}=\text{sw}_{M,N}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\quad.\label{eq:swap-special-law-monad-morphism-composition}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Then the function 
\begin_inset Formula $\phi^{\uparrow M}\bef\text{ftn}_{M}$
\end_inset

 is a monad morphism 
\begin_inset Formula $M\circ N\leadsto M$
\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to check the laws of the monad morphism:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \text{pu}_{M\circ N}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\text{pu}_{M}\quad,\\
\text{composition law}:\quad & \text{ftn}_{M\circ N}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\phi^{\uparrow M}\bef\text{ftn}_{M}\bef(\phi^{\uparrow M}\bef\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{M\circ N}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\text{pu}_{N}\bef\gunderline{\text{pu}_{M}\bef\phi^{\uparrow M}}\bef\text{ftn}_{M}\\
 & =\gunderline{\text{pu}_{N}\bef\phi}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}=\text{pu}_{M}\bef\text{id}=\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law, begin with its left-hand side:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{M\circ N}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\gunderline{\text{ftn}_{N}^{\uparrow M}\bef\phi^{\uparrow M}}\bef\text{ftn}_{M}\\
\text{composition law of }\phi:\quad & =\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\big(\phi\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

In order to use the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:swap-special-law-monad-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to move 
\begin_inset Formula $\phi$
\end_inset

 towards 
\begin_inset Formula $\text{sw}^{\uparrow M}$
\end_inset

 in the composition and to replace 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

 by 
\begin_inset Formula $\text{ftn}_{M}^{\uparrow M}$
\end_inset

.
 To achieve that, we repeatedly use 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

's laws of naturality and associativity:
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\big(\phi}\bef\phi^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}}=\text{sw}^{\uparrow M}\bef\phi^{\uparrow M\uparrow M}\bef\text{ftn}_{M}\bef\gunderline{\phi^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}\\
 & =\big(\text{sw}\bef\phi^{\uparrow M}\big)^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\gunderline{\big(\text{sw}\bef\phi^{\uparrow M}\big)^{\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}}\bef\text{ftn}_{M}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\\
\text{use Eq.~(\ref{eq:swap-special-law-monad-morphism-composition})}:\quad & =\big(\phi\bef\gunderline{\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\phi^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

Now we can rewrite the right-hand side of the law and make it equal to the
 last expression:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & \phi^{\uparrow M}\bef\text{ftn}_{M}\bef(\phi^{\uparrow M}\bef\gunderline{\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}}=\phi^{\uparrow M}\bef\text{ftn}_{M}\bef\gunderline{\phi^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}\\
 & =\phi^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Base runner laws
\end_layout

\begin_layout Standard
Given any base runner 
\begin_inset Formula $\text{brun}_{K}$
\end_inset

 for the monad transformer 
\begin_inset Formula $T_{K}$
\end_inset

, we define the base runner 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 through the special runner 
\begin_inset Formula $\theta_{P}:P^{A}\rightarrow M^{A}$
\end_inset

 that we implement through 
\begin_inset Formula $\text{brun}_{K}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{brun}_{L}:M^{A+T_{K}^{M,A}}\rightarrow M^{A}\quad,\quad\quad\text{brun}_{L}\triangleq\theta_{P}^{\uparrow M}\bef\text{ftn}_{M}\quad,\quad\quad\theta_{P}\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
T_{K}^{M,A} & \text{brun}_{K}
\end{array}\quad.\label{eq:def-of-brun-and-theta-for-free-pointed}
\end{equation}

\end_inset

The runner 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 is not purely compositional since 
\begin_inset Formula $L\triangleq M\circ P$
\end_inset

 contains the monad 
\begin_inset Formula $P$
\end_inset

 that again depends on 
\begin_inset Formula $M$
\end_inset

.
 So, we cannot use the proofs in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-transformer-runner-laws-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and the monad morphism laws and the nondegeneracy law of 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 need to be verified separately.
\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\theta_{P}:P\leadsto M$
\end_inset

 is a monad morphism by Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 is a monad morphism, we will use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-morphism-composition-theorem"
plural "false"
caps "false"
noprefix "false"

\end_inset

 where we use the monad 
\begin_inset Formula $P^{A}\triangleq A+N^{A}$
\end_inset

 instead of 
\begin_inset Formula $L^{A}$
\end_inset

.
 It remains to check the properties required by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-morphism-composition-theorem"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required monad morphism 
\begin_inset Formula $\phi$
\end_inset

 is 
\begin_inset Formula $\theta_{P}:P\leadsto M$
\end_inset

.
 The special law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 has the following form: 
\begin_inset Formula 
\[
\theta_{P}\bef\text{ftn}_{M}\overset{?}{=}\text{sw}\bef\theta_{P}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

Let us verify this law using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-swap-for-free-pointed-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-brun-and-theta-for-free-pointed"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $\theta_{P}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\theta_{P}\bef\text{ftn}_{M}:\quad & \text{sw}\bef\theta_{P}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \gunderline{\text{pu}_{P}^{\uparrow M}\bef\theta_{P}^{\uparrow M}}\bef\text{ftn}_{M}\\
N^{M^{A}} & (t\rightarrow\bbnum 0^{:A}+\text{merge}\,(t))\bef\gunderline{\text{pu}_{M}\bef\theta_{P}^{\uparrow M}}\bef\text{ftn}_{M}
\end{array}\\
\text{identity law of }\theta_{P}:\quad & =\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\\
N^{M^{A}} & (t\rightarrow\bbnum 0^{:A}+\text{merge}\,(t))\bef\theta_{P}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}
\end{array}\\
\text{identity laws of }M:\quad & =\,\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{id}\\
N^{M^{A}} & (t\rightarrow\gunderline{\bbnum 0^{:A}+\text{merge}\,(t))\bef\theta_{P}}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{id}\\
N^{M^{A}} & \text{merge}\bef\text{brun}_{K}
\end{array}\quad.
\end{align*}

\end_inset

Write out 
\begin_inset Formula $\theta_{P}\bef\text{ftn}_{M}$
\end_inset

 in matrix form:
\begin_inset Formula 
\begin{align*}
 & \theta_{P}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{pu}_{M}\bef\text{ftn}_{M}\\
N^{M^{A}} & \text{brun}_{K}\bef\text{ftn}_{M}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{id}\\
N^{M^{A}} & \text{brun}_{K}\bef\text{ftn}_{M}
\end{array}\quad.
\end{align*}

\end_inset

The remaining difference is between the following functions of type 
\begin_inset Formula $N^{M^{A}}\rightarrow M^{A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{merge}\bef\text{brun}_{K}\overset{?}{=}\text{brun}_{K}\bef\text{ftn}_{M}\quad,\\
\text{or, using the definition of }\text{merge}:\quad & \text{flift}_{K}^{\uparrow N}\bef\text{ftn}_{N}\bef\text{brun}_{K}\overset{?}{=}\text{brun}_{K}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

The monad morphism laws of 
\begin_inset Formula $\text{brun}_{K}$
\end_inset

 allow us to prove this equation:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{brun}_{K}\bef\text{ftn}_{M}:\quad & \text{flift}_{K}^{\uparrow N}\bef\gunderline{\text{ftn}_{N}\bef\text{brun}_{K}}=\gunderline{\text{flift}_{K}^{\uparrow N}\bef\text{brun}_{K}^{\uparrow N}}\bef\text{brun}_{K}\bef\text{ftn}_{M}\\
\text{non-degeneracy law of }\text{brun}_{K}:\quad & =\text{brun}_{K}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

This concludes the proof of monad morphism laws of 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the nondegeneracy law, which is an equation between functions
 of type 
\begin_inset Formula $M^{A}\rightarrow M^{A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{flift}_{L}\bef\text{brun}_{L}=\text{pu}_{P}^{\uparrow M}\bef\text{brun}_{L}=\gunderline{\text{pu}_{P}^{\uparrow M}\bef\theta_{P}^{\uparrow M}}\bef\text{ftn}_{M}=\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
The monadic naturality law of 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

 is written as:
\begin_inset Formula 
\begin{align*}
 & \text{flift}_{L}\bef\text{frun}_{L}(\phi)\overset{?}{=}\phi\bef\text{flift}_{L}\quad,\\
\text{or, using definitions of }\text{flift}_{L}\text{ and }\text{frun}_{L}:\quad & \text{pu}_{P}^{\uparrow M}\bef\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}^{\uparrow M}\bef\phi\overset{?}{=}\phi\bef\text{pu}_{P}^{\uparrow M^{\prime}}\quad.
\end{align*}

\end_inset

This should hold for any monad morphism 
\begin_inset Formula $\phi^{:M\leadsto M^{\prime}}$
\end_inset

.
 Simplify the expression under 
\begin_inset Formula $^{\uparrow M}$
\end_inset

 separately:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{P}\bef\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\,=(a\rightarrow a+\bbnum 0^{:T_{K}^{M,A}})\bef\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\,=a\rightarrow a+\bbnum 0\quad.
\end{align*}

\end_inset

So, we can transform the left-hand side of the law and obtain the right-hand
 side:
\begin_inset Formula 
\begin{align*}
 & \text{flift}_{L}\bef\text{frun}_{L}(\phi)=(a\rightarrow a+\bbnum 0)^{\uparrow M}\bef\phi=\gunderline{\text{pu}_{P}^{\uparrow M}\bef\phi}=\phi\bef\text{pu}_{P}^{\uparrow M^{\prime}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The monadic naturality law of 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 is:
\begin_inset Formula 
\[
\text{brun}_{L}\bef\phi\overset{?}{=}\text{frun}_{L}(\phi)\bef\text{brun}_{L}\quad.
\]

\end_inset

Rewrite the right-hand side using the definitions of 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 and 
\begin_inset Formula $\text{frun}_{L}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{brun}_{L}\bef\phi:\quad & \text{frun}_{L}(\phi)\bef\text{brun}_{L}=\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}^{\uparrow M}\bef\gunderline{\phi\bef\theta_{P^{\prime}}^{\uparrow M^{\prime}}}\bef\text{ftn}_{M^{\prime}}\\
\text{naturality law of }\phi:\quad & =\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}^{\uparrow M}\bef\theta_{P^{\prime}}^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}\quad.
\end{align*}

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Rewrite
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 the expression under 
\begin_inset Formula $^{\uparrow M}$
\end_inset

 separately:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\,\bef\theta_{P^{\prime}}=\,\begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{\prime A}\\
\hline A & \text{pu}_{M^{\prime}}\\
T_{K}^{M^{\prime},A} & \text{brun}_{K}
\end{array}\,\\
 & =\,\begin{array}{|c||c|}
 & M^{\prime A}\\
\hline A & \text{pu}_{M^{\prime}}\\
T_{K}^{M,A} & \gunderline{\text{frun}_{K}^{M,M^{\prime}}\!(\phi)\bef\text{brun}_{K}}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{\prime A}\\
\hline A & \gunderline{\text{pu}_{M^{\prime}}}\\
T_{K}^{M,A} & \text{brun}_{K}\bef\phi
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & M^{\prime A}\\
\hline A & \text{pu}_{M}\bef\phi\\
T_{K}^{M,A} & \text{brun}_{K}\bef\phi
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
T_{K}^{M,A} & \text{brun}_{K}
\end{array}\bef\phi=\theta_{P}\bef\phi\quad.
\end{align*}

\end_inset

Here we assumed that 
\begin_inset Formula $\text{brun}_{K}$
\end_inset

 obeys its monadic naturality law.
 So, we can now write:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{|c||cc|}
 & A & T_{K}^{M^{\prime},A}\\
\hline A & \text{id} & \bbnum 0\\
T_{K}^{M,A} & \bbnum 0 & \text{frun}_{K}^{M,M^{\prime}}\!(\phi)
\end{array}^{\uparrow M}\bef\theta_{P^{\prime}}^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}=\theta_{P}^{\uparrow M}\bef\gunderline{\phi^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}}\\
\text{composition law of }\phi:\quad & =\gunderline{\theta_{P}^{\uparrow M}\bef\text{ftn}_{M}}\bef\phi=\text{brun}_{L}\bef\phi\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This derivation concludes the proof of the laws of the free pointed monad
 transformer.
\end_layout

\begin_layout Section
Transformers for recursive monads
\end_layout

\begin_layout Subsection
Transformer for free monads.
 Proofs
\end_layout

\begin_layout Standard
The free monad (denoted by 
\begin_inset Formula $\text{Free}^{F,\bullet}$
\end_inset

) on a given functor 
\begin_inset Formula $F$
\end_inset

 is the following recursive type constructor:
\begin_inset Formula 
\[
\text{Free}^{F,A}\triangleq A+F^{\text{Free}^{F,A}}\quad.
\]

\end_inset

Its monad transformer (denoted by 
\begin_inset Formula $T_{\text{Free}}^{M,\bullet}$
\end_inset

) is also defined recursively:
\begin_inset Formula 
\[
T_{\text{Free}}^{M,A}\triangleq M^{A+F^{T_{\text{Free}}^{M,A}}}\quad.
\]

\end_inset

For brevity, we omit the superscript 
\begin_inset Formula $F$
\end_inset

 in 
\begin_inset Formula $\text{Free}^{F}$
\end_inset

, since the functor 
\begin_inset Formula $F$
\end_inset

 will be fixed throughout the derivations.
 When the foreign monad 
\begin_inset Formula $M$
\end_inset

 is also fixed, we will denote 
\begin_inset Formula $T_{\text{Free}}^{M,A}$
\end_inset

 simply by 
\begin_inset Formula $T^{A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-free-monad-transformer"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-free-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $T_{\text{Free}}$
\end_inset

 is a lawful monad transformer.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to define the methods required of a monad transformer and verify
 all the laws.
 
\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
The recursively defined type of 
\begin_inset Formula $T_{\text{Free}}^{M,A}$
\end_inset

 contains infinitely many nested layers of the monad 
\begin_inset Formula $M$
\end_inset

 composed with the functor 
\begin_inset Formula $F$
\end_inset

.
 We use the 
\begin_inset Quotes eld
\end_inset

unrolling trick
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
unrolling trick for recursive types
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive types!unrolling trick
\end_layout

\end_inset

 to express 
\begin_inset Formula $T_{\text{Free}}$
\end_inset

 through simpler types.
 Write 
\begin_inset Formula $T_{\text{Free}}$
\end_inset

 as an 
\begin_inset Quotes eld
\end_inset

infinite
\begin_inset Quotes erd
\end_inset

 type expression:
\begin_inset Formula 
\[
T_{\text{Free}}^{M}=M\circ\left(\text{Id}+F\circ M\circ\left(\text{Id}+F\circ M\circ(\text{Id}+...)\right)\right)\quad.
\]

\end_inset

If we denote by 
\begin_inset Formula $L$
\end_inset

 the type constructor defined recursively by:
\begin_inset Formula 
\[
L^{A}\triangleq A+F^{M^{L^{A}}}=A+F^{M^{A+F^{M^{A+...}}}}\quad,
\]

\end_inset

or equivalently by 
\begin_inset Formula $L^{A}\triangleq\text{Free}^{F\circ M,A}$
\end_inset

, we may express 
\begin_inset Formula $T_{\text{Free}}^{M,A}$
\end_inset

 as:
\begin_inset Formula 
\[
T_{\text{Free}}^{M,A}=M^{L^{A}}\quad,\quad\quad T_{\text{Free}}^{M}=M\circ L=M\circ\text{Free}^{F\circ M}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{Free}^{P}$
\end_inset

 is a monad for any functor 
\begin_inset Formula $P$
\end_inset

, in particular for the functor 
\begin_inset Formula $P\triangleq F\circ M$
\end_inset

, it follows that 
\begin_inset Formula $L$
\end_inset

 is a monad.
 It remains to show that the composition 
\begin_inset Formula $M\circ L$
\end_inset

 is also a monad.
 This resembles the situation with the composed-inside monad transformers
 having a base monad 
\begin_inset Formula $L$
\end_inset

 and a foreign monad 
\begin_inset Formula $M$
\end_inset

.
 A significant difference is that the monad 
\begin_inset Formula $L$
\end_inset

 also depends on the foreign monad 
\begin_inset Formula $M$
\end_inset

.
 That difference will play a role in proofs of laws that involve changing
 the foreign monad.
 But in this part of the proof, the foreign monad 
\begin_inset Formula $M$
\end_inset

 is fixed throughout the derivation.
 
\end_layout

\begin_layout Standard
Similarly to the case of composed-inside transformers, we define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function:
\begin_inset Formula 
\begin{equation}
\text{sw}:L^{M^{A}}\rightarrow M^{L^{A}}\quad,\quad\quad\text{sw}\triangleq\,\begin{array}{|c||c|}
 & M^{A+\left(F\circ M\circ L\right)^{A}}\\
\hline M^{A} & (a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}})^{\uparrow M}\\
\left(F\circ M\circ L\circ M\right)^{A} & \overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}
\end{array}\quad.\label{eq:definition-of-swap-for-free-monad-transformer}
\end{equation}

\end_inset

The upper row of the matrix contains the function 
\begin_inset Formula $a\rightarrow a+\bbnum 0$
\end_inset

, which is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method of the monad 
\begin_inset Formula $L$
\end_inset

 (denoted by 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

).
 The lower row of the matrix contains a composition of four functions, the
 first of which being 
\begin_inset Formula $\overline{\text{sw}}$
\end_inset

, the recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 To illustrate the types involved in the composition:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{0.2pc}\xyScaleX{4.0pc}F^{M^{L^{M^{A}}}}\ar[r]\sp(0.5){\overline{\text{sw}}^{\uparrow M\uparrow F}} & F^{M^{M^{L^{A}}}}\ar[r]\sp(0.5){\text{ftn}_{M}^{\uparrow F}} & F^{M^{L^{A}}}\ar[r]\sp(0.5){p\rightarrow\bbnum 0^{:A}+p} & A+F^{M^{L^{A}}}\ar[r]\sp(0.5){\text{pu}_{M}} & M^{A+F^{M^{L^{A}}}}}
\]

\end_inset

 The required methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 of the monad 
\begin_inset Formula $T\triangleq M\circ L$
\end_inset

 are defined by:
\begin_inset Formula 
\[
\text{pu}_{T}\triangleq\text{pu}_{L}\bef\text{pu}_{M}\quad,\quad\quad\text{ftn}_{T}\triangleq\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{L}^{\uparrow M}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To prove that the composition 
\begin_inset Formula $T\triangleq M\circ L$
\end_inset

 is a lawful monad, we use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 exchanged.
 That statement requires 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 to satisfy its four laws:
\begin_inset Formula 
\begin{align*}
\text{outer identity}:\quad & \text{pu}_{M}^{\uparrow L}\bef\text{sw}=\text{pu}_{M}\quad,\\
\text{inner identity}:\quad & \text{pu}_{L}\bef\text{sw}=\text{pu}_{L}^{\uparrow M}\quad,\\
\text{outer interchange}:\quad & \text{ftn}_{M}^{\uparrow L}\bef\text{sw}=\text{sw}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\quad,\\
\text{inner interchange}:\quad & \text{ftn}_{L}\bef\text{sw}=\text{sw}^{\uparrow L}\bef\text{sw}\bef\text{ftn}_{L}^{\uparrow M}\quad.
\end{align*}

\end_inset

To verify these laws, we need the code for the lifting (
\begin_inset Formula $^{\uparrow L}$
\end_inset

) as well as for the methods 
\begin_inset Formula $\text{pu}_{L}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

.
 Since 
\begin_inset Formula $L$
\end_inset

 is a free monad on the functor 
\begin_inset Formula $F\circ M$
\end_inset

, we can adapt the code from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-construction-4-free-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f^{:A\rightarrow B})^{\uparrow L}=\,\begin{array}{|c||cc|}
 & B & F^{M^{L^{B}}}\\
\hline A & f & \bbnum 0\\
F^{M^{L^{A}}} & \bbnum 0 & \big(f^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\quad,\\
\text{pu}_{L}\triangleq\,\begin{array}{|c||cc|}
 & A & F^{M^{L^{A}}}\\
\hline A & \text{id} & \bbnum 0
\end{array}\quad, & \quad\quad\text{ftn}_{L}^{:L^{L^{A}}\rightarrow L^{A}}\triangleq\,\begin{array}{|c||cc|}
 & A & F^{M^{L^{A}}}\\
\hline A & \text{id} & \bbnum 0\\
F^{M^{L^{A}}} & \bbnum 0 & \text{id}\\
F^{M^{L^{L^{A}}}} & \bbnum 0 & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In the calculations, we will omit type annotations for brevity.
 To verify the outer identity law:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}^{\uparrow L}\bef\text{sw}=\,\begin{array}{||cc|}
\text{pu}_{M} & \bbnum 0\\
\bbnum 0 & \big(\text{pu}_{M}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\,\bef\,\begin{array}{||c|}
\big(a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}}\big)^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}
\end{array}\\
 & =\,\begin{array}{||c|}
\gunderline{\text{pu}_{M}}\bef\big(a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}}\big)^{\gunderline{\uparrow M}}\\
\gunderline{\big(\text{pu}_{M}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\text{sw}}^{\uparrow M\uparrow F}}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}
\end{array}\,=\,\begin{array}{||c|}
\big(a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}}\big)\bef\gunderline{\text{pu}_{M}}\\
\big(\gunderline{\text{pu}_{M}^{\overline{\uparrow L}}\bef\overline{\text{sw}}}\big)^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\gunderline{\text{pu}_{M}}
\end{array}\\
 & =\,\,\begin{array}{||c|}
a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}}\\
\big(\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\big)^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)
\end{array}\,\bef\text{pu}_{M}=\,\begin{array}{|c||c|}
 & A+F^{M^{L^{A}}}\\
\hline A & a\rightarrow a+\bbnum 0\\
F^{M^{L^{A}}} & p\rightarrow\bbnum 0^{:A}+p
\end{array}\,\bef\text{pu}_{M}=\text{id}\bef\text{pu}_{M}=\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the inner identity law:
\begin_inset Formula 
\[
\text{pu}_{L}\bef\text{sw}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\end{array}\,\bef\,\begin{array}{||c|}
\big(a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}}\big)^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}
\end{array}\,=\big(a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}}\big)^{\uparrow M}=\text{pu}_{L}^{\uparrow M}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the outer interchange law, write the two sides of the law separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{M}^{\uparrow L}\bef\text{sw}=\,\begin{array}{||cc|}
\text{ftn}_{M} & \bbnum 0\\
\bbnum 0 & \big(\text{ftn}_{M}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\,\bef\,\begin{array}{||c|}
\big(a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}}\big)^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}
\end{array}\\
 & \quad=\,\begin{array}{||c|}
\text{ftn}_{M}\bef\text{pu}_{L}^{\uparrow M}\\
\big(\text{ftn}_{M}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}
\end{array}\quad,\\
\text{right-hand side}:\quad & \text{sw}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{||c|}
\gunderline{\text{pu}_{L}^{\uparrow M}\bef\text{sw}^{\uparrow M}}\bef\text{ftn}_{M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\gunderline{\text{pu}_{M}\bef\text{sw}^{\uparrow M}}\bef\text{ftn}_{M}
\end{array}\\
 & \quad=\,\begin{array}{||c|}
\gunderline{\text{pu}_{L}^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{sw}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}
\end{array}\\
 & \quad=\,\,\begin{array}{||c|}
\text{ftn}_{M}\bef\text{pu}_{L}^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{sw}
\end{array}\quad.
\end{align*}

\end_inset

The remaining difference is in the second rows of the matrices:
\begin_inset Formula 
\begin{equation}
\big(\text{ftn}_{M}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}\overset{?}{=}\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{sw}\quad.\label{eq:outer-interchange-free-monad-derivation1}
\end{equation}

\end_inset

Let us rewrite both sides of this expression step by step.
 By the inductive assumption, we may use the outer interchange law for the
 recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{M}^{\overline{\uparrow L}}\bef\overline{\text{sw}}=\text{sw}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

We can then rewrite the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:outer-interchange-free-monad-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\big(\text{sw}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}\\
\text{composition under }^{\uparrow F}:\quad & =\big(\text{sw}^{\uparrow M}\bef\text{sw}^{\uparrow M\uparrow M}\bef\gunderline{\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\big)^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}\\
\text{associativity law of }\text{ftn}_{M}:\quad & =\big(\text{sw}^{\uparrow M}\bef\gunderline{\text{sw}^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}\\
\text{naturality law of }\text{ftn}_{M}:\quad & =\big(\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

We can also compute the expression 
\begin_inset Formula $(p\rightarrow\bbnum 0^{:A}+p)\bef\text{sw}$
\end_inset

 in the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:outer-interchange-free-monad-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & (p\rightarrow\bbnum 0+p)\bef\text{sw}=\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\end{array}\,\bef\,\begin{array}{||c|}
\text{pu}_{L}^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}
\end{array}\\
 & =(\overline{\text{sw}}^{\uparrow M}\bef\text{ftn}_{M})^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

Then Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:outer-interchange-free-monad-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) becomes:
\begin_inset Formula 
\begin{align*}
 & \big(\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\\
 & \overset{?}{=}\gunderline{\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}}\bef(\overline{\text{sw}}^{\uparrow M}\bef\text{ftn}_{M})^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\\
 & =\big(\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Standard
To verify the inner interchange law, write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{L}\bef\text{sw}=\,\begin{array}{|c||cc|}
 & M^{A} & F^{M^{L^{M^{A}}}}\\
\hline M^{A} & \text{id} & \bbnum 0\\
F^{M^{L^{M^{A}}}} & \bbnum 0 & \text{id}\\
F^{M^{L^{L^{M^{A}}}}} & \bbnum 0 & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}
\end{array}\,\bef\,\begin{array}{||c|}
\text{pu}_{L}^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}
\end{array}\\
 & \quad=\,\begin{array}{|c||c|}
 & M^{A+(F\circ M\circ L\circ M)^{A}}\\
\hline M^{A} & \text{pu}_{L}^{\uparrow M}\\
F^{M^{L^{M^{A}}}} & \overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\\
F^{M^{L^{L^{M^{A}}}}} & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}\bef\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}
\end{array}\quad,\\
\text{right-hand side}:\quad & \text{sw}^{\uparrow L}\bef\text{sw}\bef\text{ftn}_{L}^{\uparrow M}=\,\begin{array}{|c||cc|}
 & M^{L^{A}} & F^{M^{L^{M^{L^{A}}}}}\\
\hline L^{M^{A}} & \text{sw} & \bbnum 0\\
F^{M^{L^{L^{M^{A}}}}} & \bbnum 0 & \big(\text{sw}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\,\bef\text{sw}\bef\text{ftn}_{L}^{\uparrow M}\quad.
\end{align*}

\end_inset

In order to compare the resulting matrices, we need to expand the first
 row of the last matrix, so that the disjunctive type 
\begin_inset Formula $L^{M^{A}}$
\end_inset

 is represented as 
\begin_inset Formula $M^{A}+(F\circ M\circ L)^{M^{A}}$
\end_inset

.
 We can then fill in the matrix elements of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{sw}^{\uparrow L} & =\,\begin{array}{|c||cc|}
 & M^{L^{A}} & F^{M^{L^{M^{L^{A}}}}}\\
\hline L^{M^{A}} & \text{sw} & \bbnum 0\\
F^{M^{L^{L^{M^{A}}}}} & \bbnum 0 & \big(\text{sw}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\\
 & =\,\,\begin{array}{|c||cc|}
 & M^{L^{A}} & F^{M^{L^{M^{L^{A}}}}}\\
\hline M^{A} & \text{pu}_{L}^{\uparrow M} & \bbnum 0\\
F^{M^{L^{M^{A}}}} & \overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M} & \bbnum 0\\
F^{M^{L^{L^{M^{A}}}}} & \bbnum 0 & \big(\text{sw}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset

With this matrix, we continue rewriting the right-hand side of the inner
 interchange law:
\begin_inset Formula 
\begin{align*}
 & \text{sw}^{\uparrow L}\bef\text{sw}\bef\text{ftn}_{L}^{\uparrow M}\\
 & =\,\begin{array}{||cc|}
\text{pu}_{L}^{\uparrow M} & \bbnum 0\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M} & \bbnum 0\\
\bbnum 0 & \big(\text{sw}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\,\bef\,\begin{array}{||c|}
\text{pu}_{L}^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}
\end{array}\,\bef\text{ftn}_{L}^{\uparrow M}\\
 & =\,\,\begin{array}{||c|}
\text{pu}_{L}^{\uparrow M}\bef\gunderline{\text{pu}_{L}^{\uparrow M}\bef\text{ftn}_{L}^{\uparrow M}}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\bef\gunderline{\text{pu}_{L}^{\uparrow M}\bef\text{ftn}_{L}^{\uparrow M}}\\
\gunderline{\big(\text{sw}^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\text{sw}}^{\uparrow M\uparrow F}}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{L}^{\uparrow M}}
\end{array}\\
 & =\,\begin{array}{||c|}
\text{pu}_{L}^{\uparrow M}\\
\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\\
\big(\text{sw}^{\overline{\uparrow L}}\bef\overline{\text{sw}}\big)^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{ftn}_{L}\bef\text{pu}_{M}
\end{array}\quad.
\end{align*}

\end_inset

The remaining difference between the two sides of the law is only in the
 last rows of the matrices:
\begin_inset Formula 
\[
\overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}\bef\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\overset{?}{=}\big(\text{sw}^{\overline{\uparrow L}}\bef\overline{\text{sw}}\big)^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{ftn}_{L}\bef\text{pu}_{M}\quad.
\]

\end_inset

By the inductive assumption, the law already holds for the recursive call
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\overline{\text{ftn}}_{L}\bef\overline{\text{sw}}=\text{sw}^{\uparrow L}\bef\text{sw}\bef\text{ftn}_{L}^{\uparrow M}\quad.
\]

\end_inset

This gives the following code for the left-hand side:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}\bef\overline{\text{sw}}^{\uparrow M\uparrow F}}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\\
\text{inductive assumption}:\quad & =(\text{sw}^{\uparrow L}\bef\text{sw}\bef\gunderline{\text{ftn}_{L}^{\uparrow M})^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\\
\text{naturality of }\text{ftn}_{M}:\quad & =(\text{sw}^{\uparrow L}\bef\text{sw})^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{L}^{\uparrow M\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

The remaining difference between the two sides is:
\begin_inset Formula 
\begin{align*}
 & (\text{sw}^{\uparrow L}\bef\text{sw})^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{L}^{\uparrow M\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{pu}_{M}\\
 & \overset{?}{=}\big(\text{sw}^{\overline{\uparrow L}}\bef\overline{\text{sw}}\big)^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\text{ftn}_{L}\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

Both sides are functions of type 
\begin_inset Formula $(F\circ M\circ L\circ L\circ M)^{A}\rightarrow M^{L^{A}}$
\end_inset

.
 We will prove the equality above if we show that the following two functions
 of type 
\begin_inset Formula $(F\circ M\circ L\circ L)^{A}\rightarrow L^{A}$
\end_inset

 are equal:
\begin_inset Formula 
\[
(p\rightarrow\bbnum 0+p)\bef\text{ftn}_{L}\overset{?}{=}\text{ftn}_{L}^{\uparrow M\uparrow F}\bef(p\rightarrow\bbnum 0+p)\quad.
\]

\end_inset

We compute the left-hand side and show that it equals the right-hand side:
\begin_inset Formula 
\begin{align*}
 & (p\rightarrow\bbnum 0^{:L^{A}}+p)\bef\text{ftn}_{L}=\,\begin{array}{|c||cc|}
 & L^{A} & (F\circ M\circ L\circ L)^{A}\\
\hline (F\circ M\circ L\circ L)^{A} & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & F^{M^{L^{A}}}\\
\hline A & \text{id} & \bbnum 0\\
F^{M^{L^{A}}} & \bbnum 0 & \text{id}\\
F^{M^{L^{L^{A}}}} & \bbnum 0 & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}
\end{array}\\
 & =\,\begin{array}{|c||ccc|}
 & A & F^{M^{L^{A}}} & (F\circ M\circ L\circ L)^{A}\\
\hline (F\circ M\circ L\circ L)^{A} & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & F^{M^{L^{A}}}\\
\hline A & \text{id} & \bbnum 0\\
F^{M^{L^{A}}} & \bbnum 0 & \text{id}\\
F^{M^{L^{L^{A}}}} & \bbnum 0 & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}
\end{array}\\
 & =\,\,\begin{array}{|c||cc|}
 & A & (F\circ M\circ L)^{A}\\
\hline (F\circ M\circ L\circ L)^{A} & \bbnum 0 & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}
\end{array}\,=\overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}\bef(p^{:(F\circ M\circ L)^{A}}\rightarrow\bbnum 0^{:A}+p)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This concludes the proof of the four laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 It follows that 
\begin_inset Formula $M\circ L$
\end_inset

 is a lawful monad.
\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
Setting 
\begin_inset Formula $M=\text{Id}$
\end_inset

 in the type of 
\begin_inset Formula $T_{\text{Free}}^{M,A}$
\end_inset

, we get the isomorphism 
\begin_inset Formula $\text{Id}\circ\text{Free}^{F\circ\text{Id}}\cong\text{Free}^{F}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Lifting laws
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 for 
\begin_inset Formula $T_{\text{Free}}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
\text{flift}:M^{A}\rightarrow M^{L^{A}}\quad,\quad\quad\text{flift}\triangleq\text{pu}_{L}^{\uparrow M}=(a^{:A}\rightarrow a+\bbnum 0^{:(F\circ M\circ L)^{A}})^{\uparrow M}\quad.
\]

\end_inset

To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is a monad morphism, we refer to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-transformer-lifting-laws-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we need to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and exchange the monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Paragraph
Implementation of runners
\end_layout

\begin_layout Standard
Since the transformer 
\begin_inset Formula $T_{\text{Free}}=M\circ L$
\end_inset

 is not purely compositional (the monad 
\begin_inset Formula $L$
\end_inset

 itself depends on 
\begin_inset Formula $M$
\end_inset

), mapping the monad 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $M^{\prime}$
\end_inset

 via a monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

 requires us also to map 
\begin_inset Formula $L$
\end_inset

 to 
\begin_inset Formula $L^{\prime}\triangleq\text{Free}^{F\circ M^{\prime}}$
\end_inset

.
 Denote that map temporarily by 
\begin_inset Formula $\psi$
\end_inset

; it is a function of 
\begin_inset Formula $\phi$
\end_inset

, but we will write simply 
\begin_inset Formula $\psi$
\end_inset

 rather than 
\begin_inset Formula $\psi(\phi)$
\end_inset

 for brevity, since 
\begin_inset Formula $\phi$
\end_inset

 is fixed throughout the derivation.
 We can implement 
\begin_inset Formula $\psi:L^{A}\rightarrow L^{\prime A}$
\end_inset

 by the following code matrix:
\begin_inset Formula 
\begin{equation}
\psi:\text{Free}^{F\circ M,A}\rightarrow\text{Free}^{F\circ M^{\prime},A}\quad,\quad\quad\psi\triangleq\,\begin{array}{|c||cc|}
 & A & (F\circ M^{\prime}\circ L^{\prime})^{A}\\
\hline A & \text{id} & \bbnum 0\\
(F\circ M\circ L)^{A} & \bbnum 0 & \overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}
\end{array}\quad.\label{eq:free-monad-definition-of-psi}
\end{equation}

\end_inset

Since 
\begin_inset Formula $\phi$
\end_inset

 is a natural transformation, Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a) indicates that the map 
\begin_inset Formula $\phi^{\uparrow F}:F^{M^{A}}\leadsto F^{M^{\prime A}}$
\end_inset

 is also a natural transformation, and then Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-free-monad-monadic-naturality"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\psi:\text{Free}^{F\circ M}\leadsto\text{Free}^{F\circ M^{\prime}}$
\end_inset

 is a monad morphism.
 The foreign runner 
\begin_inset Formula $\text{frun}^{M,M^{\prime}}(\phi):T_{\text{Free}}\leadsto T_{\text{Free}}^{\prime}$
\end_inset

 is then implemented by:
\begin_inset Formula 
\[
\text{frun}^{M,M^{\prime}}\!:\left(M\leadsto M^{\prime}\right)\rightarrow M^{L^{A}}\rightarrow M^{\prime L^{\prime A}}\!\quad,\quad\text{frun}^{M,M^{\prime}}\!(\phi^{:M\leadsto M^{\prime}})\triangleq\psi^{\uparrow M}\bef\phi\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To implement the base runner, we use the similarity between the two disjunctive
 types:
\begin_inset Formula 
\[
L^{A}\triangleq\text{Free}^{F\circ M,A}=A+F^{M^{\text{Free}^{F\circ M,A}}}=A+(F\circ M\circ L)^{A}\quad\text{ and }\quad\text{Free}^{F,M^{A}}=M^{A}+F^{\text{Free}^{F,M^{A}}}\quad.
\]

\end_inset

The code for the base runner is:
\begin_inset Formula 
\begin{align*}
 & \text{brun}:(\text{Free}^{F}\leadsto\text{Id})\rightarrow M^{L^{A}}\rightarrow M^{A}\quad,\\
 & \text{brun}\,(\theta^{:\text{Free}^{F}\leadsto\text{Id}})\triangleq\,\begin{array}{|c||cc|}
 & M^{A} & F^{\text{Free}^{F,M^{A}}}\\
\hline A & \text{pu}_{M} & \bbnum 0\\
(F\circ M\circ L)^{A} & \bbnum 0 & (\overline{\text{brun}}\,(\theta)\bef(x^{:M^{A}}\rightarrow x+\bbnum 0^{:F^{\text{Free}^{F,M^{A}}}}))^{\uparrow F}
\end{array}^{\uparrow M}\bef\theta^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Monadic naturality of 
\family typewriter
swap
\end_layout

\begin_layout Standard
When the monad 
\begin_inset Formula $M$
\end_inset

 is replaced by another monad 
\begin_inset Formula $M^{\prime}$
\end_inset

 via a monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function with type signature 
\begin_inset Formula $\text{sw}_{M,L}:L\circ M\leadsto M\circ L$
\end_inset

 is replaced by the corresponding function 
\begin_inset Formula $\text{sw}_{M^{\prime},L^{\prime}}:L^{\prime}\circ M^{\prime}\leadsto M^{\prime}\circ L^{\prime}$
\end_inset

.
 The function 
\begin_inset Formula $\text{sw}_{M^{\prime},L^{\prime}}$
\end_inset

 has the same code as 
\begin_inset Formula $\text{sw}_{M,L}$
\end_inset

 except for using the monad parameter 
\begin_inset Formula $M^{\prime}$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

.
 This monadic naturality property is expressed by the law analogous to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-free-pointed-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{equation}
\text{sw}_{M,L}\bef\psi^{\uparrow M}\bef\phi=\phi^{\uparrow L}\bef\psi\bef\text{sw}_{M^{\prime},L^{\prime}}\quad.\label{eq:monadic-naturality-swap-free-monad}
\end{equation}

\end_inset

To verify this law, compute both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-swap-free-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) separately.
 Both sides are functions of type 
\begin_inset Formula $L^{M^{A}}\rightarrow M^{\prime L^{\prime A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{sw}_{M,L}\bef\psi^{\uparrow M}\bef\phi=\,\begin{array}{|c||c|}
 & M^{\prime A+\left(F\circ M^{\prime}\circ L^{\prime}\right)^{A}}\\
\hline M^{A} & \gunderline{\text{pu}_{L}^{\uparrow M}\bef\psi^{\uparrow M}}\bef\phi\\
F^{M^{L^{M^{A}}}} & \overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\gunderline{\text{pu}_{M}\bef\psi^{\uparrow M}}\bef\phi
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & M^{\prime A+\left(F\circ M^{\prime}\circ L^{\prime}\right)^{A}}\\
\hline M^{A} & \text{pu}_{L^{\prime}}^{\uparrow M}\bef\phi\\
F^{M^{L^{M^{A}}}} & \overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\psi\bef\text{pu}_{M}\bef\phi
\end{array}\quad,\\
\text{right-hand side}:\quad & \phi^{\uparrow L}\bef\psi\bef\text{sw}_{M^{\prime},L^{\prime}}\\
 & =\,\begin{array}{|c||cc|}
 & M^{\prime A} & F^{M^{L^{M^{\prime A}}}}\\
\hline M^{A} & \phi & \bbnum 0\\
F^{M^{L^{M^{A}}}} & \bbnum 0 & \big(\phi^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & M^{\prime A} & F^{M^{\prime L^{\prime M^{\prime A}}}}\\
\hline M^{\prime A} & \text{id} & \bbnum 0\\
F^{M^{L^{M^{\prime A}}}} & \bbnum 0 & \overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}
\end{array}\,\bef\text{sw}_{M^{\prime},L^{\prime}}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
 & =\,\begin{array}{|c||cc|}
 & M^{\prime A} & F^{M^{\prime L^{\prime M^{\prime A}}}}\\
\hline M^{A} & \phi & \bbnum 0\\
F^{M^{L^{M^{A}}}} & \bbnum 0 & \big(\phi^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{\prime A+\left(F\circ M^{\prime}\circ L^{\prime}\right)^{A}}\\
\hline M^{\prime A} & \text{pu}_{L^{\prime}}^{\uparrow M^{\prime}}\\
F^{M^{\prime L^{\prime M^{\prime A}}}} & \overline{\text{sw}}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M^{\prime}}
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & M^{\prime A+\left(F\circ M^{\prime}\circ L^{\prime}\right)^{A}}\\
\hline M^{A} & \phi\bef\text{pu}_{L^{\prime}}^{\uparrow M^{\prime}}\\
F^{M^{L^{M^{A}}}} & \big(\phi^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\bef\overline{\text{sw}}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M^{\prime}}
\end{array}\quad.
\end{align*}

\end_inset

The first rows of the two matrices are equal due to naturality of 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula 
\[
\text{pu}_{L^{\prime}}^{\uparrow M}\bef\phi=\phi\bef\text{pu}_{L^{\prime}}^{\uparrow M^{\prime}}\quad.
\]

\end_inset

The remaining difference is in the second rows:
\begin_inset Formula 
\begin{align}
 & \overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\psi\bef\text{pu}_{M}\bef\phi\nonumber \\
 & \overset{?}{=}\big(\phi^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\bef\overline{\text{sw}}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\text{pu}_{M^{\prime}}\quad.\label{eq:monadic-naturality-swap-free-monad-derivation1}
\end{align}

\end_inset

Transform the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-swap-free-monad-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)\bef\psi\bef\gunderline{\text{pu}_{M}\bef\phi}\\
 & =\overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}
\end{array}\,\bef\text{pu}_{M^{\prime}}\\
 & =\overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\,\gunderline{\begin{array}{||cc|}
\bbnum 0 & \overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\end{array}}\,\bef\text{pu}_{M^{\prime}}\\
 & =\overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\gunderline{\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\bef(p\rightarrow\bbnum 0+p)}\bef\text{pu}_{M^{\prime}}\quad.
\end{align*}

\end_inset

The remaining difference in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-swap-free-monad-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is:
\begin_inset Formula 
\[
\overline{\text{sw}}_{M,L}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\overset{?}{=}\big(\phi^{\overline{\uparrow L}}\big)^{\uparrow M\uparrow F}\bef\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\bef\overline{\text{sw}}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\quad,
\]

\end_inset

which we can simplify by omitting the common lifting 
\begin_inset Formula $^{\uparrow F}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\overline{\text{sw}}_{M,L}^{\uparrow M}\bef\text{ftn}_{M}\bef\overline{\psi}^{\uparrow M}\bef\phi\overset{?}{=}\big(\phi^{\overline{\uparrow L}}\big)^{\uparrow M}\bef\overline{\psi}^{\uparrow M}\bef\phi\bef\overline{\text{sw}}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}}\bef\text{ftn}_{M^{\prime}}\quad.\label{eq:monadic-naturality-swap-free-monad-derivation2}
\end{equation}

\end_inset

To transform the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-swap-free-monad-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need the inductive assumption that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-swap-free-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) already holds for 
\begin_inset Formula $\overline{\text{sw}}$
\end_inset

.
 To use that assumption, we need to move 
\begin_inset Formula $\overline{\text{sw}}$
\end_inset

 next to 
\begin_inset Formula $\phi^{\uparrow L}\bef\psi$
\end_inset

 under 
\begin_inset Formula $^{\uparrow M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \big(\phi^{\overline{\uparrow L}}\big)^{\uparrow M}\bef\overline{\psi}^{\uparrow M}\bef\gunderline{\phi\bef\overline{\text{sw}}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}}}\bef\text{ftn}_{M^{\prime}}\\
\text{naturality of }\phi:\quad & =\big(\phi^{\overline{\uparrow L}}\bef\overline{\psi}\bef\text{\ensuremath{\overline{\text{sw}}_{M^{\prime},L^{\prime}}}}\big)^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}\\
\text{inductive assumption, Eq.~(\ref{eq:monadic-naturality-swap-free-monad}) for }\overline{\text{sw}}:\quad & =\big(\text{sw}_{M,L}\bef\psi^{\uparrow M}\bef\gunderline{\phi\big)^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}}\\
\text{composition law of }\phi:\quad & =\text{sw}_{M,L}^{\uparrow M}\bef\gunderline{\psi^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\phi\\
\text{naturality of }\text{ftn}_{M}:\quad & =\text{sw}_{M,L}^{\uparrow M}\bef\text{ftn}_{M}\bef\psi^{\uparrow M}\bef\phi\quad.
\end{align*}

\end_inset

The two sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-swap-free-monad-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are now equal, which completes the proof of the law.
\end_layout

\begin_layout Paragraph
Runner laws
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{frun}^{M,M^{\prime}}(\phi)$
\end_inset

 is a monad morphism 
\begin_inset Formula $T\leadsto T^{\prime}$
\end_inset

, first check the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{T^{\prime}}:\quad & \text{pu}_{T}\bef\text{frun}^{M,M^{\prime}}(\phi)=\text{pu}_{L}\bef\gunderline{\text{pu}_{M}\bef\psi^{\uparrow M}}\bef\phi\\
\text{naturality of }\text{pu}_{M}:\quad & =\gunderline{\text{pu}_{L}\bef\psi}\bef\gunderline{\text{pu}_{M}\bef\phi}\\
\text{identity laws of }\phi,\psi:\quad & =\text{pu}_{L^{\prime}}\bef\text{pu}_{M^{\prime}}=\text{pu}_{T^{\prime}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To check the composition law, write the two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{T}\bef\text{frun}\,(\phi)=\text{sw}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{L}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi\quad,\\
\text{right-hand side}:\quad & (\text{frun}\,(\phi))^{\uparrow T}\bef\text{frun}\,(\phi)\bef\text{ftn}_{T^{\prime}}=(\psi^{\uparrow M}\bef\phi)^{\uparrow L\uparrow M}\bef\psi^{\uparrow M}\bef\phi\bef\text{sw}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}}\bef\text{ftn}_{M^{\prime}}\bef\text{ftn}_{L^{\prime}}^{\uparrow M^{\prime}}\quad.
\end{align*}

\end_inset

We begin with the right-hand side since it is more complicated.
 In order to show that it is equal to the left-hand side, we need somehow
 to move 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 to the left in the function compositions, so that we may use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-swap-free-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & (\psi^{\uparrow M}\bef\phi)^{\uparrow L\uparrow M}\bef\psi^{\uparrow M}\bef\gunderline{\phi\bef\text{sw}_{M^{\prime},L^{\prime}}^{\uparrow M^{\prime}}}\bef\text{ftn}_{M^{\prime}}\bef\text{ftn}_{L^{\prime}}^{\uparrow M^{\prime}}\\
\text{naturality of }\phi:\quad & =\big((\psi^{\uparrow M}\bef\gunderline{\phi)^{\uparrow L}\bef\psi\bef\text{sw}_{M^{\prime},L^{\prime}}}\big)^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}\bef\text{ftn}_{L^{\prime}}^{\uparrow M^{\prime}}\\
\text{use Eq.~(\ref{eq:monadic-naturality-swap-free-monad}) under }^{\uparrow M}:\quad & =\big(\gunderline{\psi^{\uparrow M\uparrow L}\bef\text{sw}_{M,L}}\bef\psi^{\uparrow M}\bef\gunderline{\phi\big)^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}}\bef\text{ftn}_{L^{\prime}}^{\uparrow M^{\prime}}\\
\text{composition law of }\phi:\quad & =\text{sw}_{M,L}\bef\gunderline{\big(\psi^{\uparrow L}\bef\psi\big)^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\gunderline{\phi\bef\text{ftn}_{L^{\prime}}^{\uparrow M^{\prime}}}\\
\text{naturality of }\text{ftn}_{M}\text{ and }\phi:\quad & =\text{sw}_{M,L}\bef\text{ftn}_{M}\bef\gunderline{\big(\psi^{\uparrow L}\bef\psi\big)^{\uparrow M}\bef\text{ftn}_{L^{\prime}}^{\uparrow M}}\bef\phi\\
\text{composition law of }\psi:\quad & =\text{sw}_{M,L}\bef\text{ftn}_{M}\bef\big(\text{ftn}_{L}\bef\psi\big)^{\uparrow M}\bef\phi\quad.
\end{align*}

\end_inset

The last line equals the left-hand side of the law.
\end_layout

\begin_layout Paragraph
Functor laws of 
\family typewriter
frun
\end_layout

\begin_layout Standard
To verify the functor laws of 
\begin_inset Formula $\text{frun}$
\end_inset

, begin with the identity law.
 If 
\begin_inset Formula $\phi=\text{id}$
\end_inset

, Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-monad-definition-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) defines the corresponding function 
\begin_inset Formula $\psi$
\end_inset

 also as 
\begin_inset Formula $\psi=\text{id}$
\end_inset

, and so the identity law holds:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{frun}\,(\text{id})=\psi^{\uparrow M}\bef\phi=\text{id}^{\uparrow M}\bef\text{id}=\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law, take any monad morphisms 
\begin_inset Formula $\phi_{1}:Q\leadsto R$
\end_inset

 and 
\begin_inset Formula $\phi_{2}:R\leadsto S$
\end_inset

, where 
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 are some foreign monads.
 Denote temporarily 
\begin_inset Formula $L_{Q}\triangleq\text{Free}^{F\circ Q}$
\end_inset

, 
\begin_inset Formula $L_{R}\triangleq\text{Free}^{F\circ R}$
\end_inset

, 
\begin_inset Formula $L_{S}\triangleq\text{Free}^{F\circ S}$
\end_inset

.
 Then denote the corresponding monad morphisms by 
\begin_inset Formula $\psi_{1}:L_{Q}\leadsto L_{R}$
\end_inset

 and 
\begin_inset Formula $\psi_{2}:L_{R}\leadsto L_{S}$
\end_inset

 and write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{frun}\,(\phi_{1}\bef\phi_{2}):\quad & \text{frun}\,(\phi_{1})\bef\text{frun}(\phi_{2})=\psi_{1}^{\uparrow Q}\bef\gunderline{\phi_{1}\bef\psi_{2}^{\uparrow R}}\bef\phi_{2}\\
\text{naturality of }\phi_{1}:\quad & =\psi_{1}^{\uparrow Q}\bef\psi_{2}^{\uparrow Q}\bef\phi_{1}\bef\phi_{2}=(\psi_{1}\bef\psi_{2})^{\uparrow Q}\bef(\phi_{1}\bef\phi_{2})\quad.
\end{align*}

\end_inset

It remains to show that 
\begin_inset Formula $\psi_{1}\bef\psi_{2}$
\end_inset

 is the monad morphism 
\begin_inset Formula $L_{Q}\leadsto L_{S}$
\end_inset

 corresponding to the composition 
\begin_inset Formula $\phi_{1}\bef\phi_{2}$
\end_inset

.
 By Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-monad-definition-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we have:
\begin_inset Formula 
\begin{align*}
 & \psi_{1}\bef\psi_{2}=\,\begin{array}{|c||cc|}
 & A & (F\circ R\circ L_{R})^{A}\\
\hline A & \text{id} & \bbnum 0\\
(F\circ Q\circ L_{Q})^{A} & \bbnum 0 & \overline{\psi}_{1}^{\uparrow Q\uparrow F}\bef\phi_{1}^{\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & (F\circ S\circ L_{S})^{A}\\
\hline A & \text{id} & \bbnum 0\\
(F\circ R\circ L_{R})^{A} & \bbnum 0 & \overline{\psi}_{2}^{\uparrow R\uparrow F}\bef\phi_{2}^{\uparrow F}
\end{array}\\
 & =\,\begin{array}{|c||cc|}
 & A & (F\circ S\circ L_{S})^{A}\\
\hline A & \text{id} & \bbnum 0\\
(F\circ Q\circ L_{Q})^{A} & \bbnum 0 & \overline{\psi}_{1}^{\uparrow Q\uparrow F}\bef\phi_{1}^{\uparrow F}\bef\overline{\psi}_{2}^{\uparrow R\uparrow F}\bef\phi_{2}^{\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset

We need to show that this equals the code matrix given by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-monad-definition-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for 
\begin_inset Formula $\phi_{1}\bef\phi_{2}$
\end_inset

:
\begin_inset Formula 
\[
\psi_{1}\bef\psi_{2}\overset{?}{=}\psi\triangleq\,\begin{array}{|c||cc|}
 & A & (F\circ S\circ L_{S})^{A}\\
\hline A & \text{id} & \bbnum 0\\
(F\circ Q\circ L_{Q})^{A} & \bbnum 0 & \overline{\psi}^{\uparrow Q\uparrow F}\bef(\phi_{1}\bef\phi_{2})^{\uparrow F}
\end{array}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\psi$
\end_inset

 is a recursive function, we may use the inductive assumption that 
\begin_inset Formula $\overline{\psi}=\overline{\psi}_{1}\bef\overline{\psi}_{2}$
\end_inset

 for the recursive calls.
 The difference between the matrices is then reduced to:
\begin_inset Formula 
\[
\overline{\psi}_{1}^{\uparrow Q\uparrow F}\bef\phi_{1}^{\uparrow F}\bef\overline{\psi}_{2}^{\uparrow R\uparrow F}\bef\phi_{2}^{\uparrow F}\overset{?}{=}(\psi_{1}\bef\psi_{2})^{\uparrow Q\uparrow F}\bef(\phi_{1}\bef\phi_{2})^{\uparrow F}\quad.
\]

\end_inset

The last equality holds since 
\begin_inset Formula $\phi_{1}\bef\overline{\psi}_{2}^{\uparrow R}=\overline{\psi}_{2}^{\uparrow Q}\bef\phi_{1}$
\end_inset

 due to naturality of 
\begin_inset Formula $\phi_{1}$
\end_inset

.
 This proves the law.
\end_layout

\begin_layout Paragraph
Base runner laws
\end_layout

\begin_layout Standard
The base runner needs to satisfy the monad morphism laws and the nondegeneracy
 law.
 Let us temporarily denote by 
\begin_inset Formula $K$
\end_inset

 the base monad, 
\begin_inset Formula $K\triangleq\text{Free}^{F}$
\end_inset

, and by 
\begin_inset Formula $\xi$
\end_inset

 the function:
\begin_inset Formula 
\[
\xi:L^{A}\rightarrow K^{M^{A}}\quad,\quad\quad\xi\triangleq\,\begin{array}{|c||cc|}
 & M^{A} & F^{K^{M^{A}}}\\
\hline A & \text{pu}_{M} & \bbnum 0\\
F^{M^{L^{A}}} & \bbnum 0 & (\overline{\text{brun}}\,(\theta)\bef(x^{:M^{A}}\rightarrow x+\bbnum 0^{:F^{K^{M^{A}}}}))^{\uparrow F}
\end{array}\quad.
\]

\end_inset

We can then write the code for 
\begin_inset Formula $\text{brun}\,(\theta)$
\end_inset

 more conveniently: 
\begin_inset Formula 
\[
\text{brun}\,(\theta)\triangleq\xi^{\uparrow M}\bef\theta^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

To show that 
\begin_inset Formula $\text{brun}\,(\theta)$
\end_inset

 is a monad morphism, we will use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-morphism-composition-theorem"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with the monads 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

.
 The required monad morphism 
\begin_inset Formula $\phi:L\leadsto M$
\end_inset

 is defined as 
\begin_inset Formula $\phi\triangleq\xi\bef\theta$
\end_inset

.
 It remains to verify that 
\begin_inset Formula $\phi$
\end_inset

 is indeed a monad morphism and that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 satisfies the special law with respect to 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Although 
\begin_inset Formula $\theta:K\leadsto\text{Id}$
\end_inset

 is an arbitrary runner, its behavior is constrained by the laws of monad
 morphisms.
 To extract some useful information about 
\begin_inset Formula $\theta$
\end_inset

, begin with its identity law:
\begin_inset Formula 
\[
\text{pu}_{K}\bef\theta=\text{id}\quad,\quad\quad\text{or equivalently:}\quad\quad(x\rightarrow x+\bbnum 0)\bef\theta=\text{id}\quad.
\]

\end_inset

If we apply 
\begin_inset Formula $\theta$
\end_inset

 to a value of type 
\begin_inset Formula $\bbnum 0+F^{A+\bbnum 0}$
\end_inset

, the result must be of type 
\begin_inset Formula $A$
\end_inset

.
 Since the type 
\begin_inset Formula $\bbnum 0+F^{A+\bbnum 0}$
\end_inset

 is equivalent to 
\begin_inset Formula $F^{A}$
\end_inset

, we have obtained a transformation 
\begin_inset Formula $r:F^{A}\rightarrow A$
\end_inset

 that extracts values from 
\begin_inset Formula $F$
\end_inset

-wrappers.
 We can write this property as a definition of the function 
\begin_inset Formula $r$
\end_inset

 through 
\begin_inset Formula $\theta$
\end_inset

:
\begin_inset Formula 
\[
r:F^{A}\rightarrow A\quad,\quad\quad r\triangleq(x^{:A}\rightarrow x+\bbnum 0^{:F^{K^{A}}})^{\uparrow F}\bef(y^{:F^{A+\bbnum 0}}\rightarrow\bbnum 0^{:A}+y)\bef\theta\quad.
\]

\end_inset

Since 
\begin_inset Formula $\theta$
\end_inset

 is a natural transformation (because it is a monad morphism), 
\begin_inset Formula $r$
\end_inset

 is also a natural transformation.
 In the rest of this derivation, we will only need to use the naturality
 property of 
\begin_inset Formula $r$
\end_inset

; we will not need to know the code of 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\begin_layout Standard
With these equations, we can simplify the function 
\begin_inset Formula $\phi\triangleq\xi\bef\theta$
\end_inset

 by first rewriting the definition of 
\begin_inset Formula $\phi$
\end_inset

 in a way that does not explicitly depend on 
\begin_inset Formula $\text{brun}\,(\theta)$
\end_inset

.
 Since 
\begin_inset Formula $\text{brun}\,(\theta)=\phi^{\uparrow M}\bef\text{ftn}_{M}$
\end_inset

, we have:
\begin_inset Formula 
\[
\phi\triangleq\xi\bef\theta=\,\begin{array}{|c||cc|}
 & M^{A} & F^{K^{M^{A}}}\\
\hline A & \text{pu}_{M} & \bbnum 0\\
F^{M^{L^{A}}} & \bbnum 0 & (\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef(x^{:M^{A}}\rightarrow x+\bbnum 0^{:F^{K^{M^{A}}}}))^{\uparrow F}
\end{array}\,\bef\theta\quad.
\]

\end_inset

 Now we may merge the matrix columns of 
\begin_inset Formula $\xi$
\end_inset

 and compute the composition with 
\begin_inset Formula $\theta$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \phi=\xi\bef\theta=\,\begin{array}{|c||c|}
 & M^{A}+F^{K^{M^{A}}}\\
\hline A & \text{pu}_{M}\bef(x\rightarrow x+\bbnum 0)\\
F^{M^{L^{A}}} & (\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef(x\rightarrow x+\bbnum 0))^{\uparrow F}\bef(x\rightarrow\bbnum 0+x)
\end{array}\,\bef\theta\nonumber \\
 & =\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\bef\gunderline{(x\rightarrow x+\bbnum 0)\bef\theta}\\
F^{M^{L^{A}}} & (\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\gunderline{(x\rightarrow x+\bbnum 0))^{\uparrow F}\bef(x\rightarrow\bbnum 0+x)\bef\theta}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
F^{M^{L^{A}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}\quad.\label{eq:simplified-phi-free-monad-transformer-derivation1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
With the simplified code for 
\begin_inset Formula $\phi$
\end_inset

, we proceed with the proof.
 To verify the identity law of 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{L}\bef\phi=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\end{array}\,\bef\,\begin{array}{||c|}
\text{pu}_{M}\\
\overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}=\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law of 
\begin_inset Formula $\phi$
\end_inset

, begin with the left-hand side of that law:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{L}\bef\phi=\,\begin{array}{|c||cc|}
 & A & F^{M^{L^{A}}}\\
\hline A & \text{id} & \bbnum 0\\
F^{M^{L^{A}}} & \bbnum 0 & \text{id}\\
F^{M^{L^{L^{A}}}} & \bbnum 0 & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
F^{M^{L^{A}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
F^{M^{L^{A}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r\\
F^{M^{L^{L^{A}}}} & \overline{\text{ftn}}_{L}^{\uparrow M\uparrow F}\bef\overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}\quad.
\end{align*}

\end_inset

It is easier to work with the right-hand side of the law if we first simplify
 the function 
\begin_inset Formula $\phi\bef\text{ftn}_{M}$
\end_inset

: 
\begin_inset Formula 
\begin{align*}
 & \phi\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{M^{A}}\\
\hline M^{A} & \text{pu}_{M}\\
F^{M^{L^{M^{A}}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}\,\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
F^{M^{L^{M^{A}}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\gunderline{r\bef\text{ftn}_{M}}
\end{array}\quad.\\
 & =\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{id}\\
F^{M^{L^{M^{A}}}} & \big(\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r
\end{array}\quad.
\end{align*}

\end_inset

Now we write the right-hand side of the composition law:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & \phi^{\uparrow L}\bef\phi\bef\text{ftn}_{M}\\
 & \quad=\,\begin{array}{|c||cc|}
 & M^{A} & F^{M^{L^{M^{A}}}}\\
\hline A & \text{pu}_{M} & \bbnum 0\\
F^{M^{L^{A}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r & \bbnum 0\\
F^{M^{L^{L^{A}}}} & \bbnum 0 & \overline{\phi}^{\uparrow L\uparrow M\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{id}\\
F^{M^{L^{M^{A}}}} & \big(\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r
\end{array}\\
 & \quad=\,\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
F^{M^{L^{A}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r\\
F^{M^{L^{L^{A}}}} & \big(\overline{\phi}^{\uparrow L\uparrow M}\bef\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r
\end{array}\quad.
\end{align*}

\end_inset

The remaining difference is in the last rows of the matrices:
\begin_inset Formula 
\[
\big(\overline{\text{ftn}}_{L}^{\uparrow M}\bef\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r\overset{?}{=}\big(\overline{\phi}^{\uparrow L\uparrow M}\bef\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r\quad.
\]

\end_inset

We will prove this equality if we show that:
\begin_inset Formula 
\[
\overline{\text{ftn}}_{L}^{\uparrow M}\bef\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\overline{\phi}^{\uparrow L\uparrow M}\bef\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

Substitute the inductive assumption for the recursive calls to 
\begin_inset Formula $\overline{\phi}$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{L}\bef\overline{\phi}=\overline{\phi}^{\uparrow L}\bef\overline{\phi}\bef\text{ftn}_{M}\quad.
\]

\end_inset

Then we only need to show the following equality:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\overline{\text{ftn}}_{L}^{\uparrow M}\bef\overline{\phi}^{\uparrow M}}\bef\text{ftn}_{M}=\big(\overline{\phi}^{\uparrow L}\bef\overline{\phi}\bef\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
 & \overset{?}{=}\overline{\phi}^{\uparrow L\uparrow M}\bef\overline{\phi}^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}=\overline{\phi}^{\uparrow L\uparrow M}\bef\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

The last expressions are now equal, which completes the derivation.
\end_layout

\begin_layout Standard
It remains to check the special law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{sw}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\phi\bef\text{ftn}_{M}\quad.\label{eq:free-monad-transformer-swap-law-derivation2}
\end{equation}

\end_inset

Substitute the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-swap-for-free-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the left-hand side:
\begin_inset Formula 
\begin{align*}
 & \text{sw}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \gunderline{\text{pu}_{L}^{\uparrow M}\bef\phi^{\uparrow M}}\bef\text{ftn}_{M}\\
F^{M^{L^{M^{A}}}} & \overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\gunderline{\text{pu}_{M}\bef\phi^{\uparrow M}}\bef\text{ftn}_{M}
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\\
F^{M^{L^{M^{A}}}} & \overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\phi\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{id}\\
F^{M^{L^{M^{A}}}} & \overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\phi
\end{array}\quad.
\end{align*}

\end_inset

We can further simplify the last matrix row if we substitute the code for
 
\begin_inset Formula $\phi$
\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplified-phi-free-monad-transformer-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef(p\rightarrow\bbnum 0^{:A}+p)\bef\phi\\
 & =\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
F^{M^{L^{A}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}\\
 & =\overline{\text{sw}}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r=\big(\overline{\text{sw}}^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\overline{\phi}^{\uparrow M}}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r\\
 & =\big(\overline{\text{sw}}^{\uparrow M}\bef\phi^{\uparrow M\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\big)^{\uparrow F}\bef r=\big(\gunderline{\overline{\text{sw}}^{\uparrow M}\bef\phi^{\uparrow M\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r\\
\text{inductive assumption}:\quad & \big((\overline{\phi}\bef\gunderline{\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}}\big)^{\uparrow F}\bef r=\big(\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\big)^{\uparrow F}\bef r\quad.
\end{align*}

\end_inset

Now substitute Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplified-phi-free-monad-transformer-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-monad-transformer-swap-law-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\phi\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{M^{A}}\\
\hline M^{A} & \text{pu}_{M}\\
F^{M^{L^{M^{A}}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}\,\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline M^{A} & \text{pu}_{M}\bef\text{ftn}_{M}\\
F^{M^{L^{M^{A}}}} & \overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r\bef\text{ftn}_{M}
\end{array}\quad.
\]

\end_inset

The difference between the two sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-monad-transformer-swap-law-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is now reduced to:
\begin_inset Formula 
\[
(\overline{\phi}^{\uparrow M}\bef\text{ftn}_{M}\bef\gunderline{\text{ftn}_{M})^{\uparrow F}\bef r}\overset{?}{=}\overline{\phi}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\gunderline{r\bef\text{ftn}_{M}}\quad.
\]

\end_inset

This holds due to naturality of 
\begin_inset Formula $r:F\leadsto\text{Id}$
\end_inset

, which proves Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-monad-transformer-swap-law-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The requirements of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-morphism-composition-theorem"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are now satisfied, so 
\begin_inset Formula $\text{brun}\,(\theta)$
\end_inset

 is a monad morphism.
\end_layout

\begin_layout Standard
The nondegeneracy law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 is an equation between functions of type 
\begin_inset Formula $M^{A}\rightarrow M^{A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{flift}\bef\text{brun}\,(\theta)=\text{pu}_{L}^{\uparrow M}\bef\text{brun}\,(\theta)=\text{pu}_{L}^{\uparrow M}\bef\gunderline{\xi^{\uparrow M}\bef\theta^{\uparrow M}}\bef\text{ftn}_{M}=(\gunderline{\text{pu}_{L}\bef\phi})^{\uparrow M}\bef\text{ftn}_{M}\\
\text{identity law of }\phi:\quad & =\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
The monadic naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is:
\begin_inset Formula 
\begin{align*}
 & \text{flift}\bef\text{frun}\,(\phi)\overset{?}{=}\phi\bef\text{flift}\quad,\\
\text{or, using definitions of }\text{flift}\text{ and }\text{frun}:\quad & \text{pu}_{L}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi\overset{?}{=}\phi\bef\text{pu}_{L^{\prime}}^{\uparrow M^{\prime}}\quad,
\end{align*}

\end_inset

which should hold for any natural transformation 
\begin_inset Formula $\phi^{:M\leadsto M^{\prime}}$
\end_inset

.
 Here, we denoted 
\begin_inset Formula $L^{\prime}\triangleq\text{Free}^{F\circ M^{\prime}}$
\end_inset

.
 Since 
\begin_inset Formula $\psi:L\leadsto L^{\prime}$
\end_inset

 is a monad morphism, we find:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\phi\bef\text{pu}_{L^{\prime}}^{\uparrow M^{\prime}}:\quad & \text{pu}_{L}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi=(\text{pu}_{L}\bef\psi)^{\uparrow M}\bef\phi=\phi\bef\big(\gunderline{\text{pu}_{L}\bef\psi}\big)^{\uparrow M^{\prime}}=\phi\bef\text{pu}_{L^{\prime}}^{\uparrow M^{\prime}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The monadic naturality law of 
\begin_inset Formula $\text{brun}_{L}$
\end_inset

 is:
\begin_inset Formula 
\[
\text{brun}_{L}(\theta)\bef\phi\overset{?}{=}\text{frun}\,(\phi)\bef\text{brun}_{L^{\prime}}(\theta)\quad.
\]

\end_inset

This law should hold for any monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

.
 Write the two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{brun}_{L}(\theta)\bef\phi=\xi^{\uparrow M}\bef\theta^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\phi}\\
\text{composition law of }\phi:\quad & \quad=\gunderline{\xi^{\uparrow M}\bef\theta^{\uparrow M}\bef\phi^{\uparrow M}}\bef\phi\bef\text{ftn}_{M^{\prime}}=(\xi\bef\theta\bef\phi)^{\uparrow M}\bef\phi\bef\text{ftn}_{M^{\prime}}\quad,\\
\text{right-hand side}:\quad & \text{frun}\,(\phi)\bef\text{brun}_{L^{\prime}}(\theta)=\psi^{\uparrow M}\bef\gunderline{\phi\bef\xi^{\uparrow M^{\prime}}\bef\theta^{\uparrow M^{\prime}}}\bef\text{ftn}_{M^{\prime}}\\
\text{naturality of }\phi:\quad & \quad=(\psi\bef\xi\bef\theta)^{\uparrow M}\bef\phi\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

The remaining difference is a comparison of functions of type 
\begin_inset Formula $L^{A}\rightarrow M^{\prime A}$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\xi\bef\theta\bef\phi\overset{?}{=}\psi\bef\xi\bef\theta\quad.\label{eq:monadic-naturality-free-monad-transformer-derivation1}
\end{equation}

\end_inset

Substituting Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:free-monad-definition-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) instead of 
\begin_inset Formula $\psi$
\end_inset

 and Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:simplified-phi-free-monad-transformer-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) instead of 
\begin_inset Formula $\xi\bef\theta$
\end_inset

, we transform this equality to:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{||c|}
\text{pu}_{M}\\
\overline{\xi}^{\uparrow M\uparrow F}\bef\theta^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r
\end{array}\,\bef\phi=\,\begin{array}{||c|}
\gunderline{\text{pu}_{M}\bef\phi}\\
\overline{\xi}^{\uparrow M\uparrow F}\bef\theta^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r\bef\phi
\end{array}\,=\,\begin{array}{||c|}
\text{pu}_{M^{\prime}}\\
\overline{\xi}^{\uparrow M\uparrow F}\bef\theta^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r\bef\phi
\end{array}\\
 & \overset{?}{=}\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}
\end{array}\,\bef\,\begin{array}{||c|}
\text{pu}_{M^{\prime}}\\
\overline{\xi}^{\uparrow M^{\prime}\uparrow F}\bef\theta^{\uparrow M^{\prime}\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\bef r
\end{array}\,=\,\begin{array}{||c|}
\text{pu}_{M^{\prime}}\\
\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\bef\overline{\xi}^{\uparrow M^{\prime}\uparrow F}\bef\theta^{\uparrow M^{\prime}\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\bef r
\end{array}\quad.
\end{align*}

\end_inset

The remaining difference is:
\begin_inset Formula 
\[
\overline{\xi}^{\uparrow M\uparrow F}\bef\theta^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef r\bef\phi\overset{?}{=}\overline{\psi}^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\bef\overline{\xi}^{\uparrow M^{\prime}\uparrow F}\bef\theta^{\uparrow M^{\prime}\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\bef r\quad.
\]

\end_inset

By the inductive assumption, Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-free-monad-transformer-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds for recursive calls 
\begin_inset Formula $\overline{\xi}$
\end_inset

 and 
\begin_inset Formula $\overline{\psi}$
\end_inset

.
 To use that assumption, we need to move these functions towards each other
 in the compositions above:
\begin_inset Formula 
\begin{align*}
 & \overline{\xi}^{\uparrow M\uparrow F}\bef\theta^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\bef\gunderline{r\bef\phi}=\overline{\xi}^{\uparrow M\uparrow F}\bef\theta^{\uparrow M\uparrow F}\bef\gunderline{\text{ftn}_{M}^{\uparrow F}\bef\phi^{\uparrow F}}\bef r\\
\text{composition law of }\phi:\quad & =\gunderline{\overline{\xi}^{\uparrow M\uparrow F}\bef\theta^{\uparrow M\uparrow F}\bef\big(\phi^{\uparrow M}}\bef\phi\bef\text{ftn}_{M^{\prime}}\big)^{\uparrow F}\bef r=(\gunderline{\overline{\xi}\bef\theta\bef\phi})^{\uparrow M\uparrow F}\bef\phi^{\uparrow F}\bef\text{ftn}_{M^{\prime}}^{\uparrow F}\bef r\\
\text{inductive assumption}:\quad & =\big((\overline{\psi}\bef\gunderline{\xi\bef\theta)^{\uparrow M}\bef\phi}\bef\text{ftn}_{M^{\prime}}\big)^{\uparrow F}\bef r=\big((\overline{\psi}^{\uparrow M}\bef\phi\bef(\xi\bef\theta)^{\uparrow M^{\prime}}\bef\text{ftn}_{M^{\prime}}\big)^{\uparrow F}\bef r\quad.
\end{align*}

\end_inset

The two sides are now equal.
\end_layout

\begin_layout Standard
This concludes the proofs of the laws for the free monad's transformer.
\end_layout

\begin_layout Subsection
Transformer for the 
\family typewriter
List
\family default
 monad.
 Proofs
\begin_inset CommandInset label
LatexCommand label
name "subsec:Transformer-for-the-List-monad"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's transformer, usually named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListT
\end_layout

\end_inset

, is defined as a recursive type:
\begin_inset Formula 
\[
T_{\text{List}}^{M,A}\triangleq M^{\bbnum 1+A\times T_{\text{List}}^{M,A}}\quad,
\]

\end_inset

that wraps each partial tail of the list into a separate layer of an 
\begin_inset Formula $M$
\end_inset

-effect.
 The result is an 
\begin_inset Quotes eld
\end_inset

effectful list
\begin_inset Quotes erd
\end_inset

: obtaining each next element of the list requires running an 
\begin_inset Formula $M$
\end_inset

-effect.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method (
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

) should sequence all 
\begin_inset Formula $M$
\end_inset

-effects of the nested lists in the order they occur in the outer list.
\end_layout

\begin_layout Standard
Despite a superficial similarity between 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 and the transformers for the free monad and the free pointed monad, proofs
 of the laws for 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 require a different technique, and the transformer's implementation is
 significantly more complicated.
 The reason is that the functor 
\begin_inset Formula $L$
\end_inset

 defined by:
\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A\times T_{\text{List}}^{M,A}=\bbnum 1+A\times M^{L^{A}}\quad,
\]

\end_inset

does not admit a monad instance that flattens the 
\begin_inset Quotes eld
\end_inset

effectful lists
\begin_inset Quotes erd
\end_inset

 correctly (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-effectful-list-not-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, we cannot define 
\begin_inset Formula $T_{\text{List}}=M\circ L$
\end_inset

 as a functor composition of two monads.
 As a result, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method of 
\begin_inset Formula $T_{\text{List}}$
\end_inset

, which we will denote for brevity by 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

, cannot be defined via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function, as we have done for the other monad transformers just mentioned.
 Instead, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method of 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 is defined via a special helper function named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 as shown in the following statement.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 was studied in the paper 
\begin_inset Quotes eld
\end_inset

Composing monads
\begin_inset Quotes erd
\end_inset

 (
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf"
literal "false"

\end_inset


\family default
).
 However, that paper did not correctly define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's transformer.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-list-monad-transformer"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-list-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The type constructor 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 satisfies all the monad transformer laws.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We will shortly implement a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 with the type signature:
\begin_inset Formula 
\[
\text{prod}:L^{M^{L^{A}}}\rightarrow M^{L^{A}}\cong\bbnum 1+M^{L^{A}}\times M^{L^{M^{L^{A}}}}\rightarrow M^{L^{A}}\quad.
\]

\end_inset

The monad methods of 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 are then defined by:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3.5pc}T^{T^{A}}=M^{L^{M^{L^{A}}}}\ar[r]\sp(0.6){\text{prod}^{\uparrow M}}\ar[rd]\sb(0.5){\text{ftn}_{T}\triangleq\ } & M^{M^{L^{A}}}\ar[d]\sp(0.45){\ \text{ftn}_{M}}\\
 & M^{L^{A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{pu}_{T}\triangleq\text{pu}_{L}\bef\text{pu}_{M}\quad,\quad\quad\text{ftn}_{T}\triangleq\text{prod}^{\uparrow M}\bef\text{ftn}_{M}\quad.\label{eq:def-pure-flatten-via-prod-for-list-monad-transformer}
\end{equation}

\end_inset

The method 
\begin_inset Formula $\text{pu}_{L}:A\rightarrow L^{A}$
\end_inset

 creates a list with a single element and an empty effect:
\begin_inset Formula 
\[
\text{pu}_{L}\triangleq a^{:A}\rightarrow\bbnum 0^{:\bbnum 1}+a\times\text{pu}_{M}(1+\bbnum 0^{:A\times M^{L^{A}}})\quad.
\]

\end_inset

Since the value 
\begin_inset Formula $1+\bbnum 0^{:A\times M^{L^{A}}}$
\end_inset

 will be used frequently, we denote it by 
\begin_inset Formula $\text{Nil}^{:L^{A}}$
\end_inset

.
 So, we write:
\begin_inset Formula 
\[
\text{pu}_{L}\triangleq a^{:A}\rightarrow\bbnum 0^{:\bbnum 1}+a\times(\text{Nil}\triangleright\text{pu}_{M})=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times M^{L^{A}}\\
\hline A & \bbnum 0 & a\rightarrow a\times\text{pu}_{M}(\text{Nil})
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
Implementing 
\family typewriter
prod
\end_layout

\begin_layout Standard
The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 uses a helper function that we temporarily call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

, with type:
\begin_inset Formula 
\[
\text{comb}:M^{L^{A}}\rightarrow M^{L^{A}}\rightarrow M^{L^{A}}\quad.
\]

\end_inset

This function 
\begin_inset Quotes eld
\end_inset

combines
\begin_inset Quotes erd
\end_inset

 two values of type 
\begin_inset Formula $M^{L^{A}}\triangleq T_{\text{List}}^{A}$
\end_inset

 into a new value of the same type:
\begin_inset Formula 
\begin{equation}
\text{comb}\,(m)(n)\triangleq m\triangleright\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow n\\
A\times M^{L^{A}} & a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0^{:\bbnum 1}+a\times\overline{\text{comb}}\,(p)(n)\big)
\end{array}\,\bigg)\quad.\label{eq:definition-of-comb-for-effectful-list}
\end{equation}

\end_inset

The code uses the monad 
\begin_inset Formula $M$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method to sequence all 
\begin_inset Formula $M$
\end_inset

-effects from the first list before all 
\begin_inset Formula $M$
\end_inset

-effects of the second one.
 We will show in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monoid-operation-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 function is a monoidal operation for values of type 
\begin_inset Formula $T_{\text{List}}^{A}$
\end_inset

; that property will be used in the later derivations.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 is defined recursively via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{prod}\triangleq\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
M^{L^{A}}\times M^{L^{M^{L^{A}}}} & m\times p\rightarrow\text{comb}\,(m)(p\triangleright\overline{\text{prod}}^{\uparrow M}\bef\text{ftn}_{M})
\end{array}\quad.\label{eq:definition-of-prod-for-list-monad-transformer}
\end{equation}

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 satisfies certain laws that we will prove in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-laws-of-prod-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
 Besides a naturality law, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 satisfies two identity laws
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of 
\family typewriter
prod
\family default
 for 
\family typewriter
ListT
\end_layout

\end_inset

 and an 
\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of 
\family typewriter
prod
\family default
 for 
\family typewriter
ListT
\end_layout

\end_inset

associativity law:
\begin_inset Formula 
\begin{align}
\text{identity laws}:\quad & \text{pu}_{L}\bef\text{prod}=\text{id}\quad,\quad\quad\text{pu}_{T}^{\uparrow L}\bef\text{prod}=\text{pu}_{M}\quad,\label{eq:identity-laws-of-prod-for-effectful-list}\\
\text{associativity law}:\quad & \text{prod}\bef\text{prod}^{\uparrow M}\bef\text{ftn}_{M}=\text{prod}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{prod}\quad.\label{eq:associativity-law-of-prod-for-effectful-list}
\end{align}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3.0pc}M^{L^{A}}\ar[rd]\sp(0.5){\text{id}}\ar[d]\sb(0.45){\text{pu}_{L}} &  & L^{A}\ar[ld]\sb(0.5){\text{pu}_{M}}\ar[d]\sp(0.4){\text{pu}_{T}^{\uparrow L}} & L^{M^{L^{M^{L^{A}}}}}\ar[d]\sp(0.4){\text{prod}}\ar[r]\sp(0.55){\text{prod}^{\uparrow M\uparrow L}} & L^{M^{M^{L^{A}}}}\ar[r]\sp(0.5){\text{ftn}_{M}^{\uparrow L}} & L^{M^{L^{A}}}\ar[d]\sp(0.4){\text{prod}}\\
L^{M^{L^{A}}}\ar[r]\sp(0.45){\text{prod}} & M^{L^{A}} & \ar[l]\sb(0.45){\text{prod}}L^{M^{L^{A}}} & M^{L^{M^{L^{A}}}}\ar[r]\sp(0.5){\text{prod}^{\uparrow M}} & M^{M^{L^{A}}}\ar[r]\sp(0.55){\text{ftn}_{M}} & M^{L^{A}}
}
\]

\end_inset


\end_layout

\begin_layout Standard
We will now verify that these laws make the monad laws for 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 hold automatically:
\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
of 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 need to be verified using the monad methods 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 we defined above.
 To verify the left identity law of 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{pu}_{T}\bef\text{ftn}_{T}=\text{pu}_{L}\bef\gunderline{\text{pu}_{M}\bef\text{prod}^{\uparrow M}}\bef\text{ftn}_{M}=\gunderline{\text{pu}_{L}\bef\text{prod}}\bef\text{pu}_{M}\bef\text{ftn}_{M}\\
\text{identity law of }\text{prod}:\quad & =\text{pu}_{M}\bef\text{ftn}_{M}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the right identity law of 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{pu}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\gunderline{\text{pu}_{T}^{\uparrow L\uparrow M}\bef\text{prod}^{\uparrow M}}\bef\text{ftn}_{M}\\
\text{identity law of }\text{prod}\text{ under }^{\uparrow M}:\quad & =\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the associativity law of 
\begin_inset Formula $T$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{T}\bef\text{ftn}_{T}:\quad & \text{ftn}_{T}^{\uparrow T}\bef\text{ftn}_{T}=\gunderline{(\text{prod}^{\uparrow M}\bef\text{ftn}_{M})^{\uparrow L\uparrow M}\bef\text{prod}^{\uparrow M}}\bef\text{ftn}_{M}\\
 & =(\gunderline{\text{prod}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{prod}})^{\uparrow M}\bef\text{ftn}_{M}\\
\text{associativity law of }\text{prod}:\quad & =(\text{prod}\bef\text{prod}^{\uparrow M}\bef\gunderline{\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}}=\text{prod}^{\uparrow M}\bef\gunderline{\text{prod}^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}\\
 & =\text{prod}^{\uparrow M}\bef\text{ftn}_{M}\bef\text{prod}^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{T}\bef\text{ftn}_{T}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $M=\text{Id}$
\end_inset

, the type constructor 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 since 
\begin_inset Formula $T_{\text{List}}$
\end_inset

 is then defined by the recursive equation:
\begin_inset Formula 
\[
T_{\text{List}}^{A}=M^{\bbnum 1+A\times T_{\text{List}}^{A}}\cong\bbnum 1+A\times T_{\text{List}}^{A}\quad.
\]

\end_inset

After setting 
\begin_inset Formula $M=\text{Id}$
\end_inset

, the code of 
\begin_inset Formula $\text{pu}_{T}$
\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

, and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 becomes the same as the code of 
\begin_inset Formula $\text{pu}_{\text{List}}$
\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 (
\begin_inset Formula $\pplus$
\end_inset

), and 
\begin_inset Formula $\text{ftn}_{\text{List}}$
\end_inset

.
 So, the identity laws hold for 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Paragraph
Lifting laws
\end_layout

\begin_layout Standard
The foreign lift function is implemented as:
\begin_inset Formula 
\[
\text{flift}:M^{A}\rightarrow M^{L^{A}}\quad,\quad\quad\text{flift}\triangleq\text{pu}_{L}^{\uparrow M}\quad.
\]

\end_inset

To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is a monad morphism, begin with the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{T}:\quad & \text{pu}_{M}\bef\text{flift}=\gunderline{\text{pu}_{M}\bef\text{pu}_{L}^{\uparrow M}}=\text{pu}_{L}\bef\text{pu}_{M}\\
\text{by definition of }\text{pu}_{T}:\quad & =\text{pu}_{T}\quad.
\end{align*}

\end_inset

To verify the composition law, write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{M}\bef\text{flift}=\text{ftn}_{M}\bef\text{pu}_{L}^{\uparrow M}\quad,\\
\text{right-hand side}:\quad & \text{flift}^{\uparrow M}\bef\text{flift}\bef\text{ftn}_{T}=\text{pu}_{L}^{\uparrow M\uparrow M}\bef\gunderline{\text{pu}_{L}^{\uparrow M}\bef\text{prod}^{\uparrow M}}\bef\text{ftn}_{M}\\
\text{identity law of }\text{prod}:\quad & \quad=\gunderline{\text{pu}_{L}^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}=\text{ftn}_{M}\bef\text{pu}_{L}^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Implementation of 
\family typewriter
frun
\end_layout

\begin_layout Standard
Since the transformer 
\begin_inset Formula $T_{\text{List}}=M\circ L$
\end_inset

 is not purely compositional (
\begin_inset Formula $L$
\end_inset

 itself depends on 
\begin_inset Formula $M$
\end_inset

), mapping the monad 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $M^{\prime}$
\end_inset

 via a monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

 requires us also to map 
\begin_inset Formula $L$
\end_inset

 to 
\begin_inset Formula $L^{\prime}$
\end_inset

, where we define: 
\begin_inset Formula 
\[
L^{\prime A}\triangleq\bbnum 1+A\times M^{\prime L^{\prime A}}\quad.
\]

\end_inset

We denote that map temporarily by 
\begin_inset Formula $\psi$
\end_inset

.
 To be precise, 
\begin_inset Formula $\psi$
\end_inset

 is a function of 
\begin_inset Formula $\phi$
\end_inset

 and should be denoted by 
\begin_inset Formula $\psi(\phi)$
\end_inset

, but we will write simply 
\begin_inset Formula $\psi$
\end_inset

 for brevity (since 
\begin_inset Formula $\phi$
\end_inset

 is fixed throughout most of the derivation).
 We can implement 
\begin_inset Formula $\psi:L^{A}\rightarrow L^{\prime A}$
\end_inset

 by the following code:
\begin_inset Formula 
\begin{equation}
\psi:L^{A}\rightarrow L^{\prime A}\quad,\quad\quad\psi\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times M^{\prime L^{\prime A}}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times M^{L^{A}} & \bbnum 0 & \text{id}\boxtimes(\overline{\psi}^{\uparrow M}\bef\phi)
\end{array}\quad.\label{eq:list-monad-definition-of-psi}
\end{equation}

\end_inset

The foreign runner (
\begin_inset Formula $\text{frun}^{M,M^{\prime}}(\phi):T_{\text{List}}\leadsto T_{\text{List}}^{\prime}$
\end_inset

) is then implemented as:
\begin_inset Formula 
\[
\text{frun}^{M,M^{\prime}}\!:\,(M\leadsto M^{\prime})\rightarrow M^{L^{A}}\rightarrow M^{\prime L^{\prime A}}\!\quad,\quad\text{frun}^{M,M^{\prime}}\!(\phi^{:M\leadsto M^{\prime}})\triangleq\psi^{\uparrow M}\bef\phi\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
Monadic naturality of 
\family typewriter
prod
\end_layout

\begin_layout Standard
When the monad 
\begin_inset Formula $M$
\end_inset

 is mapped to 
\begin_inset Formula $M^{\prime}$
\end_inset

 via a monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 function with type signature 
\begin_inset Formula $\text{prod}_{M,L}:L\circ M\circ L\leadsto M\circ L$
\end_inset

 is replaced by the corresponding function 
\begin_inset Formula $\text{prod}_{M^{\prime},L^{\prime}}:L^{\prime}\circ M^{\prime}\circ L^{\prime}\leadsto M^{\prime}\circ L^{\prime}$
\end_inset

.
 The function 
\begin_inset Formula $\text{prod}_{M^{\prime},L^{\prime}}$
\end_inset

 has the same code as 
\begin_inset Formula $\text{prod}_{M,L}$
\end_inset

 except for using the monad parameter 
\begin_inset Formula $M^{\prime}$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

.
 This monadic naturality
\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law!of 
\family typewriter
prod
\family default
 for 
\family typewriter
ListT
\end_layout

\end_inset

 property is expressed by the law analogous to Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-free-pointed-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{1.6pc}L^{M^{L^{A}}}\ar[rd]\sb(0.45){\text{prod}_{M,L}}\ar[r]\sp(0.5){\psi^{\uparrow M\uparrow L}} & L^{M^{L^{\prime A}}}\ar[r]\sp(0.5){\phi^{\uparrow L}} & L^{M^{\prime L^{\prime A}}}\ar[r]\sp(0.5){\psi} & L^{\prime M^{\prime L^{\prime A}}}\ar[d]\sb(0.45){\,\text{prod}_{M^{\prime},L^{\prime}}}\\
 & M^{L^{A}}\ar[r]\sp(0.5){\psi^{\uparrow M}} & M^{L^{\prime A}}\ar[r]\sp(0.5){\phi} & M^{\prime L^{\prime A}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{prod}_{M,L}\bef\psi^{\uparrow M}\bef\phi=\psi^{\uparrow M\uparrow L}\bef\phi^{\uparrow L}\bef\psi\bef\text{prod}_{M^{\prime},L^{\prime}}\quad.\label{eq:monadic-naturality-law-of-prod-for-list-transformer}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
This law guarantees that the code of 
\begin_inset Formula $\text{prod}_{M,L}$
\end_inset

 works in the same way for all foreign monads 
\begin_inset Formula $M$
\end_inset

.
 We will verify this law in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-laws-of-prod-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
\end_layout

\begin_layout Paragraph
Runner laws
\end_layout

\begin_layout Standard
To show that the foreign runner is a monad morphism, begin with the identity
 law:
\begin_inset Formula 
\begin{align*}
\text{expect }\text{pu}_{M^{\prime}\circ L^{\prime}}:\quad & \text{pu}_{M\circ L}\bef\text{frun}\,(\phi)=\text{pu}_{L}\bef\gunderline{\text{pu}_{M}\bef\psi^{\uparrow M}}\bef\phi=\text{pu}_{L}\bef\psi\bef\gunderline{\text{pu}_{M}\bef\phi}\\
\text{identity law of }\phi:\quad & =\text{pu}_{L}\bef\psi\bef\text{pu}_{M^{\prime}}=\,\begin{array}{||cc|}
\bbnum 0 & a\rightarrow a\times\text{pu}_{M}(\text{Nil})\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\overline{\psi}^{\uparrow M}\bef\phi)
\end{array}\,\bef\text{pu}_{M^{\prime}}\\
 & =\,\begin{array}{||cc|}
\bbnum 0 & a\rightarrow a\times(\gunderline{\text{Nil}\triangleright\text{pu}_{M}\bef\overline{\psi}^{\uparrow M}\bef\phi})\end{array}\,\bef\text{pu}_{M^{\prime}}\\
 & =\,\,\begin{array}{||cc|}
\bbnum 0 & a\rightarrow a\times(\text{Nil}\triangleright\text{pu}_{M^{\prime}})\end{array}\,\bef\text{pu}_{M^{\prime}}=\text{pu}_{L^{\prime}}\bef\text{pu}_{M^{\prime}}=\text{pu}_{M^{\prime}\circ L^{\prime}}\quad.
\end{align*}

\end_inset

Here we used the following computation:
\begin_inset Formula 
\[
\text{Nil}\triangleright\gunderline{\text{pu}_{M}\bef\psi^{\uparrow M}}\bef\phi=\text{Nil}\triangleright\psi\bef\gunderline{\text{pu}_{M}\bef\phi}=\text{Nil}\triangleright\text{pu}_{M^{\prime}}\quad.
\]

\end_inset

As part of this derivation, we have found the property:
\begin_inset Formula 
\begin{equation}
\text{pu}_{L}\bef\psi=\text{pu}_{L^{\prime}}\quad,\label{eq:puL-psi-derivation1}
\end{equation}

\end_inset

which resembles the identity law of a monad morphism for 
\begin_inset Formula $\psi:L\leadsto L^{\prime}$
\end_inset

.
 However, 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $L^{\prime}$
\end_inset

 do not have the right monad structures we can use here.
\end_layout

\begin_layout Standard
To verify the composition law, write its two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{ftn}_{T}\bef\text{frun}\,(\phi)=\text{flm}_{M}(\text{prod})\bef\psi^{\uparrow M}\bef\phi=\text{flm}_{M}(\text{prod}\bef\psi^{\uparrow M})\bef\phi\\
\phi\text{'s composition law}:\quad & \quad=\phi\bef\text{flm}_{M^{\prime}}(\text{prod}\bef\psi^{\uparrow M}\bef\phi)\quad,\\
\text{right-hand side}:\quad & \big(\text{frun}\,(\phi)\big)^{\uparrow T}\bef\text{frun}\,(\phi)\bef\text{ftn}_{T^{\prime}}=\gunderline{(\psi^{\uparrow M}\bef\phi)^{\uparrow L\uparrow M}\bef\psi^{\uparrow M}\bef\phi}\bef\text{flm}_{M^{\prime}}(\text{prod})\\
\text{naturality law of }\phi:\quad & \quad=\phi\bef\big((\psi^{\uparrow M}\bef\phi)^{\uparrow L}\bef\psi\big)^{\uparrow M^{\prime}}\bef\text{flm}_{M^{\prime}}(\text{prod})=\phi\bef\text{flm}_{M^{\prime}}\big((\psi^{\uparrow M}\bef\phi)^{\uparrow L}\bef\psi\bef\text{prod}\big)\quad.
\end{align*}

\end_inset

The remaining difference is:
\begin_inset Formula 
\[
\text{prod}\bef\psi^{\uparrow M}\bef\phi\overset{?}{=}(\psi^{\uparrow M}\bef\phi)^{\uparrow L}\bef\psi\bef\text{prod}\quad.
\]

\end_inset

The last equation is the same as the monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-prod-for-list-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Functor laws of 
\family typewriter
frun
\end_layout

\begin_layout Standard
To verify the functor laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

, begin with the identity law:
\begin_inset Formula 
\[
\text{frun}\,(\text{id})=\psi(\text{id})\bef\text{id}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\overline{\psi(\text{id)}}^{\uparrow M}\bef\text{id})
\end{array}\,\bef\text{id}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes\text{id}
\end{array}\,=\text{id}\quad.
\]

\end_inset

Then verify the composition law, assuming 
\begin_inset Formula $\phi_{1}:M\leadsto M^{\prime}$
\end_inset

 and 
\begin_inset Formula $\phi_{2}:M^{\prime}\leadsto M^{\prime\prime}$
\end_inset

 are monad morphisms:
\begin_inset Formula 
\begin{align*}
 & \text{frun}\,(\phi_{1})\bef\text{frun}\,(\phi_{2})=\psi^{\uparrow M}(\phi_{1})\bef\gunderline{\phi_{1}\bef\psi^{\uparrow M^{\prime}}(\phi_{2})}\bef\phi_{2}\\
\text{naturality law of }\phi_{1}:\quad & =\psi^{\uparrow M}(\phi_{1})\bef\psi^{\uparrow M}(\phi_{2})\bef\phi_{1}\bef\phi_{2}=\big(\psi(\phi_{1})\bef\psi(\phi_{2})\big)^{\uparrow M}\bef\phi_{1}\bef\phi_{2}\\
 & \overset{?}{=}\text{frun}\,(\phi_{1}\bef\phi_{2})=\psi(\phi_{1}\bef\phi_{2})^{\uparrow M}\bef\phi_{1}\bef\phi_{2}\quad.
\end{align*}

\end_inset

The remaining difference is:
\begin_inset Formula 
\[
\psi(\phi_{1})\bef\psi(\phi_{2})\overset{?}{=}\psi(\phi_{1}\bef\phi_{2})\quad,
\]

\end_inset

which we verify by writing:
\begin_inset Formula 
\begin{align*}
 & \psi(\phi_{1})\bef\psi(\phi_{2})=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\overline{\psi(\phi_{1}\text{)}}^{\uparrow M}\bef\phi_{1})
\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\overline{\psi(\phi_{2}\text{)}}^{\uparrow M}\bef\phi_{2})
\end{array}\\
\text{compute composition}:\quad & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\gunderline{\overline{\psi(\phi_{1}\text{)}}^{\uparrow M}\bef\phi_{1}\bef\overline{\psi(\phi_{2}\text{)}}^{\uparrow M}\bef\phi_{2}})
\end{array}\\
\text{inductive assumption}:\quad & =\,\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\overline{\psi(\phi_{1}\bef\phi_{2}\text{)}}^{\uparrow M}\bef\phi_{1}\bef\phi_{2})
\end{array}\,=\psi(\phi_{1}\bef\phi_{2})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Base runner laws
\end_layout

\begin_layout Standard
The base runner (
\begin_inset Formula $\text{brun}:T^{A}\rightarrow M^{A}$
\end_inset

) cannot be implemented for arbitrary types 
\begin_inset Formula $A$
\end_inset

: since a list may be empty, it is not always possible to extract a value
 of type 
\begin_inset Formula $M^{A}$
\end_inset

 out of a given value of type 
\begin_inset Formula $T_{\text{List}}^{M,A}$
\end_inset

.
 However, for a monoid type 
\begin_inset Formula $R$
\end_inset

 with binary operation 
\begin_inset Formula $\oplus_{R}$
\end_inset

 and empty element 
\begin_inset Formula $e_{R}$
\end_inset

, the type signature 
\begin_inset Formula $\text{List}^{R}\rightarrow R$
\end_inset

 is implemented by the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 operation: 
\begin_inset Formula 
\[
\text{reduce}:\text{List}^{R}\rightarrow R\quad,\quad\quad\text{reduce}\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline \bbnum 1 & 1\rightarrow e_{R}\\
R\times\text{List}^{R} & h\times t\rightarrow h\oplus_{R}\overline{\text{reduce}}\,(t)
\end{array}\quad.
\]

\end_inset

We can similarly implement a base runner (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

) for the transformer 
\begin_inset Formula $T_{\text{List}}^{M,A}$
\end_inset

 if we restrict its usage to 
\emph on
monoid
\emph default
 types 
\begin_inset Formula $A=R$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 with the type signature 
\begin_inset Formula $M^{L^{R}}\rightarrow M^{R}$
\end_inset

 aggregates all elements of the effectful list into a single value of type
 
\begin_inset Formula $M^{R}$
\end_inset

 (which is also a monoid type):
\begin_inset Formula 
\[
\text{brun}:M^{L^{R}}\rightarrow M^{R}\quad,\quad\quad\text{brun}\triangleq\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{R}\\
\hline \bbnum 1 & 1\rightarrow\text{pu}_{M}(e_{R})\\
R\times M^{L^{R}} & h\times t\rightarrow\text{pu}_{M}(h)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\quad.
\]

\end_inset

Here we use the monoid 
\begin_inset Formula $M^{R}$
\end_inset

's binary operation 
\begin_inset Formula $\oplus_{M}$
\end_inset

 defined by:
\begin_inset Formula 
\begin{equation}
p^{:M^{R}}\oplus_{M}q^{:M^{R}}\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad.\label{eq:definition-of-oplus-M-monad-monoid-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It can be shown that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 satisfies the nondegeneracy law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{flift}\bef\text{brun}=\text{pu}_{L}^{\uparrow M}\bef\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
\text{naturality of }\text{flm}_{M}:\quad & =\text{flm}_{M}\bigg(\gunderline{\text{pu}_{L}}\bef\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
\text{definition of }\text{pu}_{L}:\quad & =\text{flm}_{M}\bigg(\,\begin{array}{||cc|}
\bbnum 0 & a\rightarrow a\times(\text{Nil}\triangleright\text{pu}_{M})\end{array}\,\bef\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
 & =\text{flm}_{M}(a\rightarrow\text{pu}_{M}(a)\oplus_{M}\gunderline{\text{brun}\,(\text{Nil}\triangleright\text{pu}_{M})})\\
\text{use Eq.~(\ref{eq:listt-brun-derivation1})}:\quad & =\text{flm}_{M}(a\rightarrow\gunderline{\text{pu}_{M}(a)\oplus\text{pu}_{M}(e_{R})})=\text{flm}_{M}(\gunderline{a\rightarrow\text{pu}_{M}(a)})=\text{flm}_{M}(\text{pu}_{M})=\text{id}\quad.
\end{align*}

\end_inset

Here we used the property that 
\begin_inset Formula $\text{pu}_{M}(e_{R})$
\end_inset

 is the unit value for 
\begin_inset Formula $\oplus_{M}$
\end_inset

, and also computed:
\begin_inset Formula 
\begin{equation}
\text{brun}\,(\text{Nil}\triangleright\text{pu}_{M})=\text{Nil}\triangleright\gunderline{\text{pu}_{M}\bef\text{flm}_{M}}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)=\text{pu}_{M}(e_{R})\quad.\label{eq:listt-brun-derivation1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The monad morphism identity law holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{T}\bef\text{brun}=\text{pu}_{L}\bef\gunderline{\text{pu}_{M}\bef\text{flm}_{M}}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
\text{identity law of }\text{flm}_{M}:\quad & =\,\begin{array}{||cc|}
\bbnum 0 & a^{:R}\rightarrow a\times(\text{Nil}\triangleright\text{pu}_{M})\end{array}\,\bef\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\\
\text{matrix composition}:\quad & =a^{:R}\rightarrow\text{pu}_{M}(a)\oplus_{M}\gunderline{\overline{\text{brun}}\,(\text{Nil}\triangleright\text{pu}_{M})}\\
\text{use Eq.~(\ref{eq:listt-brun-derivation1})}:\quad & =a\rightarrow\text{pu}_{M}(a)\,\gunderline{\oplus_{M}\,\text{pu}_{M}(e_{R})}=a\rightarrow\text{pu}_{M}(a)=\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It is not clear whether the monad morphism composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 holds (Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Problem-monads-5-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 If the composition law does not hold, the base runner 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 must be applied to an entire monadic program.
 Running several parts of a program separately and composing the results
 as values of type 
\begin_inset Formula $M^{A}$
\end_inset

 will not give the same value as running the entire program.
\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

, the monadic naturality law is written as:
\begin_inset Formula 
\[
\text{flift}^{M}\bef\text{frun}\,(\phi)=\phi\bef\text{flift}^{M^{\prime}}\quad,
\]

\end_inset

where 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

 is an arbitrary natural transformation.
 Begin with the left-hand side:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\phi\bef\text{flift}^{M^{\prime}}:\quad & \text{flift}^{M}\bef\text{frun}\,(\phi)=\text{pu}_{L}^{\uparrow M}\bef\psi^{\uparrow M}\bef\phi=(\text{pu}_{L}\bef\psi)^{\uparrow M}\bef\phi\\
\text{naturality law of }\phi:\quad & =\phi\bef(\text{pu}_{L}\bef\psi)^{\uparrow M}\\
\text{use Eq.~(\ref{eq:puL-psi-derivation1})}:\quad & =\phi\bef\text{pu}_{L^{\prime}}^{\uparrow M^{\prime}}=\phi\bef\text{flift}^{M^{\prime}}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The monadic naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

 is written for any monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

:
\begin_inset Formula 
\[
\text{brun}^{M}\bef\phi=\text{frun}\,(\phi)\bef\text{brun}^{M^{\prime}}\quad.
\]

\end_inset

Begin with the left-hand side:
\begin_inset Formula 
\[
\text{flm}_{M}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\bef\phi=\phi\bef\text{flm}_{M^{\prime}}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}\,(t)
\end{array}\,\bef\phi\bigg)\quad.
\]

\end_inset

Using the equality 
\begin_inset Formula $\text{frun}\,(\phi)=\psi^{\uparrow M}\bef\phi=\phi\bef\psi^{\uparrow M^{\prime}}$
\end_inset

, we write the right-hand side as
\begin_inset Formula 
\begin{align*}
 & \text{frun}\,(\phi)\bef\text{brun}=\phi\bef\gunderline{\psi^{\uparrow M^{\prime}}\bef\text{flm}_{M^{\prime}}}\bigg(\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M^{\prime}}(e_{R})\\
r\times t\rightarrow\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\\
\text{naturality law of }\text{flm}_{M^{\prime}}:\quad & =\phi\bef\text{flm}_{M^{\prime}}\bigg(\psi\bef\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M^{\prime}}(e_{R})\\
r\times t\rightarrow\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\overline{\text{brun}}\,(t)
\end{array}\,\bigg)\quad.
\end{align*}

\end_inset

The remaining difference is:
\begin_inset Formula 
\[
\begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}{}^{M}(t)
\end{array}\,\bef\phi\overset{?}{=}\psi\bef\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M^{\prime}}(e_{R})\\
r\times t\rightarrow\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\overline{\text{brun}}{}^{M^{\prime}}(t)
\end{array}\quad.
\]

\end_inset

Rewrite the left-hand side:
\begin_inset Formula 
\begin{align*}
 & \begin{array}{||c|}
1\rightarrow\text{pu}_{M}(e_{R})\\
r\times t\rightarrow\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}{}^{M}(t)
\end{array}\,\bef\phi=\,\begin{array}{||c|}
1\rightarrow e_{R}\triangleright\gunderline{\text{pu}_{M}\bef\phi}\\
r\times t\rightarrow\phi\big(\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}{}^{M}(t)\big)
\end{array}\\
 & =\,\begin{array}{||c|}
1\rightarrow e_{R}\triangleright\text{pu}_{M^{\prime}}\\
r\times t\rightarrow\phi\big(\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}{}^{M}(t)\big)
\end{array}\quad.
\end{align*}

\end_inset

Rewrite the right-hand side:
\begin_inset Formula 
\begin{align*}
 & \psi\bef\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M^{\prime}}(e_{R})\\
r\times t\rightarrow\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\overline{\text{brun}}{}^{M^{\prime}}(t)
\end{array}\\
\text{definition of }\psi:\quad & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes\text{frun}\,(\phi)
\end{array}\,\bef\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M^{\prime}}(e_{R})\\
r\times t\rightarrow\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\overline{\text{brun}}{}^{M^{\prime}}(t)
\end{array}\\
\text{matrix composition}:\quad & =\,\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M^{\prime}}(e_{R})\\
r\times t\rightarrow\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\big(t\triangleright\gunderline{\text{frun}\,(\phi)\bef\overline{\text{brun}}{}^{M^{\prime}}}\big)
\end{array}\\
\text{inductive assumption}:\quad & =\,\begin{array}{||c|}
1\rightarrow\text{pu}_{M^{\prime}}(e_{R})\\
r\times t\rightarrow\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\big(t\triangleright\text{brun}^{M}\bef\phi\big)
\end{array}\quad.
\end{align*}

\end_inset

The remaining difference is in the last rows of the matrices:
\begin_inset Formula 
\[
\phi\big(\text{pu}_{M}(r)\oplus_{M}\overline{\text{brun}}{}^{M}(t)\big)\overset{?}{=}\text{pu}_{M^{\prime}}(r)\oplus_{M^{\prime}}\phi\big(t\triangleright\text{brun}^{M}\big)\quad.
\]

\end_inset

This equality will be proved if we prove the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law!of monoid composition
\end_layout

\end_inset

monadic naturality of 
\begin_inset Formula $\oplus_{M}$
\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-oplus-M-monad-monoid-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
\phi(p^{:M^{R}}\oplus_{M}q^{:M^{R}})=\phi(p)\oplus_{M^{\prime}}\phi(q)\quad.
\]

\end_inset

A proof is given by the following derivation:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\phi(p)\oplus_{M}\phi(q):\quad & (p\oplus_{M}q)\triangleright\phi=p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\bef\phi\\
\text{composition law of }\phi:\quad & =p\triangleright\phi\bef\text{flm}_{M^{\prime}}(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v\gunderline{)^{\uparrow M}\bef\phi})\\
\text{naturality law of }\phi:\quad & =\phi(p)\triangleright\text{flm}_{M^{\prime}}(u\rightarrow\phi(q)\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M^{\prime}})\\
\text{definition~(\ref{eq:definition-of-oplus-M-monad-monoid-1}) of }\oplus_{M}:\quad & =\phi(p)\oplus_{M}\phi(q)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We conclude this section with derivations of some properties that were used
 in the proofs above.
 
\end_layout

\begin_layout Standard
The next statement shows that 
\begin_inset Formula $M^{L^{A}}$
\end_inset

 is a monoid for any fixed type 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monoid-operation-comb-for-effectful-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monoid-operation-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given any monad 
\begin_inset Formula $M$
\end_inset

, define the functor 
\begin_inset Formula $L$
\end_inset

 recursively by:
\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}\quad.
\]

\end_inset

Denote 
\begin_inset Formula $\text{Nil}\triangleq1+\bbnum 0^{:A\times M^{L^{A}}}$
\end_inset

.
 Then the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) satisfies:
\begin_inset Formula 
\begin{align*}
\text{identity laws}:\quad & \text{comb}\,(\text{Nil}\triangleright\text{pu}_{M})(m^{:M^{L^{A}}})=m\quad,\quad\quad\text{comb}\,(m^{:M^{L^{A}}})(\text{Nil}\triangleright\text{pu}_{M})=m\quad,\\
\text{associativity law}:\quad & \text{comb}\,(x)\big(\text{comb}\,(y)(z)\big)=\text{comb}\,\big(\text{comb}\,(x)(y)\big)(z)\quad.
\end{align*}

\end_inset

These laws show that the type 
\begin_inset Formula $M^{L^{A}}$
\end_inset

 is a monoid with empty value 
\begin_inset Formula $\text{pu}_{M}(\text{Nil})$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
To verify the left identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }m:\quad & \text{comb}\,(\text{Nil}\triangleright\text{pu}_{M})(m^{:M^{L^{A}}})\\
 & =\text{Nil}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}\bigg(\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow m\\
A\times M^{L^{A}} & a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(m)\big)
\end{array}\,\bigg)\\
\text{identity law of }M:\quad & =\text{Nil}\triangleright\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & \gunderline{1\rightarrow m}\\
A\times M^{L^{A}} & a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(m)\big)
\end{array}\,=m\quad.
\end{align*}

\end_inset

To verify the right identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }m:\quad & \text{comb}\,(m^{:M^{L^{A}}})(\text{Nil}\triangleright\text{pu}_{M})\\
 & =m\triangleright\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
A\times M^{L^{A}} & a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\gunderline{\overline{\text{comb}}\,(p)(\text{Nil}\triangleright\text{pu}_{M})}\big)
\end{array}\,\bigg)\\
\text{inductive assumption}:\quad & =\,m\triangleright\text{flm}_{M}\bigg(\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
A\times M^{L^{A}} & a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times p\big)
\end{array}\,\bigg)\\
 & =m\triangleright\text{flm}_{M}\bigg(\,\begin{array}{||c|}
(1\rightarrow1+\bbnum 0)\bef\text{pu}_{M}\\
(a\times p\rightarrow\bbnum 0+a\times p\big)\bef\text{pu}_{M}
\end{array}\,\bigg)=m\triangleright\gunderline{\text{flm}_{M}(\gunderline{\text{id}\bef\text{pu}_{M}})}=m\quad.
\end{align*}

\end_inset

To verify the associativity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

, it is convenient to express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 through a helper function 
\begin_inset Formula $\xi$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{comb}\,(m)(n)\triangleq m\triangleright\text{flm}_{M}(n\triangleright\xi)=m\triangleright(n\triangleright\xi)^{\uparrow M}\bef\text{ftn}_{M}\quad,\label{eq:comb-defined-via-helper-function-xi}\\
\text{where }\xi\text{ is defined by}:\quad & n\triangleright\xi\triangleq\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow n\\
A\times M^{L^{A}} & a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0^{:\bbnum 1}+a\times\overline{\text{comb}}\,(p)(n)\big)
\end{array}\quad.\nonumber 
\end{align}

\end_inset

We then write the two sides of the associativity law.
 The left-hand side:
\begin_inset Formula 
\[
\text{comb}\,(x)\big(\text{comb}\,(y)(z)\big)=x\triangleright\,\begin{array}{||c|}
1\rightarrow\text{comb}\,(y)(z)\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\gunderline{\overline{\text{comb}}\,(p)(\text{comb}\,(y)(z))}\big)
\end{array}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

Use the inductive assumption to rewrite the last expression as:
\begin_inset Formula 
\[
x\triangleright\,\begin{array}{||c|}
1\rightarrow\text{comb}\,(y)(z)\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(\text{comb}\,(p)(y))(z)\big)
\end{array}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\]

\end_inset

The right-hand side:
\begin_inset Formula 
\begin{align*}
 & \text{comb}\,\big(\text{comb}\,(x)(y)\big)(z)=\text{comb}\,(x)(y)\triangleright(z\triangleright\xi)^{\uparrow M}\bef\text{ftn}_{M}=x\triangleright(y\triangleright\xi)^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef(z\triangleright\xi)^{\uparrow M}}\bef\text{ftn}_{M}\\
 & =x\triangleright(y\triangleright\xi)^{\uparrow M}\bef(z\triangleright\xi)^{\uparrow M\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}=x\triangleright\big((y\triangleright\xi)\bef(z\triangleright\xi)^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

Write out the expression 
\begin_inset Formula $(y\triangleright\xi)\bef(z\triangleright\xi)^{\uparrow M}\bef\text{ftn}_{M}$
\end_inset

 (having type 
\begin_inset Formula $\bbnum 1+A\times M^{L^{A}}\rightarrow M^{L^{A}}$
\end_inset

) separately:
\begin_inset Formula 
\begin{align*}
 & (y\triangleright\xi)\bef(z\triangleright\xi)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =\,\begin{array}{||c|}
1\rightarrow y\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(y)\big)
\end{array}\,\bef(z\triangleright\xi)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =\,\,\begin{array}{||c|}
1\rightarrow\gunderline{y\triangleright(z\triangleright\xi)^{\uparrow M}\bef\text{ftn}_{M}}\\
a\times p\rightarrow\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(y)\big)\triangleright\gunderline{\text{pu}_{M}}\bef(z\triangleright\xi)^{\uparrow M}\bef\gunderline{\text{ftn}_{M}}
\end{array}\\
 & =\,\begin{array}{||c|}
1\rightarrow\text{comb}\,(y)(z)\\
a\times p\rightarrow\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(y)\big)\triangleright(z\triangleright\xi)
\end{array}\quad.
\end{align*}

\end_inset

The difference between the two sides is only in the last rows of the matrices:
\begin_inset Formula 
\[
\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(\text{comb}\,(p)(y))(z)\big)\overset{?}{=}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(y)\big)\triangleright(z\triangleright\xi)\quad.
\]

\end_inset

It remains to simplify the right-hand side above and make it equal to the
 left-hand side:
\begin_inset Formula 
\begin{align*}
 & \big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(y)\big)\triangleright(z\triangleright\xi)\\
 & =\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(y)\big)\triangleright\,\begin{array}{||c|}
1\rightarrow z\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(z)\big)
\end{array}\\
 & =\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(\overline{\text{comb}}\,(p)(y))(z)\big)\quad.
\end{align*}

\end_inset

This completes the proof.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-distributive-law-of-comb-for-effectful-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-distributive-law-of-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) satisfies the distributive law
\begin_inset Index idx
status open

\begin_layout Plain Layout
distributive law!of 
\family typewriter
comb
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\big(\text{comb}\,(p^{:T^{T^{A}}})(q^{:T^{T^{A}}})\big)\triangleright\text{ftn}_{T}=\text{comb}\,(p\triangleright\text{ftn}_{T})(q\triangleright\text{ftn}_{T})\quad,
\]

\end_inset

where we denoted 
\begin_inset Formula $T^{A}\triangleq M^{L^{A}}$
\end_inset

 for brevity, and 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 is defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-flatten-via-prod-for-list-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Begin with the left-hand side of the distributive law and use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:comb-defined-via-helper-function-xi"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \big(\text{comb}\,(p)(q)\big)\triangleright\text{ftn}_{T}=p\triangleright\text{flm}_{M}(q\triangleright\xi)\triangleright\text{ftn}_{T}=p\triangleright\text{flm}_{M}(q\triangleright\xi)\bef\text{flm}_{M}(\text{prod})\\
\text{associativity of }\text{flm}_{M}:\quad & =p\triangleright\text{flm}_{M}((q\triangleright\xi)\bef\text{flm}_{M}(\text{prod}))\quad.
\end{align*}

\end_inset

Rewrite the right-hand side of the distributive law:
\begin_inset Formula 
\begin{align*}
 & \text{comb}\,(p\triangleright\text{ftn}_{T})(q\triangleright\text{ftn}_{T})=p\triangleright\gunderline{\text{ftn}_{T}}\triangleright\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\\
 & =p\triangleright\text{flm}_{M}(\text{prod})\bef\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\\
\text{associativity of }\text{flm}_{M}:\quad & =p\triangleright\text{flm}_{M}\big(\text{prod}\bef\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\big)\quad.
\end{align*}

\end_inset

It remains to prove the following equality between functions of type 
\begin_inset Formula $L^{T^{A}}\rightarrow T^{A}$
\end_inset

:
\begin_inset Formula 
\[
\text{prod}\bef\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\overset{?}{=}(q\triangleright\xi)\bef\text{flm}_{M}(\text{prod})\quad.
\]

\end_inset

Since we have no matrix representation for 
\begin_inset Formula $\text{flm}_{M}$
\end_inset

, it is inconvenient to use matrices at this step.
 Instead, we substitute an arbitrary value of type 
\begin_inset Formula $L^{T^{A}}\cong\bbnum 1+T^{A}\times T^{T^{A}}$
\end_inset

 into both sides of the equation above.
 A value of type 
\begin_inset Formula $L^{T^{A}}$
\end_inset

 has two cases, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 and 
\begin_inset Formula $h^{:T^{A}}\times t^{:T^{T^{A}}}$
\end_inset

.
 Substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 into the left-hand side:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{Nil}\triangleright\text{prod}}\bef\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)=\text{Nil}\triangleright\gunderline{\text{pu}_{M}\bef\text{flm}_{M}}(q\triangleright\text{ftn}_{T}\triangleright\xi)\\
\text{identity law of }M:\quad & =\text{Nil}\triangleright(q\triangleright\text{ftn}_{T}\triangleright\xi)\quad.
\end{align*}

\end_inset

Since:
\begin_inset Formula 
\[
\text{Nil}\triangleright(s\triangleright\xi)=\,\begin{array}{|cc|}
1 & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
1\rightarrow s\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(s)\big)
\end{array}\,=s\quad,
\]

\end_inset

we can simplify:
\begin_inset Formula 
\[
\text{Nil}\triangleright(q\triangleright\text{ftn}_{T}\triangleright\xi)=q\triangleright\text{ftn}_{T}\quad.
\]

\end_inset

Substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 into the right-hand side yields:
\begin_inset Formula 
\[
\gunderline{\text{Nil}\triangleright(q\triangleright\xi)}\triangleright\text{flm}_{M}(\text{prod})=q\triangleright\gunderline{\text{flm}_{M}(\text{prod})}=q\triangleright\text{ftn}_{T}\quad.
\]

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Standard
It remains to substitute a value of the form 
\begin_inset Formula $\bbnum 0+h^{:T^{A}}\times t^{:T^{T^{A}}}$
\end_inset

.
 For the left-hand side:
\begin_inset Formula 
\begin{align*}
 & (\bbnum 0+h\times t)\triangleright\text{prod}\bef\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\\
 & =(\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\text{flm}_{M}(\overline{\text{prod}}))
\end{array}\,\bef\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\\
\text{apply matrix}:\quad & =\big(\text{comb}\,(h)(t\triangleright\text{ftn}_{T})\big)\triangleright\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\quad.
\end{align*}

\end_inset

Substitute 
\begin_inset Formula $\bbnum 0+h\times t$
\end_inset

 into the right-hand side:
\begin_inset Formula 
\begin{align*}
 & (\bbnum 0+h\times t)\triangleright(q\triangleright\xi)\bef\text{flm}_{M}(\text{prod})\\
\text{definition of }c:\quad & =(\bbnum 0+h\times t)\triangleright\,\begin{array}{||c|}
1\rightarrow q\triangleright\text{flm}_{M}(\text{prod})\\
a\times p\rightarrow\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(q)\big)\triangleright\gunderline{\text{pu}_{M}\bef\text{flm}_{M}}(\text{prod})
\end{array}\\
\text{apply matrix function}:\quad & =\big(\bbnum 0+h\times\overline{\text{comb}}\,(t)(q)\big)\triangleright\text{prod}\\
\text{definition of }\text{prod}:\quad & =\big(\bbnum 0+h\times\overline{\text{comb}}\,(t)(q)\big)\triangleright\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\overline{\text{ftn}}_{T})
\end{array}\\
\text{apply matrix}:\quad & =\text{comb}\,(h)\big(\gunderline{(\overline{\text{comb}}\,(t)(q))\triangleright\overline{\text{ftn}}_{T}}\big)\\
\text{inductive assumption}:\quad & =\text{comb}\,(h)\big(\text{comb}\,(t\triangleright\text{ftn}_{T})(q\triangleright\text{ftn}_{T})\big)\\
\text{associativity law of }\text{comb}:\quad & =\gunderline{\text{comb}}\,\big(\text{comb}\,(h)((t\triangleright\text{ftn}_{T}))\big)(q\triangleright\text{ftn}_{T})\\
\text{definition~(\ref{eq:definition-of-comb-for-effectful-list}) of }\text{comb}:\quad & =\big(\text{comb}\,(h)((t\triangleright\text{ftn}_{T}))\big)\triangleright\text{flm}_{M}(q\triangleright\text{ftn}_{T}\triangleright\xi)\quad.
\end{align*}

\end_inset

The two sides are now equal.
 (The associativity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 was proved in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monoid-operation-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

.)
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monadic-naturality-of-comb-for-effectful-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-naturality-of-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:comb-defined-via-helper-function-xi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) satisfies the monadic naturality law with respect to the foreign monad
 
\begin_inset Formula $M$
\end_inset

: For any two monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $M^{\prime}$
\end_inset

 with a monad morphism 
\begin_inset Formula $\phi:M\leadsto M^{\prime}$
\end_inset

, we define 
\begin_inset Formula $\psi$
\end_inset

 (which depends on 
\begin_inset Formula $\phi$
\end_inset

) by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:list-monad-definition-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The law is then written as:
\begin_inset Formula 
\[
\big(\text{comb}\,(p^{:T^{A}})(q^{:T^{A}})\big)\triangleright\psi^{\uparrow M}\bef\phi=\text{comb}\,(p\triangleright\psi^{\uparrow M}\bef\phi)(q\triangleright\psi^{\uparrow M}\bef\phi)\quad.
\]

\end_inset

Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 must use the monad 
\begin_inset Formula $M^{\prime}$
\end_inset

 in the right-hand side of the law.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We write the left-hand side of the law:
\begin_inset Formula 
\begin{align*}
 & \text{comb}\,(p)(q)\triangleright\psi^{\uparrow M}\bef\phi=p\triangleright\text{flm}_{M}(q\triangleright\xi)\bef\gunderline{\psi^{\uparrow M}\bef\phi}\\
\text{naturality law of }\phi:\quad & =p\triangleright\gunderline{\text{flm}_{M}(q\triangleright\xi)\bef\phi}\bef\psi^{\uparrow M^{\prime}}\\
\text{composition law of }\phi:\quad & =p\triangleright\phi\bef\text{flm}_{M^{\prime}}\big((q\triangleright\xi)\bef\phi\big)\,\gunderline{\bef\psi^{\uparrow M^{\prime}}}\\
\text{naturality law of }\text{flm}_{M^{\prime}}:\quad & =p\triangleright\phi\bef\text{flm}_{M^{\prime}}\big((q\triangleright\xi)\bef\phi\bef\psi^{\uparrow M^{\prime}}\big)\quad.
\end{align*}

\end_inset

The right-hand side is rewritten as:
\begin_inset Formula 
\begin{align*}
 & \text{comb}\,(p\triangleright\psi^{\uparrow M}\bef\phi)(q\triangleright\psi^{\uparrow M}\bef\phi)=p\triangleright\gunderline{\psi^{\uparrow M}\bef\phi}\bef\text{flm}_{M^{\prime}}\big(q\triangleright\gunderline{\psi^{\uparrow M}\bef\phi}\bef\xi\big)\\
\text{naturality law of }\phi:\quad & =p\triangleright\phi\bef\gunderline{\psi^{\uparrow M^{\prime}}\bef\text{flm}_{M^{\prime}}}\big(q\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\bef\xi\big)\\
\text{naturality of }\text{flm}_{M^{\prime}}:\quad & =p\triangleright\phi\bef\text{flm}_{M^{\prime}}\big(\psi\bef(q\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\bef\xi)\big)\quad.
\end{align*}

\end_inset

The remaining difference between the two sides is the following equality:
\begin_inset Formula 
\[
(q\triangleright\xi)\bef\phi\bef\psi^{\uparrow M^{\prime}}\overset{?}{=}\psi\bef(q\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\bef\xi)\quad.
\]

\end_inset

This should hold for any 
\begin_inset Formula $q^{:T^{A}}$
\end_inset

.
 Write the two sides separately:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (q\triangleright\xi)\bef\phi\bef\psi^{\uparrow M^{\prime}}=\,\begin{array}{||c|}
1\rightarrow q\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\\
a\times p\rightarrow\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(q)\big)\triangleright\gunderline{\text{pu}_{M}\bef\phi\bef\psi^{\uparrow M^{\prime}}}
\end{array}\\
 & \quad=\,\begin{array}{||c|}
1\rightarrow q\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\\
a\times p\rightarrow\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(q)\big)\triangleright\psi\bef\text{pu}_{M^{\prime}}
\end{array}\quad,\\
\text{right-hand side}:\quad & \psi\bef(q\triangleright\phi\triangleright\psi^{\uparrow M^{\prime}}\triangleright\xi)\\
 & \quad=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\phi\bef\overline{\psi}^{\uparrow M^{\prime}})
\end{array}\,\bef\,\begin{array}{||c|}
1\rightarrow q\triangleright\phi\triangleright\psi^{\uparrow M^{\prime}}\\
a\times p\rightarrow\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(q\triangleright\phi\triangleright\psi^{\uparrow M^{\prime}})\big)\triangleright\text{pu}_{M^{\prime}}
\end{array}\\
 & \quad=\,\,\begin{array}{||c|}
1\rightarrow q\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\\
a\times p\rightarrow\big(\bbnum 0+a\times\overline{\text{comb}}\,(p\triangleright\phi\bef\overline{\psi}^{\uparrow M^{\prime}})(q\triangleright\phi\bef\psi^{\uparrow M^{\prime}})\big)\triangleright\text{pu}_{M^{\prime}}
\end{array}\quad.
\end{align*}

\end_inset

By the inductive assumption:
\begin_inset Formula 
\[
\overline{\text{comb}}\,(p\triangleright\phi\bef\overline{\psi}^{\uparrow M^{\prime}})(q\triangleright\phi\bef\psi^{\uparrow M^{\prime}})=\big(\text{comb}\,(p)(q)\big)\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\quad.
\]

\end_inset

So, the remaining difference between the two sides is:
\begin_inset Formula 
\[
\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(q)\big)\triangleright\psi\overset{?}{=}\bbnum 0+a\times\big(\text{comb}\,(p)(q)\big)\triangleright\phi\bef\psi^{\uparrow M^{\prime}}\quad.
\]

\end_inset

Using the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:list-monad-definition-of-psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $\psi$
\end_inset

, we find:
\begin_inset Formula 
\begin{align*}
 & \big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(q)\big)\triangleright\psi=\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(q)\big)\triangleright\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\boxtimes(\phi\bef\overline{\psi}^{\uparrow M^{\prime}})
\end{array}\\
 & =a\times\big(\overline{\text{comb}}\,(p)(q)\big)\triangleright\phi\bef\overline{\psi}^{\uparrow M^{\prime}}\quad,
\end{align*}

\end_inset

which equals the right-hand side above.
 This completes the proof.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-laws-of-prod-for-effectful-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-laws-of-prod-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-prod-for-list-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

) satisfies Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-laws-of-prod-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-prod-for-list-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
To verify the left identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

, note that 
\begin_inset Formula $\text{Nil}\triangleright\text{prod}=\text{pu}_{M}(\text{Nil})$
\end_inset

 and write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{pu}_{L}\bef\text{prod}\\
 & =\,\begin{array}{||cc|}
\bbnum 0 & a\rightarrow a\times(\text{Nil}\triangleright\text{pu}_{M})\end{array}\,\bef\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\overline{\text{prod}}^{\uparrow M}\bef\text{ftn}_{M})
\end{array}\\
 & =a^{:M^{L^{A}}}\rightarrow\text{comb}\,(a)(\text{Nil}\triangleright\gunderline{\text{pu}_{M}\bef\overline{\text{prod}}^{\uparrow M}}\bef\text{ftn}_{M})\\
 & =a\rightarrow\text{comb}\,(a)(\text{Nil}\triangleright\text{prod}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})=a\rightarrow\text{comb}\,(a)(\gunderline{\text{Nil}\triangleright\text{prod}})\\
 & =a\rightarrow\gunderline{\text{comb}\,(a)(\text{Nil}\triangleright\text{pu}_{M})}=a\rightarrow a=\text{id}\quad.
\end{align*}

\end_inset

In the last line, we used an identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

comb
\end_layout

\end_inset

 from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monoid-operation-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
To verify the right identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

, show that its left-hand side equals 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{T}^{\uparrow L}\bef\text{prod}=(\text{pu}_{L}\bef\text{pu}_{M})^{\uparrow L}\bef\text{prod}\\
 & =\,\begin{array}{|c||cc|}
 & \bbnum 1 & M^{L^{A}}\times M^{L^{M^{L^{A}}}}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times M^{L^{A}} & \bbnum 0 & \text{pu}_{T}\boxtimes\overline{\text{pu}}_{T}^{\uparrow L\uparrow M}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
M^{L^{A}}\times M^{L^{M^{L^{A}}}} & m\times p\rightarrow\text{comb}\,(m)(p\triangleright\overline{\text{prod}}^{\uparrow M}\bef\text{ftn}_{M})
\end{array}\\
 & =\,\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
A\times M^{L^{A}} & a\times m\rightarrow\text{comb}\,(a\triangleright\text{pu}_{T})(m\triangleright\overline{\text{pu}}_{T}^{\uparrow L\uparrow M}\bef\overline{\text{prod}}^{\uparrow M}\bef\text{ftn}_{M})
\end{array}\quad.
\end{align*}

\end_inset

Simplify the second row of the matrix separately:
\begin_inset Formula 
\begin{align*}
 & \text{comb}\,(a\triangleright\text{pu}_{T})(m\triangleright\gunderline{\overline{\text{pu}}_{T}^{\uparrow L\uparrow M}\bef\overline{\text{prod}}^{\uparrow M}}\bef\text{ftn}_{M})\\
\text{inductive assumption}:\quad & =\text{comb}\,(a\triangleright\text{pu}_{T})(m\triangleright\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}})=\text{comb}\,(a\triangleright\text{pu}_{T})(m)\\
\text{definition of }\text{comb}:\quad & =a\triangleright\text{pu}_{L}\bef\gunderline{\text{pu}_{M}\bef\text{flm}_{M}}\bigg(\,\begin{array}{||c|}
1\rightarrow m\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(m)\big)
\end{array}\,\bigg)\\
\text{identity law of }M:\quad & =\gunderline{a\triangleright\text{pu}_{L}}\triangleright\,\begin{array}{||c|}
1\rightarrow m\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(m)\big)
\end{array}\\
\text{definition of }\text{pu}_{L}:\quad & =\,\begin{array}{||cc|}
\bbnum 0 & a\times(\text{Nil}\triangleright\text{pu}_{M})\end{array}\,\triangleright\,\begin{array}{||c|}
1\rightarrow m\\
a\times p\rightarrow\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(m)\big)
\end{array}\\
\text{apply matrix}:\quad & =\text{pu}_{M}\big(\bbnum 0+a\times\overline{\text{comb}}\,(p)(\text{Nil}\triangleright\text{pu}_{M})\big)=\text{pu}_{M}(\bbnum 0+a\times m)\quad.
\end{align*}

\end_inset

So, we find that the code matrix for 
\begin_inset Formula $\text{pu}_{T}^{\uparrow L}\bef\text{prod}$
\end_inset

 is:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{T}^{\uparrow L}\bef\text{prod}=\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
A\times M^{L^{A}} & a\times m\rightarrow\text{pu}_{M}(\bbnum 0+a\times m)
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow\text{pu}_{M}(1+\bbnum 0)\\
A\times M^{L^{A}} & a\times m\rightarrow\text{pu}_{M}(\bbnum 0+a\times m)
\end{array}\\
 & =\,\begin{array}{|c||c|}
 & \bbnum 1+A\times M^{L^{A}}\\
\hline \bbnum 1 & 1\rightarrow(1+\bbnum 0)\\
A\times M^{L^{A}} & a\times m\rightarrow(\bbnum 0+a\times m)
\end{array}\,\bef\text{pu}_{M}=\text{id}\bef\text{pu}_{M}=\text{pu}_{M}\quad.
\end{align*}

\end_inset

This proves the right identity law.
\end_layout

\begin_layout Standard
To verify the associativity law, write its two sides separately.
 We will use the formula 
\begin_inset Formula $\text{ftn}_{T}=\text{prod}^{\uparrow M}\bef\text{ftn}_{M}$
\end_inset

 to make the derivation shorter, but we will not use any laws of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 in the derivation (since those laws will be established only after this
 proof is complete).
\end_layout

\begin_layout Standard
Some useful properties are:
\begin_inset Formula 
\begin{align*}
 & \text{Nil}\triangleright\text{prod}=\text{Nil}\triangleright\text{pu}_{M}\quad,\\
 & \text{pu}_{M}\bef\text{ftn}_{T}=\gunderline{\text{pu}_{M}\bef\text{prod}^{\uparrow M}}\bef\text{ftn}_{M}=\text{prod}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}=\text{prod}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Begin with the left-hand side of the associativity law:
\begin_inset Formula 
\begin{align*}
 & \text{prod}\bef\gunderline{\text{prod}^{\uparrow M}\bef\text{ftn}_{M}}=\text{prod}\bef\text{ftn}_{T}=\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\gunderline{\text{pu}_{M}\bef\text{ftn}_{T}}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\overline{\text{prod}}^{\uparrow M}\bef\text{ftn}_{M})\,\gunderline{\triangleright\text{ftn}_{T}}
\end{array}\\
 & =\,\begin{array}{||c|}
1\rightarrow\gunderline{\text{Nil}\triangleright\text{prod}}\\
m\times p\rightarrow\text{comb}\,(m\triangleright\text{ftn}_{T})(p\triangleright\gunderline{\overline{\text{prod}}^{\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{T})
\end{array}\\
 & =\,\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m\triangleright\text{ftn}_{T})(p\triangleright\overline{\text{ftn}}_{T}\bef\text{ftn}_{T})
\end{array}\quad.
\end{align*}

\end_inset

To transform the right-hand side of the associativity law, we need the lifting
 of 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 to 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\[
\text{prod}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{T}^{\uparrow L}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & T^{A}\times T^{T^{A}}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
T^{T^{A}}\times T^{T^{T^{A}}} & \bbnum 0 & h\times t\rightarrow(h\triangleright\text{ftn}_{T})\times(t\triangleright\text{ftn}_{T}^{\overline{\uparrow L}\uparrow M})
\end{array}\quad.
\]

\end_inset

Then the right-hand side is written as:
\begin_inset Formula 
\begin{align*}
 & \text{prod}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\bef\text{prod}=\text{ftn}_{T}^{\uparrow L}\bef\text{prod}\\
 & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow(h\triangleright\text{ftn}_{T})\times(t\triangleright\text{ftn}_{T}^{\overline{\uparrow L}\uparrow M})
\end{array}\,\bef\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
m\times p\rightarrow\text{comb}\,(m)(p\triangleright\overline{\text{ftn}}_{T})
\end{array}\\
 & =\,\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M}\\
h\times t\rightarrow\text{comb}\,(h\triangleright\text{ftn}_{T})(t\triangleright\text{ftn}_{T}^{\overline{\uparrow L}\uparrow M}\triangleright\overline{\text{ftn}}_{T})
\end{array}\quad.
\end{align*}

\end_inset

The two matrices differ only in the last rows.
 We rename 
\begin_inset Formula $m$
\end_inset

, 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $h$
\end_inset

, 
\begin_inset Formula $t$
\end_inset

 and get:
\begin_inset Formula 
\[
\text{comb}\,(h\triangleright\text{ftn}_{T})(t\triangleright\overline{\text{ftn}}_{T}\bef\text{ftn}_{T})\overset{?}{=}\text{comb}\,(h\triangleright\text{ftn}_{T})(t\triangleright\text{ftn}_{T}^{\overline{\uparrow L}\uparrow M}\triangleright\overline{\text{ftn}}_{T})\quad.
\]

\end_inset

The remaining difference is:
\begin_inset Formula 
\[
\overline{\text{ftn}}_{T}\bef\text{ftn}_{T}\overset{?}{=}\text{ftn}_{T}^{\overline{\uparrow L}\uparrow M}\bef\overline{\text{ftn}}_{T}\quad.
\]

\end_inset

This looks like the associativity law for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 applied to some recursive calls to 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 (note that 
\begin_inset Formula $f^{\uparrow L\uparrow M}=f^{\uparrow T}$
\end_inset

 by definition of 
\begin_inset Formula $T\triangleq M\circ L$
\end_inset

).
 However, here we may 
\emph on
not
\emph default
 assume that the associativity law holds for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 The only allowed inductive hypothesis is that the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-of-prod-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds when it involves any recursive calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

.
 So, we need to rewrite the above equation through 
\begin_inset Formula $\overline{\text{prod}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \overline{\text{ftn}}_{T}\bef\text{ftn}_{T}=\text{flm}_{M}(\overline{\text{prod}})\bef\text{flm}_{M}(\text{prod})\\
\text{associativity law of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}(\overline{\text{prod}}\bef\text{flm}_{M}(\text{prod}))\\
\text{right-hand side}:\quad & \overset{?}{=}\text{ftn}_{T}^{\overline{\uparrow L}\uparrow M}\bef\overline{\text{ftn}}_{T}=\text{ftn}_{T}^{\overline{\uparrow L}\uparrow M}\bef\text{flm}_{M}(\overline{\text{prod}})\\
\text{naturality law of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}(\text{ftn}_{T}^{\overline{\uparrow L}}\bef\overline{\text{prod}})=\text{flm}_{M}(\text{ftn}_{T}^{\overline{\uparrow L}}\bef\overline{\text{prod}})\quad.
\end{align*}

\end_inset

It remains to show that:
\begin_inset Formula 
\[
\overline{\text{prod}}\bef\text{flm}_{M}(\text{prod})=\overline{\text{prod}}\bef\text{prod}^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\text{ftn}_{T}^{\overline{\uparrow L}}\bef\overline{\text{prod}}=(\text{prod}^{\uparrow M}\bef\text{ftn}_{M})^{\uparrow L}\bef\overline{\text{prod}}\quad.
\]

\end_inset

This is equivalent to:
\begin_inset Formula 
\[
\overline{\text{prod}}\bef\text{prod}^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\text{prod}^{\uparrow M\uparrow L}\bef\text{ftn}_{M}^{\uparrow L}\bef\overline{\text{prod}}\quad,
\]

\end_inset

which holds by the inductive assumption.
 So, the associativity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 holds.
\end_layout

\begin_layout Standard
To verify the monadic naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

, begin with its left-hand side:
\begin_inset Formula 
\begin{align*}
 & \text{prod}_{M,L}\bef\psi^{\uparrow M}\bef\phi=\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\gunderline{\text{pu}_{M}\bef\psi^{\uparrow M}}\bef\phi\\
h\times t\rightarrow\text{comb}\,(h)(t\triangleright\overline{\text{ftn}}_{T})\triangleright\psi^{\uparrow M}\bef\phi
\end{array}\\
 & =\,\begin{array}{||c|}
1\rightarrow\gunderline{\text{Nil}\triangleright\psi}\bef\gunderline{\text{pu}_{M}\bef\phi}\\
h\times t\rightarrow\text{comb}\,(h)(t\triangleright\overline{\text{ftn}}_{T})\triangleright\psi^{\uparrow M}\bef\phi
\end{array}\,=\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M^{\prime}}\\
h\times t\rightarrow\text{comb}\,(h)(t\triangleright\overline{\text{ftn}}_{T})\triangleright\psi^{\uparrow M}\bef\phi
\end{array}\quad.
\end{align*}

\end_inset

For the right-hand side of the monadic naturality law, we simplify the expressio
n 
\begin_inset Formula $\psi\bef\text{prod}$
\end_inset

 separately:
\begin_inset Formula 
\begin{align*}
 & \psi\bef\text{prod}_{M^{\prime},L^{\prime}}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow h\times(t\triangleright\psi^{\uparrow M}\bef\phi)
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{\prime L^{\prime A}}\\
\hline \bbnum 1 & 1\rightarrow\text{Nil}\triangleright\text{pu}_{M^{\prime}}\\
M^{\prime L^{\prime A}}\times M^{\prime L^{\prime M^{\prime L^{\prime A}}}} & m\times p\rightarrow\text{comb}\,(m)(p\triangleright\overline{\text{ftn}}_{T^{\prime}})
\end{array}\\
 & =\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M^{\prime}}\\
h\times t\rightarrow\text{comb}\,(h)(t\triangleright\psi^{\uparrow M}\bef\phi\bef\overline{\text{ftn}}_{T^{\prime}})
\end{array}\quad.
\end{align*}

\end_inset

Now the right-hand side of the law can be written as:
\begin_inset Formula 
\begin{align*}
 & (\psi^{\uparrow M}\bef\phi)^{\uparrow L}\bef\psi\bef\text{prod}_{M^{\prime},L^{\prime}}\\
 & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow(h\triangleright\psi^{\uparrow M}\bef\phi)\times\big(t\triangleright(\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}\uparrow M}\big)
\end{array}\,\bef\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M^{\prime}}\\
h\times t\rightarrow\text{comb}\,(h)(t\triangleright\psi^{\uparrow M}\bef\phi\bef\overline{\text{ftn}}_{T^{\prime}})
\end{array}\\
 & =\,\,\begin{array}{||c|}
1\rightarrow\text{Nil}\triangleright\text{pu}_{M^{\prime}}\\
h\times t\rightarrow\text{comb}\,(h\triangleright\psi^{\uparrow M}\bef\phi)\big(t\triangleright(\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}\uparrow M}\bef\psi^{\uparrow M}\bef\phi\bef\overline{\text{ftn}}_{T^{\prime}}\big)
\end{array}\quad.
\end{align*}

\end_inset

The difference between the two sides is now only in the last rows of the
 matrices:
\begin_inset Formula 
\[
\text{comb}\,(h)(t\triangleright\overline{\text{ftn}}_{T})\triangleright\psi^{\uparrow M}\bef\phi\overset{?}{=}\text{comb}\,(h\triangleright\psi^{\uparrow M}\bef\phi)\big(t\triangleright(\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}\uparrow M}\bef\psi^{\uparrow M}\bef\phi\bef\overline{\text{ftn}}_{T^{\prime}}\big)\quad.
\]

\end_inset

By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-naturality-of-comb-for-effectful-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we have:
\begin_inset Formula 
\[
\text{comb}\,(h)(t\triangleright\overline{\text{ftn}}_{T})\triangleright\psi^{\uparrow M}\bef\phi=\text{comb}\,(h\triangleright\psi^{\uparrow M}\bef\phi)(t\triangleright\overline{\text{ftn}}_{T}\bef\psi^{\uparrow M}\bef\phi)\quad.
\]

\end_inset

The remaining difference between the two sides is:
\begin_inset Formula 
\[
(\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}\uparrow M}\bef\psi^{\uparrow M}\bef\phi\bef\overline{\text{ftn}}_{T^{\prime}}\overset{?}{=}\overline{\text{ftn}}_{T}\bef\psi^{\uparrow M}\bef\phi\quad.
\]

\end_inset

This is the monad morphism composition law for 
\begin_inset Formula $\text{frun}\,(\phi)\triangleq\psi^{\uparrow M}\bef\phi$
\end_inset

.
 However, the present proof must be completed without assuming that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 is a monad morphism (of type 
\begin_inset Formula $T\leadsto T^{\prime}$
\end_inset

).
\end_layout

\begin_layout Standard
So, we need to replace 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prod
\end_layout

\end_inset

 in both sides above:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}\uparrow M}\bef\psi^{\uparrow M}\bef\phi\bef\overline{\text{ftn}}_{T^{\prime}}=\gunderline{(\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}\uparrow M}\bef\psi^{\uparrow M}\bef\phi}\bef\text{flm}_{M^{\prime}}(\overline{\text{prod}})\\
\text{naturality law of }\phi:\quad & \quad=\phi\bef\big((\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}}\bef\psi\big)^{\uparrow M^{\prime}}\bef\text{flm}_{M^{\prime}}(\overline{\text{prod}})\\
\text{naturality law of }\text{flm}_{M}:\quad & \quad=\phi\bef\text{flm}_{M^{\prime}}((\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}}\bef\psi\bef\overline{\text{prod}})\quad,\\
\text{right-hand side}:\quad & \overline{\text{ftn}}_{T}\bef\psi^{\uparrow M}\bef\phi=\text{flm}_{M}(\overline{\text{prod}})\bef\psi^{\uparrow M}\bef\phi\\
\text{naturality law of }\text{flm}_{M}:\quad & \quad=\text{flm}_{M}(\overline{\text{prod}}\bef\psi^{\uparrow M})\bef\phi\\
\text{composition law of }\phi:\quad & \quad=\phi\bef\text{flm}_{M^{\prime}}(\overline{\text{prod}}\bef\psi^{\uparrow M}\bef\phi)\quad.
\end{align*}

\end_inset

It is clear that we need to use the inductive hypothesis to make progress.
 We adapt the inductive hypothesis to be used in the above equation:
\begin_inset Formula 
\begin{align*}
\text{inductive hypothesis}:\quad & \overline{\text{prod}}_{M,L}\bef\psi^{\uparrow M}\bef\phi=(\psi^{\uparrow M}\bef\phi)^{\uparrow L}\bef\psi\bef\overline{\text{prod}}_{M^{\prime},L^{\prime}}\quad,\\
\text{apply }\text{flm}_{M^{\prime}}\text{ to both sides}:\quad & \text{flm}_{M^{\prime}}\big(\overline{\text{prod}}_{M,L}\bef\psi^{\uparrow M}\bef\phi\big)=\text{flm}_{M^{\prime}}\big((\psi^{\uparrow M}\bef\phi)^{\uparrow L}\bef\psi\bef\overline{\text{prod}}_{M^{\prime},L^{\prime}}\big)\quad.
\end{align*}

\end_inset

Now we can rewrite both sides to obtain the following expressions:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}\uparrow M}\bef\psi^{\uparrow M}\bef\phi\bef\overline{\text{ftn}}_{T^{\prime}}=\phi\bef\text{flm}_{M^{\prime}}((\psi^{\uparrow M}\bef\phi)^{\overline{\uparrow L}}\bef\psi\bef\overline{\text{prod}})\\
\text{right-hand side}:\quad & \overset{?}{=}\overline{\text{ftn}}_{T}\bef\psi^{\uparrow M}\bef\phi=\phi\bef\text{flm}_{M^{\prime}}\big((\psi^{\uparrow M}\bef\phi)^{\uparrow L}\bef\psi\bef\overline{\text{prod}}_{M^{\prime},L^{\prime}}\big)\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Standard
This completes the proof of the laws for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's transformer.
\end_layout

\begin_layout Section
Incomplete transformers
\end_layout

\begin_layout Standard
A monad transformer that obeys the laws of a pointed and co-pointed functor
 in the category of monads (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Category-theoretic-properties-of-lifts-and-runners-functors-in-category-of-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

) will give the programmer full flexibility of combining monadic effects.
 We may call such transformers 
\series bold
complete
\series default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
monad transformers!completeness
\end_layout

\end_inset

 The monad transformers for linear monads, rigid monads, product monads,
 free pointed monads, and recursive (tree-like and list-like) monads are
 
\begin_inset Quotes eld
\end_inset

complete
\begin_inset Quotes erd
\end_inset

, as we have proved in the previous sections.
 We now consider certain monads (state, continuation, choice, and codensity)
 whose transformers are 
\begin_inset Quotes eld
\end_inset

incomplete
\begin_inset Quotes erd
\end_inset

.
 Those transformers are deficient in one or another way, which leads to
 certain limitations in the practical use of the affected transformers.
\end_layout

\begin_layout Subsection
Transformer for the state monad.
 Proofs
\end_layout

\begin_layout Standard
As shown in Examples
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-state-monad-composition-fails-with-option"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-state-monad-composition-fails-with-reader"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad does not compose with several other monads.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's transformer requires custom code (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monad-transformers-for-standard-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-state-monad-transformer"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-state-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The monad transformer (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

) for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad is:
\begin_inset Formula 
\[
T_{\text{State}}^{M,A}\triangleq S\rightarrow M^{A\times S}\quad.
\]

\end_inset

It satisfies all monad transformer laws except for the monad morphism laws
 for base runners.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We need to verify all the monad transformer laws (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

) separately.
\end_layout

\begin_layout Standard
As we will see below, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 transformer has one problem: its base runner violates the monad morphism
 composition law.
 The standard runner for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad:
\begin_inset Formula 
\[
\text{run}_{\text{State}}(s_{0}):\text{State}^{S,A}\rightarrow A\quad,\quad\quad\text{run}_{\text{State}}(s_{0})\triangleq p^{:S\rightarrow A\times S}\rightarrow p(s_{0})\triangleright\pi_{1}\quad,
\]

\end_inset

also violates that law because it discards the updated state, while the
 composition law requires to pass the updated state to the next monad value.
 For the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad, this problem can be solved by starting the runner from an updated
 intermediate state instead of the fixed initial state 
\begin_inset Formula $s_{0}$
\end_inset

.
 However, that trick cannot be used with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 transformer whose updated state is wrapped as 
\begin_inset Formula $M^{A\times S}$
\end_inset

 in an arbitrary foreign monad 
\begin_inset Formula $M$
\end_inset

.
 The monad 
\begin_inset Formula $M$
\end_inset

's effect could wrap several values, or no values at all.
 The 
\begin_inset Quotes eld
\end_inset

updated intermediate state
\begin_inset Quotes erd
\end_inset

 is not well-defined in that case.
\end_layout

\begin_layout Standard
For this reason, a monadic program involving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 cannot be refactored to run in several steps.
 To get correct results, the runner must be applied to the entire monadic
 program.
\end_layout

\begin_layout Standard
In the language of category theory, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 transformer fails to be a co-pointed functor in the category of monads.
 However, it is a pointed functor in that category: its lifts and the foreign
 runner satisfy all laws, as we will prove shortly.
\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
We need to show that 
\begin_inset Formula $T_{\text{State}}^{M}$
\end_inset

 is a lawful monad, assuming that 
\begin_inset Formula $M$
\end_inset

 is one.
 The monad methods for 
\begin_inset Formula $T_{\text{State}}^{M}$
\end_inset

 are defined by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pure-for-stateT-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:flatmap-for-stateT-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To verify the monad laws, it is faster to use the uncurried Kleisli formulation
, as we did for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-state-monad-is-lawful"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
The type signature for a 
\begin_inset Formula $T_{\text{State}}$
\end_inset

-Kleisli function is:
\begin_inset Formula 
\[
A\rightarrow T_{\text{State}}^{M,B}=A\rightarrow S\rightarrow M^{B\times S}\quad.
\]

\end_inset

When we uncurry this type signature, we get 
\begin_inset Formula $A\times S\rightarrow M^{B\times S}$
\end_inset

.
 It is easy to define the Kleisli composition (
\begin_inset Formula $\tilde{\diamond}_{_{T}}$
\end_inset

) for uncurried Kleisli functions because 
\begin_inset Formula $\tilde{\diamond}_{_{T}}$
\end_inset

 is the same as the 
\begin_inset Formula $M$
\end_inset

-Kleisli composition (
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

) except applied to types 
\begin_inset Formula $A\times S$
\end_inset

, 
\begin_inset Formula $B\times S$
\end_inset

, and 
\begin_inset Formula $C\times S$
\end_inset

:
\begin_inset Formula 
\[
f^{:A\times S\rightarrow M^{B\times S}}\,\tilde{\diamond}_{_{T}}\,g^{:B\times S\rightarrow M^{C\times S}}\triangleq f\diamond_{_{M}}g\quad.
\]

\end_inset

The proper 
\begin_inset Formula $T_{\text{State}}$
\end_inset

-Kleisli composition (
\begin_inset Formula $\diamond_{_{T}}$
\end_inset

) is then defined by uncurrying:
\begin_inset Formula 
\[
f^{:A\rightarrow S\rightarrow M^{B\times S}}\diamond_{_{T}}g^{:B\rightarrow S\rightarrow M^{C\times S}}\triangleq\text{uncu}\left(f\right)\diamond_{_{M}}\text{uncu}\left(g\right)\quad.
\]

\end_inset

The 
\series bold
uncurrying
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurrying
\end_layout

\end_inset

 transformation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncu
\end_layout

\end_inset

) defined as:
\begin_inset Formula 
\[
\text{uncu}:\left(A\rightarrow B\rightarrow C\right)\rightarrow A\times B\rightarrow C\quad,\quad\quad\text{uncu}\left(f\right)\triangleq a^{:A}\times b^{:B}\rightarrow f(a)(b)\quad,
\]

\end_inset

is an isomorphism with the inverse 
\series bold
currying
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
currying
\end_layout

\end_inset

 transformation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cu
\end_layout

\end_inset

) defined as:
\begin_inset Formula 
\[
\text{cu}:\left(A\times B\rightarrow C\right)\rightarrow A\rightarrow B\rightarrow C\quad,\quad\quad\text{cu}\left(f\right)\triangleq a^{:A}\rightarrow b^{:B}\rightarrow f(a\times b)\quad.
\]

\end_inset

So, it is sufficient to verify the monad laws in the uncurried Kleisli formulati
on.
 
\end_layout

\begin_layout Standard
To verify the identity laws, we need to define the uncurried 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method for 
\begin_inset Formula $T_{\text{State}}$
\end_inset

:
\begin_inset Formula 
\[
\tilde{\text{pu}}_{T}\triangleq\text{uncu}\,(\text{pu}_{T})=a^{:A}\times s^{:S}\rightarrow\text{pu}_{M}(a\times s)=\text{pu}_{M}^{A\times S}\quad.
\]

\end_inset

It is now quick to show that all three monad laws for 
\begin_inset Formula $T_{\text{State}}$
\end_inset

 hold due to 
\begin_inset Formula $M$
\end_inset

's monad laws:
\begin_inset Formula 
\begin{align*}
\tilde{\text{pu}}_{T}\,\tilde{\diamond}_{_{T}}\,f=\text{pu}_{M}\diamond_{_{M}}f=f\quad, & \quad\quad f\,\tilde{\diamond}_{_{T}}\,\tilde{\text{pu}}_{T}=f\diamond_{_{M}}\text{pu}_{M}=f\quad,\\
(f\,\tilde{\diamond}_{_{T}}\,g)\,\tilde{\diamond}_{_{T}}\,h=(f\diamond_{_{M}}g)\diamond_{_{M}}h & =f\diamond_{_{M}}(g\diamond_{_{M}}h)=f\,\tilde{\diamond}_{_{T}}\,(g\,\tilde{\diamond}_{_{T}}\,h)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $M=\text{Id}$
\end_inset

, the type of 
\begin_inset Formula $T_{\text{State}}^{M,A}$
\end_inset

 becomes equal to 
\begin_inset Formula $\text{State}^{A}$
\end_inset

, and the monad methods become equal to those of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Paragraph
Lifting laws
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 function is defined by:
\begin_inset Formula 
\begin{equation}
m^{:M^{A}}\triangleright\text{flift}\triangleq s^{:S}\rightarrow m\triangleright(a^{:A}\rightarrow a\times s)^{\uparrow M}\quad.\label{eq:state-transformer-def-of-flift}
\end{equation}

\end_inset

We need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is a monad morphism 
\begin_inset Formula $M\leadsto T_{\text{State}}^{M}$
\end_inset

.
 The identity law:
\begin_inset Formula 
\begin{align*}
 & a^{:A}\triangleright\text{pu}_{M}\triangleright\text{flift}=s\rightarrow a\triangleright\gunderline{\text{pu}_{M}\bef(a^{:A}\rightarrow a\times s)^{\uparrow M}}\\
\text{naturality law of }\text{pu}_{M}:\quad & =s\rightarrow a\triangleright(a^{:A}\rightarrow a\times s)\bef\text{pu}_{M}=s\rightarrow\text{pu}_{M}(a\times s)=\text{pu}_{T}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The composition law in terms of the Kleisli composition (
\begin_inset Formula $\diamond_{_{T}}$
\end_inset

) is:
\begin_inset Formula 
\[
(f^{:A\rightarrow M^{B}}\bef\text{flift})\diamond_{_{T}}\!(g^{:B\rightarrow M^{C}}\bef\text{flift})\overset{?}{=}(f\diamond_{_{M}}g)\bef\text{flift}\quad.
\]

\end_inset

In terms of 
\begin_inset Formula $\tilde{\diamond}_{_{T}}$
\end_inset

, this equation is reformulated as:
\begin_inset Formula 
\[
\text{uncu}\,(f^{:A\rightarrow M^{B}}\bef\text{flift})\,\tilde{\diamond}_{_{T}}\text{uncu}\,(g^{:B\rightarrow M^{C}}\bef\text{flift})\overset{?}{=}\text{uncu}\,\big((f\diamond_{_{M}}g)\bef\text{flift}\big)\quad.
\]

\end_inset

To show that this equation holds, begin by uncurrying the arguments of 
\begin_inset Formula $\diamond_{_{T}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{uncu}\,(f^{:A\rightarrow M^{B}}\bef\text{flift})=\text{uncu}\,(a^{:A}\rightarrow f(a)\triangleright\text{flift})=\text{uncu}\,\big(a^{:A}\rightarrow s^{:S}\rightarrow a\triangleright f\triangleright(b^{:B}\rightarrow b\times s)^{\uparrow M}\big)\\
 & =a\times s\rightarrow a\triangleright f\bef(b\rightarrow b\times s)^{\uparrow M}\quad.
\end{align*}

\end_inset

Using this formula, we get:
\begin_inset Formula 
\begin{align}
 & \text{uncu}\,(f^{:A\rightarrow M^{B}}\bef\text{flift})\,\tilde{\diamond}_{_{T}}\,\text{uncu}\,(g^{:B\rightarrow M^{C}}\bef\text{flift})=\text{uncu}\,(f^{:A\rightarrow M^{B}}\bef\text{flift})\diamond_{_{M}}\text{uncu}\,(g^{:B\rightarrow M^{C}}\bef\text{flift})\nonumber \\
 & =\big(a\times s\rightarrow a\triangleright f\bef(b\rightarrow b\times s)^{\uparrow M}\big)\diamond_{_{M}}\big(b\times s\rightarrow b\triangleright g\bef(c\rightarrow c\times s)^{\uparrow M}\big)\quad.\label{eq:uncurry-state-monad-derivation0}
\end{align}

\end_inset

We need somehow to move 
\begin_inset Formula $(b\rightarrow b\times s)^{\uparrow M}$
\end_inset

 to the right of 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

.
 However, the naturality law of 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

 cannot be used because 
\begin_inset Formula $(b\rightarrow b\times s)^{\uparrow M}$
\end_inset

 contains the variable 
\begin_inset Formula $s$
\end_inset

, which is bound in the scope of the left argument of 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

.
 To proceed, we apply the function in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:uncurry-state-monad-derivation0"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary value 
\begin_inset Formula $a\times s$
\end_inset

.
 This will enable us to move the rest of the expression (
\begin_inset Formula $\diamond_{_{M}}...$
\end_inset

) into the scope of the left argument of 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \left(a\times s\right)\triangleright\big(a\times s\rightarrow a\triangleright f\bef(b\rightarrow b\times s)^{\uparrow M}\big)\diamond_{_{M}}...\\
 & =\left(a\times s\right)\triangleright\big(a\times s\rightarrow a\triangleright f\bef(b\rightarrow b\times s)^{\uparrow M}\big)\bef\text{flm}_{M}(...)\\
 & =a\triangleright f\bef(b\rightarrow b\times s)^{\uparrow M}\bef\text{flm}_{M}(...)=a\triangleright f\bef(b\rightarrow b\times s)^{\uparrow M}\diamond_{_{M}}...
\end{align*}

\end_inset

This trick allows us to complete the derivation:
\begin_inset Formula 
\begin{align*}
 & a\triangleright f\bef(b\rightarrow b\times s)^{\uparrow M}\diamond_{_{M}}\big(b\times s\rightarrow b\triangleright g\bef(c\rightarrow c\times s)^{\uparrow M}\big)\\
\text{naturality law of }\diamond_{_{M}}:\quad & =a\triangleright f\diamond_{_{M}}(b\rightarrow\gunderline{b\times s)\bef\big(b\times s}\rightarrow b\triangleright g\bef(c\rightarrow c\times s)^{\uparrow M}\big)\\
\text{compute composition}:\quad & =a\triangleright f\diamond_{_{M}}\big(\gunderline{b\rightarrow b\,\triangleright}\,g\bef(c\rightarrow c\times s)^{\uparrow M}\big)\\
\triangleright\text{-notation}:\quad & =a\triangleright f\diamond_{_{M}}(g\bef\gunderline{(c\rightarrow c\times s)^{\uparrow M}})\\
\text{naturality law of }\diamond_{_{M}}:\quad & =a\triangleright(f\diamond_{_{M}}g)\bef(c\rightarrow c\times s)^{\uparrow M}=\left(a\times s\right)\triangleright\text{uncu}\,\big((f\diamond_{_{M}}g)\bef\text{flift}\big)\quad.
\end{align*}

\end_inset

 
\end_layout

\begin_layout Paragraph
Foreign runner laws
\end_layout

\begin_layout Standard
The foreign runner (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

) is defined by:
\begin_inset Formula 
\[
\text{frun}\,(\phi^{:M\leadsto N})\triangleq p^{:S\rightarrow M^{A\times S}}\rightarrow\gunderline{s^{:S}\rightarrow s\,\triangleright}\,p\triangleright\phi=p^{:S\rightarrow M^{A\times S}}\rightarrow p\bef\phi\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
First, we need to prove that 
\begin_inset Formula $\text{frun}\left(\phi\right)$
\end_inset

 is a monad morphism of type 
\begin_inset Formula $T_{\text{State}}^{M}\leadsto T_{\text{State}}^{N}$
\end_inset

.
 For convenience, denote 
\begin_inset Formula $P\triangleq T_{\text{State}}^{M}$
\end_inset

 and 
\begin_inset Formula $Q\triangleq T_{\text{State}}^{N}$
\end_inset

.
 To verify the identity law:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{P}\bef\text{frun}\,(\phi^{:M\leadsto N})=(a^{:A}\rightarrow s^{:S}\rightarrow(a\times s)\triangleright\text{pu}_{M})\bef(p\rightarrow p\bef\phi)\\
\text{compute composition}:\quad & =a\rightarrow s\rightarrow(a\times s)\triangleright\gunderline{\text{pu}_{M}\bef\phi}\\
\text{identity law of }\phi:\quad & =a\rightarrow s\rightarrow(a\times s)\triangleright\text{pu}_{N}=\text{pu}_{Q}\quad.
\end{align*}

\end_inset

The composition law is easier to verify in the uncurried Kleisli formulation.
 For brevity, denote 
\begin_inset Formula $r\triangleq\text{frun}\left(\phi\right)$
\end_inset

; this is a monad morphism of type 
\begin_inset Formula $P\leadsto Q$
\end_inset

.
 We need to show that:
\begin_inset Formula 
\[
\big(f^{:A\rightarrow P^{B}}\bef r\big)\diamond_{_{Q}}(g^{:B\rightarrow P^{C}}\bef r)\overset{?}{=}(f\diamond_{_{P}}g)\bef r\quad.
\]

\end_inset

Express this through uncurried functions and the operations 
\begin_inset Formula $\diamond_{_{P}}$
\end_inset

 and 
\begin_inset Formula $\tilde{\diamond}_{_{Q}}$
\end_inset

:
\begin_inset Formula 
\[
\text{uncu}\,\big(f^{:A\rightarrow P^{B}}\bef r\big)\,\tilde{\diamond}_{_{Q}}\,\text{uncu}\,(g^{:B\rightarrow P^{C}}\bef r)\overset{?}{=}\text{uncu}\,\big((f\diamond_{_{P}}g)\bef r\big)\quad.
\]

\end_inset

Uncurrying a function composition such as 
\begin_inset Formula $f\bef r$
\end_inset

 works like this:
\begin_inset Formula 
\begin{align}
 & \text{uncu}\,\big(f^{:A\rightarrow S\rightarrow M^{B\times S}}\bef r^{:P^{B}\leadsto Q^{B}}\big)=a^{:A}\times s^{:S}\rightarrow s\triangleright(\gunderline{a\triangleright f\bef r})=a^{:A}\times s^{:S}\rightarrow s\triangleright(f(a)\triangleright\gunderline r)\nonumber \\
\text{definition of }r:\quad & =a\times s\rightarrow s\triangleright(\gunderline{f(a)\triangleright(p\rightarrow p\bef\phi)})=a\times s\rightarrow s\triangleright f(a)\bef\phi\nonumber \\
 & =\big(a\times s\rightarrow s\triangleright f(a)\big)\bef\phi=\text{uncu}\,(f)\bef\phi\quad.\label{eq:uncurry-state-composition-derivation1}
\end{align}

\end_inset

The right-hand side of the composition law then becomes:
\begin_inset Formula 
\[
\text{uncu}\,\big((f\diamond_{_{P}}g)\bef r\big)=\text{uncu}\,(f\diamond_{_{P}}g)\bef\phi=\big(\text{uncu}\left(f\right)\diamond_{_{M}}\text{uncu}\left(g\right)\big)\bef\phi\quad.
\]

\end_inset

We can now proceed to simplify the left-hand side of the composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{uncu}\,\big((f\diamond_{_{P}}g)\bef r\big):\quad & \gunderline{\text{uncu}\,\big(f^{:A\rightarrow P^{B}}\bef r\big)}\,\tilde{\diamond}_{_{Q}}\,\gunderline{\text{uncu}\,(g^{:B\rightarrow P^{C}}\bef r)}\\
\text{use Eq.~(\ref{eq:uncurry-state-composition-derivation1})}:\quad & =\big(\text{uncu}\left(f\right)\bef\phi\big)\,\gunderline{\tilde{\diamond}_{_{Q}}}\,\big(\text{uncu}\left(g\right)\bef\phi\big)\\
\text{definition of }\tilde{\diamond}_{_{Q}}:\quad & =\big(\text{uncu}\left(f\right)\bef\phi\big)\diamond_{_{N}}\big(\text{uncu}\left(g\right)\bef\phi\big)\\
\text{composition law of }\phi:\quad & =\big(\text{uncu}\left(f\right)\diamond_{_{M}}\text{uncu}\left(g\right)\big)\bef\phi=\text{uncu}\,\big((f\diamond_{_{P}}g)\bef r\big)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset Formula $\text{frun}\,(\phi^{:M\leadsto N})$
\end_inset

 satisfies the functor laws with respect to the monad parameters 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

.
 The functor identity law:
\begin_inset Formula 
\[
\text{frun}\,(\text{id}^{:M\leadsto M})=p\rightarrow p\bef\text{id}=p\rightarrow p=\text{id}\quad.
\]

\end_inset

The functor composition law:
\begin_inset Formula 
\[
\text{frun}\,(\phi^{:L\leadsto M})\bef\text{frun}\,(\chi^{:M\leadsto N})=(p\rightarrow p\bef\phi)\bef(q\rightarrow q\bef\chi)=p\rightarrow p\bef\phi\bef\chi=\text{frun}\,(\phi\bef\chi)\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
Base runner laws
\end_layout

\begin_layout Standard
The base runner is parameterized by an initial state value 
\begin_inset Formula $s_{0}$
\end_inset

:
\begin_inset Formula 
\[
\text{brun}\,(s_{0})\triangleq p^{:S\rightarrow M^{A\times S}}\rightarrow p(s_{0})\triangleright\pi_{1}^{\uparrow M}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We will check the laws for a fixed 
\begin_inset Formula $s_{0}$
\end_inset

.
 The nondegeneracy law holds:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }m:\quad & m\triangleright\text{flift}\triangleright\text{brun}\,(s_{0})=m\triangleright\text{flift}\triangleright(p\rightarrow p(s_{0})\triangleright\pi_{1}^{\uparrow M})=s_{0}\triangleright(\gunderline{m\triangleright\text{flift}})\triangleright\pi_{1}^{\uparrow M}\\
\text{use Eq.~(\ref{eq:state-transformer-def-of-flift})}:\quad & =m\triangleright(a\rightarrow a\times s_{0})^{\uparrow M}\triangleright\pi_{1}^{\uparrow M}=m\triangleright(a\rightarrow a)=m\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We now turn to the monadic morphism laws.
 The identity law holds:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{P}\bef\text{brun}\,(s_{0})=\big(a\rightarrow s\rightarrow(a\times s)\triangleright\text{pu}_{M}\big)\bef(p\rightarrow p(s_{0})\triangleright\pi_{1}^{\uparrow M})\\
\text{compute composition}:\quad & =a\rightarrow(a\times s_{0})\triangleright\text{pu}_{M}\triangleright\pi_{1}^{\uparrow M}=a\rightarrow(a\times s_{0})\triangleright\gunderline{\text{pu}_{M}\bef\pi_{1}^{\uparrow M}}\\
\text{naturality law of }\text{pu}_{M}:\quad & =a\rightarrow(a\times s_{0})\triangleright\pi_{1}\bef\text{pu}_{M}=a\rightarrow a\triangleright\text{pu}_{M}=\text{pu}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The composition law is quicker to work with in the Kleisli formulation:
 
\begin_inset Formula 
\[
\big(f^{:A\rightarrow S\rightarrow M^{B\times S}}\bef\text{brun}\,(s_{0})\big)\diamond_{_{M}}\big(g^{:B\rightarrow S\rightarrow M^{C\times S}}\bef\text{brun}\,(s_{0})\big)\overset{?}{=}(f\diamond_{_{P}}g)\bef\text{brun}\,(s_{0})\quad.
\]

\end_inset

Since it is easier to define 
\begin_inset Formula $\diamond_{_{P}}$
\end_inset

 in terms of the uncurried Kleisli functions, let us express the composition
 
\begin_inset Formula $f\bef\text{brun}\,(s_{0})$
\end_inset

 in terms of the uncurried version of 
\begin_inset Formula $f$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & f\bef\text{brun}\,(s_{0})=a\rightarrow a\triangleright f\triangleright(p\rightarrow p(s_{0})\triangleright\pi_{1}^{\uparrow M})=a\rightarrow f(a)(s_{0})\triangleright\pi_{1}^{\uparrow M}\nonumber \\
 & =a\rightarrow(a\times s_{0})\triangleright\text{uncu}\,(f)\bef\pi_{1}^{\uparrow M}=(a\rightarrow a\times s_{0})\bef\text{uncu}\,(f)\bef\pi_{1}^{\uparrow M}\quad.\label{eq:state-transformer-derivation2}
\end{align}

\end_inset

We can now write the left-hand side of the composition law as:
\begin_inset Formula 
\begin{align*}
 & \big(f\bef\text{brun}\,(s_{0})\big)\diamond_{_{M}}\big(g\bef\text{brun}\,(s_{0})\big)=\big((a\rightarrow a\times s_{0})\bef\text{uncu}\,(f)\bef\gunderline{\pi_{1}^{\uparrow M}\big)\,\diamond_{_{M}}}\big(g\bef\text{brun}\,(s_{0})\big)\\
\text{naturality of }\diamond_{_{M}}:\quad & =(a\rightarrow a\times s_{0})\bef\text{uncu}\,(f)\diamond_{_{M}}\big(\pi_{1}\bef g\bef\text{brun}\,(s_{0})\big)\\
\text{use Eq.~(\ref{eq:state-transformer-derivation2})}:\quad & =(a\rightarrow a\times s_{0})\bef\text{uncu}\,(f)\diamond_{_{M}}\big(\pi_{1}\bef(b\rightarrow b\times s_{0})\bef\text{uncu}\,(g)\bef\pi_{1}^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

The right-hand side of the law is:
\begin_inset Formula 
\begin{align*}
 & (f\diamond_{_{P}}g)\bef\text{brun}\,(s_{0})=(a\rightarrow a\times s_{0})\bef\text{uncu}\,(f\diamond_{_{P}}g)\bef\pi_{1}^{\uparrow M}\\
\text{definition of }\diamond_{_{P}}:\quad & =(a\rightarrow a\times s_{0})\bef\big(\text{uncu}\,(f)\diamond_{_{M}}\text{uncu}\,(g)\gunderline{\big)\bef\pi_{1}^{\uparrow M}}\\
\text{right naturality law of }\diamond_{_{M}}:\quad & =(a\rightarrow a\times s_{0})\bef\text{uncu}\,(f)\diamond_{_{M}}\big(\text{uncu}\,(g)\bef\pi_{1}^{\uparrow M}\big)\quad.
\end{align*}

\end_inset

We find that the two sides of the law are 
\emph on
not
\emph default
 equal.
 The difference is the presence of a function 
\begin_inset Formula $\pi_{1}\bef(b\rightarrow b\times s_{0})$
\end_inset

 of type 
\begin_inset Formula $B\times S\rightarrow B\times S$
\end_inset

.
 That function replaces the updated state by the fixed initial state 
\begin_inset Formula $s_{0}$
\end_inset

 before applying the uncurried function 
\begin_inset Formula $g$
\end_inset

.
 This replacement erases the updated state, which leads to an incorrect
 composition of effects in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StateT
\end_layout

\end_inset

 monad.
\end_layout

\begin_layout Standard
If we set 
\begin_inset Formula $M=\text{Id}$
\end_inset

, we will obtain the same violation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's runner.
\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
To verify the monadic naturality of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

, apply to an arbitrary 
\begin_inset Formula $m^{:M^{A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }m\triangleright\phi\triangleright\text{flift}^{N}:\quad & m\triangleright\text{flift}^{M}\triangleright\text{frun}\left(\phi\right)=m\triangleright\text{flift}^{M}\triangleright(p\rightarrow p\bef\phi)=(m\triangleright\text{flift}^{M})\bef\phi\\
\text{use Eq.~(\ref{eq:state-transformer-def-of-flift})}:\quad & =\big(s\rightarrow m\triangleright(a\rightarrow a\times s)^{\uparrow M}\big)\bef\phi=s\rightarrow m\triangleright\gunderline{(a\rightarrow a\times s)^{\uparrow M}\bef\phi}\\
\text{naturality law of }\phi:\quad & =s\rightarrow m\triangleright\phi\bef(a\rightarrow a\times s)^{\uparrow N}=m\triangleright\phi\triangleright\text{flift}^{N}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the monadic naturality of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

brun
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{brun}\,(s_{0})\bef\phi:\quad & \text{frun}\left(\phi\right)\bef\text{brun}\,(s_{0})=(p\rightarrow p\bef\phi)\bef(p\rightarrow s_{0}\triangleright p\bef\pi_{1}^{\uparrow N})\\
\text{compute composition}:\quad & =p\rightarrow s_{0}\triangleright p\bef\gunderline{\phi\bef\pi_{1}^{\uparrow N}}=\gunderline{p\rightarrow s_{0}\triangleright p\bef\pi_{1}^{\uparrow M}}\bef\phi=\text{brun}\,(s_{0})\bef\phi\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Transformer for the continuation monad.
 Proofs
\end_layout

\begin_layout Standard
The continuation monad transformer's type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT[R, M[_], *]
\end_layout

\end_inset

 is defined by:
\begin_inset Formula 
\[
T_{\text{Cont}}^{M,A}\triangleq(A\rightarrow M^{R})\rightarrow M^{R}\quad.
\]

\end_inset

Unlike most other monad transformers, 
\begin_inset Formula $T_{\text{Cont}}$
\end_inset

 is not covariant in the foreign monad 
\begin_inset Formula $M$
\end_inset

: the type 
\begin_inset Formula $T_{\text{Cont}}^{M,A}$
\end_inset

 contains 
\begin_inset Formula $M$
\end_inset

 both in covariant and contravariant positions.
 (In the language of categories, 
\begin_inset Formula $T_{\text{Cont}}$
\end_inset

 is not a functor in the category of monads.) As a result, we cannot define
 the foreign runner or the base lift functions.
 This limits the usability of the continuation monad transformer.
 
\end_layout

\begin_layout Standard
Another limitation comes from the fact that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

 monad does not have a fully parametric runner of type 
\begin_inset Formula $\forall A.\,\text{Cont}^{R,A}\rightarrow A$
\end_inset

.
 The derivation techniques developed in this book apply only to fully parametric
 code.
 The runners constructed in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-continuation-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are not fully parametric and will terminate only for values of type 
\begin_inset Formula $\text{Cont}^{R,A}$
\end_inset

 that eventually call their callbacks (of type 
\begin_inset Formula $A\rightarrow R$
\end_inset

).
 Accordingly, the transformer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT
\end_layout

\end_inset

 does not have fully parametric base runners, and we will not verify their
 laws.
 Nevertheless, we will prove that the remaining laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ContT
\end_layout

\end_inset

 hold.
\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
The transformed monad 
\begin_inset Formula $T_{\text{Cont}}^{M}$
\end_inset

 differs from the continuation monad 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

 only in the type of the result (
\begin_inset Formula $R$
\end_inset

), replacing 
\begin_inset Formula $\left(A\rightarrow R\right)\rightarrow R$
\end_inset

 by 
\begin_inset Formula $(A\rightarrow M^{R})\rightarrow M^{R}$
\end_inset

.
 The monad's methods work the same way for all result types, so 
\begin_inset Formula $T_{\text{Cont}}^{M}$
\end_inset

 is a monad for all monads 
\begin_inset Formula $M$
\end_inset

.
 (This would remain true even if the type constructor 
\begin_inset Formula $M$
\end_inset

 were not a functor!)
\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
If we set 
\begin_inset Formula $M=\text{Id}$
\end_inset

, the type of 
\begin_inset Formula $T_{\text{Cont}}^{M,A}$
\end_inset

 is equivalent to the base monad, 
\begin_inset Formula $\left(A\rightarrow R\right)\rightarrow R$
\end_inset

.
\end_layout

\begin_layout Paragraph
Lifting laws
\end_layout

\begin_layout Standard
The foreign lift function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

) is defined by:
\begin_inset Formula 
\[
\text{flift}:M^{A}\rightarrow(A\rightarrow M^{R})\rightarrow M^{R}\quad,\quad\quad\text{flift}\triangleq\text{flatMap}_{M}=m^{:M^{A}}\rightarrow f^{:A\rightarrow M^{R}}\rightarrow m\triangleright\text{flm}_{M}(f)\quad.
\]

\end_inset

To verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is a monad morphism, we use the flipped Kleisli formulation for 
\begin_inset Formula $T_{\text{Cont}}$
\end_inset

.
 In that formulation, Kleisli functions of type 
\begin_inset Formula $A\rightarrow T_{\text{Cont}}^{M,B}=A\rightarrow(B\rightarrow M^{R})\rightarrow M^{R}$
\end_inset

 are flipped into the type signature 
\begin_inset Formula $(B\rightarrow M^{R})\rightarrow A\rightarrow M^{R}$
\end_inset

.
 For the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

 monad, the flipped Kleisli composition is equal to the ordinary 
\emph on
backward
\emph default
 function composition (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-continuation-monad-is-lawful"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{equation}
f^{:(B\rightarrow M^{R})\rightarrow A\rightarrow M^{R}}\,\tilde{\diamond}_{_{T}}\,g^{:(C\rightarrow M^{R})\rightarrow B\rightarrow M^{R}}=(g\bef f)^{:(C\rightarrow M^{R})\rightarrow A\rightarrow M^{R}}\quad.\label{eq:continuation-transformer-derivation1}
\end{equation}

\end_inset

Let us also compute the result of flipping a lifted 
\begin_inset Formula $M$
\end_inset

-Kleisli function: 
\begin_inset Formula 
\begin{equation}
\text{flip}\,(f^{:A\rightarrow M^{B}}\bef\text{flift})=p^{:B\rightarrow M^{R}}\rightarrow a^{:A}\rightarrow f(a)\triangleright\text{flm}_{M}(p)=p\rightarrow f\bef\text{flm}_{M}(p)=p\rightarrow f\diamond_{_{M}}p\quad.\label{eq:continuation-transformer-flip-derivation2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is now easy to verify.
 The flipped 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method for 
\begin_inset Formula $T_{\text{Cont}}$
\end_inset

 is:
\begin_inset Formula 
\[
\tilde{\text{pu}}_{T}:(A\rightarrow M^{R})\rightarrow A\rightarrow M^{R}\quad,\quad\quad\tilde{\text{pu}}_{T}=\text{id}^{A\rightarrow M^{R}}\quad.
\]

\end_inset

To show that the law holds, we write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\tilde{\text{pu}}_{T}:\quad & \text{flip}\,(\text{pu}_{M}\bef\text{flift})=p\rightarrow\gunderline{\text{pu}_{M}\,\diamond_{_{M}}}p=p\rightarrow p=\text{id}=\tilde{\text{pu}}_{T}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The composition law in the ordinary Kleisli formulation is:
\begin_inset Formula 
\[
\big(f^{:A\rightarrow M^{B}}\bef\text{flift}\big)\diamond_{_{T}}\big(g^{:B\rightarrow M^{C}}\bef\text{flift}\big)\overset{?}{=}(f\diamond_{_{M}}g)\bef\text{flift}\quad.
\]

\end_inset

To transform the composition law to the flipped Kleisli formulation, we
 write:
\begin_inset Formula 
\[
\text{flip}\,(f\bef\text{flift})\,\tilde{\diamond}_{_{T}}\,\text{flip}\,(g\bef\text{flift})\overset{?}{=}\text{flip}\,\big((f\diamond_{_{M}}g)\bef\text{flift}\big)\quad.
\]

\end_inset

We complete the proof by using Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:uncurry-state-composition-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:state-transformer-derivation2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the associativity of 
\begin_inset Formula $\diamond_{_{M}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{flip}\,(f\bef\text{flift})\,\tilde{\diamond}_{_{T}}\,\text{flip}\,(g\bef\text{flift})=(q\rightarrow g\diamond_{_{M}}q)\bef(p\rightarrow f\diamond_{_{M}}p)=q\rightarrow\gunderline{f\diamond_{_{M}}(g\diamond_{_{M}}q)}\\
 & =q\rightarrow(f\diamond_{_{M}}g)\diamond_{_{M}}q=\text{flip}\,\big((f\diamond_{_{M}}g)\bef\text{flift}\big)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Transformer for the generalized 
\family typewriter
Search
\family default
 monad.
 Proofs
\begin_inset CommandInset label
LatexCommand label
name "subsec:Transformer-for-the-generalized-search-monad"

\end_inset


\end_layout

\begin_layout Standard
The generalized
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!generalized 
\family typewriter
Search
\family default
 monad
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad is defined, for a fixed monad 
\begin_inset Formula $L$
\end_inset

 and a fixed type 
\begin_inset Formula $Q$
\end_inset

, by:
\begin_inset Formula 
\[
\text{Search}^{L,Q,A}\triangleq(A\rightarrow L^{Q})\rightarrow L^{A}\quad.
\]

\end_inset

The ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad is obtained with 
\begin_inset Formula $L\triangleq\text{Opt}$
\end_inset

 and 
\begin_inset Formula $Q\triangleq\bbnum 1$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-generalized-search-monad"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-generalized-search-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The transformer type for the generalized 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad is given by:
\begin_inset Formula 
\[
T_{\text{Search}}^{M,A}\triangleq(A\rightarrow T_{L}^{M,Q})\rightarrow T_{L}^{M,A}\quad,
\]

\end_inset

where 
\begin_inset Formula $L$
\end_inset

 is any fixed monad and 
\begin_inset Formula $T_{L}$
\end_inset

 is the monad 
\begin_inset Formula $L$
\end_inset

's transformer.
 Like the continuation monad, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad's transformer has no base lift, foreign runner, or base runner functions.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We assume that 
\begin_inset Formula $T_{L}$
\end_inset

 already satisfies all the necessary transformer laws.
\end_layout

\begin_layout Paragraph
Monad laws
\end_layout

\begin_layout Standard
The monad laws hold for 
\begin_inset Formula $\text{Search}^{L,Q,A}$
\end_inset

 due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-construction-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we use the 
\begin_inset Formula $L$
\end_inset

-filterable contrafunctor 
\begin_inset Formula $H^{A}\triangleq A\rightarrow L^{Q}$
\end_inset

 (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-examples-of-filterable-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Similarly, we find that the monad laws hold for 
\begin_inset Formula $T_{\text{Search}}^{M,A}$
\end_inset

 if we use the 
\begin_inset Formula $T_{L}^{M}$
\end_inset

-filterable contrafunctor 
\begin_inset Formula $H^{A}\triangleq A\rightarrow T_{L}^{M,Q}$
\end_inset

, where we assume that 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 is a lawful monad.
 We will use this definition of 
\begin_inset Formula $H^{A}$
\end_inset

 in the proof below.
 For brevity, we will write simply 
\begin_inset Formula $T$
\end_inset

 instead of 
\begin_inset Formula $T_{\text{Search}}^{M}$
\end_inset

 (the foreign monad 
\begin_inset Formula $M$
\end_inset

 is fixed throughout the derivations).
 
\end_layout

\begin_layout Standard
The monad methods of 
\begin_inset Formula $T_{\text{Search}}^{M}\triangleq T$
\end_inset

 are defined according to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-construction-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{T}\triangleq a^{:A}\rightarrow\big(\_^{:H^{A}}\big)\rightarrow\text{pu}_{T_{L}}(a)\quad,\\
 & f^{:H^{B}\rightarrow A\rightarrow T_{L}^{M,B}}\tilde{\diamond}_{_{T}}g^{:H^{C}\rightarrow A\rightarrow T_{L}^{M,C}}\triangleq h^{:H^{C}}\rightarrow f\big(h\triangleright\text{lift}_{T_{L}^{M},H}(g(h))\big)\diamond_{_{T_{L}}}g(h)\quad,\\
\text{where we defined}:\quad & \text{lift}_{T_{L}^{M},H}\triangleq f^{:A\rightarrow T_{L}^{M,B}}\rightarrow h^{:B\rightarrow T_{L}^{M,Q}}\rightarrow f\diamond_{_{T_{L}^{M}}}h\quad.
\end{align*}

\end_inset

Derivations are shorter if we use the flipped Kleisli composition operation
 
\begin_inset Formula $\tilde{\diamond}_{_{T}}$
\end_inset

 and the (ordinary) Kleisli composition 
\begin_inset Formula $\diamond_{_{T_{L}}}$
\end_inset

 of the monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
We need to establish monad isomorphisms between the monads 
\begin_inset Formula $R^{A}\triangleq(A\rightarrow L^{Q})\rightarrow L^{A}$
\end_inset

 and 
\begin_inset Formula $S^{A}\triangleq(A\rightarrow T_{L}^{\text{Id},Q})\rightarrow T_{L}^{\text{Id},A}$
\end_inset

.
 Denote for brevity 
\begin_inset Formula $N^{A}\triangleq T_{L}^{\text{Id},A}$
\end_inset

.
 Our goal is to implement monad morphisms 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

:
\begin_inset Formula 
\[
p:\big((A\rightarrow L^{Q})\rightarrow L^{A}\big)\rightarrow(A\rightarrow N^{Q})\rightarrow N^{A}\quad,\quad\quad q:\big((A\rightarrow N^{Q})\rightarrow N^{A}\big)\rightarrow(A\rightarrow L^{Q})\rightarrow L^{A}\quad,
\]

\end_inset

such that 
\begin_inset Formula $p\bef q=\text{id}$
\end_inset

 and 
\begin_inset Formula $q\bef p=\text{id}$
\end_inset

.
 We may assume that the identity laws already hold for the transformer 
\begin_inset Formula $T_{L}$
\end_inset

.
 These laws imply that there exist two monad morphisms,
\begin_inset Formula 
\[
r^{A}:L^{A}\rightarrow N^{A}\quad,\quad\quad s^{A}:N^{A}\rightarrow L^{A}\quad,
\]

\end_inset

 satisfying the laws 
\begin_inset Formula $r\bef s=\text{id}$
\end_inset

 and 
\begin_inset Formula $s\bef r=\text{id}$
\end_inset

.
 We may use 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 as given functions.
\end_layout

\begin_layout Standard
The listed requirements use 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 in the same way.
 So, the implementations of 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 will be the same up to exchanging 
\begin_inset Formula $r$
\end_inset

 with 
\begin_inset Formula $s$
\end_inset

, and it will be sufficient to prove one of the laws (say, 
\begin_inset Formula $p\bef q=\text{id}$
\end_inset

).
\end_layout

\begin_layout Standard
To find the code for 
\begin_inset Formula $p$
\end_inset

, we use typed holes:
\begin_inset Formula 
\begin{align*}
 & p\triangleq u^{:(A\rightarrow L^{Q})\rightarrow L^{A}}\rightarrow v^{:A\rightarrow N^{Q}}\rightarrow\text{???}^{:N^{A}}=u\rightarrow v\rightarrow(\text{???}^{:A\rightarrow L^{Q}})\triangleright u\triangleright r^{A}\\
 & =u\rightarrow v\rightarrow(\text{???}^{:A\rightarrow N^{Q}}\bef s^{Q})\triangleright u\triangleright r=u\rightarrow v\rightarrow(v\bef s)\triangleright u\bef r\quad.
\end{align*}

\end_inset

The code for 
\begin_inset Formula $q$
\end_inset

 is found by exchanging 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 in the code of 
\begin_inset Formula $p$
\end_inset

:
\begin_inset Formula 
\[
q\triangleq t^{:(A\rightarrow N^{Q})\rightarrow N^{A}}\rightarrow w^{:A\rightarrow L^{Q}}\rightarrow(w\bef r)\triangleright t\bef s\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify that 
\begin_inset Formula $p\bef q=\text{id}$
\end_inset

, we use the assumption 
\begin_inset Formula $r\bef s=\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & p\bef q=\big(u\rightarrow\gunderline{v\rightarrow(v\bef s)\triangleright u\bef r}\big)\bef\big(\gunderline t\rightarrow w\rightarrow(w\bef r)\triangleright\gunderline t\bef s\big)\\
\text{compute composition}:\quad & =u\rightarrow w\rightarrow\gunderline{(w\bef r)\triangleright\big(v}\rightarrow(v\bef s)\triangleright u\bef r\big)\bef s\\
\text{apply function}:\quad & =u\rightarrow w\rightarrow(w\bef\,\gunderline{r\bef s})\triangleright u\bef\,\gunderline{r\bef s}=u\rightarrow(\gunderline{w\rightarrow w\,\triangleright}\,u)=u\rightarrow u=\text{id}\quad.
\end{align*}

\end_inset

A separate proof for 
\begin_inset Formula $q\bef p=\text{id}$
\end_inset

 is not needed.
\end_layout

\begin_layout Standard
It remains to prove that 
\begin_inset Formula $p$
\end_inset

 is a monad morphism (the same will then hold for 
\begin_inset Formula $q$
\end_inset

).
\end_layout

\begin_layout Standard
To verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }a\triangleright\text{pu}_{S}:\quad & a\triangleright\text{pu}_{R}\bef p=\big((\_^{:A\rightarrow L^{Q}})\rightarrow a\triangleright\text{pu}_{L}\big)\triangleright p=\gunderline v\rightarrow a\triangleright\gunderline{\text{pu}_{L}\bef r}\\
v\text{ is not used}:\quad & =\_\rightarrow a\triangleright\text{pu}_{N}=a\triangleright\text{pu}_{S}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law, we use the flipped Kleisli
\begin_inset Index idx
status open

\begin_layout Plain Layout
flipped@
\begin_inset Quotes eld
\end_inset

flipped Kleisli
\begin_inset Quotes erd
\end_inset

 technique
\end_layout

\end_inset

 formulation.
 The flipped Kleisli composition for the monad 
\begin_inset Formula $R$
\end_inset

 is defined by:
\begin_inset Formula 
\[
f^{:(B\rightarrow L^{Q})\rightarrow A\rightarrow L^{B}}\tilde{\diamond}_{_{T}}g^{:(C\rightarrow L^{Q})\rightarrow B\rightarrow L^{C}}\triangleq h^{:H^{C}}\rightarrow f\big(h\triangleright\text{lift}_{L,H}(g(h))\big)\diamond_{_{L}}g(h)\quad,
\]

\end_inset

and similarly for the monad 
\begin_inset Formula $S$
\end_inset

 (except for using 
\begin_inset Formula $N$
\end_inset

 instead of 
\begin_inset Formula $L$
\end_inset

 and a corresponding change in the definition of 
\begin_inset Formula $H$
\end_inset

).
 The next step is to modify 
\begin_inset Formula $p$
\end_inset

 into a more convenient function, 
\begin_inset Formula $\tilde{p}$
\end_inset

, that directly transforms flipped Kleisli functions in the monad 
\begin_inset Formula $R$
\end_inset

 into those in 
\begin_inset Formula $S$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \tilde{p}:\big((B\rightarrow L^{Q})\rightarrow A\rightarrow L^{B}\big)\rightarrow(B\rightarrow N^{Q})\rightarrow A\rightarrow N^{B}\quad,\\
 & \tilde{p}\triangleq k^{:(B\rightarrow L^{Q})\rightarrow A\rightarrow L^{B}}\rightarrow h^{:B\rightarrow N^{Q}}\rightarrow k(h\bef s)\bef r\quad.
\end{align*}

\end_inset

We may now rewrite the composition law using 
\begin_inset Formula $\tilde{p}$
\end_inset

:
\begin_inset Formula 
\[
\tilde{p}\big(f^{:(B\rightarrow L^{Q})\rightarrow A\rightarrow L^{B}}\tilde{\diamond}_{_{R}}g^{:(C\rightarrow L^{Q})\rightarrow B\rightarrow L^{C}}\big)\overset{?}{=}\tilde{p}(f)\tilde{\diamond}_{_{S}}\tilde{p}(g)\quad.
\]

\end_inset

Rewrite the left-hand side:
\begin_inset Formula 
\begin{align*}
 & \tilde{p}\big(f\tilde{\diamond}_{_{R}}g\big)=\gunderline{\tilde{p}}\big(h\rightarrow f\big(h\triangleright\text{lift}_{L,H}(g(h))\big)\diamond_{_{L}}g(h)\big)\\
\text{definition of }\tilde{p}:\quad & =h\rightarrow\big(f\big((h\bef s)\triangleright\text{lift}_{L,H}(g(h\bef s))\big)\gunderline{\diamond_{_{L}}}g(h\bef s)\big)\,\gunderline{\bef\,r}\\
\text{composition law of }r:\quad & =h\rightarrow\big(f\big((h\bef s)\triangleright\text{lift}_{L,H}(g(h\bef s))\big)\bef r\big)\diamond_{_{N}}\big(g(h\bef s)\bef r\big)\quad.
\end{align*}

\end_inset

Rewrite the right-hand side:
\begin_inset Formula 
\begin{align*}
 & \tilde{p}\left(f\right)\tilde{\diamond}_{_{S}}\tilde{p}\left(g\right)=\big(h\rightarrow f(h\bef s)\bef r\big)\tilde{\diamond}_{_{S}}\big(h\rightarrow g(h\bef s)\bef r\big)\\
 & =h\rightarrow\big(h\rightarrow f(h\bef s)\bef r\big)(h\triangleright\text{lift}_{N,H}(\big(h\rightarrow g(h\bef s)\bef r\big)(h)))\diamond_{_{N}}\big(h\rightarrow g(h\bef s)\bef r\big)(h)\\
 & =h\rightarrow\big(f((h\triangleright\text{lift}_{N,H}(g(h\bef s)\bef r))\bef s)\bef r\big)\diamond_{_{N}}\big(g(h\bef s)\bef r\big)\quad.
\end{align*}

\end_inset

The remaining difference between the two sides is:
\begin_inset Formula 
\begin{equation}
(h\bef s)\triangleright\text{lift}_{L,H}(g(h\bef s))\overset{?}{=}\big(h\triangleright\text{lift}_{N,H}(g(h\bef s)\bef r)\big)\bef s\quad.\label{eq:identity-law-search-monad-transformer-derivation1}
\end{equation}

\end_inset

To proceed, we need to use the code of the lifting functions 
\begin_inset Formula $\text{lift}_{L,H}$
\end_inset

 and 
\begin_inset Formula $\text{lift}_{N,H}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{lift}_{L,H}:(A\rightarrow L^{B})\rightarrow(B\rightarrow L^{Q})\rightarrow A\rightarrow L^{Q}\quad,\quad\quad g^{:B\rightarrow L^{Q}}\triangleright\text{lift}_{L,H}(f^{:A\rightarrow L^{B}})=f\diamond_{_{L}}g\quad,\\
 & \text{lift}_{N,H}:(A\rightarrow N^{B})\rightarrow(B\rightarrow N^{Q})\rightarrow A\rightarrow N^{Q}\quad,\quad\quad g^{:B\rightarrow N^{Q}}\triangleright\text{lift}_{N,H}(f^{:A\rightarrow N^{B}})=f\diamond_{_{N}}g\quad.
\end{align*}

\end_inset

Substituting the code of those functions into both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:identity-law-search-monad-transformer-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we get:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (h\bef s)\triangleright\text{lift}_{L,H}(g(h\bef s))=g(h\bef s)\diamond_{_{L}}\!(h\bef s)\\
 & \overset{?}{=}\big(h\triangleright\text{lift}_{N,H}(g(h\bef s)\bef r)\big)\bef s=\big((g(h\bef s)\bef r)\,\gunderline{\diamond_{_{N}}}h\big)\gunderline{\bef s}\\
\text{composition law of }s:\quad & =\big(g(h\bef s)\bef\,\gunderline{r\bef s}\big)\diamond_{_{L}}\!(h\bef s)=g(h\bef s)\diamond_{_{L}}\!(h\bef s)\quad.
\end{align*}

\end_inset

Both sides are now equal.
\end_layout

\begin_layout Paragraph
Lifting laws
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 function of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad transformer is defined by:
\begin_inset Formula 
\[
\text{flift}:\quad M^{A}\rightarrow(A\rightarrow T_{L}^{M,Q})\rightarrow T_{L}^{M,A}\quad,\quad\quad\text{flift}\triangleq m^{:M^{A}}\rightarrow\big(\_^{:H^{A}}\big)\rightarrow m\triangleright\text{flift}_{L}\quad,
\]

\end_inset

where 
\begin_inset Formula $\text{flift}_{L}:M^{A}\rightarrow T_{L}^{M,A}$
\end_inset

 is the transformer 
\begin_inset Formula $T_{L}$
\end_inset

's foreign lift function.
\end_layout

\begin_layout Standard
To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is a monad morphism, begin with the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }a\triangleright\text{pu}_{T}:\quad & a^{:A}\triangleright\text{pu}_{M}\bef\text{flift}=\big(\_^{:A\rightarrow T_{L}^{M,Q}}\big)\rightarrow a\triangleright\gunderline{\text{pu}_{M}\bef\text{flift}_{L}}\\
\text{identity law of }\text{flift}_{L}:\quad & =\big(\_^{:A\rightarrow T_{L}^{M,Q}}\big)\rightarrow a\triangleright\text{pu}_{T_{L}}\\
\text{definition of }\text{pu}_{T}:\quad & =a\triangleright\text{pu}_{T}\quad.
\end{align*}

\end_inset

To verify the composition law, we note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 always produces functions that ignore their argument of type 
\begin_inset Formula $H^{A}$
\end_inset

.
 For such values, the Kleisli composition 
\begin_inset Formula $\tilde{\diamond}_{_{T}}$
\end_inset

 may be simplified: If we know that the functions 
\begin_inset Formula $f^{:H^{B}\rightarrow A\rightarrow T_{L}^{M,B}}$
\end_inset

 and 
\begin_inset Formula $g^{:H^{C}\rightarrow A\rightarrow T_{L}^{M,C}}$
\end_inset

 ignore their first arguments, we may write
\begin_inset Formula 
\[
f\,\tilde{\diamond}_{_{T}}g=k^{:H^{C}}\rightarrow f(...)\diamond_{_{T_{L}}}g(...)=(\_^{:H^{C}})\rightarrow f(...)\diamond_{_{T_{L}}}g(...)\quad.
\]

\end_inset

So, the Kleisli composition also always produces functions that ignore their
 first arguments.
 We can then simplify the formulas, since 
\begin_inset Formula $\diamond_{_{T}}$
\end_inset

 reduces to the Kleisli composition 
\begin_inset Formula $\diamond_{_{T_{L}}}$
\end_inset

 of the monad 
\begin_inset Formula $T_{L}^{M}$
\end_inset

.
 To make use of this simplification, we need to flip the arguments of Kleisli
 functions.
 First, we find, for any function 
\begin_inset Formula $p^{:A\rightarrow M^{B}}$
\end_inset

:
\begin_inset Formula 
\[
\text{flip}\,(p^{:A\rightarrow M^{B}}\bef\text{flift})=(\_^{:H^{B}})\rightarrow\gunderline{a^{:A}\rightarrow a\,\triangleright}\,p\triangleright\text{flift}_{L}=(\_^{:H^{B}})\rightarrow p\bef\text{flift}_{L}\quad.
\]

\end_inset

Now we can show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

's composition law holds:
\begin_inset Formula 
\begin{align*}
\text{expect }(p\diamond_{_{M}}q)\bef\text{flift}:\quad & \big(p^{:A\rightarrow M^{B}}\bef\text{flift}\big)\diamond_{_{T}}\big(q^{:B\rightarrow M^{C}}\bef\text{flift}\big)=\text{flip}\,\big(\gunderline{\text{flip}\,(p\bef\text{flift})}\tilde{\diamond}_{_{T}}\gunderline{\text{flip}\,(q\bef\text{flift})}\big)\\
 & =\text{flip}\,\big((\_\rightarrow p\bef\text{flift}_{L})\,\tilde{\diamond}_{_{T}}(\_\rightarrow q\bef\text{flift}_{L})\big)=\text{flip}\,\big(\_\rightarrow\gunderline{(p\bef\text{flift}_{L})\diamond_{_{T_{L}}}(q\bef\text{flift}_{L})}\big)\\
\text{flift}_{L}\text{'s composition law}:\quad & =\text{flip}\,\big(\gunderline{\_\rightarrow(p\diamond_{_{M}}q)\bef\text{flift}_{L}}\big)=\gunderline{\text{flip}\,\big(\text{flip}}\,((p\diamond_{_{M}}q)\bef\text{flift})\big)\\
\text{use }\text{flip}\bef\text{flip}=\text{id}:\quad & =(p\diamond_{_{M}}q)\bef\text{flift}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
The codensity monad and its transformer.
 Proofs
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-codensity-monad"

\end_inset


\end_layout

\begin_layout Standard
For any type constructor 
\begin_inset Formula $F$
\end_inset

, the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!codensity monad|textit
\end_layout

\end_inset


\series bold
codensity monad
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
See the talk 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://begriffs.com/posts/2016-02-04-difference-lists-and-codennsity.html"

\end_inset


\family default
 for applications of the codensity monad in functional programming and for
 more references.
\end_layout

\end_inset

 
\series bold
on
\series default
 
\begin_inset Formula $F$
\end_inset

 is defined by:
\begin_inset Formula 
\[
\text{Cod}^{F,A}\triangleq\forall R.\,(A\rightarrow F^{R})\rightarrow F^{R}\quad.
\]

\end_inset

Before considering its transformer, we will establish some properties of
 this monad.
\end_layout

\begin_layout Standard
Note the similarity of 
\begin_inset Formula $\text{Cod}^{F,A}$
\end_inset

 with the continuation monad 
\begin_inset Formula $\text{Cont}^{F^{R},A}=(A\rightarrow F^{R})\rightarrow F^{R}$
\end_inset

 whose 
\begin_inset Quotes eld
\end_inset

return type
\begin_inset Quotes erd
\end_inset

 is 
\begin_inset Formula $F^{R}$
\end_inset

.
 The difference is that 
\begin_inset Formula $\text{Cod}^{F,A}$
\end_inset

 imposes a universal quantifier (
\begin_inset Formula $\forall R$
\end_inset

) on the type parameter 
\begin_inset Formula $R$
\end_inset

:
\begin_inset Formula 
\[
\text{Cod}^{F,A}=\forall R.\,\text{Cont}^{F^{R},A}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In general, adding a type quantifier preserves monad laws:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monad-with-quantifier"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-with-quantifier"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume a monad 
\begin_inset Formula $K^{R,\bullet}$
\end_inset

 with an extra type parameter 
\begin_inset Formula $R$
\end_inset

.
 In other words, 
\begin_inset Formula $K^{R,A}$
\end_inset

 is a lawful monad with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

 and with a fixed 
\begin_inset Formula $R$
\end_inset

.
 Then: 
\series bold
(a)
\series default
 
\begin_inset Formula $L^{A}\triangleq\forall R.\,K^{R,A}$
\end_inset

 is also a lawful monad.
 
\series bold
(b)
\series default
 For any fixed 
\begin_inset Formula $R$
\end_inset

, there is a monad morphism of type 
\begin_inset Formula $L^{\bullet}\leadsto K^{R,\bullet}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 We need to define the monad 
\begin_inset Formula $L$
\end_inset

's methods and verify the laws.
 The idea is to add the quantifier (
\begin_inset Formula $\forall R$
\end_inset

) to monad 
\begin_inset Formula $K$
\end_inset

's methods.
 (For brevity, we will sometimes write 
\begin_inset Formula $K$
\end_inset

 to mean 
\begin_inset Formula $K^{R,\bullet}$
\end_inset

.) Begin with the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{pu}_{L}\triangleq\forall R.\,\text{pu}_{K^{R,\bullet}}=\forall R.\,a^{:A}\rightarrow\text{pu}_{K^{R,\bullet}}(a)=a^{:A}\rightarrow\forall R.\,\text{pu}_{K^{R,\bullet}}(a)\quad.
\]

\end_inset

Here, we may move the quantifier as 
\begin_inset Formula $\forall R.\,a^{:A}\rightarrow(...)^{R}=a^{:A}\rightarrow\forall R.\,(...)^{R}$
\end_inset

 because the type parameter 
\begin_inset Formula $A$
\end_inset

 does not depend on 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Standard
To define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method for 
\begin_inset Formula $L$
\end_inset

, we add quantifiers to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method of 
\begin_inset Formula $K$
\end_inset

:
\begin_inset Formula 
\[
\text{flm}_{K}(f^{:A\rightarrow K^{R,B}})(d^{:K^{R,A}}):K^{R,B}\quad,
\]

\end_inset

and to its two curried arguments (
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

).
 To write the resulting code, we need to use distinct type parameters 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

, 
\begin_inset Formula $T$
\end_inset

 for the arguments 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $d$
\end_inset

 and for the return value respectively: 
\begin_inset Formula 
\[
\text{flm}_{L}(f^{:\forall R.\,A\rightarrow K^{R,B}})\triangleq d^{:\forall S.\,K^{S,A}}\rightarrow\forall T.\,\text{flm}_{K}(f^{T})(d^{T})\quad.
\]

\end_inset

The arguments 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 of 
\begin_inset Formula $\text{flm}_{L}$
\end_inset

 have their own type parameters (
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

), and we 
\emph on
assign
\emph default
 those type parameters to the type 
\begin_inset Formula $T$
\end_inset

 in the expression 
\begin_inset Formula $\text{flm}_{K}(f^{T})(d^{T})$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the monad laws for 
\begin_inset Formula $L$
\end_inset

, we use the Kleisli formulation.
 To define the Kleisli composition (
\begin_inset Formula $\diamond_{_{L}}$
\end_inset

) for 
\begin_inset Formula $L$
\end_inset

, we use two different universally quantified types (
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

) to avoid confusion:
\begin_inset Formula 
\[
f^{:A\rightarrow L^{B}}\diamond_{_{L}}g^{:B\rightarrow L^{C}}=f^{:\forall R.\,A\rightarrow K^{R,B}}\diamond_{_{L}}g^{:\forall S.\,B\rightarrow K^{S,C}}\triangleq\forall T.\,f^{T}\diamond_{_{K}}g^{T}\quad.
\]

\end_inset

As in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, we need to assign the type parameters 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 to 
\begin_inset Formula $T$
\end_inset

.
 
\end_layout

\begin_layout Standard
To verify the identity laws, we assume that the same laws hold for the monad
 
\begin_inset Formula $K$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }g:\quad & \text{pu}_{L}\diamond_{_{L}}g=\forall T.\,\text{pu}_{K^{T,\bullet}}\diamond_{_{K}}g^{T}=\forall T.\,g^{T}=g\quad,\\
\text{expect to equal }f:\quad & f\diamond_{_{L}}\text{pu}_{L}=\forall T.\,f^{T}\diamond_{_{K}}\text{pu}_{K^{T,\bullet}}=\forall T.\,f^{T}=f\quad.
\end{align*}

\end_inset

To verify the associativity law:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & (f\diamond_{_{L}}g)\diamond_{_{L}}h=\big(\forall T.\,f^{T}\diamond_{_{K}}g^{T}\big)\diamond_{_{L}}h\\
 & \quad=\forall S.\,\big(\forall T.\,f^{T}\diamond_{_{K}}g^{T}\big)^{S}\diamond_{_{K}}h^{S}=\forall S.\,\big(f^{S}\diamond_{_{K}}g^{S}\big)\diamond_{_{K}}h^{S}\quad,\\
\text{right-hand side}:\quad & f\diamond_{_{L}}(g\diamond_{_{L}}h)=\forall S.\,f^{S}\diamond_{_{K}}(g\diamond_{_{L}}h)^{S}\\
 & \quad=\forall S.\,f^{S}\diamond_{_{K}}\big(\forall T.\,g^{T}\diamond_{_{K}}h^{T}\big)^{S}=\forall S.\,f^{S}\diamond_{_{K}}(g^{S}\diamond_{_{K}}h^{S})\quad.
\end{align*}

\end_inset

The two sides are equal due to the associativity of the Kleisli composition
 (
\begin_inset Formula $\diamond_{_{K}}$
\end_inset

) of the monad 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The monad morphism 
\begin_inset Formula $\phi:L^{A}\rightarrow K^{R,A}$
\end_inset

 is defined by setting the quantified type parameter 
\begin_inset Formula $T$
\end_inset

 in 
\begin_inset Formula $L^{A}\triangleq\forall T.\,K^{T,A}$
\end_inset

 as 
\begin_inset Formula $T=R$
\end_inset

.
 The action of 
\begin_inset Formula $\phi$
\end_inset

 on a Kleisli function 
\begin_inset Formula $f^{:\forall T.\,A\rightarrow K^{T,B}}$
\end_inset

 can be written as 
\begin_inset Formula $f\bef\phi=f^{R}$
\end_inset

.
 To verify that 
\begin_inset Formula $\phi$
\end_inset

 is monad morphism, begin with the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{K}:\quad & \text{pu}_{L}\bef\phi=(\forall T.\,\text{pu}_{K^{T,\bullet}})\bef\phi=(\forall T.\,\text{pu}_{K^{T,\bullet}})^{R}=\text{pu}_{K^{R,\bullet}}=\text{pu}_{K}\quad.
\end{align*}

\end_inset

To verify the composition law, we show that its two sides are equal:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \big(f^{:\forall R.\,A\rightarrow K^{R,B}}\diamond_{_{L}}g^{:\forall S.\,B\rightarrow K^{S,C}}\big)\bef\phi=(\forall T.\,f^{T}\diamond_{_{K}}g^{T})^{R}=f^{R}\diamond_{_{K}}g^{R}\quad,\\
\text{right-hand side}:\quad & (f\bef\phi)\diamond_{_{K}}(g\bef\phi)=f^{R}\diamond_{_{K}}g^{R}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-codensity-monad-lawful"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-lawful"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\text{Cod}^{F,\bullet}$
\end_inset

 is a monad for any type constructor 
\begin_inset Formula $F$
\end_inset

, even if 
\begin_inset Formula $F$
\end_inset

 is not a functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-with-quantifier"
plural "false"
caps "false"
noprefix "false"

\end_inset

, adding a quantifier (
\begin_inset Formula $\forall R$
\end_inset

) to the continuation monad 
\begin_inset Formula $\text{Cont}^{F^{R},A}$
\end_inset

 gives again a lawful monad.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We will now show that when 
\begin_inset Formula $F$
\end_inset

 is a monad, 
\begin_inset Formula $\text{Cod}^{F,\bullet}$
\end_inset

 includes all the effects of 
\begin_inset Formula $F$
\end_inset

.
 The proof also shows that the monad 
\begin_inset Formula $\text{Cod}^{F,\bullet}$
\end_inset

 may support some additional effects not described by the monad 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-codensity-monad-inC-outC"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-inC-outC"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $F$
\end_inset

 is itself a monad then:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 There exist natural transformations 
\begin_inset Formula $\text{inC}:F^{\bullet}\leadsto\text{Cod}^{F,\bullet}$
\end_inset

 and 
\begin_inset Formula $\text{outC}:\text{Cod}^{F,\bullet}\leadsto F^{\bullet}$
\end_inset

, such that 
\begin_inset Formula $\text{inC}\,\bef\text{outC}=\text{id}$
\end_inset

.
 So, the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC[A]
\end_layout

\end_inset

 are injective while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC[A]
\end_layout

\end_inset

 are surjective.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 is a monad morphism 
\begin_inset Formula $F^{\bullet}\leadsto\text{Cod}^{F,\bullet}$
\end_inset

 but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 a monad morphism.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 are 
\emph on
not
\emph default
 isomorphisms between the types 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $\text{Cod}^{F,A}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Begin by implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{inC}:F^{A}\rightarrow\forall R.\,(A\rightarrow F^{R})\rightarrow F^{R}\quad,\quad\quad\text{inC}^{R,A}\triangleq f^{:F^{A}}\rightarrow k^{:A\rightarrow F^{R}}\rightarrow f\triangleright\text{flm}_{F}(k)\quad,\\
 & \text{outC}:\big(\forall R.\,(A\rightarrow F^{R})\rightarrow F^{R}\big)\rightarrow F^{A}\quad,\quad\quad\text{outC}^{A}\triangleq d^{:\forall R.\,(A\rightarrow F^{R})\rightarrow F^{R}}\rightarrow d^{A}(\text{pu}_{F}^{:A\rightarrow F^{A}})\quad.
\end{align*}

\end_inset

Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 is equivalent to 
\begin_inset Formula $F$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, or equivalently 
\begin_inset Formula $\text{flm}_{F}$
\end_inset

 with flipped arguments.
\end_layout

\begin_layout Standard
Both functions are natural transformations because their code is fully parametri
c.
\end_layout

\begin_layout Standard
To verify the nondegeneracy law, compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }f:\quad & f^{:F^{A}}\triangleright\text{inC}\bef\text{outC}=(k\rightarrow f\triangleright\text{flm}_{F}(k))\triangleright\text{outC}\\
 & =(k\rightarrow f\triangleright\text{flm}_{F}(k))(\text{pu}_{F})=f\triangleright\gunderline{\text{flm}_{F}(\text{pu}_{F})}\\
\text{right identity law of }F:\quad & =f\triangleright\text{id}=f\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 is a monad morphism, we use the Kleisli composition:
\begin_inset Formula 
\[
f^{:\forall R.\,A\rightarrow(B\rightarrow F^{R})\rightarrow F^{R}}\diamond_{_{\text{Cod}}}g^{:\forall S.\,B\rightarrow(C\rightarrow F^{S})\rightarrow F^{S}}\triangleq\forall T.\,a^{:A}\rightarrow k^{:C\rightarrow F^{T}}\rightarrow f^{T}(a)\big(b^{:B}\rightarrow g^{T}(b)(k)\big)\quad.
\]

\end_inset

To verify the identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }a\triangleright\text{pu}_{\text{Cod}}:\quad & a^{:A}\triangleright\text{pu}_{F}\bef\text{inC}=\forall R.\,g^{:A\rightarrow F^{R}}\rightarrow a\triangleright\gunderline{\text{pu}_{F}\triangleright\text{flm}_{F}}(g)\\
\text{left identity law of }F:\quad & =\forall R.\,g^{:A\rightarrow F^{R}}\rightarrow a\triangleright g=\text{pu}_{\text{Cod}}(a)\quad.
\end{align*}

\end_inset

The composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 is written as:
\begin_inset Formula 
\[
(f^{:A\rightarrow F^{B}}\diamond_{_{F}}g^{:B\rightarrow F^{C}})\bef\text{inC}\overset{?}{=}(f\bef\text{inC})\diamond_{_{\text{Cod}}}(g\bef\text{inC})\quad.
\]

\end_inset

Apply both sides to an arbitrary value 
\begin_inset Formula $a^{:A}$
\end_inset

 and simplify the results:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & a^{:A}\triangleright(f\diamond_{_{F}}g)\bef\text{inC}=k\rightarrow a\triangleright(f\diamond_{_{F}}g)\bef\text{flm}_{F}(k)\\
\text{definition of }\diamond_{_{F}}:\quad & \quad=k\rightarrow a\triangleright f\bef\text{flm}_{F}(g)\bef\text{flm}_{F}(k)\quad,\\
\text{right-hand side}:\quad & a^{:A}\triangleright\big((f\bef\text{inC})\diamond_{_{\text{Cod}}}\!(g\bef\text{inC})\big)=k\rightarrow(f\bef\text{inC})^{T}(a)\big(b\rightarrow(g\bef\text{inC})^{T}(b)(k)\big)\quad.
\end{align*}

\end_inset

For clarity, let us simplify the expression 
\begin_inset Formula $(f\bef\text{inC})^{T}(a)(x)$
\end_inset

 separately:
\begin_inset Formula 
\[
(f\bef\text{inC})^{T}(a)(x)=x\triangleright\big(a\triangleright f\triangleright\text{inC}\big)^{T}=x\triangleright\big(k\rightarrow a\triangleright f\triangleright\text{flm}_{F}(k)\big)=a\triangleright f\triangleright\text{flm}_{F}(x)\quad.
\]

\end_inset

The same simplification applies to the expression 
\begin_inset Formula $(g\bef\text{inC})^{T}(b)(k)$
\end_inset

.
 So, the right-hand side becomes:
\begin_inset Formula 
\begin{align*}
\text{right-hand side}:\quad & k\rightarrow(f\bef\text{inC})^{T}(a)\big(\gunderline{b\rightarrow b\,\triangleright\,}g\bef\text{flm}_{F}(k)\big)=k\rightarrow\gunderline{(f\bef\text{inC})(a)}(g\bef\text{flm}_{F}(k))\\
 & =k\rightarrow a\triangleright f\triangleright\gunderline{\text{flm}_{F}(g\bef\text{flm}_{F}(k))}=k\rightarrow a\triangleright f\triangleright\text{flm}_{F}(g)\bef\text{flm}_{F}(k)\quad.
\end{align*}

\end_inset

The two sides of the law are now equal.
\end_layout

\begin_layout Standard
As for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

, it does satisfy the identity law of monad morphisms:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }a\triangleright\text{pu}_{F}:\quad & a^{:A}\triangleright\text{pu}_{\text{Cod}}\bef\text{outC}=\big(\forall R.\,g^{:A\rightarrow F^{R}}\rightarrow a\triangleright g\big)\triangleright\text{outC}\\
\text{definition of }\text{outC}:\quad & =\big(\forall R.\,g^{:A\rightarrow F^{R}}\rightarrow a\triangleright g\big)^{A}(\text{pu}_{F})=a\triangleright\text{pu}_{F}\quad.
\end{align*}

\end_inset

But the composition law does not hold in general:
\begin_inset Formula 
\[
\big(f^{:\forall R.\,A\rightarrow(B\rightarrow F^{R})\rightarrow F^{R}}\diamond_{_{\text{Cod}}}g^{:\forall S.\,B\rightarrow(C\rightarrow F^{S})\rightarrow F^{S}}\big)\bef\text{outC}\overset{?}{=}(f\bef\text{outC})\diamond_{_{F}}(g\bef\text{outC})\quad.
\]

\end_inset

Apply both sides to an arbitrary value 
\begin_inset Formula $a^{:A}$
\end_inset

 and simplify the results:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & a\triangleright(f\diamond_{_{\text{Cod}}}g)\bef\text{outC}=\big(\forall T.\,k\rightarrow f^{T}(a)\big(b\rightarrow g^{T}(b)(k)\big)\big)\bef(d\rightarrow d(\text{pu}_{F}))\\
 & \quad=\big(\forall T.\,k\rightarrow f^{T}(a)\big(b\rightarrow g^{T}(b)(k)\big)\big)(\text{pu}_{F})=f(a)(b\rightarrow g(b)(\text{pu}_{F}))\quad.\\
\text{right-hand side}:\quad & a\triangleright\big((f\bef\text{outC})\diamond_{_{F}}\!(g\bef\text{outC})\big)=a\triangleright(f\bef\text{outC})\bef\text{flm}_{F}(g\bef\text{outC})\\
 & \quad=a\triangleright f\triangleright\text{outC}\triangleright\text{flm}_{F}(g\bef\text{outC})=f(a)(\text{pu}_{F})\triangleright\text{flm}_{F}\big(b\rightarrow g(b)(\text{pu}_{F})\big)\quad.
\end{align*}

\end_inset

We find two different expressions that cannot be transformed into each other:
\begin_inset Formula 
\[
f(a)(b\rightarrow g(b)(\text{pu}_{F}))\neq f(a)(\text{pu}_{F})\triangleright\text{flm}_{F}\big(b\rightarrow g(b)(\text{pu}_{F})\big)\quad.
\]

\end_inset

There are no laws that would allow us to replace 
\begin_inset Formula $\text{pu}_{F}$
\end_inset

 in the 
\emph on
argument
\emph default
 of 
\begin_inset Formula $f$
\end_inset

 because 
\begin_inset Formula $f$
\end_inset

 is an arbitrary function.
 In part 
\series bold
(c)
\series default
 of this proof, we will see an example that violates the composition law
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 are not isomorphisms because 
\begin_inset Formula $\text{outC}\bef\text{inC}\not=\text{id}$
\end_inset

.
 To show this, choose 
\begin_inset Formula $F^{A}\triangleq R\rightarrow A$
\end_inset

 (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad) and simplify the type 
\begin_inset Formula $\text{Cod}^{F,A}$
\end_inset

 via the covariant Yoneda identity:
\begin_inset Formula 
\[
\text{Cod}^{F,A}=\forall B.\,(\gunderline{A\rightarrow R}\rightarrow B)\rightarrow\gunderline{R\rightarrow}\,B=R\rightarrow\gunderline{\forall B.\,(A\times R\rightarrow B)\rightarrow B}=R\rightarrow A\times R\quad.
\]

\end_inset

The resulting type constructor is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad (
\begin_inset Formula $\text{State}^{R,A}$
\end_inset

), which includes the effect of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 and additionally has the effect of changing a value of type 
\begin_inset Formula $R$
\end_inset

 and passing it to the next computation.
 That effect is not supported by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad.
 
\end_layout

\begin_layout Standard
For this choice of 
\begin_inset Formula $F$
\end_inset

, the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 are defined as:
\begin_inset Formula 
\begin{align*}
 & \text{inC}:\left(R\rightarrow A\right)\rightarrow R\rightarrow A\times R\quad,\quad\quad\text{inC}\triangleq g^{:R\rightarrow A}\rightarrow r^{:R}\rightarrow g(r)\times r\quad,\\
 & \text{outC}:\left(R\rightarrow A\times R\right)\rightarrow R\rightarrow A\quad,\quad\quad\text{outC}\triangleq s^{:R\rightarrow A\times R}\rightarrow r^{:R}\rightarrow s(r)\triangleright\pi_{1}\quad.
\end{align*}

\end_inset

(These type signatures admit no other fully parametric implementations.)
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 is a flipped version of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's runner.
 That runner returns the result value of type 
\begin_inset Formula $A$
\end_inset

 but discards the possibly changed state (of type 
\begin_inset Formula $R$
\end_inset

).
 This makes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's runner fail the composition law, as we already noted in the proof
 of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-state-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
To obtain a specific example showing that 
\begin_inset Formula $\text{outC}\bef\text{inC}\neq\text{id}$
\end_inset

, choose the type 
\begin_inset Formula $R\triangleq\bbnum 1+P$
\end_inset

 with some fixed type 
\begin_inset Formula $P$
\end_inset

 and define a monadic value 
\begin_inset Formula $s:\text{State}^{R,R}$
\end_inset

 by:
\begin_inset Formula 
\[
s:\bbnum 1+P\rightarrow(\bbnum 1+P)\times(\bbnum 1+P)\quad,\quad\quad s\triangleq r^{:\bbnum 1+P}\rightarrow r\times(\bbnum 1+\bbnum 0)\quad.
\]

\end_inset

Let us now compute 
\begin_inset Formula $s\triangleright\text{outC}\bef\text{inC}$
\end_inset

 and check that the result is not equal to 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & s\triangleright\text{outC}=r^{:\bbnum 1+P}\rightarrow s(r)\triangleright\pi_{1}=r\rightarrow r=\text{id}\quad,\\
 & s\triangleright\text{outC}\triangleright\text{inC}=\text{id}\triangleright\text{inC}=r\rightarrow r\times r\neq s=r\rightarrow r\times(\bbnum 1+\bbnum 0)\quad.
\end{align*}

\end_inset

We conclude that 
\begin_inset Formula $\text{outC}\bef\text{inC}\neq\text{id}$
\end_inset

 for some monads 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-codensity-monad-transformer"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
A monad transformer for 
\begin_inset Formula $\text{Cod}^{F,\bullet}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
T_{\text{Cod}}^{M,A}\triangleq\forall R.\,(A\rightarrow M^{F^{R}})\rightarrow M^{F^{R}}\quad.
\]

\end_inset

This assumes a lawful foreign monad 
\begin_inset Formula $M$
\end_inset

, while 
\begin_inset Formula $F$
\end_inset

 may be any type constructor.
 The transformer 
\begin_inset Formula $T_{\text{Cod}}$
\end_inset

 does not have the base lift, foreign runner, or base runner methods.
\end_layout

\begin_layout Subparagraph
Proof 
\end_layout

\begin_layout Standard
Similarly to the continuation monad's transformer, we only prove three groups
 of laws.
\end_layout

\begin_layout Paragraph
The monad laws
\end_layout

\begin_layout Standard
hold for 
\begin_inset Formula $T_{\text{Cod}}^{M,A}$
\end_inset

 due to Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-lawful"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we replace 
\begin_inset Formula $F^{\bullet}$
\end_inset

 by 
\begin_inset Formula $M^{F^{\bullet}}$
\end_inset

.
\end_layout

\begin_layout Paragraph
The identity laws
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $M=\text{Id}$
\end_inset

, the type 
\begin_inset Formula $T_{\text{Cod}}^{\text{Id},A}$
\end_inset

 is the same as 
\begin_inset Formula $\text{Cod}^{F,A}$
\end_inset

, so the isomorphism is given by identity functions.
 Laws always hold for identity functions.
\end_layout

\begin_layout Paragraph
The lifting laws
\end_layout

\begin_layout Standard
require implementing a monad morphism 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 with type 
\begin_inset Formula $M^{A}\rightarrow T_{\text{Cod}}^{M,A}$
\end_inset

:
\begin_inset Formula 
\[
\text{flift}:M^{A}\rightarrow\forall R.\,(A\rightarrow M^{F^{R}})\rightarrow M^{F^{R}}\quad,\quad\quad\text{flift}\triangleq\forall R.\,m^{:M^{A}}\rightarrow k^{:A\rightarrow M^{F^{R}}}\rightarrow m\triangleright\text{flm}_{M}(k)\quad.
\]

\end_inset

We note that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 is the same as the code of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-inC-outC"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
\text{inC}:M^{A}\rightarrow\forall S.\,(A\rightarrow M^{S})\rightarrow M^{S}\quad,\quad\quad\text{inC}\triangleq\forall S.\,m^{:M^{A}}\rightarrow k^{:A\rightarrow M^{S}}\rightarrow m\triangleright\text{flm}_{M}(k)\quad,
\]

\end_inset

where we renamed 
\begin_inset Formula $F$
\end_inset

 to 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 to 
\begin_inset Formula $S$
\end_inset

 to make the comparison easier.
 The difference between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 is only in the universally quantified types.
 We obtain 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 by restricting the type 
\begin_inset Formula $S$
\end_inset

 to types of the form 
\begin_inset Formula $F^{R}$
\end_inset

 (where 
\begin_inset Formula $R$
\end_inset

 is arbitrary but fixed).
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-inC-outC"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the monad morphism laws hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

, where the type 
\begin_inset Formula $S$
\end_inset

 is unrestricted.
 So, the same laws will hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 where 
\begin_inset Formula $S$
\end_inset

 is restricted to types of the form 
\begin_inset Formula $F^{R}$
\end_inset

.
\end_layout

\begin_layout Subsection
Examples of monads with several different transformers
\begin_inset CommandInset label
LatexCommand label
name "subsec:Examples-of-monads-with-two-different-transformers"

\end_inset


\end_layout

\begin_layout Standard
As a rule, a monad has only one monad transformer.
 This section shows some exceptions to that rule: monads that have several
 inequivalent transformers.
 Often, one transformer is complete (has all the required methods) but others
 are incomplete.
\end_layout

\begin_layout Standard
The first example is the selector monad
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Sel
\family default
 (selector) monad
\end_layout

\end_inset

, 
\begin_inset Formula $\text{Sel}^{Q,A}=(A\rightarrow Q)\rightarrow A$
\end_inset

.
 That monad, described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-monad-construction-1-choice"
plural "false"
caps "false"
noprefix "false"

\end_inset

, has a composed-outside transformer: 
\begin_inset Formula $T_{1}^{M,A}\triangleq(M^{A}\rightarrow Q)\rightarrow M^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
At the same time, 
\begin_inset Formula $\text{Sel}^{Q,A}$
\end_inset

 is equivalent to the generalized 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

 monad (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Transformer-for-the-generalized-search-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $L$
\end_inset

 chosen to be the identity monad:
\begin_inset Formula 
\[
\text{Sel}^{Q,A}\cong\text{Search}^{\text{Id},Q,A}\quad.
\]

\end_inset

So, the selector monad 
\begin_inset Formula $\text{Sel}^{Q,A}$
\end_inset

 has another transformer with the type 
\begin_inset Formula $T_{2}^{M,A}\triangleq(A\rightarrow M^{Q})\rightarrow M^{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The transformers 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 cannot be equivalent because the transformer 
\begin_inset Formula $T_{1}$
\end_inset

 is covariant in the type parameter 
\begin_inset Formula $M$
\end_inset

 while 
\begin_inset Formula $T_{2}$
\end_inset

 is not.
 Since the transformer 
\begin_inset Formula $T_{2}$
\end_inset

 is incomplete (it lacks runners and a base lift), it may be preferable
 to use the transformer 
\begin_inset Formula $T_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
Further examples of monads with several transformers are found via the codensity
 monad transformer (
\begin_inset Formula $T_{\text{Cod}^{F}}^{M,A}$
\end_inset

).
 For some 
\begin_inset Formula $F$
\end_inset

, the type constructor 
\begin_inset Formula $\text{Cod}^{F,\bullet}$
\end_inset

 is equivalent to a simpler monad 
\begin_inset Formula $G^{\bullet}$
\end_inset

 that already has a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 transformer.
 For instance, 
\begin_inset Formula $\text{Cod}^{F,\bullet}\cong G^{\bullet}$
\end_inset

 when 
\begin_inset Formula $F^{A}=G^{A}=A$
\end_inset

 (by the covariant Yoneda identity); when 
\begin_inset Formula $F^{A}=R\rightarrow A$
\end_inset

, 
\begin_inset Formula $G^{A}=\text{State}^{R,A}$
\end_inset

 (see the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-inC-outC"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c)); and when 
\begin_inset Formula $F^{A}\triangleq A\rightarrow A$
\end_inset

, 
\begin_inset Formula $G^{A}=\text{List}^{A}$
\end_inset

 (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

(a)).
 In this way, alternative monad transformers for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Id
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monads are obtained as 
\begin_inset Formula $T_{\text{Cod}^{F}}^{M,A}$
\end_inset

 with the given choices of 
\begin_inset Formula $F$
\end_inset

.
 
\end_layout

\begin_layout Standard
Even though 
\begin_inset Formula $\text{Cod}^{F}$
\end_inset

 is equivalent to 
\begin_inset Formula $G$
\end_inset

, the codensity transformer (
\begin_inset Formula $T_{\text{Cod}^{F}}^{M,A}$
\end_inset

) will be usually 
\emph on
not
\emph default
 equivalent to 
\begin_inset Formula $G$
\end_inset

's 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 transformer (
\begin_inset Formula $T_{G}$
\end_inset

) because 
\begin_inset Formula $T_{\text{Cod}^{F}}^{M,A}$
\end_inset

 is not covariant in the foreign monad 
\begin_inset Formula $M$
\end_inset

, while many 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 transformers are.
 (For instance, the standard transformers for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Id
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monads are covariant in the foreign monad.) Also, 
\begin_inset Formula $T_{\text{Cod}^{F}}^{M,A}$
\end_inset

 is an incomplete transformer: it lacks a foreign runner, and its base runner
 fails the composition law of monad morphisms.
\end_layout

\begin_layout Standard
More examples of alternative transformers are found by considering Church-encode
d free typeclasses.
 Given a typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC
\end_layout

\end_inset

 and a type 
\begin_inset Formula $A$
\end_inset

, we define the Church-encoded free typeclass 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC
\end_layout

\end_inset

 on 
\begin_inset Formula $A$
\end_inset


\begin_inset space ~
\end_inset

as:
\begin_inset Formula 
\[
\text{FTC}^{A}\triangleq\forall X^{:\text{TC}}.\,(A\rightarrow X)\rightarrow X
\]

\end_inset

(see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Church-encodings-for-free-P-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

)***.
 Inserting a foreign monad 
\begin_inset Formula $M$
\end_inset

 as in the codensity transformer, we define:
\begin_inset Formula 
\[
T_{\text{FTC}}^{M,A}\triangleq\forall X^{:\text{TC}}.\,(A\rightarrow M^{X})\rightarrow M^{X}\quad.
\]

\end_inset

Note that 
\begin_inset Formula $\text{FTC}^{A}$
\end_inset

 is a monad (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-with-quantifier"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For some typeclasses, 
\begin_inset Formula $\text{FTC}^{A}$
\end_inset

 is equivalent to a simpler monad 
\begin_inset Formula $G^{A}$
\end_inset

.
 Specific examples are found with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC
\end_layout

\end_inset


\begin_inset Formula $\,=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Monoid
\end_layout

\end_inset

 and 
\begin_inset Formula $G$
\end_inset


\begin_inset Formula $\,=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 (see Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-additional-16-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

(e)), and with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TC
\end_layout

\end_inset


\begin_inset Formula $\,=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Semigroup
\end_layout

\end_inset

 and 
\begin_inset Formula $G$
\end_inset


\begin_inset Formula $\,=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

.
 In these cases,  the type constructor 
\begin_inset Formula $T_{\text{FTC}}^{M,A}$
\end_inset

 gives a new transformer for the monad 
\begin_inset Formula $G$
\end_inset

 that is not equivalent to 
\begin_inset Formula $G$
\end_inset

's 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 transformer.
\end_layout

\begin_layout Section
Further developments
\end_layout

\begin_layout Subsection
Some properties of monad morphisms
\end_layout

\begin_layout Standard
In this section we prove some properties of monad morphisms needed in this
 chapter.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-M-to-M-times-M-is-monadic-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-M-to-M-times-M-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monad 
\begin_inset Formula $M$
\end_inset

, the function 
\begin_inset Formula $\Delta:M^{A}\rightarrow M^{A}\times M^{A}$
\end_inset

 is a monad morphism between monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $M\times M$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use the definition of the product monad.
 The method 
\begin_inset Formula $\text{pu}_{M\times M}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
x\triangleright\text{pu}_{M\times M}=\text{pu}_{M}(x)\times\text{pu}_{M}(x)=x\triangleright\text{pu}_{M}\bef\Delta\quad,
\]

\end_inset

which proves the identity law for 
\begin_inset Formula $\Delta$
\end_inset

 (namely, 
\begin_inset Formula $\text{pu}_{M}\bef\Delta=\text{pu}_{M\times M}$
\end_inset

).
 To verify 
\begin_inset Formula $\Delta$
\end_inset

's composition law, 
\begin_inset Formula 
\[
\text{ftn}_{M}\bef\Delta=\Delta^{\uparrow M}\bef\Delta\bef\text{ftn}_{M\times M}\quad,
\]

\end_inset

we use the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monad-product-flatten-def-ftn"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $\text{ftn}_{M\times M}$
\end_inset

:
\begin_inset Formula 
\[
\text{ftn}_{M\times M}:M^{M^{\bullet}\times M^{\bullet}}\times M^{M^{\bullet}\times M^{\bullet}}\rightarrow M^{\bullet}\times M^{\bullet}=\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow M}\bef\text{ftn}_{M}\big)\quad,
\]

\end_inset

and compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{ftn}_{M}\bef\Delta:\quad & \gunderline{\Delta^{\uparrow M}\bef\Delta}\bef\text{ftn}_{M\times M}\\
\text{naturality law of }\Delta:\quad & =\Delta\bef\big(\Delta^{\uparrow M}\boxtimes\Delta^{\uparrow M}\big)\bef\gunderline{\text{ftn}_{M\times M}}\\
\text{definition of }\text{ftn}_{M\times M}:\quad & =\Delta\bef\big(\Delta^{\uparrow M}\boxtimes\Delta^{\uparrow M}\big)\bef\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow M}\bef\text{ftn}_{M}\big)\\
\text{composition law of }\boxtimes:\quad & =\Delta\bef\big(\gunderline{\Delta^{\uparrow M}\bef\pi_{1}^{\uparrow M}}\bef\text{ftn}_{M}\big)\boxtimes\big(\gunderline{\Delta^{\uparrow M}\bef\pi_{2}^{\uparrow M}}\bef\text{ftn}_{M}\big)\\
\text{simplify }\Delta\bef\pi_{i}=\text{id}:\quad & =\Delta\bef\text{ftn}_{M}\boxtimes\text{ftn}_{M}\\
\text{duplication law of }\Delta:\quad & =\text{ftn}_{M}\bef\Delta\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-pair-product-of-monadic-morphisms"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monads 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 and monad morphisms 
\begin_inset Formula $\phi:K\leadsto M$
\end_inset

 and 
\begin_inset Formula $\chi:L\leadsto N$
\end_inset

, the pair product 
\begin_inset Formula $\phi\boxtimes\chi:K\times L\leadsto M\times N$
\end_inset

 is a monad morphism between the monads 
\begin_inset Formula $K\times L$
\end_inset

 and 
\begin_inset Formula $M\times N$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The definitions of 
\begin_inset Formula $\text{pu}_{K\times L}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{M\times N}$
\end_inset

 are:
\begin_inset Formula 
\[
\text{pu}_{K\times L}=\text{pu}_{K}\boxtimes\text{pu}_{L}\quad,\quad\quad\text{pu}_{M\times N}=\text{pu}_{M}\boxtimes\text{pu}_{N}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law for 
\begin_inset Formula $\phi\boxtimes\chi$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M\times N}:\quad & \gunderline{\text{pu}_{K\times L}}\bef\phi\boxtimes\chi\\
\text{definition of }\text{pu}_{K\times L}:\quad & =\text{pu}_{K}\boxtimes\text{pu}_{L}\bef\phi\boxtimes\chi\\
\text{composition law of }\boxtimes:\quad & =(\gunderline{\text{pu}_{K}\bef\phi})\boxtimes(\gunderline{\text{pu}_{L}\bef\chi})\\
\text{identity laws of }\phi,\chi:\quad & =\text{pu}_{M}\boxtimes\text{pu}_{N}=\text{pu}_{M\times N}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law for 
\begin_inset Formula $\phi\boxtimes\chi$
\end_inset

, we use the definitions:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{K\times L}=\big(\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\big)^{:K^{K^{\bullet}\times L^{\bullet}}\rightarrow K^{\bullet}}\boxtimes\big(\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\big)^{:L^{K^{\bullet}\times L^{\bullet}}\rightarrow L^{\bullet}}\quad,\\
 & \text{ftn}_{M\times N}=\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\quad.
\end{align*}

\end_inset

Denote 
\begin_inset Formula $\psi\triangleq\phi\boxtimes\chi$
\end_inset

 for brevity.
 The required law is:
\begin_inset Formula 
\[
\text{ftn}_{K\times L}\bef\psi=\psi^{\uparrow(K\times L)}\bef\psi\bef\text{ftn}_{M\times N}\quad.
\]

\end_inset

The left-hand side of this law is:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{K\times L}\bef\psi\\
\text{definition of }\text{ftn}_{M\times N}:\quad & =\big(\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\big)\boxtimes\big(\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\big)\bef\phi\boxtimes\chi\\
\text{composition law of }\boxtimes:\quad & =\big(\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi\big)\boxtimes\big(\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\bef\chi\big)
\end{align*}

\end_inset

The right-hand side is:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\psi^{\uparrow(K\times L)}}\bef\psi\bef\text{ftn}_{M\times N}\\
\text{lifting to }K\times L:\quad & =\big(\psi^{\uparrow K}\boxtimes\psi^{\uparrow L}\big)\bef(\phi\boxtimes\chi)\bef\gunderline{\text{ftn}_{M\times N}}\\
\text{definition of }\text{ftn}_{M\times N}:\quad & =\psi^{\uparrow K}\boxtimes\psi^{\uparrow L}\bef\phi\boxtimes\chi\bef\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\\
\text{composition law of }\boxtimes:\quad & =\big(\psi^{\uparrow K}\bef\phi\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)\boxtimes\big(\psi^{\uparrow L}\bef\chi\bef\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\quad.
\end{align*}

\end_inset

Now rewrite the first part of the pair product in the last line:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\psi^{\uparrow K}\bef\phi}\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\\
\text{naturality law of }\phi:\quad & =\phi\bef\gunderline{\psi^{\uparrow M}\bef\pi_{1}^{\uparrow M}}\bef\text{ftn}_{M}\\
\text{projection law of }\pi_{1}:\quad & =\gunderline{\phi\bef\pi_{1}^{\uparrow M}}\bef\phi^{\uparrow M}\bef\text{ftn}_{M}\\
\text{naturality law of }\phi:\quad & =\pi_{1}^{\uparrow K}\bef\gunderline{\phi\bef\phi^{\uparrow M}\bef\text{ftn}_{M}}\\
\text{composition law of }\phi:\quad & =\pi_{1}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi\quad.
\end{align*}

\end_inset

In the same way, we find that the second part of the pair product is 
\begin_inset Formula $\pi_{2}^{\uparrow L}\bef\text{ftn}_{L}\bef\chi$
\end_inset

, and so the composition law holds.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-projection-is-monadic-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-projection-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, the projection function 
\begin_inset Formula $\pi_{1}:M\times N\leadsto M$
\end_inset

 is a monad morphism.
 Same for 
\begin_inset Formula $\pi_{2}:M\times N\leadsto N$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
It is sufficient to verify the laws for 
\begin_inset Formula $\pi_{1}$
\end_inset

; the proof for 
\begin_inset Formula $\pi_{2}$
\end_inset

 will be similar.
 The identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}:\quad & \text{pu}_{M\times N}\bef\pi_{1}\\
\text{definition of }\text{pu}_{M\times N}:\quad & =(\text{pu}_{M}\boxtimes\text{pu}_{N})\bef\pi_{1}\\
\text{projection law of }\pi_{1}:\quad & =\text{pu}_{M}\quad.
\end{align*}

\end_inset

The composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\pi_{1}\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}:\quad & \gunderline{\text{ftn}_{M\times N}}\bef\pi_{1}\\
\text{definition of }\text{ftn}_{M\times N}:\quad & =\gunderline{\big(\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\big)}\boxtimes\big(\pi_{2}^{\uparrow N}\bef\text{ftn}_{N}\big)\bef\gunderline{\pi_{1}}\\
\text{projection law of }\pi_{1}:\quad & =\pi_{1}\bef\pi_{1}^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-product-swap-is-monadic-morphism"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-product-swap-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

, the swapping function 
\begin_inset Formula $\sigma:M\times N\leadsto N\times M$
\end_inset

 is a monad morphism.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The code for 
\begin_inset Formula $\sigma$
\end_inset

 can be written as a combination of other functions: 
\begin_inset Formula $\sigma=\Delta\bef\left(\pi_{2}\boxtimes\pi_{1}\right)$
\end_inset

.
 The functions 
\begin_inset Formula $\Delta$
\end_inset

, 
\begin_inset Formula $\pi_{1}$
\end_inset

, and 
\begin_inset Formula $\pi_{2}$
\end_inset

 are monad morphisms by Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-M-to-M-times-M-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-projection-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The function product 
\begin_inset Formula $\pi_{1}\boxtimes\pi_{2}$
\end_inset

 is a monad morphism by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pair-product-of-monadic-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 So 
\begin_inset Formula $\sigma$
\end_inset

 is a composition of monad morphisms; by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $\sigma$
\end_inset

 is a monad morphism.
\end_layout

\begin_layout Subsection
Does a composition of rigid monads have a 
\family typewriter
swap
\family default
 function?
\begin_inset CommandInset label
LatexCommand label
name "subsec:Does-a-composition-have-swap"

\end_inset


\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-monad-construction-1-choice"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we proved the monad transformer laws for 
\begin_inset Formula $T_{R}^{M}\triangleq R\circ M$
\end_inset

 by using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function with type signature:
\begin_inset Formula 
\[
\text{sw}_{R,M}:M\circ R\leadsto R\circ M\quad,
\]

\end_inset

and proving its special laws.
 If 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 are both rigid monads then the composed monad 
\begin_inset Formula $R\circ S$
\end_inset

 is also rigid.
 Does 
\begin_inset Formula $T\triangleq R\circ S$
\end_inset

 have a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function:
\begin_inset Formula 
\[
\text{sw}_{T,M}:M\circ R\circ S\leadsto R\circ S\circ M\quad,
\]

\end_inset

satisfying all the required special laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

? If so, we may be able to find a simpler definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 for the monad stack 
\begin_inset Formula $R\circ S\circ M$
\end_inset

.
 Let us briefly investigate this question.
 However, keep in mind that the absence of a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function will not invalidate the composition properties of rigid monad
 stacks: those properties were established without assuming the existence
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 for the composed monad.
\end_layout

\begin_layout Standard
It turns out that we need yet another law for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

3-swap
\begin_inset Quotes erd
\end_inset

 law) if we wish to prove that the composed monad also has a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-3-swap-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-3-swap-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that two monads 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 are rigid and both have 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 functions (
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

) satisfying the 
\begin_inset Formula $8$
\end_inset

 laws listed in Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Additionally, assume that the functions 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

 obey the 
\series bold
3-swap law
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!3-swap law
\end_layout

\end_inset


\series default
 with respect to an arbitrary monad 
\begin_inset Formula $M$
\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{2pc}M^{S^{R^{A}}}\ar[d]\sb(0.45){\text{sw}_{S,M}}\ar[r]\sp(0.5){\text{sw}_{R,S}^{\uparrow M}} & M^{R^{S^{A}}}\ar[r]\sp(0.5){\text{sw}_{R,M}} & R^{M^{S^{A}}}\ar[d]\sp(0.4){\text{sw}_{S,M}^{\uparrow R}}\\
S^{M^{R^{A}}}\ar[r]\sp(0.5){\text{sw}_{R,M}^{\uparrow S}} & S^{R^{M^{A}}}\ar[r]\sp(0.5){\text{sw}_{R,S}} & R^{S^{M^{A}}}
}
\]

\end_inset


\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset Formula 
\begin{equation}
\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}=\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\text{sw}_{R,S}\quad.\label{eq:rigid-monad-3-swap-law}
\end{equation}

\end_inset

Then a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 function (
\begin_inset Formula $\text{sw}_{T,M}$
\end_inset

) also exists for the composed monad 
\begin_inset Formula $T\triangleq R\circ S$
\end_inset

, is defined by :
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc}M\circ R\circ S\ar[rd]\sb(0.45){\text{sw}_{T,M}\triangleq}\ar[r]\sp(0.5){\text{sw}_{R,M}} & R\circ M\circ S\ar[d]\sp(0.5){\text{sw}_{S,M}^{\uparrow R}}\\
 & R\circ S\circ M
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{sw}_{T,M}\triangleq\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\quad,\label{eq:3-swap-def-of-sw-T-M}
\end{equation}

\end_inset

and satisfies the same 
\begin_inset Formula $8$
\end_inset

 laws.
\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
We need to verify the 
\begin_inset Formula $8$
\end_inset

 laws for 
\begin_inset Formula $\text{sw}_{T,M}$
\end_inset

 (one naturality law, two identity laws, two interchange laws, and three
 monadic naturality laws), assuming that these 
\begin_inset Formula $8$
\end_inset

 laws hold for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

.
 In addition, we assume that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-monad-3-swap-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) holds, where 
\begin_inset Formula $M$
\end_inset

 is an arbitrary monad.
 The monad methods of 
\begin_inset Formula $T$
\end_inset

 are defined by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-pure-T-via-pure-L-and-pure-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-flatten-T-via-sw-and-flatten-L-M"
plural "false"
caps "false"
noprefix "false"

\end_inset

) after renaming 
\begin_inset Formula $L\triangleq R$
\end_inset

 and 
\begin_inset Formula $M\triangleq S$
\end_inset

:
\begin_inset Formula 
\begin{align}
\text{pu}_{T} & =\text{pu}_{S}\bef\text{pu}_{R}\quad,\label{eq:3-swap-pu-T-via-pu-R-S}\\
\text{ftn}_{T} & =\text{sw}_{R,S}^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.\label{eq:3-swap-ftn-T-via-sw-R-S}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
As usual, we do not need to verify the naturality law for 
\begin_inset Formula $\text{sw}_{T,M}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Identity laws
\end_layout

\begin_layout Standard
To verify the outer identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{T}:\quad & \text{pu}_{T}^{\uparrow M}\bef\text{sw}_{T,M}\\
\text{use Eqs.~(\ref{eq:3-swap-def-of-sw-T-M})-(\ref{eq:3-swap-pu-T-via-pu-R-S})}:\quad & =\text{pu}_{S}^{\uparrow M}\bef\gunderline{\text{pu}_{R}^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{outer identity law of }\text{sw}_{R,M}:\quad & =\text{pu}_{S}^{\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\text{sw}_{S,M}^{\uparrow R}}\\
\text{naturality law of }\text{pu}_{R}:\quad & =\gunderline{\text{pu}_{S}^{\uparrow M}\bef\text{sw}_{S,M}}\bef\text{pu}_{R}\\
\text{outer identity law of }\text{sw}_{S,M}:\quad & =\text{pu}_{S}\bef\text{pu}_{R}\\
\text{use Eq.~(\ref{eq:3-swap-pu-T-via-pu-R-S})}:\quad & =\text{pu}_{T}\quad.
\end{align*}

\end_inset

To verify the inner identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{M}^{\uparrow T}:\quad & \text{pu}_{M}\bef\gunderline{\text{sw}_{T,M}}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\gunderline{\text{pu}_{M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{inner identity law of }\text{sw}_{R,M}:\quad & =\text{pu}_{M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}=\big(\gunderline{\text{pu}_{M}\bef\text{sw}_{S,M}}\big)^{\uparrow R}\\
\text{inner identity law of }\text{sw}_{S,M}:\quad & =\text{pu}_{M}^{\gunderline{\uparrow S\uparrow R}}=\text{pu}_{M}^{\uparrow T}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Interchange laws
\end_layout

\begin_layout Standard
The outer interchange law is:
\begin_inset Formula 
\begin{equation}
\text{ftn}_{T}^{\uparrow M}\bef\text{sw}_{T,M}=\text{sw}_{T,M}\bef\text{sw}_{T,M}^{\uparrow T}\bef\text{ftn}_{T}\quad.\label{eq:3-swap-outer-interchange-T}
\end{equation}

\end_inset

We will use the outer interchange laws for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{ftn}_{R}^{\uparrow M}\bef\text{sw}_{R,M}=\text{sw}_{R,M}\bef\text{sw}_{R,M}^{\uparrow R}\bef\text{ftn}_{R}\quad,\label{eq:3-swap-outer-interchange-R}\\
 & \text{ftn}_{S}^{\uparrow M}\bef\text{sw}_{S,M}=\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}\bef\text{ftn}_{S}\quad.\label{eq:3-swap-outer-interchange-S}
\end{align}

\end_inset

Begin with the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-outer-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) since it is more complicated:
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{T,M}\bef\text{sw}_{T,M}^{\uparrow T}\bef\text{ftn}_{T}\\
\text{definitions}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\big(\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\big)^{\uparrow S\uparrow R}\bef\text{sw}_{R,S}^{\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{composition under }^{\uparrow R}:\quad & =\text{sw}_{R,M}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R\uparrow S}\bef\text{sw}_{R,S}}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{naturality law of }\text{sw}_{R,S}:\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{S,M}\bef\text{sw}_{R,M}^{\uparrow S}\bef\text{sw}_{R,S}}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{use Eq.~(\ref{eq:rigid-monad-3-swap-law})}:\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.
\end{align*}

\end_inset

In the last expression, all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

s are to the right of all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

s.
 So, we look to rewrite the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-outer-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) into the same form:
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{T}^{\uparrow M}\bef\text{sw}_{T,M}\\
\text{use Eqs.~(\ref{eq:3-swap-def-of-sw-T-M}), (\ref{eq:3-swap-ftn-T-via-sw-R-S})}:\quad & =\big(\text{sw}_{R,S}^{\uparrow R}\bef\text{ftn}_{R}\bef\gunderline{\text{ftn}_{S}^{\uparrow R}\big)^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{naturality law of }\text{sw}_{R,M}:\quad & =\text{sw}_{R,S}^{\uparrow R\uparrow M}\bef\gunderline{\text{ftn}_{R}^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{ftn}_{S}^{\uparrow M\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{use Eq.~(\ref{eq:3-swap-outer-interchange-R})}:\quad & =\text{sw}_{R,S}^{\uparrow R\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{R,M}^{\uparrow R}\bef\text{ftn}_{R}\bef\big(\gunderline{\text{ftn}_{S}^{\uparrow M}\bef\text{sw}_{S,M}}\big)^{\uparrow R}\\
\text{use Eq.~(\ref{eq:3-swap-outer-interchange-S})}:\quad & =\text{sw}_{R,M}\bef\text{sw}_{R,S}^{\uparrow M\uparrow R}\bef\text{sw}_{R,M}^{\uparrow R}\bef\gunderline{\text{ftn}_{R}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}}\bef\text{ftn}_{S}\big)^{\uparrow R}\\
\text{naturality law of }\text{ftn}_{R}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{R,S}^{\uparrow M\uparrow R}\bef\text{sw}_{R,M}^{\uparrow R}\bef\big(\text{sw}_{S,M}\bef\text{sw}_{S,M}^{\uparrow S}\big)^{\uparrow R\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{composition under }^{\uparrow R}:\quad & =\text{sw}_{R,M}\bef\big(\gunderline{\text{sw}_{R,S}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow S\uparrow R}}\big)^{\uparrow R}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\quad.
\end{align*}

\end_inset

Both sides of the outer interchange law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-outer-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are now equal.
\end_layout

\begin_layout Standard
The proof of the inner interchange law is simpler.
 The law says:
\begin_inset Formula 
\begin{equation}
\text{ftn}_{M}\bef\text{sw}_{T,M}=\text{sw}_{T,M}^{\uparrow M}\bef\text{sw}_{T,M}\bef\text{ftn}_{M}^{\uparrow T}\quad.\label{eq:3-swap-inner-interchange-T}
\end{equation}

\end_inset

We will use the inner interchange laws for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

:
\begin_inset Formula 
\begin{align}
 & \text{ftn}_{M}\bef\text{sw}_{R,M}=\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\text{ftn}_{M}^{\uparrow R}\quad,\label{eq:3-swap-inner-interchange-R}\\
 & \text{ftn}_{M}\bef\text{sw}_{S,M}=\text{sw}_{S,M}^{\uparrow M}\bef\text{sw}_{S,M}\bef\text{ftn}_{M}^{\uparrow S}\quad.\label{eq:3-swap-inner-interchange-S}
\end{align}

\end_inset

Begin with the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-inner-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{M}\bef\text{sw}_{T,M}=\gunderline{\text{ftn}_{M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\\
\text{use Eq.~(\ref{eq:3-swap-inner-interchange-R})}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\text{ftn}_{M}^{\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}}\\
\text{use Eq.~(\ref{eq:3-swap-inner-interchange-S}) under }^{\uparrow R}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\big(\text{sw}_{S,M}^{\uparrow M}\bef\text{sw}_{S,M}\bef\text{ftn}_{M}^{\uparrow S}\big)^{\uparrow R}}\\
\text{composition under }^{\uparrow R}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow M\uparrow R}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}}
\end{align*}

\end_inset

The right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:3-swap-inner-interchange-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is:
\begin_inset Formula 
\begin{align*}
 & \text{sw}_{T,M}^{\uparrow M}\bef\text{sw}_{T,M}\bef\text{ftn}_{M}^{\uparrow T}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\big(\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\big)^{\uparrow M}\bef\text{sw}_{R,M}}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}\\
\text{naturality law of }\text{sw}_{R,M}:\quad & =\text{sw}_{R,M}^{\uparrow M}\bef\gunderline{\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow M\uparrow R}}\bef\text{sw}_{S,M}^{\uparrow R}\bef\text{ftn}_{M}^{\uparrow S\uparrow R}\quad.
\end{align*}

\end_inset

The right-hand side is now equal to the left-hand side.
\end_layout

\begin_layout Paragraph
Monadic naturality laws
\end_layout

\begin_layout Standard
We need to verify that the following three laws:
\begin_inset Formula 
\[
\text{sw}_{T,\text{Id}}=\text{id}\quad,\quad\quad\text{sw}_{T,M}\bef\phi^{\uparrow T}=\phi\bef\text{sw}_{T,N}\quad,\quad\quad\text{sw}_{T,M}\bef\theta=\theta^{\uparrow M}\quad,
\]

\end_inset

hold for any monad morphisms 
\begin_inset Formula $\phi:M\leadsto N$
\end_inset

 and 
\begin_inset Formula $\theta:T\leadsto\text{Id}$
\end_inset

.
 We may assume that these laws already hold for 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

 and 
\begin_inset Formula $\text{sw}_{S,M}$
\end_inset

.
\end_layout

\begin_layout Standard
To verify the first law, write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{sw}_{T,\text{Id}}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\text{sw}_{R,\text{Id}}\bef\text{sw}_{S,\text{Id}}^{\uparrow R}\\
\text{first law of }\text{sw}_{R,\text{Id}}\text{ and }\text{sw}_{S,\text{Id}}:\quad & =\text{id}\bef\text{id}^{\uparrow R}=\text{id}\quad.
\end{align*}

\end_inset

To verify the second law, write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\phi\bef\text{sw}_{T,N}:\quad & \text{sw}_{T,M}\bef\phi^{\uparrow T}\\
\text{use Eq.~(\ref{eq:3-swap-def-of-sw-T-M})}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\phi^{\uparrow S\uparrow R}}\\
\text{second law of }\text{sw}_{S,M}\text{ under }^{\uparrow R}:\quad & =\gunderline{\text{sw}_{R,M}\bef\big(\phi}\bef\text{sw}_{S,N}\big)^{\uparrow R}\\
\text{second law of }\text{sw}_{R,M}:\quad & =\phi\bef\gunderline{\text{sw}_{R,N}\bef\text{sw}_{S,N}^{\uparrow R}}=\phi\bef\gunderline{\text{sw}_{T,N}}\quad.
\end{align*}

\end_inset

To verify the third law, we begin with the left-hand side:
\begin_inset Formula 
\[
\text{sw}_{T,M}\bef\theta=\text{sw}_{R,M}\bef\text{sw}_{S,M}^{\uparrow R}\bef\theta\quad.
\]

\end_inset

At this point, no relationship or law applies to the intermediate expression
 
\begin_inset Formula $\text{sw}_{S,M}^{\uparrow R}\bef\theta$
\end_inset

, so we need additional information to proceed.
 By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-base-runner-for-composed-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (proved below), we can express 
\begin_inset Formula $\theta=\theta_{R}\bef\theta_{S}$
\end_inset

 with some monad morphisms 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

.
 So, we may use 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 with the monad morphism laws for 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, in particular with the third law:
\begin_inset Formula 
\[
\text{sw}_{R,M}\bef\theta_{R}=\theta_{R}^{\uparrow M}\quad,\quad\quad\text{sw}_{S,M}\bef\theta_{S}=\theta_{S}^{\uparrow M}\quad.
\]

\end_inset

This allows us to finish the proof of the third monadic naturality law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\theta^{\uparrow M}:\quad & \text{sw}_{T,M}\bef\gunderline{\theta}\\
\text{use Statement~\ref{subsec:Statement-base-runner-for-composed-monad}}:\quad & =\text{sw}_{R,M}\bef\gunderline{\text{sw}_{S,M}^{\uparrow R}\bef\theta_{R}}\bef\theta_{S}\\
\text{naturality law of }\theta_{R}:\quad & =\gunderline{\text{sw}_{R,M}\bef\theta_{R}}\bef\gunderline{\text{sw}_{S,M}\bef\theta_{S}}\\
\text{third law of }R\text{ and }S:\quad & =\theta_{R}^{\uparrow M}\bef\theta_{S}^{\uparrow M}=\theta^{\uparrow M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-base-runner-for-composed-monad"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-base-runner-for-composed-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $R$
\end_inset

 be a rigid monad with a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method 
\begin_inset Formula $\text{sw}_{R,M}$
\end_inset

.
 Let 
\begin_inset Formula $S$
\end_inset

 be any monad.
 Then any monad morphism 
\begin_inset Formula $\theta:R\circ S\leadsto\text{Id}$
\end_inset

 can be expressed as 
\begin_inset Formula $\theta=\theta_{R}\bef\theta_{S}$
\end_inset

 by defining the functions:
\begin_inset Formula 
\[
\theta_{R}\triangleq\text{pu}_{S}^{\uparrow R}\bef\theta\quad,\quad\quad\theta_{S}\triangleq\text{pu}_{R}\bef\theta\quad,
\]

\end_inset

which are monad morphisms.
 So, any runner 
\begin_inset Formula $\theta$
\end_inset

 for the composed monad 
\begin_inset Formula $R\circ S$
\end_inset

 can be written as a function composition of some runners 
\begin_inset Formula $\theta_{R}:R\leadsto\text{Id}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}:S\leadsto\text{Id}$
\end_inset

 for the monads 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
How can we obtain 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 from the given runner 
\begin_inset Formula $\theta$
\end_inset

? Note that 
\begin_inset Formula $\theta$
\end_inset

 runs the operations of both monads 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, while 
\begin_inset Formula $\theta_{R}$
\end_inset

 runs only the operations of 
\begin_inset Formula $R$
\end_inset

.
 To obtain 
\begin_inset Formula $\theta_{R}:R\leadsto\text{Id}$
\end_inset

 from 
\begin_inset Formula $\theta:R\circ S\leadsto\text{Id}$
\end_inset

, we need to prepend a function of type 
\begin_inset Formula $R\leadsto R\circ S$
\end_inset

.
 A suitable function of that type is:
\begin_inset Formula 
\[
\text{pu}_{S}^{\uparrow R}:R^{A}\rightarrow R^{S^{A}}\quad.
\]

\end_inset

So, 
\begin_inset Formula $\theta_{R}=\text{pu}_{S}^{\uparrow R}\bef\theta$
\end_inset

 has the correct type signature, 
\begin_inset Formula $R^{A}\rightarrow A$
\end_inset

.
 Similarly, 
\begin_inset Formula $\theta_{S}=\text{pu}_{R}\bef\theta$
\end_inset

 has the correct type signature, 
\begin_inset Formula $S^{A}\rightarrow A$
\end_inset

.
 So, we can obtain 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 from the given runner 
\begin_inset Formula $\theta$
\end_inset

 as:
\begin_inset Formula 
\[
\theta_{R}\triangleq\text{pu}_{S}^{\uparrow R}\bef\theta\quad,\quad\quad\theta_{S}\triangleq\text{pu}_{R}\bef\theta\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{S}^{\uparrow R}$
\end_inset

 are the foreign and base lifts of the transformer 
\begin_inset Formula $T_{R}^{S}=R\circ S$
\end_inset

, Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-outside-transformer-swap-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{S}^{\uparrow R}$
\end_inset

 are monad morphisms.
 Since the composition of monad morphisms is again a monad morphism (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monadic-morphism-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we see that 
\begin_inset Formula $\theta_{R}$
\end_inset

 and 
\begin_inset Formula $\theta_{S}$
\end_inset

 are monad morphisms.
\end_layout

\begin_layout Standard
It remains to verify that 
\begin_inset Formula $\theta=\theta_{R}\bef\theta_{S}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\theta:\quad & \theta_{R}\bef\theta_{S}=\text{pu}_{S}^{\uparrow R}\bef\gunderline{\theta\bef\text{pu}_{R}}\bef\theta\\
\text{naturality law of }\theta:\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\gunderline{\uparrow T}}\bef\theta\bef\theta=\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\theta\bef\theta}\\
\text{composition law of }\theta:\quad & =\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\text{ftn}_{T}\bef\theta}\quad.
\end{align*}

\end_inset

The last line differs from the required result (
\begin_inset Formula $\theta$
\end_inset

) by the function 
\begin_inset Formula $\text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\text{ftn}_{T}$
\end_inset

.
 We will finish the proof if we show that this function is equal to an identity
 function:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{pu}_{S}^{\uparrow R}\bef\text{pu}_{R}^{\uparrow S\uparrow R}\bef\gunderline{\text{ftn}_{T}}\\
\text{use Eq.~(\ref{eq:def-flatten-T-via-sw-and-flatten-L-M})}:\quad & =\text{pu}_{S}^{\uparrow R}\bef\gunderline{\text{pu}_{R}^{\uparrow S\uparrow R}\bef\text{sw}_{R,S}^{\uparrow R}}\bef\text{ftn}_{R}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{outer-identity law of }\text{sw}_{R,S}:\quad & =\text{pu}_{S}^{\uparrow R}\bef\gunderline{\text{pu}_{R}^{\uparrow R}\bef\text{ftn}_{R}}\bef\text{ftn}_{S}^{\uparrow R}\\
\text{identity laws of }R\text{ and }S:\quad & =\gunderline{\text{pu}_{S}^{\uparrow R}\bef\text{ftn}_{S}^{\uparrow R}}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Rigid functors and their properties
\begin_inset CommandInset label
LatexCommand label
name "subsec:Rigid-functors"

\end_inset


\end_layout

\begin_layout Standard
Some properties of rigid monads can be extended to a (possibly) larger class
 of rigid functors.
 We begin with a definition of a rigid functor that, unlike the definition
 of rigid monads (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:transformers-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

), does not refer to monad transformers.
\end_layout

\begin_layout Paragraph
Definition 
\end_layout

\begin_layout Standard
A functor 
\begin_inset Formula $R$
\end_inset

 is 
\series bold
rigid
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
rigid functors
\end_layout

\end_inset

 if there exists a natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

) with type signature:
\begin_inset Formula 
\[
\text{fi}_{R}:(A\rightarrow R^{B})\rightarrow R^{A\rightarrow B}\quad,
\]

\end_inset

satisfying the nondegeneracy law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) shown below.
\end_layout

\begin_layout Standard
Not all functors admit a natural transformation with the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

.
 For example, the functor 
\begin_inset Formula $F^{A}\triangleq Z+A$
\end_inset

 is not rigid because the required type signature,
\begin_inset Formula 
\[
\text{fi}_{F}:\left(A\rightarrow Z+B\right)\rightarrow Z+\left(A\rightarrow B\right)\quad,
\]

\end_inset

cannot be implemented as a natural transformation.
 However, any functor 
\begin_inset Formula $R$
\end_inset

 admits the opposite natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseOut
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

):
\begin_inset Formula 
\begin{equation}
\text{fo}_{R}:R^{A\rightarrow B}\rightarrow A\rightarrow R^{B}\quad,\quad\quad\text{fo}\left(r\right)\triangleq a\rightarrow r\triangleright\big(f^{:A\rightarrow B}\rightarrow f\left(a\right)\big)^{\uparrow R}\quad.\label{eq:fuseOut-def}
\end{equation}

\end_inset

The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

 must additionally satisfy the nondegeneracy law:
\begin_inset Formula 
\begin{equation}
\text{fi}_{R}\bef\text{fo}_{R}=\text{id}^{:(A\rightarrow R^{B})\rightarrow(A\rightarrow R^{B})}\quad.\label{eq:rigid-non-degeneracy-law}
\end{equation}

\end_inset

The opposite relation does not hold in general: 
\begin_inset Formula $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$
\end_inset

 (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-fo-fi-not-id"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The next two statements show some use cases for rigid functors.
 
\end_layout

\begin_layout Standard
The first use case is a generalization of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 that can handle multiple 
\begin_inset Formula $M$
\end_inset

-effects at once.
 As a motivation, consider a given value 
\begin_inset Formula $m^{:M^{A}}$
\end_inset

 and two Kleisli functions having the same type signature, 
\begin_inset Formula $f_{1}:A\rightarrow M^{B}$
\end_inset

 and 
\begin_inset Formula $f_{2}:A\rightarrow M^{B}$
\end_inset

.
 We may apply 
\begin_inset Formula $\text{flm}_{M}(f_{1})$
\end_inset

 and 
\begin_inset Formula $\text{flm}_{M}(f_{2})$
\end_inset

 to 
\begin_inset Formula $m$
\end_inset

 and obtain two different values of type 
\begin_inset Formula $M^{B}$
\end_inset

.
 This computation can be written as:
\begin_inset Formula 
\[
\big(m\triangleright\text{flm}_{M}(f_{1})\big)\times\big(m\triangleright\text{flm}_{M}(f_{2})\big):M^{B}\times M^{B}\quad.
\]

\end_inset

To express this computation in a different but equivalent way, we define
 a new function 
\begin_inset Formula $f$
\end_inset

 as:
\begin_inset Formula 
\[
f:A\rightarrow M^{B}\times M^{B}\quad,\quad\quad f\triangleq\Delta\bef(f_{1}\boxtimes f_{2})\quad,
\]

\end_inset

and a new 
\begin_inset Quotes eld
\end_inset

double-valued 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 as:
\begin_inset Formula 
\[
\text{flm2}_{M}:(A\rightarrow M^{B}\times M^{B})\rightarrow M^{A}\rightarrow M^{B}\times M^{B}\quad,\quad\text{flm2}_{M}\triangleq f\rightarrow\Delta\bef\big(\text{flm}_{M}(f\bef\pi_{1})\boxtimes\text{flm}_{M}(f\bef\pi_{2})\big)\quad.
\]

\end_inset

It is clear that the same computation can be extended to a product of any
 number of 
\begin_inset Formula $M$
\end_inset

's.
 The general version of the 
\begin_inset Quotes eld
\end_inset

multi-valued 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a situation when the collection of 
\begin_inset Formula $M$
\end_inset

-effects is described by a rigid functor 
\begin_inset Formula $R$
\end_inset

.
 The example just shown corresponds to 
\begin_inset Formula $R^{A}\triangleq A\times A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-multi-flatMap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-multi-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any rigid functor 
\begin_inset Formula $R$
\end_inset

 and a monad 
\begin_inset Formula $M$
\end_inset

, there exists an 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $R$
\end_inset

-valued 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\text{rflm}_{M,R}:(A\rightarrow R^{M^{B}})\rightarrow M^{A}\rightarrow R^{M^{B}}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Using 
\begin_inset Formula $R$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

 method, we can convert a value of type 
\begin_inset Formula $A\rightarrow R^{M^{B}}$
\end_inset

 into a value of type 
\begin_inset Formula $R^{A\rightarrow M^{B}}$
\end_inset

.
 After that, we can use 
\begin_inset Formula $M$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{rflm}_{M,R}\triangleq k^{:A\rightarrow R^{M^{B}}}\rightarrow m^{:M^{A}}\rightarrow k\triangleright\text{fi}_{R}\triangleright\big(q^{:A\rightarrow M^{B}}\rightarrow m\triangleright\text{flm}_{M}(q)\big)^{\uparrow R}\quad.
\]

\end_inset

This code does not assume that 
\begin_inset Formula $R$
\end_inset

 is a monad.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The second use case is a program transformation that introduces a wrapper
 into a given program.
 Assume that 
\begin_inset Formula $p^{:C}$
\end_inset

 is an expression that uses a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and we would like to replace 
\begin_inset Formula $f$
\end_inset

 by a function 
\begin_inset Formula $g^{:A\rightarrow R^{B}}$
\end_inset

.
 We may imagine that 
\begin_inset Formula $g$
\end_inset

 performs a computation similar to 
\begin_inset Formula $f$
\end_inset

 except it wraps the results in the functor 
\begin_inset Formula $R$
\end_inset

 (for instance, returning several results or using concurrency).
 Can we obtain a transformed program 
\begin_inset Formula $q:R^{C}$
\end_inset

 that has the same functionality as 
\begin_inset Formula $p$
\end_inset

 except for also returning a value wrapped in 
\begin_inset Formula $R$
\end_inset

? This is possible if 
\begin_inset Formula $R$
\end_inset

 is a rigid functor:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-monadic-refactor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-monadic-refactor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a rigid functor 
\begin_inset Formula $R$
\end_inset

, a program transformation can be implemented:
\begin_inset Formula 
\[
\text{refactor}:((A\rightarrow B)\rightarrow C)\rightarrow(A\rightarrow R^{B})\rightarrow R^{C}\quad.
\]

\end_inset

This function transforms a program 
\begin_inset Formula $p(f^{:A\rightarrow B}):C$
\end_inset

 into a program 
\begin_inset Formula $q(g^{:A\rightarrow R^{B}}):R^{C}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We use 
\begin_inset Formula $R$
\end_inset

's method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

 to convert a value of type 
\begin_inset Formula $A\rightarrow R^{B}$
\end_inset

 into a value of type 
\begin_inset Formula $R^{A\rightarrow B}$
\end_inset

.
 The rest of the computation is lifted to the functor 
\begin_inset Formula $R$
\end_inset

:
\begin_inset Formula 
\[
\text{refactor}\triangleq p^{:\left(A\rightarrow B\right)\rightarrow C}\rightarrow k^{:A\rightarrow R^{B}}\rightarrow k\triangleright\text{fi}_{R}\triangleright p^{\uparrow R}\quad.
\]

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
For a rigid functor 
\begin_inset Formula $R$
\end_inset

, the type signature of 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 is the same as the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 with respect to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad:
\begin_inset Formula 
\[
\text{sw}_{R,M}:M^{R^{A}}\rightarrow R^{M^{A}}\cong(Z\rightarrow R^{A})\rightarrow R^{Z\rightarrow A}\quad\text{ if we set }\quad M^{A}\triangleq Z\rightarrow A\quad.
\]

\end_inset

All rigid monads considered in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:transformers-rigid-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method.
 It turns out that all rigid monads (regardless of the existence of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

) are also rigid functors.
 While proving that statement, we will directly use the definition of rigid
 monads via the composed-outside monad transformer, without assuming a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-monads-are-rigid-functors"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-monads-are-rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Any rigid monad 
\begin_inset Formula $R$
\end_inset

 is a rigid functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
By assumption, the monad 
\begin_inset Formula $R$
\end_inset

 has a composed-outside monad transformer 
\begin_inset Formula $T_{R}^{M}=R\circ M$
\end_inset

 and the corresponding method 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 We can define the transformation 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 in the same way as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-swap-via-flatten"
plural "false"
caps "false"
noprefix "false"

\end_inset

) defined the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 method via 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

.
 To use that formula, we need to set the foreign monad 
\begin_inset Formula $M$
\end_inset

 to be the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad, 
\begin_inset Formula $M^{B}\triangleq A\rightarrow B$
\end_inset

 (with a fixed type 
\begin_inset Formula $A$
\end_inset

):
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{4pc}(A\rightarrow R^{B})\ar[r]\sp(0.5){\text{pu}_{M}^{\uparrow R\uparrow M}}\ar[d]\sb(0.5){\text{fi}_{R}\triangleq} & (A\rightarrow R^{A\rightarrow B})\ar[d]\sp(0.5){\text{pu}_{R}}\\
R^{A\rightarrow B} & R^{A\rightarrow R^{A\rightarrow B}}\ar[l]\sb(0.5){\text{ftn}_{T}}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{fi}_{R}(f^{:A\rightarrow R^{B}})=\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\text{ftn}_{T}\quad.\label{eq:rigid-monad-fuseIn-def}
\end{equation}

\end_inset

Since 
\begin_inset Formula $M$
\end_inset

 is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad with the environment type 
\begin_inset Formula $A$
\end_inset

, we define 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 and 
\begin_inset Formula $f^{\uparrow M}$
\end_inset

 by:
\begin_inset Formula 
\[
\text{pu}_{M}(x)=(\_^{:A}\rightarrow x)\quad,\quad\quad r^{:A\rightarrow X}\triangleright(f^{:X\rightarrow Y})^{\uparrow M}=r\bef f\quad.
\]

\end_inset

The type signature of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseOut
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{fo}_{R}:R^{A\rightarrow B}\rightarrow A\rightarrow R^{B}\quad,
\]

\end_inset

resembles 
\begin_inset Quotes eld
\end_inset

running
\begin_inset Quotes erd
\end_inset

 the composed monad 
\begin_inset Formula $R^{M^{B}}$
\end_inset

 into 
\begin_inset Formula $R^{B}$
\end_inset

, consuming a value of type 
\begin_inset Formula $A$
\end_inset

.
 Indeed, given a fixed value 
\begin_inset Formula $a^{:A}$
\end_inset

, we can 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad into the identity monad.
 The corresponding runner 
\begin_inset Formula $\phi_{a}^{:M\leadsto\text{Id}}$
\end_inset

 is:
\begin_inset Formula 
\begin{equation}
\phi_{a}^{:M^{X}\rightarrow X}\triangleq m^{:A\rightarrow X}\rightarrow m(a)\quad.\label{eq:runner-phi-def}
\end{equation}

\end_inset

So, we are inspired to use the runner law for the monad transformer 
\begin_inset Formula $T_{R}^{M}$
\end_inset

 (which holds since we assumed that 
\begin_inset Formula $T_{R}^{M}$
\end_inset

 satisfies all laws).
 The law says that the lifted runner 
\begin_inset Formula $\phi_{a}^{\uparrow R}$
\end_inset

 is a monad morphism 
\begin_inset Formula $T_{R}^{M}\leadsto T_{R}^{\text{Id}}\cong T_{R}^{M}\leadsto R$
\end_inset

.
 The monad morphism law for 
\begin_inset Formula $\phi_{a}^{\uparrow R}$
\end_inset

 is then written as:
\begin_inset Formula 
\begin{equation}
\text{ftn}_{T}\bef\phi_{a}^{\uparrow R}=\phi_{a}^{\uparrow R\uparrow M\uparrow R}\bef\phi_{a}^{\uparrow R}\bef\text{ftn}_{R}\quad.\label{eq:rigid-monad-is-rigid-functor-derivation1}
\end{equation}

\end_inset

How could we use this law to obtain Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

)? Compare Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fuseOut-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:runner-phi-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and derive the connection between the runner 
\begin_inset Formula $\phi_{a}$
\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseOut
\end_layout

\end_inset

 function (which exists for any functor 
\begin_inset Formula $R$
\end_inset

):
\begin_inset Formula 
\[
\text{fo}_{R}=r\rightarrow a\rightarrow r\triangleright\phi_{a}^{\uparrow R}\quad.
\]

\end_inset

Then we can complete the derivation by rewriting the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }m:\quad & m^{:M^{R^{B}}}\triangleright\text{fi}_{R}\bef\text{fo}_{R}=\left(m\triangleright\text{fi}_{R}\right)\triangleright\gunderline{\text{fo}_{R}}\\
\text{use Eq.~(\ref{eq:fuseOut-def})}:\quad & =a\rightarrow m\triangleright\gunderline{\text{fi}_{R}}\triangleright\phi_{a}^{\uparrow R}\\
\text{use Eq.~(\ref{eq:rigid-monad-fuseIn-def})}:\quad & =a\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\text{pu}_{R}\bef\gunderline{\text{ftn}_{T}\bef\phi_{a}^{\uparrow R}}\\
\text{use Eq.~(\ref{eq:rigid-monad-is-rigid-functor-derivation1})}:\quad & =a\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\gunderline{\text{pu}_{R}\bef\phi_{a}^{\uparrow R\uparrow M\uparrow R}\bef\phi_{a}^{\uparrow R}}\bef\text{ftn}_{R}\\
\text{naturality law of }\text{pu}_{R}:\quad & =a\rightarrow m\triangleright\text{pu}_{M}^{\uparrow R\uparrow M}\bef\phi_{a}^{\uparrow R\uparrow M}\bef\phi_{a}\bef\gunderline{\text{pu}_{R}\bef\text{ftn}_{R}}\\
\text{left identity law of }R:\quad & =a\rightarrow m\triangleright\gunderline{(\text{pu}_{M}\bef\phi_{a})}^{\uparrow R\uparrow M}\bef\phi_{a}\\
\text{monad morphism identity law of }\phi_{a}:\quad & =a\rightarrow m\triangleright\gunderline{\phi_{a}}\\
\text{definition~(\ref{eq:runner-phi-def}) of }\phi_{a}:\quad & =a\rightarrow m(a)=m\quad.
\end{align*}

\end_inset

Here we used the monad morphism identity law for 
\begin_inset Formula $\phi_{a}$
\end_inset

:
\begin_inset Formula 
\[
\text{pu}_{M}\bef\phi_{a}=\big(x\rightarrow(\_\rightarrow x)\big)\bef(m\rightarrow a\triangleright m)=\left(x\rightarrow a\triangleright(\_\rightarrow x)\right)=\left(x\rightarrow x\right)=\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-fo-fi-not-id"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-fo-fi-not-id"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Show that the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseIn
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fuseOut
\end_layout

\end_inset

 are not always inverses: for some 
\begin_inset Formula $R$
\end_inset

,
\begin_inset Formula 
\[
\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Consider the rigid monads 
\begin_inset Formula $P^{A}\triangleq Z\rightarrow A$
\end_inset

 and 
\begin_inset Formula $R^{A}\triangleq\left(A\rightarrow Q\right)\rightarrow A$
\end_inset

, where 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 are fixed types.
 Since all rigid monads are rigid functors, it follows that the monads 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 have methods 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

, 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

, 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

, 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

 satisfying the nondegeneracy law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It turns out that additionally 
\begin_inset Formula $\text{fo}_{P}\bef\text{fi}_{P}=\text{id}$
\end_inset

, i.e., the methods 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

 
\emph on
are
\emph default
 inverses of each other, but 
\begin_inset Formula $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $\text{fo}_{P}\bef\text{fi}_{P}=\text{id}$
\end_inset

, consider the type signatures of 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{fo}_{P} & :P^{A\rightarrow B}\rightarrow A\rightarrow P^{B}\cong\left(Z\rightarrow A\rightarrow B\right)\rightarrow\left(A\rightarrow Z\rightarrow B\right)\quad,\\
\text{fi}_{P} & :(A\rightarrow P^{B})\rightarrow P^{A\rightarrow B}\cong\left(A\rightarrow Z\rightarrow B\right)\rightarrow\left(Z\rightarrow A\rightarrow B\right)\quad.
\end{align*}

\end_inset

Fully parametric implementations of these functions are derived uniquely
 from type signatures.
 The functions 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

 switch the curried arguments of types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 of a function that returns values of type 
\begin_inset Formula $B$
\end_inset

.
 It is clear that these two functions are inverses of each other.
 To show this directly, consider the type signature of 
\begin_inset Formula $\text{fo}_{P}\bef\text{fi}_{P}$
\end_inset

:
\begin_inset Formula 
\[
\big(\text{fo}_{P}\bef\text{fi}_{P}\big):P^{A\rightarrow B}\rightarrow P^{A\rightarrow B}\cong\left(Z\rightarrow A\rightarrow B\right)\rightarrow\left(Z\rightarrow A\rightarrow B\right)\quad.
\]

\end_inset

There is only one fully parametric implementation for this type signature:
 the identity function 
\begin_inset Formula $\text{id}^{Z\rightarrow A\rightarrow B}$
\end_inset

.
\end_layout

\begin_layout Standard
For the monad 
\begin_inset Formula $R$
\end_inset

, the type signatures of 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

 are:
\begin_inset Formula 
\begin{align*}
\text{fi}_{R} & :\left(A\rightarrow\left(B\rightarrow Q\right)\rightarrow B\right)\rightarrow\left(\left(A\rightarrow B\right)\rightarrow Q\right)\rightarrow A\rightarrow B\quad,\\
\text{fo}_{R} & :\left(\left(\left(A\rightarrow B\right)\rightarrow Q\right)\rightarrow A\rightarrow B\right)\rightarrow A\rightarrow\left(B\rightarrow Q\right)\rightarrow B\quad.
\end{align*}

\end_inset

The implementations are again derived uniquely from type signatures:
\begin_inset Formula 
\begin{align*}
 & \text{fi}_{R}\big(f^{:A\rightarrow\left(B\rightarrow Q\right)\rightarrow B}\big)=x^{:\left(A\rightarrow B\right)\rightarrow Q}\rightarrow a^{:A}\rightarrow f(a)(b^{:B}\rightarrow x(\_\rightarrow b))\quad,\\
 & \text{fo}_{R}\big(g^{:\left(\left(A\rightarrow B\right)\rightarrow Q\right)\rightarrow A\rightarrow B}\big)=a^{:A}\rightarrow y^{:B\rightarrow Q}\rightarrow g(h^{:A\rightarrow B}\rightarrow y(h(a)))(a)\quad.
\end{align*}

\end_inset

We notice that the implementation of 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 uses a constant function, 
\begin_inset Formula $\left(\_\rightarrow b\right)$
\end_inset

, which is likely to lose information.
 Indeed, while 
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$
\end_inset

 as it must be due to the rigid nondegeneracy law, we find:
\begin_inset Formula 
\begin{align*}
\text{expect \emph{not} to equal }g:\quad & g\triangleright\text{fo}_{R}\bef\text{fi}_{R}=\left(g\triangleright\text{fo}_{R}\right)\triangleright\gunderline{\text{fi}_{R}}\\
\text{definition of }\text{fi}_{R}:\quad & =x\rightarrow a\rightarrow\gunderline{\text{fo}_{R}}(g)(a)(b\rightarrow x(\_\rightarrow b))\\
\text{definition of }\text{fo}_{R}:\quad & =x\rightarrow a\rightarrow g\big(h^{:A\rightarrow B}\rightarrow h(a)\triangleright\gunderline{(b\rightarrow}\,x(\_\rightarrow b))\big)(a)\\
\text{apply to argument }b:\quad & =x\rightarrow a\rightarrow g\big(h\rightarrow x(\_\rightarrow h(a))\big)(a)\quad.
\end{align*}

\end_inset

We cannot simplify the last line any further: the functions 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 are unknown, and we cannot calculate symbolically, say, the value of 
\begin_inset Formula $x(\_\rightarrow h(a))$
\end_inset

.
 If the last line were equal to 
\begin_inset Formula $g$
\end_inset

, we would expect it to be 
\begin_inset Formula $x\rightarrow a\rightarrow g(x)(a)$
\end_inset

.
 The difference is in the first argument of 
\begin_inset Formula $g$
\end_inset

: we have 
\begin_inset Formula $h\rightarrow x(\_\rightarrow h(a))$
\end_inset

 instead of 
\begin_inset Formula $x$
\end_inset

.
 The two last expressions are not always equal.
 They would be equal if we had:
\begin_inset Formula 
\[
\left(h\rightarrow x(h)\right)=\left(h\rightarrow x(k\rightarrow h(k))\right)\quad,
\]

\end_inset

instead of 
\begin_inset Formula $h\rightarrow x(\_\rightarrow h(a))$
\end_inset

.
 Consider again the argument of 
\begin_inset Formula $x$
\end_inset

 in the two last expressions: 
\begin_inset Formula $k\rightarrow h(a)$
\end_inset

 instead of 
\begin_inset Formula $k\rightarrow h(k)$
\end_inset

.
 Since 
\begin_inset Formula $h$
\end_inset

 is not always a constant function (
\begin_inset Formula $h$
\end_inset

 is an arbitrary function of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

), the two expressions 
\begin_inset Formula $k\rightarrow h(a)$
\end_inset

 and 
\begin_inset Formula $k\rightarrow h(k)$
\end_inset

 are generally not equal.
 So, we must conclude that 
\begin_inset Formula $\text{fo}_{R}\bef\text{fi}_{R}\neq\text{id}$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Since all rigid monads are rigid functors, we can reuse all the rigid monad
 constructions to obtain new rigid functors.
 The following statement shows a construction of rigid functors that does
 not assume any monadic properties.
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-h-p"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-h-p"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functor 
\begin_inset Formula $S^{\bullet}\triangleq H^{\bullet}\rightarrow P^{\bullet}$
\end_inset

 is rigid when 
\begin_inset Formula $H$
\end_inset

 is any contrafunctor and 
\begin_inset Formula $P$
\end_inset

 is any rigid functor.
 (Note that 
\begin_inset Formula $P$
\end_inset

 does not need to be a monad.)
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We assume that 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fo}_{P}$
\end_inset

 are known and satisfy the nondegeneracy law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-non-degeneracy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The function 
\begin_inset Formula $\text{fi}_{S}$
\end_inset

 is then defined by:
\begin_inset Formula 
\begin{align*}
\text{fi}_{S} & :\big(A\rightarrow H^{B}\rightarrow P^{B}\big)\rightarrow H^{A\rightarrow B}\rightarrow P^{A\rightarrow B}\quad,\\
\text{fi}_{S} & \triangleq f^{:A\rightarrow H^{B}\rightarrow P^{B}}\rightarrow h^{:H^{A\rightarrow B}}\rightarrow\text{fi}_{P}\big(a\rightarrow f(a)\big(h\triangleright(b\rightarrow\_\rightarrow b)^{\downarrow H}\big)\big)\quad,
\end{align*}

\end_inset

or equivalently, using the pipe notation:
\begin_inset Formula 
\[
h\triangleright\text{fi}_{S}(f)=\big(a\rightarrow h\triangleright\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}\triangleright f(a)\big)\triangleright\text{fi}_{P}\quad.
\]

\end_inset

Let us write the definition of 
\begin_inset Formula $\text{fo}_{S}$
\end_inset

 as well:
\begin_inset Formula 
\begin{align*}
\text{fo}_{S} & :\big(H^{A\rightarrow B}\rightarrow P^{A\rightarrow B}\big)\rightarrow A\rightarrow H^{B}\rightarrow P^{B}\quad,\\
\text{fo}_{S} & \triangleq g^{:H^{A\rightarrow B}\rightarrow P^{A\rightarrow B}}\rightarrow a^{:A}\rightarrow h^{:H^{B}}\rightarrow\text{fo}_{P}\big(g\big(h\triangleright(p^{:A\rightarrow B}\rightarrow p(a))^{\downarrow H}\big)\big)(a)\quad,
\end{align*}

\end_inset

or equivalently, using the pipe notation:
\begin_inset Formula 
\[
\text{fo}_{S}(g)=a\triangleright\big(h\triangleright\left(p\rightarrow p(a)\right)^{\downarrow H}\bef g\bef\text{fo}_{P}\big)\quad.
\]

\end_inset

To verify the nondegeneracy law for 
\begin_inset Formula $S$
\end_inset

, apply both sides to some arguments; we expect 
\begin_inset Formula $f\triangleright(\text{fi}_{S}\bef\text{fo}_{S})$
\end_inset

 to equal 
\begin_inset Formula $f$
\end_inset

 for an arbitrary 
\begin_inset Formula $f:A\rightarrow H^{B}\rightarrow P^{B}$
\end_inset

.
 To compare values, we need to apply both sides further to some arguments
 
\begin_inset Formula $a:A$
\end_inset

 and 
\begin_inset Formula $h:H^{B}$
\end_inset

.
 So, we expect the following expression to equal 
\begin_inset Formula $f(a)(h)$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\quad & \left(f\triangleright\text{fi}_{S}\bef\text{fo}_{S}\right)(a)(h)=(f\triangleright\text{fi}_{S}\triangleright\gunderline{\text{fo}_{S}})(a)(h)\\
\text{expand }\text{fo}_{S}:\quad & =a\triangleright\big(h\triangleright\left(p\rightarrow a\triangleright p\right)^{\downarrow H}\triangleright\gunderline{\text{fi}_{S}(f)}\triangleright\text{fo}_{P}\big)\\
\text{expand }\text{fi}_{S}:\quad & =a\triangleright\big(\big(a\rightarrow h\triangleright\gunderline{\left(p\rightarrow p(a)\right)^{\downarrow H}\bef\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\triangleright\text{fo}_{P}\big)\\
\text{compose }^{\downarrow H}:\quad & =a\triangleright\big(\big(a\rightarrow h\triangleright\gunderline{\left((b\rightarrow\_\rightarrow b)\bef(p\rightarrow p(a))\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\,\gunderline{\triangleright}\,\text{fo}_{P}\big)\quad.
\end{align*}

\end_inset

Computing the function composition:
\begin_inset Formula 
\[
(b\rightarrow\_\rightarrow b)\bef(p\rightarrow p(a))=(b\rightarrow(\_\rightarrow b)(a))=(b\rightarrow b)=\text{id}
\]

\end_inset

and using the nondegeneracy law 
\begin_inset Formula $\text{fi}_{P}\bef\text{fo}_{P}=\text{id}$
\end_inset

, we can simplify further:
\begin_inset Formula 
\begin{align*}
 & a\triangleright\big(\big(a\rightarrow h\triangleright\gunderline{\left((b\rightarrow\_\rightarrow b)\bef(p\rightarrow p(a))\right)^{\downarrow H}}\bef f(a)\big)\triangleright\text{fi}_{P}\,\gunderline{\triangleright}\,\text{fo}_{P}\big)\\
\text{identity law for }H:\quad & =a\triangleright\big(\big(a\rightarrow h\triangleright f(a)\big)\triangleright\gunderline{\text{fi}_{P}\bef\text{fo}_{P}}\big)\\
\text{non-degeneracy}:\quad & =\gunderline{a\triangleright\big(a\rightarrow}\,h\triangleright f(a)\big)=h\triangleright f(a)\quad.
\end{align*}

\end_inset

This equals 
\begin_inset Formula $f(a)(h)$
\end_inset

, as required.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Trying the triangle notation: It seems that 
\begin_inset Formula $\left(a\triangleright\right)$
\end_inset

 is not so useful, we could just write 
\begin_inset Formula $\left(f\rightarrow f(a)\right)$
\end_inset

 instead.
\begin_inset Formula 
\begin{align*}
\tilde{\text{fi}}\left(f\right) & =f\triangleright\tilde{\text{fi}}=\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}\bef f\quad,\\
\tilde{\text{fo}}\left(g\right) & =g\triangleright\tilde{\text{fo}}=h\rightarrow a\rightarrow g((a\triangleright)^{\downarrow H}h)a=h\rightarrow a\rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef g\bef\left(a\triangleright\right)\quad.
\end{align*}

\end_inset

Then
\begin_inset Formula 
\begin{align*}
 & f\triangleright\tilde{\text{fi}}\triangleright\tilde{\text{fo}}\\
 & =h\rightarrow a\rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef\left(f\triangleright\tilde{\text{fi}}\right)\bef\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow h\triangleright(a\triangleright)^{\downarrow H}\bef\left(b\rightarrow\_\rightarrow b\right)^{\downarrow H}\bef f\bef\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow h\triangleright\left(b\rightarrow\_\rightarrow b\bef\left(a\triangleright\right)\right)^{\downarrow H}\bef f\bef\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow h\triangleright f\bef\left(a\triangleright\right)=h\rightarrow a\rightarrow h\triangleright f\triangleright\left(a\triangleright\right)\\
 & =h\rightarrow a\rightarrow f(h)(a)=f
\end{align*}

\end_inset

What are the simplification rules?
\begin_inset Formula 
\begin{align*}
 & a\rightarrow x\triangleright\left(a\triangleright\right)=x\quad,\\
 & a\rightarrow a\triangleright f=f\quad,\\
 & x\triangleright\left(a\triangleright\right)=x(a)=a\triangleright x\quad,\\
 & x\triangleright y\triangleright\left(a\triangleright\right)=a\triangleright\left(x\triangleright y\right)\quad.
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-is-pointed"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-is-pointed"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Any rigid functor 
\begin_inset Formula $R$
\end_inset

 is pointed.
 The required 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method can be defined by:
\begin_inset Formula 
\[
\text{pu}_{R}(x^{:A})\triangleq\text{id}^{:R^{A}\rightarrow R^{A}}\triangleright\text{fi}_{R}\triangleright(\_\rightarrow x)^{\uparrow R}\quad.
\]

\end_inset

The corresponding 
\begin_inset Quotes eld
\end_inset

wrapped unit
\begin_inset Quotes erd
\end_inset

 value 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

 of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 is computed as: 
\begin_inset Formula 
\begin{equation}
\text{wu}_{R}\triangleq\text{pu}_{R}(1)=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\rightarrow1)^{\uparrow R}\quad.\label{eq:rigid-functor-def-of-wrapped-unit}
\end{equation}

\end_inset


\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
The method 
\begin_inset Formula $\text{fi}_{R}:(X\rightarrow R^{Y})\rightarrow R^{X\rightarrow Y}$
\end_inset

 with type parameters 
\begin_inset Formula $X=R^{A}$
\end_inset

 and 
\begin_inset Formula $Y=A$
\end_inset

 is applied to the identity function 
\begin_inset Formula $\text{id}:R^{A}\rightarrow R^{A}$
\end_inset

, considered as a value of type 
\begin_inset Formula $X\rightarrow R^{Y}$
\end_inset

.
 The result is:
\begin_inset Formula 
\[
(\text{id}\triangleright\text{fi}_{R}):R^{R^{A}\rightarrow A}\quad.
\]

\end_inset

This value is transformed via the lifted constant function 
\begin_inset Formula $\left(\_\rightarrow x\right)^{\uparrow R}$
\end_inset

, which takes a value of type 
\begin_inset Formula $R^{R^{A}\rightarrow A}$
\end_inset

 and returns a value of type 
\begin_inset Formula $R^{A}$
\end_inset

.
 The resulting code can be written as:
\begin_inset Formula 
\[
\text{pu}_{R}(x^{:A})\triangleq\text{id}\triangleright\text{fi}_{R}\triangleright(\_^{:R^{A}\rightarrow A}\rightarrow x)^{\uparrow R}\quad.
\]

\end_inset

The function 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 defined in this way is a natural transformation since 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 is one.
 Applying 
\begin_inset Formula $\text{pu}_{R}$
\end_inset

 to a unit value, we obtain a selected value 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

 of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
 
\begin_inset Formula $\quad$
\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The next statement shows that 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

 is the 
\emph on
only
\emph default
 distinct value of the type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
 This means, in particular, that a rigid functor cannot be a disjunctive
 type defined with more than one constructor, such as 
\begin_inset Formula $\bbnum 1+A$
\end_inset

 or 
\begin_inset Formula $\text{List}^{A}$
\end_inset

.
 This is the motivation for the name 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

: the data structure 
\begin_inset Formula $R^{A}$
\end_inset

 must have a fixed 
\begin_inset Quotes eld
\end_inset

shape
\begin_inset Quotes erd
\end_inset

 and cannot be a disjunction of several variants.
 
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-wrapped-unit-is-unit"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-wrapped-unit-is-unit"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If a functor 
\begin_inset Formula $R$
\end_inset

 is rigid then the type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 is equivalent to the unit type: 
\begin_inset Formula $R^{\bbnum 1}\cong\bbnum 1$
\end_inset

.
 The value 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rigid-functor-def-of-wrapped-unit"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is the only distinct value of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
 The isomorphism between the types 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 is the function 
\begin_inset Formula $\left(\_^{:\bbnum 1}\rightarrow\text{wu}_{R}\right)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
The trick is to apply both sides of the nondegeneracy law (
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$
\end_inset

) to the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

.
 To adapt the type parameters, consider the type signature of 
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}$
\end_inset

:
\begin_inset Formula 
\[
\big(\text{fi}_{R}\bef\text{fo}_{R}\big):(A\rightarrow R^{B})\rightarrow(A\rightarrow R^{B})\quad,
\]

\end_inset

and set 
\begin_inset Formula $A=R^{\bbnum 1}$
\end_inset

 and 
\begin_inset Formula $B=\bbnum 1$
\end_inset

.
 The left-hand side of the law can be now applied to the identity function
 
\begin_inset Formula $\text{id}:R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

, which yields a value of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

, i.e., a function:
\begin_inset Formula 
\[
f_{1}:R^{\bbnum 1}\rightarrow R^{\bbnum 1}\quad,\quad\quad f_{1}\triangleq\text{fo}_{R}(\text{fi}_{R}(\text{id}))\quad.
\]

\end_inset

We will show that 
\begin_inset Formula $f_{1}$
\end_inset

 is a constant function, 
\begin_inset Formula $f_{1}=(\_\rightarrow\text{wu}_{R})$
\end_inset

, always returning the same value 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

 defined in Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-is-pointed"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 However, the right-hand side of the nondegeneracy law applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 is the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

.
 So, the nondegeneracy law means that 
\begin_inset Formula $f_{1}=\text{id}$
\end_inset

.
 If the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

 always returns the same value (
\begin_inset Formula $\text{wu}_{R}$
\end_inset

), it will mean that 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

 is the only distinct value of the type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
\end_layout

\begin_layout Standard
We note that for any fixed type 
\begin_inset Formula $A$
\end_inset

, the function type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 is equivalent to the unit type (
\begin_inset Formula $\bbnum 1$
\end_inset

).
 This is because there exists only one function of type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

, namely 
\begin_inset Formula $(\_\rightarrow1)$
\end_inset

.
 The code of that function is uniquely determined by its type signature.
 In other words, there exists only one distinct value of the type 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

, and that value is 
\begin_inset Formula $(\_^{:A}\rightarrow1)$
\end_inset

.
 
\end_layout

\begin_layout Standard
The isomorphism between the types 
\begin_inset Formula $A\rightarrow\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\bbnum 1$
\end_inset

 is realized by the functions 
\begin_inset Formula $u:\bbnum 1\rightarrow A\rightarrow\bbnum 1$
\end_inset

 and 
\begin_inset Formula $v:\left(A\rightarrow\bbnum 1\right)\rightarrow\bbnum 1$
\end_inset

.
 The code of these functions is also uniquely determined by their type signature
s:
\begin_inset Formula 
\[
u=\big(1\rightarrow\_^{:A}\rightarrow1\big)\quad,\quad\quad v=\big(\_^{:A\rightarrow\bbnum 1}\rightarrow1\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To prove that 
\begin_inset Formula $f_{1}$
\end_inset

 is a constant function, we apply 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 to the identity function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

 and get a value that we denote by 
\begin_inset Formula $g$
\end_inset

:
\begin_inset Formula 
\[
g:R^{R^{\bbnum 1}\rightarrow\bbnum 1}\quad,\quad\quad g\triangleq\text{id}\triangleright\text{fi}_{R}\quad.
\]

\end_inset

Since the type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow\bbnum 1$
\end_inset

 is equivalent to 
\begin_inset Formula $\bbnum 1$
\end_inset

, the type 
\begin_inset Formula $R^{R^{\bbnum 1}\rightarrow\bbnum 1}$
\end_inset

 is equivalent to 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
 To use this equivalence explicitly, we need to lift the isomorphisms 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 into the functor 
\begin_inset Formula $R$
\end_inset

.
 The isomorphism will then map 
\begin_inset Formula $g:R^{R^{\bbnum 1}\rightarrow\bbnum 1}$
\end_inset

 to some 
\begin_inset Formula $g_{1}:R^{\bbnum 1}$
\end_inset

 by:
\begin_inset Formula 
\[
g_{1}\triangleq g\triangleright v^{\uparrow R}\quad.
\]

\end_inset

Substituting the definitions of 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $v$
\end_inset

, and 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

, we find that actually 
\begin_inset Formula $g_{1}=\text{wu}_{R}$
\end_inset

:
\begin_inset Formula 
\[
g_{1}=\text{id}\triangleright\text{fi}_{R}\triangleright v^{\uparrow R}=\text{id}\triangleright\text{fi}_{R}\triangleright(\_\rightarrow1)^{\uparrow R}=\text{wu}_{R}\quad.
\]

\end_inset

We can now map 
\begin_inset Formula $g_{1}$
\end_inset

 back to 
\begin_inset Formula $g$
\end_inset

 via the lifted isomorphism 
\begin_inset Formula $u$
\end_inset

:
\begin_inset Formula 
\begin{align}
g & =g_{1}\triangleright u^{\uparrow R}=\text{wu}_{R}\triangleright u^{\uparrow R}\nonumber \\
\text{definition of }u:\quad & =\text{wu}_{R}\triangleright\big(1\rightarrow\_\rightarrow1\big)^{\uparrow R}\quad.\label{eq:rigid-functor-derivation1}
\end{align}

\end_inset

Now we compute 
\begin_inset Formula $f_{1}\triangleq\text{fo}_{R}(g)$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
 & f_{1}=\text{fo}_{R}(g)=g\triangleright\text{fo}_{R}\\
\text{use Eq.~(\ref{eq:fuseOut-def})}:\quad & =a^{:R^{\bbnum 1}}\rightarrow g\triangleright\big(f^{:A\rightarrow\bbnum 1}\rightarrow f\left(a\right)\big)^{\uparrow R}\\
\text{use Eq.~(\ref{eq:rigid-functor-derivation1})}:\quad & =a\rightarrow\text{wu}_{R}\triangleright(1\rightarrow\_^{:A}\rightarrow1)^{\uparrow R}\triangleright\big(f^{:A\rightarrow\bbnum 1}\rightarrow f\left(a\right)\big)^{\uparrow R}\\
\text{composition under }^{\uparrow R}:\quad & =a\rightarrow\text{wu}_{R}\triangleright\big(1\rightarrow(\_^{:A}\rightarrow1)(a)\big)^{\uparrow R}=a\rightarrow\text{wu}_{R}\triangleright(\gunderline{1\rightarrow1})^{\uparrow R}\\
(1\rightarrow1)\text{ is identity}:\quad & =(a\rightarrow\text{wu}_{R}\triangleright\text{id})=(a^{:R^{\bbnum 1}}\rightarrow\text{wu}_{R})=(\_^{:R^{\bbnum 1}}\rightarrow\text{wu}_{R})\quad.
\end{align*}

\end_inset

So, 
\begin_inset Formula $f_{1}\triangleq\text{fo}_{R}(\text{fi}_{R}(\text{id}))$
\end_inset

 is a function of type 
\begin_inset Formula $R^{\bbnum 1}\rightarrow R^{\bbnum 1}$
\end_inset

 that ignores its argument and always returns the same value 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

.
\end_layout

\begin_layout Standard
By virtue of the nondegeneracy law, we get 
\begin_inset Formula $f_{1}=\text{fo}_{R}(g)=\text{id}$
\end_inset

.
 So, the identity function 
\begin_inset Formula $\text{id}^{:R^{\bbnum 1}\rightarrow R^{\bbnum 1}}$
\end_inset

 always returns the same value 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

.
 Applying this function to an arbitrary value 
\begin_inset Formula $x:R^{\bbnum 1}$
\end_inset

, we get:
\begin_inset Formula 
\[
x=x\triangleright\text{id}=x\triangleright\text{fo}_{R}(g)=x\triangleright(\_\rightarrow\text{wu}_{R})=\text{wu}_{R}\quad.
\]

\end_inset

It means that all values 
\begin_inset Formula $x$
\end_inset

 of type 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

 are equal to 
\begin_inset Formula $\text{wu}_{R}$
\end_inset

.
 So, the function 
\begin_inset Formula $\_^{:\bbnum 1}\rightarrow\text{wu}_{R}$
\end_inset

 is indeed an isomorphism between the types 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $R^{\bbnum 1}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-product"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The product of rigid functors is a rigid functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We assume that two rigid functors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are given, with their methods 
\begin_inset Formula $\text{fi}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fi}_{Q}$
\end_inset

 satisfying the nondegeneracy law.
 The functor product 
\begin_inset Formula $R\triangleq P\times Q$
\end_inset

 needs its own 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 method, with the type signature:
\begin_inset Formula 
\[
\text{fi}_{R}:(A\rightarrow P^{B}\times Q^{B})\rightarrow P^{A\rightarrow B}\times Q^{A\rightarrow B}\quad.
\]

\end_inset

To implement 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

, note that the function type 
\begin_inset Formula $A\rightarrow P\times Q$
\end_inset

 is isomorphic to 
\begin_inset Formula $\left(A\rightarrow P\right)\times\left(A\rightarrow Q\right)$
\end_inset

.
 The isomorphism is given by a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

split
\end_layout

\end_inset

 function, defined as:
\begin_inset Formula 
\[
\text{split}:\left(A\rightarrow B\times C\right)\rightarrow\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)\quad,\quad\quad\text{split}\triangleq f^{:A\rightarrow B\times C}\rightarrow(f\bef\pi_{1})\times(f\bef\pi_{2})\quad.
\]

\end_inset

Then the method 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 is written more concisely:
\begin_inset Formula 
\[
\text{fi}_{R}\triangleq\text{split}\bef(\text{fi}_{P}\boxtimes\text{fi}_{Q})\quad.
\]

\end_inset

To check the nondegeneracy law (
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$
\end_inset

), we need the code of 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

.
 It is convenient to define 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

 via a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 function:
\begin_inset Formula 
\[
\text{merge}:\left(A\rightarrow B\right)\times\left(A\rightarrow C\right)\rightarrow A\rightarrow B\times C\quad,\quad\quad\text{merge}\triangleq f^{:A\rightarrow B}\times g^{:A\rightarrow C}\rightarrow a^{:A}\rightarrow f(a)\times g(a)\quad.
\]

\end_inset

The code of 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

 is then written as:
\begin_inset Formula 
\[
\text{fo}_{R}:P^{A\rightarrow B}\times Q^{A\rightarrow B}\rightarrow A\rightarrow P^{B}\times Q^{B}\quad,\quad\quad\text{fo}_{R}\triangleq(\text{fo}_{P}\boxtimes\text{fo}_{Q})\bef\text{merge}\quad.
\]

\end_inset

The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

split
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 are mutual inverses.
 Now we can verify the nondegeneracy law:
\begin_inset Formula 
\begin{align*}
 & \text{fi}_{R}\bef\text{fo}_{R}=\text{split}\bef\gunderline{(\text{fi}_{P}\boxtimes\text{fi}_{Q})\bef(\text{fo}_{P}\boxtimes\text{fo}_{Q})}\bef\text{merge}\\
 & =\text{split}\bef\big((\gunderline{\text{fi}_{P}\bef\text{fo}_{P}})\boxtimes(\gunderline{\text{fi}_{Q}\bef\text{fo}_{Q}})\big)\bef\text{merge}=\text{split}\bef\gunderline{(\text{id}\boxtimes\text{id})}\bef\text{merge}=\text{split}\bef\text{merge}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-rigid-functor-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-rigid-functor-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The composition of rigid functors is a rigid functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We will show that the nondegeneracy law (
\begin_inset Formula $\text{fi}_{R}\bef\text{fo}_{R}=\text{id}$
\end_inset

) holds for the functor 
\begin_inset Formula $R^{\bullet}\triangleq P^{Q^{\bullet}}$
\end_inset

 as long as 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 are rigid.
 Begin by defining the methods 
\begin_inset Formula $\text{fi}_{R}$
\end_inset

 and 
\begin_inset Formula $\text{fo}_{R}$
\end_inset

, assuming that the corresponding methods of 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 are known and satisfy the nondegeneracy law.
 We write:
\begin_inset Formula 
\begin{align*}
 & \text{fi}_{R}:(A\rightarrow P^{Q^{B}})\rightarrow P^{Q^{A\rightarrow B}}\quad,\quad\quad\text{fi}_{R}\triangleq\text{fi}_{P}\bef\text{fi}_{Q}^{\uparrow P}\quad,\\
 & \text{fo}_{R}:P^{Q^{A\rightarrow B}}\rightarrow A\rightarrow P^{Q^{B}}\quad,\quad\quad\text{fo}_{R}\triangleq\text{fo}_{Q}^{\uparrow P}\bef\text{fo}_{P}\quad.
\end{align*}

\end_inset

To verify the nondegeneracy law for 
\begin_inset Formula $R$
\end_inset

:
\begin_inset Formula 
\[
\text{fi}_{R}\bef\text{fo}_{R}=\text{fi}_{P}\bef\text{fi}_{Q}^{\uparrow P}\bef\text{fo}_{Q}^{\uparrow P}\bef\text{fo}_{P}=\text{fi}_{P}\bef(\gunderline{\text{fi}_{Q}\bef\text{fo}_{Q}})^{\uparrow P}\bef\text{fo}_{P}=\gunderline{\text{fi}_{P}\bef\text{fo}_{P}}=\text{id}\quad.
\]

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Flip the curried arguments of the function type 
\begin_inset Formula $A\rightarrow T^{B}\triangleq A\rightarrow H^{M^{B}}\rightarrow M^{B}$
\end_inset

, to obtain 
\begin_inset Formula $H^{M^{B}}\rightarrow A\rightarrow M^{B}$
\end_inset

, and note that 
\begin_inset Formula $A\rightarrow M^{B}$
\end_inset

 can be mapped to 
\begin_inset Formula $M^{A\rightarrow B}$
\end_inset

 using 
\begin_inset Formula $\text{fi}_{M}$
\end_inset

.
 So, we can implement 
\begin_inset Formula $\tilde{\text{fi}}_{T}$
\end_inset

 using 
\begin_inset Formula $\text{fi}_{M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\tilde{\text{fi}}_{T} & :\big(H^{M^{B}}\rightarrow A\rightarrow M^{B}\big)\rightarrow H^{M^{A\rightarrow B}}\rightarrow M^{A\rightarrow B}\\
\tilde{\text{fi}}_{T} & =f\rightarrow h\rightarrow\text{fi}_{M}\left(f\big(\left(b\rightarrow\_\rightarrow b\right)^{\uparrow M\downarrow H}h\big)\right)\\
\tilde{\text{fo}}_{T} & :\left(H^{M^{A\rightarrow B}}\rightarrow M^{A\rightarrow B}\right)\rightarrow H^{M^{B}}\rightarrow A\rightarrow M^{B}\\
\tilde{\text{fo}}_{T} & =g\rightarrow h\rightarrow a\rightarrow\text{fo}_{M}\left(g\big(\left(p^{:A\rightarrow B}\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)a
\end{align*}

\end_inset

To show the nondegeneracy law for 
\begin_inset Formula $T$
\end_inset

, compute
\begin_inset Formula 
\begin{align*}
 & \tilde{\text{fo}}_{T}\left(\tilde{\text{fi}}_{T}f\right)h^{:H^{M^{B}}}a^{:A}\\
\text{insert the definition of }\tilde{\text{fo}}_{T}\text{: }\quad & =\text{fo}_{M}\left(\left(\tilde{\text{fi}}_{T}f\right)\big(\left(p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)a\\
\text{insert the definition of }\tilde{\text{fi}}_{T}\text{: }\quad & =\text{fo}_{M}\left(\text{fi}_{M}\left(f\big(\left(b\rightarrow\_\rightarrow b\right)^{\uparrow M\downarrow H}\left(p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)\right)\right)a\\
\text{non-degeneracy law for }\text{fi}_{M}\text{: }\quad & =f\big(\left(b\rightarrow\_\rightarrow b\right)^{\uparrow M\downarrow H}\left(p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)a\\
\text{composition laws for }M,H\text{: }\quad & =f\big(\left(b\rightarrow\_\rightarrow b\bef p\rightarrow p\,a\right)^{\uparrow M\downarrow H}h\big)a\\
\text{simplify }\text{: }\quad & =f\left(\left(b\rightarrow b\right)^{\uparrow M\downarrow H}h\right)a\\
\text{identity laws for }M,H\text{: }\quad & =f\,h\,a\quad.
\end{align*}

\end_inset

We obtained 
\begin_inset Formula $\tilde{\text{fo}}_{T}\left(\tilde{\text{fi}}_{T}\,f\right)h\,a=f\,h\,a$
\end_inset

.
 Therefore the nondegeneracy law 
\begin_inset Formula $\tilde{\text{fi}}_{T}\bef\tilde{\text{fo}}_{T}=\text{id}$
\end_inset

 holds.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Monadically natural lifting of MTL operations (
\begin_inset Quotes eld
\end_inset


\family typewriter
Monatron
\family default

\begin_inset Quotes erd
\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "subsec:Monatron"

\end_inset


\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Combining-monads-via-mtl-style"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed that MTL-style programming requires custom code for lifting monad
 operations to all supported monad stacks.
 The 
\begin_inset Quotes eld
\end_inset


\family typewriter
Monatron
\family default

\begin_inset Quotes erd
\end_inset

 library
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.fceia.unr.edu.ar/~mauro/pubs/monatron.pdf"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
Monatron
\family default
 library (MTL-style)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
MTL-style monadic programs!
\family typewriter
Monatron
\family default
 library
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic program!
\family typewriter
Monatron
\family default
 library (MTL-style)
\end_layout

\end_inset

 is based on a systematic approach that lifts many known monad operations
 to most monad stacks, including stacks that contain a single monad with
 an incomplete or missing transformer (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IO
\end_layout

\end_inset

) located at the deep end of the stack.
 This section, based on the methods and results explained in a paper by
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mauro Jaskelioff
\end_layout

\end_inset

M.
\begin_inset space ~
\end_inset

Jaskelioff,
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Modular monad transformers
\begin_inset Quotes erd
\end_inset

, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.219.5365"
literal "false"

\end_inset


\end_layout

\end_inset

 will show how 
\family typewriter
Monatron
\family default
's liftings work.
 
\end_layout

\begin_layout Paragraph
Common type signatures for operations
\end_layout

\begin_layout Standard
The first step is to transform all effectful operations into a standard
 type signature.
 Looking at Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:effectful-operations-for-some-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we find that the type signatures of known operations for various monads
 
\begin_inset Formula $M$
\end_inset

 fall into four patterns: 
\end_layout

\begin_layout Enumerate
Type signature 
\begin_inset Formula $M^{Q}$
\end_inset

 or 
\begin_inset Formula $P\rightarrow M^{Q}$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are fixed types.
\end_layout

\begin_layout Enumerate
Type signature 
\begin_inset Formula $\forall A.\,M^{A}$
\end_inset

 or 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow M^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a functor that does not depend on 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Enumerate
Type signature 
\begin_inset Formula $\forall A.\,F^{M^{A}}\rightarrow M^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is a functor that does not depend on 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Enumerate
A different type signature (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

process
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operations).
\end_layout

\begin_layout Standard
At first glance, the type signatures of different operations appear to be
 different and incompatible with each other.
 However, it turns out that almost all operations may be converted into
 a common type signature of the form 
\begin_inset Formula $F^{M^{A}}\rightarrow M^{A}$
\end_inset

.
 The following definition introduces some helpful names:
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-simple-standard-operation-monatron"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-simple-standard-operation-monatron"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given monad 
\begin_inset Formula $M$
\end_inset

 and a given functor 
\begin_inset Formula $F$
\end_inset

:
\end_layout

\begin_layout Standard
A 
\series bold

\begin_inset Quotes eld
\end_inset

fixed-type
\begin_inset Quotes erd
\end_inset

 operation
\series default
 is a function of type 
\begin_inset Formula $P\rightarrow M^{Q}$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are fixed types.
\end_layout

\begin_layout Standard
A 
\series bold

\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation
\series default
 is a natural transformation with type signature 
\begin_inset Formula $\forall A.\,F^{A}\rightarrow M^{A}$
\end_inset

.
\end_layout

\begin_layout Standard
A 
\series bold

\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation
\series default
 is a natural transformation with type signature 
\begin_inset Formula $\forall A.\,F^{M^{A}}\rightarrow M^{A}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
According to this definition, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

 operations are 
\begin_inset Quotes eld
\end_inset

fixed-type
\begin_inset Quotes erd
\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

raise
\end_layout

\end_inset

 operation is 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 (with the functor 
\begin_inset Formula $F$
\end_inset

 defined as the constant functor 
\begin_inset Formula $F^{A}\triangleq E$
\end_inset

), and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

append
\end_layout

\end_inset

 operation is 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 (with the functor 
\begin_inset Formula $F^{A}\triangleq A\times A$
\end_inset

).
 
\end_layout

\begin_layout Standard
The following statement shows that 
\begin_inset Quotes eld
\end_inset

fixed-type
\begin_inset Quotes erd
\end_inset

 operations are a subset of 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations, while 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations are a subset of 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-simple-standard-operations-monatron"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-simple-standard-operations-monatron"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Any 
\begin_inset Quotes eld
\end_inset

fixed-type
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{fop}:P\rightarrow M^{Q}$
\end_inset

 is  equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

 with functor 
\begin_inset Formula $F^{A}\triangleq P\times\left(Q\rightarrow A\right)$
\end_inset

.
 The operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fop
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

 are related by:
\begin_inset Formula 
\[
\text{sop}:P\times\left(Q\rightarrow A\right)\rightarrow M^{A}\quad,\quad\text{sop}=p^{:P}\times q^{:Q\rightarrow A}\rightarrow p\triangleright\text{fop}\triangleright q^{\uparrow M}\quad,\quad\text{fop}=p^{:P}\rightarrow\text{sop}^{Q}(p\times\text{id}^{Q\rightarrow Q})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Any 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}:F^{M^{A}}\rightarrow M^{A}$
\end_inset

 that satisfies the following compatibility law:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.6pc}\xyScaleX{2.0pc}F^{M^{M^{A}}}\ar[d]\sb(0.45){\text{ftn}_{M}^{\uparrow F}}\ar[r]\sp(0.5){\text{op}} & M^{M^{A}}\ar[d]\sp(0.45){\text{ftn}_{M}}\\
F^{M^{A}}\ar[r]\sp(0.5){\text{op}} & M^{A}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{op}\bef\text{ftn}_{M}=\text{ftn}_{M}^{\uparrow F}\bef\text{op}\quad,\label{eq:monatron-standard-operation-compatibility-law}
\end{equation}

\end_inset

will be equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

 defined by:
\begin_inset Formula 
\[
\text{sop}:F^{A}\rightarrow M^{A}\quad,\quad\quad\text{sop}\triangleq\text{pu}_{M}^{\uparrow F}\bef\text{op}\quad,\quad\quad\text{op}=\text{sop}\bef\text{ftn}_{M}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Derive the type equivalence 
\begin_inset Formula $P\rightarrow M^{Q}\cong\forall A.\,P\times\left(Q\rightarrow A\right)\rightarrow M^{A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,\gunderline{P\times}\left(Q\rightarrow A\right)\rightarrow M^{A}\cong P\rightarrow\gunderline{\forall A.\,\left(Q\rightarrow A\right)\rightarrow M^{A}}\\
\text{covariant Yoneda identity}:\quad & \cong P\rightarrow M^{Q}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We will prove separately the two directions of the isomorphism.
\end_layout

\begin_layout Standard
Direction 
\begin_inset Formula $\text{op}\rightarrow\text{sop}$
\end_inset

: Given that a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}:F^{M^{A}}\rightarrow M^{A}$
\end_inset

 satisfying Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we first define 
\begin_inset Formula $\text{sop}\triangleq\text{pu}_{M}^{\uparrow F}\bef\text{op}$
\end_inset

 and then compute a new 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}^{\prime}\triangleq\text{sop}\bef\text{ftn}_{M}$
\end_inset

.
 The new operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 is equal to the initial 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{op}^{\prime}=\text{sop}\bef\text{ftn}_{M}=\text{pu}^{\uparrow F}\bef\gunderline{\text{op}\bef\text{ftn}_{M}}\\
\text{use Eq.~(\ref{eq:monatron-standard-operation-compatibility-law})}:\quad & =\gunderline{\text{pu}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}}\bef\text{op}=(\gunderline{\text{pu}\bef\text{ftn}_{M}})^{\uparrow F}=\text{op}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Direction 
\begin_inset Formula $\text{sop}\rightarrow\text{op}$
\end_inset

: Given a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{sop}:F^{A}\rightarrow M^{A}$
\end_inset

, we first define 
\begin_inset Formula $\text{op}\triangleq\text{sop}\bef\text{ftn}_{M}$
\end_inset

 and then compute a new 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{sop}^{\prime}\triangleq\text{pu}^{\uparrow F}\bef\text{op}$
\end_inset

.
 The new operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset


\begin_inset Formula $^{\prime}$
\end_inset

 equals 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{sop}^{\prime}=\text{pu}^{\uparrow F}\bef\text{op}=\gunderline{\text{pu}^{\uparrow F}\bef\text{sop}}\bef\text{ftn}_{M}\\
\text{naturality law of }\text{sop}:\quad & =\text{sop}\bef\gunderline{\text{pu}^{\uparrow M}\bef\text{ftn}_{M}}=\text{sop}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
All operations shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:effectful-operations-for-some-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (except 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

process
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

) are either 
\begin_inset Quotes eld
\end_inset

fixed-type
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

, and so (by Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-simple-standard-operations-monatron"
plural "false"
caps "false"
noprefix "false"

\end_inset

) may be equivalently represented by some 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations.
 Many operations with a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 type signature turn out to be equivalent to 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations because they satisfy the compatibility law.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-list-append-is-simple-operation"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-list-append-is-simple-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

append
\end_layout

\end_inset

 operation has the type signature of the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 form 
\begin_inset Formula $F^{\text{List}^{A}}\rightarrow\text{List}^{A}$
\end_inset

 with 
\begin_inset Formula $F^{A}\triangleq A\times A$
\end_inset

.
 By Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-flatten-concat-distributive-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

append
\end_layout

\end_inset

 satisfies the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-simple-standard-operations-monatron"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

append
\end_layout

\end_inset

 is equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sappend
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{sappend}:A\times A\rightarrow\text{List}^{A}\quad,\quad\quad\text{sappend}\left(a_{1}\times a_{2}\right)\triangleq[a_{1},a_{2}]=\text{pu}_{\text{List}}(a_{1})\,\pplus\,\text{pu}_{\text{List}}(a_{2})\quad,\\
 & p^{:\text{List}^{A}}\pplus q^{:\text{List}^{A}}=\text{ftn}_{\text{List}}([p,q])=\left(p\times q\right)\triangleright\text{sappend}\triangleright\text{ftn}_{\text{List}}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Certain 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations are 
\emph on
not
\emph default
 equivalent to 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 ones:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-monatron-flush-operation"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-monatron-flush-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 operation (erasing the message log) is defined by:
\begin_inset Formula 
\[
\text{clear}:M^{A}\rightarrow M^{A}\cong A\times W\rightarrow A\times W\quad,\quad\quad\text{clear}\triangleq a^{:A}\times\_^{:W}\rightarrow a\times e_{W}\quad.
\]

\end_inset

The type signature 
\begin_inset Formula $M^{A}\rightarrow M^{A}$
\end_inset

 is of the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 form 
\begin_inset Formula $F^{M^{A}}\rightarrow M^{A}$
\end_inset

 with 
\begin_inset Formula $F^{A}\triangleq A$
\end_inset

.
 However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 does not satisfy the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and is not equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation.
 If it were, the corresponding 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation would be a natural transformation of type 
\begin_inset Formula $F^{A}\rightarrow M^{A}\cong A\rightarrow A\times W$
\end_inset

.
 Such a natural transformation must be implemented as 
\begin_inset Formula $\text{sop}:a^{:A}\rightarrow a\times w_{0}$
\end_inset

 with some fixed value 
\begin_inset Formula $w_{0}^{:W}$
\end_inset

 that is independent of 
\begin_inset Formula $a$
\end_inset

.
 The corresponding 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation is:
\begin_inset Formula 
\[
\text{op}:M^{A}\rightarrow M^{A}\quad,\quad\quad\text{op}\triangleq\text{sop}\bef\text{ftn}_{M}=(a\times w\rightarrow a\times w\times w_{0})\bef\text{ftn}_{M}=a\times w\rightarrow a\times(w\oplus w_{0})\quad.
\]

\end_inset

This operation appends to the log instead of clearing it.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 cannot equal 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
To build an intuition for the meaning of 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

, consider a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}:F^{M^{A}}\rightarrow M^{A}$
\end_inset

, where 
\begin_inset Formula $F^{A}$
\end_inset

 contains a few values of type 
\begin_inset Formula $A$
\end_inset

 (such as 
\begin_inset Formula $F^{A}\triangleq A\times A$
\end_inset

 as in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

append
\end_layout

\end_inset

 operation).
 A 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{sop}:F^{A}\rightarrow M^{A}$
\end_inset

 computes a new 
\begin_inset Formula $M$
\end_inset

-effect value from a few values of type 
\begin_inset Formula $A$
\end_inset

 without using any previously given 
\begin_inset Formula $M$
\end_inset

-effect values.
 A 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 transforms a few effectful values of type 
\begin_inset Formula $M^{A}$
\end_inset

 into a new effectful value.
 If 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 were equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

, we would have 
\begin_inset Formula $\text{op}=\text{sop}\bef\text{ftn}_{M}$
\end_inset

.
 It follows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 computes a new 
\begin_inset Formula $M$
\end_inset

-effect by flattening the previously given 
\begin_inset Formula $M$
\end_inset

-effects and possibly using some values of type 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
As a heuristic summary, we may say that a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation creates new effect values from ordinary, non-effectful values.
 A 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation can transform effects in a way that is 
\emph on
not
\emph default
 equivalent to flattening (as the example with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 shows).
 
\begin_inset Quotes eld
\end_inset

Standard
\begin_inset Quotes erd
\end_inset

 operations that are equivalent to 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

operations cannot perform arbitrary transformations of effects: the given
 effects must be flattened and combined with a new effect value, but may
 not be transformed in any other way.
 
\end_layout

\begin_layout Standard
Putting the 
\begin_inset Quotes eld
\end_inset

non-standard
\begin_inset Quotes erd
\end_inset

 operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

process
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 temporarily aside, we now focus on how to lift 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations to monad stacks.
\end_layout

\begin_layout Standard
The goal is to lift a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}_{M}:F^{M}\leadsto M$
\end_inset

 from a monad 
\begin_inset Formula $M$
\end_inset

 to any monad stack 
\begin_inset Formula $P$
\end_inset

 containing 
\begin_inset Formula $M$
\end_inset

.
 We assume that a lawful monad morphism 
\begin_inset Formula $p:M\leadsto P$
\end_inset

 is given.
 We expect that the new operation, 
\begin_inset Formula $\text{op}_{P}:F^{P}\leadsto P$
\end_inset

, should correctly perform the functionality of the operation 
\begin_inset Formula $\text{op}_{M}$
\end_inset

 in the monad 
\begin_inset Formula $M$
\end_inset

 embedded within 
\begin_inset Formula $P$
\end_inset

.
 
\end_layout

\begin_layout Standard
For example, since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

append
\end_layout

\end_inset

 operation appends two lists, we expect that the corresponding lifted operation
 (
\begin_inset Formula $\text{append}_{P}$
\end_inset

) should correctly append lists embedded within the stack 
\begin_inset Formula $P$
\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 operation clears the log, so we expect that the corresponding lifted operation
 (
\begin_inset Formula $\text{clear}_{P}$
\end_inset

) also clears the log embedded within the stack 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
To express this requirement formally, we note that the monad morphism 
\begin_inset Formula $p$
\end_inset

 correctly embeds the monad methods of 
\begin_inset Formula $M$
\end_inset

 into 
\begin_inset Formula $P$
\end_inset

.
 So, we may require that the transformation of effects by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 should commute with the mapping by 
\begin_inset Formula $p$
\end_inset

.
 This requirement is written as a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monadic naturality law!of lifted operations
\end_layout

\end_inset

monadic naturality law:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{2.0pc}F^{M^{A}}\ar[d]\sb(0.45){p^{\uparrow F}}\ar[r]\sb(0.5){\text{op}_{M}} & M^{A}\ar[d]\sp(0.45){p}\\
F^{P^{A}}\ar[r]\sp(0.5){\text{op}_{P}} & P^{A}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{for any monad morphism }p:M\leadsto P:\quad\text{op}_{M}\bef p=p^{\uparrow F}\bef\text{op}_{P}\quad.\label{eq:monatron-monadic-naturality-for-operations}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The goal of this section is to derive monadically natural liftings of operations.
\end_layout

\begin_layout Paragraph
Lifting 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Combining-monads-via-mtl-style"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

set
\end_layout

\end_inset

 operations are lifted to any monad stack by composing with a lift function.
 This method works 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
equally well 
\end_layout

\end_inset

for any 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{sop}_{M}:F^{A}\rightarrow M^{A}$
\end_inset

 and an arbitrary monad stack 
\begin_inset Formula $P$
\end_inset

 that has a lift function 
\begin_inset Formula $p:M^{A}\rightarrow P^{A}$
\end_inset

.
 The result of lifting is a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset Formula $\text{sop}_{P}$
\end_inset

) defined by:
\begin_inset Formula 
\begin{equation}
\text{sop}_{P}:F^{A}\rightarrow P^{A}\quad,\quad\quad\text{sop}_{P}\triangleq\text{sop}_{M}\bef p\quad.\label{eq:monatron-lift-simple-operation}
\end{equation}

\end_inset

The following statement shows how to express this lifting in terms of 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations.
 It also proves that the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 counterpart of 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 always satisfies the monadic naturality law.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-lifting-simple-operation"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-lifting-simple-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $M$
\end_inset

-operation 
\begin_inset Formula $\text{sop}_{M}:F^{A}\rightarrow M^{A}$
\end_inset

 and a monad morphism 
\begin_inset Formula $p:M\leadsto P$
\end_inset

 between two monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

, define the operation 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-lift-simple-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}_{P}\triangleq\text{sop}_{P}\bef\text{ftn}_{P}$
\end_inset

 corresponding to 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 is expressed via 
\begin_inset Formula $\text{op}_{M}$
\end_inset

 by:
\begin_inset Formula 
\begin{equation}
\text{op}_{P}=\text{pu}_{M}^{\uparrow F}\bef\text{op}_{M}\bef p\bef\text{ftn}_{P}\label{eq:monatron-lifting-simple-op}
\end{equation}

\end_inset

and satisfies the monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-monadic-naturality-for-operations"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Here, we defined 
\begin_inset Formula $\text{op}_{M}\triangleq\text{sop}_{M}\bef\text{ftn}_{M}$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We substitute the definitions of 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 and the relationship between 
\begin_inset Formula $\text{sop}_{M}$
\end_inset

 and 
\begin_inset Formula $\text{op}_{M}$
\end_inset

:
\begin_inset Formula 
\[
\text{op}_{P}=\gunderline{\text{sop}_{P}}\bef\text{ftn}_{P}=\gunderline{\text{sop}_{M}}\bef p\bef\text{ftn}_{P}=\text{pu}_{M}^{\uparrow F}\bef\text{op}_{M}\bef p\bef\text{ftn}_{P}\quad.
\]

\end_inset

To verify the monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-monadic-naturality-for-operations"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }p^{\uparrow F}\bef\text{op}_{P}:\quad & \gunderline{\text{op}_{M}}\bef p=\text{sop}_{M}\bef\gunderline{\text{ftn}_{M}\bef p}\\
\text{monad morphism composition law of }p:\quad & =\gunderline{\text{sop}_{M}\bef p^{\uparrow M}}\bef p\bef\text{ftn}_{P}\\
\text{naturality law of }\text{sop}_{M}:\quad & =p^{\uparrow F}\bef\gunderline{\text{sop}_{M}\bef p}\bef\text{ftn}_{P}=p^{\uparrow F}\bef\gunderline{\text{sop}_{P}\bef\text{ftn}_{P}}=p^{\uparrow F}\bef\text{op}_{P}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The method of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-lifting-simple-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 allows us to lift a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation from a monad 
\begin_inset Formula $M$
\end_inset

 to any monad stack 
\begin_inset Formula $P$
\end_inset

 containing 
\begin_inset Formula $M$
\end_inset

, as long as we have a lift function 
\begin_inset Formula $p:M\leadsto P$
\end_inset

.
 The lift 
\begin_inset Formula $p$
\end_inset

 will exist if the monad 
\begin_inset Formula $M$
\end_inset

 is at the deep end of the stack, or if 
\begin_inset Formula $M$
\end_inset

's transformer supports a base lift.
 Accordingly, one must place the continuation monad, the search monad, the
 codensity monad, and task-like monads (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IO
\end_layout

\end_inset

) at the deep end of the stack, since those monads do not support base lifts.
\end_layout

\begin_layout Standard
The same method allows us to lift a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation if it is equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation.
 The condition for that equivalence is the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 If a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 satisfies that law, the corresponding lifted operation 
\begin_inset Formula $\text{op}_{P}$
\end_inset

 is expressed by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-lifting-simple-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Paragraph
Lifting 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations
\end_layout

\begin_layout Standard
Some 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations fail the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 So, they cannot be reduced to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation and require a different method of lifting.
\end_layout

\begin_layout Standard
We begin with the task of lifting a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}:F^{M^{A}}\rightarrow M^{A}$
\end_inset

 to a stack 
\begin_inset Formula $P$
\end_inset

 where the monad 
\begin_inset Formula $M$
\end_inset

 is located at the deep end.
 So, we assume that 
\begin_inset Formula $P=L\varangle M$
\end_inset

 for some base monad (or stack) 
\begin_inset Formula $L$
\end_inset

.
 The lifting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 to 
\begin_inset Formula $P$
\end_inset

 turns out to be complicated, so we split the procedure into four steps:
\end_layout

\begin_layout Standard
1.
 Convert 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 into an equivalent 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

) in the codensity 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!codensity monad
\end_layout

\end_inset

 monad on 
\begin_inset Formula $M$
\end_inset

 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-codensity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For brevity, we will denote the codensity monad 
\begin_inset Formula $\text{Cod}^{M,\bullet}$
\end_inset

 equivalently by 
\begin_inset Formula $\text{Cod}^{M}$
\end_inset

.
\end_layout

\begin_layout Standard
2.
 Lift 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

 to the stack 
\begin_inset Formula $P^{\prime}\triangleq L\varangle\text{Cod}^{M}$
\end_inset

 that contains the codensity monad instead of 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
3.
 Transform the stack, replacing the codensity monad 
\begin_inset Formula $\text{Cod}^{M}$
\end_inset

 by the original monad 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
4.
 Derive the code for the new operation (
\begin_inset Formula $\text{op}_{P}$
\end_inset

).
\end_layout

\begin_layout Standard
We will now go through these steps in detail.
 
\end_layout

\begin_layout Standard
The first step introduces the codensity monad 
\begin_inset Formula $\text{Cod}^{M}$
\end_inset

.
 It turns out that the type of natural transformations 
\begin_inset Formula $F^{M^{A}}\rightarrow M^{A}$
\end_inset

 (the type of 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations in the monad 
\begin_inset Formula $M$
\end_inset

) is 
\emph on
equivalent
\emph default
 to the type of natural transformations 
\begin_inset Formula $F^{A}\rightarrow\text{Cod}^{M,A}$
\end_inset

 (the type of 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations in the codensity monad on 
\begin_inset Formula $M$
\end_inset

).
 To prove this, we will derive a more general property that does not depend
 on any monads:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-kan-extension-property"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-kan-extension-property"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, the type of natural transformations 
\begin_inset Formula $\forall A.\,F^{K^{A}}\rightarrow L^{A}$
\end_inset

 is equivalent to the following type of natural transformations:
\begin_inset Foot
status open

\begin_layout Plain Layout
For some (but not all) functors 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

, the type 
\begin_inset Formula $\forall R.\,(A\rightarrow K^{R})\rightarrow L^{R}$
\end_inset

 implements the construction known in category theory as the 
\series bold
right Kan extension
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
right Kan extension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Kan extension
\end_layout

\end_inset

 of 
\begin_inset Formula $L$
\end_inset

 along 
\begin_inset Formula $K$
\end_inset

.
 See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://bartoszmilewski.com/2017/04/17/kan-extensions/"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\forall(A,R).\,F^{A}\rightarrow(A\rightarrow K^{R})\rightarrow L^{R}\quad,
\]

\end_inset

where naturality laws are required to hold with respect to both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Swap the curried arguments in the type signature 
\begin_inset Formula $F^{A}\rightarrow(A\rightarrow K^{R})\rightarrow L^{R}$
\end_inset

:
\begin_inset Formula 
\[
\forall(A,R).\,F^{A}\rightarrow(A\rightarrow K^{R})\rightarrow L^{R}\cong\forall(A,R).\,(A\rightarrow K^{R})\rightarrow F^{A}\rightarrow L^{R}=\forall R.\,\big(\forall A.\,(A\rightarrow K^{R})\rightarrow H^{A,R}\big)\quad,
\]

\end_inset

where we define 
\begin_inset Formula $H^{A,R}\triangleq F^{A}\rightarrow L^{R}$
\end_inset

.
 The type constructor 
\begin_inset Formula $H^{A,R}$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

.
 Since we assume the naturality laws to hold, we are dealing with functions
 of type 
\begin_inset Formula $\forall A.\,(A\rightarrow K^{R})\rightarrow H^{A,R}$
\end_inset

 that are natural transformations between contrafunctors.
 So, we may use the contravariant Yoneda identity (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-contravariant-yoneda-identity-for-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with respect to 
\begin_inset Formula $A$
\end_inset

.
 With that, we obtain the following type equivalence:
\begin_inset Formula 
\[
\forall A.\,(A\rightarrow K^{R})\rightarrow H^{A,R}\cong H^{K^{R},R}\quad.
\]

\end_inset

It remains to substitute the definition of 
\begin_inset Formula $H^{\bullet,\bullet}$
\end_inset

 and to rename 
\begin_inset Formula $R$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula 
\[
\forall R.\,H^{K^{R},R}=\forall R.\,F^{K^{R}}\rightarrow L^{R}=\forall A.\,F^{K^{A}}\rightarrow L^{A}\quad.
\]

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Using Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-kan-extension-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $K=L=M$
\end_inset

, we find that a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 in a monad 
\begin_inset Formula $M$
\end_inset

 is equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

 in the codensity monad 
\begin_inset Formula $\text{Cod}^{M}$
\end_inset

.
 We define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 by:
\begin_inset Formula 
\begin{equation}
\text{scop}:F^{A}\rightarrow(A\rightarrow M^{R})\rightarrow M^{R}\quad,\quad\quad\text{scop}\triangleq f^{:F^{A}}\rightarrow k^{:A\rightarrow M^{R}}\rightarrow f\triangleright k^{\uparrow F}\triangleright\text{op}^{R}\quad.\label{eq:monatron-scop-via-op}
\end{equation}

\end_inset

We can lift 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

 to the stack 
\begin_inset Formula $P^{\prime}\triangleq L\varangle\text{Cod}^{M}$
\end_inset

 that contains the codensity monad 
\begin_inset Formula $\text{Cod}^{M}$
\end_inset

 instead of 
\begin_inset Formula $M$
\end_inset

.
 The result is a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset Formula $\text{scop}_{P^{\prime}}$
\end_inset

) defined by:
\begin_inset Formula 
\[
\text{scop}_{P^{\prime}}:F^{A}\rightarrow(L\varangle\text{Cod}^{M,\bullet})^{A}\quad,\quad\quad\text{scop}_{P^{\prime}}\triangleq\text{scop}\bef\text{flift}_{L}^{\text{Cod}^{M}}\quad.
\]

\end_inset

It remains somehow to convert the operation 
\begin_inset Formula $\text{scop}_{P^{\prime}}$
\end_inset

 into a corresponding operation in the stack 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
Since the monad 
\begin_inset Formula $M$
\end_inset

 is injectively embedded within 
\begin_inset Formula $\text{Cod}^{M}$
\end_inset

 via the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-codensity-monad-inC-outC"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we may use 
\begin_inset Formula $L$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 to transform between 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $P^{\prime}$
\end_inset

 in both directions:
\begin_inset Formula 
\[
\text{frun}_{L}(\text{inC}):L\varangle M\leadsto L\varangle\text{Cod}^{M}\cong P\leadsto P^{\prime}\quad,\quad\quad\text{frun}_{L}(\text{outC}):L\varangle\text{Cod}^{M}\leadsto L\varangle M\cong P^{\prime}\leadsto P\quad.
\]

\end_inset

One way of converting 
\begin_inset Formula $\text{scop}_{P^{\prime}}$
\end_inset

 into a 
\begin_inset Formula $P$
\end_inset

-operation would be to compose with 
\begin_inset Formula $\text{flift}_{L}(\text{outC})$
\end_inset

, which creates a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 of type 
\begin_inset Formula $F^{A}\rightarrow P^{A}$
\end_inset

.
 However, the resulting operation would not correctly extend 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

's effect transformation to the stack 
\begin_inset Formula $P$
\end_inset

.
 To see why, we rewrite 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
 & \text{sop}_{P}\triangleq\text{scop}_{P^{\prime}}\bef\text{flift}_{L}(\text{outC})=\text{scop}\bef\gunderline{\text{flift}_{L}\bef\text{frun}_{L}}(\text{outC})\\
\text{monadic naturality law of }\text{flift}_{L}:\quad & =\text{scop}\bef\text{outC}\bef\text{flift}_{L}=(f\rightarrow k\rightarrow f\triangleright k^{\uparrow F}\triangleright\text{op})\bef\text{outC}\bef\text{flift}_{L}\\
 & =(\gunderline{f\rightarrow f\,\triangleright}\,\text{pu}_{M}^{\uparrow F}\bef\text{op})\bef\text{flift}_{L}=\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\text{flift}_{L}\quad.
\end{align*}

\end_inset

We find that the operation 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 is the lifted version of 
\begin_inset Formula $\text{sop}\triangleq\text{pu}_{M}^{\uparrow F}\bef\text{op}$
\end_inset

, which is the 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 counterpart of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

.
 However, by assumption, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 fails to obey the compatibility law and is not equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

.
 In other words, the operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

 does not perform the same transformation of 
\begin_inset Formula $M$
\end_inset

-effects as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

.
 So, the operation 
\begin_inset Formula $\text{sop}_{P}$
\end_inset

 fails to be a correct lifting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In this derivation, we used the monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-flift"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 with 
\begin_inset Formula $\phi\triangleq\text{outC}$
\end_inset

, although 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 a monad morphism.
 This is justified because (as we have proved in this chapter) all monad
 transformers that support 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 will also satisfy the monadic naturality law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monadic-naturality-law-of-flift"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 with 
\begin_inset Formula $\phi$
\end_inset

 being any natural transformation, not necessarily a monad morphism.
 
\end_layout

\begin_layout Standard
To obtain a correct lifting, the equivalence between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

 must be expressed differently:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-equivalence-op-cop"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-equivalence-op-cop"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 in a monad 
\begin_inset Formula $M$
\end_inset

, define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-scop-via-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Also, define the corresponding 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cop
\end_layout

\end_inset

 (in the codensity monad) via Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-simple-standard-operations-monatron"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{2.0pc}F^{M^{A}}\ar[d]\sb(0.45){\text{op}}\ar[r]\sb(0.45){\text{inC}^{\uparrow F}} & F^{\text{Cod}^{M,A}}\ar[d]\sp(0.45){\text{cop}}\\
M^{A} & \text{Cod}^{M,A}\ar[l]\sp(0.55){\text{outC}}
}
\]

\end_inset


\begin_inset Formula 
\[
\text{cop}:F^{\text{Cod}^{M,A}}\rightarrow\text{Cod}^{M,A}\quad,\quad\quad\text{cop}\triangleq\text{scop}\bef\text{ftn}_{\text{Cod}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 may be expressed through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cop
\end_layout

\end_inset

 by the following code:
\begin_inset Formula 
\begin{equation}
\text{op}=\text{inC}^{\uparrow F}\bef\text{cop}\bef\text{outC}\quad.\label{eq:monatron-op-through-cop}
\end{equation}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
In the derivation, we will need the code of 
\begin_inset Formula $^{\uparrow\text{Cod}}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{\text{Cod}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f^{:A\rightarrow B})^{\uparrow\text{Cod}}=c^{:\text{Cod}^{M,A}}\rightarrow\forall R.\,k^{:B\rightarrow M^{R}}\rightarrow c(f\bef k)\quad,\\
 & c^{:\text{Cod}^{M,\text{Cod}^{M,A}}}\triangleright\text{ftn}_{\text{Cod}}=k^{:A\rightarrow M^{R}}\rightarrow c\big(d^{:\text{Cod}^{M,A}}\rightarrow d(k)\big)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We rewrite the right-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-op-through-cop"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and use the definitions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cop
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{op}:\quad & \text{inC}^{\uparrow F}\bef\gunderline{\text{cop}}\bef\text{outC}=\gunderline{\text{inC}^{\uparrow F}\bef\text{scop}}\bef\text{ftn}_{\text{Cod}}\bef\text{outC}\\
\text{naturality law of }\text{scop}:\quad & =\text{scop}\bef\text{inC}^{\uparrow\text{Cod}}\bef\text{ftn}_{\text{Cod}}\bef\text{outC}\\
\text{use Eq.~(\ref{eq:monatron-scop-via-op}) and }^{\uparrow\text{Cod}}:\quad & =(f\rightarrow k\rightarrow f\triangleright k^{\uparrow F}\triangleright\text{op})\bef(c\rightarrow k\rightarrow c(\text{inC}\bef k))\bef\text{ftn}_{\text{Cod}}\bef\text{outC}\\
\text{compute composition}:\quad & =f\rightarrow\big(k\rightarrow f\triangleright\gunderline{(\text{inC}\bef k)^{\uparrow F}}\triangleright\text{op}\big)\triangleright\text{ftn}_{\text{Cod}}\triangleright\text{outC}\\
\text{definition of }\text{ftn}_{\text{Cod}}:\quad & =f\rightarrow\big(k\rightarrow f\triangleright\text{inC}^{\uparrow F}\bef(d\rightarrow d(k))^{\uparrow F}\bef\text{op}\big)\triangleright\text{outC}\\
\text{definition of }\text{outC}:\quad & =f\rightarrow f\triangleright\text{inC}^{\uparrow F}\bef(\gunderline{d\rightarrow d(\text{pu}_{M})})^{\uparrow F}\bef\text{op}\\
\text{definition of }\text{outC}:\quad & =f\rightarrow f\triangleright\text{inC}^{\uparrow F}\bef\text{outC}^{\uparrow F}\bef\text{op}=f\rightarrow f\triangleright\text{op}=\text{op}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We may convert 
\begin_inset Formula $\text{scop}_{P^{\prime}}$
\end_inset

 into the corresponding 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset Formula $\text{cop}_{P^{\prime}}$
\end_inset

):
\begin_inset Formula 
\[
\text{cop}_{P^{\prime}}:F^{P^{\prime A}}\rightarrow P^{\prime A}\quad,\quad\text{cop}_{P^{\prime}}\triangleq\text{scop}_{P^{\prime}}\bef\text{ftn}_{P^{\prime}}\quad\quad.
\]

\end_inset

To convert 
\begin_inset Formula $\text{cop}_{P^{\prime}}$
\end_inset

 into 
\begin_inset Formula $\text{op}_{P}$
\end_inset

, we note that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-op-through-cop"
plural "false"
caps "false"
noprefix "false"

\end_inset

) expresses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cop
\end_layout

\end_inset

 using the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

, which transform between the monads 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $\text{Cod}^{M}$
\end_inset

.
 Lifting these functions with 
\begin_inset Formula $\text{frun}_{L}$
\end_inset

, we can express the operation 
\begin_inset Formula $\text{op}_{P}$
\end_inset

 via 
\begin_inset Formula $\text{cop}_{P^{\prime}}$
\end_inset

 like this:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{4.0pc}F^{P^{A}}\ar[d]\sb(0.45){\text{op}_{P}}\ar[r]\sp(0.55){(\text{frun}_{L}(\text{inC}))^{\uparrow F}} & F^{P^{\prime A}}\ar[d]\sp(0.45){\text{cop}_{P^{\prime}}}\\
P^{A} & P^{\prime A}\ar[l]\sb(0.45){\text{frun}_{L}(\text{outC})}
}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\text{op}_{P}=(\text{frun}_{L}(\text{inC}))^{\uparrow F}\bef\text{cop}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\quad.\label{eq:monatron-op-P-via-cop}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The following statement shows that the resulting operation (
\begin_inset Formula $\text{op}_{P}$
\end_inset

) is a correct lifting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-standard-lifting-op"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-standard-lifting-op"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $\text{op}_{P}$
\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-op-P-via-cop"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is a monadically natural lifting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 if the monad transformer 
\begin_inset Formula $T_{L}$
\end_inset

 has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

 method and if the monadic naturality law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 holds for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 (even though 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

 is not a monad morphism).
\begin_inset Foot
status open

\begin_layout Plain Layout
This version of the monadic naturality law holds for all monad transformers
 that support 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

frun
\end_layout

\end_inset

, as this chapter proved.
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The lifting of 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $P$
\end_inset

 is given by 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

.
 To verify the monadic naturality law of 
\begin_inset Formula $\text{op}_{P}$
\end_inset

, we will have to use the monad morphism composition law of 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

:
\begin_inset Formula 
\[
\text{flift}_{L}^{\uparrow\text{Cod}}\bef\text{flift}_{L}\bef\text{ftn}_{P^{\prime}}=\text{ftn}_{\text{Cod}}\bef\text{flift}_{L}\quad.
\]

\end_inset

To be able to use that law, we need to move the two functions 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

 towards 
\begin_inset Formula $\text{ftn}_{P^{\prime}}$
\end_inset

.
 Compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(\text{op}\bef\text{flift}_{L}):\quad & \text{flift}_{L}^{\uparrow F}\bef\text{op}_{P}=\text{flift}_{L}^{\uparrow F}\bef(\text{frun}_{L}(\text{inC}))^{\uparrow F}\bef\text{cop}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\\
 & =\big(\gunderline{\text{flift}_{L}\bef\text{frun}_{L}(\text{inC})}\big)^{\uparrow F}\bef\text{scop}_{P^{\prime}}\bef\text{ftn}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\\
\text{monadic naturality law of }\text{flift}_{L}:\quad & =\big(\text{inC}\bef\text{flift}_{L}\gunderline{\big)^{\uparrow F}\bef\text{scop}}\bef\text{flift}_{L}\bef\text{ftn}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\\
\text{naturality law of }\text{scop}:\quad & =\text{scop}\bef\text{inC}^{\uparrow\text{Cod}}\bef\gunderline{\text{flift}_{L}^{\uparrow\text{Cod}}\bef\text{flift}_{L}\bef\text{ftn}_{P^{\prime}}}\bef\text{frun}_{L}(\text{outC})\\
\text{composition law of }\text{flift}_{L}:\quad & =\text{scop}\bef\text{inC}^{\uparrow\text{Cod}}\bef\text{ftn}_{\text{Cod}}\bef\gunderline{\text{flift}_{L}\bef\text{frun}_{L}(\text{outC})}\\
\text{monadic naturality law of }\text{flift}_{L}:\quad & =\text{scop}\bef\text{inC}^{\uparrow\text{Cod}}\bef\text{ftn}_{\text{Cod}}\bef\text{outC}\bef\text{flift}_{L}\quad.
\end{align*}

\end_inset

In the last line, we used the monadic naturality law of 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

 applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outC
\end_layout

\end_inset

, which holds by assumption.
 We now reuse the last derivation in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-equivalence-op-cop"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we found that:
\begin_inset Formula 
\[
\text{scop}\bef\text{inC}^{\uparrow\text{Cod}}\bef\text{ftn}_{\text{Cod}}\bef\text{outC}=\text{op}\quad.
\]

\end_inset

This completes the proof of the equation 
\begin_inset Formula $\text{flift}_{L}^{\uparrow F}\bef\text{op}_{P}=\text{op}\bef\text{flift}_{L}$
\end_inset

.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
What if we use this method to lift a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation that is actually equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 one and could be lifted more easily by composing with a monad morphism
 
\begin_inset Formula $p:M\leadsto P$
\end_inset

? It turns out that the lifted operations will be the same:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-lifting-op-and-sop"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-lifting-op-and-sop"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume the conditions of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-standard-lifting-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and additionally assume that the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 is equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

 (so that 
\begin_inset Formula $\text{op}=\text{sop}\bef\text{ftn}_{M}$
\end_inset

).
 Then the lifted 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset Formula $\text{op}_{P}$
\end_inset

) is equivalent to the lifted 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset Formula $\text{sop}_{P}\triangleq\text{sop}\bef\text{flift}_{L}$
\end_inset

) according to the usual formula 
\begin_inset Formula $\text{op}_{P}=\text{sop}_{P}\bef\text{ftn}_{P}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Proof
\end_layout

\begin_layout Standard
Begin by rewriting Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-op-P-via-cop"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(\text{sop}_{P}\bef\text{ftn}_{P}):\quad & \text{op}_{P}=(\text{frun}_{L}(\text{inC}))^{\uparrow F}\bef\gunderline{\text{cop}_{P^{\prime}}}\bef\text{frun}_{L}(\text{outC})\\
\text{definition of }\text{cop}_{P^{\prime}}:\quad & =\gunderline{(\text{frun}_{L}(\text{inC}))^{\uparrow F}\bef\text{scop}_{P^{\prime}}}\bef\text{ftn}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\\
\text{naturality law of }\text{scop}_{P^{\prime}}:\quad & =\gunderline{\text{scop}_{P^{\prime}}}\bef(\text{frun}_{L}(\text{inC}))^{\uparrow P^{\prime}}\bef\text{ftn}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\\
\text{definition of }\text{scop}_{P^{\prime}}:\quad & =\text{scop}\bef\text{flift}_{L}^{\text{Cod}}\bef(\text{frun}_{L}(\text{inC}))^{\uparrow P^{\prime}}\bef\text{ftn}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\quad.
\end{align*}

\end_inset

At this point, we substitute 
\begin_inset Formula $\text{op}=\text{sop}\bef\text{ftn}_{M}$
\end_inset

 into Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-scop-via-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and rewrite 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scop
\end_layout

\end_inset

 in terms of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inC
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{scop}\triangleq f^{:F^{A}}\rightarrow k^{:A\rightarrow M^{R}}\rightarrow f\triangleright k^{\uparrow F}\triangleright\text{op}=f\rightarrow k\rightarrow f\triangleright\gunderline{k^{\uparrow F}\bef\text{sop}}\bef\text{ftn}_{M}\\
\text{naturality law of }\text{sop}:\quad & =f\rightarrow k\rightarrow f\triangleright\text{sop}\gunderline{\bef k^{\uparrow M}\bef\text{ftn}_{M}}=f\rightarrow k\rightarrow f\triangleright\text{sop}\bef\text{flm}_{M}(k)\\
\text{move }\text{sop}\text{ outside}:\quad & =(f\rightarrow f\triangleright\text{sop})\bef(\gunderline{f\rightarrow k\rightarrow f\triangleright\text{flm}_{M}(k)})=\text{sop}\bef\text{inC}\quad.
\end{align*}

\end_inset

Now we continue the derivation:
\begin_inset Formula 
\begin{align*}
\text{substitute }\text{scop}=\text{sop}\bef\text{inC}:\quad & =\text{sop}\bef\gunderline{\text{inC}\bef\text{flift}_{L}^{\text{Cod}}}\bef(\text{frun}_{L}(\text{inC}))^{\uparrow P^{\prime}}\bef\text{ftn}_{P^{\prime}}\bef\text{frun}_{L}(\text{outC})\\
\text{monadic naturality law of }\text{flift}_{L}:\quad & =\text{sop}\bef\text{flift}_{L}\bef\gunderline{\text{frun}_{L}(\text{inC})\bef(\text{frun}_{L}(\text{inC}))^{\uparrow P^{\prime}}\bef\text{ftn}_{P^{\prime}}}\bef\text{frun}_{L}(\text{outC})\\
\text{composition law of }\text{frun}_{L}(\text{inC}):\quad & =\text{sop}\bef\text{flift}_{L}\bef\text{ftn}_{P}\bef\gunderline{\text{frun}_{L}(\text{inC})\bef\text{frun}_{L}(\text{outC})}\\
\text{composition law of }\text{frun}_{L}:\quad & =\text{sop}\bef\text{flift}_{L}\bef\text{ftn}_{P}\bef\text{frun}_{L}(\gunderline{\text{inC}\bef\text{outC}})\\
\text{use }\text{inC}\bef\text{outC}=\text{id}:\quad & =\gunderline{\text{sop}\bef\text{flift}_{L}}\bef\text{ftn}_{P}=\text{sop}_{P}\bef\text{ftn}_{P}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Paragraph
Lifting to the base monad
\end_layout

\begin_layout Standard
The method just shown lifts 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $M$
\end_inset

-operations to monad stacks 
\begin_inset Formula $L\varangle M$
\end_inset

 where the monad 
\begin_inset Formula $M$
\end_inset

 is located at the deep end.
 If 
\begin_inset Formula $M$
\end_inset

 is located somewhere else in the stack, there exist monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 such that the stack 
\begin_inset Formula $P$
\end_inset

 is expressed as 
\begin_inset Formula $P=L\varangle M\varangle N$
\end_inset

.
 If we knew how to lift 
\begin_inset Formula $M$
\end_inset

-operations to the stack 
\begin_inset Formula $M\varangle N$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

 is the base monad), we will then be able to lift them also to 
\begin_inset Formula $P$
\end_inset

 since the monad 
\begin_inset Formula $M\varangle N$
\end_inset

 is located at the deep end of 
\begin_inset Formula $P$
\end_inset

.
 So, it remains to see how 
\begin_inset Formula $M$
\end_inset

-operations may be lifted to a stack 
\begin_inset Formula $M\varangle N$
\end_inset

 that has 
\begin_inset Formula $M$
\end_inset

 as its base monad.
\end_layout

\begin_layout Standard
All 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $M$
\end_inset

-operations that satisfy the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are equivalent to 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations and are lifted to the stack 
\begin_inset Formula $Q\triangleq M\varangle N$
\end_inset

 using 
\begin_inset Formula $Q$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 function.
 (For monads whose transformers do not support base lifts, operations must
 be lifted by custom code.) It remains to consider 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations 
\begin_inset Formula $\text{op}:F\circ M\leadsto M$
\end_inset

 that do 
\emph on
not
\emph default
 satisfy the compatibility law.
 Our goal is to obtain a lifted operation 
\begin_inset Formula $\text{op}_{Q}:F\circ Q\leadsto Q$
\end_inset

 out of a given non-
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M$
\end_inset

's transformer is composed-inside (so that 
\begin_inset Formula $Q^{A}\triangleq M^{N^{A}}$
\end_inset

), defining 
\begin_inset Formula $\text{op}_{Q}$
\end_inset

 is straightforward:
\begin_inset Formula 
\[
\text{op}_{Q}:F^{M^{N^{A}}}\rightarrow M^{N^{A}}\quad,\quad\quad\text{op}_{Q}\triangleq\text{op}^{N^{A}}\quad.
\]

\end_inset

To show that 
\begin_inset Formula $\text{op}_{Q}$
\end_inset

 is a monadically natural lifting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

, compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(\text{op}\bef\text{blift}_{M}):\quad & \text{blift}_{M}^{\uparrow F}\bef\text{op}_{Q}=\text{pu}_{N}^{\uparrow M\uparrow F}\bef\text{op}_{Q}\\
\text{naturality law of }\text{op}_{Q}:\quad & =\text{op}_{Q}\bef\text{pu}_{N}^{\uparrow M}=\text{op}\bef\text{blift}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This case covers rigid monads (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 with its non-
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

local
\end_layout

\end_inset

 operation) but does not apply, e.g., to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 operation or to other non-rigid monads.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's transformer is composed-outside, so 
\begin_inset Formula $M\varangle N=N\circ M$
\end_inset

.
 We could implement a function of type 
\begin_inset Formula $F^{N^{M^{A}}}\rightarrow N^{M^{A}}$
\end_inset

given a function 
\begin_inset Formula $\text{op}:F^{M^{A}}\rightarrow M^{A}$
\end_inset

, but that function will not be a monadically natural lifting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-not-natural-lifting-linear-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-not-natural-lifting-linear-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $M$
\end_inset

 is a monad with a composed-outside transformer, 
\begin_inset Formula $N$
\end_inset

 is another monad, and 
\begin_inset Formula $\text{op}:F^{M^{A}}\rightarrow M^{A}$
\end_inset

 is a given 
\begin_inset Formula $M$
\end_inset

-operation that does 
\emph on
not
\emph default
 satisfy the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Then the function 
\begin_inset Formula $\text{op}_{Q}$
\end_inset

 defined by:
\begin_inset Formula 
\[
\text{op}_{Q}:F^{N^{M^{A}}}\rightarrow N^{M^{A}}\quad,\quad\quad\text{op}_{Q}\triangleq\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\text{pu}_{N}\bef\text{ftn}_{N\circ M}
\]

\end_inset

is 
\emph on
not
\emph default
 a monadically natural lifting of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 to the stack 
\begin_inset Formula $Q\triangleq M\varangle N\cong N\circ M$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Using the definition 
\begin_inset Formula $\text{blift}_{M}\triangleq\text{pu}_{N}$
\end_inset

, we write the two sides of the monadic naturality law:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & \text{op}\bef\text{blift}_{M}=\text{op}\bef\text{pu}_{N}\quad,\\
\text{right-hand side}:\quad & \text{blift}_{M}^{\uparrow F}\bef\text{op}_{Q}=\gunderline{\text{pu}_{N}^{\uparrow F}\bef\text{pu}_{M}^{\uparrow F}}\bef\text{op}\bef\text{pu}_{N}\bef\text{ftn}_{N\circ M}\\
\text{naturality law of }\text{pu}_{M}:\quad & =\text{pu}_{M}^{\uparrow F}\bef\gunderline{\text{pu}_{N}^{\uparrow M\uparrow F}\bef\text{op}}\bef\text{pu}_{N}\bef\text{ftn}_{N\circ M}\\
\text{naturality law of }\text{op}:\quad & \quad=\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\gunderline{\text{pu}_{N}^{\uparrow M}\bef\text{pu}_{N}}\bef\text{ftn}_{N\circ M}=\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\gunderline{\text{blift}_{M}^{\uparrow M}\bef\text{blift}_{M}\bef\text{ftn}_{N\circ M}}\\
\text{composition law of }\text{blift}:\quad & \quad=\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\text{ftn}_{M}\bef\gunderline{\text{blift}_{M}}=\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\text{ftn}_{M}\bef\text{pu}_{N}\quad.
\end{align*}

\end_inset

The two sides would be equal if:
\begin_inset Formula 
\[
\text{op}\bef\text{pu}_{N}\overset{?}{=}\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\text{ftn}_{M}\bef\text{pu}_{N}\quad.
\]

\end_inset

This would be true if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 satisfied the compatibility law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), because then we would have:
\begin_inset Formula 
\[
\text{pu}_{M}^{\uparrow F}\bef\text{op}\bef\text{ftn}_{M}=\gunderline{\text{pu}_{M}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}}\bef\text{op}=\text{op}\quad.
\]

\end_inset

However, by assumption the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:monatron-standard-operation-compatibility-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

) does not hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

.
 To see that this is sufficient to destroy the monadic naturality of 
\begin_inset Formula $\text{op}_{Q}$
\end_inset

, choose 
\begin_inset Formula $F\triangleq\text{Id}$
\end_inset

, 
\begin_inset Formula $N\triangleq\text{Id}$
\end_inset

, 
\begin_inset Formula $M^{A}\triangleq A\times W$
\end_inset

 (a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad), and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset


\begin_inset Formula $=$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{clear}:M^{A}\rightarrow M^{A}\quad,\quad\quad\text{clear}\triangleq a^{:A}\times\_^{:W}\rightarrow a\times e_{W}\quad.
\]

\end_inset

Then 
\begin_inset Formula $\text{pu}_{N}=\text{id}$
\end_inset

, and we compute 
\begin_inset Formula $\text{pu}_{M}^{\uparrow F}\bef\text{clear}\bef\text{ftn}_{M}\bef\text{pu}_{N}$
\end_inset

 as a function of type 
\begin_inset Formula $A\times W\rightarrow A\times W$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{pu}_{M}^{\uparrow F}\bef\text{clear}\bef\text{ftn}_{M}\bef\text{pu}_{N}=(a\times w\rightarrow a\times w\times e_{W})\bef(b^{:A\times W}\times\_^{:W}\rightarrow b\times e_{W})\bef\text{ftn}_{M}\\
 & =a\times w\rightarrow\text{ftn}_{M}(a\times w\times e_{W})=a\times w\rightarrow a\times w=\text{id}\quad.
\end{align*}

\end_inset

This is not equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 is not an identity function.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
As the case of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad shows, it does not seem possible to implement a monadically natural
 lifting to the base monad for all monads 
\begin_inset Formula $M$
\end_inset

 at once.
 The method of Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-equivalence-op-cop"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-standard-lifting-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot be used because the codensity monad's transformer does not support
 base lifts.
 So, lifting those operations requires custom code adapted to the particular
 structure of the functor 
\begin_inset Formula $F$
\end_inset

 and the base monad 
\begin_inset Formula $M$
\end_inset

.
 For example, we may lift the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 operation to any stack 
\begin_inset Formula $Q\triangleq M\varangle N=N\circ M$
\end_inset

 like this:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-lifting-writer-clear-to-base"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-lifting-writer-clear-to-base"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For any monad 
\begin_inset Formula $N$
\end_inset

, define 
\begin_inset Formula $Q\triangleq\text{Writer}^{W,\bullet}\varangle N$
\end_inset

, so 
\begin_inset Formula $Q^{A}\triangleq N^{A\times W}$
\end_inset

.
 A monadically natural lifting of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

clear
\end_layout

\end_inset

 operation to 
\begin_inset Formula $Q$
\end_inset

 is then defined by:
\begin_inset Formula 
\[
\text{clear}_{Q}:N^{A\times W}\rightarrow N^{A\times W}\quad,\quad\quad\text{clear}_{Q}\triangleq\text{clear}^{\uparrow N}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the monadic naturality law using 
\begin_inset Formula $\text{blift}_{\text{Writer}}\triangleq\text{pu}_{N}$
\end_inset

 and 
\begin_inset Formula $F=\text{Id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(\text{clear}\bef\text{pu}_{N}):\quad & \text{pu}_{N}^{\uparrow F}\bef\text{clear}_{Q}=\text{pu}_{N}\bef\text{clear}^{\uparrow N}\\
\text{naturality law of }\text{pu}_{N}:\quad & =\text{clear}\bef\text{pu}_{N}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
A similar case is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

handle
\end_layout

\end_inset

 operation:
\begin_inset Formula 
\[
\text{handle}:\left(E\rightarrow E+A\right)\times\left(E+A\right)\rightarrow E+A\quad,\quad\quad\text{handle}\triangleq h^{:E\rightarrow E+A}\times m^{:E+A}\rightarrow m\triangleright\,\begin{array}{|c||c|}
 & E+A\\
\hline E & h\\
A & a\rightarrow\bbnum 0+a
\end{array}\quad.
\]

\end_inset

This operation is of the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 form with the functor 
\begin_inset Formula $F^{B}\triangleq\left(E\rightarrow B\right)\times B$
\end_inset

 but is not equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation.
 Custom code is needed to lift the handle operation to a stack 
\begin_inset Formula $Q\triangleq\text{Either}^{E,\bullet}\varangle N$
\end_inset

:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-lifting-either-handle-to-base"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-lifting-either-handle-to-base"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monad 
\begin_inset Formula $N$
\end_inset

, define 
\begin_inset Formula $Q\triangleq\text{Either}^{E,\bullet}\varangle N$
\end_inset

, so 
\begin_inset Formula $Q^{A}\triangleq N^{E+A}$
\end_inset

 and 
\begin_inset Formula $\text{pu}_{Q}(a)=\text{pu}_{N}(\bbnum 0+a)$
\end_inset

.
 Then a monadically natural lifting of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

handle
\end_layout

\end_inset

 operation to 
\begin_inset Formula $Q$
\end_inset

 is:
\begin_inset Formula 
\[
\text{handle}_{Q}:(E\rightarrow Q^{A})\times Q^{A}\rightarrow Q^{A}\quad,\quad\quad\text{handle}_{Q}\triangleq h^{:E\rightarrow N^{E+A}}\times n^{:N^{E+A}}\rightarrow n\triangleright\text{flm}_{N}\bigg(\,\begin{array}{|c||c|}
 & N^{E+A}\\
\hline E & h\\
A & \text{pu}_{Q}
\end{array}\,\bigg)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify the monadic naturality law using 
\begin_inset Formula $\text{blift}_{\text{Either}}\triangleq\text{pu}_{N}$
\end_inset

 and 
\begin_inset Formula $F^{B}\triangleq\left(E\rightarrow B\right)\times B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect }(\text{handle}\bef\text{pu}_{N}):\quad & \text{pu}_{N}^{\uparrow F}\bef\text{handle}_{Q}=\big(h^{:E\rightarrow E+A}\times m^{:E+A}\rightarrow(h\bef\text{pu}_{N})\times(m\triangleright\text{pu}_{N})\big)\bef\text{handle}_{Q}\\
 & =h\times m\rightarrow m\triangleright\gunderline{\text{pu}_{N}\triangleright\text{flm}_{N}}\bigg(\,\begin{array}{|c||c|}
 & N^{E+A}\\
\hline E & h\bef\text{pu}_{N}\\
A & \text{pu}_{Q}
\end{array}\,\bigg)=h\times m\rightarrow m\triangleright\,\begin{array}{|c||c|}
 & N^{E+A}\\
\hline E & h\bef\text{pu}_{N}\\
A & \text{pu}_{Q}
\end{array}\\
 & =h\times m\rightarrow m\triangleright\,\begin{array}{|c||c|}
 & N^{E+A}\\
\hline E & h\\
A & a\rightarrow\bbnum 0+a
\end{array}\,\bef\text{pu}_{N}=\text{handle}\bef\text{pu}_{N}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
After writing custom code for lifting each 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 but non-
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation to the base monad of a stack, we will be able to lift those operation
s to arbitrary monad stacks.
 The length of the required custom code is linear in the number of such
 operations.
\end_layout

\begin_layout Standard
We could also combine all 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations (
\begin_inset Formula $\text{op}_{1}:F_{1}^{M^{A}}\rightarrow M^{A}$
\end_inset

, 
\begin_inset Formula $\text{op}_{2}:F_{2}^{M^{A}}\rightarrow M^{A}$
\end_inset

, etc.) into a single operation by using the type equivalence:
\begin_inset Formula 
\[
(F_{1}^{M^{A}}\rightarrow M^{A})\times(F_{2}^{M^{A}}\rightarrow M^{A})\cong\big(F_{1}^{M^{A}}+F_{2}^{M^{A}}\big)\rightarrow M^{A}\cong(F_{1}+F_{2})^{M^{A}}\rightarrow M^{A}\quad.
\]

\end_inset

The resulting 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation corresponds to the product of all 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations of the monad 
\begin_inset Formula $M$
\end_inset

.
 It is easier to reason about operations when all operations are combined
 into one.
 Having lifted the product of all operations, we obtain the product of lifted
 operations.
 However, this will not reduce the length of the required custom lifting
 code.
 Practical programming is easier when individual operations are kept separate.
\end_layout

\begin_layout Paragraph
\begin_inset Quotes eld
\end_inset

Flipped-standard
\begin_inset Quotes erd
\end_inset

 operations
\end_layout

\begin_layout Standard
It remains to lift operations that have neither a 
\begin_inset Quotes eld
\end_inset

fixed-type
\begin_inset Quotes erd
\end_inset

, nor 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

, nor a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 type signature.
 Four such operations are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:effectful-operations-for-some-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

process
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

.
 As we know from Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Filterable-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 function is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 with type signature 
\begin_inset Formula $\text{List}^{\bbnum 1+A}\rightarrow\text{List}^{A}$
\end_inset

.
 Then the type signatures of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

process
\end_layout

\end_inset

 are of the 
\begin_inset Quotes eld
\end_inset


\series bold
flipped-standard
\series default

\begin_inset Quotes erd
\end_inset

 form 
\begin_inset Formula $M^{F^{A}}\rightarrow M^{A}$
\end_inset

, where 
\begin_inset Formula $F$
\end_inset

 is some functor.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

 operation can be also transformed to a 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

 form:
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-collect-operation"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-collect-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

 operation:
\begin_inset Formula 
\[
\text{collect}:\forall A.\,A\times W\rightarrow(A\times W)\times W
\]

\end_inset

is equivalent to the type 
\begin_inset Formula $\forall A.\,(W\rightarrow A)\times W\rightarrow A\times W$
\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We use Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-kan-extension-property"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with the functors 
\begin_inset Formula $F$
\end_inset

, 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

 defined as 
\begin_inset Formula $F^{A}\triangleq A\times W$
\end_inset

, 
\begin_inset Formula $K^{A}\triangleq W\rightarrow A$
\end_inset

, and 
\begin_inset Formula $L^{A}\triangleq A\times W$
\end_inset

.
 The result is the type equivalence between:
\begin_inset Formula 
\[
\forall A.\,F^{K^{A}}\rightarrow L^{A}=\forall A.\,\left(W\rightarrow A\right)\times W\rightarrow A\times W
\]

\end_inset

and:
\begin_inset Formula 
\[
\forall A.\,F^{A}\rightarrow\forall R.\,(A\rightarrow K^{R})\rightarrow L^{R}=\forall A.\,A\times W\rightarrow\forall R.\,(A\rightarrow W\rightarrow R)\rightarrow R\times W\quad.
\]

\end_inset

Transforming the last type via the covariant Yoneda identity, we obtain
 the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \forall A.\,A\times W\rightarrow\forall R.\,(\gunderline{A\rightarrow W\rightarrow}\,R)\rightarrow R\times W\cong\forall A.\,A\times W\rightarrow\gunderline{\forall R.\,}(A\times W\rightarrow\gunderline{R)\rightarrow R}\times W\\
 & \cong\forall A.\,A\times W\rightarrow\left(A\times W\right)\times W\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
It follows that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

 operation may be expressed equivalently through an operation with the type
 signature 
\begin_inset Formula $\text{Writer}^{W,W\rightarrow A}\rightarrow\text{Writer}^{W,A}$
\end_inset

.
 That type is of 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

 form, 
\begin_inset Formula $M^{F^{A}}\rightarrow M^{A}$
\end_inset

, where 
\begin_inset Formula $M^{A}=\text{Writer}^{W,A}$
\end_inset

 and 
\begin_inset Formula $F^{A}\triangleq W\rightarrow A$
\end_inset

.
\end_layout

\begin_layout Standard
If an operation of 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

 form (
\begin_inset Formula $M^{F^{A}}\rightarrow M^{A}$
\end_inset

) satisfies a suitable compatibility law, it is equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset Formula $F^{A}\rightarrow M^{A}$
\end_inset

):
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-monatron-flipped-standard-op-equivalent-to-sop"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monatron-flipped-standard-op-equivalent-to-sop"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The type of functions 
\begin_inset Formula $\text{op}:M^{F^{A}}\rightarrow M^{A}$
\end_inset

 that obey the compatibility law:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{2.5pc}M^{M^{F^{A}}}\ar[d]\sb(0.45){\text{ftn}_{M}}\ar[r]\sb(0.55){\text{op}^{\uparrow M}} & M^{M^{A}}\ar[d]\sp(0.45){\text{ftn}_{M}}\\
M^{P^{A}}\ar[r]\sp(0.5){\text{op}} & M^{A}
}
\]

\end_inset


\begin_inset Formula 
\[
\text{op}^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{op}\quad,
\]

\end_inset

is equivalent to the type of functions 
\begin_inset Formula $F^{A}\rightarrow M^{A}$
\end_inset

.
 (Here 
\begin_inset Formula $M$
\end_inset

 is a monad and 
\begin_inset Formula $F$
\end_inset

 is any functor.)
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Given a function 
\begin_inset Formula $\text{op}:M^{F^{A}}\rightarrow M^{A}$
\end_inset

, define the corresponding operation 
\begin_inset Formula $\text{sop}:F^{A}\rightarrow M^{A}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{sop}\triangleq\text{pu}_{M}\bef\text{op}\quad.
\]

\end_inset

Given a function 
\begin_inset Formula $\text{sop}:F^{A}\rightarrow M^{A}$
\end_inset

, define the corresponding operation:
\begin_inset Formula 
\[
\text{op}\triangleq\text{sop}^{\uparrow M}\bef\text{ftn}_{M}=\text{flm}_{M}(\text{sop})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To verify one direction of the isomorphism, substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{op}:\quad & \text{sop}^{\uparrow M}\bef\text{ftn}_{M}=(\text{pu}_{M}\bef\gunderline{\text{op})^{\uparrow M}\bef\text{ftn}_{M}}\\
\text{compatibility law of }\text{op}:\quad & =\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\bef\text{op}=\text{op}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the reverse direction of the isomorphism, substitute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{sop}:\quad & \text{pu}_{M}\bef\text{op}=\text{pu}_{M}\bef\text{sop}^{\uparrow M}\bef\text{ftn}_{M}\\
\text{naturality law of }\text{pu}_{M}:\quad & =\text{sop}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}=\text{sop}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
If an operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 is defined via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

, the compatibility law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 will hold automatically:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(\text{ftn}_{M}\bef\text{op}):\quad & \text{op}^{\uparrow M}\bef\text{ftn}_{M}=(\text{sop}^{\uparrow M}\bef\gunderline{\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}}\\
\text{associativity law of }\text{ftn}_{M}:\quad & =\gunderline{\text{sop}^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{sop}^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{op}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

 operations that are equivalent to 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations may be lifted to monad stacks similarly to the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operations that are equivalent to 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations.
 An example of such an operation is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

: if the monad 
\begin_inset Formula $M$
\end_inset

 is at the same time a filterable functor, it is reasonable to require the
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
compatibility law!of 
\family typewriter
deflate
\family default
 and 
\family typewriter
flatten
\end_layout

\end_inset


\series bold
compatibility law
\series default
:
\begin_inset Formula 
\begin{equation}
\text{deflate}^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{deflate}\quad.\label{eq:compatibility-law-deflate-flatten}
\end{equation}

\end_inset

This law holds for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad (filtering before flattening or after flattening gives the same results).
 One can show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 is equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation that we will call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

defl
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{defl}:\bbnum 1+A\rightarrow\text{List}^{A}\quad,\quad\quad\text{defl}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times\text{List}^{A}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & a\rightarrow a\times(\bbnum 1+\bbnum 0)
\end{array}\quad,\quad\quad\text{deflate}=\text{flm}_{\text{List}}(\text{defl})\quad.
\]

\end_inset

To lift 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 to a stack 
\begin_inset Formula $P$
\end_inset

, we first lift 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

defl
\end_layout

\end_inset

 to 
\begin_inset Formula $P$
\end_inset

 by composing it with a monad morphism 
\begin_inset Formula $p:M\leadsto P$
\end_inset

 and then pass to the corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

deflate
\end_layout

\end_inset

 operation, defined by:
\begin_inset Formula 
\[
\text{deflate}_{P}\triangleq\text{flm}_{P}(\text{defl}_{P})=\text{flm}_{P}(\text{defl}\bef p)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
However, the other two operations of 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

 signature (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

process
\end_layout

\end_inset

) are 
\emph on
not
\emph default
 equivalent to 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations.
 Let us see how to lift those operations to an arbitrary monad stack containing
 the monad 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
We need to consider two cases: the stack 
\begin_inset Formula $P$
\end_inset

 contains 
\begin_inset Formula $M$
\end_inset

 at the deep end (
\begin_inset Formula $P\triangleq L\varangle M$
\end_inset

) or in the middle (
\begin_inset Formula $P\triangleq L\varangle M\varangle N$
\end_inset

).
 
\end_layout

\begin_layout Standard
In the first case, we assume that the monad 
\begin_inset Formula $L$
\end_inset

 has the foreign runner (
\begin_inset Formula $\text{frun}_{L}$
\end_inset

).
 For a given operation 
\begin_inset Formula $\text{op}:M^{F^{A}}\rightarrow M^{A}$
\end_inset

, we define the lifted operation (
\begin_inset Formula $\text{op}_{P}$
\end_inset

) by:
\begin_inset Formula 
\[
\text{op}_{P}:(L\varangle M)^{F^{A}}\rightarrow(L\varangle M)^{A}\quad,\quad\quad\text{op}_{P}\triangleq\text{frun}_{L}(\text{op})\quad.
\]

\end_inset

To verify the monadic naturality law of 
\begin_inset Formula $\text{op}_{P}$
\end_inset

 written as:
\begin_inset Formula 
\[
\text{flift}_{L}^{F^{A}}\bef\text{op}_{P}\overset{?}{=}\text{op}\bef\text{flift}_{L}\quad,
\]

\end_inset

we use the monadic naturality law of 
\begin_inset Formula $\text{flift}_{L}$
\end_inset

 applied to the natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 (which is not a monad morphism):
\begin_inset Formula 
\[
\text{flift}_{L}^{F^{A}}\bef\text{op}_{P}=\text{flift}_{L}\bef\text{frun}_{L}(\text{op})=\text{op}\bef\text{flift}_{L}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
In the second case, we need to lift 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 to the stack 
\begin_inset Formula $Q\triangleq M\varangle N$
\end_inset

 that contains 
\begin_inset Formula $M$
\end_inset

 as a base monad.
 In general (for arbitrary 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

 operations), this lifting is not possible since we cannot transform 
\begin_inset Formula $(M\varangle N)^{F^{A}}$
\end_inset

 to 
\begin_inset Formula $M^{F^{A}}$
\end_inset

.
 However, the operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

process
\end_layout

\end_inset

 are in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

 monad whose transformer is composed-outside (
\begin_inset Formula $M\varangle N=N\circ M$
\end_inset

).
 In that case, the lifted operation (
\begin_inset Formula $\text{op}_{Q}$
\end_inset

) can be defined by:
\begin_inset Formula 
\[
\text{op}_{Q}:N^{M^{F^{A}}}\rightarrow N^{M^{A}}\quad,\quad\quad\text{op}_{Q}\triangleq\text{op}^{\uparrow N}\quad.
\]

\end_inset

To verify the monadic naturality law of 
\begin_inset Formula $\text{op}_{Q}$
\end_inset

, we use the definition 
\begin_inset Formula $\text{blift}_{M}\triangleq\text{pu}_{N}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(\text{op}\bef\text{blift}_{M}):\quad & \text{blift}_{M}\bef\text{op}_{Q}=\text{pu}_{N}\bef\text{op}^{\uparrow N}=\text{op}\bef\text{pu}_{N}=\text{op}\bef\text{blift}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
The 
\family typewriter
callcc
\family default
 operation
\end_layout

\begin_layout Standard
has a type signature of neither 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 nor 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

 form:
\begin_inset Formula 
\[
\text{callcc}:\forall(A,B).\,((A\rightarrow\text{Cont}^{R,B})\rightarrow\text{Cont}^{R,A})\rightarrow\text{Cont}^{R,A}\quad.
\]

\end_inset

It turns out that, using some tricks, one can express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 through two 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations: one denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

jump
\end_layout

\end_inset

 (with type signature 
\begin_inset Formula $\text{jump}:\forall A.\,R\rightarrow\text{Cont}^{R,A}$
\end_inset

) and another denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

 (with type signature 
\begin_inset Formula $\text{scc}:\forall A.\,F^{A}\rightarrow\text{Cont}^{R,A}$
\end_inset

).
 The functor 
\begin_inset Formula $F$
\end_inset

 for operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

 is the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Sel
\family default
 (selector) monad
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

selector monad
\begin_inset Quotes erd
\end_inset

: 
\begin_inset Formula $F^{A}\triangleq\text{Sel}^{R,A}=(A\rightarrow R)\rightarrow A$
\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

 is studied in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-selector-and-continuation-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The two 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

jump
\end_layout

\end_inset

 are lifted straightforwardly to any monad stack.
 
\end_layout

\begin_layout Standard
To express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

jump
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

, we first convert 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

 to an equivalent 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

):
\begin_inset Formula 
\[
\text{cc}:\text{Sel}^{R,\,\text{Cont}^{R,A}}\rightarrow\text{Cont}^{R,A}\quad,\quad\quad\text{cc}\triangleq\text{scc}\bef\text{ftn}_{\text{Cont}}\quad.
\]

\end_inset

To arrive at a systematic way of transforming functions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

's type signature into functions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

's type signature, let us write out some more detail in the type signatures
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{callcc}:\forall(A,B).\,\big(\big((A\rightarrow(B\rightarrow R)\rightarrow R\big)\rightarrow\text{Cont}^{R,A}\big)\rightarrow\text{Cont}^{R,A}\quad,\\
 & \text{cc}:\forall A.\,\big(\big(((A\rightarrow R)\rightarrow R)\rightarrow R\big)\rightarrow\text{Cont}^{R,A}\big)\rightarrow\text{Cont}^{R,A}\quad.
\end{align*}

\end_inset

The difference is 
\begin_inset Formula $A\rightarrow(B\rightarrow R)\rightarrow R$
\end_inset

 instead of 
\begin_inset Formula $((A\rightarrow R)\rightarrow R)\rightarrow R$
\end_inset

.
 Note that the type parameter 
\begin_inset Formula $B$
\end_inset

 appears under the universal quantifier (
\begin_inset Formula $\forall B$
\end_inset

) and is in a covariant position.
 So, we can set 
\begin_inset Formula $B=\bbnum 0$
\end_inset

 in the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 and obtain an equivalent type:
\begin_inset Formula 
\[
\gunderline{\forall B.}\,A\rightarrow(\gunderline B\rightarrow R)\rightarrow R\cong A\rightarrow(\gunderline{\bbnum 0\rightarrow R})\rightarrow R\cong A\rightarrow\gunderline{\bbnum 1\rightarrow}\,R\cong A\rightarrow R\quad.
\]

\end_inset

The type 
\begin_inset Formula $A\rightarrow R$
\end_inset

 can be seen as equivalent to a function of type 
\begin_inset Formula $A\rightarrow(B\rightarrow R)\rightarrow R$
\end_inset

 that ignores its curried argument of type 
\begin_inset Formula $B\rightarrow R$
\end_inset

.
 In this way, the type expression supports an arbitrary type parameter 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
The next trick is to notice that there is a mapping from the type 
\begin_inset Formula $((A\rightarrow R)\rightarrow R)\rightarrow R$
\end_inset

 to 
\begin_inset Formula $A\rightarrow R$
\end_inset

:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-mapping-arrr-ar"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-mapping-arrr-ar"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 are some fixed types.
 The type 
\begin_inset Formula $((A\rightarrow R)\rightarrow R)\rightarrow R$
\end_inset

 can be surjectively mapped to the type 
\begin_inset Formula $A\rightarrow R$
\end_inset

, which, in turn, can be injectively mapped back to 
\begin_inset Formula $((A\rightarrow R)\rightarrow R)\rightarrow R$
\end_inset

.
 These two types are 
\emph on
not
\emph default
 equivalent (at least for some 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The mappings are implemented by two functions that we will call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

inS
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

outS
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{inS}:(A\rightarrow R)\rightarrow((A\rightarrow R)\rightarrow R)\rightarrow R\quad,\quad\quad\text{inS}\triangleq k^{:A\rightarrow R}\rightarrow c^{:(A\rightarrow R)\rightarrow R}\rightarrow c(k)\quad,\\
 & \text{outS}:\big(((A\rightarrow R)\rightarrow R)\rightarrow R\big)\rightarrow A\rightarrow R\quad,\quad\quad\text{outS}\triangleq s^{:((A\rightarrow R)\rightarrow R)\rightarrow R}\rightarrow a^{:A}\rightarrow s(k^{:A\rightarrow R}\rightarrow k(a))\quad.
\end{align*}

\end_inset

To prove the injective and surjective properties, we will show that 
\begin_inset Formula $\text{inS}\bef\text{outS}=\text{id}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }k:\quad & k^{:A\rightarrow R}\triangleright\text{inS}\triangleright\text{outS}=(c\rightarrow c(k))\triangleright\text{outS}=a\rightarrow(c\rightarrow c(k))(k\rightarrow k(a))\\
\text{compute composition}:\quad & =a\rightarrow k(a)=k\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To show that the types 
\begin_inset Formula $A\rightarrow R$
\end_inset

 and 
\begin_inset Formula $((A\rightarrow R)\rightarrow R)\rightarrow R$
\end_inset

 are not equivalent, we consider 
\begin_inset Formula $A=R=\bbnum 2$
\end_inset

 and find that these types have different cardinality.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
In the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

, the type 
\begin_inset Formula $((A\rightarrow R)\rightarrow R)\rightarrow R$
\end_inset

 appears wrapped under the functor 
\begin_inset Formula $(\bullet\rightarrow\text{Cont}^{R,A})\rightarrow\text{Cont}^{R,A}$
\end_inset

(here the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 are considered as fixed).
 Denoting that functor by 
\begin_inset Formula $G$
\end_inset

, we can write a function transforming the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

 into the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
G^{X}\triangleq(X\rightarrow\text{Cont}^{R,A})\rightarrow\text{Cont}^{R,A}\quad,\quad\quad\text{outS}^{\uparrow G}:G^{((A\rightarrow R)\rightarrow R)\rightarrow R}\rightarrow G^{A\rightarrow R}\quad.
\]

\end_inset

By Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Statement-functor-preserves-injective"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $\text{outS}^{\uparrow G}$
\end_inset

 is a surjective function.
 So, we will not lose information if we express 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

.
 Let us compute and simplify the code of 
\begin_inset Formula $\text{cc}\triangleright\text{outS}^{\uparrow G}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f^{:X\rightarrow Y})^{\uparrow G}\triangleq g^{:(X\rightarrow\text{Cont}^{R,A})\rightarrow\text{Cont}^{R,A}}\rightarrow h^{:Y\rightarrow\text{Cont}^{R,A}}\rightarrow g(f\bef h)\quad,\\
 & \text{cc}\triangleright\text{outS}^{\uparrow G}=h^{:(A\rightarrow R)\rightarrow\text{Cont}^{R,A}}\rightarrow\text{cc}\,(\text{outS}\bef h)\\
 & \quad=h^{:(A\rightarrow R)\rightarrow\text{Cont}^{R,A}}\rightarrow\text{cc}\,(s^{:((A\rightarrow R)\rightarrow R)\rightarrow R}\rightarrow h(a^{:A}\rightarrow s(k^{:A\rightarrow R}\rightarrow k(a))))\quad.
\end{align*}

\end_inset

To obtain 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

, we still need to to replace 
\begin_inset Formula $A\rightarrow R$
\end_inset

 by 
\begin_inset Formula $A\rightarrow\left(B\rightarrow R\right)\rightarrow R\cong A\rightarrow\text{Cont}^{R,B}$
\end_inset

 in the type of 
\begin_inset Formula $h$
\end_inset

.
 We insert an ignored argument of type 
\begin_inset Formula $B\rightarrow R$
\end_inset

 when 
\begin_inset Formula $h$
\end_inset

 is applied: 
\begin_inset Formula 
\[
\text{callcc}=h^{:(A\rightarrow\text{Cont}^{R,B})\rightarrow\text{Cont}^{R,A}}\rightarrow\text{cc}\,\big(s^{:\text{Cont}^{R,A\rightarrow R}}\rightarrow h(a^{:A}\rightarrow\_^{:B\rightarrow R}\rightarrow s(k^{:A\rightarrow R}\rightarrow k(a)))\big)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The last step is to obtain a formula for the operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

 after lifting to a monad stack 
\begin_inset Formula $P$
\end_inset

.
 We assume that a monad morphism 
\begin_inset Formula $p:\text{Cont}^{R,\bullet}\leadsto P$
\end_inset

 is given.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cc
\end_layout

\end_inset

 is equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

, the lifted operation (
\begin_inset Formula $\text{cc}_{P}$
\end_inset

) is defined by:
\begin_inset Formula 
\[
\text{cc}_{P}\triangleq\text{scc}\bef p\bef\text{ftn}_{P}\quad.
\]

\end_inset

It remains to express 
\begin_inset Formula $\text{callcc}_{P}$
\end_inset

 via 
\begin_inset Formula $\text{cc}_{P}$
\end_inset

 and the operations of the monad 
\begin_inset Formula $P$
\end_inset

.
 To achieve that, we cannot use the above formula for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 directly because it uses the type of 
\begin_inset Formula $\text{Cont}^{R,A}$
\end_inset

.
 Instead, we rewrite that formula using the functions:
\begin_inset Formula 
\[
\text{pu}_{\text{Cont}}(a^{:A})\triangleq k^{:A\rightarrow R}\rightarrow k(a)\quad,\quad\quad\text{jump}(r^{:R})\triangleq\_^{:X\rightarrow R}\rightarrow r\quad.
\]

\end_inset

The result is:
\begin_inset Formula 
\begin{align*}
 & \text{callcc}=h^{:(A\rightarrow\text{Cont}^{R,B})\rightarrow\text{Cont}^{R,A}}\rightarrow\text{cc}\,\big(s^{:\text{Cont}^{R,A\rightarrow R}}\rightarrow h(a^{:A}\rightarrow\gunderline{\_^{:B\rightarrow R}\rightarrow}\,s(\text{pu}_{\text{Cont}}(a)))\big)\\
 & =h^{:(A\rightarrow\text{Cont}^{R,B})\rightarrow\text{Cont}^{R,A}}\rightarrow\text{cc}\,\big(s^{:\text{Cont}^{R,A\rightarrow R}}\rightarrow h(\gunderline{a^{:A}\rightarrow\text{jump}(s(\text{pu}_{\text{Cont}}(a)))})\big)\\
 & =h^{:(A\rightarrow\text{Cont}^{R,B})\rightarrow\text{Cont}^{R,A}}\rightarrow\text{cc}\,\big(s^{:\text{Cont}^{R,A\rightarrow R}}\rightarrow h(\text{pu}_{\text{Cont}}\bef s\bef\text{jump})\big)\quad.
\end{align*}

\end_inset

We may lift the 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

jump
\end_layout

\end_inset

 to the stack 
\begin_inset Formula $P$
\end_inset

 as:
\begin_inset Formula 
\[
\text{jump}_{P}\triangleq\text{jump}\bef p\quad.
\]

\end_inset

Finally, we define the lifted operation 
\begin_inset Formula $\text{callcc}_{P}$
\end_inset

 through 
\begin_inset Formula $\text{cc}_{P}$
\end_inset

, 
\begin_inset Formula $\text{jump}_{P}$
\end_inset

, and 
\begin_inset Formula $\text{pu}_{P}$
\end_inset

:
\begin_inset Formula 
\[
\text{callcc}_{P}\triangleq h^{:(A\rightarrow P^{B})\rightarrow P^{A}}\rightarrow\text{cc}_{P}\big(s^{:P^{A\rightarrow R}}\rightarrow h(\text{pu}_{P}\bef s\bef\text{jump}_{P})\big)\quad.
\]

\end_inset

In this way, we correctly reproduce the behavior of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

 operation within the stack 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
Apart from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

callcc
\end_layout

\end_inset

, the continuation monad has other operations such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reset
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

shift
\end_layout

\end_inset

:
\begin_inset Foot
status open

\begin_layout Plain Layout
See, for example, the Scala-based blog posts 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://blog.bruchez.name/2011/09/continuations-in-scala.html"
literal "false"

\end_inset


\family default
 and 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://dcsobral.blogspot.com/2009/07/delimited-continuations-explained-in.html"
literal "false"

\end_inset


\family default
, as well as the Haskell-based discussion 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/43695653/cont-monad-shift"
literal "false"

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{reset}:\forall S.\,\text{Cont}^{R,R}\rightarrow\text{Cont}^{S,R}\quad,\quad\quad\text{reset}\triangleq c^{:\left(R\rightarrow R\right)\rightarrow R}\rightarrow k^{:R\rightarrow S}\rightarrow k(c(\text{id}))\quad,\\
 & \text{shift}:\forall A.\,((A\rightarrow R)\rightarrow\text{Cont}^{R,R})\rightarrow\text{Cont}^{R,A}\quad,\quad\quad\text{shift}\triangleq g^{:\left(A\rightarrow R\right)\rightarrow\text{Cont}^{R,R}}\rightarrow k^{:A\rightarrow R}\rightarrow g(k)(\text{id})\quad.
\end{align*}

\end_inset

The type signatures of these operations are neither 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 nor of 
\begin_inset Quotes eld
\end_inset

flipped-standard
\begin_inset Quotes erd
\end_inset

.
 Lifting these operations in a systematic way to arbitrary monad stacks
 is the topic of Problem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Problem-monatron-lift-reset-and-shift"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Characterizing monads by operations
\end_layout

\begin_layout Standard
Each monad has a particular set of effectful operations.
 Can we recover a monad's type given its operations? This appears to be
 impossible in general.
 It is also unknown how to obtain a 
\begin_inset Quotes eld
\end_inset

complete
\begin_inset Quotes erd
\end_inset

 set of operations for a given monad.
 The following examples show some failing attempts to characterize monads
 by operations in the general case.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-monatron-trivial-operation"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-monatron-trivial-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that any monad 
\begin_inset Formula $M$
\end_inset

 admits a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation with 
\begin_inset Formula $F=M$
\end_inset

.
 Is that 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The type signature of a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation with 
\begin_inset Formula $F=M$
\end_inset

 is 
\begin_inset Formula $\text{op}:M^{M^{A}}\rightarrow M^{A}$
\end_inset

.
 For an arbitrary monad 
\begin_inset Formula $M$
\end_inset

, the only available function with that type signature is 
\begin_inset Formula $\text{op}\triangleq\text{ftn}_{M}$
\end_inset

.
 The compabitility law holds for this function due to the associativity
 law of 
\begin_inset Formula $\text{ftn}_{M}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(\text{op}\bef\text{ftn}_{M}):\quad & \text{ftn}_{M}^{\uparrow M}\bef\text{op}=\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{ftn}_{M}=\text{op}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset

The corresponding 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sop
\end_layout

\end_inset

) is:
\begin_inset Formula 
\[
\text{sop}\triangleq\text{pu}_{M}^{\uparrow M}\bef\text{op}=\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}=\text{id}\quad.
\]

\end_inset

This 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation is just the identity function (of type 
\begin_inset Formula $M^{A}\rightarrow M^{A}$
\end_inset

).
 This function carries no information specific to the monad 
\begin_inset Formula $M$
\end_inset

 and cannot be used to characterize 
\begin_inset Formula $M$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-monatron-free-monad-operation"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-monatron-free-monad-operation"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that for any functor 
\begin_inset Formula $F$
\end_inset

 there exists a monad 
\begin_inset Formula $M$
\end_inset

 that admits a 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation 
\begin_inset Formula $\text{op}:F^{M}\leadsto M$
\end_inset

.
 Is that 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 operation equivalent to a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The required monad 
\begin_inset Formula $M$
\end_inset

 is the free monad on 
\begin_inset Formula $F$
\end_inset

, which we denote for brevity by 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\[
L^{A}\triangleq A+F^{L^{A}}\quad.
\]

\end_inset

The operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

op
\end_layout

\end_inset

 is the injection of 
\begin_inset Formula $F^{L^{A}}$
\end_inset

 into the disjunctive type 
\begin_inset Formula $A+F^{L^{A}}$
\end_inset

:
\begin_inset Formula 
\[
\text{op}:F^{L^{A}}\rightarrow L^{A}\quad,\quad\quad\text{op}\triangleq p^{:F^{L^{A}}}\rightarrow\bbnum 0^{:A}+p=\,\begin{array}{|c||cc|}
 & A & F^{L^{A}}\\
\hline F^{L^{A}} & \bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset

This operation satisfies the compatibility law because (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-construction-4-free-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{align*}
 & \text{ftn}_{L}^{\uparrow F}\bef\text{op}=\,\begin{array}{|c||cc|}
 & A & F^{L^{A}}\\
\hline F^{L^{L^{A}}} & \bbnum 0 & \text{ftn}_{L}^{\uparrow F}
\end{array}\quad,\\
 & \text{op}\bef\text{ftn}_{L}=\,\begin{array}{|c||ccc|}
 & A & F^{L^{A}} & F^{L^{L^{A}}}\\
\hline F^{L^{L^{A}}} & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & F^{L^{A}}\\
\hline A & \text{id} & \bbnum 0\\
F^{L^{A}} & \bbnum 0 & \text{id}\\
F^{L^{L^{A}}} & \bbnum 0 & \overline{\text{ftn}}_{L}^{\uparrow F}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & F^{L^{A}}\\
\hline F^{L^{L^{A}}} & \bbnum 0 & \text{ftn}_{L}^{\uparrow F}
\end{array}\quad.
\end{align*}

\end_inset

The equivalent 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 operation is the injection of 
\begin_inset Formula $F$
\end_inset

 into the free monad:
\begin_inset Formula 
\[
\text{sop}:\quad F^{A}\rightarrow L^{A}\quad,\quad\quad\text{sop}\triangleq p^{:F^{A}}\rightarrow\bbnum 0+p\triangleright(a^{:A}\rightarrow a+\bbnum 0)^{\uparrow F}\quad.
\]

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
We may combine any number of 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 effectful operations with functors 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, ..., 
\begin_inset Formula $F_{k}$
\end_inset

 into a single effect constructor 
\begin_inset Formula $F=F_{1}+F_{2}+...+F_{k}$
\end_inset

.
 The free monad on 
\begin_inset Formula $F$
\end_inset

 will support all the given operations.
 But a free monad cannot describe an operation that is not equivalent to
 a 
\begin_inset Quotes eld
\end_inset

simple
\begin_inset Quotes erd
\end_inset

 one.
\end_layout

\begin_layout Subsection
Summary of monad transformer constructions
\end_layout

\begin_layout Standard
Monad transformers seen in this chapter fall into one of the 6 cases:
\end_layout

\begin_layout Standard
1.
 Compositional transformers that work by functor composition in one or another
 order.
 This applies to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

, and the 
\begin_inset Quotes eld
\end_inset

rigid
\begin_inset Quotes erd
\end_inset

 monads.
\end_layout

\begin_layout Standard
2.
 The special monads 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cod
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Search
\end_layout

\end_inset

, whose transformers are not fully-featured.
\end_layout

\begin_layout Standard
3.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad and the free monad have recursively defined transformers.
\end_layout

\begin_layout Standard
4.
 The transformer for a Cartesian product of monads is the Cartesian product
 of transformers.
\end_layout

\begin_layout Standard
5.
 The free pointed monad has its special transformer.
\end_layout

\begin_layout Standard
6.
 Monad stacks (monads of the form 
\begin_inset Formula $K\varangle L\varangle...\varangle P$
\end_inset

 where 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $L$
\end_inset

, ..., 
\begin_inset Formula $P$
\end_inset

 are given monads).
\end_layout

\begin_layout Standard
No one knows any explicit examples of monads that do not fit into one of
 these cases.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-stack-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-stack-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define type constructors for these monad stacks and for their transformers:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

 
\begin_inset Formula $\varangle$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.

\series bold
 (b)
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 
\begin_inset Formula $\varangle$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Eval
\end_layout

\end_inset

.

\series bold
 (c)
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 
\begin_inset Formula $\varangle$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Writer[W, *]
\end_layout

\end_inset

.

\series bold
 (d)
\series default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Cont[R, *]
\end_layout

\end_inset

 
\begin_inset Formula $\varangle$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 
\begin_inset Formula $\varangle$
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

State[S, *]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-stack-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-stack-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider a monad stack 
\begin_inset Formula $P\triangleq K_{1}\varangle...\varangle K_{n}$
\end_inset

 where each of the monads 
\begin_inset Formula $K_{i}$
\end_inset

 (for 
\begin_inset Formula $i=1,...,n$
\end_inset

) has a runner 
\begin_inset Formula $\theta_{i}:K_{i}^{A}\rightarrow A$
\end_inset

.
 Assume that the monads 
\begin_inset Formula $K_{i}$
\end_inset

 have complete monad transformers, so that all base runners (
\begin_inset Formula $\text{brun}_{K_{i}}$
\end_inset

) are known.
 Show that each runner 
\begin_inset Formula $\theta_{i}$
\end_inset

 can be lifted to the stack 
\begin_inset Formula $P$
\end_inset

, giving a monad morphism 
\begin_inset Formula $\bar{\theta}_{i}$
\end_inset

 with type signature:
\begin_inset Formula 
\[
\bar{\theta}_{i}:K_{1}\varangle...\varangle K_{n}\leadsto K_{1}\varangle...\varangle K_{i-1}\varangle K_{i+1}\varangle...\varangle K_{n}\quad\text{(the stack }P\text{ without }K_{i})\quad.
\]

\end_inset

Prove that all runners 
\begin_inset Formula $\bar{\theta}_{i}$
\end_inset

 commute: 
\begin_inset Formula $\bar{\theta}_{i}\bef\bar{\theta}_{j}=\bar{\theta}_{j}\bef\bar{\theta}_{i}$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-transformer-extra-layer-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
For an arbitrary monad 
\begin_inset Formula $M$
\end_inset

, Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-M-to-M-times-M-is-monadic-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that the duplicating function 
\begin_inset Formula $\Delta:M\leadsto M\times M$
\end_inset

 is a monad morphism.
 Prove that the same holds for all similarly defined duplicating functions
 of types 
\begin_inset Formula $M\leadsto M\times M\times M$
\end_inset

, 
\begin_inset Formula $M\leadsto M\times M\times M\times M$
\end_inset

, and so on.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-transformer-extra-layer"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
We know from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-pure-M-is-monad-morphism"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that 
\begin_inset Formula $\text{pu}_{M}$
\end_inset

 is a monad morphism from the identity monad (
\begin_inset Formula $\text{Id}$
\end_inset

) to a given monad 
\begin_inset Formula $M$
\end_inset

.
 Show that there are no other such monad morphisms 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula 
\[
\phi:\text{Id}\leadsto M\quad,\quad\text{or equivalently,}\quad\quad\phi^{A}:A\rightarrow M^{A}\quad.
\]

\end_inset

In other words, prove that any such monad morphism 
\begin_inset Formula $\phi$
\end_inset

 must be equal to 
\begin_inset Formula $M$
\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 method: 
\begin_inset Formula $\phi=\text{pu}_{M}$
\end_inset

.
 It means that the identity monad is an initial object
\begin_inset Index idx
status open

\begin_layout Plain Layout
category of monads!initial object
\end_layout

\end_inset

 in the category of monads.
 (An object 
\begin_inset Formula $i$
\end_inset

 is an 
\series bold
initial object
\series default
 of a category if for any object 
\begin_inset Formula $x$
\end_inset

 there is a unique morphism 
\begin_inset Formula $i\rightarrow x$
\end_inset

.)
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-transformer-extra-layer-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that for any monad 
\begin_inset Formula $M$
\end_inset

, there is only one monad morphism 
\begin_inset Formula $\varepsilon:M\leadsto\bbnum 1$
\end_inset

, where 
\begin_inset Formula $\bbnum 1$
\end_inset

 denotes the unit monad, 
\begin_inset Formula $L^{A}=\bbnum 1$
\end_inset

.
 It means that the unit monad is a terminal object in the category of monads.
 (An object 
\begin_inset Formula $t$
\end_inset

 is a 
\series bold
terminal object
\series default
 in a category if for any object 
\begin_inset Formula $x$
\end_inset

 there is a unique morphism 
\begin_inset Formula $x\rightarrow t$
\end_inset

.)
\begin_inset Index idx
status open

\begin_layout Plain Layout
category of monads!terminal object
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that a monad morphism 
\begin_inset Formula $\phi:\bbnum 1\leadsto M$
\end_inset

 between the unit monad and some monad 
\begin_inset Formula $M$
\end_inset

 is possible only if 
\begin_inset Formula $M$
\end_inset

 is also a unit monad or is isomorphic to the unit monad (
\begin_inset Formula $M^{A}\cong\bbnum 1$
\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-transformer-extra-layer-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any given monad 
\begin_inset Formula $M$
\end_inset

, consider a function 
\begin_inset Formula $\text{dbl}:M^{A}\rightarrow M^{A}$
\end_inset

 defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def dbl[M[_]: Monad, A](m: M[A]): M[A] = for {
\end_layout

\begin_layout Plain Layout

  _ <- m
\end_layout

\begin_layout Plain Layout

  x <- m
\end_layout

\begin_layout Plain Layout

} yield x
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
m^{:M^{A}}\triangleright\text{dbl} & \triangleq m\triangleright\text{flm}_{M}(\_^{:A}\rightarrow m)\\
 & =m\triangleright(\_\rightarrow m)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This function 
\begin_inset Quotes eld
\end_inset

doubles
\begin_inset Quotes erd
\end_inset

 the 
\begin_inset Formula $M$
\end_inset

-effect in a given monadic value 
\begin_inset Formula $m$
\end_inset

 while keeping the value 
\begin_inset Formula $x^{:A}$
\end_inset

 from the second copy of 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

dbl[M, A]
\end_layout

\end_inset

 is a 
\emph on
monadically natural
\emph default
 transformation 
\begin_inset Formula $M^{A}\rightarrow M^{A}$
\end_inset

 with respect to the monad type parameter 
\begin_inset Formula $M$
\end_inset

.
 The monadic naturality law requires, for any two monads 
\begin_inset Formula $M$
\end_inset

, 
\begin_inset Formula $N$
\end_inset

 and any monad morphism 
\begin_inset Formula $\phi^{:M\leadsto N}$
\end_inset

, the following equation to hold:
\begin_inset Formula 
\[
\text{dbl}^{M}\bef\phi=\phi\bef\text{dbl}^{N}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

dbl
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 a monad morphism 
\begin_inset Formula $M\leadsto M$
\end_inset

 (at least for some monads 
\begin_inset Formula $M$
\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-morphism-reader-writer-morphisms"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-morphism-reader-writer-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 When 
\begin_inset Formula $f:R\rightarrow S$
\end_inset

 is any function between two types 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, show that there exists a lawful monad morphism of type 
\begin_inset Formula $\text{Reader}^{S,A}\rightarrow\text{Reader}^{R,A}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 When 
\begin_inset Formula $f:R\rightarrow S$
\end_inset

 is any 
\emph on
monoid
\emph default
 morphism between monoids 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

, show that there exists a lawful monad morphism of type 
\begin_inset Formula $\text{Writer}^{R,A}\rightarrow\text{Writer}^{S,A}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that monad morphisms 
\begin_inset Formula $\text{Writer}^{R,A}\rightarrow\text{Writer}^{S,A}$
\end_inset

 are in one-to-one correspondence with monoid morphisms 
\begin_inset Formula $R\rightarrow S$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-morphism-reader-state"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-morphism-reader-state"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the monads 
\begin_inset Formula $\text{Reader}^{R,A}$
\end_inset

 and 
\begin_inset Formula $\text{State}^{R,A}$
\end_inset

 (where 
\begin_inset Formula $R$
\end_inset

 is a fixed type).
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
State
\family default
 monad
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Reader
\family default
 monad
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Implement a monad morphism 
\begin_inset Formula $\text{inS}:\text{Reader}^{R,A}\rightarrow\text{State}^{R,A}$
\end_inset

 and prove that the laws hold.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Find a natural transformation 
\begin_inset Formula $\text{outS}:\text{State}^{R,A}\rightarrow\text{Reader}^{R,A}$
\end_inset

 such that 
\begin_inset Formula $\text{inS}\bef\text{outS}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that there is 
\emph on
no
\emph default
 lawful monad morphism of type 
\begin_inset Formula $\text{State}^{R,A}\rightarrow\text{Reader}^{R,A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-morphism-writer-state"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-morphism-writer-state"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the monads 
\begin_inset Formula $\text{Writer}^{W,A}$
\end_inset

 and 
\begin_inset Formula $\text{State}^{W,A}$
\end_inset

 (where 
\begin_inset Formula $W$
\end_inset

 is a fixed monoid type).
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
State
\family default
 monad
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Writer
\family default
 monad
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Implement a monad morphism 
\begin_inset Formula $\text{inS}:\text{Writer}^{W,A}\rightarrow\text{State}^{W,A}$
\end_inset

 and prove that the laws hold.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Find a natural transformation 
\begin_inset Formula $\text{outS}:\text{State}^{W,A}\rightarrow\text{Writer}^{W,A}$
\end_inset

 such that 
\begin_inset Formula $\text{inS}\bef\text{outS}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that there is 
\emph on
no
\emph default
 lawful monad morphism of type 
\begin_inset Formula $\text{State}^{W,A}\rightarrow\text{Writer}^{W,A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-transformer-extra-layer-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-transformer-extra-layer-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $T_{L}$
\end_inset

 is a lawful monad transformer for a base monad 
\begin_inset Formula $L$
\end_inset

 and a foreign monad 
\begin_inset Formula $M$
\end_inset

.
 Can we modify 
\begin_inset Formula $T_{L}$
\end_inset

 and construct another lawful monad transformer for 
\begin_inset Formula $L$
\end_inset

?
\end_layout

\begin_layout Standard
One possibility is to compose 
\begin_inset Formula $T_{L}^{M,A}$
\end_inset

 with an extra layer of the monads 
\begin_inset Formula $L$
\end_inset

 or 
\begin_inset Formula $M$
\end_inset

.
 Define 
\begin_inset Formula $U$
\end_inset

 and 
\begin_inset Formula $V$
\end_inset

 by:
\begin_inset Formula 
\[
U^{A}\triangleq L^{T_{L}^{M,A}}\quad,\quad\quad V^{A}\triangleq M^{T_{L}^{M,A}}\quad.
\]

\end_inset

In a shorter notation, 
\begin_inset Formula $U\triangleq L\circ T_{L}^{M}$
\end_inset

 and 
\begin_inset Formula $V\triangleq M\circ T_{L}^{M}$
\end_inset

.
 We have the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 functions:
\begin_inset Formula 
\begin{align*}
\text{sw}_{L,T} & :T_{L}^{M}\circ L\leadsto L\circ T_{L}^{M}\quad,\\
\text{sw}_{M,T} & :T_{L}^{M}\circ M\leadsto M\circ T_{L}^{M}\quad,
\end{align*}

\end_inset

defined using the already given methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

blift
\end_layout

\end_inset

 of 
\begin_inset Formula $T_{L}^{M}$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
\text{sw}_{L,T} & =\text{blift}^{\uparrow T}\bef\text{ftn}_{T}\bef\text{pu}_{L}\quad,\\
\text{sw}_{M,T} & =\text{flift}^{\uparrow T}\bef\text{ftn}_{T}\bef\text{pu}_{M}\quad.
\end{align*}

\end_inset

We can define the monad methods 
\begin_inset Formula $\text{ftn}_{U}$
\end_inset

 and 
\begin_inset Formula $\text{ftn}_{V}$
\end_inset

 using these 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 functions.
 Will 
\begin_inset Formula $U$
\end_inset

 and/or 
\begin_inset Formula $V$
\end_inset

 be lawful monad transformers for 
\begin_inset Formula $L$
\end_inset

? 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-1-interchange-laws-for-ftn-T"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-1-interchange-laws-for-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any two monads 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 and a natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset


\begin_inset Formula $\,:M\circ L\leadsto L\circ M$
\end_inset

, assume that the method 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

 of the monad 
\begin_inset Formula $T\triangleq L\circ M$
\end_inset

 is 
\emph on
defined
\emph default
 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:define-flatten-via-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Show that the two interchange laws will then hold for 
\begin_inset Formula $\text{ftn}_{T}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{inner interchange law}:\quad & \text{ftn}_{L}\bef\text{ftn}_{T}=\text{ftn}_{T}^{\uparrow L}\bef\text{ftn}_{L}\quad,\\
\text{outer interchange law}:\quad & \text{ftn}_{T}\bef\text{ftn}_{M}^{\uparrow L}=\text{ftn}_{M}^{\uparrow L\uparrow M\uparrow L}\bef\text{ftn}_{T}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-2-prove-compat-laws-for-T-from-swap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-2-prove-compat-laws-for-T-from-swap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
With the same assumptions as Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-1-interchange-laws-for-ftn-T"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and additionally assuming the inner and outer identity laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 (see Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Statement-swap-laws-to-monad-transformer-first-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

), show that the monad 
\begin_inset Formula $T\triangleq L\circ M$
\end_inset

 satisfies two 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pure
\end_layout

\end_inset

 compatibility
\begin_inset Quotes erd
\end_inset

 laws:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
pure
\family default
 compatibility laws
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\text{inner \texttt{pure} compatibility law}:\quad & \text{ftn}_{L}=\text{pu}_{M}^{\uparrow L}\bef\text{ftn}_{T}\quad:L^{L^{M^{A}}}\rightarrow L^{M^{A}}\quad,\\
\text{outer \texttt{pure} compatibility law}:\quad & \text{ftn}_{M}^{\uparrow L}=\text{pu}_{L}^{\uparrow T}\bef\text{ftn}_{T}\quad:L^{M^{M^{A}}}\rightarrow L^{M^{A}}\quad,
\end{align*}

\end_inset

or, expressed equivalently through the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{flm}_{L}\big(f^{:A\rightarrow L^{M^{B}}}\big)=\text{pu}_{M}^{\uparrow L}\bef\text{flm}_{T}(f)\quad,\quad\quad\big(\text{flm}_{M}(f^{:A\rightarrow M^{B}})\big)^{\uparrow L}=\text{pu}_{L}^{\uparrow T}\bef\text{flm}_{T}(f^{\uparrow L})\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Statement-search-and-selector-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-search-and-selector-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Search
\family default
 monad
\end_layout

\end_inset

search monad
\begin_inset Quotes erd
\end_inset

 by 
\begin_inset Formula $\text{Search}^{P,A}\triangleq\left(A\rightarrow\bbnum 1+P\right)\rightarrow\bbnum 1+A$
\end_inset

.
 The function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def finder[A, P](s: (A => Option[P]) => A): (A => Option[P]) => Option[A]
 = {
\end_layout

\begin_layout Plain Layout

  p: (A => Option[P]) => p(s(p)).map { _ => s(p) }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{finder}:\text{Sel}^{\bbnum 1+P,A}\rightarrow\text{Search}^{P,A}\quad,\quad\quad\text{finder}\,(s^{:\text{Sel}^{\bbnum 1+P,A}})\triangleq p^{:A\rightarrow\bbnum 1+P}\rightarrow p(s(p))\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
P & \bbnum 0 & s(p)
\end{array}\quad,
\]

\end_inset

transforms a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
Sel
\family default
 (selector) monad
\end_layout

\end_inset

selector monad 
\begin_inset Formula $\text{Sel}^{\bbnum 1+P,A}$
\end_inset

 to the search monad.
 Show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

finder
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 a monad morphism 
\begin_inset Formula $\text{Sel}^{\bbnum 1+P,\bullet}\leadsto\text{Search}^{P,\bullet}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-selector-and-continuation-monads"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-selector-and-continuation-monads"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scc
\end_layout

\end_inset

) is a monad morphism 
\begin_inset Formula $\text{Sel}^{P,\bullet}\leadsto\text{Cont}^{P,\bullet}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def scc[P, A](s: (A => P) => A): (A => P) => P = { f: (A => P) => f(s(f))
 }
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{scc}:\text{Sel}^{P,A}\rightarrow\text{Cont}^{P,A}\quad,\quad\quad\text{scc}\,(s^{:(A\rightarrow P)\rightarrow A})\triangleq f^{:A\rightarrow P}\rightarrow f(s(f))\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Hint: Use the flipped Kleisli technique to simplify the proof of the composition
 law.
\begin_inset Index idx
status open

\begin_layout Plain Layout
flipped@
\begin_inset Quotes eld
\end_inset

flipped Kleisli
\begin_inset Quotes erd
\end_inset

 technique
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-monad-product"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-monad-product"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that the product of three monads 
\begin_inset Formula $K^{\bullet}\times L^{\bullet}\times M^{\bullet}$
\end_inset

 is again a monad.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the type isomorphism 
\begin_inset Formula $(K^{\bullet}\times L^{\bullet})\times M^{\bullet}\cong K^{\bullet}\times(L^{\bullet}\times M^{\bullet})$
\end_inset

 is also a 
\emph on
monad
\emph default
 isomorphism.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-mt-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The construction of the free pointed monad on 
\begin_inset Formula $M$
\end_inset

, namely 
\begin_inset Formula $N^{A}\triangleq A+M^{A}$
\end_inset

 (where 
\begin_inset Formula $M$
\end_inset

 is a given monad), uses a helper function 
\begin_inset Formula $\gamma_{M}$
\end_inset

 defined by:
\begin_inset Formula 
\[
\gamma_{M}:A+M^{A}\rightarrow M^{A}\quad,\quad\quad\gamma_{M}\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\quad.
\]

\end_inset

Show that 
\begin_inset Formula $\gamma_{M}$
\end_inset

 is a monad morphism between the monads 
\begin_inset Formula $N$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-mt-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For any monads 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 and a given monad morphism 
\begin_inset Formula $\phi:K\leadsto M$
\end_inset

, show that there exists a corresponding monad morphism 
\begin_inset Formula $\psi:L\leadsto N$
\end_inset

 between free pointed monads 
\begin_inset Formula $L^{A}\triangleq A+K^{A}$
\end_inset

 and 
\begin_inset Formula $N^{A}\triangleq A+M{}^{A}$
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!free pointed
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-mt-3-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Given two natural transformations 
\begin_inset Formula $\phi:K^{A}\rightarrow M^{A}$
\end_inset

 and 
\begin_inset Formula $\chi:L^{A}\rightarrow M^{A}$
\end_inset

, show that the function 
\begin_inset Formula $\psi$
\end_inset

 defined by:
\begin_inset Formula 
\[
\psi:K^{A}+L^{A}\rightarrow M^{A}\quad,\quad\quad\psi\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline K^{A} & \phi\\
L^{A} & \chi
\end{array}\quad,
\]

\end_inset

 is also a natural transformation.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Given a natural transformation 
\begin_inset Formula $\psi:K^{A}+L^{A}\rightarrow M^{A}$
\end_inset

, show that the following functions 
\begin_inset Formula $\phi:K^{A}\rightarrow M^{A}$
\end_inset

 and 
\begin_inset Formula $\chi:L^{A}\rightarrow M^{A}$
\end_inset

 are both natural transformations:
\begin_inset Formula 
\[
\phi\triangleq(k\rightarrow k+\bbnum 0)\bef\psi\quad,\quad\quad\chi\triangleq(l\rightarrow\bbnum 0+l)\bef\psi\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-mt-3-2-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given monad 
\begin_inset Formula $K$
\end_inset

, define 
\begin_inset Formula $L^{A}\triangleq A+K^{A}$
\end_inset

, that is, the free pointed monad on 
\begin_inset Formula $K$
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!free pointed
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that the monad transformer for 
\begin_inset Formula $L$
\end_inset

 
\emph on
cannot
\emph default
 be defined as the monad 
\begin_inset Formula $T_{L}^{M,A}\triangleq A+T_{K}^{M,A}$
\end_inset

 because then (at least for some monads 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

) there is no monad morphism 
\begin_inset Formula $\text{flift}:M\leadsto T_{L}^{M,A}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Given a runner 
\begin_inset Formula $\theta_{K}:K\leadsto M$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is an arbitrary (but fixed) target monad, implement a runner 
\begin_inset Formula $\theta_{L}:L\leadsto M$
\end_inset

 and show that 
\begin_inset Formula $\theta_{L}$
\end_inset

 is a monad morphism when 
\begin_inset Formula $\theta_{K}$
\end_inset

 is one.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that it is 
\emph on
not
\emph default
 possible to implement a monad morphism 
\begin_inset Formula $\theta_{K}:K\leadsto M$
\end_inset

 given a monad morphism 
\begin_inset Formula $\theta_{L}:L\leadsto M$
\end_inset

, at least for some monads 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(d)*
\series default
 Given a monad morphism 
\begin_inset Formula $\theta_{L}:L^{A}\rightarrow A$
\end_inset

, implement a lawful monad morphism 
\begin_inset Formula $\theta_{K}:K^{A}\rightarrow A$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-mt-3-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For a given monad 
\begin_inset Formula $K$
\end_inset

, define 
\begin_inset Formula $L$
\end_inset

 as the free pointed monad
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!free pointed
\end_layout

\end_inset

 
\begin_inset Formula $L^{A}\triangleq A+K^{A}$
\end_inset

.
 Given a monad morphism 
\begin_inset Formula $\phi:K\leadsto L$
\end_inset

, implement a monad morphism 
\begin_inset Formula $\delta:K\leadsto\text{Opt}$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Exercise 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
(a)
\series default
 Given a monad morphism 
\begin_inset Formula $\phi:K\leadsto L$
\end_inset

, show that one can implement a monad morphism 
\begin_inset Formula $\delta:K\leadsto\text{Opt}$
\end_inset

.
\end_layout

\begin_layout Plain Layout

\series bold
(b)*???
\series default
 Given a monad morphism 
\begin_inset Formula $\delta:K\leadsto\text{Opt}$
\end_inset

 (from 
\begin_inset Formula $K$
\end_inset

 to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 monad), show that one can implement a monad morphism 
\begin_inset Formula $\phi:K\leadsto L$
\end_inset

.
\end_layout

\begin_layout Plain Layout
– Not clear that we can actually prove part 
\series bold
(b)
\series default
!
\end_layout

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout

\series bold
(a)
\series default
 Consider the monad morphism 
\begin_inset Formula $\varepsilon:K\leadsto\bbnum 1$
\end_inset

 defined by 
\begin_inset Formula $\varepsilon\triangleq\_\rightarrow1$
\end_inset

.
 (This is a monad morphism because all its laws reduce to the equation 
\begin_inset Formula $1=1$
\end_inset

.) By Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can implement a corresponding monad morphism between free pointed monads
 
\begin_inset Formula $\text{Id}+K\leadsto\text{Id}+\bbnum 1$
\end_inset

.
 Define 
\begin_inset Formula $\delta$
\end_inset

 as that monad morphism.
 The monad 
\begin_inset Formula $\text{Id}+\bbnum 1$
\end_inset

 is the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 monad.
 So, we have implemented a monad morphism 
\begin_inset Formula $\delta:A+K^{A}\rightarrow\text{Opt}^{A}$
\end_inset

.
\end_layout

\begin_layout Plain Layout

\series bold
(b)
\series default
 Given 
\begin_inset Formula $\delta:K^{A}\rightarrow\bbnum 1+A$
\end_inset

, define the function 
\begin_inset Formula $\phi:K^{A}\rightarrow A+K^{A}$
\end_inset

 by 
\begin_inset Formula 
\[
\phi\triangleq k^{:K^{A}}\rightarrow k\triangleright\delta\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\\
A & \text{id} & \bbnum 0
\end{array}\quad.
\]

\end_inset

Now we verify the monad morphism laws for 
\begin_inset Formula $\phi$
\end_inset

.
 The identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{pu}_{L}:\quad & \text{pu}_{K}\bef\phi=a\rightarrow a\triangleright\text{pu}_{K}\triangleright\phi=a\rightarrow a\triangleright\gunderline{\text{pu}_{K}\triangleright\delta}\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow a\triangleright\text{pu}_{K}\\
A & \text{id} & \bbnum 0
\end{array}\\
\text{identity law of }\delta:\quad & =a\rightarrow a\triangleright\text{pu}_{\text{Opt}}\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow a\triangleright\text{pu}_{K}\\
A & \text{id} & \bbnum 0
\end{array}=a\rightarrow(\bbnum 0^{:\bbnum 1}+A)\triangleright\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow a\triangleright\text{pu}_{K}\\
A & \text{id} & \bbnum 0
\end{array}\\
 & =a\rightarrow a+\bbnum 0^{:K^{A}}=a\rightarrow a\triangleright\text{pu}_{L}=\text{pu}_{L}\quad.
\end{align*}

\end_inset

To verify the composition law, apply both sides to a value 
\begin_inset Formula $k^{:K^{K^{A}}}$
\end_inset

:
\begin_inset Formula 
\[
k\triangleright\phi^{\uparrow K}\bef\phi\bef\text{ftn}_{L}\overset{?}{=}k\triangleright\text{ftn}_{K}\bef\phi\quad.
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Begin with the left-hand side:
\begin_inset Formula 
\begin{align*}
 & k\triangleright\phi^{\uparrow K}\bef\phi\bef\text{ftn}_{L}\\
 & =k\triangleright\phi^{\uparrow K}\triangleright\delta^{:K^{L^{A}}\rightarrow\bbnum 1+L^{A}}\bef\,\begin{array}{|c||ccc|}
 & A & K^{A} & K^{L^{A}}\\
\hline \bbnum 1 & \bbnum 0 & \bbnum 0 & 1\rightarrow k\triangleright\phi^{\uparrow K}\\
A & \text{id} & \bbnum 0 & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\\
\text{composition}:\quad & =k\triangleright\gunderline{\phi^{\uparrow K}\bef\delta}\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & (1\rightarrow k\triangleright\phi^{\uparrow K})\bef\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\\
A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}
\end{array}\\
\text{naturality of }\delta:\quad & =k\triangleright\delta\bef\gunderline{\phi^{\uparrow\text{Opt}}}\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\phi^{\uparrow K}\bef\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\\
A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}
\end{array}\\
\text{expand }\phi^{\uparrow\text{Opt}}:\quad & =k\triangleright\delta\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & L^{A}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & q\rightarrow q\triangleright\delta\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow q\\
A & \text{id} & \bbnum 0
\end{array}\,
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\phi^{\uparrow K}\bef\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\\
A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}
\end{array}\\
 & =\,k\triangleright\delta\bef\,\begin{array}{|c||c|}
 & A+K^{A}\\
\hline \bbnum 1 & 1\rightarrow\bbnum 0+k\triangleright\phi^{\uparrow K}\bef\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\\
K^{A} & q\rightarrow q\triangleright\delta\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow q\\
A & \text{id} & \bbnum 0
\end{array}\,
\end{array}\quad.
\end{align*}

\end_inset

We compute separately the expression
\begin_inset Formula 
\begin{align*}
 & \phi\bef\gamma_{K}=k^{:K^{A}}\rightarrow k\triangleright\delta\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\\
A & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\,=k\rightarrow k\triangleright\delta\bef\,\begin{array}{|c||c|}
 & K^{A}\\
\hline \bbnum 1 & 1\rightarrow k\\
A & \text{pu}_{K}
\end{array}\\
 & =?
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
The right-hand side:
\begin_inset Formula 
\begin{align*}
 & k\triangleright\text{ftn}_{K}\triangleright\phi=k\triangleright\text{ftn}_{K}\bef\delta\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\text{ftn}_{K}\\
A & \text{id} & \bbnum 0
\end{array}\\
 & =k\triangleright\delta\bef\delta^{\uparrow\text{Opt}}\bef\text{ftn}_{\text{Opt}}\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\text{ftn}_{K}\\
A & \text{id} & \bbnum 0
\end{array}\\
 & =k\triangleright\delta\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & \bbnum 1+A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \delta
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
\bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\text{ftn}_{K}\\
A & \text{id} & \bbnum 0
\end{array}\\
 & =k\triangleright\delta\bef\,\begin{array}{|c||cc|}
 & \bbnum 1 & \bbnum 1+A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \delta
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\text{ftn}_{K}\\
\bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\text{ftn}_{K}\\
A & \text{id} & \bbnum 0
\end{array}=k\triangleright\delta\bef\,\begin{array}{|c||c|}
 & A+K^{A}\\
\hline \bbnum 1 & 1\rightarrow\bbnum 0+k\triangleright\text{ftn}_{K}\\
K^{A} & \delta\bef\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline \bbnum 1 & \bbnum 0 & 1\rightarrow k\triangleright\text{ftn}_{K}\\
A & \text{id} & \bbnum 0
\end{array}\,
\end{array}\quad.
\end{align*}

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "par:Exercise-mt-3-2-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Exercise-mt-3-2-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
It follows from Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Statement-monad-with-quantifier"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that adding a type quantifier to a monad gives again a monad.
 Show that adding a type quantifier to any 
\begin_inset Formula $P$
\end_inset

-typeclass (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:P-typeclasses"
plural "false"
caps "false"
noprefix "false"

\end_inset

) gives again a 
\begin_inset Formula $P$
\end_inset

-typeclass.
 In detail: assume a 
\begin_inset Formula $P$
\end_inset

-typeclass defined via a structure functor 
\begin_inset Formula $S^{R,\bullet}$
\end_inset

 that has an extra type parameter 
\begin_inset Formula $R$
\end_inset

.
 All methods of the typeclass are then contained in a value of type 
\begin_inset Formula $S^{R,A}\rightarrow A$
\end_inset

, where the type 
\begin_inset Formula $R$
\end_inset

 is fixed.
 Show that 
\begin_inset Formula $\forall R.\,S^{R,A}\rightarrow A$
\end_inset

 is again a 
\begin_inset Formula $P$
\end_inset

-typeclass (with a different choice of the structure functor).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-effectful-list-not-monad"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-effectful-list-not-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Assume an arbitrary monad 
\begin_inset Formula $M$
\end_inset

 and define 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times M^{L^{A}}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that any (fully parametric in 
\begin_inset Formula $M$
\end_inset

) implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 for 
\begin_inset Formula $L$
\end_inset

 (with type signature 
\begin_inset Formula $\text{ftn}_{L}:L^{L^{A}}\rightarrow L^{A}$
\end_inset

) must truncate the nested effectful list whenever it encounters an empty
 sub-list.
 To see the truncating behavior in a simpler way, take 
\begin_inset Formula $M=\text{Id}$
\end_inset

, which reduces 
\begin_inset Formula $L$
\end_inset

 to the ordinary list (
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times L^{A}$
\end_inset

).
 Show that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method for 
\begin_inset Formula $L$
\end_inset

 must ignore all sub-lists after an empty sub-list.
 For example, 
\begin_inset Formula $\text{ftn}_{L}(\left[\left[1,2\right],\left[3,4\right],\left[\right],\left[5,6\right]\right])$
\end_inset

 must ignore the values 
\begin_inset Formula $\left[5,6\right]$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the monad laws do 
\emph on
not
\emph default
 hold for a non-standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method that truncates the list after the first empty sub-list, such that
 
\begin_inset Formula $\text{ftn}_{L}(\left[\left[1,2\right],\left[3,4\right],\left[\right],\left[5,6\right]\right])=\left[1,2,3,4\right]$
\end_inset

.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
List
\family default
 monad with invalid truncation
\end_layout

\end_inset

 (Compare with Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 where the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 whenever there are any empty sub-lists.)
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!
\family typewriter
List
\family default
 monad with empty sub-lists
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that the functor 
\begin_inset Formula $L$
\end_inset

 
\emph on
cannot
\emph default
 be a monad transformer for the non-standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 monad defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-1-monads-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, because we cannot implement a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flift
\end_layout

\end_inset

 function of type 
\begin_inset Formula $M^{A}\rightarrow L^{A}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-combined-codensity-monad"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-combined-codensity-monad"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The
\begin_inset Index idx
status open

\begin_layout Plain Layout
monads!composed codensity monad
\end_layout

\end_inset

 
\series bold
composed
\series default
 
\series bold
codensity monad
\series default
 
\begin_inset Formula $\text{Cod}_{F}^{L,A}$
\end_inset

 is defined by:
\begin_inset Formula 
\[
\text{Cod}_{F}^{L,A}\triangleq\forall X.\,(A\rightarrow F^{X})\rightarrow F^{L^{X}}\quad,
\]

\end_inset

where 
\begin_inset Formula $L$
\end_inset

 is any monad and 
\begin_inset Formula $F$
\end_inset

 is any functor.
 One may define the monad instance for 
\begin_inset Formula $\text{Cod}_{F}^{L,A}$
\end_inset

 via the flipped Kleisli composition:
\begin_inset Formula 
\[
f^{:\forall X.\,(B\rightarrow F^{X})\rightarrow A\rightarrow F^{L^{X}}}\tilde{\diamond}\,\,g^{:\forall Y.\,(C\rightarrow F^{Y})\rightarrow B\rightarrow F^{L^{Y}}}\triangleq\forall Z.\,k^{:C\rightarrow F^{Z}}\rightarrow\big(k\triangleright g^{Z}\triangleright f^{L^{Z}}\big)\bef\text{ftn}_{L}^{\uparrow F}\quad.
\]

\end_inset

Prove that the type constructor 
\begin_inset Formula $\text{Cod}_{F}^{L,\bullet}$
\end_inset

 is a lawful monad.
\end_layout

\begin_layout Standard
Hints: Use the flipped Kleisli formulation of the monad laws.
 Assume that values of type 
\begin_inset Formula $\text{Cod}_{F}^{L,A}$
\end_inset

 are natural transformations obeying the appropriate naturality law.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the quantifier 
\begin_inset Formula $\forall X$
\end_inset

 cannot be removed from the definition of 
\begin_inset Formula $\text{Cod}_{F}^{L,A}$
\end_inset

 even if 
\begin_inset Formula $F^{A}\triangleq A$
\end_inset

: for a fixed type 
\begin_inset Formula $X$
\end_inset

 and for some 
\begin_inset Formula $L^{\bullet}$
\end_inset

, the type constructor 
\begin_inset Formula $P^{A}\triangleq(A\rightarrow X)\rightarrow L^{X}$
\end_inset

 is 
\emph on
not
\emph default
 a monad.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that in general there is 
\emph on
no
\emph default
 monad morphism 
\begin_inset Formula $L^{A}\rightarrow\text{Cod}_{F}^{L,A}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
A simple counterexample is found with 
\begin_inset Formula $M^{A}\triangleq R\rightarrow A$
\end_inset

 and 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-pair-functor-is-rigid"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-pair-functor-is-rigid"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Rigid functors are defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rigid-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Show that the functor 
\begin_inset Formula $F^{A}\triangleq A\times A\times A$
\end_inset

 is rigid.
 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Show that the functor 
\begin_inset Formula $F^{A}\triangleq\bbnum 1+A\times A$
\end_inset

 is not rigid.
 
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Show that the functor 
\begin_inset Formula $F^{A}\triangleq\left(A\rightarrow Z\right)\rightarrow Z$
\end_inset

 is not rigid (
\begin_inset Formula $Z$
\end_inset

 is a fixed type).
\begin_inset Note Note
status open

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-associativity-of-Day-convolution"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-associativity-of-Day-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset

Day convolution
\begin_inset Quotes erd
\end_inset

 operation (
\begin_inset Formula $\star$
\end_inset

) is defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:definition-of-monoidal-convolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-failure-of-generic-monad-transformer"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Prove the associativity law of Day convolution
\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of Day convolution
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Day convolution
\end_layout

\end_inset

: 
\begin_inset Formula $(L\star M)\star N\cong L\star(M\star N)$
\end_inset

.
 
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Day_convolution"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Chapter eleven of the functional programming tutorial computations in a
 central context have been one of the teams in this tutorial and this is
 a final part this which talks about moon and transformers to begin let
 me look at some code that needs to compute a value in the future but the
 value is of optional type so these kind of computations often happen in
 application code when you are computing some value in the future but the
 value itself has additional logic and option is a simplest such example
 so imagine that we would like to implement a program that computes a value
 using a future and then if this value is a non-empty option the computation
 continues and then it can compute another value again in the future using
 what was concluded before and that computation again returns an optional
 type and we again see if that is a non-empty option and if so we continue
 and return another future value and so on and if at any time this option
 is empty after having computed it we need to stop some way short-cut the
 computation by returning a feature of none right away so that's what we
 have to do so the code then starts looking like this now I just write here
 option of one very simple computations for which I wouldn't have to do
 such coding but in real life test as a function that takes time to compute
 so I put it into a future and then it might return an empty result I don't
 know that in advance let's suppose and then I need to match on that result
 so you see this code is quite difficult to read and difficult to modify
 that is to maintain and the reason is that it's full of repetitions so
 there are all these match expressions that always have the same structure
 if there is a Sun then we continue if there is none then we were transfusion
 successful now it is precisely that kind of repetition that was eliminated
 by using the function block or the for yield block but so we eliminate
 them but only for the outer type constructor the inner type constructor
 remains and we still have to do the same thing for it and we could not
 use the same for yield block to deal with the future chaining and the option
 chain because this is a limitation of the function block the factor in
 which we perform the computation must be the same throughout the entire
 function block so the full yield delimit a block of thunder computations
 where to the right-hand side of the arrow there must be always the same
 factor type so future in this example once the first line is giving you
 a future everything to the right of the arrow must be of type future of
 something so it's future this also must be future which it is will have
 having the right code like this and so on so it could not be that in the
 next line I write something like X is equal to X X going to X hoped this
 would not actually compile because this X optical type option it is not
 of type future of something so this would not actually compile and that's
 why we need to write this code so this difficult to write and difficult
 to maintain code unfortunately is unavoidable if we simply use the function
 block on the type constructor that is nested when you have one monad and
 composed in the type constructor with another monnet like this we will
 have this problem whenever this happens so this could be a future of option
 or it could be a list of either or any kind of combination like that will
 give rise to ugly code of this kind so one solution that could be easy
 to implement is to wrap this type constructor into a new class for which
 we implement a monad syntax directly so here's how it works so we create
 a type wrapper which is just a case class with a single value inside and
 this wrapped value is of type future option and now we directly define
 for this case class the methods map and flatmap and they're defined by
 simply doing a nested map and then and the map inside so that's nested
 flat map and then we write this code where we match on the resulting option
 by hint so so this basically replaces all the repetitive code above were
 in the case of none where we turn a successful future of none and if the
 case of nonempty option then we continue we continue with the next computation
 so that is the flat map defined for this wrapped class once we have done
 this we also do some convenience functions which I will talk about later
 such as the lift and I define for convenience some implicit conversions
 so that I can just convert future of a into this future option where I
 promote a to option trivially by using some apply and another opposite
 conversion converts the nested type constructor into a wrapped s to type
 constructing automatically so that is what I do here once this is defined
 the code above is magically transformed into this so the pure computations
 are just examples like I said this is a very simple example and don't really
 need to do this future option stuff in real code this would be a function
 that returns a value of type future of option of something and it could
 have been non-trivial could return in the future that fails or it could
 return a future that succeeds with an empty option or it could return a
 future with succeeds with a non-empty option and so now the code becomes
 very straightforward easy to maintain at the same time I could do operations
 like this or else directly on this type where the or else refers to the
 optional type inside future I implemented there or else for convenience
 like this and the left is a function that transforms option a option B
 into a future option A to future shouldn't be so this is kind of a lifting
 of that kind so this is the basic idea of monad transformers namely how
 to avoid having to write repetitive code languages and instead write with
 some of course and definitions that you need to do but eventually you would
 write code language so in other words we could say we have combined a future
 monad and the option monad into one big moment future with option which
 we can manipulate in a functor block director with no need for pattern
 matching or anything else so all the pattern matching within the future
 is done automatic so this is an example of combining two monads so it is
 very often necessary to combine different monad effects where effect is
 informal notion it is not a specific clearly defined type it is an informal
 notion which expresses the idea that in in a monad M the type of dysfunction
 expresses a computation that takes a and computes perhaps a value of B
 and also to compute something else or something else happens while we were
 computing a value of B or maybe you compute many values of B or maybe none
 at all or maybe you fail with some error message or maybe something else
 happens so whatever else happens while you're computing be from a in this
 function that's the effect of the monad M and so an example would be for
 option is that the computation can have no result or a single result for
 list computation to have multiple results for either it could fail to obtain
 the result and then report an error for the reader it always gives a result
 but it needs to read an external value for that writer it always gives
 a result but additionally there is some accumulator which is of a monoid
 type and some value will be appended to that accumulator for the future
 you might compute computer value might fail with an error but all of that
 will be run later it will not be computed right away so those are the effects
 of some standard monads and often you would like to combine them so you
 would like to have a list of either-or future of options and learning and
 that could be given combinations of more than two when you want to combine
 reader and writer and future at the same time so how do we combine effects
 well I just showed you a code where I combined effects although it required
 me to do acquainted quite some work obviously what you could not do is
 you could you could not simply write code with first a future of something
 which has a future type and then a different monad on the right side of
 the arrow that would not compile so if this has a type try and this has
 a type future they're not compatible future and try are not compatible
 types and so this would not work if you wanted to do that and you need
 to do something else you'd have to unify both right-hand sides into a bigger
 moment such that you somehow transform this into the value of a 
\end_layout

\begin_layout Plain Layout
monad he also transformed this into the value of a bigger movement so these
 operations are called lifting so you lift the small nut into the bigger
 moment you also lift the small nut and a bigger more not and then if you
 can do that and I have done this in my code I just showed you using an
 implicit conversion so if I can do that I can just write code like this
 indeed and implicit conversions will take care or maybe I can just put
 some type annotations and in there that would take care of types and then
 on the right hand side of the accumulator arrow I will always have the
 same type constructor and that is therefore I'm going to be valid Scala
 code so to see that this is not valid it's easy to see that because I should
 translate this into flat maps see the first thing is in sequence the second
 thing is the future so the flat map on a sequence takes this function but
 the future is a different kind type constructor than the sequence on a
 flat map has a type signature that requires a sequence here so that would
 not compile so the conclusion is that in order to combine different effects
 in the same function block we need to unify all these effects in a new
 unit that is in some sense larger than all the previous monads and contains
 all of them so the main goal of this chapter is to learn how we can compute
 the type of this new moon at how can we decide what that type constructor
 is how to implement the moon add instance for it for any kind of moon does
 that you might want to use so there are several ways of combining two models
 into a new bigger moon at that we could try and many of these ways just
 won't work so the easiest way would be well why don't I just take a product
 of these two moons that's a monad we know that the reason is that this
 is not what we need this is a moon Atias but it describes two separate
 values of type a each having a separate effect on it that's not what we
 need we need a single value of type a that has a combination of two effects
 possibly and that's not all this describes now maybe a disjunction because
 that could be the first effect on a or the second effect on a unfortunately
 this is usually not a monad and even even if it is a monad this is really
 a choice between two different effects work even two different values it's
 not one value with the combination of two effects with with the first effect
 and the second effect remember the Scala speech revulsion the combination
 is at the same time being computed in the future and it returns an optional
 result so this doesn't work now the next what we can try is functor composition
 so we can pose and one of them - we can compose in two different orders
 and sometimes indeed that works it is often at one end when you compose
 so let's look at some examples but if one unit is this and the second model
 is this then we can compose and the composition is this type constructor
 and that is actually correct it as a monad similarly future of option as
 I just showed can be combined in case a moment unfortunately if you try
 to combine in there in the other order for example do some following this
 or something like this those are not units so you can combine option and
 reader this is the reader who not only in one order you can come compose
 reader outside and options if you try option outside and you're either
 inside the result is not imminent also you cannot combine State mana with
 other moons like this so for example neither disorder nor that order is
 a minute so from these examples we see first of all sometimes it works
 but sometimes it requires a specific order of composition and it does not
 work with the other order and sometimes it does not work with composition
 at all so I will show that later that the state monad is such that it does
 not compose with other monads in either order so as a comment when composition
 works both ways and example would be either and writer so they can be composed
 in both ways this would be one result of composition this would be another
 and both of these are monads but these moments express different kinds
 of effects so for instance here we either compute result and write a message
 or everything failed we have an error message will have no result and no
 blog messages here we have always a log message the computation may fail
 does not give us a result of type a but the log message is always written
 so we can have an error message and a log message in the same time so these
 are obviously two different kinds of logic that you could express or two
 different kinds of effects so the task in front of us is of course to avoid
 try on there we don't want to do that every time that we need to compose
 two monads we need to have a general way defining a new combined monads
 and we need to show that it is always a moment so that we don't have to
 prove things every time when we write code so that is what we would like
 to achieve and we would go a very long way towards that goal in this chapter
 so what we would achieve is that we will have a monad say Big M big manga
 that somehow combines only effects so instead of the code that I showed
 here which is invalid trying to combine the sequence future and try in
 a single functor block that is not valid but if we somehow define a big
 model that combines sequence future and try in the same big moment then
 we had also we would have three functions for lifting I would call them
 lifts one left two and lifts three for now which would lift a sequence
 value into the big model a future value into the big wallet and a try value
 into the big magnet so then we could just write a function block like this
 lift lift lift after lifting the right hand sides are of type big M of
 something this is now valid and this would work the result would be of
 type maybe Big M of int or something here are two examples of these liftings
 so combining future and option would require us to define two liftings
 option a into future option a and future in the future optionally so these
 lifters are easy define and that's how we would probably have to write
 code in another example suppose we want to combine list of track list and
 try so that works try inside the list networks I don't think that try would
 work outside the list as I'm Oona and these are the two lifting so that's
 easy enough and you see that could work now they're still of course a lot
 of work to be done if we were to go this way for each pair of moments or
 even for each combination which could be very very many we would have to
 define these wave teams we'd have to define the monad instance for a big
 M I haven't even talked about that I haven't even said what the type of
 Big M is for this combination for this I know but for this I haven't said
 that so how to combine list feature and try in a single type constructor
 this is a non-trivial question which is not easy to resolve by trial and
 error composition would not necessarily work we need also to check that
 the laws of the mana told for these moments which I also will check but
 haven't done yet so all these questions remain is it always possible how
 to find such a type constructor is it unique are there several options
 alternative solutions are they some of them better than others these liftings
 what are the laws that they have to satisfy and and so on also can we somehow
 reduce the complexity instead of having to define liftings for all possible
 combinations maybe we find fewer and make other things automatic so let
 me first talk about the laws of liftings so we assume that there will be
 a monadic program such as this one with some liftings and we ask what are
 the laws for these liftings now we assume that the monads m1 m2 and also
 the big model whatever it might be already satisfied all the Monad laws
 how would we argue about lifting laws so for example imagine a functor
 block in which we have code like this so first we have a lifting of a pure
 value so we have an m1 pure and we lift it so that becomes a big moon add
 value and then we continue with some big monad stuff depends on high now
 since this is just pure our initial code without liftings which is incorrect
 would have been just I going to the pure of X and then continuing with
 that I usually code like this is equivalent to this kind of code where
 we don't need to do monadic arrow and the left arrow we don't need that
 if we just use pure we just say i equals x and continue and so we expect
 that with lifting it will be the same that we can replace this code with
 this equivalently so this is a law that the function lift must satisfy
 we write it down is like this this is the law now of course it's not very
 nice to reason about code so I prefer to reason about a more condensed
 notation rather than Scala code syntax and in particular it is convenient
 often to use the closely composition criminals which is composition of
 functions of these types the nicely functions and so if we rewrite this
 code in terms of closely functions then it looks like this the composition
 of the flow-rate composition of pure of n1 and lifts one flat map with
 some arbitrary B which is some x2 big animals voice this is this B must
 be equal to B so that's what we get if we remember that the classic composition
 is replacing this kind of code so F composition with G is a function that
 is like this another law is that if we have a lifting of pure after some
 valid computation then we expect that this X again has just ik equal to
 Omega there's no effect here and this should remain so after lifting so
 therefore this code must be equivalent to this code writing the same code
 that is the equation like this and writing it in terms of the class like
 composition it becomes this equation and of course the same identity laws
 must hold for the second moment in its second lifting so these moments
 we consider to be only cause fruiting right now and both of them need to
 be lifted into the big mullet if this construction is to be of practical
 use now these laws are kind of complicated let's simplify them these laws
 basically say that this function this this composition of pure em and lift
 is the identity for the closely composition so this Purim lifts to the
 left of B equals B and p.m.
 lift to the right of B also equals B and so this function is the unit for
 the classic composition but this monad already has a unit in the classical
 composition laneway it as this viewer of the Big M and in the Monod the
 two-sided unit element is unique and similarly this is so in a closely
 composition so if you have two different unit elements U and u Prime and
 we can easily write this equation which is that you Kleist a product u
 prime it must be equal to u because U prime is a unit element it also must
 be equal to u prime because u is the unit element and so u must be equal
 to u prime so the unit element is always unique and so these two identity
 laws that we have seen here can we actually produced a single or equivalent
 to saying that this forward composition of pure hand and lift it must be
 equal to the pure function of the big moment so we have now reduced the
 identity law to a single identity law and let us now derive another one
 for the lifting which is that if we have some kind of lift one of everything
 so we have a portion of a program that just uses the first moment and keeps
 lifting it into the big moment we should be able to refactor this into
 a nomadic program that only works within the first moment and then lift
 the result of that program into the big moment so this would be the equivalent
 program first we'll do the flat map in the moon atom one and then we lift
 the result into the big moment so this program it is kind of reasonable
 should be equivalent to this if it's not it would be kind of strange that
 I cannot refactor my programs the idea is that lifting should be transparent
 it should be just tight from massaging for the moment so usually if I have
 a nomadic program like this imagine there's no lifting I can always refactor
 it I can do this what not somewhere else and then put the results of that
 flat map back here you can always do that that's the usual associative
 'ti buna so I should be able to do the same if I lift into the big moment
 so that law when written out it becomes this equation and unfortunately
 now this is a little unwieldy to you to think about so let let us rewrite
 it equivalently through the flat map function so the flat map function
 which I did denote F L M it is with this type signature which is not the
 same as the usual flat map in scala but it is easier to reason about and
 then using this flat map we write this code like that so we have a lift
 then we have a flat map of this function and then it's the same as first
 doing a flat map and then lifting the result on both sides of this law
 are functions of this type signature lifting and one into the big moment
 we can further simplify this if we rewrite flat map through flatten flatten
 has this type signature and the law becomes lift one and then lift one
 lifted four raised to the big moment using its map function and then followed
 by flat map in the big Monat is equal to flat map in the m1 mu not followed
 by lift so these are easy to obtain if you remember that flat map is map
 followed by flatten in other words it's this map followed by flat so that's
 basically how I get from here to here and the function Q disappears from
 the law in this formulation so it becomes simpler there's no arbitrary
 function from A to B nothing like that it's just both sides are functions
 of this type there's only one type a involved as a type parameter whereas
 in this law there is a function q and they're two type parameters a B and
 in this formulation they're two arbitrary functions P and Q so in this
 way the laws is simply the law is simplified can be simplified even more
 if we write it in terms of Chrysler composition then it becomes a law that
 is for some functions B and C of class Li type signature the be lifted
 and closely composed with C lifted is equal to twice Li composition of
 B and C all lifted notice I am using two different closely compositions
 in this law and the left I am using the class decomposition in the big
 moon on the right in the moon at M one to make it clear I use the subscript
 in each case so this is maybe slightly more difficult to read with the
 subscript so squint at it and imagine that the subscript isn't there keep
 it just in mind and then you see be lifted composed with C lifted is be
 composed C all lifted so that's the composition law in other words the
 lifting of functions before composition is equal to lifting of functions
 after composition in other words the liftings commute with a closely competitio
n and also the lifting is commute with pure pure after lifting is the same
 as the other pure and so the laws expressed the idea intuitively that these
 liftings lift 1 and lift two of course as well should commute with the
 operations pure and flatmap of the magnets so this is how we can think
 about these laws and remember them so the liftings must lift peer-to-peer
 and compress a closely composition into classically composition additionally
 the liftings must be natural transformations but actually it is a consequence
 of the fact that they lift pure to pure and flatmap to flat map or flattened
 to flatten or glass the composition to place the composition now the term
 that I use for such functions and that commute with monads and lift purity
 pure and flat map to flatten ax is monad morphism so it's not just the
 function or morphism but it's a monad morphism in other words it's a morphism
 that agrees or is compatible with the structure of the moon and and it's
 a function between f1 and Big M so it is compatible in this way with structures
 of these two moments whatever structure is an n1 it maps into that correspondin
g structure in Big M and in the previous chapter we already saw an example
 of an antique morphism although we did not talk about it I didn't talk
 about it I talked about magnetic interpreters not run one one addict program
 and obtain a monadic value in another moment these must actually satisfy
 these laws in order to be useful and so Mahna Mahna the interpreters are
 always magnetic morphisms unless they are be very useful and now let me
 derive the naturality law for this lift now lift has this type signature
 so naturality for it means that if i have some function f from X to Y and
 I lifted to m1 and I also lifted too big him so that's the F map of 1/2
 and I am in m1 or in Big M then the lifting must commute with that so in
 other words first you lift and then you map X to Y or you first map X to
 Y then you lift it doesn't matter and that is the equation that we can
 write expressing this equivalent system now we can derive this law actually
 from the fact that lift is a magnetic morphism so this is not a separate
 law that we need to check once we know that it is a one-man ignore thism
 how so this is a derivation F map can be expressed through a flat map and
 pyrrha and that is a monad law for both movements and then this is the
 lifting law for flat map and instead of saying this so we write that so
 this column of F here is the left hand side or actually that the right
 hand side of this law is f map f lift 1 so instead of f map I write this
 and the result is that so in this way I what I'm trying to get is that
 I replace in this law F Maps through F Elam and the right and on the left
 and I hope that I get an identity after that so I begin with the left hand
 with the right hand side where I replaced F map through a felon now I used
 this law that FLM of some function and then lifted is lifting followed
 by a column of this where Q is equal to a composition of F and P rm1 so
 that results in this expression we have left one FLN Big M which I didn't
 enjoy it of composition of this Q which is this and left so that is here
 now I'll use the fact that pure M followed by lift one is pure Big M which
 is this law therefore I have here F followed by pure Big M now this is
 flat map in Big M therefore this is a law of Big M which is this okay which
 I can replace this by flat by F map of begin so now the result is this
 which is the left hand side of the law and trying to prove so I started
 from the right-hand side replaced things in it identically and I got the
 left hand side using the fact that lift 1 satisfies the laws of a magnetic
 north ISM so monad morphism therefore is always a natural transformation
 so how do we deal with the problem of combining many moments and reducing
 the amount of work so to look at an example if we can bind listen this
 on that only this combination works this is a functor composition of this
 and this where the reader is outside and the option is inside the other
 order would not work this is not a minute and so this destroys our hopes
 of somehow always writing a formula combining M 1 and M 2 for arbitrary
 M 1 and M 2 using some kind of natural combination or by functor this would
 not work and another example is that the state monad does not compose in
 any order with other moons let me show some code that explains why not
 a stone if I try to compose optional is reader in the other order then
 I try to combo I'd really defined flatmap further also and define a flat
 map with this type signature so I get so this o R is an option of reader
 and I need to get an or R of B from or of a and the function a to or me
 now if FA is none we have nothing to do except return there's no a available
 in our so they cannot possibly use F and return some non-trivial for B
 so we have to return none here now suppose we have a non empty option and
 then we have a function R T so now how can we return an option of artemiy
 we have a function that takes a and returns this or B now unfortunately
 we cannot use this F either because to use F we need a function we need
 the value of that a but we don't have it we have a function from R to a
 we don't have an R and so we cannot apply F to anything at this point we
 have to decide at this point without applying F which will give us some
 option we need to return either a nun or a some heartily so trying to return
 the nun here would be bad because then I would return none in both cases
 so we basically have a flat model that always returns an empty option and
 that has no hope of satisfying the identity law which is that flat map
 of something with pure is equal to that something but if our flat map always
 returns an empty option this will never work so let's try to return a non
 empty option okay so we start returning it we have an R now we can use
 this function f by computing R to a of origin of type a and applying F
 to that so we get an option over hard to be here but we are inside this
 function we are required to return a value of type B but we don't have
 that we have an option of something which could be none and this point
 could be empty and if it is not empty as we can return the value of time
 but if it is empty we are stuck we cannot return a value of type B so there
 is no good implementation of flat map in this case a pure we can implement
 with a flat map no let's look at the statement so this is the statement
 type constructor so let's compose it with reader well I need to implement
 flat map with this type signature work as R is this combination the state
 with this radio inside now I will follow the types and there's only one
 way of implementing it so we start with a function s we need to return
 as RB which is s going to a pair of s and R to me so start with s then
 we can compute FA of s we get these things now we want to return the pair
 of s 1 and a function are to be now how do we get a be only way to get
 a B is to apply the function f to some a so we have an a yes we can apply
 after a we can give an R 2 that give it a B so finally we get a B but we
 have to discard this value s not we obtained lust so and this is suspicious
 in the state monad we should not discard updated values of the state yes
 but we have to discard it because we are returning must return s here and
 the function are to be is inside so we cannot give this s which we only
 computed here back over and over there and this is indeed the problem that
 we described certain parts of the state so essentially we have not used
 f in computing the new state I have used f to compute the new value but
 F only gives you not only gives you a value it only gives you an effect
 of taking on the state and is updating we are ignoring and indeed it will
 violate the identity law which is this one of the identity laws and I can
 show that this is so because if I compute the flatmap according to the
 code over there then it will be a function that always ignores the value
 which is okay it's the pure but it always returns the unmodified state
 s so the first element of the pair is always going to be unmodified state
 s and this could not be equal to F it should it should equal F this should
 equal f of X but it cannot because F could modify the state language F
 could be of this form which modifies the state but our flat map will never
 modify the state in this combination with pure and so that cannot possibly
 be equal to f of X for arbitrary functions F no F I could have an effect
 and we should have accumulated that effect we are not now trying to compose
 state monad with reader inside fails what about composing it outside let's
 take an option another simple model and compose it outside with state Bible
 you know go through this in detail but it's a very simple computation and
 basically either you're always return none in your flattener an empty option
 which is bad or you're stuck you're trying to return the value you need
 and you don't get it you have an option of something but you need that
 value itself so you have an option in the wrong place and you're stuck
 you're not able to compute a be just like we're not able to compute early
 previously so this shows that the state moment fails to compose with other
 moments in either order so it does come to us with some owners in one order
 in with other models in another order but you cannot in advance say I compose
 the state monad outside with an arbitrary other monad and that result is
 valid or not no that doesn't work or inside no doesn't work so this is
 a problem and [Music] the solution is actually what is called mono transformers
 the main trick is that we're not going to try to combine arbitrary to monads
 we're going to fix one moment which will go call the base model and look
 I will denote it as L and for a fixed L I will let the other one at vary
 so that will be called a foreign minute and we'll try to assimilate the
 foreign minute into a fixed base model and combine them in this way so
 the result is a type constructor on which I call T LOM and it still has
 a type parameter you're not it here by this placeholder symbol so this
 placeholder symbol is just a type parameter that I'm not writing so I introduce
 this notation in the previous chapter and this color this is written simply
 like that it says type parameter that we're not writing so this type constructo
r depends on both L and M and it gives you a new moment and it is such that
 for a fixed L this M is actually a type parameter so this works for a fixed
 L and for any M so fixed base model and arbitrary foreign moment so that's
 what that transformer is it's a type constructor it depends on L and M
 but it depends on them in a different way so it is generic and M but not
 an L in other words for each L for each baseman on L there is a different
 construction t om but the construction is the same for all M so the fixed
 L the construction is the same for all M so in other words its generic
 in him so right away that is important to understand that there's no general
 formula that takes a monad L and produces the transformer doesn't seem
 to exist so for each L for each base moment he'll we need a different construct
ion of the city em the foreign moment will be generic but the basement will
 not be just a parameter and finally there is a question whether some monads
 have a transformer or not now I don't know how to answer this question
 but I do have examples of monads that don't have full-featured transformers
 and maybe this is not a problem but I do not have examples of monads where
 I don't know how to make a transformer so this question seems to be difficult
 and in practice every moment that we can write down as a type constructor
 will have a transformer or at least halfway I will talk about this in more
 detail very soon so what is the advantage of having this approach of using
 this approach when we fix the base model and vary the foreign model the
 advantage is that now we can easily compose three or more units by simply
 composing the Transformers since the transformer is generic in this one
 on M I can put that monad M as the type parameter and I can set it to a
 transformer for a different moment I'm missing here another type parameter
 placeholder but the notation is difficult as it is so in Scala for example
 you would have transformers such as State T of list T of freighter so you
 can do that with these placeholders which correspond to my lowitz and in
 this way you can stack together many many wonders with no additional work
 once you have implemented transformer for each Manette you can stack any
 number of them like this so no need to have a combinatorial explosion in
 how many different transformers you need combined future and option future
 in list list an option listen either future and either know it just implement
 a transformer for list transformer for either transform an option transformer
 for reader and then you just stack them and this is called the moon a stack
 but make sure you don't mix together and one on stack and composition of
 type constructors will functor composition because this is not the same
 as a simple composition like this the transformer is not just a composition
 for someone as it is but for others it is not unlike for the state model
 it is not a composition as we have seen i cannot work as a composition
 also for some units the composition goes inside and for others outside
 the transformer is a type constructor that is always outside but the result
 of it could be that some things are inside work or even transcribed in
 some difficult way that is neither composition inside nor outside so monad
 stack is not the same as composing type constructors formulas this is not
 a minute this would not work well that transformers will always work they
 will always produce and will not satisfy all the laws so what are the requireme
nts for mana transformers for all foreign there must be the following properties
 so first of all this must be a monad which I call the moon at em transformed
 with this transform ITL so it's a foreign moment that has been assimilated
 somehow onto the base model and the result is this big larger moment that
 has both effects there must be a lifting which is this function monad morphism
 between em the foreign Monat and the transformer there's also the base
 lifting which lifts the basement in the new transformer but it is not natural
 in L because L is not a natural type Brown or not generic type parameter
 in the transformer another property is that if we take the identity monad
 as M and the result must be equivalent to hell and this is not natural
 because the identity monad does not have an effect so if we transform that
 assimilate and that then just the effects of L remain and that's the same
 as just having L now the fact that the transformer is magnetically natural
 in the mannered M means that there are these other properties namely T
 must be paralyzed by him as a type parameter and for any other moment in
 we could we should be able to map M - n inside the T so if we know how
 to map M - n using some melodic morphism then we should also know how to
 map transform the M to transformed him so this I call em Ron so if I know
 how to run the moon and em into some other moment and I should know how
 to run the transform model into the transform the other monitor also these
 runners must commute with lifts and baseless so if I first lift and then
 run for example for lift L and then I run [Music] then I should obtain
 the same result as when I first run and then lift so we will look at the
 precise formulation of this a little later now this naturality will always
 hold automatically as long as we implement this mu not only using the moon
 had methods of him we don't use the structure of M but only call its methods
 pure and flat map and this situation is similar to what happened in chapter
 9 when we talked about I talked about Traverse so this Traverse had this
 type signature and it was natural with respect to negative function f so
 did not use the structure of the function f only the fact that it was a
 negative and this therefore can be used to run the monad for example take
 this runner if it exists and lift it to this runner which is a runner from
 TM to L so we can eliminate the effects of M or run them evaluate them
 perform them and get just an L which are so effects of L and M were combined
 in this monad we can separately run or evaluate effects of M and the effects
 of L should remain similarly there should be a base runner where we can
 run the effects of L inside the transferrin monad and the result is just
 M left that's the base runner and again it should commute with lift and
 base lifts why do we need these runners well the only way to evaluate Mona's
 is to run them to actually perform the effects and unless these laws hold
 performing the effects would give incorrect results when we combine the
 effects so we should be able to combine the effects without changing our
 ability to run them separately so we can combine L and M effects but we
 can run ill and not M work we can just run em but not l separately as much
 as we can as much as we need to separate them so these are the requirements
 and I will go through these requirements later to prove that they hold
 for all the monad transformers here are some first examples if we have
 a reader then the reader composed outside works if we have this mu knot
 which is a combination of either and writer then this can be composed inside
 these are monarch instructions that I have proved in Chapter 7 and actually
 these are ma not transformers for these moments from the reader and for
 this moment which is a combination of either and writer so therefore these
 are the Transformers reader te 30 and writer T which we can write down
 immediately already having proved that these are models we still haven't
 proved other laws but we have proved that the Campbell combine types Ramona's
 notice that the reader composes with the foreign loan add from the outside
 but either in writer compose inside that foreign unit and this must be
 so other the other way around is wrong it doesn't work does not produce
 a minute for her betray him which I just showed you thank God the remaining
 questions for us so what about other movements so now we chanced to know
 this before but what about other moments we don't know and they don't compose
 me neither of them composes inside or outside with arbitrary other monads
 so we also have a lot of other melodic instructions how to find transformers
 for the results of those constructions if we use them and if we know transforme
rs for some previous moment we made new moments out of previous moments
 how to find transformers for them what about monads constructed using a
 transformer what's a transformer for that and whether it's always possible
 as like I said it is unknown maybe there are some owners that don't have
 transformers I haven't seen good examples of that now is a transformer
 unique now it is not almost sure why but usually there is one transformer
 against preferred that's the simplest and that's what people usually mean
 when they say the mono transformer and another final issue is all this
 boilerplate around lift now lifting is still quite cumbersome you need
 all this lifting and the code is cumbersome because they're all these especiall
y if you have more than two monads combined and there's lift of lift of
 lift in different orders and that makes code difficult to maintain so there
 are solutions for that which are called MTL style transformers until stands
 for monad transformer library so I'll talk about these issues in order
 in the rest of this chapter here's an overview of all what I know about
 one on transformers each one that has a different transformer so it's really
 a zoology and each construction is ad-hoc so there's no general method
 for them so some will not have composed inside transformer so these are
 the option right here and either for each Monett we need to know what that
 is so we will see how that works so for someone as it's composed inside
 for others it's composed outside so this is the formula what are those
 moments that can pose outside the reader and also there's a unit called
 the search monad which is this type which I have shown before the chapter
 7 I didn't call it specifically a search moment but this and similar moments
 have transformers and that can pose outside and more generally I define
 I will define a class of factors that are called the rigid and muninn saturated
 or have outside transformers so they're kind of they're they're generalizing
 the reader and this kind of monad there are several other such types another
 type of monads is recursive lists non-empty lists and free movement they
 are defined recursively and neither of the compositions worked for them
 they need a different construction which is interleaving the basement and
 the foreign unit inside the recursion so it cannot be just composition
 another type of monads is monads obtained from constructions so for example
 product a unit has a product of transformers so you need to know the transforme
r for L one transformer for L 2 and then you make a product that is the
 transformer for the product monent another construction that I already
 described in chapter 7 is this we have a contra factor H and have a function
 from its to a so this construction works for any control factor H and gives
 you a moment and this moment has a composed outside transformer it is rigid
 another class of one else is free pointed minutes this is also construction
 from chapter 7 a transformer for that Monod looks like this it's neither
 composition outside nor inside and requires you to know the transformer
 for the m'lad l and then you know how to define a transformer for this
 moment finally there are irregular moments where none of these constructions
 work for example the statement for the statement composition doesn't work
 these constructions doesn't don't work you need to put the formula at the
 precise spot inside the statement and then it works for the continuation
 or not you need to put the foreign wallet in here otherwise nothing works
 there is a another class of Mona's that I call selectors for them you have
 to do this again it's neither composition nor constructions like that finally
 there is a good density monitor which again you have to put the foreign
 model inside at specific places so these are irregular so each has its
 own recipe and there doesn't seem to be much of a system here it is not
 clear that one odds could exist with no transformers but one suspicious
 fact is that some transformers do not have several of the required methods
 so for example the continuation monad transformer does not have a base
 lifting in other words you cannot lift a value of the continuation monad
 into the value of these types of continuation when it is a - R - R cannot
 lift that into a TOA Mart anymore for arbitrary yeah now this is a problem
 in my view it means that these transformers are not fully usable they kind
 of half work but unless I can lift both my monads into a transformer I
 cannot really replace in the functor block the previous monad with the
 big moment so in my view this is a problem and you could argue that these
 transformers are incorrect they are not fully featured they do not satisfy
 the required laws I couldn't get that and I will talk about this later
 so now I begin with the composed inside transformers which is the first
 class of transformers in my 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
