#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The logic of types.
 I.
 Disjunctive types
\begin_inset CommandInset label
LatexCommand label
name "chap:Disjunctive-types"

\end_inset


\end_layout

\begin_layout Standard
Disjunctive types describe values that belong to a disjoint set of alternatives.
 
\end_layout

\begin_layout Standard
To see how Scala implements disjunctive types, we need to begin by looking
 at 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Scala's 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Tuple types with names
\end_layout

\begin_layout Standard
It is often helpful to use names for the different parts of a tuple.
 Suppose that some program represents the size and the color of socks with
 the tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

.
 What if the same tuple type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, String)
\end_layout

\end_inset

 is used in another place in the program to mean the amount paid and the
 payee? A programmer could mix the two values by mistake, and it would be
 hard to find out why the program incorrectly computes, say, the total amount
 paid:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[(Double, String)]): Double = ps.map(_._1).sum
\end_layout

\begin_layout Plain Layout

val x = (10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)       // Sock size and color.
\end_layout

\begin_layout Plain Layout

val y = (25.0, 
\begin_inset Quotes eld
\end_inset

restaurant
\begin_inset Quotes erd
\end_inset

)  // The amount paid and the payee.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(x, y)) // Nonsense.
\end_layout

\begin_layout Plain Layout

res0: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We would prevent this kind of mistake if we could use two 
\emph on
different
\emph default
 types, with names such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

, for the two kinds of data.
 There are  three basic ways of defining a new named type in Scala: using
 a type alias, using a class (or 
\begin_inset Quotes eld
\end_inset

trait
\begin_inset Quotes erd
\end_inset

), and using an 
\begin_inset Index idx
status open

\begin_layout Plain Layout
opaque type
\end_layout

\end_inset

opaque type.
 
\end_layout

\begin_layout Standard
Opaque types (hiding a type under a new name) is a feature of Scala 3.
 It can be seen as a case class with a single field but without the cost
 of memory allocation.
 Here, we will focus on type aliases and case classes.
\end_layout

\begin_layout Standard
A 
\series bold
type alias
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type alias
\end_layout

\end_inset

 is an alternative name for an existing (already defined) type.
 We could use type aliases in our example to add clarity to the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type MySockTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

type PaymentTuple = (Double, String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val s: MySockTuple = (10.5, "white")
\end_layout

\begin_layout Plain Layout

s: MySockTuple = (10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val p: PaymentTuple = (25.0, "restaurant")
\end_layout

\begin_layout Plain Layout

p: PaymentTuple = (25.0,restaurant)
\end_layout

\end_inset

But type aliases do not prevent mix-up errors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(s, p)) // Nonsense again.
\end_layout

\begin_layout Plain Layout

res1: Double = 35.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's 
\series bold
case classes
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
case class
\end_layout

\end_inset

 can be seen as 
\begin_inset Quotes eld
\end_inset

tuples with names
\begin_inset Quotes erd
\end_inset

.
 A case class is equivalent to a tuple type that has a name designating
 the type and a separate name for each part of the case class.
 This is how we might define case classes for the example with socks and
 payments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class Payment(amount: Double, name: String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val sock = MySock(10.5, "white")
\end_layout

\begin_layout Plain Layout

sock: MySock = MySock(10.5,white)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val paid = Payment(25.0, "restaurant")
\end_layout

\begin_layout Plain Layout

paid: Payment = Payment(25.0,restaurant)                                
  
\end_layout

\end_inset

This code defines new types named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

.
 Values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 are written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

, which is similar to writing the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 except for adding the name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 in front of the tuple.
\end_layout

\begin_layout Standard
To access the parts of a case class, we use the part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> sock.size
\end_layout

\begin_layout Plain Layout

res2: Double = 10.5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> paid.amount
\end_layout

\begin_layout Plain Layout

res3: Double = 25.0
\end_layout

\end_inset

The mix-up error is now a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

type error detected by the compiler:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def totalAmountPaid(ps: Seq[Payment]): Double = ps.map(_.amount).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(paid, paid))
\end_layout

\begin_layout Plain Layout

res4: Double = 50.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> totalAmountPaid(Seq(sock, paid))
\end_layout

\begin_layout Plain Layout

<console>:19: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : MySock
\end_layout

\begin_layout Plain Layout

 required: Payment
\end_layout

\begin_layout Plain Layout

       totalAmountPaid(Seq(sock, paid))
\end_layout

\begin_layout Plain Layout

                           ^
\end_layout

\end_inset

A function whose argument is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 cannot be applied to an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Payment
\end_layout

\end_inset

.
 Case classes with different names are 
\emph on
different types
\emph default
, even if they contain the same parts.
 
\end_layout

\begin_layout Standard
It is important that type errors are detected at compile time.
 Compiled programs can run only if all types match.
 This prevents a broad class of run-time errors
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(as seen in some programming languages: 
\begin_inset Quotes eld
\end_inset


\emph on
object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 does not have method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset


\emph default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\emph on
undefined is not an object
\emph default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 that occur due to wrong types.
 
\end_layout

\begin_layout Standard
Just as tuples can have any number of parts, case classes can have any number
 of parts, but the part names must be distinct, for example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Person(firstName: String, lastName: String, age: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val noether = Person("Emmy", "Noether", 137)
\end_layout

\begin_layout Plain Layout

noether: Person = Person(Emmy,Noether,137)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> noether.firstName
\end_layout

\begin_layout Plain Layout

res5: String = Emmy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> noether.age
\end_layout

\begin_layout Plain Layout

res6: Int = 137
\end_layout

\end_inset

This data type carries the same information as a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String, String, Int)
\end_layout

\end_inset

.
 However, the declaration of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Person
\end_layout

\end_inset

 gives the programmer several features that make working with the tuple's
 data more convenient and less error-prone.
\end_layout

\begin_layout Standard
Some (or all) part names may be specified when creating a case class value:
\begin_inset listings
lstparams "extendedchars=true,mathescape=true"
inline false
status open

\begin_layout Plain Layout

scala> val poincar$
\backslash
text{
\backslash
'e}$ = Person(firstName = "Henri", lastName = "Poincar$
\backslash
text{
\backslash
color{mauve}
\backslash
'e}$", 165)
\end_layout

\begin_layout Plain Layout

poincar$
\backslash
text{
\backslash
'{e}}$: Person = Person(Henri,Poincar$
\backslash
text{
\backslash
'e}$,165)
\end_layout

\end_inset

It is a type error to use wrong types with a case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : Int(140)
\end_layout

\begin_layout Plain Layout

 required: String
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                      ^
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("Albert")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       val p = Person(140, "Einstein", "Albert")
\end_layout

\begin_layout Plain Layout

                                       ^
\end_layout

\end_inset

This error is due to an incorrect order of parts when creating a case class
 value.
 However, parts can be specified in any order when using part names:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val p = Person(age = 137, lastName = "Noether", firstName = "Emmy")
\end_layout

\begin_layout Plain Layout

p: Person = Person(Emmy,Noether,137)
\end_layout

\end_inset

A part of a case class can have the type of another case class, creating
 a type similar to a nested tuple:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, "white"), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> bag.sock.size
\end_layout

\begin_layout Plain Layout

res7: Double = 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Case classes with type parameters
\end_layout

\begin_layout Standard
Type classes can be defined with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type parameter
\end_layout

\end_inset

type parameters.
 As an example, consider an extension of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySock
\end_layout

\end_inset

 where, in addition to the size and color, an 
\begin_inset Quotes eld
\end_inset

extended sock
\begin_inset Quotes erd
\end_inset

 holds another value.
 We could define several specialized case classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySockInt(size: Double, color: String, value: Int)
\end_layout

\begin_layout Plain Layout

case class MySockBoolean(size: Double, color: String, value: Boolean)
\end_layout

\end_inset

but it is better to define a single parameterized case class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySockX[A](size: Double, color: String, value: A)
\end_layout

\end_inset

This case class can accommodate every type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 We may now create values of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

 containing a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

value
\end_layout

\end_inset

 of any given type, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = MySockX(10.5, "white", 123)
\end_layout

\begin_layout Plain Layout

s: MySockX[Int] = MySockX(10.5,white,123) 
\end_layout

\end_inset

Because the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 was automatically set to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 The result has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

MySockX[Int]
\end_layout

\end_inset

.
 The programmer does not need to specify that type explicitly.
\end_layout

\begin_layout Standard
Each time we create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

, a specific type will have to be used instead of the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 If we want to be explicit, we may write the type parameter like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val s = MySockX[String](10.5, "white", 
\begin_inset Quotes eld
\end_inset

last pair
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

s: MySockX[String] = MySockX(10.5,white,last pair) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can write 
\series bold
parametric code
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
parametric code
\end_layout

\end_inset

 working with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

, that is, keeping the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 in the code.
 For example, a function that checks whether a sock of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[A]
\end_layout

\end_inset

 fits the author's foot can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fits[A](sock: MySockX[A]): Boolean = sock.size >= 10.5 && sock.size <=
 11
\end_layout

\end_inset

This function is defined for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 at once, because its code works in the same way regardless of what 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is.
 Scala will set the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 automatically when we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fits
\end_layout

\end_inset

 to an argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fits(MySockX(10.5, 
\begin_inset Quotes eld
\end_inset

blue
\begin_inset Quotes erd
\end_inset

, List(1, 2, 3))) // Using MySockX[List[Int]].
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\end_inset

This code forces the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 to be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

, and so we may omit the type parameter of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fits
\end_layout

\end_inset

.
 When types become more complicated, it may be helpful to write out some
 type parameters.
 The compiler can detect a mismatch between the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = List[Int]
\end_layout

\end_inset

 used in the 
\begin_inset Quotes eld
\end_inset

sock
\begin_inset Quotes erd
\end_inset

 value and the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

 in the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fits
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fits[Int](MySockX(10.5, "blue", List(1, 2, 3)))
\end_layout

\begin_layout Plain Layout

<console>:15: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : List[Int]
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

       fits[Int](MySockX(10.5, "blue", List(1, 2, 3)))
\end_layout

\begin_layout Plain Layout

                                           ^ 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Case classes may have several type parameters, and the types of the parts
 may use these type parameters.
 Here is an artificial example of a case class using type parameters in
 different ways:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Complicated[A, B, C, D](x: (A, A), y: (B, Int) => A, z: C =>
 C)
\end_layout

\end_inset

This case class contains parts of different types that use the type parameters
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 in tuples and functions.
 The type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 is not used at all; this is allowed (and occasionally useful).
\end_layout

\begin_layout Standard
A type with type parameters, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Complicated
\end_layout

\end_inset

, is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
type constructor
\end_layout

\end_inset


\series bold
type constructor
\series default
.
 A type constructor 
\begin_inset Quotes eld
\end_inset

constructs
\begin_inset Quotes erd
\end_inset

 a new type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[Int]
\end_layout

\end_inset

, from a given type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

 cannot be created without setting the type parameter.
 So, it is important to distinguish the type constructor, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX
\end_layout

\end_inset

, from a type that can have values, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

MySockX[Int]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Tuples with one part and with zero parts
\end_layout

\begin_layout Standard
Let us compare tuples and case classes more systematically.
\end_layout

\begin_layout Standard
Parts of a case class are accessed with a dot syntax, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sock.color
\end_layout

\end_inset

.
 Parts of a tuple are accessed with the accessors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x._1
\end_layout

\end_inset

.
 This syntax is the same as that for a case class whose parts have names
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 So, it appears that tuple parts 
\emph on
do
\emph default
 have names in Scala, although those names are always automatically chosen
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_2
\end_layout

\end_inset

, etc.
 Tuple types are also automatically named in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple3
\end_layout

\end_inset

, etc., and they are parameterized, since each part of the tuple may be of
 any chosen type.
 A tuple type expression such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, String)
\end_layout

\end_inset

 is just a special syntax for the parameterized type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple2[Int, String]
\end_layout

\end_inset

.
 One could define the tuple types as case classes like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Tuple2[A, B](_1: A, _2: B)
\end_layout

\begin_layout Plain Layout

case class Tuple3[A, B, C](_1: A, _2: B, _3: C)  // And so on with Tuple4,
 Tuple5...
\end_layout

\end_inset

However, these types are already defined in the Scala library.
\end_layout

\begin_layout Standard
Proceeding systematically, we ask whether tuple types can have just one
 part or even no parts.
 Indeed, Scala defines 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple1[A]
\end_layout

\end_inset

 (which is rarely used in practice) as a tuple with a single part.
\end_layout

\begin_layout Standard
The tuple with zero parts also exists and is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 (instead of 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tuple0
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

).
 The syntax for the value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is an empty tuple, denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 in Scala.
 It is clear that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 is the 
\emph on
only
\emph default
 possible value of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type.
 The name 
\begin_inset Quotes eld
\end_inset

unit
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 reminds us of that.
 
\end_layout

\begin_layout Standard
At first sight, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type — an empty tuple that carries no data — may appear to be useless.
 It turns out, however, that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type is important in functional programming.
 It is used as a type 
\emph on
guaranteed
\emph default
 to have only a single distinct value.
 This book will show many examples of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Case classes may have one part or zero parts, similarly to the one-part
 and zero-part tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class B(z: Int)     // Tuple with one part.
\end_layout

\begin_layout Plain Layout

case class C()           // Tuple with no parts.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following table shows the correspondence between tuples and case classes:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Tuples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Case classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123, "xyz"): Tuple2[Int, String]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class A(x: Int, y: String)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(123,): Tuple1[Int]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class B(z: Int)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(): Unit
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Scala has an alternative syntax for empty case classes
\begin_inset Index idx
status open

\begin_layout Plain Layout
empty case class
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case object C   // Similar to `case class C()`.
\end_layout

\end_inset

There are two main differences between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 cannot have type parameters, while we could define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C[X, Y, Z]()
\end_layout

\end_inset

 with type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Z
\end_layout

\end_inset

, etc.
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 is allocated in memory only once, while new values of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 will be allocated in memory each time 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C()
\end_layout

\end_inset

 is evaluated.
\end_layout

\begin_layout Standard
Other than that, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class C()
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object C
\end_layout

\end_inset

 have the same meaning: a named tuple with zero parts, which we may also
 view as a 
\begin_inset Quotes eld
\end_inset

named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset


\begin_inset Index true 1 ""
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 type.
 This book will not use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

s because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class
\end_layout

\end_inset

es are sufficient.
\end_layout

\begin_layout Subsection
Pattern matching for case classes
\end_layout

\begin_layout Standard
Scala performs pattern matching in two situations:
\end_layout

\begin_layout Itemize
destructuring definition: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

val $pattern$ = ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression: 
\begin_inset listings
lstparams "mathescape=true"
inline true
status open

\begin_layout Plain Layout

case $pattern$ => ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In both situations, case classes can be used as patterns.
 The following code is an example of a destructuring definition with case
 classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class MySock(size: Double, color: String)
\end_layout

\begin_layout Plain Layout

case class BagOfSocks(sock: MySock, count: Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def printBag(bag: BagOfSocks): String = {
\end_layout

\begin_layout Plain Layout

  val BagOfSocks(MySock(size, color), count) = bag // Destructure the `bag`.
\end_layout

\begin_layout Plain Layout

  s
\begin_inset Quotes eld
\end_inset

bag has $count $color socks of size $size
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val bag = BagOfSocks(MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

), 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> printBag(bag)
\end_layout

\begin_layout Plain Layout

res0: String = bag has 6 white socks of size 10.5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression can match a value, extract some pattern variables, and compute
 a result:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fits(bag: BagOfSocks): Boolean = bag match {
\end_layout

\begin_layout Plain Layout

  case BagOfSocks(MySock(size, _), _) => (size >= 10.5 && size <= 11.0)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the code of this function, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bag
\end_layout

\end_inset

 is matched against the pattern expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks(MySock(size, _), _)
\end_layout

\end_inset

.
 This pattern will define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

 as a pattern variable of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 and assign the corresponding part of the case class to that variable.
 For example, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks(MySock(10.5, 
\begin_inset Quotes eld
\end_inset

white
\begin_inset Quotes erd
\end_inset

), 6)
\end_layout

\end_inset

) matched against 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

BagOfSocks(MySock(size, _), _)
\end_layout

\end_inset

 assigns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10.5
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

.
 The symbols 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 mean that we just ignore other parts of the case classes and do not create
 any pattern variables for them (because we do not need them in this code).
\end_layout

\begin_layout Standard
The syntax for pattern matching for case classes is similar to the syntax
 for pattern matching for tuples, except for the presence of 
\emph on
names
\emph default
 of the case classes.
 For example, by removing the case class names from the pattern:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case BagOfSocks(MySock(size, _), _) => ...
\end_layout

\end_inset

we obtain a nested tuple pattern:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case ((size, _), _) => ...
\end_layout

\end_inset

that could be used for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((Double, String), Int)
\end_layout

\end_inset

.
 So, within pattern matching expressions, case classes behave as tuple types
 with added names.
 
\end_layout

\begin_layout Standard
Scala's 
\begin_inset Quotes eld
\end_inset

case classes
\begin_inset Quotes erd
\end_inset

 got their name from their use in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 It is usually more convenient to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions with case classes than to use destructuring definitions.
\end_layout

\begin_layout Section
Disjunctive types
\end_layout

\begin_layout Subsection
Motivation and first examples
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Motivation-and-first-examples"

\end_inset


\end_layout

\begin_layout Standard
In many situations, it is useful to have several different shapes of data
 within the same type.
 As a first example, suppose we are looking for real roots of a quadratic
 equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

.
 There are three cases: no real roots, one real root, and two real roots.
 It is convenient to have a type that represents 
\begin_inset Quotes eld
\end_inset

real roots of a quadratic equation
\begin_inset Quotes erd
\end_inset

; call it 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 Inside that type, we distinguish between the three cases, but outside it
 looks like a single type.
\end_layout

\begin_layout Standard
Another example is the binary search algorithm that looks for an integer
 
\begin_inset Formula $x$
\end_inset

 in a sorted array.
 Either the algorithm finds the location of 
\begin_inset Formula $x$
\end_inset

 in the array, or it determines that the array does not contain 
\begin_inset Formula $x$
\end_inset

.
 It is convenient if the algorithm could return a value of a single type
 (say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

) that represents 
\emph on
either
\emph default
 an index at which 
\begin_inset Formula $x$
\end_inset

 is found, 
\emph on
or
\emph default
 the absence of an index.
\end_layout

\begin_layout Standard
More generally, we may have computations that 
\emph on
either
\emph default
 return a result 
\emph on
or
\emph default
 generate an error and fail to produce a result.
 It is then convenient to return a value of a single type (say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

) that represents either a correct result or an error message.
 
\end_layout

\begin_layout Standard
In certain computer games, one has different types of 
\begin_inset Quotes eld
\end_inset

rooms
\begin_inset Quotes erd
\end_inset

, each room having certain properties depending on its type.
 Some rooms are dangerous because of monsters, other rooms contain useful
 objects, certain rooms allow you to finish the game, and so on.
 We want to represent all the different kinds of rooms uniformly as a type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Room
\end_layout

\end_inset

.
 A value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Room
\end_layout

\end_inset

 should automatically describe the room's relevant properties in each case.
\end_layout

\begin_layout Standard
In all these situations, data comes in several mutually exclusive shapes.
 This sort of data 
\emph on
can
\emph default
 be represented by a single type if that type is able to describe a mutually
 exclusive set of cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 must be either the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 value, or a tuple of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 must be either an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value or the empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 must be either an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 error message
\end_layout

\begin_layout Standard
We see that the empty tuple, i.e., the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, is natural to use in these situations.
 It is also helpful to assign names to each of the cases:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

no roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

one root
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

two roots
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

index
\begin_inset Quotes erd
\end_inset

 with an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 value, or 
\begin_inset Quotes eld
\end_inset

not found
\begin_inset Quotes erd
\end_inset

 with value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset Quotes eld
\end_inset

error message
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala's case classes provides exactly what we need here — named tuples with
 zero, one, two, or more parts.
 So, it is natural to use case classes instead of tuples:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is a value of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, or of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(x: Double)
\end_layout

\end_inset

, or of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x: Double, y: Double)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 is a value of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Index(x: Int)
\end_layout

\end_inset

 or of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 is a value of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value(x: Int)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error(message: String)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our three examples are now described as types that allow us to select one
 case class out of a given set.
 It remains to see how Scala defines such types.
 For instance, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 needs to indicate that the case classes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

 are the only possibilities allowed by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 The Scala syntax for that definition looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class NoRoots()                        extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class OneRoot(x: Double)               extends RootsOfQ
\end_layout

\begin_layout Plain Layout

final case class TwoRoots(x: Double, y: Double)   extends RootsOfQ
\end_layout

\end_inset

In the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, we have two cases:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait SearchResult
\end_layout

\begin_layout Plain Layout

final case class Index(x: Int)   extends SearchResult
\end_layout

\begin_layout Plain Layout

final case class NotFound()      extends SearchResult
\end_layout

\end_inset

The definition of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 type is parameterized, so that we can describe results of any type (while
 error messages are always of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Result[A]
\end_layout

\begin_layout Plain Layout

final case class Value[A](x: A)              extends Result[A]
\end_layout

\begin_layout Plain Layout

final case class Error[A](message: String)   extends Result[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sealed trait
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

final case class
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax defines a type that represents a choice of one case class from a
 fixed set of case classes.
 This kind of type is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type
\end_layout

\end_inset


\series bold
disjunctive 
\series default
type (or a 
\series bold
co-product
\series default
 type
\begin_inset Index idx
status open

\begin_layout Plain Layout
co-product type!see 
\begin_inset Quotes eld
\end_inset

disjunctive type
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

) in this book.
 The keywords 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

final
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sealed
\end_layout

\end_inset

 tell the Scala compiler that the given set of case classes within a disjunctive
 type is fixed and unchangeable.
\end_layout

\begin_layout Subsection
Examples: Pattern matching for disjunctive types
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our first examples of disjunctive types are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[A]
\end_layout

\end_inset

 defined in the previous section.
 We will now look at the Scala syntax for working with disjunctive types.
\end_layout

\begin_layout Standard
Consider the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 with three parts (the case classes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

).
 The only way of creating a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is to create a value of one of these case classes.
 This is done by writing expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(2.0)
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(1.0, -1.0)
\end_layout

\end_inset

.
 Scala will accept these expressions as having the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: RootsOfQ = OneRoot(2.0)
\end_layout

\begin_layout Plain Layout

x: RootsOfQ = OneRoot(2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How can we use a given value, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: RootsOfQ
\end_layout

\end_inset

? Disjunctive types fit well with pattern matching.
 In Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we used pattern matching with syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (x, y) => ...
 }
\end_layout

\end_inset

.
 To use pattern matching with disjunctive types, we write 
\emph on
several
\emph default
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 patterns because we need to detect several possible cases of the disjunctive
 type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def print(r: RootsOfQ): String = r match {
\end_layout

\begin_layout Plain Layout

  case NoRoots()       => 
\begin_inset Quotes eld
\end_inset

no real roots
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case OneRoot(r)      => s
\begin_inset Quotes eld
\end_inset

one real root: $r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case TwoRoots(x, y)  => s
\begin_inset Quotes erd
\end_inset

real roots: ($x, $y)
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> print(x)
\end_layout

\begin_layout Plain Layout

res0: String = 
\begin_inset Quotes eld
\end_inset

one real root: 2.0
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

Each 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

case
\end_layout

\end_inset

 pattern will introduce its own pattern variables, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

r
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

y
\end_layout

\end_inset

 as in the code at left.
 Each pattern variable is defined only within the 
\emph on
local scope
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset

, that is, within the scope of its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

case
\end_layout

\end_inset

 expression.
 It is impossible to make a mistake where we, say, refer to the variable
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

r
\end_layout

\end_inset

 within the code that handles the case of two roots.
\end_layout

\begin_layout Standard
If the code only needs to work with a subset of cases, we can match all
 other cases with an underscore character (as in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case _
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> x match {
\end_layout

\begin_layout Plain Layout

  case OneRoot(r)   => s
\begin_inset Quotes erd
\end_inset

one real root: $r
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

  case _            => 
\begin_inset Quotes eld
\end_inset

have something else
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

res1: String = one real root: 2.0
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression represents a choice over possible values of a given type.
 Note the similarity with this code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int): Int = x match {
\end_layout

\begin_layout Plain Layout

  case 0    => println(s"error: must be nonzero"); -1
\end_layout

\begin_layout Plain Layout

  case 1    => println(s"error: must be greater than 1"); -1
\end_layout

\begin_layout Plain Layout

  case _    => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

 are some possible values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, just as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(4.0)
\end_layout

\end_inset

 is a possible value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 When used with disjunctive types, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions will usually cover the complete list of possibilities.
 If the list of cases is incomplete, the Scala compiler will print a warning:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def g(x: RootsOfQ): String = x match {
\end_layout

\begin_layout Plain Layout

         case OneRoot(r) => s"one real root: $r"
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

<console>:14: warning: match may not be exhaustive.
\end_layout

\begin_layout Plain Layout

It would fail on the following inputs: NoRoots(), TwoRoots(_, _)
\end_layout

\end_inset

This code defines a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset


\emph on
partial
\emph default
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 that can be applied only to values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(...)
\end_layout

\end_inset

 and will fail (throwing an exception
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset

) for other values.
\end_layout

\begin_layout Standard
Let us look at more examples of using the disjunctive types we just defined.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of quadratic equations, compute a sequence containing their
 real roots as values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Define a case class representing a quadratic equation 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class QEqu(b: Double, c: Double)
\end_layout

\end_inset

The following function determines how many real roots an equation has:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solve(quadraticEqu: QEqu): RootsOfQ = {
\end_layout

\begin_layout Plain Layout

   val QEqu(b, c) = quadraticEqu    // Destructure QEqu.
\end_layout

\begin_layout Plain Layout

   val d = b * b / 4 - c
\end_layout

\begin_layout Plain Layout

   if (d > 0) {
\end_layout

\begin_layout Plain Layout

     val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

     TwoRoots(- b / 2 - s, - b / 2 + s)
\end_layout

\begin_layout Plain Layout

   } else if (d == 0.0) OneRoot(- b / 2)
\end_layout

\begin_layout Plain Layout

   else NoRoots()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> solve(QEqu(1, 1))
\end_layout

\begin_layout Plain Layout

res1: RootsOfQ = NoRoots()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(1, -1))
\end_layout

\begin_layout Plain Layout

res2: RootsOfQ = TwoRoots(-1.618033988749895,0.6180339887498949) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solve(QEqu(6, 9))
\end_layout

\begin_layout Plain Layout

res3: RootsOfQ = OneRoot(-3.0) 
\end_layout

\end_inset

We can now implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

findRoots
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map(solve)
\end_layout

\end_inset

If the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 will not be used often, we may want to write it inline as a nameless function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def findRoots(equs: Seq[QEqu]): Seq[RootsOfQ] = equs.map { case QEqu(b, c)
 =>
\end_layout

\begin_layout Plain Layout

  (b * b / 4 - c) match {
\end_layout

\begin_layout Plain Layout

    case d if d > 0   =>
\end_layout

\begin_layout Plain Layout

      val s = math.sqrt(d)
\end_layout

\begin_layout Plain Layout

      TwoRoots(- b / 2 - s, - b / 2 + s)
\end_layout

\begin_layout Plain Layout

    case 0.0          => OneRoot(- b / 2)
\end_layout

\begin_layout Plain Layout

    case _            => NoRoots()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code depends on some features of Scala syntax.
 We can use the function expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case QEqu(b, c) => ...
 }
\end_layout

\end_inset

 directly as the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, destructuring 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QEqu
\end_layout

\end_inset

 at the same time.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expression is replaced by an 
\begin_inset Quotes eld
\end_inset

embedded
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
embedded 
\family typewriter
if
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

 within a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression, which is easier to read.
\end_layout

\begin_layout Standard
Test the final code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> findRoots(Seq(QEqu(1, 1), QEqu(2, 1)))
\end_layout

\begin_layout Plain Layout

res4: Seq[RootsOfQ] = List(NoRoots(), OneRoot(-1.0)) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a sequence of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

, compute a sequence containing only the single roots.
 Example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> singleRoots(Seq(TwoRoots(-1, 1), OneRoot(3.0), OneRoot(1.0), NoRoots()))
\end_layout

\begin_layout Plain Layout

res5: Seq[Double] = List(3.0, 1.0) 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 to the sequence of roots:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double] =
\end_layout

\begin_layout Plain Layout

  rs.filter {
\end_layout

\begin_layout Plain Layout

    case OneRoot(x) => true
\end_layout

\begin_layout Plain Layout

    case _          => false
\end_layout

\begin_layout Plain Layout

  }.map { case OneRoot(x) => x }
\end_layout

\end_inset

In the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operation, we need to cover only the one-root case because the two other
 possibilities have been excluded (
\begin_inset Quotes eld
\end_inset

filtered out
\begin_inset Quotes erd
\end_inset

) by the preceding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation.
 
\end_layout

\begin_layout Standard
We can implement the same function by using the standard library's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

collect
\end_layout

\end_inset

 method that performs the filtering and mapping operation in one step:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def singleRoots(rs: Seq[RootsOfQ]): Seq[Double]
\end_layout

\begin_layout Plain Layout

  = rs.collect { case OneRoot(x) => x }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-searchresult"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-searchresult"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement binary search returning a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

.
 Modify the implementation from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) to return a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound
\end_layout

\end_inset

 value when needed.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The code from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch2Example-binary-search-seq-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

(b) will return 
\emph on
some
\emph default
 index even if the given number is not present in the array: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), goal = 5)
\end_layout

\begin_layout Plain Layout

res6: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> binSearch(Array(1, 3, 5, 7), goal = 4)
\end_layout

\begin_layout Plain Layout

res7: Int = 1
\end_layout

\end_inset

In that case, the array's element at the computed index will not be equal
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

goal
\end_layout

\end_inset

.
 We should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NotFound()
\end_layout

\end_inset

 in that case.
 We use a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expression for the new logic:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def safeBinSearch(xs: Seq[Int], goal: Int): SearchResult =
\end_layout

\begin_layout Plain Layout

  binSearch(xs, goal) match {
\end_layout

\begin_layout Plain Layout

    case n if xs(n) == goal   => Index(n) 
\end_layout

\begin_layout Plain Layout

    case _                    => NotFound()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 5)
\end_layout

\begin_layout Plain Layout

res8: SearchResult = Index(2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> safeBinSearch(Array(1, 3, 5, 7), 4)
\end_layout

\begin_layout Plain Layout

res9: SearchResult = NotFound()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-resultA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 to implement 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

, where a division by zero or a square root of a negative number gives an
 error message.
 Define arithmetic operations directly for values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

.
 Abandon further computations on any error.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the (integer-valued) square root as a function from
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sqrt(r: Result[Int]): Result[Int] = r match {
\end_layout

\begin_layout Plain Layout

  case Value(x) if x >= 0  => Value(math.sqrt(x).toInt)
\end_layout

\begin_layout Plain Layout

  case Value(x)            => Error(s
\begin_inset Quotes eld
\end_inset

error: sqrt($x)
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case Error(m)            => Error(m) // Keep the error message.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The square root is computed only if we have the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Value(x)
\end_layout

\end_inset

 case, and only if 
\begin_inset Formula $x\geq0$
\end_inset

.
 If the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

 was already an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Error
\end_layout

\end_inset

 case, we keep the error message and perform no further computations.
\end_layout

\begin_layout Standard
To implement the addition operation, we need a bit more work:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x + y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m)  // Keep the first error message.
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)  // Keep the second error message.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code illustrates nested patterns that match the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(rx, ry)
\end_layout

\end_inset

 against various possibilities.
 When written in this way, the code is clearer than code written with nested
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

else
\end_layout

\end_inset

 expressions.
\end_layout

\begin_layout Standard
Implementing the multiplication operation results in almost the same code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mul(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) => Value(x * y)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To avoid repetition, we may define a general function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map2
\end_layout

\end_inset

) that 
\begin_inset Quotes eld
\end_inset

maps
\begin_inset Quotes erd
\end_inset

 binary operations on integers to operations on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

 types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map2(rx: Result[Int], ry: Result[Int])(op: (Int, Int) => Int): Result[Int]
 =
\end_layout

\begin_layout Plain Layout

  (rx, ry) match {
\end_layout

\begin_layout Plain Layout

    case (Value(x), Value(y)) => Value(op(x, y))
\end_layout

\begin_layout Plain Layout

    case (Error(m), _)        => Error(m)
\end_layout

\begin_layout Plain Layout

    case (_, Error(m))        => Error(m)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

Now we can easily 
\begin_inset Quotes eld
\end_inset

map
\begin_inset Quotes erd
\end_inset

 any binary operation on integers to a binary operation on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result[Int]
\end_layout

\end_inset

, assuming that the operation itself never generates an error:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sub(rx: Result[Int], ry: Result[Int]): Result[Int] =
\end_layout

\begin_layout Plain Layout

  map2(rx, ry) { (x, y) => x - y }
\end_layout

\end_inset

 Custom code is still needed for operations that 
\emph on
may
\emph default
 generate errors:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def div(rx: Result[Int], ry: Result[Int]): Result[Int] = (rx, ry) match
 {
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y)) if y != 0  => Value(x / y)
\end_layout

\begin_layout Plain Layout

  case (Value(x), Value(y))            => Error(s
\begin_inset Quotes eld
\end_inset

error: $x / $y
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

  case (Error(m), _)                   => Error(m)
\end_layout

\begin_layout Plain Layout

  case (_, Error(m))                   => Error(m)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can now test the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 on simple calculations.
 Let us see what happens after an error:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(1), Value(2))
\end_layout

\begin_layout Plain Layout

res10: Result[Int] = Value(3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> div(add(Value(1), Value(2)), Value(0))
\end_layout

\begin_layout Plain Layout

res11: Result[Int] = Error(error: 3 / 0)
\end_layout

\end_inset

Let us check that all further computations are abandoned once an error occurs.
 Indeed, the following example shows that the error message for 
\begin_inset Formula $20+1/0$
\end_inset

 never mentions 
\begin_inset Formula $20$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add(Value(20), div(Value(1), Value(0)))
\end_layout

\begin_layout Plain Layout

res12: Result[Int] = Error(error: 1 / 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> add(sqrt(Value(-1)), Value(10))
\end_layout

\begin_layout Plain Layout

res13: Result[Int] = Error(error: sqrt(-1))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Standard-disjunctive-types:"

\end_inset

Standard disjunctive types: 
\family typewriter
Option
\family default
, 
\family typewriter
Either
\family default
, 
\family typewriter
Try
\end_layout

\begin_layout Standard
The Scala library defines the disjunctive types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.
 These types are used often in Scala programs.
\end_layout

\begin_layout Paragraph
The 
\family typewriter
Option
\family default
 type
\end_layout

\begin_layout Standard
is a disjunctive type with two cases: the empty tuple and a one-element
 tuple.
 The names of the two case classes are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some
\end_layout

\end_inset

.
 If the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type were not already defined in the Scala library, we could define it
 by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Option[+T]  // The annotation `+T` will be explained in Chapter
 6.
\end_layout

\begin_layout Plain Layout

final case object None           extends Option[Nothing]
\end_layout

\begin_layout Plain Layout

final case class Some[T](t: T)   extends Option[T]
\end_layout

\end_inset

This code is similar to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SearchResult
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

, except that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 has a type parameter instead of a fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Another difference is the use of a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

 instead of an empty case class, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None()
\end_layout

\end_inset

.
 Since Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case object
\end_layout

\end_inset

s cannot have type parameters, the type parameter in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 must be set to the special type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, which is a type with 
\emph on
no
\emph default
 values, also called the 
\series bold
void
\series default
 
\series bold
type
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
void type|textit
\end_layout

\end_inset

 (not to be confused with Java or C's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

void
\end_layout

\end_inset

 keyword!).
 The special type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

+T
\end_layout

\end_inset

 makes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 usable as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[T]
\end_layout

\end_inset

 for any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

T
\end_layout

\end_inset

; see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Covariance,-contravariance,-and-subtyping"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details.
\end_layout

\begin_layout Standard
An alternative (implemented, e.g., in the 
\family typewriter
scalaz
\family default
 library) is to define the empty option value as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class None[T]() extends Option[T]
\end_layout

\end_inset

In that implementation, the empty option 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None[T]()
\end_layout

\end_inset

 has a type parameter.
\end_layout

\begin_layout Standard
The Scala library's decision to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 without a type parameter means that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 can be reused as a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 for any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val y: Option[Int] = None
\end_layout

\begin_layout Plain Layout

y: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val z: Option[String] = None
\end_layout

\begin_layout Plain Layout

z: Option[String] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Typically, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 is used in situations where a value may be either present or missing, especiall
y when a missing value 
\emph on
is
\emph default
 
\emph on
not an error
\emph default
.
 The missing-value case is represented by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(x)
\end_layout

\end_inset

 represents a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 that is present.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-option-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Information about 
\begin_inset Quotes eld
\end_inset

subscribers
\begin_inset Quotes erd
\end_inset

 must include a name and an email address, but a telephone number is optional.
 To represent this information, we define a case class like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Subscriber(name: String, email: String, phone: Option[Long])
\end_layout

\end_inset

What if we represent the missing telephone number by a special value such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

 and use the simpler type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

? The disadvantage is that we would need to 
\emph on
remember
\emph default
 to check for the special value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

-1
\end_layout

\end_inset

 in all functions that take the telephone number as an argument.
 Looking at a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sendSMS(phone: Long)
\end_layout

\end_inset

 at a different place in the code, a programmer might forget that the telephone
 number is actually optional.
 In contrast, the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sendSMS(phone: Option[Long])
\end_layout

\end_inset

 unambiguously indicates that the telephone number might be missing and
 helps the programmer to remember to handle both cases.
\end_layout

\begin_layout Standard
Pattern-matching code involving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 can handle the two cases like this:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone match {
\end_layout

\begin_layout Plain Layout

  case None               => None       // Have no digits, so return `None`.
\end_layout

\begin_layout Plain Layout

  case Some(number)       => Some(digitsOf(number))
\end_layout

\begin_layout Plain Layout

}  // The function `digitsOf` was defined in Section ${
\backslash
color{dkgreen}
\backslash
textrm{
\backslash
ref{sec:ch2Converting-a-single}}}$.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At the two sides of 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case None => None
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 has different types, namely 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Seq[Long]]
\end_layout

\end_inset

.
 Since these types are declared in the type signature of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getDigits
\end_layout

\end_inset

, the Scala compiler is able to figure out the types of all expressions
 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 construction.
 So, pattern-matching code can be written without explicit type annotations
\begin_inset Index idx
status open

\begin_layout Plain Layout
type annotation
\end_layout

\end_inset

 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(None: Option[Long])
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
If we now need to compute the number of digits, we can write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def numberOfDigits(phone: Option[Long]): Option[Long] = getDigits(phone)
 match {
\end_layout

\begin_layout Plain Layout

  case None               => None
\end_layout

\begin_layout Plain Layout

  case Some(digits)       => Some(digits.length)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These examples perform a computation when an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 value is non-empty, and leave it empty otherwise.
 This code pattern is used often.
 To avoid repeating the code, we can implement this code pattern as a function
 that takes the computation as an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def doComputation(x: Option[Long], f: Long => Long): Option[Long] = x match
 {
\end_layout

\begin_layout Plain Layout

  case None               => None
\end_layout

\begin_layout Plain Layout

  case Some(i)            => Some(f(i))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

It is then natural to generalize this function to arbitrary types using
 type parameters instead of a fixed type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

.
 The resulting function is usually called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 in functional programming libraries:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  case None               => None
\end_layout

\begin_layout Plain Layout

  case Some(a)            => Some(f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap(digitsOf)(Some(4096))
\end_layout

\begin_layout Plain Layout

res0: Option[Seq[Long]] = Some(List(4, 0, 9, 6))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap(digitsOf)(None)
\end_layout

\begin_layout Plain Layout

res1: Option[Seq[Long]] = None
\end_layout

\end_inset

We say that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 operation 
\series bold
lifts
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
lifting
\end_layout

\end_inset

 a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

 to a new function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[B]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
It is important to keep in mind that the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Some(a) => Some(f(a))
\end_layout

\end_inset

 changes the type of the option value.
 On the left side of the arrow, the type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

, while on the right side it is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[B]
\end_layout

\end_inset

.
 The Scala compiler knows this from the given type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, so an explicit type parameter, which we could write as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[B](f(a))
\end_layout

\end_inset

, is not needed.
\end_layout

\begin_layout Standard
The Scala library implements an equivalent function as a method of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 class, with the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f)
\end_layout

\end_inset

 rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(x)
\end_layout

\end_inset

.
 We can concisely rewrite the previous code using these methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def getDigits(phone: Option[Long]): Option[Seq[Long]] = phone.map(digitsOf)
\end_layout

\begin_layout Plain Layout

def numberOfDigits(phone: Option[Long]): Option[Long] = phone.map(digitsOf).map(_.l
ength)
\end_layout

\end_inset

We see that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operation for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type is analogous to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operation for sequences.
 
\end_layout

\begin_layout Standard
The similarity between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 is clearer if we view 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 as a special kind of 
\begin_inset Quotes eld
\end_inset

sequence
\begin_inset Quotes erd
\end_inset

 whose length is restricted to be either 
\begin_inset Formula $0$
\end_inset

 or 
\begin_inset Formula $1$
\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 can have all the operations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 except operations such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

concat
\end_layout

\end_inset

 that may grow the sequence beyond length 
\begin_inset Formula $1$
\end_inset

.
 The standard operations defined on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 include 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exists
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunction-Example-Option-flatMap"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunction-Example-Option-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a phone number as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

, extract the country code if it is present.
 The result must be again of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

.
 Assume that the country code is the digits in front of a 
\begin_inset Formula $10$
\end_inset

-digit phone number; for the phone number 
\begin_inset Formula $18004151212$
\end_inset

, the country code is 
\begin_inset Formula $1$
\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
If the phone number is a positive integer 
\begin_inset Formula $n$
\end_inset

, we may compute the country code simply as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n / 10000000000L
\end_layout

\end_inset

.
 However, if the result of that division is zero, we should return an empty
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 (i.e., the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

) rather than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

0
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(n)   =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Notice that we have reimplemented the code pattern similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, namely 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 then return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, else return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(...)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 So, we may try to rewrite the code as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

} // Type error: the result is Option[Option[Long]], not Option[Long].
\end_layout

\end_inset

This code does not compile: we are returning an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

 within a function lifted via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, so the resulting type is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[Long]]
\end_layout

\end_inset

.
 Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 to convert 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[Long]]
\end_layout

\end_inset

 to the required type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Long]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.map { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

}.flatten // Types are correct now.
\end_layout

\end_inset

Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 follows a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, rewrite the code using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.flatMap { n =>
\end_layout

\begin_layout Plain Layout

    val countryCode = n / 10000000000L
\end_layout

\begin_layout Plain Layout

    if (countryCode != 0L) Some(countryCode) else None 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another way of implementing this example is to notice the code pattern 
\begin_inset Quotes eld
\end_inset

if condition does not hold, return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, otherwise keep the value
\begin_inset Quotes erd
\end_inset

.
 For an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type, this is equivalent to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 operation (recall that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 returns an empty sequence if the predicate never holds).
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countryCode(phone: Option[Long]): Option[Long] = phone.map(_ / 10000000000L).f
ilter(_ != 0L)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countryCode(Some(18004151212L))
\end_layout

\begin_layout Plain Layout

res0: Option[Long] = Some(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countryCode(Some(8004151212L))
\end_layout

\begin_layout Plain Layout

res1: Option[Long] = None
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunction-Example-Option-getOrElse"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunction-Example-Option-getOrElse"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Add a new requirement to Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunction-Example-Option-flatMap"
plural "false"
caps "false"
noprefix "false"

\end_inset

: if the country code is not present, return the default country code 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
This is an often used code pattern: 
\begin_inset Quotes eld
\end_inset

if empty, substitute a default value
\begin_inset Quotes erd
\end_inset

.
 The Scala library has the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getOrElse
\end_layout

\end_inset

 for this purpose:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Some(100).getOrElse(1)
\end_layout

\begin_layout Plain Layout

res2: Int = 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> None.getOrElse(1)
\end_layout

\begin_layout Plain Layout

res3: Int = 1
\end_layout

\end_inset

So, we can implement the new requirement as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> countryCode(Some(8004151212L)).getOrElse(1L)
\end_layout

\begin_layout Plain Layout

res4: Long = 1
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Using 
\family typewriter
Option
\family default
 with collections
\end_layout

\begin_layout Standard
Several Scala library methods return an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 as a result.
 Examples are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lift
\end_layout

\end_inset

 for sequences, as well as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 for dictionaries.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

 method returns the first element satisfying a predicate:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).find(_ > 5)
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (1 to 10).find(_ > 100) // No element is > 100.
\end_layout

\begin_layout Plain Layout

res1: Option[Int] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lift
\end_layout

\end_inset

 method returns the element of a sequence at a given index:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (10 to 100).lift(0)
\end_layout

\begin_layout Plain Layout

res2: Option[Int] = Some(10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> (10 to 100).lift(1000) // No element at index 1000.
\end_layout

\begin_layout Plain Layout

res3: Option[Int] = None
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

 method returns the first element of a sequence, unless the sequence is
 empty.
 This is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lift(0)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).headOption
\end_layout

\begin_layout Plain Layout

res4: Option[Int] = Some(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(1, 2, 3).filter(_ > 10).headOption
\end_layout

\begin_layout Plain Layout

res5: Option[Int] = None
\end_layout

\end_inset

Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find(p)
\end_layout

\end_inset

 computes the same result as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.filter(p).headOption
\end_layout

\end_inset

, but 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.find(p)
\end_layout

\end_inset

 may be faster.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 method for a dictionary checks whether the given key is present in the
 dictionary.
 If so, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 returns the value wrapped in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some()
\end_layout

\end_inset

.
 Otherwise, it returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b").get(10)
\end_layout

\begin_layout Plain Layout

res6: Option[String] = Some(a)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b").get(30)
\end_layout

\begin_layout Plain Layout

res7: Option[String] = None 
\end_layout

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 method is a safe by-key access to dictionaries, unlike the direct access
 that may fail with an exception:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b")(10)
\end_layout

\begin_layout Plain Layout

res8: String = a 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Map(10 -> "a", 20 -> "b")(30)
\end_layout

\begin_layout Plain Layout

java.util.NoSuchElementException: key not found: 30
\end_layout

\end_inset

Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lift
\end_layout

\end_inset

 is a safe by-index access to collections, unlike the direct access that
 may fail with an exception:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(10, 20, 30)(0)
\end_layout

\begin_layout Plain Layout

res9: Int = 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Seq(10, 20, 30)(5)
\end_layout

\begin_layout Plain Layout

java.lang.IndexOutOfBoundsException: 5
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
The 
\family typewriter
Either
\family default
 type
\end_layout

\begin_layout Standard
The standard disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 has two type parameters and is often used for computations that report
 errors.
 By convention, the 
\emph on
first
\emph default
 type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

) is the type of error, and the 
\emph on
second
\emph default
 type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

) is the type of the (non-error) result.
 The names of the two cases are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

.
 A possible definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 may be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Either[A, B]
\end_layout

\begin_layout Plain Layout

final case class Left[A, B](value: A)  extends Either[A, B]
\end_layout

\begin_layout Plain Layout

final case class Right[A, B](value: B) extends Either[A, B]
\end_layout

\end_inset

By convention, a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 represents an error, and a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 represents a valid result.
\end_layout

\begin_layout Standard
As an example, the following function substitutes a default value and logs
 the error information:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logError(x: Either[String, Int], default: Int): Int = x match {
\end_layout

\begin_layout Plain Layout

  case Left(error)  => println(s"Got error: $error"); default
\end_layout

\begin_layout Plain Layout

  case Right(res)   => res
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> logError(Right(123), -1)
\end_layout

\begin_layout Plain Layout

res1: Int = 123
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> logError(Left("bad result"), -1)
\end_layout

\begin_layout Plain Layout

Got error: bad result
\end_layout

\begin_layout Plain Layout

res2: Int = -1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 for computations that may fail? When a missing result is an error, we will
 usually need to know the reason why the result is unavailable.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type may provide detailed information about such errors, which 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 cannot do.
 An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type is mostly used in cases where the absence of a result is 
\emph on
not
\emph default
 an error.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type generalizes the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Result
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Motivation-and-first-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to an arbitrary error type instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 We have seen its usage in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where the code pattern was 
\begin_inset Quotes eld
\end_inset

if value is present, do a computation, otherwise keep the error
\begin_inset Quotes erd
\end_inset

.
 This code pattern is implemented by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

scala> Right(1).map(_ + 1)
\end_layout

\begin_layout Plain Layout

res0: Either[Nothing, Int] = Right(2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> Left[String, Int]("error").map(_ + 1)
\end_layout

\begin_layout Plain Layout

res1: Either[String, Int] = Left(
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

 was filled in by the Scala compiler because we did not specify the first
 type parameter of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right
\end_layout

\end_inset

 in line 1.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

getOrElse
\end_layout

\end_inset

 are also defined for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, with the same convention that a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left
\end_layout

\end_inset

 value represents an error.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
These methods are available in Scala 2.12 and in later versions.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Exceptions and the 
\family typewriter
Try
\family default
 type
\end_layout

\begin_layout Standard
When computations fail for any reason, Scala generates an 
\series bold
exception
\begin_inset Index idx
status open

\begin_layout Plain Layout
exception
\end_layout

\end_inset


\series default
 instead of returning a value.
 An exception means that the evaluation of some expression was stopped without
 returning a result.
\end_layout

\begin_layout Standard
As an example, exceptions are generated when the available memory is too
 small to store the resulting data (as we saw in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Lazy-values-iterators-and-streams"
plural "false"
caps "false"
noprefix "false"

\end_inset

), or if a stack overflow occurs during the computation (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tail-recursion"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Exceptions may also occur due to programmer's errors: when a pattern matching
 operation fails, when a requested key does not exist in a dictionary, or
 when the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 operation is applied to an empty list.
\end_layout

\begin_layout Standard
Motivated by these examples, we may distinguish 
\begin_inset Quotes eld
\end_inset

planned
\begin_inset Index idx
status open

\begin_layout Plain Layout
planned exception
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

unplanned
\begin_inset Quotes erd
\end_inset

 exceptions.
 
\end_layout

\begin_layout Standard
A 
\series bold
planned
\series default
 exception is generated by programmer's code via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> throw new Exception("This is a test...
 this is only a test.")
\end_layout

\begin_layout Plain Layout

java.lang.Exception: This is a test...
 this is only a test.
\end_layout

\end_inset

The Scala library contains a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 operation in various places, such as in the code for applying the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 method to an empty sequence, as well as in other situations where exceptions
 are generated due to programmer's errors.
 These exceptions are generated deliberately and in well-defined situations.
 Although these exceptions indicate errors, these errors are anticipated
 in advance and so may be handled by the programmer.
\end_layout

\begin_layout Standard
For example, many Java libraries will generate exceptions when function
 arguments have unexpected values, when a network operation takes too long
 or a network connection is unexpectedly broken, when a file is not found
 or cannot be read due to access permissions, and in other situations.
 All those exceptions are 
\begin_inset Quotes eld
\end_inset

planned
\begin_inset Quotes erd
\end_inset

 because they are generated explicitly by library code such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw new FileNotFoundException(...)
\end_layout

\end_inset

.
 The programmer's code is expected to catch those exceptions, to handle
 the errors, and to continue running the program.
\end_layout

\begin_layout Standard
An 
\series bold
unplanned
\series default
 exception
\begin_inset Index idx
status open

\begin_layout Plain Layout
unplanned exception
\end_layout

\end_inset

 is generated by the Java runtime system when critical errors occur, such
 as a stack overflow or an out-of-memory error.
 It is rare that a programmer writes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val y = f(x)
\end_layout

\end_inset

 while 
\emph on
expecting
\emph default
 that an out-of-memory exception will likely occur at that point.
\begin_inset Foot
status open

\begin_layout Plain Layout
Just once in the author's experience, an out-of-memory exception had to
 be anticipated in an Android app as something that regularly happens during
 normal usage of the app.
\end_layout

\end_inset

 An unplanned exception indicates a serious problem with memory or another
 critically important resource, such as the operating system's threads or
 file handles.
 Such problems usually cannot be fixed and will prevent the program from
 running any further.
 It is reasonable that the program should abruptly stop (or 
\begin_inset Quotes eld
\end_inset

crash
\begin_inset Quotes erd
\end_inset

, as programmers say) after such an error.
\end_layout

\begin_layout Standard
The use of planned exceptions assumes that the programmer will write code
 to handle each exception.
 This assumption makes it significantly harder to write programs correctly:
 it is hard to figure out and to keep in mind all the possible exceptions
 that a given library function may 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 in its code (and in the code of all other libraries being used).
 Instead of using exceptions for indicating errors, Scala programmers can
 write functions that return a disjunctive type, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

, describing both a correct result and an error condition.
 Users of these functions will 
\emph on
have
\emph default
 to do pattern matching on the result values.
 This helps programmers to avoid forgetting to handle an error situation
 that the code is likely to encounter.
\end_layout

\begin_layout Standard
Nevertheless, programmers will often need to use Java or Scala libraries
 that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 exceptions.
 To help write code for these situations, the Scala library provides a disjuncti
ve type called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Throwable, A]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Throwable
\end_layout

\end_inset

 is the general type of all exceptions (i.e., values to which a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 operation can be applied).
 The two parts of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 are called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Success[A]
\end_layout

\end_inset

 (instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[Throwable, A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[Throwable, A]
\end_layout

\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type).
 The class constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(expr)
\end_layout

\end_inset

 will catch all 
\begin_inset Quotes eld
\end_inset

planned
\begin_inset Quotes erd
\end_inset

 exceptions thrown while the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 is evaluated.
\begin_inset Foot
status open

\begin_layout Plain Layout
But 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try()
\end_layout

\end_inset

 will not catch exceptions of class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

java.lang.Error
\end_layout

\end_inset

 and its subclasses.
 Those exceptions are intended to represent unplanned, serious error situations.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
If the evaluation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 succeeds and returns a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

, the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(expr)
\end_layout

\end_inset

 will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Success(x)
\end_layout

\end_inset

.
 Otherwise it will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure(t)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t: Throwable
\end_layout

\end_inset

 is a value containing details about the exception.
 Here is an example of using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import scala.util.{Try, Success, Failure}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val p = Try(
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

.toInt)
\end_layout

\begin_layout Plain Layout

p: Try[Int] = Failure(java.lang.NumberFormatException: For input string: "xyz")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val q = Try(
\begin_inset Quotes eld
\end_inset

0002
\begin_inset Quotes erd
\end_inset

.toInt)
\end_layout

\begin_layout Plain Layout

q: Try[Int] = Success(2) 
\end_layout

\end_inset

The code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try(
\begin_inset Quotes eld
\end_inset

xyz
\begin_inset Quotes erd
\end_inset

.toInt)
\end_layout

\end_inset

 does not generate any exceptions and will not crash the program.
 Any computation that may 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

throw
\end_layout

\end_inset

 a planned exception can be enclosed in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try()
\end_layout

\end_inset

, and the exception will be caught and encapsulated within the disjunctive
 type as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Failure(...)
\end_layout

\end_inset

 value.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 are defined for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 class similarly to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 type.
 One additional feature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 is to catch exceptions generated by the function arguments of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

, and other standard methods:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val y = q.map(y => throw new Exception("ouch"))
\end_layout

\begin_layout Plain Layout

y: Try[Int] = Failure(java.lang.Exception: ouch)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val z = q.filter(y => throw new Exception("huh"))
\end_layout

\begin_layout Plain Layout

z: Try[Int] = Failure(java.lang.Exception: huh)
\end_layout

\end_inset

In this example, the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 were computed 
\emph on
successfully
\emph default
 even though exceptions were thrown while the function arguments of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 were evaluated.
 Further code can use pattern matching on the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 and examine those exceptions.
 However, it is important that these exceptions were caught and the program
 did not crash, meaning that further code is 
\emph on
able
\emph default
 to run.
 
\end_layout

\begin_layout Standard
While the standard types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 will cover many use cases, programmers can also define custom disjunctive
 types in order to represent all the anticipated failures or errors in the
 business logic of a particular application.
 Representing all errors in the types helps assure that the program will
 not crash because of an exception that we forgot to handle or did not even
 know about.
\end_layout

\begin_layout Section
Lists and trees as recursive disjunctive types
\begin_inset CommandInset label
LatexCommand label
name "sec:Lists-and-trees:recursive-disjunctive-types"

\end_inset


\end_layout

\begin_layout Standard
Consider this code defining a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NInt
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait NInt
\end_layout

\begin_layout Plain Layout

final case class N1(x: Int)    extends NInt
\end_layout

\begin_layout Plain Layout

final case class N2(n: NInt)   extends NInt
\end_layout

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NInt
\end_layout

\end_inset

 has two disjunctive parts: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

N1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

N2
\end_layout

\end_inset

.
 But the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N2
\end_layout

\end_inset

 contains a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NInt
\end_layout

\end_inset

 as if the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

NInt
\end_layout

\end_inset

 were already defined.
 
\end_layout

\begin_layout Standard
A type whose definition uses that same type is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive types
\end_layout

\end_inset


\series bold
recursive type
\series default
.
 The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NInt
\end_layout

\end_inset

 is an example of a recursive disjunctive type.
\end_layout

\begin_layout Standard
We might imagine defining a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 whose parts recursively refer to the same type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 (and/or to each other) in complicated ways.
 What kind of data would be represented by such a type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, and in what situations would 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 be useful? For instance, the simple definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Bad(x: Bad)
\end_layout

\end_inset

is useless since we cannot create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

 unless we 
\emph on
already have
\emph default
 a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

.
 This is an example of an infinite loop in type recursion
\begin_inset Index idx
status open

\begin_layout Plain Layout
infinite loop in type recursion
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive types!infinite loop
\end_layout

\end_inset

.
 We will never be able to create values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

, which means that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Bad
\end_layout

\end_inset

 is 
\begin_inset Quotes eld
\end_inset

void
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 (has no values, like the special Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Recursive-types-and-the-existence-of-their-values"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will derive precise conditions under which a recursive type is not void.
 For now, we will look at the recursive disjunctive types that are used
 most often: lists and trees.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-recursive-type-List"

\end_inset

The recursive type 
\family typewriter
List
\end_layout

\begin_layout Standard
A list of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is either empty, or has one value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, or two values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, etc.
 We can visualize the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 as a disjunctive type defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait List[A]
\end_layout

\begin_layout Plain Layout

final case class List0[A]()               extends List[A]
\end_layout

\begin_layout Plain Layout

final case class List1[A](x: A)           extends List[A]
\end_layout

\begin_layout Plain Layout

final case class List2[A](x1: A, x2: A)   extends List[A]
\end_layout

\begin_layout Plain Layout

???                // Need an infinitely long definition.
\end_layout

\end_inset

However, this definition is not practical: we cannot define a separate case
 class for 
\emph on
each
\emph default
 possible length.
 Instead, we define the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 via mathematical induction on the length of the list:
\end_layout

\begin_layout Itemize
Base case: empty list, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class List0[A]()
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Inductive step: given a list of a previously defined length, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $_{n-1}$
\end_inset

, define a new case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $_{n}$
\end_inset

 describing a list with one more element of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, we could define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset


\begin_inset Formula $_{n}=\,$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, List
\end_layout

\end_inset


\begin_inset Formula $_{n-1}$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us try to write this inductive definition as code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait ListI[A]           // Inductive definition of a list.
\end_layout

\begin_layout Plain Layout

final case class List0[A]()                       extends ListI[A]
\end_layout

\begin_layout Plain Layout

final case class List1[A](x: A, next: List0[A])   extends ListI[A]
\end_layout

\begin_layout Plain Layout

final case class List2[A](x: A, next: List1[A])   extends ListI[A]
\end_layout

\begin_layout Plain Layout

???                   // Still need an infinitely long definition.
\end_layout

\end_inset

To avoid writing an infinitely long type definition, we use a trick.
 Note that the definitions of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List2
\end_layout

\end_inset

, etc., have a similar form (while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List0
\end_layout

\end_inset

 is not similar).
 To replace the definitions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List2
\end_layout

\end_inset

, etc., by a single definition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN
\end_layout

\end_inset

, we write the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 inside the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait ListI[A]           // Inductive definition of a list.
\end_layout

\begin_layout Plain Layout

final case class List0[A]()                       extends ListI[A]
\end_layout

\begin_layout Plain Layout

final case class ListN[A](x: A, next: ListI[A])   extends ListI[A]
\end_layout

\end_inset

The type definition has become recursive.
 For this trick to work, it is important to use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 and not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN[A]
\end_layout

\end_inset

 inside the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN[A]
\end_layout

\end_inset

.
 Otherwise, we would get an infinite loop in type recursion
\begin_inset Index idx
status open

\begin_layout Plain Layout
infinite loop in type recursion
\end_layout

\end_inset

 (similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case class Bad
\end_layout

\end_inset

 shown before).
\end_layout

\begin_layout Standard
Since we obtained the definition of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 via a trick, let us verify that the code actually defines the disjunctive
 type we wanted.
 
\end_layout

\begin_layout Standard
To create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

, we must use one of the two available case classes.
 Using the first case class, we may create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List0()
\end_layout

\end_inset

.
 Since this empty case class does not contain any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, it effectively represents an empty list (the base case of the induction).
 Using the second case class, we may create a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN(x, next)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

 is an already constructed value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

.
 This represents the inductive step because the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN
\end_layout

\end_inset

 is a named tuple containing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

.
 Now, the same consideration recursively applies to constructing the value
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next
\end_layout

\end_inset

, which must be either an empty list or a pair containing a value of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and another list.
 The assumption that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

next: ListI[A]
\end_layout

\end_inset

 is already constructed is equivalent to the inductive assumption that we
 already have a list of a previously defined length.
 So, we have verified that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI[A]
\end_layout

\end_inset

 implements the inductive definition shown above.
\end_layout

\begin_layout Standard
Examples of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListI
\end_layout

\end_inset

 are the empty list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List0()
\end_layout

\end_inset

, a one-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN(x, List0())
\end_layout

\end_inset

, and a two-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListN(x, ListN(y, List0())
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To illustrate writing pattern-matching code using this type, let us implement
 the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def headOption[A]: ListI[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case List0()          => None
\end_layout

\begin_layout Plain Layout

  case ListN(x, next)   => Some(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Scala library  defines the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 in a  different way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait List[A]
\end_layout

\begin_layout Plain Layout

final case object Nil extends List[Nothing]
\end_layout

\begin_layout Plain Layout

final case class ::[A](head: A, tail: List[A]) extends List[A]
\end_layout

\end_inset

Because 
\begin_inset Quotes eld
\end_inset

operator-like
\begin_inset Quotes erd
\end_inset

 case class names, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::
\end_layout

\end_inset

, support the infix syntax, we may write expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head :: tail
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::(head, tail)
\end_layout

\end_inset

.
 This syntax can be also used in pattern matching on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 values, with code that looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def headOption[A]: List[A] => Option[A] = {
\end_layout

\begin_layout Plain Layout

  case Nil            => None
\end_layout

\begin_layout Plain Layout

  case head :: tail   => Some(head)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Examples of values created using Scala's standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type are the empty list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

, a one-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x :: Nil
\end_layout

\end_inset

, and a two-element list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x :: y :: Nil
\end_layout

\end_inset

.
 The same syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x :: y :: Nil
\end_layout

\end_inset

 is used both for creating values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 and for pattern matching on such values.
 
\end_layout

\begin_layout Standard
The Scala library also defines the helper function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List()
\end_layout

\end_inset

, so that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List()
\end_layout

\end_inset

 is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 2, 3)
\end_layout

\end_inset

 is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 :: 2 :: 3 :: Nil
\end_layout

\end_inset

.
 Lists are easier to read in the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 2, 3)
\end_layout

\end_inset

.
 Pattern matching may also use that syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: List[Int] = List(1, 2, 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x match {
\end_layout

\begin_layout Plain Layout

  case List(a)         => ...
\end_layout

\begin_layout Plain Layout

  case List(a, b, c)   => ...
\end_layout

\begin_layout Plain Layout

  case _               => ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tail recursion with 
\family typewriter
List
\family default

\begin_inset CommandInset label
LatexCommand label
name "subsec:Tail-recursion-with-list"

\end_inset


\end_layout

\begin_layout Standard
Because the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type is defined by induction, it is straightforward to implement iterative
 computations with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type using recursion.
\end_layout

\begin_layout Standard
A first example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function.
 We use reasoning by induction in order to figure out the implementation
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 The required type signature is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] = ???
\end_layout

\end_inset

The base case is an empty list, and we return again an empty list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
\end_layout

\begin_layout Plain Layout

  case Nil => Nil
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\end_inset

In the inductive step, we have a pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(head, tail)
\end_layout

\end_inset

 in the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

::
\end_layout

\end_inset

, with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail: List[A]
\end_layout

\end_inset

.
 The pair can be pattern-matched with the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head :: tail
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function should apply the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the head value, which will give the first element of the resulting list.
 The remaining elements are computed by the induction assumption, i.e., by
 a recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] = xs match {
\end_layout

\begin_layout Plain Layout

  case Nil           => Nil
\end_layout

\begin_layout Plain Layout

  case head :: tail  => f(head) :: map(tail)(f)
\end_layout

\end_inset

While this implementation is straightforward and concise, it is not tail-recursi
ve.
 This will be a problem for large enough lists.
\end_layout

\begin_layout Standard
To resolve this issue, let us implement a tail-recursive 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, because many methods can be expressed via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 The required type signature is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R = ???
\end_layout

\end_inset

Reasoning by induction, we start with the base case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs == Nil
\end_layout

\end_inset

, where the only possibility is to return the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R = xs match {
\end_layout

\begin_layout Plain Layout

    case Nil            => init
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\end_inset

The inductive step for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 says that, given the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail: List[A]
\end_layout

\end_inset

, we need to apply the updater function to the previous accumulator value.
 That value is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

init
\end_layout

\end_inset

.
 So, we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 recursively to the tail of the list once we have the updated accumulator
 value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def foldLeft[A, R](xs: List[A])(init: R)(f: (R, A) => R): R =
\end_layout

\begin_layout Plain Layout

  xs match {
\end_layout

\begin_layout Plain Layout

    case Nil            => init
\end_layout

\begin_layout Plain Layout

    case head :: tail   => 
\end_layout

\begin_layout Plain Layout

      val newInit = f(init, head) // Update the accumulator.
\end_layout

\begin_layout Plain Layout

      foldLeft(tail)(newInit)(f)  // Recursive call to `foldLeft`.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

This implementation is tail-recursive because the recursive call to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 is the last expression returned in a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 branch.
\end_layout

\begin_layout Standard
Another example is a function for reversing a list.
 The Scala library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

 method for this task, but we will show an implementation using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

.
 The updater function 
\emph on
prepends
\emph default
 an element to a previous list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[A](xs: List[A]): List[A] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Nil: List[A])((prev, x) => x :: prev)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reverse(List(1, 2, 3))
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(3, 2, 1) 
\end_layout

\end_inset

Without the explicit type annotation (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil: List[A]
\end_layout

\end_inset

), the Scala compiler will decide that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Nothing]
\end_layout

\end_inset

, and the types will not match later in the code.
 In Scala, the initial value for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 often needs an explicit type annotation.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

 function can be used to obtain a tail-recursive implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 The idea is to first use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to accumulate transformed elements:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(1, 2, 3).foldLeft(Nil:List[Int])((prev, x) => (x * x) :: prev)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(9, 4, 1)
\end_layout

\end_inset

To obtain the correct result (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 4, 9)
\end_layout

\end_inset

), it remains to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: List[A])(f: A => B): List[B] =
\end_layout

\begin_layout Plain Layout

  xs.foldLeft(Nil: List[B])((prev, x) => f(x) :: prev).reverse
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> map(List(1, 2, 3))(x => x * x)
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(1, 4, 9)
\end_layout

\end_inset

This achieves stack safety at the cost of traversing the list twice.
 (This code is shown only as an example.
 The Scala library implements 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 using mutable variables to improve performance.)
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-non-empty-list-foldLeft"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-non-empty-list-foldLeft"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A definition of the 
\series bold
non-empty list
\begin_inset Index idx
status open

\begin_layout Plain Layout
non-empty list
\end_layout

\end_inset


\series default
 is similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 except that the empty-list case is replaced by a 
\begin_inset Formula $1$
\end_inset

-element case:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait NEL[A]
\end_layout

\begin_layout Plain Layout

final case class Last[A](head: A)                 extends NEL[A]
\end_layout

\begin_layout Plain Layout

final case class More[A](head: A, tail: NEL[A])   extends NEL[A]
\end_layout

\end_inset

Values of a non-empty list look like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val xs: NEL[Int] = More(1, More(2, Last(3)))  // [1, 2, 3]
\end_layout

\begin_layout Plain Layout

xs: NEL[Int] = More(1,More(2,Last(3)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val ys: NEL[String] = Last("abc") // One element, [
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

].
\end_layout

\begin_layout Plain Layout

ys: NEL[String] = Last(abc)
\end_layout

\end_inset

To create non-empty lists more easily, we implement a conversion function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toNEL
\end_layout

\end_inset

 from an ordinary list.
 To guarantee that a non-empty list can be created, we give 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toNEL
\end_layout

\end_inset

 
\emph on
two
\emph default
 arguments:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toNEL[A](x: A, rest: List[A]): NEL[A] = rest match {
\end_layout

\begin_layout Plain Layout

  case Nil         => Last(x)
\end_layout

\begin_layout Plain Layout

  case y :: tail   => More(x, toNEL(y, tail))
\end_layout

\begin_layout Plain Layout

}   // Not tail-recursive: `toNEL()` is used inside `More(...)`.
\end_layout

\end_inset

To test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> toNEL(1, List()) // Result = [1].
\end_layout

\begin_layout Plain Layout

res0: NEL[Int] = Last(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toNEL(1, List(2, 3)) // Result = [1, 2, 3].
\end_layout

\begin_layout Plain Layout

res1: NEL[Int] = More(1,More(2,Last(3)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 method is safe for non-empty lists, unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 for an ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def head[A]: NEL[A] => A = {
\end_layout

\begin_layout Plain Layout

  case Last(x)        => x
\end_layout

\begin_layout Plain Layout

  case More(x, _)     => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can also implement a tail-recursive 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 function for non-empty lists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def foldLeft[A, R](n: NEL[A])(init: R)(f: (R, A) => R): R = n match
 {
\end_layout

\begin_layout Plain Layout

  case Last(x)        => f(init, x)
\end_layout

\begin_layout Plain Layout

  case More(x, tail)  => foldLeft(tail)(f(init, x))(f)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(More(1, More(2, Last(3))))(0)(_ + _)
\end_layout

\begin_layout Plain Layout

res2: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-non-empty-list"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-non-empty-list"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

 function for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[A]: NEL[A] => NEL[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reverse(toNEL(10, List(20, 30))) // The result must be [30, 20, 10].
\end_layout

\begin_layout Plain Layout

res3: NEL[Int] = More(30,More(20,Last(10)))
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 to build up the reversed list as the accumulator value.
 It remains to choose the initial value of the accumulator and the updater
 function.
 We have already seen the code for reversing the ordinary list via the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 method:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[A](xs: List[A]): List[A] = xs.foldLeft(Nil: List[A])((prev,x)
 => x :: prev)
\end_layout

\end_inset

However, we cannot reuse the same code for non-empty lists by writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

More(x, prev)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x :: prev
\end_layout

\end_inset

, because the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 operation works with non-empty lists differently.
 Since lists are always non-empty, the updater function is always applied
 to an initial value, and the code works incorrectly:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[A](xs: NEL[A]): NEL[A] =
\end_layout

\begin_layout Plain Layout

  foldLeft(xs)(Last(head(xs)): NEL[A])((prev,x) => More(x, prev))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reverse(toNEL(10, List(20, 30))) // The result is [30, 20, 10, 10].
\end_layout

\begin_layout Plain Layout

res4: NEL[Int] = More(30,More(20,More(10,Last(10))))
\end_layout

\end_inset

The last element, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, should not have been repeated.
 It was repeated because the initial accumulator value already contained
 the head element 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

 of the original list.
 However, we cannot set the initial accumulator value to an empty list,
 since a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL[A]
\end_layout

\end_inset

 must be non-empty.
 It seems that we need to handle the case of a one-element list separately.
 So, we begin by matching on the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse
\end_layout

\end_inset

, and apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 only when the list is longer than 
\begin_inset Formula $1$
\end_inset

 element:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[A]: NEL[A] => NEL[A] = {
\end_layout

\begin_layout Plain Layout

  case Last(x)         => Last(x)    // `reverse` is a no-op.
\end_layout

\begin_layout Plain Layout

  case More(x, tail)   =>            // Use foldLeft on `tail`.
\end_layout

\begin_layout Plain Layout

    foldLeft(tail)(Last(x): NEL[A])((prev, x) => More(x, prev))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> reverse(toNEL(10, List(20, 30))) // The result is [30, 20, 10].
\end_layout

\begin_layout Plain Layout

res5: NEL[Int] = More(30,More(20,Last(10)))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-non-empty-list-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-non-empty-list-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toList
\end_layout

\end_inset

 that converts a non-empty list into an ordinary Scala 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
 The required type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def toList[A](nel: NEL[A]): List[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> toList(More(1, More(2, Last(3)))) // This is [1, 2, 3].
\end_layout

\begin_layout Plain Layout

res6: List[Int] = List(1, 2, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-map-for-NEL"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-map-for-NEL"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

.
 Type signature and a sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mapNEL[A,B](xs: NEL[A])(f: A => B): NEL[B] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> mapNEL[Int, Int](toNEL(10, List(20, 30)))(_ + 5)
\end_layout

\begin_layout Plain Layout

res7: NEL[Int] = More(15,More(25,Last(35)))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-non-empty-list-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-non-empty-list-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function that concatenates two non-empty lists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def concatNEL[A](xs: NEL[A], ys: NEL[A]): NEL[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> concatNEL(More(1, More(2, Last(3))), More(4, Last(5)))
\end_layout

\begin_layout Plain Layout

res8: NEL[Int] = More(1,More(2,More(3,More(4,Last(5)))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-non-empty-list-2-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-non-empty-list-2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 for non-empty lists:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flattenNEL[A](xs: NEL[Nel[A]]): NEL[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> flattenNEL(More(More(1, Last(2)), More(More(3, Last(4)), Last(More(5,
 Last(6))))))
\end_layout

\begin_layout Plain Layout

res9: NEL[Int] = More(1,More(2,More(3,More(4,More(5,Last(6))))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binary trees
\begin_inset CommandInset label
LatexCommand label
name "subsec:Binary-trees"

\end_inset


\end_layout

\begin_layout Standard
We will consider four kinds of trees defined as recursive disjunctive types:
 binary trees, rose trees, perfect-shaped trees, and abstract syntax trees.
\end_layout

\begin_layout Standard
The diagrams 
\size tiny

\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] ]  [ $a_3$ ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\size default
 and 
\size small

\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\size default
 (where 
\begin_inset Formula $a_{1}$
\end_inset

, ..., 
\begin_inset Formula $a_{5}$
\end_inset

 are some values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

) are examples of 
\series bold
binary trees
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
binary tree
\end_layout

\end_inset


\series default
 with leaves of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
An inductive definition says that a binary tree is either a leaf with a
 value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 or a branch containing 
\emph on
two
\emph default
 previously defined binary trees.
 Translating this definition into code, we get:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Tree2[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](a: A)                         extends Tree2[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](x: Tree2[A], y: Tree2[A])   extends Tree2[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here are some examples of code expressions and the corresponding trees:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "73col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Branch(Branch(Leaf("a1"), Leaf("a2")), Leaf("a3"))
\end_layout

\end_inset


\begin_inset VSpace 140baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 40baselineskip%
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset


\size tiny

\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] ]  [ $a_3$ ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "73col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -40baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Branch(Branch(Leaf(
\begin_inset Quotes eld
\end_inset

a1
\begin_inset Quotes erd
\end_inset

), Branch(Leaf(
\begin_inset Quotes eld
\end_inset

a2
\begin_inset Quotes erd
\end_inset

), Leaf(
\begin_inset Quotes eld
\end_inset

a3
\begin_inset Quotes erd
\end_inset

))),
\end_layout

\begin_layout Plain Layout

  Branch(Leaf(
\begin_inset Quotes eld
\end_inset

a4
\begin_inset Quotes erd
\end_inset

), Leaf(
\begin_inset Quotes eld
\end_inset

a5
\begin_inset Quotes erd
\end_inset

)))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 110baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 30baselineskip%
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ [ $a_4$ ] [ $a_5$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Recursive functions on trees are translated into concise code.
 For instance, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for trees of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tree2
\end_layout

\end_inset

 is implemented as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](t: Tree2[A])(init: R)(f: (R, A) => R): R = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(a)          => f(init, a)
\end_layout

\begin_layout Plain Layout

  case Branch(t1, t2)   =>
\end_layout

\begin_layout Plain Layout

    val r1 = foldLeft(t1)(init)(f)   // Fold the left branch and obtain
 the result `r1`.
\end_layout

\begin_layout Plain Layout

    foldLeft(t2)(r1)(f)              // Using `r1` as the `init` value,
 fold the right branch.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Note that this function 
\emph on
cannot
\emph default
 be made tail-recursive using the accumulator trick, because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 needs to call itself twice in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 case.
 
\end_layout

\begin_layout Standard
To verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 works as intended, let us run a simple test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val t: Tree2[String] = Branch(Branch(Leaf("a1"), Leaf("a2")), Leaf("a3"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(t)(
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

)(_ + 
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

 + _)
\end_layout

\begin_layout Plain Layout

res0: String = " a1 a2 a3"
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rose trees
\begin_inset CommandInset label
LatexCommand label
name "subsec:Rose-trees"

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
rose tree
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
rose tree
\end_layout

\end_inset

 is similar to the binary tree except the branches contain a non-empty list
 of trees.
 Because of that, a rose tree can fork into arbitrarily many branches at
 each node, rather than always into two branches as the binary tree does.
 Some examples of rose trees are 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] [ $a_3$ ] ] [ [ $a_4$ ] [ $a_5$ ] [ $a_6$ ]
 ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 and 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] [ $a_4$ ] [ $a_5$ ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 .
\end_layout

\begin_layout Standard
A possible definition of a data type for the rose tree is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait TreeN[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](a: A)                  extends TreeN[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](ts: NEL[TreeN[A]])   extends TreeN[A]
\end_layout

\end_inset

Since we used a non-empty list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch()
\end_layout

\end_inset

 value is guaranteed to have at least one branch.
 If we used an ordinary 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 instead, we could (by mistake) create a tree with empty branches.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-foldLeft-rose-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-foldLeft-rose-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Define the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for a rose tree of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TreeN[A]
\end_layout

\end_inset

 shown above.
 Assume that a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 function is already available for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NEL
\end_layout

\end_inset

.
 The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foldLeft[A, R](t: TreeN[A])(init: R)(f: (R, A) => R): R = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(Branch(More(Leaf(1), More(Leaf(2), Last(Leaf(3))))))(0)(_
 + _)
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Perfect-shaped trees
\begin_inset CommandInset label
LatexCommand label
name "subsec:Perfect-shaped-trees"

\end_inset


\end_layout

\begin_layout Standard
Binary trees and rose trees may choose to branch or not to branch at any
 given node, resulting in structures that may have different branching depths
 at different nodes, such as 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ [ $a_2$ ] [ $a_3$ ] ] ] [ $a_4$ ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

.
 A 
\series bold
perfect-shaped tree
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
perfect-shaped tree
\end_layout

\end_inset

 always branches in the same way at every node until a chosen total depth.
 As an example, consider the tree 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 where all nodes at depth 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 always branch into two, while all nodes at depth 
\begin_inset Formula $2$
\end_inset

 are leaves (do not branch).
 The branching number is fixed for a given type of a perfect-shaped tree;
 in this example, the branching number is 
\begin_inset Formula $2$
\end_inset

, so it is a perfect-shaped 
\emph on
binary
\emph default
 tree.
\end_layout

\begin_layout Standard
How can we define a data type representing a perfect-shaped binary tree?
 We need a type that is either a single value, or a pair of values, or a
 pair of pairs, etc.
 Begin with the non-recursive (but, of course, impractical) definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](x: A)                     extends PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch1[A](xs: (A, A))            extends PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch2[A](xs: ((A, A),(A, A)))   extends PTree[A]
\end_layout

\begin_layout Plain Layout

???                          // Need an infinitely long definition.
\end_layout

\end_inset

The case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch1
\end_layout

\end_inset

 describes a perfect-shaped tree with total depth 
\begin_inset Formula $1$
\end_inset

, the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch2
\end_layout

\end_inset

 has total depth 
\begin_inset Formula $2$
\end_inset

, and so on.
 The non-trivial step is to notice that each case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset


\begin_inset Formula $_{n}$
\end_inset

 uses the previous case class's data structure with the 
\emph on
type parameter
\emph default
 set to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 So, we can rewrite the above definition as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](x: A)                     extends PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch1[A](xs: Leaf[(A, A)])      extends PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch2[A](xs: Branch1[(A, A)])   extends PTree[A]
\end_layout

\begin_layout Plain Layout

???                          // Need an infinitely long definition.
\end_layout

\end_inset

We can now apply the type recursion trick: replace the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset


\begin_inset Formula $_{n-1}$
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[(A, A)]
\end_layout

\end_inset

 in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset


\begin_inset Formula $_{n}$
\end_inset

 by the recursively used type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[(A, A)]
\end_layout

\end_inset

.
 Now we can define a perfect-shaped binary tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](x: A)                  extends PTree[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](xs: PTree[(A, A)])   extends PTree[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since we used some tricks to figure out the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[A]
\end_layout

\end_inset

, let us verify that this definition actually describes the recursive disjunctiv
e type we wanted.
 The only way to create a structure of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[A]
\end_layout

\end_inset

 is to create a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf[A]
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch[A]
\end_layout

\end_inset

.
 A value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf[A]
\end_layout

\end_inset

 is itself a perfect-shaped tree.
 It remains to consider the case of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch[A]
\end_layout

\end_inset

.
 Creating a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch[A]
\end_layout

\end_inset

 requires a previously created 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree
\end_layout

\end_inset

 with values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 By the inductive assumption, the previously created 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[A]
\end_layout

\end_inset

 would have the correct shape.
 Now, it is clear that if we replace the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 by the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

, a perfect-shaped tree such as 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[ [ [ $a_1$ ] [ $a_2$ ] ] [ [ $a_3$ ] [ $a_4$ ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

 is replaced by 
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Tree[ [ [ [ $a_1^{'}$ ] [ $a_1^{"}$ ] ] [ [ $a_2^{'}$ ] [ $a_2^{"}$ ] ]
 ] [ [ [ $a_3^{'}$ ] [ $a_3^{"}$ ] ] [ [ $a_4^{'}$ ] [ $a_4^{"}$ ] ] ] ]
 
\end_layout

\end_inset


\end_layout

\end_inset

 (each leaf value 
\begin_inset Formula $a_{i}$
\end_inset

 became a pair 
\begin_inset Formula $a_{i}^{'},a_{i}^{"}$
\end_inset

).
 That tree is again perfect-shaped but is one level deeper.
 We see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[A]
\end_layout

\end_inset

 is a correct definition of a perfect-shaped binary tree.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Example-map-regular-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-map-regular-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Define a (non-tail-recursive) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for a perfect-shaped binary tree.
 The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: PTree[A])(f: A => B): PTree[B] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> map(Branch(Branch(Leaf(((1, 2), (3, 4))))))(_ * 10)
\end_layout

\begin_layout Plain Layout

res0: PTree[Int] = Branch(Branch(Leaf(((10,20),(30,40)))))
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern matching on the tree:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: PTree[A])(f: A => B): PTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => ???
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the base case, we have no choice but to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf(f(x))
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: PTree[A])(f: A => B): PTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => Leaf(f(x))
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inductive step, we are given a previous tree value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs: PTree[(A, A)]
\end_layout

\end_inset

.
 It is clear that we need to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 recursively to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

.
 Let us try:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: PTree[A])(f: A => B): PTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => Leaf(f(x))
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => Branch(map(xs)(f))    // Type error!
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(xs)(f)
\end_layout

\end_inset

 has an incorrect type of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree[(A, A)]
\end_layout

\end_inset

, the recursive call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(xs)(f)
\end_layout

\end_inset

 requires 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, A)) => (B, B)
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

.
 So, we need to provide a function of the correct type instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 A function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, A)) => (B, B)
\end_layout

\end_inset

 will be obtained out of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 if we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each part of the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A)
\end_layout

\end_inset

.
 The code for that function is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case (x, y) => (f(x), f(y)) }
\end_layout

\end_inset

.
 Therefore, we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](t: PTree[A])(f: A => B): PTree[B] = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)      => Leaf(f(x))
\end_layout

\begin_layout Plain Layout

  case Branch(xs)   => Branch(map(xs){ case (x, y) => (f(x), f(y)) })
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code is not tail-recursive since it calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

map
\end_layout

\end_inset

 inside an expression.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-foldLeft-regular-tree-depth"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using tail recursion, compute the depth of a perfect-shaped binary tree
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree
\end_layout

\end_inset

.
 (An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PTree
\end_layout

\end_inset

 of depth 
\begin_inset Formula $n$
\end_inset

 has 
\begin_inset Formula $2^{n}$
\end_inset

 leaf values.) The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def depth[A](t: PTree[A]): Int = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> depth(Branch(Branch(Leaf((("a","b"),("c","d"))))))
\end_layout

\begin_layout Plain Layout

res2: Int = 2
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def depth[A](t: PTree[A], acc: Int = 0): Int = t match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)    => acc
\end_layout

\begin_layout Plain Layout

  case Branch(xs) => depth(xs, acc + 1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctive-Exercise-foldLeft-regular-tree"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Exercise-foldLeft-regular-tree"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a tail-recursive function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for a perfect-shaped binary tree.
 The required type signature and a test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def foldLeft[A, R](t: PTree[A])(init: R)(f: (R, A) => R): R = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(Branch(Branch(Leaf(((1, 2), (3, 4))))))(0)(_ + _)
\end_layout

\begin_layout Plain Layout

res0: Int = 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> foldLeft(Branch(Branch(Leaf((("a", "b"), ("c", "d"))))))("")(_ +
 _)
\end_layout

\begin_layout Plain Layout

res1: String = abcd
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def foldLeft[A, R](t: PTree[A])(init: R)(f: (R, A) => R): R = t
 match {
\end_layout

\begin_layout Plain Layout

  case Leaf(x)    => f(init, x)
\end_layout

\begin_layout Plain Layout

  case Branch(xs) => foldLeft(xs)(init) { case (r, (a, b)) => f(f(r, a),
 b) } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Abstract syntax trees
\end_layout

\begin_layout Standard
Expressions in formal languages are represented by abstract syntax trees.
 An 
\series bold
abstract syntax tree
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
abstract syntax tree
\end_layout

\end_inset


\series bold
 
\series default
(or 
\series bold
AST
\series default
 for short) is defined as either a leaf of one of the available leaf types,
 or a branch of one of the available branch types.
 All the available leaf and branch types must be specified as part of the
 definition of an AST.
 In other words, one must specify the data carried by leaves and branches,
 as well as the branching numbers.
\end_layout

\begin_layout Standard
To illustrate how ASTs are used, let us rewrite Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

 via an AST.
 We view Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a small sub-language that deals with 
\begin_inset Quotes eld
\end_inset

safe integers
\begin_inset Quotes erd
\end_inset

 and supports the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sqrt
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mul
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Div
\end_layout

\end_inset

.
 Example calculations in this sub-language are 
\begin_inset Formula $\sqrt{16}*(1+2)=12$
\end_inset

; 
\begin_inset Formula $20+1/0=\text{error}$
\end_inset

; and 
\begin_inset Formula $10+\sqrt{-1}=\text{error}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We can implement this sub-language in two stages.
 The first stage will create a data structure (an AST) that represents an
 unevaluated expression
\begin_inset Index idx
status open

\begin_layout Plain Layout
unevaluated expression
\end_layout

\end_inset

 in the sub-language.
 The second stage will evaluate that AST to obtain either a number or an
 error message.
\end_layout

\begin_layout Standard
A straightforward way of defining the data structure for the AST is to use
 a disjunctive type whose parts describe all the possible operations of
 the sub-language.
 We will need one case class for each of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sqrt
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mul
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Div
\end_layout

\end_inset

.
 An additional operation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Num
\end_layout

\end_inset

, will lift ordinary integers into 
\begin_inset Quotes eld
\end_inset

safe integers
\begin_inset Quotes erd
\end_inset

.
 So, we define the disjunctive type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

) for the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 sub-language as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Arith
\end_layout

\begin_layout Plain Layout

final case class Num(x: Int)               extends Arith
\end_layout

\begin_layout Plain Layout

final case class Sqrt(x: Arith)            extends Arith
\end_layout

\begin_layout Plain Layout

final case class Add(x: Arith, y: Arith)   extends Arith
\end_layout

\begin_layout Plain Layout

final case class Mul(x: Arith, y: Arith)   extends Arith
\end_layout

\begin_layout Plain Layout

final case class Div(x: Arith, y: Arith)   extends Arith
\end_layout

\end_inset

A value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

 is either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Num(x)
\end_layout

\end_inset

 for some integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, or an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add(x, y)
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 are previously defined 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

 expressions, or another operation.
\end_layout

\begin_layout Standard
This type definition is similar to the binary tree type if we rename 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Leaf
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Num
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Branch
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Tree
\end_layout

\begin_layout Plain Layout

final case class Leaf(x: Int)               extends Tree
\end_layout

\begin_layout Plain Layout

final case class Branch(x: Tree, y: Tree)   extends Tree
\end_layout

\end_inset

However, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

 type is a tree that supports four different types of branches, some with
 branching number 
\begin_inset Formula $1$
\end_inset

 and others with branching number 
\begin_inset Formula $2$
\end_inset

.
 
\end_layout

\begin_layout Standard
This example illustrates the structure of an AST: it is a tree of a specific
 shape, with leaves and branches chosen from a specified set of allowed
 possibilities.
 In the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

 example, we have a single allowed type of leaf (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Num
\end_layout

\end_inset

) and four allowed types of branches (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sqrt
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Add
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Mul
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Div
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
This completes the first stage of implementing the sub-language.
 We may now use the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Arith
\end_layout

\end_inset

 to create expressions in the sub-language.
 For example, 
\begin_inset Formula $\sqrt{16}*(1+2)$
\end_inset

 is represented by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: Arith = Mul(Sqrt(Num(16)), Add(Num(1), Num(2)))
\end_layout

\begin_layout Plain Layout

x: Arith = Mul(Sqrt(Num(16)),Add(Num(1),Num(2))) 
\end_layout

\end_inset

We can visualize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as the abstract syntax tree
\begin_inset Preview

\begin_layout Standard

\size tiny
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
Tree[.
\backslash
texttt{Mul} [.
\backslash
texttt{Sqrt} [.
\backslash
texttt{Num} $16$ ] ] [.
\backslash
texttt{Add} [ [.
\backslash
texttt{Num} [ $1$ ] ] [.
\backslash
texttt{Num} [ $2$ ] ] ] ] ] 
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The expressions 
\begin_inset Formula $20+1/0$
\end_inset

 and 
\begin_inset Formula $10*\sqrt{-1}$
\end_inset

 are represented by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val y: Arith = Add(Num(20), Div(Num(1), Num(0)))
\end_layout

\begin_layout Plain Layout

y: Arith = Add(Num(20),Div(Num(1),Num(0)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val z: Arith = Mul(Num(10), Sqrt(Num(-1)))
\end_layout

\begin_layout Plain Layout

z: Arith = Mul(Num(10),Sqrt(Num(-1)))
\end_layout

\end_inset

As we see, the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 
\emph on
remain
\emph default
 
\emph on
unevaluated
\emph default
; each of them is a data structure that encodes a tree of operations of
 the sub-language.
 These operations will be evaluated at the second stage of implementing
 the sub-language.
\end_layout

\begin_layout Standard
To evaluate expressions in the 
\begin_inset Quotes eld
\end_inset

safe arithmetic
\begin_inset Quotes erd
\end_inset

, we can implement a function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run: Arith => Either[String, Int]
\end_layout

\end_inset

.
 That function plays the role of an 
\series bold
interpreter
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
interpreter
\end_layout

\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\series bold
runner
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
runner
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 for programs written in the sub-language.
 The runner will walk through the expression tree and execute all the operations
, taking care of possible errors.
 
\end_layout

\begin_layout Standard
To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

run
\end_layout

\end_inset

, we need to define the required arithmetic operations on the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[String, Int]
\end_layout

\end_inset

.
 For instance, we need to be able to add or multiply values of that type.
 Instead of custom code from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-resultA"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we can use the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods defined on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

.
 For example, addition and multiplication of two 
\begin_inset Quotes eld
\end_inset

safe integers
\begin_inset Quotes erd
\end_inset

 is implemented as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add(x: Either[String, Int], y: Either[String, Int]):
\end_layout

\begin_layout Plain Layout

    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 + r2) }
\end_layout

\begin_layout Plain Layout

def mul(x: Either[String, Int], y: Either[String, Int]):
\end_layout

\begin_layout Plain Layout

    Either[String, Int] = x.flatMap { r1 => y.map(r2 => r1 * r2) }
\end_layout

\end_inset

The code for the 
\begin_inset Quotes eld
\end_inset

safe division
\begin_inset Quotes erd
\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def div(x: Either[String, Int], y: Either[String, Int]): Either[String,
 Int] =
\end_layout

\begin_layout Plain Layout

  x.flatMap { r1 => y.flatMap { r2 =>
\end_layout

\begin_layout Plain Layout

      if (r2 == 0) Left(s
\begin_inset Quotes eld
\end_inset

error: $r1 / $r2
\begin_inset Quotes erd
\end_inset

) else Right(r1 / r2)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

With this code, we can implement the runner as a recursive function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def run: Arith => Either[String, Int] = {
\end_layout

\begin_layout Plain Layout

  case Num(x)     => Right(x)
\end_layout

\begin_layout Plain Layout

  case Sqrt(x)    => run(x).flatMap { r =>
\end_layout

\begin_layout Plain Layout

    if (r < 0) Left(s
\begin_inset Quotes eld
\end_inset

error: sqrt($r)
\begin_inset Quotes erd
\end_inset

) else Right(math.sqrt(r).toInt)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  case Add(x, y)  => add(run(x), run(y))
\end_layout

\begin_layout Plain Layout

  case Mul(x, y)  => mul(run(x), run(y))
\end_layout

\begin_layout Plain Layout

  case Div(x, y)  => div(run(x), run(y))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test it with the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 defined previously:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> run(x)
\end_layout

\begin_layout Plain Layout

res0: Either[String, Int] = Right(12)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> run(y)
\end_layout

\begin_layout Plain Layout

res1: Either[String, Int] = Left("error: 1 / 0")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> run(z)
\end_layout

\begin_layout Plain Layout

res2: Either[String, Int] = Left("error: sqrt(-1)")
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What problems can we solve now?
\end_layout

\begin_layout Itemize
Represent values from a disjoint domain by a custom disjunctive type.
\end_layout

\begin_layout Itemize
Use disjunctive types instead of exceptions to indicate failures.
\end_layout

\begin_layout Itemize
Use standard disjunctive types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

 and their methods.
\end_layout

\begin_layout Itemize
Define recursive disjunctive types (such as lists and trees) and implement
 recursive functions that work with them.
\end_layout

\begin_layout Standard
The following examples and exercises illustrate these tasks.
\end_layout

\begin_layout Subsection
Examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

DayOfWeek
\end_layout

\end_inset

 representing the seven days of a week.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Since each day carries no information except the day's name, we can use
 empty case classes and represent the day's name via the name of the case
 class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Sunday()    extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Monday()    extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Tuesday()   extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Wednesday() extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Thursday()  extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Friday()    extends DayOfWeek
\end_layout

\begin_layout Plain Layout

final case class Saturday()  extends DayOfWeek
\end_layout

\end_inset

This data type is analogous to an enumeration type
\begin_inset Index idx
status open

\begin_layout Plain Layout
enumeration type
\end_layout

\end_inset

 in C or C++:
\begin_inset listings
lstparams "language={C++}"
inline false
status open

\begin_layout Plain Layout

typedef enum { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
 } DayOfWeek;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Modify 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

DayOfWeek
\end_layout

\end_inset

 so that on Fridays the values additionally represent names of restaurants
 and amounts paid, and on Saturdays a wake-up time.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
For the days where additional information is given, we use non-empty case
 classes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait DayOfWeekX
\end_layout

\begin_layout Plain Layout

final case class Sunday()                                extends DayOfWeekX
\end_layout

\begin_layout Plain Layout

final case class Monday()                                extends DayOfWeekX
\end_layout

\begin_layout Plain Layout

final case class Tuesday()                               extends DayOfWeekX
\end_layout

\begin_layout Plain Layout

final case class Wednesday()                             extends DayOfWeekX
\end_layout

\begin_layout Plain Layout

final case class Thursday()                              extends DayOfWeekX
\end_layout

\begin_layout Plain Layout

final case class Friday(restaurant: String, amount: Int) extends DayOfWeekX
\end_layout

\begin_layout Plain Layout

final case class Saturday(wakeUpAt: java.time.LocalTime) extends DayOfWeekX
\end_layout

\end_inset

This data type is no longer equivalent to an enumeration type.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:disj-Example-rootsofq-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type that describes the real roots of the equation
 
\begin_inset Formula $ax^{2}+bx+c=0$
\end_inset

, where 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 are arbitrary real numbers.
 Write a function that returns a value of that type and solves a given equation
 of the form 
\begin_inset Formula $ax^{2}+bx+c=0$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by solving the equation and enumerating all the possible cases.
 It may happen that 
\begin_inset Formula $a=b=c=0$
\end_inset

, and then all 
\begin_inset Formula $x$
\end_inset

 are roots.
 If 
\begin_inset Formula $a=b=0$
\end_inset

 but 
\begin_inset Formula $c\neq0$
\end_inset

, the equation is 
\begin_inset Formula $c=0$
\end_inset

, which has no roots.
 If 
\begin_inset Formula $a=0$
\end_inset

 but 
\begin_inset Formula $b\neq0$
\end_inset

, the equation becomes 
\begin_inset Formula $bx+c=0$
\end_inset

, having a single root.
 If 
\begin_inset Formula $a\neq0$
\end_inset

 and 
\begin_inset Formula $b^{2}>4ac$
\end_inset

, we have two distinct real roots.
 If 
\begin_inset Formula $a\neq0$
\end_inset

 and 
\begin_inset Formula $b^{2}=4ac$
\end_inset

, we have one real root.
 If 
\begin_inset Formula $b^{2}<4ac$
\end_inset

, we have no real roots.
 The resulting type definition can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class AllRoots()                      extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class ConstNoRoots()                  extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class Linear(x: Double)               extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class NoRealRoots()                   extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class OneRootQ(x: Double)             extends RootsOfQ2
\end_layout

\begin_layout Plain Layout

final case class TwoRootsQ(x: Double, y: Double) extends RootsOfQ2
\end_layout

\end_inset

This disjunctive type contains six parts: three parts are empty tuples and
 two parts are single-element tuples; but this is not a useless redundancy.
 We would lose information if we reused 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Linear
\end_layout

\end_inset

 for the two cases (
\begin_inset Formula $a=0$
\end_inset

, 
\begin_inset Formula $b\neq0$
\end_inset

) and (
\begin_inset Formula $a\neq0$
\end_inset

, 
\begin_inset Formula $b^{2}=4ac$
\end_inset

), or if we reused 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

 for all three different no-roots cases.
\end_layout

\begin_layout Standard
To solve a given equation, we need to decide which part of the disjunctive
 type to return.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solveQ2(a: Double, b: Double, c: Double) : RootsOfQ2 = (a, b, c) match
 {
\end_layout

\begin_layout Plain Layout

  case (0.0, 0.0, 0.0)   => AllRoots()
\end_layout

\begin_layout Plain Layout

  case (0.0, 0.0, _)     => NoRealRoots()
\end_layout

\begin_layout Plain Layout

  case (0.0, _, _)       => Linear(-c / b)
\end_layout

\begin_layout Plain Layout

  case _                 => // We match here only if `a` is nonzero.
\end_layout

\begin_layout Plain Layout

    val d = b * b - 4 * a * c
\end_layout

\begin_layout Plain Layout

    val p = - b / (2.0 * a)
\end_layout

\begin_layout Plain Layout

    if (d < 0.0) NoRealRoots()
\end_layout

\begin_layout Plain Layout

    else if (d == 0.0) OneRootQ(p)
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      val s = math.sqrt(d) / (2.0 * a)
\end_layout

\begin_layout Plain Layout

      TwoRootsQ(p - s, p + s)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Let us test this code with various input parameters:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> solveQ2(1, 1, 1)
\end_layout

\begin_layout Plain Layout

res0: RootsOfQ2 = NoRealRoots()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> solveQ2(1, 0, -4)
\end_layout

\begin_layout Plain Layout

res1: RootsOfQ2 = TwoRootsQ(-2.0, 2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rootAverage
\end_layout

\end_inset

 that computes the average value of all real roots of a general quadratic
 equation, where the set of roots is represented by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ2
\end_layout

\end_inset

 defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The required type signature is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = ???
\end_layout

\end_inset

Return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 if the average is undefined (no roots or all values are roots).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The average is defined only in cases 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Linear
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRootQ
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRootsQ
\end_layout

\end_inset

.
 In all other cases, we must return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 We implement this via pattern matching:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = roots => roots match {
\end_layout

\begin_layout Plain Layout

    case Linear(x)       => Some(x)
\end_layout

\begin_layout Plain Layout

    case OneRootQ(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

    case TwoRootsQ(x, y) => Some((x + y) * 0.5)
\end_layout

\begin_layout Plain Layout

    case _               => None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

We do not need to enumerate all other cases since the underscore (
\begin_inset Formula $\_$
\end_inset

) matches everything that the previous cases did not match.
\end_layout

\begin_layout Standard
In Scala, the often-used code pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x match { case ...
 => ...
 }
\end_layout

\end_inset

 can be shortened to just the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ case ...
 => ...
 }
\end_layout

\end_inset

.
 Then the code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val rootAverage: RootsOfQ2 => Option[Double] = {
\end_layout

\begin_layout Plain Layout

  case Linear(x)       => Some(x)
\end_layout

\begin_layout Plain Layout

  case OneRootQ(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

  case TwoRootsQ(x, y) => Some((x + y) * 0.5)
\end_layout

\begin_layout Plain Layout

  case _               => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Test it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Seq(NoRealRoots(), OneRootQ(1.0), TwoRootsQ(1.0, 2.0), AllRoots()).map(rootAv
erage)
\end_layout

\begin_layout Plain Layout

res0: Seq[Option[Double]] = List(None, Some(1.0), Some(1.5), None)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Generate 
\begin_inset Formula $100$
\end_inset

 quadratic equations 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

 with random coefficients 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 (uniformly distributed between 
\begin_inset Formula $-1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

) and compute the mean of the largest real roots from all these equations.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QEqu
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 function from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 A sequence of equations with random coefficients is created by applying
 the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq.fill
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def random(): Double = scala.util.Random.nextDouble() * 2 - 1
\end_layout

\begin_layout Plain Layout

val coeffs: Seq[QEqu] = Seq.fill(100)(QEqu(random(), random()))
\end_layout

\end_inset

Now we can use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve
\end_layout

\end_inset

 function to compute all roots:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val solutions: Seq[RootsOfQ] = coeffs.map(solve)
\end_layout

\end_inset

For each set of roots, compute the largest root:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val largest: Seq[Option[Double]] = solutions.map {
\end_layout

\begin_layout Plain Layout

  case OneRoot(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

  case TwoRoots(x, y) => Some(math.max(x, y))
\end_layout

\begin_layout Plain Layout

  case _              => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

largest: Seq[Option[Double]] = List(None, Some(0.9346072365885472), Some(1.1356234
869160806), Some(0.9453181931646322), Some(1.1595052441078866), None, Some(0.576225
2742788)...
\end_layout

\end_inset

It remains to remove the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 values and to compute the mean of the resulting sequence.
 The Scala library defines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 method that removes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

s and transforms 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Option[A]]
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> largest.flatten
\end_layout

\begin_layout Plain Layout

res0: Seq[Double] = List(0.9346072365885472, 1.1356234869160806, 0.9453181931646322
, 1.1595052441078866, 0.5762252742788...
\end_layout

\end_inset

Now compute the mean of the last sequence.
 Since the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 operation is preceded by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we can replace it by a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 The final code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val largest = Seq.fill(100)(QEqu(random(), random()))
\end_layout

\begin_layout Plain Layout

  .map(solve)
\end_layout

\begin_layout Plain Layout

  .flatMap {
\end_layout

\begin_layout Plain Layout

    case OneRoot(x)     => Some(x)
\end_layout

\begin_layout Plain Layout

    case TwoRoots(x, y) => Some(math.max(x, y))
\end_layout

\begin_layout Plain Layout

    case _              => None
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> largest.sum / largest.size
\end_layout

\begin_layout Plain Layout

res1: Double = 0.7682649774589514
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = ???
\end_layout

\end_inset

The function should preserve information as much as possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern matching on the argument:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None                     => ???
\end_layout

\begin_layout Plain Layout

  case Some(eab: Either[A, B])  => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In line 3, we wrote the 
\series bold
type annotation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type annotation
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eab: Either[A, B]
\end_layout

\end_inset

 only for clarity.
 It is not required here since the Scala compiler can deduce the type of
 the pattern variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eab
\end_layout

\end_inset

 from the fact that we are matching a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Either[A, B]]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In the scope of line 2, we need to return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 A value of that type must be either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: Option[B]
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(z)
\end_layout

\end_inset

 with a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z: B
\end_layout

\end_inset

.
 However, in our case the code is of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case None => ???
\end_layout

\end_inset

, and we cannot produce any values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z: B
\end_layout

\end_inset

 since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary, unknown types.
 The only remaining possibility is to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = None
\end_layout

\end_inset

, and so the code must be:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  case None => Right(None) // No other choice here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the next scope, we can perform pattern matching on the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

eab
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  case Some(eab: Either[A, B]) = eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a)   => ???
\end_layout

\begin_layout Plain Layout

    case Right(b)  => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It remains to figure out what expressions to write in each case.
 In the case 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a) => ???
\end_layout

\end_inset

, we have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, and we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 We use the same argument as before: The return value must be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(x)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(y)
\end_layout

\end_inset

 for some 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: Option[B]
\end_layout

\end_inset

.
 At this point, we have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 but no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 So, we have two possibilities: to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

.
 If we decide to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

, the code is:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None       => Right(None)  // No other choice here.
\end_layout

\begin_layout Plain Layout

  case Some(eab)  => eab match {
\end_layout

\begin_layout Plain Layout

    case Left(a)  => Left(a)      // Could return Right(None) here.
\end_layout

\begin_layout Plain Layout

    case Right(b) => ???
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Should we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 in line 4? Both choices will satisfy the required return type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

.
 However, if we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 in that line, we will ignore the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

, losing information.
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 So, we return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left(a)
\end_layout

\end_inset

 in line 4.
\end_layout

\begin_layout Standard
Similarly, we find in line 5 that we may return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(None)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right(Some(b))
\end_layout

\end_inset

.
 Both choices will have the required return type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, Option[B]]
\end_layout

\end_inset

), but the first choice ignores the given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

.
 To preserve information, we need to make the second choice:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None       => Right(None)
\end_layout

\begin_layout Plain Layout

  case Some(eab)  => eab match {
\end_layout

\begin_layout Plain Layout

      case Left(a)    => Left(a)
\end_layout

\begin_layout Plain Layout

      case Right(b)   => Right(Some(b))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now refactor this code into a somewhat more readable form by using
 nested patterns: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[Either[A, B]] => Either[A, Option[B]] = {
\end_layout

\begin_layout Plain Layout

  case None             => Right(None)
\end_layout

\begin_layout Plain Layout

  case Some(Left(a))    => Left(a)
\end_layout

\begin_layout Plain Layout

  case Some(Right(b))   => Right(Some(b))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-disjunctive-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function with the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = ???
\end_layout

\end_inset

The function should preserve information as much as possible.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by pattern matching on the argument:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => ???
\end_layout

\end_inset

In line 2, we have values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

, and we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(A, B)]
\end_layout

\end_inset

.
 A value of that type is either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((x, y))
\end_layout

\end_inset

 where we would need to choose some  
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: B
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary types, we cannot produce new values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 from scratch.
 The only way of obtaining 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 is to set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = a
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = b
\end_layout

\end_inset

.
 So, our choices are to return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((a, b))
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 We reject returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 since that would unnecessarily lose information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

.
 Thus, we continue writing code as:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case (Some(a), None)    => ???
\end_layout

\end_inset

In line 3, we have a value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 but no values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 As the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is arbitrary, we cannot produce any values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 to return a value of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some((x, y))
\end_layout

\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

None
\end_layout

\end_inset

 is the only computable value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[(A, B)]
\end_layout

\end_inset

 in line 3.
 We continue to write the code:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case (Some(a), None)    => None // No other choice here.
\end_layout

\begin_layout Plain Layout

  case (None, Some(b))    => ???
\end_layout

\begin_layout Plain Layout

  case (None, None)       => ???
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In lines 4–5, we find that there is no choice other than returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

.
 So, we can simplify the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2[A, B]: (Option[A], Option[B]) => Option[(A, B)] = {
\end_layout

\begin_layout Plain Layout

  case (Some(a), Some(b)) => Some((a, b))
\end_layout

\begin_layout Plain Layout

  case _                  => None // No other choice here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

CellState
\end_layout

\end_inset

 representing the visual state of one cell in the 
\begin_inset Quotes eld
\end_inset

Minesweeper
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Minesweeper_(video_game)"
literal "false"

\end_inset


\end_layout

\end_inset

 game: A cell can be closed (showing nothing), or show a bomb, or be open
 and show the number of bombs in neighbor cells.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
In the context of the 
\begin_inset Quotes eld
\end_inset

Minesweeper
\begin_inset Quotes erd
\end_inset

 game (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), count the total number of cells with zero neighbor bombs shown by implementin
g a function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Seq[CellState]] => Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootOfLinear
\end_layout

\end_inset

 representing all possibilities for the solution of the equation 
\begin_inset Formula $ax+b=0$
\end_inset

 for arbitrary real 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

.
 (The possibilities are: no roots; one root; all 
\begin_inset Formula $x$
\end_inset

 are roots.) Implement the solution as a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve1
\end_layout

\end_inset

 with type signature: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def solve1: ((Double, Double)) => RootOfLinear = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[(Double, Double)]
\end_layout

\end_inset

 containing pairs 
\begin_inset Formula $\left(a,b\right)$
\end_inset

 of  coefficients of 
\begin_inset Formula $ax+b=0$
\end_inset

, compute a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Double]
\end_layout

\end_inset

 containing the roots of that equation when a unique root exists.
 Use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootOfLinear
\end_layout

\end_inset

 and the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

solve1
\end_layout

\end_inset

 defined in Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-4-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-4-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

rootAverage
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-disjunctive-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to compute the average root of 
\begin_inset Formula $100$
\end_inset

 equations whose coefficients (
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

) are chosen randomly between 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 Ignore equations for which the average root value is undefined.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-4-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-4-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Subscriber
\end_layout

\end_inset

 was defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Disjunctive-Example-option-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Given a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Subscriber]
\end_layout

\end_inset

, compute the sequence of email addresses for all subscribers that did 
\emph on
not
\emph default
 provide a phone number.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-Procedure-DSL"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-Procedure-DSL"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
In this exercise, a 
\begin_inset Quotes eld
\end_inset

procedure
\begin_inset Index idx
status open

\begin_layout Plain Layout
procedure
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => Unit
\end_layout

\end_inset

.
 An example of a procedure is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ _ => println(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\end_inset

.
 Define a disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Proc
\end_layout

\end_inset

 for an abstract syntax tree representing three operations on procedures:
 1) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Func[A](f)
\end_layout

\end_inset

, to create a procedure from a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit => A
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is a type parameter.
 (Note that the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Proc
\end_layout

\end_inset

 does not have any type parameters.) 2) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Sequ(p1, p2)
\end_layout

\end_inset

, to execute two procedures sequentially.
 3) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Para(p1, p2)
\end_layout

\end_inset

, to execute two procedures in parallel.
 Then implement a 
\begin_inset Quotes eld
\end_inset

runner
\begin_inset Quotes erd
\end_inset

 that converts a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Proc
\end_layout

\end_inset

 into a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[Unit]
\end_layout

\end_inset

, running the computations either sequentially or in parallel as appropriate.
 Test with this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Proc
\end_layout

\begin_layout Plain Layout

final case class Func[A](???)   extends Proc    // And so on.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def runner: Proc => Future[Unit] = ???
\end_layout

\begin_layout Plain Layout

val proc1: Proc = Func{_ => Thread.sleep(200); println(
\begin_inset Quotes eld
\end_inset

hello1
\begin_inset Quotes erd
\end_inset

)}
\end_layout

\begin_layout Plain Layout

val proc2: Proc = Func{_ => Thread.sleep(400); println(
\begin_inset Quotes eld
\end_inset

hello2
\begin_inset Quotes erd
\end_inset

)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> runner(Sequ(Para(proc2, proc1), proc2))
\end_layout

\begin_layout Plain Layout

hello1
\end_layout

\begin_layout Plain Layout

hello2
\end_layout

\begin_layout Plain Layout

hello2
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use pattern matching to implement functions with given type signatures,
 preserving information as much as possible: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1[A, B]: Option[(A, B)] => (Option[A], Option[B]) = ???
\end_layout

\begin_layout Plain Layout

def f2[A, B]: Either[A, B] => (Option[A], Option[B]) = ???
\end_layout

\begin_layout Plain Layout

def f3[A, B, C]: Either[A, Either[B, C]] => Either[Either[A, B], C] = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-EvenList"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-EvenList"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a parameterized type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EvenList[A]
\end_layout

\end_inset

 representing a list of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 that must have an even length (zero, two, four, etc.).
 Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EvenList
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-disjunctive-EvenList-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-disjunctive-EvenList-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The standard type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 requires all its values to have the same type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Define a parameterized type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListX[A]
\end_layout

\end_inset

 representing a data structure in the form of a non-empty list where the
 first value has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, the second value has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

, the third — 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[A]]
\end_layout

\end_inset

, and so on.
 Using a wrong type at a given place (say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Option[A]]
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 for the second value in the list) should cause a type error.
 Implement (not necessarily tail-recursive) functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ListX
\end_layout

\end_inset

.
 The type signatures:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](lx: ListX[A])(f: A => B): ListX[B] = ???
\end_layout

\begin_layout Plain Layout

def foldLeft[A, R](lx: ListX[A])(init: R)(f: (R, A) = R): R = ???
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Solution
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait ListX[A]
\end_layout

\begin_layout Plain Layout

final case class One[A](a: A) extends ListX[A]
\end_layout

\begin_layout Plain Layout

final case class Two[A](a: A, tail: ListX[Option[A]]) extends ListX[A]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val lx: ListX[Int] = Two(1, Two(Some(1), Two(Some(Some(2)), One(Some(Some(Some(3
)))))))
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion and further developments
\end_layout

\begin_layout Subsection
Disjunctive types as mathematical sets
\end_layout

\begin_layout Standard
To understand the properties of disjunctive types from the mathematical
 point of view, consider a function whose argument is a disjunctive type,
 such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isDoubleRoot(r: RootsOfQ) = ...
\end_layout

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 represents the set of admissible values of the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r
\end_layout

\end_inset

, that is, the mathematical 
\series bold
domain
\series default
 of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isDoubleRoot
\end_layout

\end_inset

.
 What kind of domain is that? The set of real roots of a quadratic equation
 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

 can be empty, or it can contain a single real number 
\begin_inset Formula $x$
\end_inset

, or a pair of real numbers 
\begin_inset Formula $\left(x,y\right)$
\end_inset

.
 Geometrically, a number 
\begin_inset Formula $x$
\end_inset

 is pictured as a point in a line (a one-dimensional space), and pair of
 numbers 
\begin_inset Formula $\left(x,y\right)$
\end_inset

 is pictured as a point in a Cartesian plane (a two-dimensional space).
 The no-roots case corresponds to a zero-dimensional space, which can be
 pictured as a single point (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RootsOfQ-disjoint-domain"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The point, the line, and the plane do not intersect (i.e., have no common
 points).
 Together, they form the set of the possible roots of the quadratic equation
 
\begin_inset Formula $x^{2}+bx+c=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset space \hspace{}
\length -1cm
\end_inset


\begin_inset Graphics
	filename chapter3-picture.pdf
	lyxscale 40
	scale 120

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

   
\backslash
newrgbcolor{lightpastel}{0.90 0.93 0.87}
\end_layout

\begin_layout Plain Layout

   
\backslash
psset{unit=0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{pspicture}(0,0)(1,1)
\end_layout

\begin_layout Plain Layout

      
\backslash
pscircle(0.3,0.5){0.005}
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.5,0.2)(0.5,0.8)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.535,0.77){$x$}
\end_layout

\begin_layout Plain Layout

      
\backslash
pspolygon[fillstyle=solid,fillcolor=lightpastel](0.8,0.8)(0.8,0.3)(0.7,0.2)(0.7,0.7)(0.8,
0.8)
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.7,0.2)(0.775,0.275)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.67,0.28){$x$} 
\backslash
rput(0.79,0.24){$y$}
\end_layout

\begin_layout Plain Layout

      
\backslash
psline{->}(0.7,0.2)(0.7,0.3)
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.30,0.45){
\backslash
smaller
\backslash
texttt{NoRoots()}}
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.49,0.85){
\backslash
smaller
\backslash
texttt{OneRoot(x)}}
\end_layout

\begin_layout Plain Layout

      
\backslash
rput(0.75,0.15){
\backslash
smaller
\backslash
texttt{TwoRoots(x, y)}}
\end_layout

\begin_layout Plain Layout

   
\backslash
end{pspicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -140baselineskip%
\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The disjoint domain represented by the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:RootsOfQ-disjoint-domain"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the mathematical notation, a one-dimensional real space is denoted by
 
\begin_inset Formula $\mathbb{R}$
\end_inset

, a two-dimensional space by 
\begin_inset Formula $\mathbb{R}^{2}$
\end_inset

, and a zero-dimensional space by 
\begin_inset Formula $\mathbb{R}^{0}$
\end_inset

.
 At first, we may think that the mathematical representation of the type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is a union of the three sets, 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}$
\end_inset

.
 But an ordinary union of sets would not always work correctly because we
 need to distinguish the parts of the union unambiguously, even if some
 parts have the same type.
 For instance, the disjunctive type shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:disj-Example-rootsofq-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 cannot be correctly represented by the mathematical union:
\begin_inset Formula 
\[
\mathbb{R}^{0}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}\quad,
\]

\end_inset

because 
\begin_inset Formula $\mathbb{R}^{0}\cup\mathbb{R}^{0}=\mathbb{R}^{0}$
\end_inset

 and 
\begin_inset Formula $\mathbb{R}^{1}\cup\mathbb{R}^{1}=\mathbb{R}^{1}$
\end_inset

, so:
\begin_inset Formula 
\[
\mathbb{R}^{0}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}=\mathbb{R}^{0}\cup\mathbb{R}^{1}\cup\mathbb{R}^{2}\quad.
\]

\end_inset

For instance, this representation has no distinction between the cases 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Linear(x)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRootQ(x)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In Scala code, each part of a disjunctive type must be distinguished by
 a unique name such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

.
 To represent this mathematically, we need to attach a distinct label to
 each part of the union.
 Labels are symbols without any special meaning, and we can assume that
 labels are names of Scala case classes.
 Parts of the union are then represented by sets of pairs such as 
\begin_inset Formula $(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}$
\end_inset

.
 Then the domain 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 is expressed as:
\begin_inset Formula 
\[
\text{\texttt{RootsOfQ}}=(\text{\texttt{NoRoots}},u)_{u\in\mathbb{R}^{0}}\cup(\text{\texttt{OneRoot}},x)_{x\in\mathbb{R}^{1}}\cup(\text{\texttt{TwoRoots}},\left(x,y\right))_{\left(x,y\right)\in\mathbb{R}^{2}}\quad.
\]

\end_inset

This is an ordinary union of mathematical sets, but each of the sets has
 a unique label, so no two values from different parts of the union could
 possibly be equal.
 This kind of set is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
labeled union
\end_layout

\end_inset


\series bold
labeled union
\series default
 (also a tagged union or a disjoint union
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjoint union!see 
\begin_inset Quotes eld
\end_inset

labeled union
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

).
 Each element of a labeled union is a pair of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(label, data)
\end_layout

\end_inset

, where the label uniquely identifies the part of the union, and the data
 can have any chosen type such as 
\begin_inset Formula $\mathbb{R}^{1}$
\end_inset

.
 If we use labeled unions, we cannot confuse different parts of the union
 even if their data have the same type, because labels are required to be
 distinct.
\end_layout

\begin_layout Standard
Labeled unions are not often used in mathematics, but they are needed in
 software engineering because real-life data is often described by sets
 having several disjoint parts.
\end_layout

\begin_layout Paragraph
Named 
\family typewriter
Unit
\family default
 types
\end_layout

\begin_layout Standard
At first sight, it may seem strange that the zero-dimensional space is represent
ed by a set containing 
\emph on
one
\emph default
 point.
 Why should we not use an empty set (rather than a set with one element)
 to represent the case where the equation has no real roots? The reason
 is that we are required to represent not only the values of the roots but
 also the information 
\emph on
about
\emph default
 the existence of the roots.
 The case with no real roots needs to be represented by some 
\emph on
value
\emph default
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

.
 That value cannot be missing, which would happen if we used an empty set
 to represent the no-roots case.
 It is natural to use the named empty tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

 to represent that case, just as we used a named 
\begin_inset Formula $2$
\end_inset

-tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x, y)
\end_layout

\end_inset

 to represent the case of two roots.
\end_layout

\begin_layout Standard
Consider the value 
\begin_inset Formula $u$
\end_inset

 used by the mathematical set 
\begin_inset Formula $\left(\text{\texttt{NoRoots}},u\right)_{u\in\mathbb{R}^{0}}$
\end_inset

.
 Since 
\begin_inset Formula $\mathbb{R}^{0}$
\end_inset

 consists of a single point, there is only 
\emph on
one
\emph default
 possible value of 
\begin_inset Formula $u$
\end_inset

.
 Similarly, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type in Scala has only one distinct value, written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 A case class with no parts, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

, has only one distinct value, written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

.
 The Scala value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

 is fully analogous to the mathematical notation 
\begin_inset Formula $\left(\text{\texttt{NoRoots}},u\right)_{u\in\mathbb{R}^{0}}$
\end_inset

.
\end_layout

\begin_layout Standard
So, case classes with no parts are similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 except for an added name.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

 can be regarded as the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 with name 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots
\end_layout

\end_inset

.
 For this reason, this book calls them 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Quotes erd
\end_inset

 types.
\begin_inset Index true 1 ""
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Disjunctive types in other programming languages
\end_layout

\begin_layout Standard
Disjunctive types and pattern matching turns out to be one of the defining
 features of FP languages.
 Languages that were not designed for functional programming do not support
 these features, while OCaml, Haskell, F#, Scala, Swift, and Rust support
 disjunctive types and pattern matching as part of the language design.
 
\end_layout

\begin_layout Standard
It is remarkable that named tuple types (also called 
\begin_inset Quotes eld
\end_inset

structs
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

records
\begin_inset Quotes erd
\end_inset

) are provided in almost every programming language, while disjunctive types
 are almost never present except in languages designed for the FP paradigm.
\begin_inset Foot
status open

\begin_layout Plain Layout
The programming languages Ada and Pascal support disjunctive types but no
 other FP features.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

 types in C and C++ are not disjunctive types because it is not possible
 to determine which part of the union is represented by a given value.
 A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

union
\end_layout

\end_inset

 declaration in C looks like this:
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

union { int x; double y; long z; } i_d_l;
\end_layout

\end_inset

This type does not include any labels telling us which of the values is
 present.
 Without a label, we (and the compiler) will not know whether a given value
 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

i_d_l
\end_layout

\end_inset

 represents an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

int
\end_layout

\end_inset

, a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

double
\end_layout

\end_inset

, or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

long
\end_layout

\end_inset

.
 This will lead to errors that are hard to detect.
\end_layout

\begin_layout Standard
Programming languages of the C family (C, C++, Objective C, Java) support
 
\series bold
enumeration
\series default
 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

) types
\begin_inset Index idx
status open

\begin_layout Plain Layout
enumeration type
\end_layout

\end_inset

, which are a limited form of disjunctive types, and a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

 operation, which is a limited form of pattern matching.
 An 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

 type declaration in Java looks like this:
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

enum Color { RED, GREEN, BLUE; } 
\end_layout

\end_inset

In Scala, this is equivalent to a disjunctive type containing three 
\emph on
empty
\emph default
 tuples:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Color
\end_layout

\begin_layout Plain Layout

final case class RED()   extends Color
\end_layout

\begin_layout Plain Layout

final case class GREEN() extends Color
\end_layout

\begin_layout Plain Layout

final case class BLUE()  extends Color
\end_layout

\end_inset

If we add extra data to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset

 types, allowing the tuples to be non-empty, and extend the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

switch
\end_layout

\end_inset

 expression to be able to handle the extra data, we will recover the full
 functionality of disjunctive types.
 A definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 could then look like this: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

enum RootsOfQ {                 // This is not valid in Java!
\end_layout

\begin_layout Plain Layout

  NoRoots(), OneRoot(Double x), TwoRoots(Double x, Double y);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Scala 3 has a shorter a syntax for disjunctive types
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://dotty.epfl.ch/docs/reference/enums/adts.html"
target "https://dotty.epfl.ch/docs/reference/enums/adts.html"
literal "false"

\end_inset


\end_layout

\end_inset

 that resembles Java's 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

enum
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

enum RootsOfQ {
\end_layout

\begin_layout Plain Layout

  case NoRoots
\end_layout

\begin_layout Plain Layout

  case OneRoot(x: Double)
\end_layout

\begin_layout Plain Layout

  case TwoRoots(x: Double, y: Double)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

For comparison, the syntax for a disjunctive type equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 in OCaml and Haskell is:
\begin_inset listings
lstparams "language=Caml"
inline false
status open

\begin_layout Plain Layout

(* OCaml *)
\end_layout

\begin_layout Plain Layout

type RootsOfQ = NoRoots | OneRoot of float | TwoRoots of float * float
\end_layout

\end_inset


\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

-- Haskell
\end_layout

\begin_layout Plain Layout

data RootsOfQ = NoRoots | OneRoot Double | TwoRoots (Double, Double)
\end_layout

\end_inset

This is more concise than the Scala syntax.
 When reasoning about disjunctive types, it is inconvenient to write out
 long type definitions.
 Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:5-Curry-Howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will introduce a mathematical notation designed for efficient reasoning
 about types.
 That notation is even more concise than the syntax of Haskell or OCaml.
\end_layout

\begin_layout Subsection
Disjunctions and conjunctions in formal logic
\begin_inset CommandInset label
LatexCommand label
name "subsec:Disjunctions-and-conjunctions"

\end_inset


\end_layout

\begin_layout Standard
In logic, a 
\series bold
proposition
\begin_inset Index idx
status open

\begin_layout Plain Layout
proposition (in logic)
\end_layout

\end_inset


\series default
 is a logical formula that could be true or false.
 A 
\series bold
disjunction
\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunction (in logic)
\end_layout

\end_inset


\series default
 of propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is denoted by 
\begin_inset Formula $A\vee B\vee C$
\end_inset

 and is true if and only if 
\emph on
at least one
\emph default
 of 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is true.
 A 
\series bold
conjunction
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
conjunction (in logic)
\end_layout

\end_inset

 of 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 is denoted by 
\begin_inset Formula $A\wedge B\wedge C$
\end_inset

 and is true if and only if 
\emph on
all
\emph default
 of the propositions 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 are true.
\end_layout

\begin_layout Standard
There is a connection between disjunctive data types and logical disjunctions
 of propositions.
 A value of the disjunctive data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 can be constructed only if we have one of the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

NoRoots()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OneRoot(x)
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x, y)
\end_layout

\end_inset

.
 Let us now rewrite the previous sentence as a logical formula.
 Denote by 
\begin_inset Formula ${\cal CH}(A)$
\end_inset

 the logical proposition 
\begin_inset Quotes eld
\end_inset

we 
\begin_inset Formula ${\cal C}\!$
\end_inset

an 
\begin_inset Formula ${\cal H}\!$
\end_inset

ave a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 here
\begin_inset Quotes erd
\end_inset

, where by 
\begin_inset Quotes eld
\end_inset

here
\begin_inset Quotes erd
\end_inset

 we mean a particular scope in a program.
 So, the proposition 
\begin_inset Quotes eld
\end_inset

the code 
\emph on
can
\emph default
 compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is denoted by 
\begin_inset Formula ${\cal CH}(\text{\texttt{RootsOfQ}})$
\end_inset

.
 We can then write the above sentence about 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RootsOfQ
\end_layout

\end_inset

 as a logical formula:
\begin_inset Formula 
\begin{equation}
{\cal CH}(\text{\texttt{RootsOfQ}})={\cal CH}(\text{\texttt{NoRoots}})\vee{\cal CH}(\text{\texttt{OneRoot}})\vee{\cal CH}(\text{\texttt{TwoRoots}})\quad.\label{eq:curry-howard-example-disjunction}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
There is a similar connection between logical 
\emph on
conjunctions
\emph default
 and tuple types.
 Consider the named tuple (i.e., a case class) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots(x: Double, y: Double)
\end_layout

\end_inset

.
 We can have a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TwoRoots
\end_layout

\end_inset

 only if we have two values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 Rewriting this sentence as a logical formula, we get:
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{TwoRoots}})={\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset

Formal logic admits the simplification:
\begin_inset Formula 
\[
{\cal CH}(\text{\texttt{Double}})\wedge{\cal CH}(\text{\texttt{Double}})={\cal CH}(\text{\texttt{Double}})\quad.
\]

\end_inset

However, no such simplification will be available in the general case, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Data3(x: Int, y: String, z: Double)
\end_layout

\end_inset

For this type, we will have the formula:
\begin_inset Formula 
\begin{equation}
{\cal CH}(\text{\texttt{Data3}})={\cal CH}(\text{\texttt{Int}})\wedge{\cal CH}(\text{\texttt{String}})\wedge{\cal CH}(\text{\texttt{Double}})\quad.\label{eq:curry-howard-example-case-class}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We find that tuples are related to logical conjunctions in the same way
 as disjunctive types are related to logical disjunctions.
 This is the main reason for choosing the name 
\begin_inset Quotes eld
\end_inset

disjunctive types
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
Disjunctive types are also called sum types, co-product types, variants,
 and tagged unions.
 This book uses the terms 
\begin_inset Quotes eld
\end_inset

disjunctive types
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

co-product types
\begin_inset Quotes erd
\end_inset

 interchangeably.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The correspondence between disjunctions, conjunctions, and data types is
 explained in more detail in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:5-Curry-Howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For now, we note that the operations of conjunction and disjunction are
 not sufficient to produce all possible logical expressions.
 To obtain a complete logic, it is also necessary to have the logical implicatio
n 
\begin_inset Formula $A\rightarrow B$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $A$
\end_inset

 is true than 
\begin_inset Formula $B$
\end_inset

 is true
\begin_inset Quotes erd
\end_inset

).
 It turns out that the implication 
\begin_inset Formula $A\rightarrow B$
\end_inset

 is related to the function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

 in the same way as the disjunction operation is related to disjunctive
 types and the conjunction to tuples.
 In Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Higher-order-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we will study function types in depth.
\end_layout

\end_body
\end_document
