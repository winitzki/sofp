#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Functors and contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "chap:Functors,-contrafunctors,-and"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset

Types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[A]
\end_layout

\end_inset

 represent data structures that hold or 
\begin_inset Quotes eld
\end_inset

wrap
\begin_inset Quotes erd
\end_inset

 zero or more values of a given type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Those data structures are fully parametric: they work in the same way for
 every type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 Working with parametric 
\begin_inset Quotes eld
\end_inset

data wrappers
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

data containers
\begin_inset Quotes erd
\end_inset

 turns out to be a powerful design pattern of functional programming.
 To realize all its benefits, we will formalize the concept of data wrapping
 through a set of mathematical laws.
 We will then extend that design pattern to all data types for which the
 laws hold.
\end_layout

\begin_layout Section
Practical use
\end_layout

\begin_layout Subsection
Motivation.
 Type constructors that wrap data
\end_layout

\begin_layout Standard
How to formalize the idea of wrapped data? An intuitive view is that the
 data is somehow stored inside the wrapper.
 Then we should be able to manipulate the stored data.
 In functional programming, manipulating means applying functions to data.
 So, if an integer value 
\begin_inset Formula $123$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

, we should be able somehow to apply a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{x => x * 2}
\end_layout

\end_inset

 and obtain a 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

 value 
\begin_inset Formula $246$
\end_inset

.
\end_layout

\begin_layout Standard
Let us look at some often used type constructors defined in the Scala standard
 library, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

.
 We notice the common features:
\end_layout

\begin_layout Itemize
There are some methods for creating a data structure that wraps zero or
 more values of a given type.
 For example, the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List.fill(10)(0)
\end_layout

\end_inset

 creates a list of ten zeros of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
There are some methods for reading the wrapped values, if they exist.
 For example, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 class has the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

headOption
\end_layout

\end_inset

 that returns a non-empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 when the first element exists.
\end_layout

\begin_layout Itemize
There are some methods for manipulating the wrapped values while 
\emph on
keeping
\emph default
 them wrapped.
 For example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(10, 20, 30).map(_ + 5)
\end_layout

\end_inset

 evaluates to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(15, 25, 35)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 express quite different kinds of wrapping.
 The data structure implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[A]
\end_layout

\end_inset

 can hold a variable number of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 The data structure 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try[A]
\end_layout

\end_inset

 holds either a successfully computed value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 or a failure.
 The data structure 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future[A]
\end_layout

\end_inset

 implements a computation that has been scheduled to run but may not have
 finished yet, and may compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 (or fail) at a later time.
\end_layout

\begin_layout Standard
Since the 
\begin_inset Quotes eld
\end_inset

wrappers
\begin_inset Quotes erd
\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 are so different, the methods for creating and reading the wrapped values
 have different type signatures for each wrapper.
 However, the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is similar in all three examples.
 We can say generally that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method will apply a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 to all the data of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 stored inside the wrapper, putting new data (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

) into a wrapper of the same type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val a = List(x,y,z).map(f) // Result is List(f(x), f(y), f(z)).
\end_layout

\begin_layout Plain Layout

val b = Try(x).map(f)      // Result is Try(f(x)).
\end_layout

\begin_layout Plain Layout

val c = Future(x).map(f)   // Result is Future(f(x)).
\end_layout

\end_inset

This motivates us to use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method as a requirement for the wrapping functionality.
 We will consider a type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 a 
\begin_inset Quotes eld
\end_inset

wrapper
\begin_inset Quotes erd
\end_inset

 if there exists a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 with the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: F[A] => (A => B) => F[B]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 are 
\begin_inset Quotes eld
\end_inset

wrappers
\begin_inset Quotes erd
\end_inset

 because they have a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method.
 This chapter focuses on the properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 that are common to 
\emph on
all
\emph default
 wrapper types.
 We will ignore all other features — reading data out of the wrapper, inserting
 or deleting data, waiting until data becomes available, etc., — as they
 are implemented by methods specific to each wrapper type.
\end_layout

\begin_layout Subsection
Example: 
\family typewriter
Option
\family default
 and the identity law
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example:-Option-and"

\end_inset


\end_layout

\begin_layout Standard
As another example of a 
\begin_inset Quotes eld
\end_inset

data wrapper
\begin_inset Quotes erd
\end_inset

, consider the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, which is written in the type notation as:
\begin_inset Formula 
\[
\text{Opt}^{A}\triangleq\bbnum 1+A\quad.
\]

\end_inset

The type signature of its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function is:
\begin_inset Formula 
\[
\text{map}^{A,B}:\bbnum 1+A\rightarrow\left(A\rightarrow B\right)\rightarrow\bbnum 1+B\quad.
\]

\end_inset

This function produces a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[B]
\end_layout

\end_inset

 value that wraps transformed data.
 We will now use this example to develop intuition about manipulating data
 in a wrapper.
 Two possible implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 will fit the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def mapX[A, B](p: Option[A])(f: A => B): Option[B] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def mapY[A, B](p: Option[A])(f: A => B): Option[B] =
\end_layout

\begin_layout Plain Layout

  p match {
\end_layout

\begin_layout Plain Layout

    case None      => None
\end_layout

\begin_layout Plain Layout

    case Some(x)   => Some(f(x))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset

The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapX
\end_layout

\end_inset

 loses information
\begin_inset Index idx
status open

\begin_layout Plain Layout
information loss
\end_layout

\end_inset

 since it always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and ignores all input.
 The implementation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapY
\end_layout

\end_inset

 is more useful since it preserves information.
 
\end_layout

\begin_layout Standard
How can we formulate this property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapY
\end_layout

\end_inset

 in a rigorous way? The trick is to choose the argument 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(p)(f)
\end_layout

\end_inset

 to be the identity function 
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

 (setting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

's type parameters as 
\begin_inset Formula $A=B$
\end_inset

, so that the types match).
 Applying an identity function to a value stored in an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 should not change that value.
 To verify that, substitute the identity function instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapY
\end_layout

\end_inset

 and compute:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mapY[A, A](p: Option[A])(identity[A]: A => A): Option[A]
\end_layout

\begin_layout Plain Layout

  == p match {
\end_layout

\begin_layout Plain Layout

        case None      => None        // No change.
\end_layout

\begin_layout Plain Layout

        case Some(x)   => Some(x)     // No change.
\end_layout

\begin_layout Plain Layout

     } == p
\end_layout

\end_inset

The result is always equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 We can write that fact as an equation:
\begin_inset Formula 
\[
\text{for all }p^{:\text{Opt}^{A}}:\,\,\text{map}\,(p)(\text{id})=p\quad.
\]

\end_inset

This equation is called the 
\series bold
identity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of functors
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 The identity law is a formal way of expressing the information-preserving
 property of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function.
 The implementation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapX
\end_layout

\end_inset

 violates the identity law since it always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 and so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapX(p)(id) == None
\end_layout

\end_inset

 and not equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 A data wrapper should not unexpectedly lose information when we manipulate
 the wrapped data.
 So, the correct implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

mapY
\end_layout

\end_inset

.
 The code notation for that implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{map}^{A,B}\triangleq p^{:\bbnum 1+A}\rightarrow f^{:A\rightarrow B}\rightarrow p\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & B\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
When writing code, it is convenient to use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method defined in the Scala library.
 However, when proving the properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, it turns out to be more convenient to flip the order of the curried arguments
 and to use the equivalent function, called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, with the type signature:
\begin_inset Formula 
\[
\text{fmap}^{A,B}:\left(A\rightarrow B\right)\rightarrow\bbnum 1+A\rightarrow\bbnum 1+B\quad.
\]

\end_inset

The Scala implementation and the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 are shorter than for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Option[A] => Option[B] = {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => Some(f(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\text{fmap}\,(f^{:A\rightarrow B})\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & B\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\quad.\label{eq:f-def-opt-fmap-matrix-notation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The identity law also looks simpler if expressed in terms of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

: 
\begin_inset Formula 
\[
\text{fmap}\,(\text{id})=\text{id}\quad.
\]

\end_inset

Here we omitted the type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, which must be both equal (
\begin_inset Formula $A=B$
\end_inset

).
\end_layout

\begin_layout Standard
Note that the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 looks like a transformation from functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset

 to functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[B]
\end_layout

\end_inset

.
 This transformation is called 
\series bold
lifting
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
lifting
\end_layout

\end_inset

 because it 
\begin_inset Quotes eld
\end_inset

lifts
\begin_inset Quotes erd
\end_inset

 a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 operating on simple values into a function operating on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

-wrapped values.
 
\end_layout

\begin_layout Standard
So, the identity law may be stated by saying that 
\begin_inset Quotes eld
\end_inset

a lifted identity function is also an identity function
\begin_inset Quotes erd
\end_inset

.
 If we apply a lifted identity function to a data wrapper, we expect the
 wrapped data to remain unchanged.
 The identity law expresses this expectation as a mathematical equation.
\end_layout

\begin_layout Subsection
Motivation for the composition law
\end_layout

\begin_layout Standard
The main feature of a 
\begin_inset Quotes eld
\end_inset

data wrapper
\begin_inset Quotes erd
\end_inset

 is to allow us to manipulate the data inside it by applying functions to
 that data.
 The corresponding Scala code is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.map(f)
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 is a value of a wrapper type.
 It is natural to expect that lifted functions behave in the same way as
 the 
\begin_inset Quotes eld
\end_inset

unlifted
\begin_inset Quotes erd
\end_inset

 ones.
 For example, suppose we need to increment a counter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type means that the counter may be empty or non-empty; if it is non-empty,
 we increment the integer value wrapped inside the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 using the incrementing function:
\begin_inset Formula 
\[
\text{incr}\triangleq x^{:\text{Int}}\rightarrow x+1\quad.
\]

\end_inset

In order to apply a function to the counter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

, we need to lift that function.
 The Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def incr: Int => Int = x => x + 1
\end_layout

\begin_layout Plain Layout

val c: Option[Int] = Some(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> c.map(incr)
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(1) 
\end_layout

\end_inset

If we apply the lifted function twice, we expect that the counter will be
 incremented twice:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> c.map(incr).map(incr)
\end_layout

\begin_layout Plain Layout

res1: Option[Int] = Some(2)
\end_layout

\end_inset

This result is the same as when applying a lifted function 
\begin_inset Formula $x\rightarrow x+2$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> c.map(x => x + 2)
\end_layout

\begin_layout Plain Layout

res2: Option[Int] = Some(2)
\end_layout

\end_inset

It would be confusing and counter-intuitive if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c.map(x => x + 2)
\end_layout

\end_inset

 did not give the same result as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c.map(incr).map(incr)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We can formulate this property more generally: Liftings should preserve
 the function composition for arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

.
 So, we must have:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

c.map(f).map(g) == c.map(f andThen g)
\end_layout

\end_inset


\begin_inset Formula 
\[
c^{:F^{A}}\triangleright\text{fmap}\,(f)\triangleright\text{fmap}\,(g)=c\triangleright\text{fmap}\,(f\bef g)\quad.
\]

\end_inset

The pipe notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset

 allows us to write:
\begin_inset Formula 
\[
c\triangleright\text{fmap}\,(f)\triangleright\text{fmap}\,(g)=c\triangleright\text{fmap}\,(f)\bef\text{fmap}\,(g)\quad.
\]

\end_inset

Then we can express the property of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as:
\begin_inset Formula 
\[
c\triangleright\text{fmap}\,(f)\bef\text{fmap}\,(g)=c\triangleright\text{fmap}\,(f\bef g)\quad.
\]

\end_inset

When 
\begin_inset Formula $c\triangleright p=c\triangleright q$
\end_inset

 for all 
\begin_inset Formula $c$
\end_inset

, where 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 are some functions, it means 
\emph on
the functions themselves
\emph default
 are equal, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
equality between functions
\end_layout

\end_inset

 and we may simply write 
\begin_inset Formula $p=q$
\end_inset

 instead of 
\begin_inset Formula $c\triangleright p=c\triangleright q$
\end_inset

.
 So, we omit the argument 
\begin_inset Formula $c$
\end_inset

 in the last equation and rewrite it in a shorter form:
\begin_inset Formula 
\[
\text{fmap}\,(f)\bef\text{fmap}\,(g)=\text{fmap}\,(f\bef g)\quad.
\]

\end_inset

This is called the 
\series bold
composition law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of functors
\end_layout

\end_inset

 of functors.
 
\end_layout

\begin_layout Standard
Let us verify the composition law of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type, whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function was shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example:-Option-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For clarity and practice, we will perform the derivations both in the code
 notation and in the Scala syntax.
\end_layout

\begin_layout Standard
The composition law must hold for arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

.
 Then both sides of the composition law are functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Option[C]
\end_layout

\end_inset

.
 To show that both sides are equal, we apply both sides to an arbitrary
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: Option[A]
\end_layout

\end_inset

 and show that the results are equal.
 Begin with the right-hand side, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f andThen g)
\end_layout

\end_inset

 in Scala.
 It is convenient to use the  method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.map(f)
\end_layout

\end_inset

 instead of the equivalent expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(p)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fmap(f andThen g)(p) == p.map(f andThen g) == p match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => (f andThen g)(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f andThen g)(x) == g(f(x))
\end_layout

\end_inset

, we rewrite the result as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

p.map(f andThen g) == p match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => g(f(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now apply the left-hand side of the law to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

p.map(f).map(g) == (p match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => f(x)
\end_layout

\begin_layout Plain Layout

}).map(g) == (p match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => f(x)
\end_layout

\begin_layout Plain Layout

}) match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(y)   => g(y)
\end_layout

\begin_layout Plain Layout

} == p match {
\end_layout

\begin_layout Plain Layout

  case None      => None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => g(f(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We find that the two sides of the law have identical code.
\end_layout

\begin_layout Standard
The derivation is shorter in the matrix notation.
 We use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-opt-fmap-matrix-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 and omit the types:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}\,(f)\bef\text{fmap}\,(g)=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & f
\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & g
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{||cc|}
\text{id}\bef\text{id} & \bbnum 0\\
\bbnum 0 & f\bef g
\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & f\bef g
\end{array}\\
\text{definition of fmap}:\quad & =\text{fmap}\,(f\bef g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
These calculations prove that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type satisfies the composition law.
 If the composition law did not hold, we would incorrectly imagine the way
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 manipulates data within the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 wrapper.
 Looking at the Scala code example above, we expect 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c.map(incr).map(incr)
\end_layout

\end_inset

 to increment the data wrapped by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 two times.
 If the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c.map(incr).map(incr)
\end_layout

\end_inset

 were not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(2)
\end_layout

\end_inset

 but, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(1)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, our ordinary intuitions about data transformations would become incorrect.
 In other words, violations of the composition law prevent us from understanding
 the code via reasoning about transformation of data values.
\end_layout

\begin_layout Standard
The composition law is a rigorous formulation of the requirement that wrapped
 data should be transformed (by lifted functions) in the same way as ordinary
 data; the shape of the 
\begin_inset Quotes eld
\end_inset

wrapping
\begin_inset Quotes erd
\end_inset

 should remain unchanged.
 As an illustration, let us prove the following  property:
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Statement-composition-associativy-law"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Statement-composition-associativy-law"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, and 
\begin_inset Formula $h^{:C\rightarrow D}$
\end_inset

, we have:
\begin_inset Formula 
\[
\text{fmap}\,(f)\bef\text{fmap}\,(g\bef h)=\text{fmap}\,(f\bef g)\bef\text{fmap}\,(h)\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The left-hand side is rewritten as:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}\,(f)\bef\,\gunderline{\text{fmap}\,(g\bef h)}\\
\text{composition law for }\left(g\bef h\right):\quad & =\text{fmap}\,(f)\bef\left(\text{fmap}\,(g)\bef\text{fmap}\,(h)\right)\\
\text{associativity law (\ref{eq:associativity-of-function-composition})}:\quad & =\gunderline{\left(\text{fmap}\,(f)\bef\text{fmap}\,(g)\right)}\bef\text{fmap}\,(h)\\
\text{composition law for }\left(f\bef g\right):\quad & =\text{fmap}\,(f\bef g)\bef\text{fmap}\,(h)\quad,
\end{align*}

\end_inset

which now equals the right-hand side.
\end_layout

\begin_layout Subsection
Functors: definition and examples
\begin_inset CommandInset label
LatexCommand label
name "subsec:Functors:-definition-and-examples"

\end_inset


\end_layout

\begin_layout Standard
Separating the functionality of 
\begin_inset Quotes eld
\end_inset

data wrapper
\begin_inset Quotes erd
\end_inset

 from other features of a data type, we obtain:
\end_layout

\begin_layout Itemize
A data type with a type parameter, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

.
 We will sometimes use the notation 
\begin_inset Formula $L^{\bullet}$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

) in order to emphasize that 
\begin_inset Formula $L$
\end_inset

 is a type constructor.
\end_layout

\begin_layout Itemize
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!function
\end_layout

\end_inset

fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 with the type signature:
\begin_inset Formula 
\[
\text{fmap}_{L}:\left(A\rightarrow B\right)\rightarrow L^{A}\rightarrow L^{B}\quad.
\]

\end_inset


\end_layout

\begin_layout Itemize
Two laws that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 must satisfy:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\text{identity law}:\quad & \text{fmap}_{L}(\text{id}^{:A\rightarrow A})=\text{id}^{:L^{A}\rightarrow L^{A}}\quad,\label{eq:f-identity-law-functor-fmap}\\
\text{composition law}:\quad & \text{fmap}_{L}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})=\text{fmap}_{L}(f^{:A\rightarrow B})\bef\text{fmap}_{L}(g^{:B\rightarrow C})\quad.\label{eq:f-composition-law-functor-fmap}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
A type constructor 
\begin_inset Formula $L$
\end_inset

 with these properties is called a 
\series bold
functor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
functor
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
When a law involves function compositions, it is helpful to draw a type
 diagram
\begin_inset Index idx
status open

\begin_layout Plain Layout
type diagram
\end_layout

\end_inset

 to clarify how the functions transform various types involved in the law.
 A 
\series bold
type diagram
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type diagram
\end_layout

\end_inset

 is a directed graph whose vertices are types and edges are functions mapping
 one type to another.
 Function composition corresponds to following a path in the diagram.
 A type diagram for the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-composition-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc} & L^{B}\ar[rd]\sp(0.6){~~\text{fmap}_{L}(g^{:B\rightarrow C})}\\
L^{A}\ar[ru]\sp(0.4){\text{fmap}_{L}(f^{:A\rightarrow B})\ ~}\ar[rr]\sb(0.5){\text{fmap}_{L}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\ } &  & L^{C}
}
\]

\end_inset

There are two paths from 
\begin_inset Formula $L^{A}$
\end_inset

 to 
\begin_inset Formula $L^{C}$
\end_inset

.
 By Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-composition-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

), both paths must give the same result.
 Mathematicians say that the diagram is 
\begin_inset Quotes eld
\end_inset


\series bold
commutative
\series default

\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
commutative diagram
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Type diagrams are easier to read when using the 
\emph on
forward
\emph default
 composition 
\begin_inset Formula $\left(f\bef g\right)$
\end_inset

 because the order of edges is the same as the order of functions in the
 composition.
 To see this, compare Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-composition-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the type diagram above with the same law written using the backward
 composition:
\begin_inset Formula 
\[
\text{fmap}_{L}(g^{:B\rightarrow C}\circ f^{:A\rightarrow B})=\text{fmap}_{L}(g^{:B\rightarrow C})\circ\text{fmap}_{L}(f^{:A\rightarrow B})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 and can be expressed through 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 by:
\begin_inset Formula 
\begin{align*}
 & \text{map}_{L}:L^{A}\rightarrow\left(A\rightarrow B\right)\rightarrow L^{B}\quad,\\
 & \text{map}_{L}(x^{:L^{A}})(f^{:A\rightarrow B})=\text{fmap}_{L}(f^{:A\rightarrow B})(x^{:L^{A}})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Each of the type constructors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 has its own definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 but the functor laws remain the same.
 We use the subscript 
\begin_inset Formula $L$
\end_inset

 when writing 
\begin_inset Formula $\text{map}_{L}$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

 in order to indicate clearly the type constructor those functions work
 with.
\end_layout

\begin_layout Standard
We will now look at some examples of type constructors that are functors.
\end_layout

\begin_layout Paragraph
Standard data structures
\end_layout

\begin_layout Standard
Many type constructors defined in the Scala library have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method, and almost all of them are functors.
 Some often used functors are:
\end_layout

\begin_layout Itemize
The standard disjunctive types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Try
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

 (where, by default, transformations apply to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
The linear sequence 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 and its various subtypes such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Range
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vector
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

IndexedSeq
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

task-like
\begin_inset Quotes erd
\end_inset

 functors: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Future
\end_layout

\end_inset

 and its alternatives: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Task
\end_layout

\end_inset

 (provided by the 
\family typewriter
monix
\family default
 library), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Async
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Concurrent
\end_layout

\end_inset

 (provided by the 
\family typewriter
cats-effect
\family default
 library), 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ZIO
\end_layout

\end_inset

 (provided by the 
\family typewriter
zio
\family default
 library).
\end_layout

\begin_layout Itemize
Dictionaries: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, V]
\end_layout

\end_inset

 with respect to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

V
\end_layout

\end_inset

.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method transforms the values in a dictionary, leaving the keys unchanged.
\end_layout

\begin_layout Standard
Application-specific, custom type constructors defined by the programmer,
 such as case classes with type parameters, are often functors.
 Their structure is simple and helps build intuition for functors, so let
 us now consider some examples of case classes that are functors.
 In this book, they are called 
\begin_inset Quotes eld
\end_inset

polynomial functors
\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functors
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Polynomial functors
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
types!polynomial type constructors
\end_layout

\end_inset

Type constructors defined via primitive types, products, and disjunctions
 (or 
\begin_inset Quotes eld
\end_inset

sums
\begin_inset Quotes erd
\end_inset

) are often used to represent application-specific data.
 As an example, consider this definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Counted[A](n: Int, a: A)
\end_layout

\end_inset

The data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[A]
\end_layout

\end_inset

 may be used to describe 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 repetitions of a given value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

.
 We may implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[A]
\end_layout

\end_inset

 as a function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](c: Counted[A])(f: A => B): Counted[B] = c match {
\end_layout

\begin_layout Plain Layout

  case Counted(n, a) => Counted(n, f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

But it is often more convenient to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as a class method:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Counted[A](n: Int, a: A) {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): Counted[B] = Counted(n, f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code defines both the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 and the method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 Here is a usage example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> Counted(10, 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

).map(s => 
\begin_inset Quotes eld
\end_inset

prefix 
\begin_inset Quotes eld
\end_inset

 + s)
\end_layout

\begin_layout Plain Layout

res0: Counted[String] = Counted(10,prefix abc) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The type notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{Counted}^{A}\triangleq\text{Int}\times A\quad,
\]

\end_inset

showing that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 is a polynomial type constructor.
 Let us verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 is a functor.
 As we already have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

, it remains to check that the functor laws hold.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-Int-x-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-Int-x-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verify that the above implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 satisfies the functor laws.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is fully parametric since it does not perform any type-specific operations;
 it uses the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

 as if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 were a type parameter.
 It remains to check that the laws hold.
 We will first verify the laws using the Scala syntax and then using the
 code notation.
\end_layout

\begin_layout Standard
The identity law means that for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 we must have:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Counted(n, a).map(identity) == Counted(n, a)
\end_layout

\end_inset

To verify this, we substitute the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and find:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Counted(n, a).map(identity) == Counted(n, identity(a)) == Counted(n, a)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The composition law means that for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: B => C
\end_layout

\end_inset

, we must have:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Counted(n, a).map(f).map(g) == Counted(n, a).map(f andThen g)
\end_layout

\end_inset

Substitute the Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 into the left-hand side:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Counted(n, a).map(f).map(g) == Counted(n, f(a)).map(g) == Counted(n, g(f(a)))
\end_layout

\end_inset

The right-hand side can be transformed to the same expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Counted(n, a).map(f andThen g) == Counted(n, (f andThen g)(a)) == Counted(n,
 g(f(a)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us now write a proof in the code notation, formulating the laws via
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method:
\begin_inset Formula 
\[
\text{fmap}_{\text{Counted}}(f^{:A\rightarrow B})\triangleq n^{:\text{Int}}\times a^{:A}\rightarrow n\times f(a)\quad.
\]

\end_inset

To verify the identity law, we write:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{fmap}_{\text{Counted}}(\text{id})\\
\text{definition of }\text{fmap}_{\text{Counted}}:\quad & =n\times a\rightarrow n\times\gunderline{\text{id}\,(a)}\\
\text{definition of }\text{id}:\quad & =\left(n\times a\rightarrow n\times a\right)=\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law (for brevity, denote 
\begin_inset Formula $\text{fmap}_{\text{Counted}}$
\end_inset

 by just 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{fmap}$
\end_inset


\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{fmap}(f\bef g):\quad & \text{fmap}\,(f)\bef\text{fmap}\,(g)\\
\text{definition of }\text{fmap}:\quad & =\left(n\times a\rightarrow n\times f(a)\right)\bef\left(n\times b\rightarrow n\times g(b)\right)\\
\text{compute composition}:\quad & =n\times a\rightarrow n\times\gunderline{g(f(a))}\\
\text{definition of }\left(f\bef g\right):\quad & =n\times a\rightarrow n\times(f\bef g)(a)=\text{fmap}\,(f\bef g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We will prove later that all polynomial type constructors have a definition
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 that satisfies the functor laws.
 It will be clear without proof that our definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 is correct.
 
\end_layout

\begin_layout Standard
What would be an 
\emph on
incorrect
\emph default
 implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

? As an example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 could transform 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted(n, a)
\end_layout

\end_inset

 as before, except that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is now used to count the number of times 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is applied:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map_bad[A, B](c: Counted[A])(f: A => B): Counted[B] = c match {
\end_layout

\begin_layout Plain Layout

  case Counted(n, a) => Counted(n + 1, f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This implementation may appear reasonable.
 However, it violates both functor laws.
 For instance:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Counter(n, a) != map_bad(Counter(n, a))(identity) == Counter(n + 1, a)
\end_layout

\begin_layout Plain Layout

  // Identity law does not hold.
\end_layout

\end_inset

The failure of functor laws means that code involving 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 cannot be refactored in usual ways:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Counter(n, a).map(incr).map(incr) != Counter(n, a).map(x => x + 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us look at some other examples of polynomial type constructors.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-A-A-A"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-A-A-A"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function for the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vec3
\end_layout

\end_inset

 defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

case class Vec3[A](x: A, y: A, z: A)
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing a fully parametric function in a straightforward way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Vec3[A] => Vec3[B] = {
\end_layout

\begin_layout Plain Layout

  case Vec3(x, y, z) => Vec3(f(x), f(y), f(z))  // Apply `f` to all data
 of type `A`, keep the order.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Since all three values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(y)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(z)
\end_layout

\end_inset

 have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 would still satisfy the required type signature if it returned, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vec3(f(z), f(x), f(x))
\end_layout

\end_inset

 or some other combination of those values.
 However, we would then fail to preserve information about the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 and about their ordering in the original data, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vec(x, y, z)
\end_layout

\end_inset

.
 For this reason, we use the implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 shown above.
\end_layout

\begin_layout Standard
The type notation for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vec3
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{Vec}_{3}{}^{A}\triangleq A\times A\times A\quad,
\]

\end_inset

and the code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{fmap}_{\text{Vec}_{3}}(f^{:A\rightarrow B})\triangleq x^{:A}\times y^{:A}\times z^{:A}\rightarrow f(x)\times f(y)\times f(z)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-P+QxA"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-P+QxA"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function for this type constructor:
\begin_inset Formula 
\[
\text{QueryResult}^{A}\triangleq\text{String}+\text{String}\times\text{Long}\times A\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Begin by implementing the type constructor in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait QueryResult[A]
\end_layout

\begin_layout Plain Layout

case class Error[A](message: String)                    extends QueryResult[A]
\end_layout

\begin_layout Plain Layout

case class Result[A](name: String, time: Long, data: A) extends QueryResult[A]
\end_layout

\end_inset

Now implement a fully parametric, information-preserving function with the
 type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for this type constructor:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): QueryResult[A] => QueryResult[B] = {
\end_layout

\begin_layout Plain Layout

  case Error(message)             => Error(message)
\end_layout

\begin_layout Plain Layout

  case Result(name, time, data)   => Result(name, time, f(data))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

As in the previous example, we treat specific types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Long
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

) as if they were type parameters.
 In this way, we obtain a correct implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 that satisfies the functor laws.
\end_layout

\begin_layout Paragraph
Recursive polynomial functors
\end_layout

\begin_layout Standard
Recursive disjunctive type constructors shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Lists-and-trees:recursive-disjunctive-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

, such as lists and trees, are functors.
 Their 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 methods use recursion (the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 calls itself at some places).
 It is often 
\emph on
not
\emph default
 easy to implement those 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 methods tail-recursively! Since our main focus is to prove that various
 laws hold for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, we will prefer shorter and more straightforward code even if it is not
 tail-recursive.
 Once the laws are proved for that code, the programmer may look for an
 equivalent but more efficient and stack-safe implementation of the same
 function.
\end_layout

\begin_layout Standard
Proving laws for a recursive function needs mathematical induction.
 For a first example of such a proof, we use the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 data type (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-recursive-type-List"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-rec-poly-functor-List"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-rec-poly-functor-List"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method satisfies the functor laws.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We will first write the proof in the Scala syntax and then in the code notation.
 The Scala code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method was shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Tail-recursion-with-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The equivalent 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): List[A] => List[B] = {
\end_layout

\begin_layout Plain Layout

  case Nil            => Nil
\end_layout

\begin_layout Plain Layout

  case head :: tail   => f(head) :: fmap(f)(tail)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To verify the identity law, we need to show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(identity) == identity
\end_layout

\end_inset

.
 Both sides of this law are functions, so we need to apply them to an arbitrary
 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[A]
\end_layout

\end_inset

 and show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(identity)(s) == s
\end_layout

\end_inset

.
 The proof goes by induction on the length of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

.
 The value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 must be either 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head :: tail
\end_layout

\end_inset

, since these are the only ways of creating a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 value.
\end_layout

\begin_layout Standard
The base case is an empty list (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s == Nil
\end_layout

\end_inset

).
 To prove the base case, we apply the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nil
\end_layout

\end_inset

.
 The code goes into the first line: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case Nil => Nil
\end_layout

\end_inset

.
 So, we have proved that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(identity)(Nil) == Nil
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To prove the inductive step, we need to show that the law holds for lists
 of length 
\begin_inset Formula $n+1$
\end_inset

 assuming it holds for lists of length 
\begin_inset Formula $n$
\end_inset

.
 This corresponds to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s == head :: tail
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head
\end_layout

\end_inset

 is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

 is a list of length 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

.
 By the inductive assumption, the law already holds when applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(identity)(tail) == tail
\end_layout

\end_inset

.
 Then we compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(identity)(s)
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fmap(identity)(head::tail)
\end_layout

\begin_layout Plain Layout

  == identity(head) :: fmap(identity)(tail)
\end_layout

\begin_layout Plain Layout

  == head :: fmap(identity)(tail)
\end_layout

\end_inset

The last result is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

head :: tail == s
\end_layout

\end_inset

 due to the inductive assumption.
\end_layout

\begin_layout Standard
Note that the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap(f)(tail)
\end_layout

\end_inset

 in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is a 
\emph on
recursive call
\emph default
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 The inductive assumption says that the law already holds for any recursive
 calls of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 We will use such inductive assumptions in all proofs of laws for recursive
 functions.
\end_layout

\begin_layout Standard
To prove the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, take arbitrary functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: B => C
\end_layout

\end_inset

, and apply both sides of the law to an arbitrary list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s: List[A]
\end_layout

\end_inset

.
 We need to show that:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fmap(g)(fmap(f)(s)) == fmap(f andThen g)(s)
\end_layout

\end_inset

The base case of induction is an empty list, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s == Nil
\end_layout

\end_inset

.
 In that case, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 always returns an empty list, so the law holds:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* left-hand side of the law:  */   fmap(g)(fmap(f)(Nil)) == fmap(g)(Nil)
 == Nil
\end_layout

\begin_layout Plain Layout

/* right-hand side of the law: */   fmap(f andThen g)(Nil) == Nil
\end_layout

\end_inset

The inductive step assumes that the law holds for any list of length 
\begin_inset Formula $n$
\end_inset

.
 We need to verify the law for a list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s == head :: tail
\end_layout

\end_inset

 of length 
\begin_inset Formula $n+1$
\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

tail
\end_layout

\end_inset

 is a list of length 
\begin_inset Formula $n$
\end_inset

.
 The left-hand side of the law is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* left-hand side of the law:  */   fmap(g)(fmap(f)(head :: tail))
\end_layout

\begin_layout Plain Layout

/* expand the code of fmap(f): */   == fmap(g)(f(head) :: fmap(f)(tail))
\end_layout

\begin_layout Plain Layout

/* expand the code of fmap(g): */   == g(f(head)) :: fmap(g)(fmap(f)(tail))
\end_layout

\begin_layout Plain Layout

/* the inductive assumption:   */   == g(f(head)) :: fmap(f andThen g)(tail)
\end_layout

\end_inset

Now compute the right-hand side and show that it equals the left-hand side:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/* right-hand side of the law: */   fmap(f andThen g)(head :: tail)
\end_layout

\begin_layout Plain Layout

/* expand the code of fmap:    */   == (f andThen g)(head) :: fmap(f andThen
 g)(tail)
\end_layout

\begin_layout Plain Layout

/* expand (f andThen g)(head): */   == g(f(head)) :: fmap(f andThen g)(tail)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now write the same proof in the code notation.
 Begin with the definition of the type constructor 
\begin_inset Formula $\text{List}^{A}$
\end_inset

:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}\quad.
\]

\end_inset

The code of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method is written in the matrix notation as:
\begin_inset Formula 
\[
\text{fmap}\,(f^{:A\rightarrow B})\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & B\times\text{List}^{B}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times\text{List}^{A} & \bbnum 0 & h^{:A}\times t^{:\text{List}^{A}}\rightarrow f(h)\times\overline{\text{fmap}}\,(f)(t)
\end{array}\quad.
\]

\end_inset

In this book, recursive calls to functions are indicated by an overline,
 as in 
\begin_inset Formula $\overline{\text{fmap}}$
\end_inset

.
 Keep in mind that the symbol 
\begin_inset Formula $\overline{\text{fmap}}$
\end_inset

 denotes 
\emph on
the same
\emph default
 function as 
\begin_inset Formula $\text{fmap}$
\end_inset

.
 The overline is used only as a reminder that certain parts of code are
 recursive calls.
\end_layout

\begin_layout Standard
To verify the identity law, we apply 
\begin_inset Formula $\text{fmap}$
\end_inset

 to an identity function (
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

) and find:
\begin_inset Formula 
\[
\text{fmap}\,(\text{id})=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times\text{List}^{A}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times\text{List}^{A} & \bbnum 0 & h\times t\rightarrow\text{id}\,(h)\times\overline{\text{fmap}}\,(\text{id})(t)
\end{array}\quad.
\]

\end_inset

The inductive assumption says that any recursive calls to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 already satisfy the identity law.
 We write this in the code notation as:
\begin_inset Formula 
\[
\overline{\text{fmap}}\,(\text{id})=\text{id}\quad.
\]

\end_inset

Using this assumption, we write (omitting types for brevity):
\begin_inset Formula 
\[
\text{fmap}\,(\text{id})=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow\gunderline{\text{id}\,(h)\times\text{id}\,(t)}
\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow h\times t
\end{array}\quad.
\]

\end_inset

As 
\begin_inset Formula $h\times t\rightarrow h\times t$
\end_inset

 is an identity function of type 
\begin_inset Formula $A\times\text{List}^{A}\rightarrow A\times\text{List}^{A}$
\end_inset

, we find:
\begin_inset Formula 
\[
\text{fmap}\,(\text{id})=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times\text{List}^{A}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times\text{List}^{A} & \bbnum 0 & \text{id}
\end{array}\,=\text{id}\quad.
\]

\end_inset

A diagonal code matrix whose elements are identity functions will never
 change any values in any of the disjunctive parts.
 So, that matrix is equal to the identity function applied to the entire
 disjunctive type.
 
\end_layout

\begin_layout Standard
This concludes the proof of the identity law.
\end_layout

\begin_layout Standard
To verify the composition law, we write (omitting types for brevity):
\begin_inset Formula 
\begin{align*}
 & \text{fmap}\,(f)\bef\text{fmap}\,(g)\\
 & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow f(h)\times\overline{\text{fmap}}\,(f)(t)
\end{array}\,\bef\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow g(h)\times\overline{\text{fmap}}\,(g)(t)
\end{array}\\
 & \quad\text{matrix composition}:\quad\\
 & =\,\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow g(f(h))\times\overline{\text{fmap}}\,(g)\big(\overline{\text{fmap}}\,(f)(t)\big)
\end{array}\quad.
\end{align*}

\end_inset

By the inductive assumption, the law already holds for recursive calls,
 which we denoted by 
\begin_inset Formula $\overline{\text{fmap}}$
\end_inset

:
\begin_inset Formula 
\[
\overline{\text{fmap}}\,(g)\big(\overline{\text{fmap}}\,(f)(t)\big)=t\triangleright\overline{\text{fmap}}\,(f)\bef\overline{\text{fmap}}\,(g)\overset{!}{=}t\triangleright\overline{\text{fmap}}\,(f\bef g)\quad.
\]

\end_inset

This allows us to complete the proof of the law:
\begin_inset Formula 
\[
\text{fmap}\,(f)\bef\text{fmap}\,(g)=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow(h\triangleright f\bef g)\times\overline{\text{fmap}}\,(f\bef g)(t)
\end{array}\,=\overline{\text{fmap}}\,(f\bef g)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-rec-poly-functor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-rec-poly-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a list of 
\emph on
odd
\emph default
 length as a recursive type constructor 
\begin_inset Formula $\text{LO}$
\end_inset

:
\begin_inset Formula 
\begin{align}
\text{LO}^{A} & \triangleq A+A\times A\times\text{LO}^{A}\label{eq:f-lo-def}\\
 & \cong A+A\times A\times A+A\times A\times A\times A\times A+...\quad,\nonumber 
\end{align}

\end_inset

and implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for it (without proving the laws).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The Scala definition of the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LO
\end_layout

\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait LO[A]
\end_layout

\begin_layout Plain Layout

final case class LO1[A](x: A)                    extends LO[A]
\end_layout

\begin_layout Plain Layout

final case class LO2[A](x: A, y: A, tail: LO[A]) extends LO[A]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 as a recursive function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): LO[A] => LO[B] = {
\end_layout

\begin_layout Plain Layout

  case LO1(x)            => LO1[B](f(x))
\end_layout

\begin_layout Plain Layout

  case LO2(x, y, tail)   => LO2[B](f(x), f(y), fmap(f)(tail))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 tail-recursive because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is called inside the case class constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LO2
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The type constructor 
\begin_inset Formula $\text{LO}$
\end_inset

 is a 
\series bold
recursive
\series default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functor!recursive
\end_layout

\end_inset


\series bold
polynomial
\series default
 
\series bold
functor
\series default
 because it is defined by a recursive type equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-lo-def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that uses only polynomial type constructions (
\begin_inset Quotes eld
\end_inset

sums and products
\begin_inset Quotes erd
\end_inset

) in its right-hand side.
 Other examples of recursive polynomial functors are lists and trees.
 We will prove later (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-recursive"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LO
\end_layout

\end_inset

 and other list-like and tree-like data types are lawful functors.
\end_layout

\begin_layout Subsection
Functor block expressions
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Computations with wrapped values often require a chain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val result = Map(1 -> 
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset

, 2 -> 
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset

, 3 -> 
\begin_inset Quotes eld
\end_inset

three
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Plain Layout

  map { case (i, name) => (i * i, name) }.
         // Compute i * i.
\end_layout

\begin_layout Plain Layout

  map { case (x, name) => (x, s
\begin_inset Quotes erd
\end_inset

$name * $name
\begin_inset Quotes erd
\end_inset

) }.
 // Compute product message.
\end_layout

\begin_layout Plain Layout

  map { case (x, product) => s
\begin_inset Quotes eld
\end_inset

$product is $x
\begin_inset Quotes erd
\end_inset

 }   // Compute final message.
\end_layout

\begin_layout Plain Layout

result: Seq[String] = List(one * one is 1, two * two is 4, three * three
 is 9)
\end_layout

\end_inset

Such code can be rewritten equivalently in the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block
\end_layout

\end_inset


\series bold
functor block
\series default
 syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val result = for {
\end_layout

\begin_layout Plain Layout

  (i, name) <- Map(1 -> "one", 2 -> "two", 3 -> "three") // For each (i,
 name):
\end_layout

\begin_layout Plain Layout

  x = i * i                           // define `x` by computing i * i...
\end_layout

\begin_layout Plain Layout

  product = s"$name * $name"          // define `product`...
\end_layout

\begin_layout Plain Layout

} yield s"$product is $x"             // and add this to the `result` sequence.
\end_layout

\begin_layout Plain Layout

result: Seq[String] = List(one * one is 1, two * two is 4, three * three
 is 9) 
\end_layout

\end_inset

Written in this way, the computations are easier to understand for two main
 reasons.
 First, there is less code to read and to write; no 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 and fewer curly braces.
 Second, values such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 need to be kept in tuples to pass them from one 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function to another, but any line in a functor block can directly reuse
 all values defined in previous lines.
 Let us look at this in more detail.
\end_layout

\begin_layout Standard
Scala's functor block syntax replaces a chain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods (as well as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods, as we will see in later chapters) by a visually clearer sequence
 of definitions and expressions.
 A functor block is denoted by the keywords 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

.
 We will see many examples of functor blocks throughout this book.
 In this chapter, we only consider functor blocks that are equivalent to
 a chain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operations on a functor value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p: L[A]
\end_layout

\end_inset

.
 These functor blocks can be recognized because they contain 
\emph on
only one
\emph default
 left arrow (in the first line).
 Here is how to replace a chain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operations by a functor block:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

p.map(x => f(x)).map(y => g(y)).map(z => h(z)) == for {
\end_layout

\begin_layout Plain Layout

   x <- p     // The first line must contain a left arrow.
\end_layout

\begin_layout Plain Layout

   y = f(x)   // Some computation involving x.
\end_layout

\begin_layout Plain Layout

   z = g(y)   // Another computation, uses y.
\end_layout

\begin_layout Plain Layout

} yield h(z)  // The `yield h(z)` replaces the inner result of the last
 `map`.
\end_layout

\end_inset

Translating functor blocks back into a chain of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operations is straightforward except that in some cases the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operations may need to create some intermediate tuples that are not needed
 in the functor block syntax.
 Consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: L[B] = for {
\end_layout

\begin_layout Plain Layout

  x <- p           // The first line must contain a left arrow.
\end_layout

\begin_layout Plain Layout

  y = f(x)         // Some computation involving x.
\end_layout

\begin_layout Plain Layout

  z = g(x, y)      // Another computation, uses x and y.
\end_layout

\begin_layout Plain Layout

} yield q(x, y, z) // The `yield` may use any defined variables.
\end_layout

\end_inset

The above functor block assumes that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(x, y, z)
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, and is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val result: L[B] = p
\end_layout

\begin_layout Plain Layout

  .map { x => (x, f(x)) }     // Create a tuple: we need to keep x and f(x).
\end_layout

\begin_layout Plain Layout

  .map { case (x, y) => (x, y, g(x, y)) } // Need to keep x, y, and g(x,
 y).
\end_layout

\begin_layout Plain Layout

  .map { case (x, y, z) => q(x, y, z) }   // Here we can use x, y, and z.
\end_layout

\end_inset

This code creates intermediate tuples only because the values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 need to be used in later calculations.
 The functor block code is easier to read, write, and modify than a chain
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

s with tuples.
 
\end_layout

\begin_layout Standard
If desired, functor blocks may be written in a single line by using semicolons
 to separate the individual steps:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for { x <- List(1, 2, 3); y = x * x; z = y + 2 } yield z
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(3, 6, 11)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A confusing feature of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

 / 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 syntax is that, at first sight, this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for { x <- p; ...
 } yield expr(x)
\end_layout

\end_inset

appears to compute the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(x)
\end_layout

\end_inset

 because the code says 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield expr(x)
\end_layout

\end_inset

.
 However, this is not so.
 As the above examples show, if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 is a sequence then the functor block also computes a 
\emph on
sequence
\emph default
; that will be a sequence of values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(x)
\end_layout

\end_inset

 for various 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 In general, the result of a functor block is a 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

 value, where the type of the 
\begin_inset Quotes eld
\end_inset

wrapper
\begin_inset Quotes erd
\end_inset

 is determined by the first line of the functor block.
 The first line must have a left arrow followed by a 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor block!source
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, which must be an expression of a functor type, i.e., of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

 for some functor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[_]
\end_layout

\end_inset

.
 The result's type will be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[B]
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 is the type of the expression after the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 keyword.
\end_layout

\begin_layout Standard
As another example, the first line of the following functor block contains
 the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(123)
\end_layout

\end_inset

 as the 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Quotes erd
\end_inset

.
 Because of that, the value of the entire functor block expression will
 also be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[...]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for {
\end_layout

\begin_layout Plain Layout

  x <- Some(123)   // 
\begin_inset Quotes eld
\end_inset

Source
\begin_inset Quotes erd
\end_inset

 is Option[Int].
\end_layout

\begin_layout Plain Layout

  y = (x - 3) / 10
\end_layout

\begin_layout Plain Layout

} yield { if (y > 0) s
\begin_inset Quotes eld
\end_inset

Have $y
\begin_inset Quotes erd
\end_inset

 else 
\begin_inset Quotes eld
\end_inset

Error
\begin_inset Quotes erd
\end_inset

 }
\end_layout

\begin_layout Plain Layout

res1: Option[String] = Some(Have 12)
\end_layout

\end_inset

In this code, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 keyword is followed by an expression of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 So, the result of the entire functor block is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[String]
\end_layout

\end_inset

.
 The expression after the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 can be a block of arbitrary code containing new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

s, new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

def
\end_layout

\end_inset

s, and other 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

for
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

yield
\end_layout

\end_inset

 functor blocks if needed.
\end_layout

\begin_layout Standard
Functor blocks can be used with any functor that has a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method, not only with library-defined type constructors such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

.
 Here are some examples of defining the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods and using functor blocks with disjunctive types.
\end_layout

\begin_layout Standard
The type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QueryResult
\end_layout

\end_inset

 may define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method on the trait itself and split its implementation between the case
 classes like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait QueryResult[A] {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): QueryResult[B] // No implementation here.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

case class Error[A](message: String) extends QueryResult[A] {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): QueryResult[B] = Error(message)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

case class Result[A](name: String, time: Long, data: A) extends QueryResult[A]
 {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): QueryResult[B] = Result(name, time, f(data))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

After these definitions, we can use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

QueryResult
\end_layout

\end_inset

 in functor blocks:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val q: QueryResult[Int] = Result(
\begin_inset Quotes eld
\end_inset

addresses
\begin_inset Quotes erd
\end_inset

, 123L, 10)
\end_layout

\begin_layout Plain Layout

scala> val result = for {
\end_layout

\begin_layout Plain Layout

  x <- q
\end_layout

\begin_layout Plain Layout

  y = x + 2
\end_layout

\begin_layout Plain Layout

} yield s
\begin_inset Quotes erd
\end_inset

$z addresses instead of $x
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

result: QueryResult[String] = Result(addresses,123,12 addresses instead
 of 10)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As another example, let us define the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method on the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LO
\end_layout

\end_inset

 trait (a recursive disjunctive type):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait LO[A] {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): LO[B]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

final case class LO1[A](x: A)                      extends LO[A] {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): LO[B] = LO1[B](f(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

final case class LO2[A](x: A, y: A, tail: LO[A])   extends LO[A] {
\end_layout

\begin_layout Plain Layout

  def map[B](f: A => B): LO[B] = LO2[B](f(x), f(y), tail.map(f))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

After these definitions, we may use values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

LO[...]
\end_layout

\end_inset

 in functor blocks:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val result = for {
\end_layout

\begin_layout Plain Layout

         x <- LO2("a", "quick", LO2("brown", "fox", LO1("jumped")))
\end_layout

\begin_layout Plain Layout

         y = x.capitalize
\end_layout

\begin_layout Plain Layout

         z = y + "/"
\end_layout

\begin_layout Plain Layout

       } yield (z, z.length)
\end_layout

\begin_layout Plain Layout

result: LO[(String, Int)] = LO2((A/,2),(Quick/,6),LO2((Brown/,6),(Fox/,4),LO1((J
umped/,7))))
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Functor blocks and functor laws
\end_layout

\begin_layout Standard
There is an important connection between the functor laws and the properties
 of code in functor blocks.
 Consider this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int) = x * x
\end_layout

\begin_layout Plain Layout

def g(x: Int) = x - 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> for {
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)
\end_layout

\begin_layout Plain Layout

  y = x
\end_layout

\begin_layout Plain Layout

  z = f(y)
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(99, 399, 899)
\end_layout

\end_inset

The code says that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = y
\end_layout

\end_inset

, so it appears reasonable to eliminate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 and simplify this code into:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for {
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)    // Eliminated `y` from the code.
\end_layout

\begin_layout Plain Layout

  z = f(x)
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(99, 399, 899)
\end_layout

\end_inset

Another example of a reasonable refactoring  is to combine transformations:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for {
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)
\end_layout

\begin_layout Plain Layout

  y = x + 1
\end_layout

\begin_layout Plain Layout

  z = f(y)
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(120, 440, 960) 
\end_layout

\end_inset

The code says that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = x + 1
\end_layout

\end_inset

, so we may want to replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(y)
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x + 1)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> for {
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)
\end_layout

\begin_layout Plain Layout

  z = f(x + 1)   // Eliminated `y` from the code.
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\begin_layout Plain Layout

res3: List[Int] = List(120, 440, 960) 
\end_layout

\end_inset

Looking at these code changes, we expect that the computed results will
 remain the same.
 Indeed, when the code directly states that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = y
\end_layout

\end_inset

, it would be confusing and counter-intuitive if the result value changed
 after replacing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 When the code says that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = x + 1
\end_layout

\end_inset

, ordinary mathematical reasoning suggests that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(y)
\end_layout

\end_inset

 can be replaced by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x + 1)
\end_layout

\end_inset

 without affecting the results.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="45text%">
<column alignment="center" valignment="top" width="45text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Functor block syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Chains of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {  // Fragment 1a.
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)
\end_layout

\begin_layout Plain Layout

  y = x
\end_layout

\begin_layout Plain Layout

  z = f(y)
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(10, 20, 30)  // Fragment 1b.
\end_layout

\begin_layout Plain Layout

  .map(x =>
\end_layout

\begin_layout Plain Layout

   x).map(y =>
\end_layout

\begin_layout Plain Layout

   f(y) ).map(z =>
\end_layout

\begin_layout Plain Layout

   g(z) )
\end_layout

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {  // Fragment 2a.
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)
\end_layout

\begin_layout Plain Layout

  z = f(x)
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(10, 20, 30)  // Fragment 2b.
\end_layout

\begin_layout Plain Layout

  .map(x =>
\end_layout

\begin_layout Plain Layout

   f(x) ).map(z =>
\end_layout

\begin_layout Plain Layout

   g(z) )
\end_layout

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {  // Fragment 3a.
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)
\end_layout

\begin_layout Plain Layout

  y = x + 1
\end_layout

\begin_layout Plain Layout

  z = f(y)
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(10, 20, 30)  // Fragment 3b.
\end_layout

\begin_layout Plain Layout

  .map(x =>
\end_layout

\begin_layout Plain Layout

   x + 1).map(y =>
\end_layout

\begin_layout Plain Layout

   f(y) ).map(z =>
\end_layout

\begin_layout Plain Layout

   g(z) )
\end_layout

\end_inset


\begin_inset VSpace -25baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {  // Fragment 4a.
\end_layout

\begin_layout Plain Layout

  x <- List(10, 20, 30)
\end_layout

\begin_layout Plain Layout

  z = f(x + 1)
\end_layout

\begin_layout Plain Layout

} yield g(z)
\end_layout

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length -2.78line%
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "106line%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

List(10, 20, 30)  // Fragment 4b.
\end_layout

\begin_layout Plain Layout

  .map(x =>
\end_layout

\begin_layout Plain Layout

   f(x + 1) ).map(z =>
\end_layout

\begin_layout Plain Layout

   g(z) )
\end_layout

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example translations of functor blocks into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods.
\begin_inset CommandInset label
LatexCommand label
name "tab:Example-translations-of-functor-blocks-into-map-methods"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To see the connection with the functor laws, we translate the functor block
 syntax line by line into chains of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods.
 The resulting code fragments are shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Example-translations-of-functor-blocks-into-map-methods"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The fragments using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods were split into lines to emphasize their close correspondence to
 functor blocks.
\end_layout

\begin_layout Standard
We find that code fragments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1b
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

2b
\end_layout

\end_inset

 are equal only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(x => x)
\end_layout

\end_inset

 does not modify the list to which it applies.
 This holds if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method obeys the functor identity law, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.map(identity) == p
\end_layout

\end_inset

, for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 of the appropriate type.
 We also find that code fragments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

3b
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

4b
\end_layout

\end_inset

 are equal if we can replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(x => x + 1).map(f)
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

.map(x => f(x + 1))
\end_layout

\end_inset

.
 This replacement is justified if the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method obeys the functor composition law:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

p.map(h).map(f) == p.map(x => f(h(x)))
\end_layout

\end_inset

for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 and functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of appropriate types.
\end_layout

\begin_layout Standard
Functor laws guarantee that we can correctly understand and modify code
 written in functor blocks, reasoning about transformations of values as
 we do in mathematics.
\end_layout

\begin_layout Subsection
Examples of non-functors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Examples-of-non-functors"

\end_inset


\end_layout

\begin_layout Standard
What properties of a data type make it a functor? To build an intuition,
 it is helpful to see examples of data types that are 
\emph on
not
\emph default
 functors.
\end_layout

\begin_layout Standard
There are several possibilities for a type constructor to fail being a functor:
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function's type signature cannot be implemented at all.
\end_layout

\begin_layout Itemize
A 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function can be implemented but cannot satisfy the functor laws.
\end_layout

\begin_layout Itemize
A given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function is incorrect (does not satisfy the laws), although the error could
 be fixed: a different implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 satisfies the laws.
\end_layout

\begin_layout Itemize
A given 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map[A, B]
\end_layout

\end_inset

 function satisfies the laws for some types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 but violates the laws for other 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We will now look at examples illustrating these possibilities.
\end_layout

\begin_layout Paragraph
Cannot implement 
\family typewriter
map
\family default
's type signature
\end_layout

\begin_layout Standard
Consider the type constructor 
\begin_inset Formula $H$
\end_inset

 defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class H[A](r: A => Int)
\end_layout

\end_inset


\begin_inset Formula 
\[
H^{A}\triangleq A\rightarrow\text{Int}\quad.
\]

\end_inset

The data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

H[A]
\end_layout

\end_inset

 does not wrap data of type 
\begin_inset Formula $A$
\end_inset

; instead, it is a function that 
\emph on
consumes
\emph default
 data of type 
\begin_inset Formula $A$
\end_inset

.
 Then, as it turns out, one cannot implement a fully parametric 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function with the required type signature:
\begin_inset Formula 
\[
\text{map}^{A,B}:\left(A\rightarrow\text{Int}\right)\rightarrow\left(A\rightarrow B\right)\rightarrow\left(B\rightarrow\text{Int}\right)\quad.
\]

\end_inset

To see this, recall that a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!function
\end_layout

\end_inset

fully parametric function needs to treat all types as type parameters.
 The code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: H[A] => (A => B) => H[B] = { r => f => C(_ => 123) }
\end_layout

\end_inset

satisfies the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 but is not fully parametric because it returns a specific value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, which is not allowed.
 Replacing the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 by a new type parameter 
\begin_inset Formula $N$
\end_inset

, we obtain the type signature:
\begin_inset Formula 
\[
\text{map}^{A,B,N}:\left(A\rightarrow N\right)\rightarrow\left(A\rightarrow B\right)\rightarrow B\rightarrow N\quad.
\]

\end_inset

We have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-solvedExample-6"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that this type signature cannot be implemented by fully parametric code.
 So, the type constructor 
\begin_inset Formula $H$
\end_inset

 is not a functor.
\end_layout

\begin_layout Standard
Another important example where the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

's type signature cannot be implemented are certain kinds of type constructors
 called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
generalized algebraic data types!see GADT
\end_layout

\end_inset


\series bold
generalized algebraic data types
\series default
 (
\series bold
GADT
\series default
s
\begin_inset Index idx
status open

\begin_layout Plain Layout
GADT|textit
\end_layout

\end_inset

).
 In this book we call a GADT a type constructor whose definition sets type
 parameters to specific types.
 This makes it impossible to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 An example of a GADT is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait ServerAction[R]
\end_layout

\begin_layout Plain Layout

final case class StoreId(x: Long, y: String) extends ServerAction[Boolean]
\end_layout

\begin_layout Plain Layout

final case class StoreName(name: String)     extends ServerAction[Int]
\end_layout

\end_inset

We see that the parts of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[R]
\end_layout

\end_inset

 do not carry the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R
\end_layout

\end_inset

 but instead set 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R
\end_layout

\end_inset

 to specific types: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R = Boolean
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R = Int
\end_layout

\end_inset

.
 As a consequence, the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StoreName
\end_layout

\end_inset

 has no type parameters and can only represent values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[Int]
\end_layout

\end_inset

 but not, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[String]
\end_layout

\end_inset

.
 Similarly, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StoreId
\end_layout

\end_inset

 represents only values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[Boolean]
\end_layout

\end_inset

.
 For this reason, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction
\end_layout

\end_inset

 cannot have a fully parametric 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: ServerAction[A] => (A => B) => ServerAction[B]
\end_layout

\end_inset

To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, we are required to support any choice of the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 For example, with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

, we must be able to transform the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

StoreName(
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[Int]
\end_layout

\end_inset

 to some value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[B]
\end_layout

\end_inset

 with 
\emph on
any
\emph default
 given type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 However, it is possible to create only values either of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[Boolean]
\end_layout

\end_inset

 or of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[Int]
\end_layout

\end_inset

, because the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[R]
\end_layout

\end_inset

 has only two parts with the specified types.
 So, we cannot create a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[B]
\end_layout

\end_inset

 with an arbitrary type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 For this reason, it is impossible to implement a fully parametric 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We are prevented from implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 because some type parameters are already set in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction
\end_layout

\end_inset

.
 One can say that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction
\end_layout

\end_inset

 fails to be fully parametric 
\emph on
in its type definition
\emph default
.
 This behavior of GADTs is intentional.
 GADTs are used only in situations where the lack of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 does not lead to problems.
\end_layout

\begin_layout Paragraph
Cannot implement a lawful 
\family typewriter
map
\end_layout

\begin_layout Standard
An example of a non-functor of this kind is:
\begin_inset Formula 
\[
Q^{A}\triangleq\left(A\rightarrow\text{Int}\right)\times A\quad.
\]

\end_inset

Here is the Scala code for this type constructor:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Q[A](q: A => Int, a: A)
\end_layout

\end_inset

A fully parametric 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function with the correct type signature 
\emph on
can
\emph default
 be implemented (and there is only one such implementation):
\begin_inset Formula 
\[
\text{map}^{A,B}\triangleq q^{:A\rightarrow\text{Int}}\times a^{:A}\rightarrow f^{:A\rightarrow B}\rightarrow(\_\rightarrow q(a))^{:B\rightarrow\text{Int}}\times f(a)\quad.
\]

\end_inset

The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: Q[A] => (A => B) => Q[B] = { qa => f =>
\end_layout

\begin_layout Plain Layout

  Q[B](_ => qa.q(qa.a), f(qa.a)) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function is fully parametric (since it treats the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 as a type parameter) and has the right type signature, but the functor
 laws do not hold.
 To show that the identity law fails, we take an arbitrary value 
\begin_inset Formula $q^{:A\rightarrow\text{Int}}\times a^{:A}$
\end_inset

 and compute:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }q\times a:\quad & \text{map}\,(q\times a)(\text{id})\\
\text{definition of }\text{map}:\quad & =(\_\rightarrow q(a))\times\gunderline{\text{id}\,(a)}\\
\text{definition of }\text{id}:\quad & =(\_\rightarrow q(a))\times a\\
\text{expanded function, }q=\left(x\rightarrow q(x)\right):\quad & \quad\neq q\times a=(x\rightarrow q(x))\times a\quad.
\end{align*}

\end_inset

The law must hold for arbitrary functions 
\begin_inset Formula $q^{:A\rightarrow\text{Int}}$
\end_inset

, but the function 
\begin_inset Formula $\left(\_\rightarrow q(a)\right)$
\end_inset

 always returns the same value 
\begin_inset Formula $q(a)$
\end_inset

 and is not equal to the original function 
\begin_inset Formula $q$
\end_inset

.
 So, the result of evaluating the expression 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{map}(q\times a)(\text{id})$
\end_inset


\begin_inset Quotes erd
\end_inset

 is not always equal to the original value 
\begin_inset Formula $q\times a$
\end_inset

.
 
\end_layout

\begin_layout Standard
Since this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function is the only available fully parametric implementation of the required
 type signature, we conclude that 
\begin_inset Formula $Q$
\end_inset

 is not a functor (we cannot implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 that satisfies the laws).
\end_layout

\begin_layout Paragraph
Mistakes in implementing 
\family typewriter
map
\end_layout

\begin_layout Standard
Non-functors of the third kind are type constructors with an incorrectly
 implemented 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 An example is  
\begin_inset Formula $P^{A}\triangleq A\times A$
\end_inset

 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function:
\begin_inset Formula 
\[
\text{map}\triangleq x^{:A}\times y^{:A}\rightarrow f^{:A\rightarrow B}\rightarrow f(y)\times f(x)\quad.
\]

\end_inset

Here is the Scala code corresponding to this code notation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](p: (A, A))(f: A => B): (B, B) = p match { case (x, y) => (f(y),
 f(x)) }
\end_layout

\end_inset

This code swaps the values in the pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x, y)
\end_layout

\end_inset

; it fails to preserve information about the order of those values.
 The functor identity law does not hold:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }x\times y:\quad & \text{map}\,(x^{:A}\times y^{:A})(\text{id}^{A})\\
\text{definition of }\text{map}:\quad & =\gunderline{\text{id}\,(y)}\times\gunderline{\text{id}\,(x)}\\
\text{definition of }\text{id}:\quad & =y\times x\neq x\times y\quad.
\end{align*}

\end_inset

We should not have swapped the order of values in the pair.
 The correct implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is:
\begin_inset Formula 
\[
\text{map}\triangleq x^{:A}\times y^{:A}\rightarrow f^{:A\rightarrow B}\rightarrow f(x)\times f(y)\quad.
\]

\end_inset

This code preserves information and satisfies the functor laws.
\end_layout

\begin_layout Standard
Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-A-A-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the type constructor 
\begin_inset Formula $\text{Vec}_{3}$
\end_inset

 with an incorrect implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 that reorders some parts of a tuple and duplicates other parts.
 The correct implementation preserves the order of parts in a tuple and
 neither duplicates nor omits any data.
\end_layout

\begin_layout Standard
Another case of an incorrect implementation is this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map_bad[A, B]: Option[A] => (A => B) => Option[B] = { _ => _ => None
 }
\end_layout

\end_inset

This function always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, losing information and violating the identity law.
 However, we have already seen that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 has a different implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 that satisfies the functor laws.
\end_layout

\begin_layout Standard
Similarly, one could define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 type constructor to always return an empty list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map_bad[A, B]: List[A] => (A => B) => List[B] = { _ => _ => List() }
\end_layout

\end_inset

This implementation loses information and violates the functor laws.
 Of course, the Scala library provides a correct implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-Int-x-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is another situation where an incorrectly implemented 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 violates functor laws.
\end_layout

\begin_layout Standard
Functor laws will also be violated when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is not fully parametric.
 For instance, consider an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap[A, B](f)
\end_layout

\end_inset

 that checks whether the two type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are equal to each other 
\emph on
as types
\emph default
, and if so, applies the function argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 twice.
 We need to use special features of Scala (
\begin_inset Index idx
status open

\begin_layout Plain Layout
type reflection
\end_layout

\end_inset

type reflection and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

TypeTag
\end_layout

\end_inset

) for comparing two type parameters at run time:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import scala.reflect.runtime.universe._
\end_layout

\begin_layout Plain Layout

def getType[T: TypeTag]: Type = weakTypeOf[T]
\end_layout

\begin_layout Plain Layout

def equalTypes[A: TypeTag, B: TypeTag]: Boolean = getType[A] =:= getType[B]
\end_layout

\begin_layout Plain Layout

def fmap_bad[A: TypeTag, B: TypeTag](f: A => B): Option[A] => Option[B]
 = {
\end_layout

\begin_layout Plain Layout

  case None      =>   None
\end_layout

\begin_layout Plain Layout

  case Some(x)   => // If A = B, compute f(f(x)), else compute f(x).
\end_layout

\begin_layout Plain Layout

    val z: B = if (equalTypes[A, B]) f(f(x).asInstanceOf[A]) else f(x)
\end_layout

\begin_layout Plain Layout

    Some(z)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Testing shows that this function works as designed:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fmap_bad[Int, String](_ + " a")(Some(123))       // Appends 
\begin_inset Quotes eld
\end_inset

 a
\begin_inset Quotes erd
\end_inset

 once.
\end_layout

\begin_layout Plain Layout

res0: Option[String] = Some(123 a)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap_bad[String, String](_ + " a")(Some("123"))  // Appends 
\begin_inset Quotes eld
\end_inset

 a
\begin_inset Quotes erd
\end_inset

 twice.
\end_layout

\begin_layout Plain Layout

res1: Option[String] = Some(123 a a)
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap_bad[A, B]
\end_layout

\end_inset

 satisfies the identity law but violates the composition law when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = B
\end_layout

\end_inset

.
 To see that, we use functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_ + 
\begin_inset Quotes eld
\end_inset

 a
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_ + 
\begin_inset Quotes eld
\end_inset

 b
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fmap_bad[String, String](_ + " b")(Some("123 a a"))
\end_layout

\begin_layout Plain Layout

res2: Option[String] = Some(123 a a b b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fmap_bad[String, String](_ + 
\begin_inset Quotes eld
\end_inset

 a b
\begin_inset Quotes erd
\end_inset

)(Some(
\begin_inset Quotes eld
\end_inset

123
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

res3: Option[String] = Some(123 a b a b)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all these examples, we 
\emph on
could
\emph default
 implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function that obeys the laws.
 When we say that, e.g., the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vec3
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

is a functor
\begin_inset Quotes erd
\end_inset

, we will mean
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
: being a functor depends on having a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function.
 Keeping that in mind, we will still say that the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Vec3
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

is
\begin_inset Quotes erd
\end_inset

 a functor, meaning
\end_layout

\end_inset

 that a lawful implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 can be found.
\end_layout

\begin_layout Paragraph
Laws hold for some types but not for others
\end_layout

\begin_layout Standard
The Scala standard library contains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods for the type constructors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set
\end_layout

\end_inset

 (transforming the values in a set) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map
\end_layout

\end_inset

 (transforming both the keys and values in a dictionary).
 However, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[K]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, V]
\end_layout

\end_inset

 fail to be lawful functors with respect to the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

.
 The reason for the failure is complicated.
 A value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[K]
\end_layout

\end_inset

 represents a set of zero or more values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

, and it is enforced that all values in the set are distinct.
 So, the correct functionality of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set
\end_layout

\end_inset

 requires us to be able to
\emph on
 
\emph default
check whether two values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 are equal.
 A standard way of comparing values for equality is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method defined in the Scala library:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala>  List(1, 2, 3).equals(List(1, 2, 3))
\end_layout

\begin_layout Plain Layout

res0: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala>  List(1, 2, 3).equals(List(1, 2, 3, 4))
\end_layout

\begin_layout Plain Layout

res1: Boolean = false
\end_layout

\end_inset

However, an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 operation will work as expected only if it obeys the 
\begin_inset CommandInset label
LatexCommand label
name "par:label-equality-laws"

\end_inset

laws of 
\series bold
identity
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of equality|textit
\end_layout

\end_inset

 (if 
\begin_inset Formula $x=y$
\end_inset

 then 
\begin_inset Formula $f(x)=f(y)$
\end_inset

 for any 
\begin_inset Formula $f$
\end_inset

), 
\series bold
symmetry
\series default
 (if 
\begin_inset Formula $x=y$
\end_inset

 then 
\begin_inset Formula $y=x$
\end_inset

)
\begin_inset Index idx
status open

\begin_layout Plain Layout
symmetry law of equality
\end_layout

\end_inset

, 
\series bold
reflexivity
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
reflexivity law|textit
\end_layout

\end_inset

 (
\begin_inset Formula $x=x$
\end_inset

 for any 
\begin_inset Formula $x$
\end_inset

), and 
\series bold
transitivity
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
transitivity law of equality
\end_layout

\end_inset

 (if 
\begin_inset Formula $x=y$
\end_inset

 and 
\begin_inset Formula $y=z$
\end_inset

 then 
\begin_inset Formula $x=z$
\end_inset

).
 In most practical applications, the required type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

) will have a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method.
 However, data types may redefine their 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method for application-specific purposes and violate some of those laws.
\end_layout

\begin_layout Standard
Here are two examples of law-breaking (but potentially useful) code for
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

.
 The first example
\begin_inset Foot
status open

\begin_layout Plain Layout
Based on a comment by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pawel@Paweł Szulc
\end_layout

\end_inset

Paweł Szulc at 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://gist.github.com/tpolecat/7401433"

\end_inset


\end_layout

\end_inset

 is a disjunctive type 
\begin_inset Formula $A+B$
\end_inset

 whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method allows only values of type 
\begin_inset Formula $A+\bbnum 0$
\end_inset

 to be equal:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class OnlyA[A, B](eab: Either[A, B]) {
\end_layout

\begin_layout Plain Layout

  override def equals(y: Any): Boolean = (eab, y) match {
\end_layout

\begin_layout Plain Layout

    case (Left(a1), OnlyA(Left(a2)))   => a1 == a2 // Values Left(a1) and
 Left(a2) might be equal.
\end_layout

\begin_layout Plain Layout

    case _                             => false    // Never equal if not
 both `Left`.
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 is mathematically invalid: it violates the reflexivity law (
\begin_inset Formula $\forall x.\,x=x$
\end_inset

) because values of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OnlyA
\end_layout

\end_inset

 are never equal to each other:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> OnlyA(Right(0)) equals OnlyA(Right(0))
\end_layout

\begin_layout Plain Layout

res2: Boolean = false
\end_layout

\end_inset

As a result, the library code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[OnlyA]
\end_layout

\end_inset

 will fail to detect that, e.g., several values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

OnlyA(Right(0))
\end_layout

\end_inset

 are equal.
 The composition law of functors will fail when intermediate values of that
 type are used:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: OnlyA[Int, Int] => Int = { case OnlyA(Left(a)) => a
\end_layout

\begin_layout Plain Layout

  case OnlyA(Right(a)) => a }
\end_layout

\begin_layout Plain Layout

val g: Int => OnlyA[Int, Int] = { a => OnlyA(Right(a)) }
\end_layout

\begin_layout Plain Layout

val xs = Seq(0, 0, 0).map(g).toSet
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> xs.map(f andThen g)  // `Set` fails to detect identical values.
\end_layout

\begin_layout Plain Layout

res3: Set[OnlyA[Int,Int]] = Set(OnlyA(Right(0)), OnlyA(Right(0)), OnlyA(Right(0)
))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> xs.map(f).map(g)     // `Set` detects identical values.
\end_layout

\begin_layout Plain Layout

res4: Set[OnlyA[Int,Int]] = Set(OnlyA(Right(0)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second example is a product type 
\begin_inset Formula $A\times B$
\end_inset

 whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method ignores the part of type 
\begin_inset Formula $B$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class IgnoreB[A, B](a: A, b: B) {
\end_layout

\begin_layout Plain Layout

  override def equals(y: Any): Boolean = y match {
\end_layout

\begin_layout Plain Layout

    case IgnoreB(a2, b2)   => a == a2  // Equal as long as the parts of
 type A are equal.
\end_layout

\begin_layout Plain Layout

    case _                 => false    // Never equal to a value of another
 type (not IgnoreB).
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> IgnoreB(123, "abc") == IgnoreB(123, "def")
\end_layout

\begin_layout Plain Layout

res5: Boolean = true
\end_layout

\end_inset

As a result, Scala's library code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[IgnoreB]
\end_layout

\end_inset

 will fail to detect that some values are different.
 This violates the functor composition law:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

val f: IgnoreB[Int, Int] => IgnoreB[Int, Int] = { case IgnoreB(x, y) =>
 IgnoreB(y, x) }  //  ${
\backslash
color{dkgreen} f 
\backslash
bef f = 
\backslash
textrm{id} }$
\end_layout

\begin_layout Plain Layout

val xs = Set(IgnoreB(0, 0), IgnoreB(1, 0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> xs.map(f andThen f)    // This is equal to `xs`.
\end_layout

\begin_layout Plain Layout

res6: Set[IgnoreB[Int,Int]] = Set(IgnoreB(0,0), IgnoreB(1,0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> xs.map(f).map(f)       // This is not equal to `xs`.
\end_layout

\begin_layout Plain Layout

res7: Set[IgnoreB[Int,Int]] = Set(IgnoreB(0,0))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The functor laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-identity-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-composition-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for a type constructor 
\begin_inset Formula $L$
\end_inset

 are imposed on the function:
\begin_inset Formula 
\[
\text{fmap}_{L}:\left(A\rightarrow B\right)\rightarrow L^{A}\rightarrow L^{B}\quad.
\]

\end_inset

The functor laws do not require that the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 should have an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method (or any other operation).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method of a functor 
\begin_inset Formula $L$
\end_inset

 must be 
\series bold
lawful
\series default
, i.e., must satisfy the functor laws for all types 
\begin_inset Formula $A,B$
\end_inset

.
\end_layout

\end_inset

 The functor laws must hold even if a type 
\begin_inset Formula $A$
\end_inset

's implementations of some other operations violate some other laws.
 For this reason, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set
\end_layout

\end_inset

 cannot be considered a functor in a rigorous sense.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for dictionaries has a similar problem: the keys of a dictionary
 must be distinct and will be compared using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method.
 So, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, V]
\end_layout

\end_inset

 will violate the functor laws unless the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 has a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 method.
\end_layout

\begin_layout Standard
The Scala standard library still provides the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 methods for sets 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Set[K]
\end_layout

\end_inset

 and dictionaries 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Map[K, V]
\end_layout

\end_inset

 because most applications will use types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

 that have a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

equals
\end_layout

\end_inset

 operation, and the functor laws will hold for those 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

K
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Contrafunctors"

\end_inset


\end_layout

\begin_layout Standard
As we have seen in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-non-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the type constructor 
\begin_inset Formula $H$
\end_inset

 defined by 
\begin_inset Formula $H^{A}\triangleq A\rightarrow\text{Int}$
\end_inset

 is not a functor because it is impossible to implement the type signature
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as a fully parametric function:
\begin_inset Formula 
\[
\text{map}^{A,B}:\left(A\rightarrow\text{Int}\right)\rightarrow\left(A\rightarrow B\right)\rightarrow B\rightarrow\text{Int}\quad.
\]

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To see why, begin writing the code with a typed hole:
\begin_inset Formula 
\[
\text{map}\,(h^{:A\rightarrow\text{Int}})(f^{:A\rightarrow B})(b^{:B})=\text{???}^{:\text{Int}}\quad.
\]

\end_inset

The only way of returning an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 in fully parametric code is by applying the function 
\begin_inset Formula $h^{:A\rightarrow\text{Int}}$
\end_inset

.
 Since 
\begin_inset Formula $h$
\end_inset

 consumes (rather than wraps) values of type 
\begin_inset Formula $A$
\end_inset

, we have no values of type 
\begin_inset Formula $A$
\end_inset

 and cannot apply the function 
\begin_inset Formula $h^{:A\rightarrow\text{Int}}$
\end_inset

.
 However, it is possible to apply a function of type 
\begin_inset Formula $B\rightarrow A$
\end_inset

 since a value of type 
\begin_inset Formula $B$
\end_inset

 is given as one of the curried arguments, 
\begin_inset Formula $b^{:B}$
\end_inset

.
 So, we can 
\end_layout

\end_inset

However, it is possible to implement a function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 with a different type signature ,where the function type is 
\begin_inset Formula $B\rightarrow A$
\end_inset

 instead of 
\begin_inset Formula $A\rightarrow B$
\end_inset

: 
\begin_inset Formula 
\[
\text{contramap}^{A,B}:\left(A\rightarrow\text{Int}\right)\rightarrow\left(B\rightarrow A\right)\rightarrow B\rightarrow\text{Int}\quad.
\]

\end_inset

The implementation of this function is written in the code notation as:
\begin_inset Formula 
\[
\text{contramap}\triangleq h^{:A\rightarrow\text{Int}}\rightarrow f^{:B\rightarrow A}\rightarrow\left(f\bef h\right)^{:B\rightarrow\text{Int}}\quad,
\]

\end_inset

and the corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def contramap[A, B](h: H[A])(f: B => A): H[B] = { f andThen h }
\end_layout

\end_inset

Flipping the order of the curried arguments in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

, we define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 as:
\begin_inset Formula 
\begin{align}
 & \text{cmap}^{A,B}:\left(B\rightarrow A\right)\rightarrow H^{A}\rightarrow H^{B}\quad,\nonumber \\
 & \text{cmap}\triangleq f^{:B\rightarrow A}\rightarrow h^{:A\rightarrow\text{Int}}\rightarrow\left(f\bef h\right)^{:B\rightarrow\text{Int}}\quad.\label{eq:f-example-1-contrafmap}
\end{align}

\end_inset

The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 has the form of a 
\begin_inset Quotes eld
\end_inset

reverse lifting
\begin_inset Quotes erd
\end_inset

: functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => A
\end_layout

\end_inset

 are lifted into the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

H[A] => H[B]
\end_layout

\end_inset

.
 The Scala code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cmap[A, B](f: B => A): H[A] => H[B] = { h => f andThen h } 
\end_layout

\end_inset

We can check that this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 satisfies two laws analogous to the functor laws
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of contrafunctors
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of contrafunctors
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \text{cmap}^{A,A}(\text{id}^{:A\rightarrow A})=\text{id}^{:H^{A}\rightarrow H^{A}}\quad,\\
\text{composition law}:\quad & \text{cmap}^{A,B}(f^{:B\rightarrow A})\bef\text{cmap}^{B,C}(g^{:C\rightarrow B})=\text{cmap}^{A,C}(g\bef f)\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3pc} & H^{B}\ar[rd]\sp(0.6){\ ~\text{cmap}_{H}(g^{:C\rightarrow B})}\\
H^{A}\ar[ru]\sp(0.4){\text{cmap}_{H}(f^{:B\rightarrow A})\ }\ar[rr]\sb(0.5){\text{cmap}_{H}(g^{:C\rightarrow B}\bef f^{:B\rightarrow A})\ ~} &  & H^{C}
}
\]

\end_inset

Since the function argument 
\begin_inset Formula $f^{:B\rightarrow A}$
\end_inset

 has the reverse order of types, the composition law needs the reverse order
 of composition 
\begin_inset Formula $\left(g\bef f\right)$
\end_inset

 on one side; in this way, all types match.
 To verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{cmap}\left(\text{id}\right)\\
\text{use Eq.~(\ref{eq:f-example-1-contrafmap})}:\quad & =h\rightarrow\gunderline{(\text{id}\bef h)}\\
\text{definition of }\text{id}:\quad & =\left(h\rightarrow h\right)=\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{cmap}\left(g\bef f\right):\quad & \text{cmap}\left(f\right)\bef\text{cmap}\left(g\right)\\
\text{use Eq.~(\ref{eq:f-example-1-contrafmap})}:\quad & =\left(h\rightarrow(f\bef h)\right)\bef(\gunderline h\rightarrow(g\bef\gunderline h))\\
\text{rename }h\text{ to }k\text{ for clarity}:\quad & =\left(h\rightarrow(f\bef h)\right)\bef\left(k\rightarrow(g\bef k)\right)\\
\text{compute composition}:\quad & =\left(h\rightarrow g\bef f\bef h\right)\\
\text{use Eq.~(\ref{eq:f-example-1-contrafmap})}:\quad & =\text{cmap}\left(g\bef f\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
A type constructor with a fully parametric 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 satisfying the identity law and the composition law is called a 
\series bold
contrafunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

 (short for 
\begin_inset Quotes eld
\end_inset

contravariant functor
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-contrafunctor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-contrafunctor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the type constructor 
\begin_inset Formula $D^{A}\triangleq A\rightarrow A\rightarrow\text{Int}$
\end_inset

 is a contrafunctor.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The required type signature for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def contramap[A, B](d: A => A => Int)(f: B => A): B => B => Int = ???
\end_layout

\end_inset

We begin implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 by writing code with a typed hole:
\begin_inset Formula 
\[
\text{contramap}^{A,B}\triangleq d^{:A\rightarrow A\rightarrow\text{Int}}\rightarrow f^{:B\rightarrow A}\rightarrow b_{1}^{:B}\rightarrow b_{2}^{:B}\rightarrow\text{???}^{:\text{Int}}\quad.
\]

\end_inset

To fill the typed hole, we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 The only possibility is to apply 
\begin_inset Formula $d$
\end_inset

 to two curried arguments of type 
\begin_inset Formula $A$
\end_inset

.
 We have two curried arguments of type 
\begin_inset Formula $B$
\end_inset

.
 So, we apply 
\begin_inset Formula $f^{:B\rightarrow A}$
\end_inset

 to those arguments, obtaining two values of type 
\begin_inset Formula $A$
\end_inset

.
 To avoid information loss, we need to preserve the order of the curried
 arguments.
 The resulting expression is:
\begin_inset Formula 
\[
\text{contramap}^{A,B}\triangleq d^{:A\rightarrow A\rightarrow\text{Int}}\rightarrow f^{:B\rightarrow A}\rightarrow b_{1}^{:B}\rightarrow b_{2}^{:B}\rightarrow d\left(f(b_{1})\right)\left(f(b_{2})\right)\quad.
\]

\end_inset

The corresponding Scala code is: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def contramap[A, B](d: A => A => Int)(f: B => A): B => B => Int = { b1 =>
 b2 => d(f(b1))(f(b2)) }
\end_layout

\end_inset

To verify the laws, it is easier to use the equivalent function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 defined by:
\begin_inset Formula 
\begin{equation}
\text{cmap}^{A,B}(f^{:B\rightarrow A})\triangleq d^{:A\rightarrow A\rightarrow\text{Int}}\rightarrow b_{1}^{:B}\rightarrow b_{2}^{:B}\rightarrow d\left(f(b_{1})\right)\left(f(b_{2})\right)\quad.\label{eq:f-example-2-contrafmap}
\end{equation}

\end_inset

To verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{cmap}\left(\text{id}\right)\\
\text{use Eq.~(\ref{eq:f-example-2-contrafmap})}:\quad & =d\rightarrow b_{1}\rightarrow b_{2}\rightarrow d\,\gunderline{\left(\text{id}\,(b_{1})\right)}\gunderline{\left(\text{id}\,(b_{2})\right)}\\
\text{definition of }\text{id}:\quad & =d\rightarrow\gunderline{b_{1}\rightarrow b_{2}\rightarrow d\left(b_{1}\right)\left(b_{2}\right)}\\
\text{simplify curried function}:\quad & =\left(d\rightarrow d\right)=\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law, we rewrite its left-hand side:
\begin_inset Formula 
\begin{align*}
 & \text{cmap}\,(f)\bef\text{cmap}\,(g)\\
 & \quad\text{use Eq.~(\ref{eq:f-example-2-contrafmap})}:\quad\\
 & =\left(d\rightarrow b_{1}\rightarrow b_{2}\rightarrow d\left(f(b_{1})\right)\left(f(b_{2})\right)\right)\bef(\gunderline d\rightarrow b_{1}\rightarrow b_{2}\rightarrow\gunderline d\left(g(b_{1})\right)\left(g(b_{2})\right))\\
 & \quad\text{rename }d\text{ to }e:\quad\\
 & =\left(d\rightarrow b_{1}\rightarrow b_{2}\rightarrow d\left(f(b_{1})\right)\left(f(b_{2})\right)\right)\bef\left(e\rightarrow b_{1}\rightarrow b_{2}\rightarrow e\left(g(b_{1})\right)\left(g(b_{2})\right)\right)\\
 & \quad\text{compute composition}:\quad\\
 & =d\rightarrow b_{1}\rightarrow b_{2}\rightarrow d\left(f(g(b_{1}))\right)\left(f(g(b_{2}))\right)\\
 & \quad\text{use Eq.~(\ref{eq:f-example-2-contrafmap})}:\quad\\
 & =\text{cmap}\,(b\rightarrow f(g(b)))\\
 & \quad\text{definition of }\left(g\bef f\right):\quad\\
 & =\text{cmap}\,(g\bef f)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The type 
\begin_inset Formula $H^{A}$
\end_inset

 represents a function that consumes a value of type 
\begin_inset Formula $A$
\end_inset

 to produce an integer; the type 
\begin_inset Formula $D^{A}$
\end_inset

 represents a curried function consuming 
\emph on
two
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

.
 These examples suggest the heuristic view that contrafunctors 
\begin_inset Quotes eld
\end_inset

consume
\begin_inset Quotes erd
\end_inset

 data while functors 
\begin_inset Quotes eld
\end_inset

wrap
\begin_inset Quotes erd
\end_inset

 data.
 By looking at the position of a given type parameter in a type expression
 such as 
\begin_inset Formula $A\times\text{Int}$
\end_inset

 or 
\begin_inset Formula $A\rightarrow A\rightarrow\text{Int}$
\end_inset

, we can see whether the type parameter is 
\begin_inset Quotes eld
\end_inset

consumed
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

: A type parameter to the left of a function arrow is being 
\begin_inset Quotes eld
\end_inset

consumed
\begin_inset Quotes erd
\end_inset

; a type parameter to the right of a function arrow (or used without a function
 arrow) is being 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

.
 We will make this intuition precise in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:f-Laws-and-structure"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Paragraph
Type constructors that are not contrafunctors 
\end_layout

\begin_layout Standard
A type constructor that both consumes 
\emph on
and
\emph default
 wraps data is neither a functor nor a contrafunctor.
 An example of such a type constructor is:
\begin_inset Formula 
\[
N^{A}\triangleq\left(A\rightarrow\text{Int}\right)\times\left(\bbnum 1+A\right)\quad.
\]

\end_inset

We can implement neither 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 nor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 for 
\begin_inset Formula $N$
\end_inset

.
 Intuitively, the type parameter 
\begin_inset Formula $A$
\end_inset

 is used both to the left of a function arrow (being 
\begin_inset Quotes eld
\end_inset

consumed
\begin_inset Quotes erd
\end_inset

) and outside of a function (being 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
GADTs
\begin_inset Index idx
status open

\begin_layout Plain Layout
GADT
\end_layout

\end_inset

 (type constructors that lack full parametricity) also cannot be contrafunctors
 because the required type signature for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

contramap
\end_layout

\end_inset

 cannot be implemented by a fully parametric function.
 To show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction
\end_layout

\end_inset

 cannot be a contrafunctor, we can straightforwardly adapt the reasoning
 used in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-non-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 when we showed that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction
\end_layout

\end_inset

 cannot be a functor.
\end_layout

\begin_layout Subsection
Subtyping, covariance, and contravariance
\begin_inset CommandInset label
LatexCommand label
name "subsec:Covariance,-contravariance,-and-subtyping"

\end_inset


\end_layout

\begin_layout Standard
Ordinarily, applying a function of type 
\begin_inset Formula $Q\rightarrow R$
\end_inset

 to a value of a different type 
\begin_inset Formula $P$
\end_inset

 is an error:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def h(q: Q): R = ???
\end_layout

\begin_layout Plain Layout

val p: P = ???
\end_layout

\begin_layout Plain Layout

h(p)         // Type error: expected type Q but found P.
\end_layout

\end_inset

However, the Scala compiler admits this kind of code when 
\begin_inset Formula $P$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

subtype
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Formula $Q$
\end_inset

.
 
\end_layout

\begin_layout Standard
Programming languages that support subtyping allow us to use a value of
 type 
\begin_inset Formula $P$
\end_inset

 in any expression instead of a value of type 
\begin_inset Formula $Q$
\end_inset

, when 
\begin_inset Formula $P$
\end_inset

 is a subtype of 
\begin_inset Formula $Q$
\end_inset

.
 Each programming language defines in some way what are the possible subtypes
 of every given type.
 
\end_layout

\begin_layout Standard
We may imagine that the language's compiler automatically converts values
 of type 
\begin_inset Formula $P$
\end_inset

 into values of type 
\begin_inset Formula $Q$
\end_inset

 using a fixed, compiler-provided 
\begin_inset Quotes eld
\end_inset

conversion function
\begin_inset Quotes erd
\end_inset

 of type 
\begin_inset Formula $P\rightarrow Q$
\end_inset

.
 It is convenient to 
\emph on
define
\emph default
 subtyping through the existence of a conversion function:
\end_layout

\begin_layout Subsubsection
Definition 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Definition-subtyping"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Definition-subtyping"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
A type 
\begin_inset Formula $P$
\end_inset

 is called a 
\series bold
subtype
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
types!subtyping
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping
\end_layout

\end_inset

 of a type 
\begin_inset Formula $Q$
\end_inset

 (denoted 
\begin_inset Formula $P\lesssim Q$
\end_inset

) if the compiler automatically inserts a designated
\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping!subtype conversion function|textit
\end_layout

\end_inset

 
\series bold
subtype conversion
\series default
 
\series bold
function
\series default
 of type 
\begin_inset Formula $P\rightarrow Q$
\end_inset

 whenever a value of type 
\begin_inset Formula $P$
\end_inset

 is used instead of a value of type 
\begin_inset Formula $Q$
\end_inset

.
 
\end_layout

\begin_layout Standard
Programming languages that support subtyping usually do not let programmers
 define subtype conversion functions explicitly.
 Nevertheless, whenever 
\begin_inset Formula $P\lesssim Q$
\end_inset

 we can recover the underlying conversion function 
\begin_inset Formula $c^{:P\rightarrow Q}$
\end_inset

 if we apply an identity function 
\begin_inset Formula $\text{id}^{:Q\rightarrow Q}$
\end_inset

 to a value of type 
\begin_inset Formula $P$
\end_inset

 (since we may use values of type 
\begin_inset Formula $P$
\end_inset

 instead of 
\begin_inset Formula $Q$
\end_inset

 in any expression).
 Then we find: 
\begin_inset Formula $c^{:P\rightarrow Q}\triangleq p^{:P}\rightarrow\text{id}^{:Q\rightarrow Q}(p)$
\end_inset

.
\end_layout

\begin_layout Standard
In most programming languages, the allowed subtype conversion functions
 do not transform any data but only reassign the types.
 Let us look at some examples of subtyping of that kind.
 
\end_layout

\begin_layout Standard
The first example uses disjunctive types.
 Consider this type definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait AtMostTwo
\end_layout

\begin_layout Plain Layout

final case class Zero()               extends AtMostTwo
\end_layout

\begin_layout Plain Layout

final case class One(x: Int)          extends AtMostTwo
\end_layout

\begin_layout Plain Layout

final case class Two(x: Int, y: Int)  extends AtMostTwo
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{AtMostTwo}\triangleq\bbnum 1+\text{Int}+\text{Int}\times\text{Int}\quad.
\]

\end_inset

Each of the case classes (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Zero
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

One
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Two
\end_layout

\end_inset

) defines a type that is a subtype of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AtMostTwo
\end_layout

\end_inset

.
 Let us write the conversion functions from each of the three case classes
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AtMostTwo
\end_layout

\end_inset

.
 These functions reassign the types but do not change any data:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f0: Zero => AtMostTwo  = { case Zero()      => Zero()    }
\end_layout

\begin_layout Plain Layout

def f1: One  => AtMostTwo  = { case One(x)      => One(x)    }
\end_layout

\begin_layout Plain Layout

def f2: Two  => AtMostTwo  = { case Two(x, y)   => Two(x, y) }
\end_layout

\end_inset

The implementations of these subtype conversions look like the code of identity
 functions except for the reassignment of types.
 In the matrix code notation, we write:
\size small

\begin_inset Formula 
\begin{align*}
f_{0} & \triangleq\,\begin{array}{|c||ccc|}
 & \text{Zero} & \text{One} & \text{Two}\\
\hline \text{Zero} & \text{id} & \bbnum 0 & \bbnum 0
\end{array}\quad,\quad\text{so}\quad f_{0}(1^{:\text{Zero}})\triangleq1^{:\text{Zero}}+\bbnum 0^{:\text{One}}+\bbnum 0^{:\text{Two}}\quad,\\
f_{1} & \triangleq\,\,\begin{array}{|c||ccc|}
 & \text{Zero} & \text{One} & \text{Two}\\
\hline \text{One} & \bbnum 0 & \text{id} & \bbnum 0
\end{array}\quad,\quad\text{so}\quad f_{1}(x^{:\text{One}})\triangleq\bbnum 0^{:\text{Zero}}+x^{:\text{One}}+\bbnum 0^{:\text{Two}}\quad,\\
f_{2} & \triangleq\,\begin{array}{|c||ccc|}
 & \text{Zero} & \text{One} & \text{Two}\\
\hline \text{Two} & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\quad,\quad\text{so}\quad f_{2}\big((x\times y)^{:\text{Two}}\big)\triangleq\bbnum 0^{:\text{Zero}}+\bbnum 0^{:\text{One}}+(x\times y)^{:\text{Two}}\quad.
\end{align*}

\end_inset


\size default
The matrix notation shows that the code contains just identity functions
 but reassigns the types.
\end_layout

\begin_layout Standard
Another example is  subtyping between 
\emph on
function
\emph default
 types.
 Consider these types 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type P = (AtMostTwo => Int)
\end_layout

\begin_layout Plain Layout

type Q = (Two => Int)
\end_layout

\end_inset

We can convert a function 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset Formula $P$
\end_inset

 into a function 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $Q$
\end_inset

 because 
\begin_inset Formula $f$
\end_inset

 includes all the information necessary to define 
\begin_inset Formula $g$
\end_inset

.
 The Scala code for that subtype conversion is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p2q(f: P): Q = { t: Two => f(t) }
\end_layout

\end_inset

This is written in the code notation as:
\begin_inset Formula 
\[
\text{p2q}\,(f^{:\text{AtMostTwo}\rightarrow\text{Int}})\triangleq t^{:\text{Two}}\rightarrow f(t)\quad.
\]

\end_inset

Compare the code 
\begin_inset Formula $\text{p2q}\,(f)=t^{:\text{Two}}\rightarrow f(t)$
\end_inset

 with the code of an identity function, 
\begin_inset Formula $\text{id}\left(f\right)=f=t\rightarrow f(t)$
\end_inset

.
 We see that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2q
\end_layout

\end_inset

 an identity function that just reassigns the type of its argument to be
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Two
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In these cases, it is easy for the compiler to insert the appropriate conversion
 functions automatically whenever necessary.
 Any function that consumes an argument of type 
\begin_inset Formula $Q$
\end_inset

 will be then automatically compatible with arguments of type 
\begin_inset Formula $P$
\end_inset

.
 The compiler does not actually need to insert any new code, since the code
 of conversion functions does not perform any data transformations.
\end_layout

\begin_layout Standard
For this to work, we need to tell the Scala compiler that a certain type
 is a subtype of another.
 This can be done in three ways depending on the situation: First, one may
 declare a class that 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extends
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 another class.
 Second, one may declare type parameters with a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
variance annotation
\end_layout

\end_inset


\series bold
variance annotation
\series default
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[+A]
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[-B]
\end_layout

\end_inset

.
 Third, one may declare type parameters with a 
\series bold
subtyping annotation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping annotation
\end_layout

\end_inset

 (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A <: B
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Parts of a disjunctive type are subtypes of that type since they are declared
 via the keyword 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

extends
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 A
\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping!for disjunctive types
\end_layout

\end_inset

 function with argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AtMostTwo
\end_layout

\end_inset

 can be applied to a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Two
\end_layout

\end_inset

 with no additional code written by the programmer:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def head: AtMostTwo => Option[Int] = {
\end_layout

\begin_layout Plain Layout

  case Zero()      => None
\end_layout

\begin_layout Plain Layout

  case One(x)      => Some(x)
\end_layout

\begin_layout Plain Layout

  case Two(x, y)   => Some(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> head(Two(10, 20))
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(10)
\end_layout

\end_inset

We may imagine that the compiler automatically uses the subtype conversion
 function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 shown above to convert a value of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Two
\end_layout

\end_inset

 into a value of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

AtMostTwo
\end_layout

\end_inset

.
 Since the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is equivalent to an identity function, this conversion does not change
 any data and only reassigns some types.
 So, the compiler will not need to insert any additional machine code.
 The subtype conversion does not lead to any decrease in performance.
\end_layout

\begin_layout Standard
The void type (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, denoted by 
\begin_inset Formula $\bbnum 0$
\end_inset

 in the type notation) is special:
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type
\end_layout

\end_inset

 it is a subtype of 
\emph on
every
\emph default
 type 
\begin_inset Formula $A$
\end_inset

.
 The reason is that the type 
\begin_inset Formula $\bbnum 0$
\end_inset

 has 
\emph on
no
\emph default
 values, so the conversion function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

absurd
\end_layout

\end_inset

 
\begin_inset Formula $:\bbnum 0\rightarrow A$
\end_inset

 (shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch-Example-type-identity-0-to-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

) exists but never actually needs to be applied.
 The Scala compiler recognizes this automatically.
\end_layout

\begin_layout Standard
Let us now consider subtyping for type constructors.
 If a type constructor 
\begin_inset Formula $L^{A}$
\end_inset

 is a functor, we can use its 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

 method to lift a subtype conversion function 
\begin_inset Formula $f:P\rightarrow Q$
\end_inset

 into:
\begin_inset Formula 
\[
\text{fmap}_{L}(f):L^{P}\rightarrow L^{Q}\quad,
\]

\end_inset

which gives a subtype conversion function from 
\begin_inset Formula $L^{P}$
\end_inset

 to 
\begin_inset Formula $L^{Q}$
\end_inset

.
 So, it makes sense to define subtyping as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[P] <: L[Q]
\end_layout

\end_inset

 between the types 
\begin_inset Formula $L^{P}$
\end_inset

 and 
\begin_inset Formula $L^{Q}$
\end_inset

.
 If 
\begin_inset Formula $f$
\end_inset

's code is an identity  function then 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

's code is also an identity function because 
\begin_inset Formula $\text{fmap}_{L}(\text{id})=\text{id}$
\end_inset

 (the functor 
\begin_inset Formula $L$
\end_inset

's identity law).
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\bbnum 0$
\end_inset

 is a subtype of any type 
\begin_inset Formula $A$
\end_inset

, the type 
\begin_inset Formula $F^{\bbnum 0}$
\end_inset

 is a subtype of 
\begin_inset Formula $F^{A}$
\end_inset

 for any functor 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Standard
If a type constructor 
\begin_inset Formula $H^{A}$
\end_inset

 is a contrafunctor, a subtype conversion function 
\begin_inset Formula $f^{:P\rightarrow Q}$
\end_inset

 is lifted to:
\begin_inset Formula 
\[
\text{cmap}_{H}(f):H^{Q}\rightarrow H^{P}\quad,
\]

\end_inset

showing that 
\begin_inset Formula $H^{Q}$
\end_inset

 is a subtype of 
\begin_inset Formula $H^{P}$
\end_inset

.
 The identity law of the contrafunctor 
\begin_inset Formula $H$
\end_inset

,
\begin_inset Formula 
\[
\text{cmap}_{H}(\text{id})=\text{id}\quad,
\]

\end_inset

shows that the lifted conversion function is again an identity function
 (with reassigned types).
\end_layout

\begin_layout Standard
A type constructor 
\begin_inset Formula $F$
\end_inset

 is called 
\series bold
subtype-covariant
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type constructor!subtype-covariant
\end_layout

\end_inset

 if 
\begin_inset Formula $F^{A}$
\end_inset

 is a subtype of 
\begin_inset Formula $F^{B}$
\end_inset

 whenever 
\begin_inset Formula $A$
\end_inset

 is a subtype of 
\begin_inset Formula $B$
\end_inset

.
 A 
\series bold
subtype-contravariant
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type constructor!subtype-contravariant
\end_layout

\end_inset

 type constructor 
\begin_inset Formula $H$
\end_inset

 performs subtyping in the opposite direction: 
\begin_inset Formula $H^{B}$
\end_inset

 is a subtype of 
\begin_inset Formula $H^{A}$
\end_inset

.
 It follows that all functors would be subtype-covariant and all contrafunctors
 subtype-contravariant
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The word 
\begin_inset Quotes eld
\end_inset


\series bold
contrafunctor
\series default

\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
contrafunctor
\end_layout

\end_inset

 is used in this book as a shortened form of 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
contravariant functor!see 
\begin_inset Quotes eld
\end_inset

contrafunctor
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

contravariant functor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 if the compiler automatically lifted the type conversion functions as required
 using the appropriate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 methods.
 The Scala compiler 
\emph on
does
\emph default
 determine whether a given type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

 is covariant or contravariant, but the features of subtype-co(ntra)variance
 are not activated automatically.
 To do that, the programmer needs to use a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
variance annotation
\end_layout

\end_inset


\series bold
variance annotation
\series default
, which looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[+A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For example, the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Functors:-definition-and-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is a functor (has a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method), and so it is covariant.
 If we write the variance annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[+A]
\end_layout

\end_inset

 in the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

, Scala will activate the subtype covariance for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

.
 Then, for example, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[Two]
\end_layout

\end_inset

 will be automatically recognized a subtype of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[AtMostTwo]
\end_layout

\end_inset

.
 We will be able to use values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[Two]
\end_layout

\end_inset

 in place of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[AtMostTwo]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Counted[+A](n: Int, a: A)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def total(c: Counted[AtMostTwo]): Int = c match {
\end_layout

\begin_layout Plain Layout

  case Counted(n, Zero())      => 0
\end_layout

\begin_layout Plain Layout

  case Counted(n, One(_))      => n
\end_layout

\begin_layout Plain Layout

  case Counted(n, Two(_, _))   => n * 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> total(Counted(2, Two(10, 20)))
\end_layout

\begin_layout Plain Layout

res1: Int = 4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The subtype-contravariance property is annotated as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[-A]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is important that the covariance/contravariance properties of a type
 constructor are determined by its type structure alone, regardless of variance
 annotations or subtyping.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[A]
\end_layout

\end_inset

 is covariant because we may implement a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

.
 (This property holds also in programming languages that do not support
 subtyping.) The variance annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted[+A]
\end_layout

\end_inset

 merely tells the Scala compiler to activate the automatic subtyping features
 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

.
 Before doing that, the Scala compiler will check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Counted
\end_layout

\end_inset

 is in fact covariant.
 It will be a type error if a variance annotation specified by the programmer
 does not match the actual covariance or contravariance of the type constructor:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Counted[-A](n: Int, a: A)  // Compile-time error.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

final case class C[+A](run: A => Unit)      // Compile-time error.
\end_layout

\end_inset

The type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is in fact contravariant; this can be verified by implementing a lawful
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 function for it.
 The Scala compiler will accept a contravariance annotation on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 if we choose to write it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class C[-A](run: A => Unit)   // OK
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A type constructor with several type parameters may be covariant with respect
 to some of them and contravariant with respect to others.
 Intuitively, the data type 
\begin_inset Quotes eld
\end_inset

wraps
\begin_inset Quotes erd
\end_inset

 covariant types but 
\begin_inset Quotes eld
\end_inset

consumes
\begin_inset Quotes erd
\end_inset

 contravariant ones.
 So far, we have seen examples suggesting that a type parameter to the right
 of function arrows, or without function arrows, is 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

 (used in a 
\series bold
covariant position
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
covariant position
\end_layout

\end_inset

).
 Type parameters to the left of function arrows are 
\begin_inset Quotes eld
\end_inset

consumed
\begin_inset Quotes erd
\end_inset

 (used in a 
\series bold
contravariant position
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
contravariant position
\end_layout

\end_inset

).
 The next examples confirm this intuition, which will be made rigorous in
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Solved-examples:-How-to-recognize-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Examples: implementing functors and contrafunctors
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-functors"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider this implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](p: Option[A])(f: A => B): Option[B] = p match {
\end_layout

\begin_layout Plain Layout

  case None           => None
\end_layout

\begin_layout Plain Layout

  case Some(x: Int)   => Some(f((x + 1).asInstanceOf[A]))
\end_layout

\begin_layout Plain Layout

  case Some(x)        => Some(f(x))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This code performs a non-standard computation if the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is set to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 Show that this implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 does not obey the functor laws.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
If the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 is not 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or if the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

, the given code is the same as the standard (correct) implementation of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

.
 The function does something non-standard when, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p == Some(123)
\end_layout

\end_inset

.
 Substitute this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 into the identity law, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(p)(identity) == p
\end_layout

\end_inset

, and compute symbolically (using Scala syntax):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

map(p)(identity) == Some(identity((123+1).asInstanceOf[Int])) == Some(124)
 != p
\end_layout

\end_inset

This shows a violation of the functor identity law: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some(124) != Some(123)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-functors-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-functors-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define case classes and implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for the given type constructors:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{Data}^{A}\triangleq\text{String}+A\times\text{Int}+A\times A\times A\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{Data}^{A}\triangleq\bbnum 1+A\times(\text{Int}\times\text{String}+A)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\text{Data}^{A}\triangleq(\text{String}\rightarrow\text{Int}\rightarrow A)\times A+(\text{Boolean}\rightarrow\text{Double}\rightarrow A)\times A\quad.$
\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Begin by defining a case class for each part of the disjunctive type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Data[A] 
\end_layout

\begin_layout Plain Layout

final case class Message[A](message: String)  extends Data[A]
\end_layout

\begin_layout Plain Layout

final case class Have1[A](x: A, n: Int)       extends Data[A]  
\end_layout

\begin_layout Plain Layout

final case class Have3[A](x: A, y: A, z: A)   extends Data[A]
\end_layout

\end_inset

The names 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Message
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Have1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Have3
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 are chosen arbitrarily.
 
\end_layout

\begin_layout Standard
The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 must have this type signature:
\begin_inset Formula 
\[
\text{fmap}^{A,B}:\left(A\rightarrow B\right)\rightarrow\text{Data}^{A}\rightarrow\text{Data}^{B}\quad,\quad\quad\text{fmap}\,(f^{:A\rightarrow B})=\text{???}\quad.
\]

\end_inset

To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 correctly, we need to transform each part of the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data[A]
\end_layout

\end_inset

 into the corresponding part of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data[B]
\end_layout

\end_inset

 without loss of information.
 To clarify where the transformation 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 need to be applied, let us write the type notation for 
\begin_inset Formula $\text{Data}^{A}$
\end_inset

 and 
\begin_inset Formula $\text{Data}^{B}$
\end_inset

 side by side:
\begin_inset Formula 
\begin{align*}
\text{Data}^{A} & \triangleq\text{String}+A\times\text{Int}+A\times A\times A\quad,\\
\text{Data}^{B} & \triangleq\text{String}+B\times\text{Int}+B\times B\times B\quad.
\end{align*}

\end_inset

Now it is clear that we need to apply 
\begin_inset Formula $f$
\end_inset

 to each value of type 
\begin_inset Formula $A$
\end_inset

 present in 
\begin_inset Formula $\text{Data}^{A}$
\end_inset

, preserving the order of values.
 The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Data[A] => Data[B] = {
\end_layout

\begin_layout Plain Layout

  case Message(message)   => Message(message)
\end_layout

\begin_layout Plain Layout

  case Have1(x, n)        => Have1(f(x), n)
\end_layout

\begin_layout Plain Layout

  case Have3(x, y, z)     => Have3(f(x), f(y), f(z))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 It is convenient to name the type 
\begin_inset Formula $\text{Int}\times\text{String}+A$
\end_inset

 as, say, 
\begin_inset Formula $P^{A}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait P[A]
\end_layout

\begin_layout Plain Layout

final case class Message[A](code: Int, message: String)  extends P[A]
\end_layout

\begin_layout Plain Layout

final case class Value[A](x: A)                          extends P[A]
\end_layout

\end_inset

Now we notice that the type expression 
\begin_inset Formula $\left(\bbnum 1+...\right)$
\end_inset

 can be encoded via the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 type.
 So, the Scala code for 
\begin_inset Formula $\text{Data}^{A}$
\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class Data[A](d: Option[(A, P[A])])
\end_layout

\end_inset

To make sure we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 correctly, let us write out the type expressions:
\begin_inset Formula 
\begin{align*}
\text{Data}^{A} & \triangleq\bbnum 1+A\times(\text{Int}\times\text{String}+A)\quad,\\
\text{Data}^{B} & \triangleq\bbnum 1+B\times(\text{Int}\times\text{String}+B)\quad.
\end{align*}

\end_inset

Now we can transform 
\begin_inset Formula $\text{Data}^{A}$
\end_inset

 into 
\begin_inset Formula $\text{Data}^{B}$
\end_inset

 by applying 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 at the correct places:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Data[A] => Data[B] = {
\end_layout

\begin_layout Plain Layout

  case Data(None)                                => Data(None)
\end_layout

\begin_layout Plain Layout

  case Data(Some((x, Message(code, message))))   => Data(Some((f(x), Message(cod
e, message))))
\end_layout

\begin_layout Plain Layout

  case Data(Some((x, Value(y))))                 => Data(Some((f(x), Value(f(y))
)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

When deeply nested patterns become hard to read, we may handle the nested
 structure separately:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Data[A] => Data[B] = {
\end_layout

\begin_layout Plain Layout

  case Data(None)           => Data(None)
\end_layout

\begin_layout Plain Layout

  case Data(Some((x, p)))   =>
\end_layout

\begin_layout Plain Layout

      val newP: P[B] = p match {
\end_layout

\begin_layout Plain Layout

        case Message(code, message)   => Message(code, message)
\end_layout

\begin_layout Plain Layout

        case Value(x)                 => Value(f(x))
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      Data(Some((f(x), newP)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 Since the types 
\begin_inset Formula $(\text{String}\rightarrow\text{Int}\rightarrow A)\times A$
\end_inset

 and 
\begin_inset Formula $(\text{Boolean}\rightarrow\text{Double}\rightarrow A)\times A$
\end_inset

 share a similar pattern, let us define a new parameterized type:
\begin_inset Formula 
\[
Q^{X,Y,A}\triangleq\left(X\rightarrow Y\rightarrow A\right)\times A\quad,
\]

\end_inset

and rewrite the given type expression 
\begin_inset Formula $\text{Data}^{A}$
\end_inset

 as:
\begin_inset Formula 
\[
\text{Data}^{A}=Q^{\text{String},\text{Int},A}+Q^{\text{Boolean},\text{Double},A}\quad.
\]

\end_inset

We can then define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data[A]
\end_layout

\end_inset

 using the standard disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Q[X, Y, A] = (X => Y => A, A)
\end_layout

\begin_layout Plain Layout

type Data[A] = Either[Q[String, Int, A], Q[Boolean, Double, A]]
\end_layout

\end_inset

For clarity, we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 separately for 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $\text{Data}$
\end_inset

.
\end_layout

\begin_layout Standard
To derive the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for 
\begin_inset Formula $Q$
\end_inset

, we begin with the type signature:
\begin_inset Formula 
\[
\text{fmap}_{Q}^{A,B}:\left(A\rightarrow B\right)\rightarrow\left(X\rightarrow Y\rightarrow A\right)\times A\rightarrow\left(X\rightarrow Y\rightarrow B\right)\times B\quad,
\]

\end_inset

and start writing the code using typed holes:
\begin_inset Formula 
\[
\text{fmap}_{Q}(f^{:A\rightarrow B})\triangleq g^{:X\rightarrow Y\rightarrow A}\times a^{:A}\rightarrow\text{???}^{:X\rightarrow Y\rightarrow B}\times\text{???}^{:B}\quad.
\]

\end_inset

The typed hole 
\begin_inset Formula $\text{???}^{:B}$
\end_inset

 is filled by 
\begin_inset Formula $f(a)$
\end_inset

.
 To fill the type hole 
\begin_inset Formula $\text{???}^{:X\rightarrow Y\rightarrow B}$
\end_inset

, we write:
\begin_inset Formula 
\begin{align*}
 & \text{???}^{:X\rightarrow Y\rightarrow B}\\
 & =x^{:X}\rightarrow y^{:Y}\rightarrow\gunderline{\text{???}^{:B}}\\
 & =x^{:X}\rightarrow y^{:Y}\rightarrow f(\text{???}^{:A})\quad.
\end{align*}

\end_inset

It would be wrong to fill the typed hole 
\begin_inset Formula $\text{???}^{:A}$
\end_inset

 by 
\begin_inset Formula $a^{:A}$
\end_inset

 because, to preserve information, a value of type 
\begin_inset Formula $X\rightarrow Y\rightarrow B$
\end_inset

 should be computed using the given data 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset Formula $X\rightarrow Y\rightarrow A$
\end_inset

.
 So, we write:
\begin_inset Formula 
\[
\text{???}^{:X\rightarrow Y\rightarrow B}=x^{:X}\rightarrow y^{:Y}\rightarrow f(g(x)(y))\quad.
\]

\end_inset

The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_Q[A, B, X, Y](f: A => B): Q[X, Y, A] => Q[X, Y, B] = {
\end_layout

\begin_layout Plain Layout

  case (g, a) => (x => y => f(g(x)(y)), f(a))
\end_layout

\begin_layout Plain Layout

  // Could also write the code as:
\end_layout

\begin_layout Plain Layout

  //   case (g, a) => (x => g(x) andThen f, f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Finally, we can write the code for 
\begin_inset Formula $\text{fmap}_{\text{Data}}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_Data[A, B](f: A => B): Data[A] => Data[B] = {
\end_layout

\begin_layout Plain Layout

  case Left(q)    => Left(fmap_Q(f)(q))
\end_layout

\begin_layout Plain Layout

  case Right(q)   => Right(fmap_Q(f)(q))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The Scala compiler will automatically infer the type parameters required
 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap_Q
\end_layout

\end_inset

 and check that all types match.
 With all inferred types written out, the code above becomes:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_Data[A, B](f: A => B): Data[A] => Data[B] = {
\end_layout

\begin_layout Plain Layout

  case Left(q: Q[String, Int, A])            =>
\end_layout

\begin_layout Plain Layout

         Left[Q[String, Int, B]](fmap_Q[A, B, String, Int](f)(q))
\end_layout

\begin_layout Plain Layout

  case Right(q: Q[Boolean, Double, A])       =>
\end_layout

\begin_layout Plain Layout

         Right[Q[Boolean, Double, B]](fmap_Q[A, B, Boolean, Double](f)(q))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

When types become complicated, it may help to write out some of the type
 parameters in the code.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-functors-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-functors-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Decide whether these types are functors or contrafunctors, and implement
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 as appropriate:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{Data1}^{A}\triangleq\left(\bbnum 1+A\rightarrow\text{Int}\right)+(A\rightarrow A\times A\rightarrow\text{String})\quad.$
\end_inset

 
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{Data2}^{A,B}\triangleq\left(A+B\right)\times\left(\left(A\rightarrow\text{Int}\right)\rightarrow B\right)\quad.$
\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data1
\end_layout

\end_inset

 is defined in Scala as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Data1[A] = Either[Option[A] => Int, A => ((A, A)) => String]
\end_layout

\end_inset

The type parameter 
\begin_inset Formula $A$
\end_inset

 is always located to the left of function arrows.
 So, 
\begin_inset Formula $\text{Data1}^{A}$
\end_inset

 
\emph on
consumes
\emph default
 values of type 
\begin_inset Formula $A$
\end_inset

, and we expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data1
\end_layout

\end_inset

 is a contrafunctor.
 Indeed, we can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cmap[A, B](f: B => A): Data1[A] => Data1[B] = {
\end_layout

\begin_layout Plain Layout

  case Left(oa2Int)        => Left(b => oa2Int(b.map(f)))
\end_layout

\begin_layout Plain Layout

  case Right(a2aa2Str)     => Right( b1 => { case (b2, b3) => a2aa2Str(f(b1))((f
(b2), f(b3))) } )
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Data2
\end_layout

\end_inset

 has two type parameters, and so we need to answer the question separately
 for each of them.
 Write the Scala type definition:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Data2[A, B] = (Either[A, B], (A => Int) => B)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Begin with the type parameter 
\begin_inset Formula $A$
\end_inset

 and notice that a value of type 
\begin_inset Formula $\text{Data2}^{A,B}$
\end_inset

 possibly contains a value of type 
\begin_inset Formula $A$
\end_inset

 within 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, B]
\end_layout

\end_inset

.
 In other words, 
\begin_inset Formula $A$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

wrapped
\begin_inset Quotes erd
\end_inset

, i.e., it is in a covariant position within the first part of the tuple.
 It remains to check the second part of the tuple, which is a higher-order
 function of type 
\begin_inset Formula $\left(A\rightarrow\text{Int}\right)\rightarrow B$
\end_inset

.
 That function consumes a function of type 
\begin_inset Formula $A\rightarrow\text{Int}$
\end_inset

, which in turn consumes a value of type 
\begin_inset Formula $A$
\end_inset

.
 Consumers of 
\begin_inset Formula $A$
\end_inset

 are contravariant in 
\begin_inset Formula $A$
\end_inset

, but it turns out that a 
\begin_inset Quotes eld
\end_inset

consumer of a consumer of 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 is 
\emph on
covariant
\emph default
 in 
\begin_inset Formula $A$
\end_inset

.
 So, we expect to be able to implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 that applies to the type parameter 
\begin_inset Formula $A$
\end_inset

 of 
\begin_inset Formula $\text{Data2}^{A,B}$
\end_inset

.
 Renaming the type parameter 
\begin_inset Formula $B$
\end_inset

 to 
\begin_inset Formula $Z$
\end_inset

 for clarity, we write the type signature for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 like this:
\begin_inset Formula 
\[
\text{fmap}^{A,C,Z}:\left(A\rightarrow C\right)\rightarrow\left(A+Z\right)\times\left(\left(A\rightarrow\text{Int}\right)\rightarrow Z\right)\rightarrow\left(C+Z\right)\times\left(\left(C\rightarrow\text{Int}\right)\rightarrow Z\right)\quad.
\]

\end_inset

We need to transform each part of the tuple separately.
 Transforming 
\begin_inset Formula $A+Z$
\end_inset

 into 
\begin_inset Formula $C+Z$
\end_inset

 is straightforward via the function:
\begin_inset Formula 
\[
\begin{array}{|c||cc|}
 & C & Z\\
\hline A & f & \bbnum 0\\
Z & \bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset

This code notation corresponds to the following Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  case Left(x)    => Left(f(x))
\end_layout

\begin_layout Plain Layout

  case Right(z)   => Right(z)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

To derive code transforming 
\begin_inset Formula $\left(A\rightarrow\text{Int}\right)\rightarrow Z$
\end_inset

 into 
\begin_inset Formula $\left(C\rightarrow\text{Int}\right)\rightarrow Z$
\end_inset

, we use typed holes:
\begin_inset Formula 
\begin{align*}
 & f^{:A\rightarrow C}\rightarrow g^{:\left(A\rightarrow\text{Int}\right)\rightarrow Z}\rightarrow\gunderline{\text{???}^{:\left(C\rightarrow\text{Int}\right)\rightarrow Z}}\\
\text{nameless function}:\quad & =f^{:A\rightarrow C}\rightarrow g^{:\left(A\rightarrow\text{Int}\right)\rightarrow Z}\rightarrow p^{:C\rightarrow\text{Int}}\rightarrow\gunderline{\text{???}^{:Z}}\\
\text{apply }g\text{ to get a }Z:\quad & =f^{:A\rightarrow C}\rightarrow g^{:\left(A\rightarrow\text{Int}\right)\rightarrow Z}\rightarrow p^{:C\rightarrow\text{Int}}\rightarrow g(\gunderline{\text{???}^{:A\rightarrow\text{Int}}})\\
\text{nameless function}:\quad & =f^{:A\rightarrow C}\rightarrow g^{:\left(A\rightarrow\text{Int}\right)\rightarrow Z}\rightarrow p^{:C\rightarrow\text{Int}}\rightarrow g(a^{:A}\rightarrow\gunderline{\text{???}^{:\text{Int}}})\\
\text{apply }p\text{ to get an Int}:\quad & =f^{:A\rightarrow C}\rightarrow g^{:\left(A\rightarrow\text{Int}\right)\rightarrow Z}\rightarrow p^{:C\rightarrow\text{Int}}\rightarrow g(a^{:A}\rightarrow p(\gunderline{\text{???}^{:C}}))\\
\text{apply }f\text{ to get a }C:\quad & =f^{:A\rightarrow C}\rightarrow g^{:\left(A\rightarrow\text{Int}\right)\rightarrow Z}\rightarrow p^{:C\rightarrow\text{Int}}\rightarrow g(a^{:A}\rightarrow p(f(\gunderline{\text{???}^{:A}})))\\
\text{use argument }a^{:A}:\quad & =f\rightarrow g\rightarrow p\rightarrow g(a\rightarrow p(f(a))\quad.
\end{align*}

\end_inset

In the resulting Scala code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

, we write out some types for clarity:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmapA[A, Z, C](f: A => C): Data2[A, Z] => Data2[C, Z] = {
\end_layout

\begin_layout Plain Layout

  case (e: Either[A, Z], g: ((A => Int) => Z)) =>
\end_layout

\begin_layout Plain Layout

    val newE: Either[C, Z] = e match {
\end_layout

\begin_layout Plain Layout

      case Left(x)    => Left(f(x))
\end_layout

\begin_layout Plain Layout

      case Right(z)   => Right(z)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    val newG: (C => Int) => Z = { p => g(a => p(f(a))) }
\end_layout

\begin_layout Plain Layout

    (newE, newG) // This has type Data2[C, Z].
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This suggests that 
\begin_inset Formula $\text{Data2}^{A,Z}$
\end_inset

 is covariant with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

.
 The results of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:f-Laws-and-structure"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show rigorously that the functor laws hold for this implementation
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The analysis is simpler for the type parameter 
\begin_inset Formula $B$
\end_inset

 because it is only used in covariant positions, never to the left of function
 arrows.
 So, we expect 
\begin_inset Formula $\text{Data2}^{A,B}$
\end_inset

 to be a functor with respect to 
\begin_inset Formula $B$
\end_inset

.
 Implementing the corresponding 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is straightforward:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmapB[Z, B, C](f: B => C): Data2[Z, A] => Data2[Z, B] = {
\end_layout

\begin_layout Plain Layout

  case (e: Either[Z, B], g: ((Z => Int) => B)) =>
\end_layout

\begin_layout Plain Layout

    val newE: Either[Z, B] = e match {
\end_layout

\begin_layout Plain Layout

      case Left(x)    => Left(f(x))
\end_layout

\begin_layout Plain Layout

      case Right(z)   => Right(z)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    val newG: (C => Int) => Z = { p => g(a => p(f(a))) }
\end_layout

\begin_layout Plain Layout

    (newE, newG) // This has type Data2[C, Z].
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code indicates that 
\begin_inset Formula $\text{Data2}^{A,B}$
\end_inset

 is a functor with respect to both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-functors-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-functors-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Rewrite the following code in the type notation; identify covariant and
 contravariant type usages; verify with the Scala compiler that the variance
 annotations are correct:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Coi[A, B]
\end_layout

\begin_layout Plain Layout

final case class Pa[A, B](b: (A, B), c: B => Int)     extends Coi[A, B]
\end_layout

\begin_layout Plain Layout

final case class Re[A, B](d: A, e: B, c: Int)         extends Coi[A, B]
\end_layout

\begin_layout Plain Layout

final case class Ci[A, B](f: String => A, g: B => A)  extends Coi[A, B]
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The type notation puts all parts of the disjunctive type into a single type
 expression:
\begin_inset Formula 
\[
\text{Coi}^{A,B}\triangleq A\times B\times(B\rightarrow\text{Int})+A\times B\times\text{Int}+(\text{String}\rightarrow A)\times(B\rightarrow A)\quad.
\]

\end_inset

Now find which types are wrapped and which are consumed in this type expression.
 The type parameter 
\begin_inset Formula $A$
\end_inset

 is wrapped and never consumed, but 
\begin_inset Formula $B$
\end_inset

 is both wrapped and consumed (in 
\begin_inset Formula $B\rightarrow A$
\end_inset

).
 So, the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Coi
\end_layout

\end_inset

 is covariant in 
\begin_inset Formula $A$
\end_inset

 but neither covariant nor contravariant in 
\begin_inset Formula $B$
\end_inset

.
 We can check this by compiling the corresponding Scala code with variance
 annotations:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Coi[+A, B]
\end_layout

\begin_layout Plain Layout

case class Pa[+A, B](b: (A, B), c: B => Int)     extends Coi[A, B]
\end_layout

\begin_layout Plain Layout

case class Re[+A, B](d: A, e: B, c: Int)         extends Coi[A, B]
\end_layout

\begin_layout Plain Layout

case class Ci[+A, B](f: String => A, g: B => A)  extends Coi[A, B]
\end_layout

\end_inset

We could also replace the fixed types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 by type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

.
 A similar analysis shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

 is in covariant positions while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 is in a contravariant position.
 We can then check that the Scala compiler accepts the following type definition
 with variance annotations:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Coi2[+A, B, +N, -S]
\end_layout

\begin_layout Plain Layout

case class Pa2[+A, B, +N, -S](b: (A, B), c: B => N)  extends Coi[A, B, N,
 S]
\end_layout

\begin_layout Plain Layout

case class Re2[+A, B, +N, -S](d: A, e: B, c: N)      extends Coi[A, B, N,
 S]
\end_layout

\begin_layout Plain Layout

case class Ci2[+A, B, +N, -S](f: S => A, g: B => A)  extends Coi[A, B, N,
 S]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exercises: implementation of functors and contrafunctors
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Exercise-functors"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Exercise-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
An implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A, A]
\end_layout

\end_inset

 is given as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Either[A, A] => Either[B, B] = {
\end_layout

\begin_layout Plain Layout

  case Left(a)         => Right(f(a))
\end_layout

\begin_layout Plain Layout

  case Right(a: Int)   => Left(f(a + 1))
\end_layout

\begin_layout Plain Layout

  case Right(a)        => Left(f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Show that this implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 violates the functor laws.
 Implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 correctly for this type constructor and the given type signature.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Exercise-functors-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Exercise-functors-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define these type constructors in Scala, decide whether they are covariant
 or contravariant, and implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 as appropriate:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\text{Data}^{A}\triangleq\left(\bbnum 1+A\right)\times\left(\bbnum 1+A\right)\times\text{String}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\text{Data}^{A}\triangleq(A\rightarrow\text{Boolean})\rightarrow A\times\left(\text{Int}+A\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\text{Data}^{A,B}\triangleq(A\rightarrow\text{Boolean})\times\left(A+B\rightarrow\text{Int}\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $\text{Data}^{A}\triangleq(\bbnum 1+(A\rightarrow\text{Boolean}))\rightarrow\bbnum 1+(A\rightarrow\text{Int})\rightarrow\text{Int}\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $\text{Data}^{B}\triangleq(B+(\text{Int}\rightarrow B))\times(B+(\text{String}\rightarrow B))\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Exercise-functors-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Exercise-functors-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Rewrite the following code in the type notation; find covariant and contravarian
t positions of type parameters; add variance annotations and verify that
 the revised code compiles:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait S[A, B]
\end_layout

\begin_layout Plain Layout

final case class P[A, B](a: A, b: B, c: Int)        extends S[A, B]
\end_layout

\begin_layout Plain Layout

final case class Q[A, B](d: Int => A, e: Int => B)  extends S[A, B]
\end_layout

\begin_layout Plain Layout

final case class R[A, B](f: A => A, g: A => B)      extends S[A, B]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Laws and structure
\begin_inset CommandInset label
LatexCommand label
name "sec:f-Laws-and-structure"

\end_inset


\end_layout

\begin_layout Standard
A type constructor is a functor if it admits a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function.
 How can we recognize quickly whether a given type constructor is a functor
 or a contrafunctor? For example, consider the type constructor 
\begin_inset Formula $Z^{A,R}$
\end_inset

 defined by: 
\begin_inset Formula 
\begin{equation}
Z^{A,R}\triangleq\left(\left(A\rightarrow A\rightarrow R\right)\rightarrow R\right)\times A+\left(\bbnum 1+R\rightarrow A+\text{Int}\right)+A\times A\times\text{Int}\times\text{Int}\quad.\label{eq:f-example-complicated-z}
\end{equation}

\end_inset

Is 
\begin_inset Formula $Z^{A,R}$
\end_inset

 a functor with respect to 
\begin_inset Formula $A$
\end_inset

, or perhaps with respect to 
\begin_inset Formula $R$
\end_inset

? To answer these questions, we will systematically build up various type
 expressions for which the functor or contrafunctor laws hold.
 
\end_layout

\begin_layout Subsection
Functor laws in the pipe notation
\end_layout

\begin_layout Standard
We begin by introducing a more convenient notation for the functor laws.
 The laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-identity-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-composition-law-functor-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) were defined in terms of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 When written in terms of the curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, the structure of the laws becomes less clear:
\begin_inset Formula 
\begin{align*}
 & \text{map}_{L}(x^{:L^{A}})(\text{id}^{:A\rightarrow A})=x\quad,\\
 & \text{map}_{L}(x^{:L^{A}})(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})=\text{map}_{L}\big(\text{map}_{L}(x)(f)\big)(g)\quad.
\end{align*}

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
But the laws become easier to read when using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 in Scala's method syntax:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x.map(identity) == x
\end_layout

\begin_layout Plain Layout

x.map(f).map(g) == x.map(f andThen g)
\end_layout

\end_inset

To take advantage of this syntax, we use the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset


\series bold
pipe notation
\series default
 with the symbol 
\begin_inset Formula $\triangleright$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset

).
 Then 
\begin_inset Formula $x\triangleright\text{fmap}(f)$
\end_inset

 is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout
\noindent

fmap(f)(x)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f)
\end_layout

\end_inset

.
 The functor laws become:
\begin_inset Formula 
\begin{align*}
 & x\triangleright\text{fmap}_{L}(\text{id})=x\quad,\\
 & x\triangleright\text{fmap}_{L}(f)\triangleright\text{fmap}_{L}(g)=x\triangleright\text{fmap}_{L}(f\bef g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In later chapters of this book, we will find that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method (equivalently, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function) is used so often in different contexts that the notation 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

 becomes too verbose.
 To make code expressions visually easier to manipulate, we need a shorter
 notation.
 At the same time, it is important to show clearly the relevant type constructor
 
\begin_inset Formula $L$
\end_inset

.
 Dropping the symbol 
\begin_inset Formula $L$
\end_inset

 can lead to errors, since it will be sometimes unclear what type constructors
 are involved in an expression such as 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f).map(g)
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 and whether we are justified in replacing that expression with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f andThen g)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For these reasons, we introduce the superscript notation 
\begin_inset Formula $^{\uparrow L}$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

lifted to 
\begin_inset Formula $L$
\end_inset


\begin_inset Quotes erd
\end_inset

).
 For any function 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset Formula $A\rightarrow B$
\end_inset

, we define the function 
\begin_inset Formula $f^{\uparrow L}$
\end_inset

 of type 
\begin_inset Formula $L^{A}\rightarrow L^{B}$
\end_inset

:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow L}:L^{A}\rightarrow L^{B}\quad,\quad\quad f^{\uparrow L}\triangleq\text{fmap}_{L}(f)\quad.
\]

\end_inset

Now we can choose the notation for lifted functions according to convenience:
\begin_inset Formula 
\[
\text{map}_{L}(x)(f)=\text{fmap}_{L}(f)(x)=x\triangleright\text{fmap}_{L}(f)=x\triangleright f^{\uparrow L}=f^{\uparrow L}(x)\quad.
\]

\end_inset

In the lifting
\begin_inset Index idx
status open

\begin_layout Plain Layout
lifting
\end_layout

\end_inset

 notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor!lifting notation
\end_layout

\end_inset

, the identity and composition laws for a functor 
\begin_inset Formula $L$
\end_inset

 are especially short:
\begin_inset Formula 
\[
\text{id}^{\uparrow L}=\text{id}\quad,\quad\quad\left(f\bef g\right)^{\uparrow L}=f^{\uparrow L}\bef g^{\uparrow L}\quad.
\]

\end_inset

Applying a composition of lifted functions to a value looks like this:
\begin_inset Formula 
\[
x\triangleright\left(f\bef g\right)^{\uparrow L}=x\triangleright f^{\uparrow L}\bef g^{\uparrow L}=x\triangleright f^{\uparrow L}\triangleright g^{\uparrow L}\quad.
\]

\end_inset

This equation corresponds to the Scala code syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x.map(f andThen g) == x.map(f).map(g)
\end_layout

\end_inset

because the pipe symbol 
\begin_inset Formula $\left(\triangleright\right)$
\end_inset

 groups weaker than the composition symbol 
\begin_inset Formula $\left(\bef\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Written in the 
\emph on
backward
\emph default
 notation (
\begin_inset Formula $f\circ g$
\end_inset

), the functor composition law is:
\begin_inset Formula 
\[
\left(g\circ f\right)^{\uparrow L}=g^{\uparrow L}\circ f^{\uparrow L}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The lifting notation for a contrafunctor 
\begin_inset Formula $C$
\end_inset

 is:
\begin_inset Formula 
\[
f^{\downarrow C}\triangleq\text{cmap}_{C}(f)\quad.
\]

\end_inset

The contrafunctor laws are then written as:
\begin_inset Formula 
\[
\text{id}^{\downarrow C}=\text{id}\quad,\quad\quad\left(f\bef g\right)^{\downarrow C}=g^{\downarrow C}\bef f^{\downarrow C}\quad,\quad\quad\left(g\circ f\right)^{\downarrow C}=f^{\downarrow C}\circ g^{\downarrow C}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We will almost always use the forward composition 
\begin_inset Formula $f\bef g$
\end_inset

 in this book, keeping in mind that one can straightforwardly and mechanically
 translate between forward and backward notations:
\begin_inset Formula 
\[
f\bef g=g\circ f\quad,\quad\quad x\triangleright f\bef g=x\triangleright f\triangleright g=g(f(x))=(g\circ f)(x)\quad.
\]

\end_inset


\end_layout

\begin_layout Subsection
Bifunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Bifunctors"

\end_inset


\end_layout

\begin_layout Standard
A 
\series bold
bifunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
bifunctor
\end_layout

\end_inset

 is a type constructor with 
\emph on
two
\emph default
 type parameters that has lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 methods with respect to both parameters.
\end_layout

\begin_layout Standard
As an example, consider the type constructor 
\begin_inset Formula $F$
\end_inset

 defined by:
\begin_inset Formula 
\[
F^{A,B}\triangleq A\times B\times B\quad.
\]

\end_inset

If we fix the type parameter 
\begin_inset Formula $B$
\end_inset

 in 
\begin_inset Formula $F^{A,B}$
\end_inset

 but let the parameter 
\begin_inset Formula $A$
\end_inset

 vary, we get a type constructor that we denote by 
\begin_inset Formula $F^{\bullet,B}$
\end_inset

.
 We see that the type constructor 
\begin_inset Formula $F^{\bullet,B}$
\end_inset

 is a functor with the following 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function:
\begin_inset Formula 
\[
\text{fmap}_{F^{\bullet,B}}(f^{:A\rightarrow C})\triangleq a^{:A}\times b_{1}^{:B}\times b_{2}^{:B}\rightarrow f(a)\times b_{1}\times b_{2}\quad.
\]

\end_inset

Instead of saying that 
\begin_inset Formula $F^{\bullet,B}$
\end_inset

 is a functor, we will also say more verbosely that 
\begin_inset Formula $F^{A,B}$
\end_inset

 is a functor with respect to 
\begin_inset Formula $A$
\end_inset

 when 
\begin_inset Formula $B$
\end_inset

 is held fixed.
 For brevity, we will prefer the notation 
\begin_inset Formula $F^{\bullet,B}$
\end_inset

.
\end_layout

\begin_layout Standard
If we now fix the type parameter 
\begin_inset Formula $A$
\end_inset

, we find that the type constructor 
\begin_inset Formula $F^{A,\bullet}$
\end_inset

 is a functor with the following 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method:
\begin_inset Formula 
\[
\text{fmap}_{F^{A,\bullet}}(g^{:B\rightarrow D})\triangleq a^{:A}\times b_{1}^{:B}\times b_{2}^{:B}\rightarrow a\times g(b_{1})\times g(b_{2})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Since the bifunctor 
\begin_inset Formula $F$
\end_inset

 is a functor with respect to each type parameter separately, we can transform
 a value of type 
\begin_inset Formula $F^{A,B}$
\end_inset

 to a value of type 
\begin_inset Formula $F^{C,D}$
\end_inset

 by applying the two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions one after another.
 It is convenient to express that transformation by a single operation called
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 that uses two functions 
\begin_inset Formula $f^{:A\rightarrow C}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow D}$
\end_inset

 as arguments:
\begin_inset Formula 
\begin{align}
\text{bimap}_{F}(f^{:A\rightarrow C})(g^{:B\rightarrow D}) & :F^{A,B}\rightarrow F^{C,D}\quad,\nonumber \\
\text{bimap}_{F}(f^{:A\rightarrow C})(g^{:B\rightarrow D}) & \triangleq\text{fmap}_{F^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{F^{C,\bullet}}(g^{:B\rightarrow D})\quad.\label{eq:f-definition-of-bimap}
\end{align}

\end_inset

In the lifting notation, this is written as:
\begin_inset Formula 
\[
\text{bimap}_{F}(f^{:A\rightarrow C})(g^{:B\rightarrow D})\triangleq f^{\uparrow F^{\bullet,B}}\bef g^{\uparrow F^{C,\bullet}}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
What if we apply the two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions in the opposite order? Since these functions work with different
 type parameters, it is reasonable to expect that the transformation 
\begin_inset Formula $F^{A,B}\rightarrow F^{C,D}$
\end_inset

 should be independent of the order of application:
\begin_inset Formula 
\begin{equation}
\text{fmap}_{F^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{F^{C,\bullet}}(g^{:B\rightarrow D})=\text{fmap}_{F^{A,\bullet}}(g^{:B\rightarrow D})\bef\text{fmap}_{F^{\bullet,D}}(f^{:A\rightarrow C})\quad.\label{eq:f-fmap-fmap-bifunctor-commutativity}
\end{equation}

\end_inset

This equation is illustrated by the type diagram:
\begin_inset Preview

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{5.0pc} & F^{C,B}\ar[rd]\sp(0.6){\ ~~\text{fmap}_{F^{C,\bullet}}(g^{:B\rightarrow D})}\\
F^{A,B}\ar[ru]\sp(0.4){\text{fmap}_{F^{\bullet,B}}(f^{:A\rightarrow C})~~~}\ar[rd]\sb(0.5){\text{fmap}_{F^{A,\bullet}}(g^{:B\rightarrow D})~~\ }\ar[rr]\sp(0.5){\text{bimap}_{F}(f^{:A\rightarrow C})(g^{:B\rightarrow D})\ } &  & F^{C,D}\\
 & F^{A,D}\ar[ru]\sb(0.6){~~~~\text{fmap}_{F^{\bullet,D}}(f^{:A\rightarrow C})}
}
\]

\end_inset


\end_layout

\end_inset

Different paths in this diagram give the same results if they arrive at
 the same vertex (as mathematicians say, 
\begin_inset Quotes eld
\end_inset

the diagram is 
\begin_inset Index idx
status open

\begin_layout Plain Layout
commutative diagram
\end_layout

\end_inset

commutative
\begin_inset Quotes erd
\end_inset

).
 In this way, the diagram illustrates at once the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-definition-of-bimap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) of 
\begin_inset Formula $\text{bimap}_{F}$
\end_inset

.
\end_layout

\begin_layout Standard
Let us verify the commutativity law for the bifunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
commutativity law!of bifunctors
\end_layout

\end_inset

 
\begin_inset Formula $F^{A,B}\triangleq A\times B\times B$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \quad\quad\text{left-hand side}:\quad\\
 & \text{fmap}_{F^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{F^{C,\bullet}}(g^{:B\rightarrow D})\\
 & \quad\quad\text{definitions of }\text{fmap}_{F^{\bullet,B}}\text{ and }\text{fmap}_{F^{C,\bullet}}:\quad\\
 & \quad=(a^{:A}\times b_{1}^{:B}\times b_{2}^{:B}\rightarrow f(a)\times b_{1}\times b_{2})\bef(c^{:C}\times b_{1}^{:B}\times b_{2}^{:B}\rightarrow c\times g(b_{1})\times g(b_{2}))\\
 & \quad\quad\text{compute composition}:\quad\\
 & \quad=a^{:A}\times b_{1}^{:B}\times b_{2}^{:B}\rightarrow f(a)\times g(b_{1})\times g(b_{2})\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
 & \quad\quad\text{right-hand side}:\quad\\
 & \text{fmap}_{F^{A,\bullet}}(g^{:B\rightarrow D})\bef\text{fmap}_{F^{\bullet,D}}(f^{:A\rightarrow C})\\
 & \quad\quad\text{definitions of }\text{fmap}_{F^{A,\bullet}}\text{ and }\text{fmap}_{F^{\bullet,D}}:\quad\\
 & \quad=(a^{:A}\times b_{1}^{:B}\times b_{2}^{:B}\rightarrow a\times g(b_{1})\times g(b_{2}))\bef(a^{:A}\times d_{1}^{:D}\times d_{2}^{:D}\rightarrow f(a)\times d_{1}\times d_{2})\\
 & \quad\quad\text{compute composition}:\quad\\
 & \quad=a^{:A}\times b_{1}^{:B}\times b_{2}^{:B}\rightarrow f(a)\times g(b_{1})\times g(b_{2})\quad.
\end{align*}

\end_inset

Both sides of the law are now equal.
\end_layout

\begin_layout Standard
The commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) leads to the composition law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

:
\begin_inset Formula 
\begin{equation}
\text{bimap}_{F}(f_{1}^{:A\rightarrow C})(g_{1}^{:B\rightarrow D})\bef\text{bimap}_{F}(f_{2}^{:C\rightarrow E})(g_{2}^{:D\rightarrow G})=\text{bimap}_{F}(f_{1}\bef f_{2})(g_{1}\bef g_{2})\quad.\label{eq:f-bimap-composition-law}
\end{equation}

\end_inset

The following type diagram shows the relationships between various 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{3.0pc}\xyScaleX{11.0pc}F^{A,B}\ar[rd]\sp(0.6){~~~\text{bimap}_{F}(f_{1})(g_{1})}\ar[r]\sp(0.4){\text{fmap}_{F^{\bullet,B}}(f_{1}^{:A\rightarrow C})}\ar[d]\sp(0.5){\text{fmap}_{F^{A,\bullet}}(g_{1})} & F^{C,B}\ar[rd]\sp(0.6){~~~\text{bimap}_{F}(f_{2})(g_{1})}\ar[r]\sp(0.4){~\text{fmap}_{F^{\bullet,B}}(f_{2}^{:C\rightarrow E})}\ar[d]\sp(0.5){\text{fmap}_{F^{C,\bullet}}(g_{1})~~~} & F^{E,B}\ar[d]\sp(0.5){\text{fmap}_{F^{E,\bullet}}(g_{1}^{:B\rightarrow D})}\\
F^{A,D}\ar[rd]\sp(0.6){~~~\text{bimap}_{F}(f_{1})(g_{2})}\ar[r]\sp(0.4){\text{fmap}_{F^{\bullet,D}}(f_{1})}\ar[d]\sp(0.5){\text{fmap}_{F^{A,\bullet}}(g_{2})} & F^{C,D}\ar[rd]\sp(0.6){~~~\text{bimap}_{F}(f_{2})(g_{2})}\ar[r]\sp(0.4){~\text{fmap}_{F^{\bullet,D}}(f_{2})}\ar[d]\sp(0.5){\text{fmap}_{F^{C,\bullet}}(g_{2})~~~} & F^{E,D}\ar[d]\sp(0.5){\text{fmap}_{F^{E,\bullet}}(g_{2}^{:D\rightarrow G})}\\
F^{A,G}\ar[r]\sp(0.4){~\text{fmap}_{F^{\bullet,G}}(f_{1})} & F^{C,G}\ar[r]\sp(0.4){~\text{fmap}_{F^{\bullet,G}}(f_{2})} & F^{E,G}
}
\]

\end_inset

To derive the composition law from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

), write:
\begin_inset Formula 
\begin{align*}
 & \text{bimap}_{F}(f_{1})(g_{1})\bef\text{bimap}_{F}(f_{2})(g_{2})\\
\text{use Eq.~(\ref{eq:f-definition-of-bimap})}:\quad & =\text{fmap}_{F^{\bullet,B}}(f_{1})\bef\gunderline{\text{fmap}_{F^{C,\bullet}}(g_{1})\bef\text{fmap}_{F^{\bullet,D}}(f_{2})}\bef\text{fmap}_{F^{E,\bullet}}(g_{2})\\
\text{the law in Eq.~(\ref{eq:f-fmap-fmap-bifunctor-commutativity})}:\quad & =\text{fmap}_{F^{\bullet,B}}(f_{1})\gunderline{\,\bef\,}\text{fmap}_{F^{\bullet,B}}(f_{2})\bef\text{fmap}_{F^{E,\bullet}}(g_{1})\gunderline{\,\bef\,}\text{fmap}_{F^{E,\bullet}}(g_{2})\\
\text{composition laws}:\quad & =\text{fmap}_{F^{\bullet,B}}(f_{1}\bef f_{2})\bef\text{fmap}_{F^{E,\bullet}}(g_{1}\bef g_{2})\\
\text{use Eq.~(\ref{eq:f-definition-of-bimap})}:\quad & =\text{bimap}_{F}(f_{1}\bef f_{2})(g_{1}\bef g_{2})\quad.
\end{align*}

\end_inset

Conversely, we can derive Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) from the composition law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-bimap-composition-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We write the composition law with specially chosen functions:
\begin_inset Formula 
\begin{equation}
\text{bimap}_{F}(f^{:A\rightarrow C})(g^{:B\rightarrow D})=\text{bimap}_{F}(\text{id}^{:A\rightarrow A})(g^{:B\rightarrow D})\bef\text{bimap}_{F}(f^{:A\rightarrow C})(\text{id}^{:D\rightarrow D})\quad.\label{eq:f-bimap-id-f-g-id}
\end{equation}

\end_inset

Using Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-definition-of-bimap"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we find:
\begin_inset Formula 
\begin{align*}
 & \quad\quad\text{expect to equal }\text{fmap}_{F^{A,\bullet}}(g)\bef\text{fmap}_{F^{\bullet,D}}(f):\quad\\
 & \text{fmap}_{F^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{F^{C,\bullet}}(g^{:B\rightarrow D})\\
 & \quad\quad\text{use Eq.~(\ref{eq:f-definition-of-bimap})}:\quad\\
 & =\text{bimap}_{F}(f^{:A\rightarrow C})(g^{:B\rightarrow D})\\
 & \quad\quad\text{use Eq.~(\ref{eq:f-bimap-id-f-g-id})}:\quad\\
 & =\text{bimap}_{F}(\text{id}^{:A\rightarrow A})(g^{:B\rightarrow D})\bef\text{bimap}_{F}(f^{:A\rightarrow C})(\text{id}^{:D\rightarrow D})\\
 & \quad\quad\text{use Eq.~(\ref{eq:f-definition-of-bimap})}:\quad\\
 & =\gunderline{\text{fmap}_{F^{\bullet,B}}(\text{id})}\bef\text{fmap}_{F^{A,\bullet}}(g)\bef\text{fmap}_{F^{\bullet,D}}(f)\bef\gunderline{\text{fmap}_{F^{C,\bullet}}(\text{id})}\\
 & \quad\quad\text{identity laws for }F:\quad\\
 & =\text{fmap}_{F^{A,\bullet}}(g)\bef\text{fmap}_{F^{\bullet,D}}(f)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The identity law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 holds as well:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{bimap}_{F}(\text{id}^{:A\rightarrow A})(\text{id}^{:B\rightarrow B})\\
\text{use Eq.~(\ref{eq:f-definition-of-bimap})}:\quad & =\gunderline{\text{fmap}_{F^{\bullet,B}}(\text{id})}\bef\gunderline{\text{fmap}_{F^{C,\bullet}}(\text{id})}\\
\text{identity laws for }F:\quad & =\text{id}\bef\text{id}=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $F^{A,B}$
\end_inset

 is known to be a functor separately with respect to 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, will the commutativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-fmap-fmap-bifunctor-commutativity"
plural "false"
caps "false"
noprefix "false"

\end_inset

) always hold? The calculation for 
\begin_inset Formula $F^{A,B}\triangleq A\times B\times B$
\end_inset

 shows that the two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions commute because they work on different parts of the data structure
 
\begin_inset Formula $F^{A,B}$
\end_inset

.
 This turns out
\begin_inset Foot
status open

\begin_layout Plain Layout
A proof is given in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Commutativity-laws-for-type-constructors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 of Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app:Proofs-of-naturality-parametricity"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It assumes that the bifunctor 
\begin_inset Formula $F$
\end_inset

 is fully parametric.
\end_layout

\end_inset

 to be true in general: the commutativity law follows from the parametricity
 of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions.
 Because of that, we do not need to verify the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 laws as long as 
\begin_inset Formula $F^{\bullet,B}$
\end_inset

 and 
\begin_inset Formula $F^{A,\bullet}$
\end_inset

 are lawful functors.
\end_layout

\begin_layout Standard
Type constructors with more than two type parameters have similar properties.
 It is sufficient to check the functor laws with respect to each type parameter
 separately.
\end_layout

\begin_layout Standard
In general, a type constructor may be a functor with respect to some type
 parameters and a contrafunctor with respect to others.
 We will see examples of such type constructors later.
\end_layout

\begin_layout Subsection
Constructions of functors
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Functor-constructions"

\end_inset


\end_layout

\begin_layout Standard
What type expressions will produce a functor? Functional programming languages
 support the six standard type constructions (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Type-notation-and-standard-type-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This section will check whether each construction produces a new type that
 obeys the functor laws.
 The results are summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Assumptions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L^{A}\triangleq A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
product type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L^{A}\triangleq P^{A}\times Q^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are functors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
disjunctive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L^{A}\triangleq P^{A}+Q^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are functors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
function type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L^{A}\triangleq C^{A}\rightarrow P^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P$
\end_inset

 is a functor and 
\begin_inset Formula $C$
\end_inset

 is a contrafunctor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L^{A}\triangleq Z$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $Z$
\end_inset

 is a fixed type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
type constructor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L^{A}\triangleq P^{Q^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are both functors or both contrafunctors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L^{A}\triangleq S^{A,L^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $S^{A,B}$
\end_inset

 is a functor w.r.t.
\begin_inset space ~
\end_inset

both 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions defining a functor 
\begin_inset Formula $L$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:f-Functor-constructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In each of these constructions, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function for a new functor is defined either from scratch or by using the
 known 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions for previously defined type constructors.
 The rest of this section will derive the code for these constructions and
 prove their laws.
 We will use the code notation for brevity, occasionally showing the translation
 into the Scala syntax.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Statement-identity-functor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Statement-identity-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The type constructor 
\begin_inset Formula $\text{Id}^{A}\triangleq A$
\end_inset

 is a lawful functor (the 
\series bold
identity functor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity functor
\end_layout

\end_inset

).
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function is defined by:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{\text{Id}}:\left(A\rightarrow B\right)\rightarrow\text{Id}^{A}\rightarrow\text{Id}^{B}\cong\left(A\rightarrow B\right)\rightarrow A\rightarrow B\quad,\\
 & \text{fmap}_{\text{Id}}\triangleq(f^{:A\rightarrow B}\rightarrow f)=\text{id}^{:(A\rightarrow B)\rightarrow A\rightarrow B}\quad.
\end{align*}

\end_inset

The identity function is the only fully parametric implementation of the
 type signature 
\begin_inset Formula $\left(A\rightarrow B\right)\rightarrow A\rightarrow B$
\end_inset

.
 Since the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 is the identity function, the laws are satisfied:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \text{fmap}_{\text{Id}}(\text{id})=\text{id}(\text{id})=\text{id}\quad,\\
\text{composition law}:\quad & \text{\text{fmap}_{\text{Id}}}(f\bef g)=f\bef g=\text{fmap}_{\text{Id}}(f)\bef\text{fmap}_{\text{Id}}(g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Statement-constant-functor"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Statement-constant-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The type
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant functor
\end_layout

\end_inset

 constructor 
\begin_inset Formula $\text{Const}^{Z,A}\triangleq Z$
\end_inset

 is a lawful functor (a 
\series bold
constant functor
\series default
) with respect to the type parameter 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function is defined by:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{\text{Const}}:\left(A\rightarrow B\right)\rightarrow\text{Const}^{Z,A}\rightarrow\text{Const}^{Z,B}\cong\left(A\rightarrow B\right)\rightarrow Z\rightarrow Z\quad,\\
 & \text{fmap}_{\text{Const}}(f^{:A\rightarrow B})\triangleq(z^{:Z}\rightarrow z)=\text{id}^{:Z\rightarrow Z}\quad.
\end{align*}

\end_inset

It is a constant function that ignores 
\begin_inset Formula $f$
\end_inset

 and returns the identity 
\begin_inset Formula $\text{id}^{:Z\rightarrow Z}$
\end_inset

.
 The laws are satisfied:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \text{fmap}_{\text{Const}}(\text{id})=\text{id}\quad,\\
\text{composition law}:\quad & \text{\text{fmap}_{\text{Const}}}(f\bef g)=\text{id}=\text{fmap}_{\text{Const}}(f)\bef\text{fmap}_{\text{Const}}(g)=\text{id}\bef\text{id}\quad.
\end{align*}

\end_inset

The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Const[Z, A] = Z
\end_layout

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Const[Z, A] => Const[Z, B] = identity[Z]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The identity functor and the constant functor are not often used: as their
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 methods are identity functions, they rarely provide useful functionality.
 
\end_layout

\begin_layout Standard
We have seen that type constructors with product types, such as 
\begin_inset Formula $L^{A}\triangleq A\times A\times A$
\end_inset

, are functors.
 The next construction (the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor product
\end_layout

\end_inset


\series bold
functor product
\series default
) explains why.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-functor-product"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are two functors then the product
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor product
\end_layout

\end_inset

 
\begin_inset Formula $P^{A}\triangleq L^{A}\times M^{A}$
\end_inset

 is also a functor.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function for 
\begin_inset Formula $P$
\end_inset

 is defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): (L[A], M[A]) => (L[B], M[B]) = {
\end_layout

\begin_layout Plain Layout

  case (la, ma) => (la.map(f), ma.map(f))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The corresponding code notation is:
\begin_inset Formula 
\[
f^{\uparrow P}\triangleq l^{:L^{A}}\times m^{:M^{A}}\rightarrow f^{\uparrow L}(l)\times f^{\uparrow M}(m)\quad.
\]

\end_inset

Writing this code using the pipe (
\begin_inset Formula $\triangleright$
\end_inset

) operation makes it somewhat closer to the Scala syntax:
\begin_inset Formula 
\begin{equation}
(l^{:L^{A}}\times m^{:M^{A}})\triangleright f^{\uparrow P}\triangleq(l\triangleright f^{\uparrow L})\times(m\triangleright f^{\uparrow M})\quad.\label{eq:f-def-of-functor-product-lift}
\end{equation}

\end_inset

An alternative notation uses the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pair product of functions
\end_layout

\end_inset


\series bold
pair product
\series default
 symbol 
\begin_inset Formula $\boxtimes$
\end_inset

 defined by:
\begin_inset Formula 
\begin{align*}
 & p^{:A\rightarrow B}\boxtimes q^{:C\rightarrow D}:A\times C\rightarrow B\times D\quad,\\
 & p\boxtimes q\triangleq a\times c\rightarrow p(a)\times q(c)\quad,\\
\text{or equivalently}:\quad & (a\times c)\triangleright\left(p\boxtimes q\right)=\left(a\triangleright p\right)\times\left(b\triangleright q\right)\quad.
\end{align*}

\end_inset

In this notation, the lifting for 
\begin_inset Formula $P$
\end_inset

 is defined more concisely:
\begin_inset Formula 
\begin{equation}
f^{\uparrow P}=f^{\uparrow L\times M}\triangleq f^{\uparrow L}\boxtimes f^{\uparrow M}\quad.\label{eq:def-of-functor-product-fmap}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We need to verify the identity law and the composition law.
\end_layout

\begin_layout Standard
To verify the identity law of 
\begin_inset Formula $P$
\end_inset

, pipe an arbitrary value of type 
\begin_inset Formula $L^{A}\times M^{A}$
\end_inset

 into both sides of the law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }l\times m:\quad & (l^{:L^{A}}\times m^{:M^{A}})\triangleright\text{id}^{\uparrow P}\\
\text{definition of }f^{\uparrow P}:\quad & =(l\triangleright\gunderline{\text{id}^{\uparrow L}})\times(m\triangleright\gunderline{\text{id}^{\uparrow M}})\\
\text{identity laws of }L\text{ and }M:\quad & =(\gunderline{l\triangleright\text{id}})\times(\gunderline{m\triangleright\text{id}})\\
\text{definition of }\text{id}:\quad & =l\times m\quad.
\end{align*}

\end_inset

To verify the composition law of 
\begin_inset Formula $P$
\end_inset

, we need to show that:
\begin_inset Formula 
\[
f^{\uparrow P}\bef g^{\uparrow P}=\left(f\bef g\right)^{\uparrow P}\quad.
\]

\end_inset

Apply both sides of this equation to an arbitrary value of type 
\begin_inset Formula $L^{A}\times M^{A}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(l\times m)\triangleright(f\bef g)^{\uparrow P}:\quad & (l^{:L^{A}}\times m^{:M^{A}})\triangleright f^{\uparrow P}\gunderline{\,\bef\,}g^{\uparrow P}\\
\triangleright\text{-notation}:\quad & =\gunderline (l^{:L^{A}}\times m^{:M^{A}}\gunderline{)\triangleright f^{\uparrow P}}\triangleright g^{\uparrow P}\\
\text{use Eq.~(\ref{eq:f-def-of-functor-product-lift})}:\quad & =\gunderline{\big(}(l\triangleright f^{\uparrow L})\times(m\triangleright f^{\uparrow M})\gunderline{\big)\triangleright g^{\uparrow P}}\\
\text{use Eq.~(\ref{eq:f-def-of-functor-product-lift})}:\quad & =(l\triangleright f^{\uparrow L}\gunderline{\,\triangleright\,}g^{\uparrow L})\times(m\triangleright f^{\uparrow M}\gunderline{\,\triangleright\,}g^{\uparrow M})\\
\triangleright\text{-notation}:\quad & =(l\triangleright\gunderline{f^{\uparrow L}\bef g^{\uparrow L}})\times(m\triangleright\gunderline{f^{\uparrow M}\bef g^{\uparrow M}})\\
\text{composition laws of }L\text{ and }M:\quad & =(l\triangleright(f\bef g)^{\uparrow L})\times(m\triangleright(f\bef g)^{\uparrow M})\\
\text{use Eq.~(\ref{eq:f-def-of-functor-product-lift})}:\quad & =(l\times m)\triangleright(f\bef g)^{\uparrow P}\quad.
\end{align*}

\end_inset

The calculations are shorter if we use the pair product operation (
\begin_inset Formula $\boxtimes$
\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(f\bef g)^{\uparrow P}:\quad & f^{\uparrow P}\bef g^{\uparrow P}=(f^{\uparrow L}\boxtimes f^{\uparrow M})\bef(g^{\uparrow L}\boxtimes g^{\uparrow M})\\
\text{composition of functions under }\boxtimes:\quad & =(\gunderline{f^{\uparrow L}\bef g^{\uparrow L}})\boxtimes(\gunderline{f^{\uparrow M}\bef g^{\uparrow M}})\\
\text{composition laws of }L\text{ and }M:\quad & =(f\bef g)^{\uparrow L}\boxtimes(f\bef g)^{\uparrow M}=(f\bef g)^{\uparrow P}\quad.
\end{align*}

\end_inset

For comparison, the same derivation using the Scala code syntax looks like
 this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(( l, m )).map(f).map(g) == (( l.map(f), m.map(f) )).map(g)
\end_layout

\begin_layout Plain Layout

  == (( l.map(f).map(g), m.map(f).map(g) ))
\end_layout

\begin_layout Plain Layout

  == (( l.map(f andThen g), m.map(f andThen g) )) 
\end_layout

\end_inset

assuming that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method is defined on pairs by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-of-functor-product-lift"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(( l, m )).map(f) == (( l.map(f), m.map(f) ))
\end_layout

\end_inset

The proof written in the Scala syntax does not show the type constructors
 whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods are used in each expression.
 For instance, it is not indicated that the two 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 methods used in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m.map(f).map(g)
\end_layout

\end_inset

 belong to the 
\emph on
same
\emph default
 type constructor 
\begin_inset Formula $M$
\end_inset

 and thus obey 
\begin_inset Formula $M$
\end_inset

's composition law.
 The code notation shows this more concisely and more clearly, helping us
 in reasoning:
\begin_inset Formula 
\[
m\triangleright f^{\uparrow M}\triangleright g^{\uparrow M}=m\triangleright f^{\uparrow M}\bef g^{\uparrow M}=m\triangleright(f\bef g)^{\uparrow M}\quad.
\]

\end_inset

By convention, the pipe symbol (
\begin_inset Formula $\triangleright$
\end_inset

) groups to the left, and so we can write:
\begin_inset Formula 
\[
\left(x\triangleright f\right)\triangleright g=x\triangleright f\triangleright g=x\triangleright f\bef g=x\triangleright(f\bef g)=(f\bef g)(x)=g(f(x))\quad.
\]

\end_inset

We will often use the pipe notation in derivations.
 (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Reasoning-about-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

 gives an overview of the derivation techniques.)
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-functor-coproduct"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are functors then the type constructor 
\begin_inset Formula $L$
\end_inset

 defined by 
\begin_inset Formula $L^{A}\triangleq P^{A}+Q^{A}$
\end_inset

 is a functor whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method is given by this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Either[P[A], Q[A]] => Either[P[B], Q[B]] = {
\end_layout

\begin_layout Plain Layout

  case Left(pa)    => Left(fmap_P(f)(pa))   // Use fmap for P.
\end_layout

\begin_layout Plain Layout

  case Right(qa)   => Right(fmap_Q(f)(qa))  // Use fmap for Q.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The functor 
\begin_inset Formula $L$
\end_inset

 is the 
\series bold
functor co-product
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
functor co-product
\end_layout

\end_inset

 of 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 The code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

  is:
\begin_inset Formula 
\[
\text{fmap}_{L}(f^{:A\rightarrow B})=f^{\uparrow L}\triangleq\,\begin{array}{|c||cc|}
 & P^{B} & Q^{B}\\
\hline P^{A} & f^{\uparrow P} & \bbnum 0\\
Q^{A} & \bbnum 0 & f^{\uparrow Q}
\end{array}\quad.
\]

\end_inset

Here we assume that lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions are given for the functors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Omitting the type annotations, we write the code of 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
\text{fmap}_{L}(f)=f^{\uparrow L}=\,\begin{array}{||cc|}
f^{\uparrow P} & \bbnum 0\\
\bbnum 0 & f^{\uparrow Q}
\end{array}\quad.\label{eq:f-coproduct-functor-def-fmap}
\end{equation}

\end_inset

To verify the identity law, use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-coproduct-functor-def-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and the identity laws for 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{id}^{\uparrow L}=\,\begin{array}{||cc|}
\text{id}^{\uparrow P} & \bbnum 0\\
\bbnum 0 & \text{id}^{\uparrow Q}
\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\\
\text{identity function in matrix notation}:\quad & =\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(f\bef g)^{\uparrow L}:\quad & f^{\uparrow L}\bef g^{\uparrow L}=\,\begin{array}{||cc|}
f^{\uparrow P} & \bbnum 0\\
\bbnum 0 & f^{\uparrow Q}
\end{array}\,\bef\,\begin{array}{||cc|}
g^{\uparrow P} & \bbnum 0\\
\bbnum 0 & g^{\uparrow Q}
\end{array}\\
\text{matrix composition}:\quad & =\,\begin{array}{||cc|}
\gunderline{f^{\uparrow P}\bef g^{\uparrow P}} & \bbnum 0\\
\bbnum 0 & \gunderline{f^{\uparrow Q}\bef g^{\uparrow Q}}
\end{array}\\
\text{composition laws of }P\text{ and }Q:\quad & =\,\,\begin{array}{||cc|}
(f\bef g)^{\uparrow P} & \bbnum 0\\
\bbnum 0 & (f\bef g)^{\uparrow Q}
\end{array}\,=(f\bef g)^{\uparrow L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The last two statements show that any type constructor built up via primitive
 types, type parameters, products and co-products, such as 
\begin_inset Formula $L^{A}\triangleq\bbnum 1+(\text{String}+A)\times A\times\text{Int}+A$
\end_inset

, is a functor.
 Functors of this kind are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functor
\end_layout

\end_inset


\series bold
polynomial functors
\series default
 because of the analogy to ordinary arithmetic polynomial functions of a
 variable 
\begin_inset Formula $A$
\end_inset

.
 The type notation with its symbols (
\begin_inset Formula $+$
\end_inset

, 
\begin_inset Formula $\times$
\end_inset

) makes this analogy visually clear.
 
\end_layout

\begin_layout Standard
Implementing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for a polynomial functor is straightforward: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 replaces each occurrence of a value of type 
\begin_inset Formula $A$
\end_inset

 by the corresponding value of type 
\begin_inset Formula $B$
\end_inset

, leaving constant types unchanged and keeping the order of parts in all
 products and disjunctive types.
 Previously, our implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for various type constructors (such as shown in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-functors-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) were guided by the idea of preserving information.
 Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-coproduct"
plural "false"
caps "false"
noprefix "false"

\end_inset

 explain why those implementations of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 are correct (i.e., obey the functor laws).
\end_layout

\begin_layout Standard
The next construction shows when a function type is a functor: the argument
 of the function must be a contrafunctor.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-functor-exponential"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $C$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $P$
\end_inset

 is a functor then 
\begin_inset Formula $L^{A}\triangleq C^{A}\rightarrow P^{A}$
\end_inset

 is a functor, called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor exponential
\end_layout

\end_inset


\series bold
functor exponential
\series default
, with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 defined by:
\begin_inset Formula 
\begin{align}
 & \text{fmap}_{L}^{A,B}(f^{:A\rightarrow B}):(C^{A}\rightarrow P^{A})\rightarrow C^{B}\rightarrow P^{B}\quad,\nonumber \\
 & \text{fmap}_{L}(f^{:A\rightarrow B})=f^{\uparrow L}\triangleq h^{:C^{A}\rightarrow P^{A}}\rightarrow f^{\downarrow C}\bef h\bef f^{\uparrow P}\quad.\label{eq:f-functor-exponential-def-of-fmap}
\end{align}

\end_inset

The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_L[A, B](f: A => B)(h: C[A] => P[A]): C[B] => P[B] = {
\end_layout

\begin_layout Plain Layout

  cmap_C(f) andThen h andThen fmap_P(f)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

A type diagram for 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

 can be drawn as:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{2.5pc} & C^{A}\ar[r]\sp(0.5){h} & P^{A}\ar[rd]\sp(0.6){\ \text{fmap}_{P}(f^{:A\rightarrow B})\ }\\
C^{B}\ar[ru]\sp(0.4){\text{cmap}_{C}(f^{:A\rightarrow B})\ ~~}\ar[rrr]\sb(0.5){\text{fmap}_{L}(f^{:A\rightarrow B})(h^{:C^{A}\rightarrow P^{A}})\ } &  &  & P^{B}
}
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Since the types are already checked, we can use Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-functor-exponential-def-of-fmap"
plural "false"
caps "false"
noprefix "false"

\end_inset

) without type annotations:
\begin_inset Formula 
\begin{equation}
h\triangleright f^{\uparrow L}=f^{\downarrow C}\bef h\bef f^{\uparrow P}\quad.\label{eq:f-functor-exponential-def-fmap-f-h}
\end{equation}

\end_inset

To verify the identity law of 
\begin_inset Formula $L$
\end_inset

, show that 
\begin_inset Formula $\text{id}^{\uparrow L}(h)=h$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }h:\quad & h\triangleright\text{id}^{\uparrow L}\\
\text{definition (\ref{eq:f-functor-exponential-def-fmap-f-h}) of }^{\uparrow L}:\quad & =\gunderline{\text{id}^{\downarrow C}}\bef h\bef\gunderline{\text{id}^{\uparrow P}}\\
\text{identity laws of }C\text{ and }P:\quad & =\gunderline{\text{id}}\bef h\bef\gunderline{\text{id}}\\
\text{definition of }\text{id}:\quad & =h\quad.
\end{align*}

\end_inset

To verify the composition law of 
\begin_inset Formula $L$
\end_inset

, it helps to apply both sides of the law to an arbitrary 
\begin_inset Formula $h^{:L^{A}}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }h\triangleright f^{\uparrow L}\bef g^{\uparrow L}:\quad & h\triangleright(f\bef g)^{\uparrow L}\\
\text{definition (\ref{eq:f-functor-exponential-def-fmap-f-h}) of }^{\uparrow L}:\quad & =(\gunderline{f\bef g})^{\downarrow C}\bef h\bef(\gunderline{f\bef g})^{\uparrow P}\\
\text{composition laws of }C\text{ and }P:\quad & =g^{\downarrow C}\bef\gunderline{f^{\downarrow C}}\bef h\bef\gunderline{f^{\uparrow P}}\bef g^{\uparrow P}\\
\text{definition (\ref{eq:f-functor-exponential-def-fmap-f-h}) of }^{\uparrow L}:\quad & =\gunderline{g^{\downarrow C}}\bef(h\triangleright f^{\uparrow L})\bef\gunderline{g^{\uparrow P}}\\
\text{definition (\ref{eq:f-functor-exponential-def-fmap-f-h}) of }^{\uparrow L}:\quad & =(h\triangleright f^{\uparrow L})\triangleright g^{\uparrow L}=h\triangleright f^{\uparrow L}\bef g^{\uparrow L}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
This proof uses the fact that the order of function compositions is reversed
 when lifting to a contrafunctor 
\begin_inset Formula $C$
\end_inset

 as in 
\begin_inset Formula $(f\bef g)^{\downarrow C}=g^{\downarrow C}\bef f^{\downarrow C}$
\end_inset

.
 If 
\begin_inset Formula $C$
\end_inset

 were a functor, the proof would not work because we would have obtained
 
\begin_inset Formula $f^{\uparrow C}\bef g^{\uparrow C}$
\end_inset

 instead of 
\begin_inset Formula $g^{\downarrow C}\bef f^{\downarrow C}$
\end_inset

.
 The order of composition cannot be permuted for arbitrary functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

.
 So, we would not be able to group 
\begin_inset Formula $f^{\downarrow C}\bef h\bef f^{\uparrow P}$
\end_inset

 together.
\end_layout

\begin_layout Standard
Examples of functors obtained via the exponential
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor exponential
\end_layout

\end_inset

 construction are 
\begin_inset Formula $L^{A}\triangleq Z\rightarrow A$
\end_inset

 (with the contrafunctor 
\begin_inset Formula $C$
\end_inset

 chosen as the constant contrafunctor, 
\begin_inset Formula $C^{A}\triangleq Z$
\end_inset

, where 
\begin_inset Formula $Z$
\end_inset

 is a fixed type) and 
\begin_inset Formula $L^{A}\triangleq\left(A\rightarrow Z\right)\rightarrow A$
\end_inset

 (with the contrafunctor 
\begin_inset Formula $C^{A}\triangleq A\rightarrow Z$
\end_inset

).
 Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

 generalizes those examples to arbitrary contrafunctors 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Standard
Similarly, one can prove that 
\begin_inset Formula $P^{A}\rightarrow C^{A}$
\end_inset

 is a contrafunctor (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Together with Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

, this gives us rules of reasoning about covariance and contravariance of
 type parameters in arbitrary type expressions.
 Every function arrow (
\begin_inset Formula $\rightarrow$
\end_inset

) flips the variance from covariant to contravariant and back.
 For instance, the identity functor 
\begin_inset Formula $L^{A}\triangleq A$
\end_inset

 is covariant in 
\begin_inset Formula $A$
\end_inset

, while 
\begin_inset Formula $A\rightarrow Z$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

.
 But 
\begin_inset Formula $\left(A\rightarrow Z\right)\rightarrow Z$
\end_inset

 is again covariant in 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
As we have seen, 
\begin_inset Formula $A\rightarrow A\rightarrow Z$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

, so any number of curried arrows count as one in this reasoning (and, in
 any case, 
\begin_inset Formula $A\rightarrow A\rightarrow Z\cong A\times A\rightarrow Z$
\end_inset

).
 Products and co-products preserve variance; for example, 
\begin_inset Formula $\left(A\rightarrow Z_{1}\right)\times\left(A\rightarrow Z_{2}\right)+\left(A\rightarrow Z_{3}\right)$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

.
 More examples illustrating these techniques are given in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Solved-examples:-How-to-recognize-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below.
\end_layout

\begin_layout Standard
The remaining construction is the 
\series bold
functor composition
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
functor composition
\end_layout

\end_inset

 
\begin_inset Formula $P^{Q^{A}}$
\end_inset

, written in Scala as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P[Q[A]]
\end_layout

\end_inset

.
 This is analogous to a function composition such as 
\begin_inset Formula $f(g(x))$
\end_inset

 except for using type constructors.
 Viewed in this way, type constructors are 
\series bold
type-level functions
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type-level function
\end_layout

\end_inset

 (i.e., mappings from types to types).
 So, we will denote functor composition by 
\begin_inset Formula $P\circ Q$
\end_inset

, similarly to the function composition 
\begin_inset Formula $f\circ g$
\end_inset

.
\end_layout

\begin_layout Standard
An example of functor composition in Scala is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Option[A]]
\end_layout

\end_inset

.
 Since both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 have a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method, we may write code such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val p: List[Option[Int]] = List(Some(1), None, Some(2), None, Some(3))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> p.map(_.map(x => x + 10))
\end_layout

\begin_layout Plain Layout

res0: List[Option[Int]] = List(Some(11), None, Some(12), None, Some(13))
 
\end_layout

\end_inset

The code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p.map(_.map(f))
\end_layout

\end_inset

 lifts an 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 into a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Option[A]] => List[Option[B]]
\end_layout

\end_inset

.
 In this way, we may perform the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 operation on the nested data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Option[A]]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The next statement shows that this code always produces a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function.
 In other words, the composition
\begin_inset Index idx
status open

\begin_layout Plain Layout
functor composition
\end_layout

\end_inset

 of functors is always a functor.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-functor-composition-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-composition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are functors then 
\begin_inset Formula $L^{A}\triangleq P^{Q^{A}}$
\end_inset

 is also a functor, with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_L[A, B](f: A => B): P[Q[A]] => P[Q[B]] = fmap_P(fmap_Q(f))
\end_layout

\end_inset

Here we assumed that the functions 
\begin_inset Formula $\text{fmap}_{P}$
\end_inset

 and 
\begin_inset Formula $\text{fmap}_{Q}$
\end_inset

 are known and satisfy the functor laws.
\end_layout

\begin_layout Standard
In the code notation, 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

 is written as:
\begin_inset Formula 
\begin{align}
\text{type signature}:\quad & \text{fmap}_{L}:f^{:A\rightarrow B}\rightarrow P^{Q^{A}}\rightarrow P^{Q^{B}}\quad,\nonumber \\
\text{implementation}:\quad & \text{fmap}_{L}(f)\triangleq\text{fmap}_{P}(\text{fmap}_{Q}(f))\quad,\nonumber \\
\text{equivalent code}:\quad & \text{fmap}_{L}\triangleq\text{fmap}_{Q}\bef\text{fmap}_{P}\quad,\\
\text{in a shorter notation}:\quad & f^{\uparrow L}\triangleq(f^{\uparrow Q})^{\uparrow P}\triangleq f^{\uparrow Q\uparrow P}\quad.\label{eq:def-functor-composition-fmap}
\end{align}

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
To verify the identity law of 
\begin_inset Formula $L$
\end_inset

, use the identity laws for 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\[
\text{id}^{\uparrow L}=(\gunderline{\text{id}^{\uparrow Q}})^{\uparrow P}=\gunderline{\text{id}^{\uparrow P}}=\text{id}\quad.
\]

\end_inset

To verify the composition law of 
\begin_inset Formula $L$
\end_inset

, use the composition laws for 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\[
(f\bef g)^{\uparrow L}=\big((\gunderline{f\bef g})^{\uparrow Q}\big)^{\uparrow P}=(\gunderline{f^{\uparrow Q}\bef g^{\uparrow Q}}\big)^{\uparrow P}=f^{\uparrow Q\uparrow P}\bef g^{\uparrow Q\uparrow P}\quad.
\]

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
Finally, we consider recursive data types such as lists and trees (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Lists-and-trees:recursive-disjunctive-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 It is helpful to use the type notation for reasoning about those types.
 The list type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait List[A]
\end_layout

\begin_layout Plain Layout

final case class Empty()                         extends List[A]
\end_layout

\begin_layout Plain Layout

final case class Head[A](head: A, tail: List[A]) extends List[A]
\end_layout

\end_inset

is written in type notation as:
\begin_inset Formula 
\[
\text{List}^{A}\triangleq\bbnum 1+A\times\text{List}^{A}\quad.
\]

\end_inset

The binary tree type:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait Tree2[A]
\end_layout

\begin_layout Plain Layout

final case class Leaf[A](a: A)                       extends Tree2[A]
\end_layout

\begin_layout Plain Layout

final case class Branch[A](x: Tree2[A], y: Tree2[A]) extends Tree2[A]
\end_layout

\end_inset

is denoted by 
\begin_inset Formula $\text{Tree}_{2}^{A}\triangleq A+\text{Tree}_{2}^{A}\times\text{Tree}_{2}^{A}$
\end_inset

.
 Such definitions of recursive types look like 
\begin_inset Quotes eld
\end_inset

type equations
\begin_inset Quotes erd
\end_inset

.
 We can generalize these examples to a recursive definition:
\begin_inset Formula 
\begin{equation}
L^{A}\triangleq S^{A,L^{A}}\quad,\label{eq:f-def-recursive-functor}
\end{equation}

\end_inset

where 
\begin_inset Formula $S^{A,R}$
\end_inset

 is a suitably chosen type constructor (called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursion scheme|textit
\end_layout

\end_inset


\series bold
recursion scheme
\series default
) with two type parameters 
\begin_inset Formula $A,R$
\end_inset

.
 If a recursion scheme 
\begin_inset Formula $S$
\end_inset

 is given, the Scala code defining 
\begin_inset Formula $L$
\end_inset

 can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = ...
           // Must be defined as type alias, class, or trait.
\end_layout

\begin_layout Plain Layout

final case class L[A](x: S[A, L[A]])    // Define a recursive type L via
 a recursion scheme S.
\end_layout

\end_inset

We must use a 
\emph on
class
\emph default
 to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

 because Scala does not support recursive type aliases:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> type L[A] = Either[A, L[A]]
\end_layout

\begin_layout Plain Layout

<console>:14: error: illegal cyclic reference involving type L
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> final case class L[A](x: Either[A, L[A]])
\end_layout

\begin_layout Plain Layout

defined class L
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Examples-of-recursive-disjunctive-type-equations"
plural "false"
caps "false"
noprefix "false"

\end_inset

 summarizes our previous examples of recursive disjunctive types and shows
 the relevant choices of 
\begin_inset Formula $S$
\end_inset

, which turns out to be always a bifunctor.
 For abstract syntax trees, the functors 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 must be given; they specify the available shapes of leaves and branches
 respectively.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type definition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Bifunctor 
\begin_inset Formula $S^{A,R}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq\bbnum 1+A\times L^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{A,R}\triangleq\bbnum 1+A\times R$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
non-empty list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{NEL}^{A}\triangleq A+A\times\text{NEL}^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{A,R}\triangleq A+A\times R$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
list of odd length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq A+A\times A\times L^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{A,R}\triangleq A+A\times A\times R$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
binary tree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq A+L^{A}\times L^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{A,R}\triangleq A+R\times R$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
rose tree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq A+\text{NEL}^{L^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{A,R}\triangleq A+\text{NEL}^{R}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
perfect-shaped binary tree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq A+L^{A\times A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
not possible
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
abstract syntax tree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $L^{A}\triangleq P^{A}+Q^{L^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $S^{A,R}\triangleq P^{A}+Q^{R}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Recursive disjunctive types defined using type equations.
\begin_inset CommandInset label
LatexCommand label
name "tab:Examples-of-recursive-disjunctive-type-equations"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now prove that Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-recursive-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) always defines a functor when 
\begin_inset Formula $S$
\end_inset

 is a bifunctor.
 The proof is by induction with an inductive assumption that the laws already
 hold for all recursive calls of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

.
 This generalizes the technique used in the proof for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor (Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-rec-poly-functor-List"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-functor-recursive"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-recursive"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $S$
\end_inset

 is a bifunctor then the recursively defined type constructor 
\begin_inset Formula $L$
\end_inset

 is a lawful functor:
\begin_inset Formula 
\[
L^{A}\triangleq S^{A,L^{A}}\quad.
\]

\end_inset

The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method for 
\begin_inset Formula $L$
\end_inset

 is a recursive function implemented as:
\begin_inset Formula 
\begin{equation}
\text{fmap}_{L}(f^{:A\rightarrow B})\triangleq\text{bimap}_{S}(f)(\text{fmap}_{L}(f))\quad.\label{eq:def-recursive-functor-fmap}
\end{equation}

\end_inset

The corresponding Scala code (assuming that 
\begin_inset Formula $S$
\end_inset

 and 
\begin_inset Formula $\text{bimap}_{S}$
\end_inset

 are already defined):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class L[A](x: S[A, L[A]]) // Must have defined S[_, _] before.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def bimap_S[A, B, C, D](f: A => C)(g: B => D): S[A, B] => S[C, D] = ???
 // Must define it here.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def fmap_L[A, B](f: A => B): L[A] => L[B] = { case L(x) =>
\end_layout

\begin_layout Plain Layout

    val newX: S[B, L[B]] = bimap_S(f)(fmap_L(f))(x) // Recursive call to
 fmap_L.
\end_layout

\begin_layout Plain Layout

    L(newX)   // Need to wrap the value of type S[B, L[B]] in L.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Usually, laws for a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
recursive function!proving laws for
\end_layout

\end_inset

recursive function (such as 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

) are proved by induction.
 The code of a recursive implementation of 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

 calls itself in some cases but returns without recursive calls in other
 cases.
 So, the base case of induction corresponds to the non-recursive evaluations
 in the code of 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

, and we need to prove that the law is then satisfied.
 The inductive step must prove that the code of 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

 obeys the law under the inductive assumption that all recursive calls to
 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

 already obey that law.
 In the proof, we do not need to separate the base case from the inductive
 step; we just derive the law using the inductive assumption whenever needed.
\end_layout

\begin_layout Standard
For clarity, we add an overline to recursive calls in the code formulas:
\begin_inset Formula 
\[
\text{fmap}_{L}(f)\triangleq\text{bimap}_{S}(f)(\overline{\text{fmap}_{L}}(f))\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To prove the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{fmap}_{L}(\text{id})\\
\text{definition of }\text{fmap}_{L}:\quad & =\text{bimap}_{S}(\text{id})\gunderline{(\overline{\text{fmap}_{L}}(\text{id}))}\\
\text{inductive assumption --- the law holds for }\overline{\text{fmap}_{L}}:\quad & =\text{bimap}_{S}(\text{id})(\text{id})\\
\text{identity law of }S:\quad & =\text{id}\quad.
\end{align*}

\end_inset

To prove the composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{fmap}_{L}(f\bef g):\quad & \text{fmap}_{L}(f)\bef\text{fmap}_{L}(g)\\
\text{definition of }\text{fmap}_{L}:\quad & =\text{bimap}_{S}(f)(\overline{\text{fmap}_{L}}(f))\bef\text{bimap}_{S}(g)(\overline{\text{fmap}_{L}}(g))\\
\text{composition law of }S:\quad & =\text{bimap}_{S}(f\bef g)(\gunderline{\overline{\text{fmap}_{L}}(f)\bef\overline{\text{fmap}_{L}}(g)})\\
\text{inductive assumption}:\quad & =\text{bimap}_{S}(f\bef g)(\overline{\text{fmap}_{L}}(f\bef g))\\
\text{definition of }\text{fmap}_{L}:\quad & =\text{fmap}_{L}(f\bef g)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
For a perfect-shaped binary tree, the construction
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-recursive-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is insufficient: no bifunctor 
\begin_inset Formula $S^{A,L^{A}}$
\end_inset

 can replace the type argument 
\begin_inset Formula $A$
\end_inset

 in 
\begin_inset Formula $L^{A}$
\end_inset

 to obtain 
\begin_inset Formula $L^{A\times A}$
\end_inset

.
 Indeed, 
\begin_inset Formula $S^{A,L^{A}}$
\end_inset

 is an application of a type-level function 
\begin_inset Formula $S$
\end_inset

 to its two type parameters, which are set to 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $L^{A}$
\end_inset

.
 In Scala syntax, 
\begin_inset Formula $S^{A,L^{A}}$
\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S[A, L[A]]
\end_layout

\end_inset

.
 No matter how we define the type constructor 
\begin_inset Formula $S$
\end_inset

, the resulting type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S[A, L[A]]
\end_layout

\end_inset

 will always use the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[A]
\end_layout

\end_inset

 and not as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

L[(A, A)]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
To describe perfect-shaped trees, we need to modify Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-recursive-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

) by introducing another arbitrary functor (
\begin_inset Formula $P$
\end_inset

) like this:
\begin_inset Formula 
\begin{equation}
L^{A}\triangleq S^{A,L^{P^{A}}}\quad.\label{eq:f-def-recursive-functor-2}
\end{equation}

\end_inset

The Scala syntax for 
\begin_inset Formula $S^{A,L^{P^{A}}}$
\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S[A, L[P[A]]]
\end_layout

\end_inset

.
 Perfect-shaped binary trees are defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-recursive-functor-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with 
\begin_inset Formula $S^{A,R}\triangleq A+R$
\end_inset

 and 
\begin_inset Formula $P^{A}\triangleq A\times A$
\end_inset

.
 The Scala code for these definitions is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type S[A, R] = Either[A, R]
\end_layout

\begin_layout Plain Layout

type P[A] = (A, A)
\end_layout

\begin_layout Plain Layout

final case class L[A](s: S[A, L[P[A]]])
\end_layout

\begin_layout Plain Layout

// Equivalently: case class L[A](s: Either[A, L[(A, A)]])
\end_layout

\end_inset

Different choices of 
\begin_inset Formula $P$
\end_inset

 will define perfect-shaped trees with different kinds of branching.
\end_layout

\begin_layout Standard
Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Exercise-recursive-functor-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows that type constructors defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-recursive-functor-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are always functors.
\end_layout

\begin_layout Subsection
Constructions of contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Contrafunctor-constructions"

\end_inset


\end_layout

\begin_layout Standard
The previous section performed 
\series bold
structural analysis
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
structural analysis|textit
\end_layout

\end_inset

 for functors: a systematic search for type constructions (product, co-product,
 etc.) that create new functors.

\emph on
 Mutatis mutandis
\emph default
, similar constructions work for contrafunctors, as shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Contrafunctor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 One difference with respect to Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the absence of the identity type constructor, 
\begin_inset Formula $L^{A}\triangleq A$
\end_inset

 (it is a functor, not a contrafunctor).
 However, the constant type constructor, 
\begin_inset Formula $L^{A}\triangleq Z$
\end_inset

, is a functor and a contrafunctor at the same time.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Construction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Assumptions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $C^{A}\triangleq P^{A}\times Q^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are contrafunctors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
disjunctive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $C^{A}\triangleq P^{A}+Q^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 are contrafunctors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
function type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $C^{A}\triangleq L^{A}\rightarrow H^{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $L$
\end_inset

 is a functor and 
\begin_inset Formula $H$
\end_inset

 is a contrafunctor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
type parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $C^{A}\triangleq Z$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $Z$
\end_inset

 is a fixed type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
type constructor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $C^{A}\triangleq P^{Q^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
one of 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $Q$
\end_inset

 is a functor and the other a contrafunctor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
recursive type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $C^{A}\triangleq S^{A,C^{A}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $S^{A,B}$
\end_inset

 is a contrafunctor w.r.t.
\begin_inset space ~
\end_inset


\begin_inset Formula $A$
\end_inset

 and functor w.r.t.
\begin_inset space ~
\end_inset


\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Type constructions defining a contrafunctor 
\begin_inset Formula $C$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:f-Contrafunctor-constructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us now prove the validity of some of these constructions.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-contrafunctor-constant"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-contrafunctor-constant"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $Z$
\end_inset

 is any fixed type, the constant type constructor 
\begin_inset Formula $C^{A}\triangleq Z$
\end_inset

 is a contrafunctor (the 
\series bold
constant contrafunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
constant contrafunctor
\end_layout

\end_inset

) whose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 returns an identity function of type 
\begin_inset Formula $Z\rightarrow Z$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type Const[Z, A] = Z
\end_layout

\begin_layout Plain Layout

def cmap[Z, A, B](f: B => A): Const[Z, A] => Const[Z, B] = identity[Z] 
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
All laws hold because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 returns an identity function:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \text{cmap}\left(\text{id}\right)=\text{id}\quad,\\
\text{composition law}:\quad & \text{cmap}\left(f\right)\bef\text{cmap}\left(g\right)=\text{id}\bef\text{id}=\text{id}=\text{cmap}\left(g\bef f\right)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-contrafunctor-composition-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-contrafunctor-composition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $P$
\end_inset

 is a functor and 
\begin_inset Formula $Q$
\end_inset

 is a contrafunctor then 
\begin_inset Formula $L^{A}\triangleq P^{Q^{A}}$
\end_inset

 is a contrafunctor with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cmap[A, B](f: B => A): P[Q[A]] => P[Q[B]] = fmap_P(cmap_Q(f))
\end_layout

\end_inset

where lawful implementations of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $_{P}$
\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset


\begin_inset Formula $_{Q}$
\end_inset

 are assumed to be given.
\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
Convert the Scala implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset


\begin_inset Formula $_{L}$
\end_inset

 into the code notation:
\begin_inset Formula 
\[
\text{cmap}_{L}(f^{:B\rightarrow A})\triangleq\text{fmap}_{P}(\text{cmap}_{Q}(f))\quad.
\]

\end_inset

It is easier to reason about this function if we rewrite the previous line
 as:
\begin_inset Formula 
\[
f^{\downarrow L}\triangleq\big(f^{\downarrow Q}\big)^{\uparrow P}\quad.
\]

\end_inset

The contrafunctor laws for 
\begin_inset Formula $L$
\end_inset

 are then proved like this:
\begin_inset Formula 
\begin{align*}
\text{identity law}:\quad & \text{id}^{\downarrow L}=(\text{id}^{\downarrow Q})^{\uparrow P}=\text{id}^{\uparrow P}=\text{id}\quad.\\
\text{composition law}:\quad & f^{\downarrow L}\bef g^{\downarrow L}=(f^{\downarrow Q})^{\uparrow P}\gunderline{\,\bef\,}(g^{\downarrow Q})^{\uparrow P}\\
\text{use }P\text{'s composition law}:\quad & \quad=\big(\gunderline{f^{\downarrow Q}\bef g^{\downarrow Q}}\big)^{\uparrow P}=\big((g\bef f\gunderline{)^{\downarrow Q}\big)^{\uparrow P}}=\left(g\bef f\right)^{\downarrow L}\quad.
\end{align*}

\end_inset


\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
The recursive construction is the same for contrafunctors, except that 
\begin_inset Formula $S^{A,R}$
\end_inset

 must be a contravariant in 
\begin_inset Formula $A$
\end_inset

 (but still covariant in 
\begin_inset Formula $R$
\end_inset

).
 An example of such a type constructor 
\begin_inset Formula $S$
\end_inset

 is:
\begin_inset Formula 
\begin{equation}
S^{A,R}\triangleq\left(A\rightarrow\text{Int}\right)+R\times R\quad.\label{eq:f-example-contra-bifunctor}
\end{equation}

\end_inset

This 
\begin_inset Formula $S$
\end_inset

 is not a bifunctor because it is contravariant in its first type parameter;
 so we cannot define a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

bimap
\end_layout

\end_inset

 function for 
\begin_inset Formula $S$
\end_inset

.
 However, we can define an analogous function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

 with the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def xmap[A, B, Q, R](f: B => A)(g: Q => R): S[A, Q] => S[B, R]
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \text{xmap}_{S}:\left(B\rightarrow A\right)\rightarrow\left(Q\rightarrow R\right)\rightarrow S^{A,Q}\rightarrow S^{B,R}\quad,\\
 & \text{xmap}_{S}(f^{:B\rightarrow A})(g^{:Q\rightarrow R})\triangleq\text{fmap}_{S^{A,\bullet}}(g)\bef\text{cmap}_{S^{\bullet,R}}(f)\quad.
\end{align*}

\end_inset

The type constructor 
\begin_inset Formula $S$
\end_inset

 is called a 
\series bold
profunctor
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor|textit
\end_layout

\end_inset

 if its 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

 obeys the laws of identity and composition:
\begin_inset Formula 
\begin{align}
\text{identity law}:\quad & \text{xmap}_{S}(\text{id})(\text{id})=\text{id}\quad,\label{eq:f-profunctor-identity-law}\\
\text{composition law}:\quad & \text{xmap}_{S}(f_{1})(g_{1})\bef\text{xmap}_{S}(f_{2})(g_{2})=\text{xmap}_{S}(f_{2}\bef f_{1})(g_{1}\bef g_{2})\quad.\label{eq:f-profunctor-composition-law}
\end{align}

\end_inset

These laws are similar to the identity and composition laws for bifunctors
 (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Bifunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

) except for inverting the order of the composition 
\begin_inset Formula $\left(f_{2}\bef f_{1}\right)$
\end_inset

.
 The laws hold automatically whenever the functor and contrafunctor methods
 for 
\begin_inset Formula $S$
\end_inset

 (
\begin_inset Formula $\text{fmap}_{S^{A,\bullet}}$
\end_inset

 and 
\begin_inset Formula $\text{cmap}_{S^{\bullet,R}}$
\end_inset

) are fully parametric.
 We omit the details since they are quite similar to what we saw in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Bifunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for bifunctors.
\end_layout

\begin_layout Standard
If we define a type constructor 
\begin_inset Formula $L$
\end_inset

 using the recursive 
\begin_inset Quotes eld
\end_inset

type equation
\begin_inset Index idx
status open

\begin_layout Plain Layout
type equation
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
L^{A}\triangleq S^{A,L^{A}}\triangleq\left(A\rightarrow\text{Int}\right)+L^{A}\times L^{A}\quad,
\]

\end_inset

we obtain a contrafunctor in the shape of a binary tree whose leaves are
 functions of type 
\begin_inset Formula $A\rightarrow\text{Int}$
\end_inset

.
 The next statement shows that recursive type equations of this kind always
 define contrafunctors.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Statement-contrafunctor-recursive-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-contrafunctor-recursive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $S^{A,R}$
\end_inset

 is contravariant with respect to 
\begin_inset Formula $A$
\end_inset

 and covariant with respect to 
\begin_inset Formula $R$
\end_inset

 then the recursively defined type constructor 
\begin_inset Formula $C$
\end_inset

 is a contrafunctor:
\begin_inset Formula 
\[
C^{A}\triangleq S^{A,C^{A}}\quad.
\]

\end_inset

Given the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset


\begin_inset Formula $_{S^{\bullet,R}}$
\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $_{S^{A,\bullet}}$
\end_inset

 for 
\begin_inset Formula $S$
\end_inset

, we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset


\begin_inset Formula $_{C}$
\end_inset

 as:
\begin_inset Formula 
\begin{align*}
\text{cmap}_{C}(f^{:B\rightarrow A}) & :C^{A}\rightarrow C^{B}\cong S^{A,C^{A}}\rightarrow S^{B,C^{B}}\quad,\\
\text{cmap}_{C}(f^{:B\rightarrow A}) & \triangleq\text{xmap}_{S}(f)(\overline{\text{cmap}_{C}}(f))\quad.
\end{align*}

\end_inset

The corresponding Scala code can be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class C[A](x: S[A, C[A]]) // The type constructor S[_, _] must
 be defined previously.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def xmap_S[A,B,Q,R](f: B => A)(g: Q => R): S[A, Q] => S[B, R] = ??? // Must
 be defined.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def cmap_C[A, B](f: B => A): C[A] => C[B] = { case C(x) =>
\end_layout

\begin_layout Plain Layout

  val sbcb: S[B, C[B]] = xmap_S(f)(cmap_C(f))(x) // Recursive call to cmap_C.
\end_layout

\begin_layout Plain Layout

  C(sbcb) // Need to wrap the value of type S[B, C[B]] in C.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
We mark by an overline the recursive call in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

: 
\begin_inset Formula 
\[
\text{cmap}_{C}(f)\triangleq f^{\downarrow C}\triangleq\text{xmap}_{S}(f)(\overline{\text{cmap}_{C}}(f))\quad.
\]

\end_inset

To verify the identity law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{cmap}_{C}(\text{id})=\text{xmap}_{S}(\text{id})(\gunderline{\overline{\text{cmap}_{C}}(\text{id})})\\
\text{inductive assumption}:\quad & =\text{xmap}_{S}(\text{id})(\text{id})\\
\text{identity law of }\text{xmap}_{S}:\quad & =\text{id}\quad.
\end{align*}

\end_inset

To verify the composition law:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(g^{\downarrow C}\bef f^{\downarrow C}):\quad & (f^{:D\rightarrow B}\bef g^{:B\rightarrow A})^{\downarrow C}=\text{xmap}_{S}(f\bef g)(\gunderline{\overline{\text{cmap}_{C}}(f\bef g)})\\
\text{inductive assumption}:\quad & =\text{xmap}_{S}(f\bef g)(\overline{\text{cmap}_{C}}(g)\bef\overline{\text{cmap}_{C}}(f)))\\
\text{composition law of }\text{xmap}_{S}:\quad & =\text{xmap}_{S}(g)(\overline{\text{cmap}_{C}}(g))\bef\text{xmap}_{S}(f)(\overline{\text{cmap}_{C}}(f))\\
\text{definition of }^{\downarrow C}:\quad & =g^{\downarrow C}\bef f^{\downarrow C}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Examples: Recognizing functors and contrafunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Solved-examples:-How-to-recognize-functors"

\end_inset


\end_layout

\begin_layout Standard
Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Contrafunctor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 describe how functors and contrafunctors are built from various type expression
s.
 Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Contrafunctor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 show that 
\emph on
every
\emph default
 one of the six basic type constructions
\begin_inset Index idx
status open

\begin_layout Plain Layout
six type constructions
\end_layout

\end_inset

 (unit type, type parameters, product types, co-product types, function
 types, recursive types) gives either a new functor or a new contrafunctor.
 The six type constructions generate all 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exponential-polynomial type
\end_layout

\end_inset

exponential-polynomial types, including recursive ones.
 So, we should be able to decide whether any given exponential-polynomial
 type expression is a functor or a contrafunctor.
 The decision algorithm is based on the results shown in Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Functor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:f-Contrafunctor-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Itemize
Primitive types 
\begin_inset Formula $\bbnum 1$
\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, etc., can be viewed both as constant functors and as constant contrafunctors
 (since they do not contain type parameters).
\end_layout

\begin_layout Itemize
Polynomial type expressions (not containing any function arrows) are always
 functors
\begin_inset Index idx
status open

\begin_layout Plain Layout
polynomial functor
\end_layout

\end_inset

 with respect to every type parameter.
 Equivalently, we may say that all polynomial type constructors are covariant
 in every type parameter.
 For example, the type expression 
\begin_inset Formula $A\times B+\left(A+\bbnum 1+B\right)\times A\times C$
\end_inset

 is covariant in each of the type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

.
\end_layout

\begin_layout Itemize
Type parameters to the right of a function arrow are in a covariant position.
 For example, 
\begin_inset Formula $F^{A}\triangleq\text{Int}\rightarrow A$
\end_inset

 is covariant in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Itemize
Each time a type parameter is placed to the left of an 
\emph on
uncurried
\emph default
 function arrow 
\begin_inset Formula $\rightarrow$
\end_inset

, the variance is reversed: covariant becomes contravariant and vice versa.
 For example:
\begin_inset Formula 
\begin{align*}
\text{this is covariant in }A:\quad & \bbnum 1+A\times A\quad,\\
\text{this is contravariant in }A:\quad & \left(\bbnum 1+A\times A\right)\rightarrow\text{Int}\quad,\\
\text{this is covariant in }A:\quad & \left(\left(\bbnum 1+A\times A\right)\rightarrow\text{Int}\right)\rightarrow\text{Int}\quad,\\
\text{this is contravariant in }A:\quad & \left(\left(\left(\bbnum 1+A\times A\right)\rightarrow\text{Int}\right)\rightarrow\text{Int}\right)\rightarrow\text{Int}\quad.
\end{align*}

\end_inset

Indeed, Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

 proves that any contravariant type expression (i.e., a contrafunctor) placed
 to the left of a function arrow will create a covariant functor.
 One can prove in a similar way that a function arrow turns covariance into
 contravariance (Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-contrafunctor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Itemize
Repeated curried function arrows work as one arrow: 
\begin_inset Formula $A\rightarrow\text{Int}$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

, and 
\begin_inset Formula $A\rightarrow A\rightarrow A\rightarrow\text{Int}$
\end_inset

 is still contravariant in 
\begin_inset Formula $A$
\end_inset

.
 This is  because the type 
\begin_inset Formula $A\rightarrow A\rightarrow A\rightarrow\text{Int}$
\end_inset

 is equivalent to 
\begin_inset Formula $A\times A\times A\rightarrow\text{Int}$
\end_inset

, which is of the form 
\begin_inset Formula $F^{A}\rightarrow\text{Int}$
\end_inset

 with a type constructor 
\begin_inset Formula $F^{A}\triangleq A\times A\times A$
\end_inset

.
 Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-contrafunctor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show that 
\begin_inset Formula $F^{A}\rightarrow\text{Int}$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Itemize
Nested type constructors combine their variances: e.g., if 
\begin_inset Formula $F^{A}$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

 then 
\begin_inset Formula $F^{A\rightarrow\text{Int}}$
\end_inset

 is covariant in 
\begin_inset Formula $A$
\end_inset

, while 
\begin_inset Formula $F^{A\times A\times A}$
\end_inset

 is contravariant in 
\begin_inset Formula $A$
\end_inset

.
 This is shown in Exercises
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

(c), (d).
\end_layout

\begin_layout Standard
To see how this works in practice, consider any exponential-polynomial type
 expression, such as Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-example-complicated-z"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\[
Z^{A,R}\triangleq\left(\left(A\rightarrow A\rightarrow R\right)\rightarrow R\right)\times A+\left(\bbnum 1+R\rightarrow A+\text{Int}\right)+A\times A\times\text{Int}\times\text{Int}\quad.
\]

\end_inset

Mark the position of each type parameter as either covariant (
\begin_inset Formula $+$
\end_inset

) or contravariant (
\begin_inset Formula $-$
\end_inset

), according to the number of nested 
\emph on
uncurried
\emph default
 function arrows:
\begin_inset Formula 
\[
\big(\big(\underset{+}{A}\rightarrow\underset{+}{A}\rightarrow\underset{-}{R}\big)\rightarrow\underset{+}{R}\big)\times\underset{+}{A}+\big(\bbnum 1+\underset{-}{R}\rightarrow\underset{+}{A}+\text{Int}\big)+\underset{+}{A}\times\underset{+}{A}\times\text{Int}\times\text{Int}\quad.
\]

\end_inset

We find that 
\begin_inset Formula $A$
\end_inset

 is always in covariant positions, while 
\begin_inset Formula $R$
\end_inset

 is sometimes in covariant and sometimes in contravariant positions.
 So, we expect that 
\begin_inset Formula $Z^{A,R}$
\end_inset

 is a functor with respect to 
\begin_inset Formula $A$
\end_inset

, but not a functor (nor a contrafunctor) with respect to 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Standard
To show that 
\begin_inset Formula $Z^{A,R}$
\end_inset

 is indeed a functor in the parameter 
\begin_inset Formula $A$
\end_inset

, we need to implement a suitable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method and verify that the functor laws hold.
 To do that from scratch, we could use the techniques explained in this
 and the previous chapters: starting from the type signature,
\begin_inset Formula 
\[
\text{map}_{Z}:Z^{A,R}\rightarrow\left(A\rightarrow B\right)\rightarrow Z^{B,R}\quad,
\]

\end_inset

we could derive a fully parametric, information-preserving implementation
 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 We could then look for proofs of the identity and composition laws for
 that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 function.
 This would require a lot of work for a complicated type constructor such
 as 
\begin_inset Formula $Z^{A,R}$
\end_inset

.
\end_layout

\begin_layout Standard
All that work can be avoided if we build 
\begin_inset Formula $Z^{A,R}$
\end_inset

 step by step via the known functor and contrafunctor constructions.
 Each step automatically provides both a fragment of the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and a proof that the functor laws hold up to that step.
 In this way, we will avoid the need to guess an implementation of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or prove the laws for each new functor and contrafunctor.
 The next examples illustrate this procedure on a simpler type constructor.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-recognize-type-variance-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-recognize-type-variance-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rewrite the Scala definitions in the type notation.
 Are 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 covariant or contravariant with respect to each type parameter?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final case class F[A, Z](f: Int => Z => (Int, A))
\end_layout

\begin_layout Plain Layout

final case class G[A, Z](p: Either[Int, A], q: Option[Z => F[A, Z]])
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The type notation for 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 is: 
\begin_inset Formula 
\begin{align*}
 & F^{A,Z}\triangleq\text{Int}\rightarrow Z\rightarrow\text{Int}\times A\quad,\\
 & G^{A,Z}\triangleq(\text{Int}+A)\times(\bbnum 1+(Z\rightarrow F^{A,Z}))=(\text{Int}+A)\times(\bbnum 1+(Z\rightarrow\text{Int}\rightarrow Z\rightarrow\text{Int}\times A))\quad.
\end{align*}

\end_inset

Mark the covariant and the contravariant positions in the type expressions
 for 
\begin_inset Formula $F^{A,Z}$
\end_inset

 and 
\begin_inset Formula $G^{A,Z}$
\end_inset

:
\begin_inset Formula 
\[
F^{A,Z}=\text{Int}\rightarrow\underset{-}{Z}\rightarrow\text{Int}\times\underset{+}{A}\quad,\quad G^{A,Z}=(\text{Int}+\underset{+}{A})\times(\bbnum 1+(\underset{-}{Z}\rightarrow\text{Int}\rightarrow\underset{-}{Z}\rightarrow\text{Int}\times\underset{+}{A}))\quad.
\]

\end_inset

All 
\begin_inset Formula $Z$
\end_inset

 positions in the sub-expression 
\begin_inset Formula $Z\rightarrow\text{Int}\rightarrow Z\rightarrow\text{Int}\times A$
\end_inset

 are contravariant since the function arrows are curried rather than nested.
 So, 
\begin_inset Formula $A$
\end_inset

 is always in covariant positions (
\begin_inset Formula $+$
\end_inset

) while 
\begin_inset Formula $Z$
\end_inset

 is always in contravariant positions (
\begin_inset Formula $-$
\end_inset

).
 It follows that 
\begin_inset Formula $F^{A,Z}$
\end_inset

 and 
\begin_inset Formula $G^{A,Z}$
\end_inset

 are covariant in 
\begin_inset Formula $A$
\end_inset

 but contravariant in 
\begin_inset Formula $Z$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Example-recognize-type-variance-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-recognize-type-variance-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Use known functor constructions to implement the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 method with respect to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G[A, Z]
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Example-recognize-type-variance-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
At the top level of its type expression, 
\begin_inset Formula $G^{A,Z}$
\end_inset

 is a product type.
 So, we begin by using the 
\begin_inset Quotes eld
\end_inset

functor product
\begin_inset Quotes erd
\end_inset

 construction (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

): 
\begin_inset Formula 
\begin{align*}
 & G^{A,Z}\cong G_{1}^{A}\times G_{2}^{A,Z}\quad,\\
\text{where }\quad & G_{1}^{A}\triangleq\text{Int}+A\quad\text{ and }\quad G_{2}^{A,Z}\triangleq\bbnum 1+(Z\rightarrow\text{Int}\rightarrow Z\rightarrow\text{Int}\times A)\quad.
\end{align*}

\end_inset

We continue with 
\begin_inset Formula $G_{1}^{A}$
\end_inset

, which is a co-product of 
\begin_inset Formula $\text{Int}$
\end_inset

 (a constant functor) and 
\begin_inset Formula $A$
\end_inset

 (the identity functor).
 The constant functor and the identity functor have lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 implementations that are already known (Statements
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Statement-identity-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Statement-constant-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Now, the 
\begin_inset Quotes eld
\end_inset

functor co-product
\begin_inset Quotes erd
\end_inset

 construction (Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

) produces a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 implementation for 
\begin_inset Formula $G_{1}^{A}$
\end_inset

 together with a proof that it satisfies the functor laws:
\begin_inset Formula 
\[
\text{fmap}_{G_{1}}(f^{:A\rightarrow B})=f^{\uparrow G_{1}}\triangleq\,\begin{array}{|c||cc|}
 & \text{Int} & B\\
\hline \text{Int} & \text{id} & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\quad.
\]

\end_inset

Turning our attention to 
\begin_inset Formula $G_{2}^{A,Z}$
\end_inset

, we find that it is a disjunctive type containing a curried function type
 that ultimately returns the product type 
\begin_inset Formula $\text{Int}\times A$
\end_inset

.
 This tells us to use the functor constructions for 
\begin_inset Quotes eld
\end_inset

co-product
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

exponential
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

product
\begin_inset Quotes erd
\end_inset

.
 Write down the functor constructions needed at each step as we decompose
 
\begin_inset Formula $G_{2}^{A,Z}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & G_{2}^{A,Z}\triangleq\bbnum 1+(Z\rightarrow\text{Int}\rightarrow Z\rightarrow\text{Int}\times A)\quad.\\
\text{co-product}:\quad & G_{2}^{A,Z}\cong\bbnum 1+G_{3}^{A,Z}\quad\text{ where }\quad G_{3}^{A,Z}\triangleq Z\rightarrow\text{Int}\rightarrow Z\rightarrow\text{Int}\times A\quad.\\
\text{exponential}:\quad & G_{3}^{A,Z}\cong Z\rightarrow G_{4}^{A,Z}\quad\text{ where \quad}G_{4}^{A,Z}\triangleq\text{Int}\rightarrow Z\rightarrow\text{Int}\times A\quad.\\
\text{exponential}:\quad & G_{4}^{A,Z}\cong\text{Int}\rightarrow G_{5}^{A,Z}\quad\text{ where }\quad G_{5}^{A,Z}\triangleq Z\rightarrow\text{Int}\times A\quad.\\
\text{exponential}:\quad & G_{5}^{A,Z}\cong Z\rightarrow G_{6}^{A}\quad\text{ where }\quad G_{6}^{A}\triangleq\text{Int}\times A\quad.\\
\text{product}:\quad & G_{6}^{A}\cong\text{Int}\times A\cong\text{Const}^{\text{Int},A}\times\text{Id}^{A}\quad.
\end{align*}

\end_inset

Each of the type constructors 
\begin_inset Formula $G_{1}$
\end_inset

, ..., 
\begin_inset Formula $G_{6}$
\end_inset

 is a functor in 
\begin_inset Formula $A$
\end_inset

 because all of the listed constructions preserve the functor laws.
 Therefore, 
\begin_inset Formula $G^{A,Z}$
\end_inset

 is a functor in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
It remains to derive the code for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method of 
\begin_inset Formula $G$
\end_inset

.
 Each of the functor constructions combines the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 implementations from previously defined functors into a new 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 implementation, so we just need to combine the code fragments in the order
 of constructions.
 For brevity, we will use the notations 
\begin_inset Formula $f^{\uparrow L}\triangleq\text{fmap}_{L}(f)$
\end_inset

 and 
\begin_inset Formula $x\triangleright f^{\uparrow L}$
\end_inset

 instead of the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f)
\end_layout

\end_inset

 throughout the derivations:
\begin_inset Formula 
\begin{align*}
\text{product}:\quad & G^{A,Z}\cong G_{1}^{A}\times G_{2}^{A,Z}\quad,\quad(g_{1}\times g_{2})\triangleright f^{\uparrow G}=(g_{1}\triangleright f^{\uparrow G_{1}})\times(g_{2}\triangleright f^{\uparrow G_{2}})\quad.\\
\text{co-product}:\quad & G_{1}^{A}\triangleq\text{Int}+A\quad,\quad f^{\uparrow G_{1}}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & f
\end{array}\quad.
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{co-product}:\quad & G_{2}^{A,Z}\triangleq\bbnum 1+G_{3}^{A,Z}\quad,\quad f^{\uparrow G_{2}}=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & f^{\uparrow G_{3}}
\end{array}\quad.\\
\text{exponential}:\quad & G_{3}^{A,Z}\triangleq Z\rightarrow G_{4}^{A,Z}\quad,\quad g_{3}\triangleright f^{\uparrow G_{3}}=g_{3}\bef f^{\uparrow G_{4}}=z^{:Z}\rightarrow z\triangleright g_{3}\triangleright f^{\uparrow G_{4}}\quad.
\end{align*}

\end_inset

The pipe symbol (
\begin_inset Formula $\triangleright$
\end_inset

) groups stronger than the function arrow.
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation!operator precedence
\end_layout

\end_inset

 So, 
\begin_inset Formula $z\rightarrow z\triangleright g\triangleright h$
\end_inset

 means 
\begin_inset Formula $z\rightarrow(z\triangleright g\triangleright h)$
\end_inset

, or 
\begin_inset Formula $z\rightarrow h(g(z))$
\end_inset

.
 Applying the exponential  construction three times, we finally obtain:
\begin_inset Formula 
\begin{align*}
 & G_{3}^{A,Z}\triangleq Z\rightarrow\text{Int}\rightarrow Z\rightarrow G_{6}^{A}\quad,\\
 & \quad\quad g_{3}\triangleright f^{\uparrow G_{3}}=z_{1}^{:Z}\rightarrow n^{:\text{Int}}\rightarrow z_{2}^{:Z}\rightarrow g_{3}(z_{1})(n)(z_{2})\triangleright f^{\uparrow G_{6}}\quad.\\
 & G_{6}^{A}\triangleq\text{Int}\times A\quad,\\
 & \quad\quad(i\times a)\triangleright f^{\uparrow G_{6}}=i\times f(a)\quad.
\end{align*}

\end_inset

We can now write the corresponding Scala code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset


\begin_inset Formula $_{G}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_G[A, B, Z](f: A => B): G[A, Z] => G[B, Z] = { case G(p, q) =>
\end_layout

\begin_layout Plain Layout

  val newP: Either[Int, B] = p.map(f)      // Use the standard map method
 for Either[Int, A].
\end_layout

\begin_layout Plain Layout

  val newQ: Option[Z => Int => Z => (Int, B)]  = q.map { // Use the map method
 for Option.
\end_layout

\begin_layout Plain Layout

    (g3: Z => Int => Z => (Int, A)) => 
\end_layout

\begin_layout Plain Layout

       z1 => n => z2 =>             // The code of map for G_3.
\end_layout

\begin_layout Plain Layout

         val (i, a) = g3(z1)(n)(z2)
\end_layout

\begin_layout Plain Layout

         (i, f(a))                  // The code of map for G_6.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  G(newP, newQ)                     // The code of map for G_1.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In this way, the correct-by-construction code of 
\begin_inset Formula $\text{fmap}_{G}$
\end_inset

 may be 
\emph on
derived
\emph default
 for any functor 
\begin_inset Formula $G$
\end_inset

 whose type expression is given, and similarly the code for 
\begin_inset Formula $\text{cmap}_{C}$
\end_inset

 for any given contrafunctor 
\begin_inset Formula $C$
\end_inset

.
 The corresponding algorithms could be implemented as a Scala macro library
 that derives the code at compile time.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
What tasks can we perform with the techniques of this chapter?
\end_layout

\begin_layout Itemize
Quickly decide if a given type constructor is a functor, a contrafunctor,
 or neither.
\end_layout

\begin_layout Itemize
Implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 function that satisfies the appropriate laws.
\end_layout

\begin_layout Itemize
Use constructions to derive the correct code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 with no guessing.
\end_layout

\begin_layout Itemize
Write more readable code using functor blocks to manipulate data wrapped
 in functors.
\end_layout

\begin_layout Subsection
Exercises: Functor and contrafunctor constructions 
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-contrafunctor-exponential"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-contrafunctor-exponential"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $H^{A}$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $L^{A}$
\end_inset

 is a functor, show that 
\begin_inset Formula $C\triangleq L^{A}\rightarrow H^{A}$
\end_inset

 is a contrafunctor with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 method defined by the following code:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

def cmap[A, B](f: B => A)(c: L[A] => H[A]): L[B] => H[B] = {
\end_layout

\begin_layout Plain Layout

  lb: L[B] => cmap_H(f)(c(fmap_L(f)(lb))) // Code notation: ${
\backslash
color{dkgreen}
\backslash
scriptstyle f^{
\backslash
downarrow C}
\backslash
,
\backslash
,
\backslash
triangleq
\backslash
, c
\backslash
rightarrow f^{
\backslash
uparrow L}
\backslash
bef c
\backslash
bef f^{
\backslash
downarrow H}}$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Here, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap_H
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap_L
\end_layout

\end_inset

 are the methods already defined for 
\begin_inset Formula $H$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
 Prove that the laws hold.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-functor-laws"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-laws"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the required 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 function for the given type constructors 
\begin_inset Formula $L$
\end_inset

 and prove that the appropriate laws hold.
 Write the implementations both in Scala and in the code notation.
 Assume that the given type constructors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 already satisfy their respective laws.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $L^{A}\triangleq F^{A}\times G^{A}$
\end_inset

 is a contrafunctor if 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are contrafunctors.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $L^{A}\triangleq F^{A}+G^{A}$
\end_inset

 is a contrafunctor if 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $G^{A}$
\end_inset

 are contrafunctors.
\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $L^{A}\triangleq F^{G^{A}}$
\end_inset

 is a functor when both 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are contrafunctors.
\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $L^{A}\triangleq F^{G^{A}}$
\end_inset

 is a contrafunctor when 
\begin_inset Formula $F$
\end_inset

 is a contrafunctor and 
\begin_inset Formula $G$
\end_inset

 is a functor.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-functor-constructions-0"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-constructions-0"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset Formula $L^{A}\triangleq F^{A}\rightarrow G^{A}$
\end_inset

 is, in general, neither a functor nor a contrafunctor if both 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

 are functors or both are contrafunctors (give examples of suitable 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

).
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-functor-constructions-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-constructions-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For each of the Scala type constructors defined below, formulate the definition
 in the type notation and decide whether the type constructors are functors,
 contrafunctors, or neither:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type F[A] = Int => (Option[A], Either[A, Int], Either[A, A])
\end_layout

\begin_layout Plain Layout

type G[A] = ((Int, A)) => Either[Int, A]
\end_layout

\begin_layout Plain Layout

type H[A] = Either[A, (A, Option[A])] => Int => Int
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-functor-constructions-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-constructions-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the known constructions, determine which of the following are functors
 or contrafunctors (or neither) and implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 if appropriate.
 Answer this question with respect to each type parameter separately.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $F^{A}\triangleq\text{Int}\times A\times A+(\text{String}\rightarrow A)\times A\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $G^{A,B}\triangleq\left(A\rightarrow\text{Int}\rightarrow\bbnum 1+B\right)+\left(A\rightarrow\bbnum 1+A\rightarrow\text{Int}\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $H^{A,B,C}\triangleq\left(A\rightarrow A\rightarrow B\rightarrow C\right)\times C+\left(B\rightarrow A\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $P^{A,B}\triangleq\left(\left(\left(A\rightarrow B\right)\rightarrow A\right)\rightarrow B\right)\rightarrow A\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-functor-constructions-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-constructions-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the recursive type constructor 
\begin_inset Formula $L$
\end_inset

 defined by:
\begin_inset Formula 
\[
L^{A}\triangleq\bbnum 1+A+L^{A}
\]

\end_inset

is a functor, and implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function for 
\begin_inset Formula $L$
\end_inset

 in Scala.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-functor-constructions-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-constructions-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the perfect-shaped tree 
\begin_inset Formula $L$
\end_inset

 defined by:
\begin_inset Formula 
\[
L^{A}\triangleq A\times A+L^{A\times A\times A}
\]

\end_inset

is a functor, and implement a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 function for 
\begin_inset Formula $L$
\end_inset

 in Scala.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Exercise-recursive-functor-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Exercise-recursive-functor-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the type constructor 
\begin_inset Formula $L$
\end_inset

 defined by Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-def-recursive-functor-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is a functor for any given bifunctor 
\begin_inset Formula $S$
\end_inset

 and functor 
\begin_inset Formula $P$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:functor-Exercise-functor-lifted-equivalence"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Exercise-functor-lifted-equivalence"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Given any functor 
\begin_inset Formula $F$
\end_inset

, show that if two types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are equivalent then the types 
\begin_inset Formula $F^{A}$
\end_inset

 and 
\begin_inset Formula $F^{B}$
\end_inset

 are also equivalent.
 
\series bold
(b)
\series default
 Show that the same property holds for any contrafunctor 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Section
Further developments
\end_layout

\begin_layout Subsection
Profunctors
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Profunctors"

\end_inset


\end_layout

\begin_layout Standard
We have seen that some type constructors are neither functors nor contrafunctors
 because their type parameters appear both in covariant and contravariant
 positions.
 An example of such a type constructor is:
\begin_inset Formula 
\[
P^{A}\triangleq A+\left(A\rightarrow\text{Int}\right)\quad.
\]

\end_inset

It is not possible to define either a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 function for 
\begin_inset Formula $P$
\end_inset

: the required type signatures cannot be implemented via fully parametric
 code.
 However, we 
\emph on
can
\emph default
 implement a fully parametric function called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

 with the type signature:
\begin_inset Formula 
\[
\text{xmap}_{P}:\left(B\rightarrow A\right)\rightarrow\left(A\rightarrow B\right)\rightarrow P^{A}\rightarrow P^{B}\quad.
\]

\end_inset

To see why, let us temporarily rename the contravariant occurrence of 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $Z$
\end_inset

 and define a new type constructor 
\begin_inset Formula $\tilde{P}$
\end_inset

 by:
\begin_inset Formula 
\[
\tilde{P}^{Z,A}\triangleq A+\left(Z\rightarrow\text{Int}\right)\quad.
\]

\end_inset

The original type constructor 
\begin_inset Formula $P^{A}$
\end_inset

 is expressed as 
\begin_inset Formula $P^{A}=\tilde{P}^{A,A}$
\end_inset

.
 Now, 
\begin_inset Formula $\tilde{P}^{Z,A}$
\end_inset

 is covariant in 
\begin_inset Formula $A$
\end_inset

 and contravariant in 
\begin_inset Formula $Z$
\end_inset

.
 We can implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\begin_inset Formula $_{\tilde{P}}$
\end_inset

 as a composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 with respect to 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cmap
\end_layout

\end_inset

 with respect to 
\begin_inset Formula $Z$
\end_inset

, similarly to what we saw in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-contrafunctor-recursive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\begin_inset Formula $_{\tilde{P}}$
\end_inset

 will satisfy the identity and composition laws
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-profunctor-identity-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

)–(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:f-profunctor-composition-law"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Setting the type parameter 
\begin_inset Formula $Z=A$
\end_inset

, we will obtain the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\begin_inset Formula $_{P}$
\end_inset

 function for 
\begin_inset Formula $P$
\end_inset

.
 The identity and composition laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\begin_inset Formula $_{P}$
\end_inset

 will hold, since the laws of 
\begin_inset Formula $\tilde{P}^{Z,A}$
\end_inset

 hold for all type parameters:
\begin_inset Formula 
\begin{align*}
P\text{'s identity law}:\quad & \text{xmap}_{P}(\text{id}^{:A\rightarrow A})(\text{id}^{:A\rightarrow A})=\text{id}\quad,\\
P\text{'s composition law}:\quad & \text{xmap}_{P}(f_{1}^{:B\rightarrow A})(g_{1}^{:A\rightarrow B})\bef\text{xmap}_{P}(f_{2}^{:C\rightarrow B})(g_{2}^{:B\rightarrow C})\\
 & \quad=\text{xmap}_{P}(f_{2}\bef f_{1})(g_{1}\bef g_{2})\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
A type constructor 
\begin_inset Formula $\tilde{P}^{Z,A}$
\end_inset

 with a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\begin_inset Formula $_{\tilde{P}}$
\end_inset

 is called a profunctor
\begin_inset Index idx
status open

\begin_layout Plain Layout
profunctor
\end_layout

\end_inset

.
 We will sometimes also call the type constructor 
\begin_inset Formula $P^{A}\triangleq\tilde{P}^{A,A}$
\end_inset

 a profunctor.
\end_layout

\begin_layout Standard
Consider an exponential-polynomial type constructor 
\begin_inset Formula $P^{A}$
\end_inset

 such as:
\begin_inset Formula 
\[
P^{A}\triangleq\left(\bbnum 1+A\times A\rightarrow A\right)\times A\rightarrow\bbnum 1+\left(A\rightarrow A+\text{Int}\right)\quad.
\]

\end_inset

Each copy of the type parameter 
\begin_inset Formula $A$
\end_inset

 will occur either in covariant or in a contravariant position because no
 other possibility is available in exponential-polynomial types.
 So, we can always rename all contravariant occurrences of the type parameter
 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $Z$
\end_inset

 and obtain a new type constructor 
\begin_inset Formula $\tilde{P}^{Z,A}$
\end_inset

, which will be covariant in 
\begin_inset Formula $A$
\end_inset

 and contravariant in 
\begin_inset Formula $Z$
\end_inset

.
 Since 
\begin_inset Formula $\tilde{P}^{A,Z}$
\end_inset

 is a functor in 
\begin_inset Formula $A$
\end_inset

 and a contrafunctor in 
\begin_inset Formula $Z$
\end_inset

, we will be able to define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\begin_inset Formula $_{\tilde{P}}$
\end_inset

 satisfying the identity and composition laws.
 Setting 
\begin_inset Formula $Z=A$
\end_inset

, we will obtain a lawful 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset


\begin_inset Formula $_{P}$
\end_inset

, which makes 
\begin_inset Formula $P$
\end_inset

 a profunctor.
 So, 
\emph on
every
\emph default
 exponential-polynomial type constructor is a profunctor.
\end_layout

\begin_layout Standard
GADTs
\begin_inset Index idx
status open

\begin_layout Plain Layout
GADT
\end_layout

\end_inset

, such as the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[R]
\end_layout

\end_inset

 shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-non-functors"
plural "false"
caps "false"
noprefix "false"

\end_inset

, cannot be made into profunctors.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xmap
\end_layout

\end_inset

 cannot be implemented for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ServerAction[R]
\end_layout

\end_inset

 because it is not a fully parametric type constructor (and so is not exponentia
l-polynomial).
\end_layout

\begin_layout Standard
Profunctors are not often used in practical coding.
 We will see profunctors occasionally in later chapters where we need to
 reason about type constructors of arbitrary variance.
\end_layout

\begin_layout Subsection
Subtyping with injective or surjective conversion functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Subtyping-with-injective"

\end_inset


\end_layout

\begin_layout Standard
When 
\begin_inset Formula $P$
\end_inset

 is a subtype of 
\begin_inset Formula $Q$
\end_inset

 (denoted as 
\begin_inset Formula $P\lesssim Q$
\end_inset

), sometimes the set of values of 
\begin_inset Formula $P$
\end_inset

 is a 
\emph on
subset
\emph default
 of values of 
\begin_inset Formula $Q$
\end_inset

.
 In that case, the subtype conversion function
\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping!subtype conversion function
\end_layout

\end_inset

 
\begin_inset Formula $P\rightarrow Q$
\end_inset

 preserves all information from a value of type 
\begin_inset Formula $P$
\end_inset

 within a value of type 
\begin_inset Formula $Q$
\end_inset

.
 This kind of functions are called 
\begin_inset Quotes eld
\end_inset

injective
\begin_inset Quotes erd
\end_inset

.
 The intuition is that all values of type 
\begin_inset Formula $P$
\end_inset

 can be somehow embedded into the type 
\begin_inset Formula $Q$
\end_inset

 without loss of information.
\end_layout

\begin_layout Standard
If all information from 
\begin_inset Formula $P$
\end_inset

 is preserved in 
\begin_inset Formula $Q$
\end_inset

, we should be able to recover the original value of type 
\begin_inset Formula $P$
\end_inset

 after converting to 
\begin_inset Formula $Q$
\end_inset

.
 The procedure for recovering the original value is a function of type 
\begin_inset Formula $Q\rightarrow P$
\end_inset

.
 So, a more formal definition is that a function 
\begin_inset Formula $f:P\rightarrow Q$
\end_inset

 is 
\series bold
injective
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
injective function
\end_layout

\end_inset

 if there exists a function 
\begin_inset Formula $g:Q\rightarrow P$
\end_inset

 such that 
\begin_inset Formula $f\bef g=\text{id}$
\end_inset

.
 In other words, 
\begin_inset Formula $g(f(p))=p$
\end_inset

 for all 
\begin_inset Formula $p^{:P}$
\end_inset

.
 The function 
\begin_inset Formula $g$
\end_inset

 is called the 
\series bold
left inverse
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
left inverse
\end_layout

\end_inset

 to 
\begin_inset Formula $f$
\end_inset

.
 
\end_layout

\begin_layout Standard
Despite the equation 
\begin_inset Formula $f\bef g=\text{id}$
\end_inset

, the function 
\begin_inset Formula $g$
\end_inset

 is not an inverse of 
\begin_inset Formula $f$
\end_inset

.
 An inverse
\begin_inset Index idx
status open

\begin_layout Plain Layout
inverse function
\end_layout

\end_inset

 function for 
\begin_inset Formula $f$
\end_inset

 must be a function 
\begin_inset Formula $h$
\end_inset

 satisfying both 
\begin_inset Formula $f\bef h=\text{id}$
\end_inset

 and 
\begin_inset Formula $h\bef f=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
To get an example of an injective conversion function, consider subtyping
 of disjunctive types, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A] <: Option[A]
\end_layout

\end_inset

 (in the type notation, 
\begin_inset Formula $\bbnum 0+A\lesssim\bbnum 1+A$
\end_inset

).
 The set of all values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

 is a subset of the set of values of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

.
 In that case, the conversion function is injective.
 The code of the conversion function is an identity function, 
\begin_inset Formula $\bbnum 0+x^{:A}\rightarrow\bbnum 0+x$
\end_inset

, that merely reassigns types.
 So, all information from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A]
\end_layout

\end_inset

 is preserved by the conversion function.
\end_layout

\begin_layout Standard
Another example of subtyping is found when using object-oriented inheritance.
\begin_inset Index idx
status open

\begin_layout Plain Layout
object-oriented inheritance
\end_layout

\end_inset

 Consider this code where a class inherits a value from a parent class:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class HasID(val id: Long)
\end_layout

\begin_layout Plain Layout

final case class Person(name: String, override val id: Long) extends HasID(id)
\end_layout

\end_inset

The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Person
\end_layout

\end_inset

 is a subtype of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasID
\end_layout

\end_inset

.
 The conversion function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Person => HasID
\end_layout

\end_inset

 simply forgets that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

name
\end_layout

\end_inset

 is defined.
 In the type notation, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasID
\end_layout

\end_inset

 
\begin_inset Formula $\cong\text{Long}$
\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Person
\end_layout

\end_inset

 
\begin_inset Formula $\cong\text{String}\times\text{Long}$
\end_inset

.
 The subtype conversion function is 
\begin_inset Formula $\pi_{2}:\text{String}\times\text{Long}\rightarrow\text{Long}$
\end_inset

.
 This function is 
\emph on
not
\emph default
 injective, as it loses information about the first part of the tuple.
 Instead, the conversion function has the property that any value of type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

HasID
\end_layout

\end_inset

 can be computed by converting a suitably chosen value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Person
\end_layout

\end_inset

.
 This property is called 
\begin_inset Quotes eld
\end_inset

surjectivity
\begin_inset Quotes erd
\end_inset

: for any value 
\begin_inset Formula $q^{:Q}$
\end_inset

 we can find at least one value 
\begin_inset Formula $p^{:P}$
\end_inset

 such that 
\begin_inset Formula $f(p)=q$
\end_inset

.
 
\end_layout

\begin_layout Standard
The choice of 
\begin_inset Formula $q$
\end_inset

 for a given 
\begin_inset Formula $p$
\end_inset

 is a function of type 
\begin_inset Formula $Q\rightarrow P$
\end_inset

.
 So, a more formal definition of surjectivity is that a function 
\begin_inset Formula $f:P\rightarrow Q$
\end_inset

 is 
\series bold
surjective
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
surjective function
\end_layout

\end_inset

 if there exists at least one function 
\begin_inset Formula $g:Q\rightarrow P$
\end_inset

 such that 
\begin_inset Formula $g\bef f=\text{id}$
\end_inset

.
 The function 
\begin_inset Formula $g$
\end_inset

 is called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
right inverse
\end_layout

\end_inset


\series bold
right inverse
\series default
 to 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
We see that subtyping does not always involve an injective conversion function.
 Sometimes, the conversion function is surjective, and sometimes neither
 injective nor surjective.
 As an example of the latter, consider the product type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Option[A], HasID)
\end_layout

\end_inset

 and its subtype 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Some[A], Person)
\end_layout

\end_inset

.
 The corresponding type conversion function is neither injective nor surjective.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
An example of subtyping with a 
\emph on
surjective
\emph default
 conversion function is between the function types 
\begin_inset Formula $P\triangleq\bbnum 1+A\rightarrow\text{Int}$
\end_inset

 and 
\begin_inset Formula $Q\triangleq\bbnum 0+A\rightarrow\text{Int}$
\end_inset

 (in Scala, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = Option[A] => Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q = Some[A] => Int
\end_layout

\end_inset

).
 We have 
\begin_inset Formula $P\lesssim Q$
\end_inset

 because 
\begin_inset Formula $P\cong C^{\bbnum 1+A}$
\end_inset

 and 
\begin_inset Formula $Q\cong C^{\bbnum 0+A}$
\end_inset

, where 
\begin_inset Formula $C^{X}\triangleq X\rightarrow\text{Int}$
\end_inset

 is a contrafunctor.
 The conversion function 
\begin_inset Formula $P\rightarrow Q$
\end_inset

 is an identity function that reassigns types:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p2q[A](p: Option[A] => Int): Some[A] => Int = { x: Some[A] => p(x) }
\end_layout

\end_inset

In the code notation, 
\begin_inset Formula $p\rightarrow x\rightarrow p(x)$
\end_inset

 is just an expanded form of the identity function 
\begin_inset Formula $p\rightarrow p$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Note that functions of type 
\begin_inset Formula $P$
\end_inset

 accept 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 as an argument, while functions of type 
\begin_inset Formula $Q$
\end_inset

 do not.
 So, there are 
\emph on
more values
\emph default
 of type 
\begin_inset Formula $P$
\end_inset

 than values of type 
\begin_inset Formula $Q$
\end_inset

.
 The conversion function 
\begin_inset Formula $\text{p2q}:P\rightarrow Q$
\end_inset

 is surjective: for any function 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[A] => Int
\end_layout

\end_inset

, we can find a function 
\begin_inset Formula $g$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A] => Int
\end_layout

\end_inset

 such that 
\begin_inset Formula $\text{p2q}\,(g)=f$
\end_inset

.
 (The function 
\begin_inset Formula $g$
\end_inset

 is defined as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(Some(x)) = f(x)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(None) = 123
\end_layout

\end_inset

, say.) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Functors preserve subtyping; it turns out that functor liftings also preserve
 injectivity and surjectivity.
 If a function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is injective, it is lifted to an injective function 
\begin_inset Formula $f^{\uparrow L}:L^{A}\rightarrow L^{B}$
\end_inset

, and similarly for surjective functions 
\begin_inset Formula $f$
\end_inset

.
 We conclude this chapter by proving that property.
\end_layout

\begin_layout Subsubsection
Statement 
\begin_inset CommandInset label
LatexCommand label
name "subsec:f-Statement-functor-preserves-injective"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:f-Statement-functor-preserves-injective"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L^{A}$
\end_inset

 is a lawful functor and 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is an injective function then 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

 is also an injective function of type 
\begin_inset Formula $L^{A}\rightarrow L^{B}$
\end_inset

.
 If 
\begin_inset Formula $f$
\end_inset

 is surjective then the function 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

 is also surjective.
\begin_inset Index idx
status open

\begin_layout Plain Layout
subtyping!injective or surjective
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Proof
\end_layout

\begin_layout Standard
If the function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 is injective, there must exist a function 
\begin_inset Formula $g^{:B\rightarrow A}$
\end_inset

 such that 
\begin_inset Formula $f\bef g=\text{id}$
\end_inset

.
 We can lift both sides of the equation 
\begin_inset Formula $f\bef g=\text{id}$
\end_inset

 to get:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{L}(f)\bef\text{fmap}_{L}(g)\\
\text{composition law of }L:\quad & =\text{fmap}_{L}(f\bef g)\\
\text{use }f\bef g=\text{id}:\quad & =\text{fmap}_{L}(\text{id})\\
\text{identity law of }L:\quad & =\text{id}\quad.
\end{align*}

\end_inset

It follows that 
\begin_inset Formula $\text{fmap}_{L}(f)\bef\text{fmap}_{L}(g)=\text{id}$
\end_inset

.
 So, 
\begin_inset Formula $\text{fmap}_{L}(g)$
\end_inset

 is a left inverse function for 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

, which means that 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

 is injective.
\end_layout

\begin_layout Standard
Now consider surjective functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 By definition of a surjective function, there must exist a function 
\begin_inset Formula $g^{:B\rightarrow A}$
\end_inset

 such that 
\begin_inset Formula $g\bef f=\text{id}$
\end_inset

.
 Lifting the law 
\begin_inset Formula $g\bef f=\text{id}$
\end_inset

 to the functor 
\begin_inset Formula $L$
\end_inset

, we obtain:
\begin_inset Formula 
\[
\text{fmap}_{L}(g)\bef\text{fmap}_{L}(f)=\text{fmap}_{L}(g\bef f)=\text{fmap}_{L}(\text{id})=\text{id}\quad.
\]

\end_inset

We see that the function 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

 has a right inverse.
 So, 
\begin_inset Formula $\text{fmap}_{L}(f)$
\end_inset

 is surjective.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
the common feature is what I call here the bare functionality of a container
 it's just the functionality that describes the idea of holding in some
 way an item or perhaps several items of type T and holding means you can
 manipulate this data inside the container that's the only way that we can
 interpret this if there is data inside the container but we can never manipulat
e it in any way then that's not reasonable to call that a container 
\end_layout

\begin_layout Plain Layout
so what does it mean to manipulate it means we can apply functions to these
 values because in functional programming that's all we do we apply functions
 and get new values out of old ones so the idea that the container holds
 items it means that we can apply a function to these items and the new
 items will remain in the container so we're not extracting items out of
 it were just transforming the items that stay within the container 
\end_layout

\begin_layout Plain Layout
all the values that were held in the container here have been transformed
 through this function into values of type B but they remain in the same
 container or in it is a new value of the container type but they remain
 within the same kind of container of the same shape 
\end_layout

\begin_layout Plain Layout
so for instance if it were a sequence then it will remain a sequence 
\end_layout

\begin_layout Plain Layout
so this is the common pattern between sequence and future it's a pattern
 that allows us to transform data while keeping that data within the same
 container
\end_layout

\begin_layout Plain Layout
so that's what I'll mean here by the functionality of their container so
 for instance making a new container out of a given set of data items is
 not part of that functionality or reading values out of the container or
 adding more items or deleting items these are also not part of the functionalit
y of the bigger container so these are specific containers that we will
 consider later that can do this but the most basic and common among all
 containers is not is not this also not waiting or getting notified when
 new items become available like in the future container none of that is
 the basic functionality of a container only this so if we have the map
 when we have a container we can additionally have other things 
\end_layout

\begin_layout Plain Layout
and of course any kind of useful container will have other methods and we'll
 have other functionality it is unreasonable to just use bare container
 you can do anything with it you can't even create it or read values out
 of it so in any specific case you will have a bunch of other methods for
 any specific container so for example you want to create a future container
 it means you need to create some parallel process that will be running
 and computing this value of type T while you're still doing your computation
 so creating a container of this type actually involves creating a parallel
 process or parallel thread of computation creating a container of this
 type doesn't involve that necessarily so these are going to be specific
 things that I'm not going to talk about in this tutorial
\end_layout

\begin_layout Plain Layout
I'm only going to talk about what is common to all containers which is a
 bare container functionality which is the map function
\end_layout

\begin_layout Plain Layout
do we avoid that is it this function how do we define this function so that
 we don't lose information and how do we also define this function so that
 it actually allows you allows us to manipulate values so are there some
 constraints on this function that we need to be aware of and that's a center
 point of this tutorial 
\end_layout

\begin_layout Plain Layout
so these are the main questions that we will be dealing with how to define
 this map function in a sensible and reasonable way because that's part
 of the idea of the container because the container does not lose information
 you transfer information inside but you should don't lose it while you're
 transforming losing it would violate the whole idea of having a container
 that holds information 
\end_layout

\begin_layout Plain Layout
so the first question about information loss we will translate that into
 a formula 
\end_layout

\begin_layout Plain Layout
because we don't want to just talk about some intuition intuition is important
 but we also want to formulate these both requirements there's very precise
 formulas as requirements or as we call them laws 
\end_layout

\begin_layout Plain Layout
so this looks like lifting a function from A to B to option eight option
 B so from one kind of function space to another kind of function space
 
\end_layout

\begin_layout Plain Layout
you're lifting the function so that's much more visually clear what this
 function has map does but for coding in scholar especially it's actually
 easier to use this order of arguments because you usually have mapped as
 a method in a class so you have a dot map of F and that's also easier to
 read in code 
\end_layout

\begin_layout Plain Layout
a definition of functor so functor is the term which is used in functional
 programming recently to denote this abstraction of the functionality of
 a bare container the bare container having a map with laws so definition
 is that functor first of all it is a data type that has a type parameter
 such as something like this now if you don't have a type traveler you cannot
 have a container obviously so or you cannot abstract the functionality
 of a container if you don't first abstract the type of values to a type
 parameter and you can have a sequence of integers and you can say that's
 a container it is but it is not abstracted and you cannot reason about
 its properties as an abstract container and so you cannot see what is commonly
 between a sequence of integers and some other sequence like a sequence
 of boolean's or a sequence of options of some other thing you cannot see
 what's common between them unless you abstract the type into a type parameter
 and so the abstraction for this functionality requires you first to do
 that and to have a type parameter second require is that a function map
 should be available for this data type with this type signature or F map
 these are equivalent they just differ by order during the order of curried
 arguments and these functions must be such that the laws of identity and
 the laws of composition must hold so these laws are written like that in
 terms of F map is much easier to write them shorter and also easier to
 see what these laws do and you remember why you need them and of course
 to check them so the F map applied to the same type a identity and you
 a gives you an identity F a to FA and F my applied to a composition of
 functions gives you a composition of lifted functions and so now I just
 want to mention that the word functor comes from category theory it is
 not going to be useful for us to go into category theory right now but
 there is different usage of the word factor in programming or in software
 engineering which are not the same because what we're doing here which
 do not come from category theory so for example even C++ now has something
 called a functor and Kokomo has some other thing called a functor these
 are not the same and as is just a very specific usage of the word function
 that is now being being dominated being the dominant one in an functional
 programming so this functor is a concept from category theory and not something
 else but for us this is not very important that it comes from category
 theory because we are actually motivating these laws by requirements of
 practical use so you want to manipulate data in a container and if you
 want to do that in a reasonable way and be able to understand your code
 after you have written it several years back then the children there should
 be surprises so if you for example identity law just tells you that if
 you manipulate data by doing nothing it shouldn't change your container
 so it would be very surprising in your code if that were the case and you
 would never find the bug until you debug every step painfully and so that's
 the kind of thing I want to avoid by imposing these walls and the second
 law the composition law also says that basically functions are applied
 in the way you expect expect them to be applied and there's no surprises
 so you can simplify your code for instance if you discover that this function
 G is identity you can omit it from the code and the code will still be
 working and that's not the case if this law is violated so let us go to
 actual code demonstration - very fine the law is for the option in the
 F map implementation for the option is written here it's a very easy thing
 that you take a function f as a parameter and you return a function from
 option a to option B so now if you return a function like this an option
 is a case class or a sealed trade with case classes or disjunction as I
 prefer to call them then a short syntax in Scala is to just write a case
 partial function with case so you did not say much more than this it's
 just very easy to to write that it's a shorter syntax and then if the optional
 a is empty and you return none and if the option is not empty and they
 return a non empty option B with the value inside that this transformed
 so let's go to the code so this is the code that is written a little more
 verbally and there are three versions here well first of all I do the map
 not just the F map so the map takes an option I exit function A to B and
 returns an option B and so since there's this syntax I have to say the
 first argument is this option is the option a the second argument is f
 so I didn't check the types control shift P so option a is being matched
 and then if it's not empty we return this it's empty return death now the
 bad implementation would be we did the same thing but we always return
 none so that would be a bad implementation but doesn't satisfy the laws
 and the F map is exactly what was from basically what was written there
 except for the F being here just the syntax difference and I also have
 a fourth implementation which is F map although which is automatically
 implemented so I'm using this the function from the Greek Harvard library
 which I'm using here just as a reference check to see whether these methods
 can be automatically implemented or not so then we verify the identity
 law for all these implementations so this is the way to verify the laws
 is to use the Scala check library that allows you to say things like this
 for all value of option int this must be true and I just write here what
 I want to be true like for example here the map which I define right there
 it plot applied to this option and to the identity function should be able
 to that option so that is my statement that identity being lifted is equal
 to identity but I cannot compare functions directly in Scala I have to
 say for all argument opt the function applied to the argument is equal
 to the argument that's the only way I can say that the function is equal
 to identity the library Scala check will go through a large number of a
 randomly chosen values of this type and it can generate these values automatica
lly the checking for s map is quite similar except for the order of arguments
 which was inverted as compared with that map and F exactly the same as
 f ma'am now for my bad actually the test would fail if I wrote the same
 test for me from my bad it would have failed because my bad does not give
 you identity it always Maps your option to none so once you take here an
 option that's not none you get and there and also we verify the composition
 law which means we say for all X and for all functions F and G and here
 I chose some specific types like integers string and lon all our functions
 here are completely type parametric so I can say any types I want but when
 i test i have to give a specific type because there will be specific values
 randomly generated for these functions and it is impossible to do that
 unless you specify type so you have to choose and I choose some random
 different types so then here is how I check the composition law the end
 then is a standard scala function or method rather that is defined on function
 so f and then G means that the same as you you would write this circle
 in my slides the composition is a circle it's in Scott will be and then
 so first a and then these and sorry first F and then G so if you apply
 this to a value of type a then first F will map it to be and then G will
 map it to C so then it is easier to to read it that way so there's this
 so basically I write down this law has written here putting ends then instead
 of the circle if map F and then G I've not have and then with man G and
 then I also have to apply the resulting function to an X and I say that
 the result should be equal to applying the other function to the same X
 that's the only way to check that functions are equal here this is an equality
 of functions this lifted function should be equal to that with the function
 and in the test you cannot directly compare functions we have to apply
 functions to values and say that for all values the results are the same
 so that's what I do and again I have a check for all the implementations
 including the bad one for each for which the composition law actually holds
 because this this thing always gives you none so whatever you compose with
 the result is going to be none at in any case and so the composition law
 will trivially hold what the identity law does not does not hold here are
 some examples of functors so like I said we are only concerned about the
 properties of map here and all these specific examples will have lots of
 different other methods so that you can do other things so for example
 option T has methods to get values out of it and to put values in it and
 so on so basically anything in the Scala standard library that has a map
 method is a functor except for certain map which are almost functors except
 that for certain and not well behaved types the laws will not hold let's
 see how that works so here's a here's some example so have a I took this
 idea from from here from Rob Norris so imagine we have a type bad which
 calls an integer but it has the equals function that is not well behaved
 the eCos function always returns true for any other thing which would be
 kind of unreasonable and useless but what if this was true for some reason
 what if you need this behavior then you define a function f in the function
 G in a very obvious way you take an integer you put it into the container
 so this can be seen as an container itself that contains a single integer
 but we're not using that as a container using that as a data type inside
 the container so you put an integer in there in the open this way and you
 get the integer back in the obvious way so there are two functions F and
 G and now let's take a set of integers and map with the composition of
 these two functions and so then we write it like this so you see in scours
 much easier to use map rather than F map because of the syntax so then
 you get this set because F and then G is identity because you take this
 F you put an integer inside and you get that integer back with no changes
 you're not comparing anything while you're doing this and so this function
 is identity and of course this set does not change when you map it over
 identity but if you first map into F and then map into G which you accept
 expect to be the same as that then you get wrong answer because when you
 first map with your f then it becomes a set of bad one bad to bad three
 and then the set try to see if they're equal because a set is trying to
 eliminate duplications right because isettas cannot have duplicated elements
 but we have made the eCos operation so that it always returns true and
 so the set will think that all of them are the same and it will eliminate
 all of them except the first one perhaps and then you map it back to integer
 and you get a set of one element so the composition law fails and that's
 that's bad so basically for a set of integers it is not even set of integers
 integers well behaved the quality of operation but because you go through
 some bad type while you're composing functions you are violating the compositio
n law and the map is similar it has a map values method which is a good
 function but it also has a map method which is mapping with respect to
 both key and value and it behaves like a set with respect to keys because
 it will not allow you to have duplicate key and that's the same problem
 as with this set so if you have a map and you have functions that map you
 to type with none ill-behaved equals operation then you will violate the
 composition law and that code could have difficult to find bugs will be
 very difficult to reason about that code so that's the real value of these
 laws I would like to have a little more intuition about functors and type
 constructors in general and a good way rather than look at some types defined
 in the standard library which are complicated let's look at very simple
 types that we can define ourselves and work with ourselves to see to understand
 how functors work and what it means to be their container what it means
 to be a functor so here I have three examples first example is a type clearly
 result Jeremy tries by a the type variable a and it holds a triple of string
 integer and a so the short notation for this type is this and the Scala
 code would be that I have to put names on each so I'm just writing down
 whatever comes to mind what would be appropriate for a query result and
 another example would be a vector of three and three dimensions having
 coordinates of type a so I have three coordinates of type a so it could
 be maybe double or real or complex or something like that three dimensional
 vector of type a with coordinates of type a and the third example would
 be disjunction tie the clear is out that could be so the short notation
 is strain plus strain times integer times again in Scala code that would
 be sealed trait with two cases so I'm just interpreting what it could be
 so one could be an error with the message and another would be a success
 with a value of type a so C the first element of the disjunction does not
 actually contain in the elements of type a and any values of type a let's
 the second one does so let's look at the test code to see how we make them
 into factors so the first example was the string times integer times a
 so we need to define F map and all these examples are all beginning with
 F map because it's much easier to write down but the map would be equivalent
 we called so to implement F map and what do we do well we need to take
 even a function I have take a query result of type a return a query result
 of type B well I could have written this as that because what I need here
 is I need to return a function with arguments of type quick query result
 a so if I need to return a function and my code needs to start like this
 this would be the argument of that function and that would be the result
 value now the first thing I have to do that is to match all this query
 result because it's a the easiest thing Regus way to extract values from
 it would be to match and then I would say case quite a result with three
 parts and then I returned query result with the same parts except I apply
 the function f to the data so you see I need to transform string x integer
 times a into string times integer times B and I have a function from A
 to B the only way I can do it is to apply this function to the a and leave
 the string and integer and changed and that's the code I have written here
 and this is a simplification of syntax but this is not necessary to write
 otherwise it's exactly the same code it is a function takes an argument
 of this type immediately does a match on that argument and returns us an
 equivalent way of writing this code would be like this so you take this
 argument and use the copy function on case classes that copies only so
 it copies the entire value of the case class and it only changes one part
 of it which is data data the new value is equal to this F of the old of
 the old QR dot data so in this case because the code is so simple the case
 match would be a lot more writing than this in India in every other way
 these are equivalent I'm creating a new value of type query result be and
 I'm copying all the parts name and time and I'm only modifying the data
 part in this way and I can do this automatically using the current hardliner
 so that's the last implementation and I verify identity law and composition
 law for all three implementations the second example was the type constructor
 that has a Triple A three dimensional vector of A's so here I do the same
 thing I do a case match on the vector and now I have to apply the function
 f to all three of the elements here so again I've I've tried the the automatic
 implementation but actually there are different ways of implementing this
 automatically because you could for example you could interchange x and
 y here so the type would still be correct and the automatic implementation
 only looks at the type and tries to find out what what code could be of
 this type now if I wrote here Y and X instead of x and y the type would
 still be correct the function being correct as well we'll see later the
 composition law will not hold the identity law or not called no it's obvious
 that identity law will not hold because if F is identity then you are exchangin
g wine X you're not leaving the vector3 unchanged but the Kirk Howard library
 doesn't know that we want to have the identity law and so it only looks
 at the type the type will be correct so then there are six different ways
 of permuting the order of these and it finds all six and has no idea what
 what to choose as a workaround I say give me all of those implementations
 and take the first of them and actually turns out to be the right one so
 all of type returns a sequence of values on this table and I check the
 identity law and the composition law and all these tests pass and a final
 example right now is to commit to make this into a factor and you find
 that never depend checking laws so again this is very similar to one we
 had before except now we have two cases of a disjunction in order to transform
 this into the query result of B we still just need to apply F to this a
 and to be and we're done but now there are two cases in the first case
 we actually don't have any values of type a we just have a string and in
 the other case we have a string and int and the name so we need to do a
 case match so here's how will you find it if it's an error so you see the
 two cases error in success if it's an error then we just return error with
 no change to the message and if it's a success then we do what we did before
 we apply F to data and leave other parts of the case classic unchanged
 and the curry Howard library can implement this automatically there's no
 no uncertainty as to what to do only one good implementation so that's
 these three examples in these three examples what we found is that we can
 define F map so we try to define F map guided by types and also guided
 by laws so sometimes we have different possibilities for the same type
 to write code but the laws only give us one possibility and that's the
 general situation with all the type constructors and that we are going
 to work with laws and type dictate how to implement map in only one way
 what are examples that are not factors where you cannot implement map well
 one type of these examples is types that cannot have any map function at
 all due to type problems is an example is is this not container just which
 is defined as a product of a function from a to end and a so the case us
 will be like this function from A to E and and also a value of type a so
 why is this not a container well I can try to implement an app for it but
 that won't satisfy the one what what I would do is it would transform the
 Y and then it would apply it would apply that function to that a that you
 had and get an integer and you cannot produce a function from beta integer
 but you can produce a function that's returning your constant integer and
 so that con because you have an integer you can compute a constant integer
 by applying X to one and so you just return a constant function that always
 returns that constant integer now that is not the right implementation
 for F map because it doesn't satisfy the laws which I check here so I check
 that the try F Maps that I get here does not satisfy identity another example
 of a data type that they cannot have a map due to type problems is this
 one where we have a disjunction type but its type values are nonparametric
 in some strange way so here's what I mean by that you have a sealed trait
 with the type parameter called dress or some kind of action with results
 let's say and the the case classes that extend this trait are defined in
 this curious way so the first one is normal it has a value and it extends
 the survey with the same time parameter race but the second case class
 doesn't have a typewriter an external extends server action with a specific
 title loan and and also a third case class extends that with specific type
 string so it uses type values that are not parametric type values that
 are not equal to this parameter so the the way that we have keys classes
 for option or either for such parametric disjunction types is that each
 case class extends the trait with the same type parameter as it has and
 here it's not the case it extends with a fixed type so these kind of disjunctio
n types are called generalized algebraic data types and I don't have short
 notation for them that's very useful and at this point I'm not sure what
 that thread notation should be and how to reason about them in terms of
 in terms of data containers because they are not data containers they're
 very odd type constructors if you try to think about them as containers
 they may be very useful certainly are very useful in a number of situations
 but as containers they fail you cannot even implement FF map or map for
 this because you do not actually have a value let's say observer action
 long or server action integer for this there's no if you want to have a
 function that map's long to integer you cannot do a store ID server action
 integer is that that's a fixed type so there is no way you can define the
 app for this kind of type because of type problems another type of things
 that are not factors are types that could be factors but we didn't implement
 correctly we need to have a well behaved of map to have a functor and a
 number of things could go wrong if we try to implement F map so one thing
 could be that F map ignores F it always returns none for an option so for
 instance if that is true usually it would not be satisfying laws or F map
 reorders data in a continued for instance here's a container with two values
 of type a and we define F map that applies F but also reorders the values
 in the container now this or here is this example I was showing in the
 code now this would immediately violate that identity you are so that's
 not good and we can verify that so I'm gonna have tests with a special
 method exists some that I implemented we can verify that identity law is
 not is not satisfied another example is that you could have enough map
 that checks the types because in Scala you can you can see what type II
 or your past using reflection and that's that's a very risky thing to do
 because it's easy to make mistakes I'm difficult to write code that will
 always work but if you do that you could check that a and B are the same
 type or not and if same time then you do one thing in your F math let's
 say you return identity ignoring the F and if you have another not the
 same type then you do something else we apply f of X in some way now this
 would obviously satisfy the identity law but this would violate the composition
 law because you could have functions F and G whose composition his identity
 and so then you would check that the type is the same and you would sorry
 whose composition is not identity and you would check here that the type
 is the same you would return an identity for them and it would not be equal
 to the composition of F and G so you would violate the composition law
 if you do that or you could do other special computations in in case that
 the type is equal to some specific type like integer then you do something
 else in the general case or if the function is equal to some specific function
 then you do a special thing and otherwise they do the general case so none
 of this would give you an F map that's well behaved that satisfies the
 laws so an interesting example of functor is a recursive type defined like
 this for example so let's say a list of pairs which I could just define
 my hand as type LP with parameter a that satisfies this recursive equation
 this is a type equation LP array is equal to 1 plus a times a times of
 P of a so if you expand this using the algebraic or arithmetic very hard
 correspondence rules the arithmetic identity would be this kind of expansion
 so then you can visualize what this type does so it's either empty or it's
 two copies of a well-tuned in values of type a or four values of type a
 or more so it's kind of list of pairs except it's a list that can only
 have even number of elements it's not really a list of pairs as as I've
 defined it so here's a definition installer so you have a co trade copy
 of a and it has two parts of a disjunction so one I would write it like
 this with empty or unit here and the other with X&Y of type a and the tail
 which is this which is again of type LP of a so that is allowed so this
 kind of type recursion is allowed in Scala when you do take when you when
 you use case classes so now we can implement a map here you use recursion
 so that's implement F map for simplicity you match on LP of a and there
 are two cases so either it's empty and the result will be also empty or
 it's going to be a pair of XY tail and then you apply F to x apply F to
 a sorry F to Y and you apply F to tail now tail is of the same type and
 so you need to use the same F map that should be enough map here should
 the same F map that you're defining this use the same recursive call here
 applying to the tail so that's all right and that works and actually this
 is the only way to implement an app that satisfies the funky laws what
 would be another way well we could always return empty here or we could
 match on this tail further and let's say if if there at least four of them
 then we return empty if there is not for we don't return it or something
 like this all of that would be wrong all that would be incorrect factor
 instance as it's called incorrect implementation of map so let's look at
 the test code so here's the implementation of this recursive type is defined
 like that so here I don't have this title obviously because tests pass
 we can compile if I find maybe typos so that's now for for this example
 it's exactly the same code as before verifying the laws now notice that
 I'm able to generate arbitrary values of this recursive type so how does
 the library do it just a short digression I'm using a library called college
 XJ plus which is a library made by Alex Horne planar Shambo and he allows
 me to use case classes in for all so I can do for all [Music] value of
 some case closed or sealed trait now I don't have to write any code to
 do that it's automatic so this is some macro and library that I'm user
 now another curious thing is that a type such as this one a function from
 a to hints is not a funder it cannot implement map for it but you can implement
 something called contra map or here contra F map which is this similar
 to f map except that I interchange the order of B and a here so the function
 goes from B to a but the lifted function goes from C a to C B so that's
 the contract it reverses the arrow between a and B the Contra function
 laws are very similar to function laws except for the interchanging of
 the order of function here in composition so this is the control direction
 so composition G and F and that's composition of F lifted and G lifted
 an interesting observation here is that in this type the type parameter
 is to the left of the function area so this type parameter a is consumed
 by the function in all our examples of functors here this was not the case
 the type a was produced or if it was there it was not consumed here it
 was consumed in all these examples of function so that was our example
 a non-factor and all of these examples they have a that is produced or
 it's already there but it is not consumed so that's an interesting observation
 but functors contain data that contractors consume data so contra functor
 is not a container is not a functor so it's not a container should be thought
 of as a container it's something that consumes data of this type and this
 is an example that we had before the non container it is neither a function
 or a contra factor so I have here of some test code I tried to implement
 contra F maps for this type but actually there aren't any implementations
 there's zero implementations possible there's one implementation possible
 of the F map but it does not satisfy the law there are no implementations
 of this type at all so this type is neither a function or a contra factor
 so it can be not cannot be thought of as a container and also cannot be
 thought of as something that consumes the data of this type it's a strange
 thing maybe maybe useful maybe not but in any case it's not a factor or
 not a contractor another so now that we see functors and conscious factors
 another thing that comes to mind is the concepts of covariance and contravarian
ce now the concepts of covariance and contravariance our relevant to subtyping
 so what is subtyping an example would be when you say class extends something
 trait so in scholar these are traits and class diseases a bit specific
 to scholars and other languages would not be called traits maybe and we
 just classiest but this is a subtype so zero is a subtype of at most two
 so this is an example I have at most two is a disjunction of zero integers
 one integer or two integers and so the 0 1 & 2 in Scala are types themselves
 that are subtypes of at most 2 which means that if you have a function
 that takes an at most 2 as an argument you can pass this value to that
 function and it will take it so this is how we have been using these junctions
 until now so we're using this feature of Scala that they're implemented
 as subtypes and subtype means that you can automatically convert this type
 into that type whatever you need that so this function going from two to
 at most two is identity function has just relabeled the type because there's
 nothing to convert in this case this class is just an instance or a subtype
 of that so but logically speaking there are different types so this type
 is different from this and so you can think about it as having always an
 automatic type conversion of this sort whenever you need it and so this
 looks like a function of this type that's always available let's never
 need to be written out explicitly but we could write it out explicitly
 if we wanted to and we will in in a second so what does it mean that a
 type constructor is covariant so it means that if the container or type
 constructor applied to the type two is a subtype of the container of at
 most two in other words when you lift these types into the container type
 they still are subtypes of each other so this two is a subtype of at most
 two and then C of two is also a subtype of C at most two if that is so
 and C is called covariant and then you have this type conversion function
 automatically available whenever you need it so more generally what is
 covariance so covariant so C is covariant type constructors see is covariant
 in its argument X when whenever if if whenever if you have xn is a subtype
 of Y then you have also this conversion automatically and obviously if
 you have this kind of function which is taking this and producing that
 if you have this kind of function then you're guaranteed to have this kind
 of conversion in other words and this is this is this type signature of
 f map in other words if you have a type constructor that has F map and
 it's guaranteed to have the right type conversions and to be covariant
 and so all functors are covariant and in Scala you can put the little plus
 next to the type when you declare the sealed trait to tell a compiler that
 you want this explicitly to be known that this is covariant in that argument
 and similarly conservatives are contravariant so contravariant means that
 this arrow goes into the opposite direction if too is a subtype of at most
 to anicon chiffon jerkoff at most two will be a subtype of a contra founder
 of two and so because of this very easy argument with the implicit or automatic
 type conversion functions we write them explicitly then we see immediately
 that functors are automatically covariant and contravariant variant so
 if you want to make this explicit in scala if for any reason you need subtyping
 which is advanced topic in functional programming and it's not something
 I'm going to talk about a lot right now you can put a plus sign or a minus
 sign for contravariant and then the compiler will check that you actually
 have covariance or contravariance correct so so this is the correspondence
 between functors control factors covariance and contravariance which is
 a very interesting thing so in other words we are talking about centers
 and country hunters and this is exactly parallel to covariance and contravarian
ce but usually in object-oriented programming people talk about so let's
 go through some more examples with actual coding where we will do certain
 things roll first we can now decide if a data type is a functor a country
 founder or neither of the Eastern so to decide that we look we look at
 the data type write it down in the short notation and see if there is any
 type trainer to the left of the area which is consumed and to the right
 of the arrow or off without an error which is produced or which is already
 there and that allows us to decide whether it's a functor or country function
 then we implement a map or country map that satisfies the laws so we are
 implementing first looking at the type just guided by what types need to
 be produced and if there is a choice or ambiguity we then see whether laws
 are satisfied so let's look at the first example which is this one so we
 have this type string plus a times int plus a times a times a our task
 is to define case classes for this type and implement map so this is how
 we would write our case classes in all these examples I'm going to call
 this type data so that all my code is always ready to cut and paste so
 in this case we have three pieces of the injunction or 3s rate disjunction
 so there are three parts of the disjunction the first part is just string
 so we have this second part is a product of a and int so we have four tuple
 we have a and we have an int in the third part is a a a so F map makes
 a match on data disjunction if I have a message then I don't change that
 message you know in any case I couldn't do anything else at this point
 I have to return the message of type B because there is nothing else I
 could possibly return if I have a second case class then it means I have
 one I have one item of the of type a so then I apply F to that item and
 I'm done and the third case I have three items of type a and I apply F
 on each of them and I don't change the order so that's how I'm implemented
 the second example is this one so now in this example first what I notice
 is that I have a type of the for one plus something so in Scala I already
 have option type I don't have to myself implement the cases for that so
 let me use it so it will be an option of this and that is a tuple of a
 and this Junction for this this Junction here I declare another sealed
 trait which is a called data two and here this trade is still parameterize
 by a it has two cases the message and the value so so now I have a bit
 more complication in my code because when I match on data then that's a
 case class that has a data constructor over option so it's a data of option
 and the option needs to be matched as well so I can match this in the same
 case expression and I have two possibilities data of some of blob data
 of none know if I have data of none and clearly all I can do is return
 data of not there's nothing else I can do I couldn't possibly return any
 of those things so it remains to to do this with a case data of some and
 the sum is of a tuple of the of a pair work most more precisely of a and
 this data to so there is a pair of value a and data to so then I am going
 to return a data of some of some new value a and some new data to so I'm
 going to return this and in order to make the code more readable I'm going
 to write explicitly what new value a is and what new data to is so new
 value a is just a function f of the old value a so in order to make this
 more visual I in my head I do this maybe for tutorial purposes let me write
 this out this is what I want to do I want to transform data alien today
 to be using this function f so I need to replace a by B exactly at each
 place that I have a here I replace it by B and replacing by B means I apply
 F to that value here so then all I need to do is I need to case match and
 whenever I get a value of a I apply F to it here I have another value of
 a control shifty that's it I apply F to it everything else I don't touch
 so I don't change these integers this string I don't change the order of
 anything I just replace a by B by using the final through using the function
 f and change nothing else so this one goes to this one so that's this line
 this a goes to this B that's this line integer string goes to integer string
 that's this line and this n goes to has B that's that line so that's all
 I'm doing and of course the laws will hold them the third example is a
 bit more involved in this example I notice first of all this the structure
 of the data and must be that first it's a disjunction of two parts and
 the parts are quite similar so each part has this structure that I have
 string to integer to a here I have boolean to double to a other than the
 other and end times a so that's always a tuple with a except for these
 types boolean and double is exactly the same structure so I'm going to
 parameterize boolean and so on by X Y and I'm going to define a structure
 this and that's going to be data too so it's going to be a case class with
 two parts so that or tuple with two parts and I'm going to do X and y setting
 them to string int here and the boolean double here so then I define not
 a case class but a type I don't have to do it against plus if I can I already
 have either as a case class and so that's actually a little less writing
 than what I was doing the previous example where I could also use either
 or or tuple here but I chose to do here I chose a tuple then I chose this
 data to and explicitly had two cases but I could have used either and tuples
 and just draw write all of this as one expression with either in tuples
 I could have done that just a little less writing perhaps and certain points
 could be more writing so this is not clear how best to arrange this you
 have a choice and so let me try it try it this way of course all these
 tights are going to be equivalent they're going to be isomorphic and no
 matter what I do I can put them inside a case class or not it's just going
 to be more wrapping if I put them more into case classes so let me try
 without the case class and this level but I do have a case class for this
 repeating structure that I found maybe that's also in Scala that's easier
 to read because you can have documentation so to speak as the name of your
 data type names of your elements they could tell in the program or what
 they mean so that it's clear clear what needs to do what in this case for
 this example I'm just using very short names like the data of type anywhere
 gene just a function whatever kind so I define the data like this just
 in either of two double of two data two structures and that's precisely
 mirrors what I have here so that's Scala syntax for the same I also need
 to define the function that compares values of this type that is necessary
 because as you remember functions cannot be compared directly in Scala
 and we will have to compare things in this test if we want to verify laws
 so they'll need to compare values of this type for example if something
 is an identity function data to going to data two and I want to verify
 that and I need to compare the data to the head before applying that function
 and after and so that's why I need to have a method of comparing two values
 of data of type data a so that is implemented in the same way using case
 matches and certain parts should be equal to certain other parts and if
 not then I have this special method called fail that will throw an exception
 so you can look on that code so here's how I would implement F map so data
 of type a is in either so first of all I match on that and I get two cases
 left and right now if I'm in the left case it means I have a data tool
 of this type string and be and so like string it into a so I compute a
 new string and be out of that and I return the left of that and if I'm
 in the right and I compute the new data tool and and return that so now
 the only non-trivial part is what to do with this higher order function
 x2 y2 a so I need to transform X to Y of a into X to Y to be so how do
 I do that well I do that here in line but I could have done it as another
 Val if I wanted to all right for example Yugi I could have done that let
 me see if that would be perhaps more instructive so what is the type of
 new G I need to specify the type otherwise be arrived in Scala so I need
 a function from string to int to be so how can I make this function I have
 a function G which is of type string katha into a and I have a function
 f from A to B so how do I put this new be here well new G is a function
 so let me return the function so it takes X returns a function that takes
 Y and then I need to produce a B so how they produce a B and I have an
 x and y I can put those x and y into G just drink them into a which will
 be this so that's the value of type A when I apply F to it I get a B and
 that's what I returned so in this way I can implement the F map for my
 type so notice this kind of trick with putting first taking arguments out
 and then putting them back in that is necessary whenever you have a type
 of the sort which produces a value of your interesting type using some
 other values you have to do this kind of code but this code is actually
 this code could be generated automatically if I wanted if I wanted to be
 clever here and use my curry Howard library I could have done like this
 and I need to specify what values I'm allowed to use so I'm allowed to
 use FMG so let me do an import so that I have this off type I will just
 import everything right so now of type works so I need to say auf type
 is a an interface to a lecture a Harvard library that automatically generates
 expressions of a given type using other expressions that are already available
 so it will find that code basically this code will be generated automatically
 there is no other way of generating this let me let me run this test and
 I'll see if that actually works but I expect this to work because there's
 no other way so this combination X to Y T or F of G X Y is the only combination
 that has the right type and so you'll be able to derive this automatically
 but of course it's important to understand how to write this code by hand
 as well only then you can correctly use automatic tools but warning is
 expected but the strip ass warnings are fine Oh actually it's compiling
 the first tests still right they will take a long time it's not compiling
 this test the very Harvard library is used in the first one several times
 and it's slow it goes through different combinations to find this expression
 all right looks like we're compiled and once we compile you're pretty much
 guaranteed to work excellent so we have just checked all these laws work
 the second series of examples is to decide whether these are functors or
 country factors and then it can implement either F map or contra F map
 as appropriate the first example is this type so now if you look at this
 type here is on the left of the arrow so that looks like it's consuming
 an A so it looks like we're having a contra hunter here certainly not a
 functor now here are we consuming an A or are we producing an A now the
 syntax might be a little confusing until you get used to it but all these
 things are to the left of the arrow so these are the syntax is like this
 by convention the arrow associates to the right and so this consumes an
 A and produces a function that again consumes an A and produces a strain
 so this function actually consumes two different values of a let's type
 a and so all this consumes a this also consumes two different values of
 type in and so we have a hope of getting a country founder here it's certainly
 not effective let's try the country hunter so here I'm going to do some
 easier that go the easier route a room but I won't defend I won't define
 any case classes I'll just use standard library so I have a single disjunction
 and I'll just use either and then I'll just write down these types more
 or less like in this formula I also define the data equal function otherwise
 these tests won't run because data contains functions so whenever that
 is so I need to define it for these tests a function that will compare
 for equality so then I define contra F nap so how do I do that it's a very
 similar trick as well we did before we just need to replace arguments here
 in functions by our own arguments and that will be it so here's contra
 F map we have an either our data type isn't either so in your case match
 first of all the left is a function from a to int so now we we need to
 produce let me just write down again for convenience what we want to produce
 is this so we want to produce a database so if we are in the left and we
 should produce this and if we're in the right and we should produce this
 so if you're in the left then we produce left of a function that takes
 some value let's actually it's a what's always because that's the type
 it's more and more clear it's a function that takes B and returns an integer
 so we'll take a beat now we need to return an integer so how do we return
 you into we can do F of B and we get an A and then we apply this function
 a to an integer to that a and we get an integer so that's how we can do
 this very similarly we doing the right so there is an A and a in string
 now this B actually is the first eight let's called a one and this let's
 call it a two just to be more clear so a 1 and a 2 or 20 what's sorry let's
 call them so they're of type B so we are supposed to produce a function
 from B to B to strength so we produce the function tends be one takes B
 2 and then we produce a string so we get this applied to an A and again
 applied to an A so that's all we do here so f of B 1 is in a f of B 2 is
 again here not an interesting question is what order should this be should
 this be B 2 B 1 or B 1 B 2 well let's see so this we just drink tests actually
 we didn't run this test but it's from this test and I think the test would
 fail if we do it the wrong way so let me run this test first and then make
 a change and then run the test again and the reason is that we shouldn't
 interchange the order of arguments salafi give these two arguments we should
 not interchange them that would probably violate the identity law if we
 did interchanged some of you do the bad thing and run the test again so
 as a rule of thumb when we when we build an F map cone for some data type
 you just change every instance of a tree instance of B or vice versa we
 don't change any order of anything we don't yeah it fails so there's some
 value our delta T law yes then did you all failed to hold so damaged yeah
 so as a rule of thumb never changes order anything never interchange things
 that would violate the laws the type of deep grip but that would violate
 the laws and so since here we're implementing the contra hunter it could
 be a bit difficult to decide whether it should be V 2 V 1 or V 1 V 2 what
 is the order of these arguments really just run the tests and make your
 laws testable and you are sure there's not much choice here they're these
 choices when you have different values at the same time of same type or
 different arguments of the same type then you might find a stake interchange
 them the laws would tell you that this is not so this is not bad and the
 Contra composition law remember that was composed of F with G lifted is
 equal to a composed of G E and an F so that's contra composition a second
 example is this type so it has two parameters a and B so which should we
 use as a type Trevor now it's important to realize that we are free to
 use either of these two typewriters a functor is a type constructor with
 a type triangle but if we have a type constructor it has many type parameters
 we need to choose one and say that this type constructor is a functor with
 respect to that type parameter and our F map will modify that type parameter
 only and not others and so in this example it shows we can choose for example
 a you our typewriter and B is just a fixed type I'm going to f map is not
 going to change that let's examine this type so there is this there is
 this arrow here and this arrow okay so it looks like a is behind them error
 so does it look like a is actually contravariant but wait here's another
 here so this entire thing is to the left of an error so this is the entire
 thing is consumed so we consume something that consumes a so that actually
 makes a covariant again as we will see if you consume something that consumes
 a then you can implement F map with respective a and not the Contra map
 so it looks like you're not this is a strange container if it doesn't actually
 have values of type a but instead it consumes something that consumes a
 value of type a but that is actually so in other words you don't have a
 value of type a that is true and not all containers have actual values
 of type a inside but one example that would be the future container future
 is a functor but it doesn't actually have a value inside not yet in any
 case it might have it in the future or might not at all so that's an example
 of a container that is a fun turn with respect to a but it does this funny
 thing of it consumes a function of consumes a oh so be is in a covariant
 position here we have a B inside of this Junction and here we produce a
 B so we know that when we produce a B that's covariant and when so again
 we could be a type parameter and choose to have a functor instance or a
 functor instance is the same as to say we have an implementation of f map
 so in this code I will actually define both F map with respect to a and
 f map with respect to B so let me start with B it's a little easier so
 in order to have an F map with respect to B I'm going to put the first
 trailer rename it to Z so let's rename that to Z then F map will have to
 be paralyzed by Z and B and C and we'll map B to C and the result will
 be mapping from data ZB into the data ZC so that's I chose the letter Z
 far from B and C so that it's clear that Z is not changing B is changing
 to see after F map alright so how do we do that so we again need to think
 so this is this case class there is no disjunction at the top there is
 a disjunction inside so we need to get the data data dot a B will be matched
 the result will be that we need to return a new value of type data with
 which means we need to produce some new a B and some new D right so data
 has a B and it has a D you need to produce new Indian new D so I structured
 the code like this to be more clear about that and now we need to produce
 a new a B of this type and gnudi of this type so how do we do that so new
 a B is just an either of Z C so we just need to map over the easy either
 somehow so that's easy to do if we're on the Left we don't matter because
 it's an a so that's this or Z so that's not mapped not changed and the
 B value is mapped with F so it's changed it remains to do this so that's
 the trick we just saw this is not changing and we have a D which is dated
 of D which is of type 0 integer to be so we put an argument out which is
 0 integer and for the apply this D 2 that the result is the value of B
 apply F to that value and get the value of C so then we get a function
 from G to that see and that's what you probably need this function so like
 before this part of code is probably unique it can be generated automatically
 so I try to I haven't tried to actually generate all this automatically
 with Kurihara stuff you could try to see maybe maybe in this case there
 are no ambiguities and you couldn't just generate all this code automatically
 in which case we'll just say def F map of all this equals implement you
 can just say that yes let's run this list to see if that is so and I will
 explain the rest now the F map here is with respect to a so a is changing
 so I rename that into X just so that it's clear we are going to map data
 xB into data Y B so B is the type trailer that rent remains constant and
 we're mapping X to Y through the function X all right there's some problem
 ok doesn't work it might be a bug or there might be some other problems
 correct Harvard library is working progress so it works in many cases but
 not in all cases I'll make a note of this it's a good idea to have some
 words and tests or bug fixes so to implement F map we do a very similar
 thing we match on data so sorry we return the data with new a B mu D but
 now the types of new a B are different so this is going to be either of
 Y B and this is going to be this so the either is dealt with in the same
 way as before matching over and pulling B so B is unchanged and a any value
 is actually enough type X now so we could bring in this for clarity into
 x value there could you name this this is of time the path type Y so can
 you move this into my ability oh no this is a big spoke to you sir now
 what they do what do we do with this how do we map x2 ends to be into y2
 entity so this is the non trivial part where we have something data dot
 d is x2 end to be which consumes a function that consumes X and we need
 to produce a function that consume as a function that produces light how
 do we do that well we just write the code directed by type so this is a
 function so G is type white urgent data dot d has the type of x2 ends to
 be so we need to use data dot d on a function that takes X and produces
 int so how do we produce int well the only way to produce an int is to
 get G acting on some Y so G of something so that something must be some
 Y the only way to get a Y is to apply F to X so this code could be generated
 automatically even if that whole thing didn't work I'm pretty sure this
 would have worked if I just say off type here I put G and F and data table
 D data gene has flat major so I need F G actually F and data no G myself
 of type and I copy this type expression over here and I want to run this
 test so in any case the tests should pass with or without this change and
 this shows how the types that consume something that consumes a are actually
 go variant in a their functors in a it's the same same thing let's see
 what failed alright so that's also didn't work so let me undo that drama
 test again goodish Oregon compiles the first one the first test that here's
 a great covered land anymore very card library is slowing long examples
 all right right now we're alright so these are probably bugs or something
 that I could fix in the creek or we'd like it but the important thing is
 for us to understand how to do this by him and that's what this tutorial
 is about the last worked example right now is to to do this you have a
 a bunch of scholar can use classes with seal trait you need to identify
 which types are used covalently and conveniently and verify that with covarianc
e annotations yes how we do this so here's the seal trait so I put already
 the covariance annotations now the first thing I would do is to write this
 in a short notation because this is a lot of text with names and all that
 in the short notation so what do I have the first class as a case class
 has B and C so that's a times B is this and then B to hint the second one
 is a B and int so that's this product the third one the she is the string
 to a and B to a so product of these two and now I just look at this and
 figure out what types it has and whether these types are used covariant
 and contravariant so I find that a is only used in covariant positions
 so here I have an a here I have an a here I produce an A here I produced
 any so those are covariant positions to the right of the arrow or define
 the final arrow or without a mirror now the B is used here in a covariant
 position here in a contravariant position here covariant here contravariant
 so that's hopeless so B cannot be B is neither covariant nor contravariant
 now there are other types like int so int is used here in the covariant
 position here in a covariant position so int would be covariant so if I
 wanted to parameterize this by the type over int it would be a covariant
 or a functor with respect to that parameter and the string here is used
 contravariant lee only in one place so that's that would be a candidate
 for contra factor if I needed to parameterize by that type that would be
 a Concha factor so let me do that so I changed integer to I and string
 to s and then I put minus on s plus an i plus on a and B is not not too
 marked because it's neither covariant nor contravariant and now here's
 what would happen if I put a plus here instead of - so let me compile this
 and run this test if I if I do that the compiler will tell me that this
 mirror so it will know that this s is used here in a contravariant position
 i intellij doesn't show me the red and for that but here's the error message'
 Kovarian type s occurs on contravariant position and type este or bound
 effects so that's the air and that concludes our worked examples for this
 part and now there are some exercises of the same kind for you so after
 you have done these exercises you have an understanding of how to work
 with functor types and we have been checking we have been checking laws
 of function by hand every time by writing tests now this is not very satisfacto
ry because a main question still remains here is it true that any data type
 where a is well a type parameter in covariant position is it true that
 the data type is a function with respect to a I could write any kind of
 stuff like this and it would take time and effort to check the laws each
 time I have a type like this but just visually I see that here a is consumed
 but the whole thing is consumed so this is covariant usage of a here is
 covariant here's covariant and here's covariant so the entire type is a
 functor with respective a that seems obvious I could write an F map function
 very easily by just mapping each of these A's to be a to be a to be this
 I map to the same integer a to be they sent map to the same integer this
 R I'm after the same R I know how to do this we just had examples of all
 kinds of different types of this kind types of the sort that we can implement
 as factors but do the laws hold and do we need to write tests every time
 for this kind of thing in fact so the way we answer this question is to
 to realize that these data types are built from parts they're built like
 from a Lego set and what are the parts so these are the constant types
 like integer or unit you know type parameters and then there are operations
 that for example take two parts and put a plus between them when you get
 a new type and or you use the arrow or we use the product so basically
 these are type expressions that are produced out of constant types type
 parameters and these operations or you can have also other operations like
 composition of function like you take one factor and apply it to another
 like we did with our examples we took an either and under the either we
 had some data types that we defined and so on so that's a composition of
 functions or type constructors and we have noticed that every time that
 some type is moved to the left of an arrow its covariance is reversed so
 this would be contravariant in a and this is again covariant in a and so
 this that does this intuition always work or are there some cases when
 this is wrong that this is not the right right functor or the laws don't
 hold and also note that if we don't use the function error then everything
 is going to be always covariant so if we have a function error then we
 have to trace which one is covariant but if there is no error if if a.type
 was made without using the area operational types then all positions are
 covariant and so these are these are types that are called before polynomial
 types or polynomial type constructors and if this intuition is correct
 and they're always functors so all polynomial type constructors are functors
 and to answer this question we are going to build F map incrementally as
 we build up the type expression out of these parts and operations and at
 every step when we take for example two parts and put them together we
 define what the F map is for the new type constructor and we check the
 law left hold the dead step and once we go through all possible steps which
 are only for as far as I can see here then we're done we will prove we
 have we will have proved by induction that any type constructed from these
 operations will be a factor so let's see how that works so the building
 blocks for functors are constant factors and identity factor so what does
 that mean the constant factor is a type constructor that takes a type parameter
 a and always returns the quantity so for example int I can be considered
 as a functor that is parameterize by some a and always has a type int not
 a very interesting factor of course but nevertheless a valid function if
 you take F map which is always equal to identity so the value of type C
 is never changed and interestingly enough this is a contra factor at the
 same time with contrib also equal to identity and all the laws hold trivially
 because it's always identity so all the compositions are always identities
 that's not much to check the identity function is the factor that takes
 a type parameter and always returns that side type right now notice how
 I started to use terminology let the type the functor takes a type and
 returns at like as if factor is a function on types so that's indeed the
 case so you can consider factors or type constructors as functions of types
 functions that take types and return other types so that's in Scala it
 is noted it is very clear that this this is the case because we use square
 brackets to denote type application so this is very similar in exactly
 almost like having a function f that is applied to a type which is a function
 G applied to type a now is type level function the function that takes
 types and returns types so these are type constructors so it is a good
 way of thinking about type constructors just functions in the type space
 so the F map for the identity function takes the F and returns the same
 F so it means that if you want to transform a to B and you just apply the
 same F to a and you get to be the the walls hold in a very easy way obviously
 if F is identity then this has identity and composition is composition
 because we haven't changed anything so f is unchanged now the operations
 of creating new factors are the previous ones is what we're going to be
 concerned with next so imagine we have some functors F and G and we already
 have the F map implementations for them and we already checked the laws
 so f and G are functions and we already check that and now we need to build
 a functor such as this one so we need to build a new F map and we need
 to show that the laws hold for it and then we will we need to show there
 further that this type constructor is a functor and we need we do the same
 for these for this for this and also well we can see how that works because
 we already have experience in examples implementing F map for various construct
ions like this for example this is just built by pattern matching we preserve
 the left side to the left and the right side to the right and here we to
 pull the two results and again preserve the order and here we substitute
 the function argument into F map remember that trick we have G goes to
 f of X of whatever G so that's the kind of trick we need to do here an
 interesting thing in this case is that for this construction to work F
 must be a contractor and G must be a functor so then the contractor F will
 be in the contravariant position and the result of this will be covariant
 in a in every place now this wanna do composition of factors when you compose
 the to F Maps we just do F map here and you do F map of that and the final
 case it's interesting this type recursion so type recursion means that
 you define a type F using a recursive equation so you have some R which
 is a functor and both a and X must be a factor and then you write this
 equation so remember what we had as an example of recursive polynomial
 type so we wrote this equation so actually this equation can be written
 as L PA equals some function applied to LP a and a because this is a type
 construction of the same kind as we are considering as we are considering
 here so this can be just paralyzed like this and then this is a recursive
 equation because we're using FA inside here to define itself and we can
 then define F map for this just like we did before in that example and
 the F map function will be recursive and we'll use the F maps of this factor
 so that is all the operations that we need so for contra functors with
 appropriate changes we will have exactly the same instructions except that
 here this should be a functor that should be a contra function then the
 result is a contra functor so what remains is to check that in each case
 the filter laws still hold after each operation so let me check this for
 a few cases and I will leave other cases as exercises the first case is
 the disjunction of two factors so how does that work let me actually go
 and show you the code for this disjunction before we look at the short
 notation so in this code what I'm doing is I define two factors in some
 random way for example F 1 is just to prove a and integer and F 2 is an
 either of integer to a and a so see this is a is covariant and covariant
 here so I define these two factors I have defined some helper functions
 to help me check laws and and so on but just ignore it where these F map
 classes that I defined in the tests this is not essential and essential
 is that we define the F map of the right type and here I use implement
 because it just works and I need to define an equal function for F 2 so
 but suppose I'm given F 1 and F 2 so how do i define a disjunction well
 first of all I need to define the data type data okay but again I call
 this data just to be consistent with all other examples this is just a
 name this type so this is an either of F 1 away and F 2 away so you see
 in this case we just use it either and we don't need an extra case class
 strapless in and I define the f map so how do i define it I use the two
 f maps from the previous factors so these are the classes that I define
 they have this dot code method that represents the code of the F map and
 this is necessary for type reasons but not necessarily the best way of
 doing the functor constructions one will be sufficient for now so I define
 how do i define this F map well the data is a disjunction of functor f1
 and frontier f2 so I need to match on this disjunction so I match when
 I'm on the Left then I also return the left I'm supposed to return so I
 need to return a left part for the left and the right part for the right
 so this is the code that needs to be written for that purpose note that
 this quote does not use any details about what these functors are it just
 uses the F map for them so I have the F map 1 and F map 2 for the factors
 F 1 F 2 and I just call these F maps on the data that I have so that's
 what works when I check the laws of identity and composition but can I
 understand why these laws hold they do hold the tests pass but I want to
 have understanding and assurance that this is really correct for all factors
 not just for particular factors I have chosen and this is what I would
 do I would reason about the code more generally and I would use the short
 notation for the code to make it easier so it assumed that F n GA are type
 constructors for which we already have the F map with map F and F G and
 we already know that the laws hold for them now we define the F map for
 the factor F plus G or it would be function f plus G you find it like this
 so the data is a disjunction of P and Q and P is of type FA and Q is of
 type GA so this is our either from the code and this is the argument of
 this function and the result is a disjunction of left and right corresponding
 to P and Q so exactly what the code was doing I just wrote this in the
 show notation in short notation P is here and so if P is given that we
 return this plus zero and if Q is given them will return zero plus that
 so that Chris points in the code to returning left or returning right and
 that's just a short notation that I'll use the reason about these laws
 let us check the laws we have defined the function f map F plus G let's
 check that the laws hold for it now first law is identity law if F is identity
 then f map F plus G or identity must be identity and we assume that the
 law holds also for already holds for F and G at maps so this is a quick
 check then P plus Q is an arbitrary value of type F plus G and then by
 the formula we need to apply F map of F to the P which is identity and
 we need to apply F map of G to the F map G of F to the Q which is again
 and that is again identity so we just have P plus Q so we get we take P
 plus Q will return v plus Q and that's obviously identity so identity law
 holds for F map F plus G the composition law is a little longer to check
 but note as we noted in the code we don't actually use the structure of
 the factors F and G we just use the fact that they're functors and that
 F maps for them work correctly so the composition of these two F maps let's
 decompose first we need to first apply F 1 and then F 2 so when we apply
 F 1 and we have this this is a definition of our F map F plus G and then
 we apply that and then gives us the two compositions in the left hand and
 the right and then we can simplify that you the law for F into this using
 the law of G into that and that's exactly the same as if we have applied
 our F map F plus G to the composition of functions F 1 and F 2 so I suggest
 you go through this computation yourself and check that for any P and Q
 that you give here for any or rather not for any pienty for any value of
 P plus Q because there's only P or there's only Q in that disjunction so
 for any P plus Q you always return exactly this so the law holds and the
 law holds precisely because this may f map f what G was defined to work
 it was defined here to work separately on P and Q and to return corresponding
 parts of the disjunction if we mixed up some house and some of these parts
 oil for instance or given P but we return the right part of the disjunction
 sometimes that law would not hold at the law obviously here it depends
 on having the two parts completely separate so that concludes the proof
 that this construction gives you a factor if the fmg are factors the next
 example is to show that if f is a contra function G is a function then
 the function from G to F is itself a factor so let me go to the code which
 I have for this so I have a some contra factor very simple one and it's
 F map is so simple that it can be automatically implemented our defining
 quality for it as necessary for the test and then I define this data as
 a type I don't want to have an extra case class for extra complexity and
 this is just defined like that so exactly the same as the formula for the
 type can i define f map so how do i define f map all this seems to be a
 lot of code but actually this is just a definition of types for clarity
 i have an argument f of this type argument da which is data in an argument
 CF 1 B which is a part of data be so data B is C F 1 of B going to F 2
 of B so it's a function that takes CF one of these an argument so I have
 to return that function so that's how I'm returning it and the result must
 be F 2 of 8 so all this must be F - ok so how do I make this work I use
 the sorry F 2 of be nice to UM be the only way to get of 2 of B is to apply
 something to have two away because I cannot just construct f2 of be here
 from nothing from scratch no idea what this function is would be so I need
 to use the data I'm given so I'm given this FD a and C F 1 B so what's
 my plan well first I'm going to map CF on B into CF 1 a and that's a contra
 functor map contract map because I have a 2 B so I can map for the control
 factor C F 1 B to save one hey so then I have this I put that into da I
 get F 2 of a and then I EV map with F F to a goes to F to B of two of me
 so that's the whole thing I put the contra map first contra factor 1 into
 here apply this to CF I get a CF 1a I put that as an argument into da I
 get a tf2a and then I use F map 2 which is 4 F 2 again with the same F
 on the result and the laws hold why do they hold let's prove them they
 hold in general in the tests we only have specific contracts on certain
 specific function and specific types you know we cannot just run tests
 for generic functor so let's prove mathematically that this is true it's
 a very similar proof to the previous one the details are been different
 so here will help if we have some shorter notations definitions so instead
 of f map G of F I would just write gamma F instead of contra map F of F
 I would read 5x5 so Phi for F and gamma for G and just replacing Latin
 letters with Greek ones so this is the code that we had in our skull example
 written in this notation the XQ first uses the contra map of F on Q puts
 that into P which is this and then uses the map gamma gamma F on that P
 so then we check the identity law we just substitute these expressions
 so we take an arbitrary P of this type which is now our new functor to
 be and then we use we just substitute we get Q goes to P of Q because gamma
 is identity Phi is identity so it's kill going to P of Q right here now
 Q going to P of Q is the same as P because this is a function that takes
 argument and applies P to that same argument that's the same as what P
 would do by itself so this expression is exactly the same as this expression
 in its effect so that concludes the proof of the identity law we showed
 that F map of identity applied to some P gives you exactly the same P a
 composition law is checked like this so we assume that the composition
 law already holds for a fine gamma and here we see opposite order of compositio
n for Phi because it's a control factor so then we apply the definition
 and we get first we apply F map F G or F 1 so first we apply this and that's
 this gamma F 1 P Phi Q now we'll put that in there apply again and we have
 a curious thing that we have gummys together and Phi's together when you
 do this computation because here instead of P you have to put in that definitio
n this Q goes to this so when you do that the gamma is next to the gamma
 and the Phi is next to the phone so now those are compositions of gammas
 so we can use the composition law that already holds for gamma and replace
 this by this and also for fine note the order so from gamma is this order
 finds the reversal and this is therefore exactly the same as what we would
 have if we apply this new F map to the composition of functions F 1 and
 F 2 so then we have proved the composition law note that the order of the
 compositions must be reversed for fine otherwise this thing just won't
 work so if I did not have this reversed order here in this position the
 proof would not go through so this won't work if F is a factor F must be
 a country from K which is what we expected from intuition without from
 our intuition whatever is on the left has reversed its covariance and so
 if this is a contractor if this were a functor then being on the left makes
 this whole thing a contra variant in a and that's wrong through the function
 so this is our intuition the intuition is correct as we have just shown
 control function behind the error or to the left of the arrow it becomes
 covariant and vice-versa here are some exercises for you to check that
 this works and to check that this works for contra functor G and functor
 F so this is quite similar but the opposite order and also to show that
 this is neither a function or contra function when they're both functors
 are both country factors so that's much easier because you just give an
 example and show that the types don't match so to conclude this tutorial
 I would make a note that this kind of code is certainly not the best way
 of dealing with funder constructions so if you want in your code to construct
 new factors like this I would suggest taking a look at the libraries that
 do this there are two main libraries scholars II and cats so these libraries
 include functionality functionality that is quite similar to what we're
 doing here they can deal with functors generally so the the power of functional
 programming languages such as Scala and Haskell is that you can write code
 that takes an arbitrary function and transforms it in some way so you can
 not only as we have done we parameterize code by types but you can also
 parameterize code by a type constructor so you can have a function which
 I did not show here because it's quite advanced stuff but you can have
 a function that is permit rised by these things so it would work for any
 F 1 and F 2 with certain properties and that's the power of these type
 systems which is not present in most programming languages so in Scala
 this is a little difficult to write and quite abstract so if you if you
 try to write it from scratch so these libraries help and they can define
 functors and help you write code with functors so for instance if you wanted
 to have code that does something for any factor then I would suggest you
 try it yourself but it would be a bit hard explore these libraries also
 there there is a library called shapeless which has some utilities for
 automatic construction of functors so you see as you have noticed these
 operations are quite mechanical so there is no choice here and all this
 can be done automatically by by some preprocessor or or the compiler of
 Scala so there are libraries that allow you to write code to automatically
 implement F map for your own types with no code that you have to write
 almost no quality you have to write because all these operations are dictated
 by the mathematical properties of functor there's no choice the curry Howard
 library can help in certain cases but it doesn't know that you are constructing
 a functor instance it does not check the Loess so if that is if that is
 your purpose you should try to explore these libraries that allow you to
 automatically construct a functor implementation for your types and any
 types of this kind I think should be supported if not make a PR for them
 well this concludes the tutorial 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
