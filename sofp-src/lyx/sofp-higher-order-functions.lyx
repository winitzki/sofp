#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The logic of types.
 II.
 Curried functions
\begin_inset CommandInset label
LatexCommand label
name "chap:Higher-order-functions"

\end_inset

 
\end_layout

\begin_layout Section
Functions that return functions
\end_layout

\begin_layout Subsection
Motivation and first examples
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset

Consider the task of preparing a logger function that prints messages with
 a configurable prefix.
 
\end_layout

\begin_layout Standard
A simple logger function can be a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

, such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val logger: String => Unit = { message => println(s
\begin_inset Quotes erd
\end_inset

INFO: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> logger("hello world")
\end_layout

\begin_layout Plain Layout

INFO: hello world
\end_layout

\end_inset

This function prints any given message with the logging prefix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The standard library function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

println(...)
\end_layout

\end_inset

 always returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 value after printing its arguments.
 As we already know, there is only a single value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, and that value is denoted by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

.
 To see that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

println
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, run this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x = println(123)
\end_layout

\begin_layout Plain Layout

123
\end_layout

\begin_layout Plain Layout

x: Unit = ()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The task is to make the logging prefix configurable.
 A simple solution is to implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 that takes a prefix as an argument and returns a new logger containing
 that prefix.
 Note that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 returns a new 
\emph on
function
\emph default
, i.e., a new value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def logWith(prefix: String): (String => Unit) = {
\end_layout

\begin_layout Plain Layout

    message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 consists of a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

message => println(...)
\end_layout

\end_inset

, which is a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => Unit
\end_layout

\end_inset

.
 This value will be returned when we evaluate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

...
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We can now use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 to create some logger functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val info = logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

info: String => Unit = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val warn = logWith(
\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

warn: String => Unit = <function1>
\end_layout

\end_inset

The created loggers are then usable as ordinary functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

INFO: hello
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> warn(
\begin_inset Quotes eld
\end_inset

goodbye
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

WARN: goodbye
\end_layout

\end_inset

The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 can be used by any code that needs a logging function.
\end_layout

\begin_layout Standard
It is important that the prefix is 
\begin_inset Quotes eld
\end_inset

baked into
\begin_inset Quotes erd
\end_inset

 functions created by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

.
 A logger such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 will always print messages with the prefix 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, and the prefix cannot be changed any more.
 This is because the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prefix
\end_layout

\end_inset

 is treated as a local constant within the body of the nameless function
 computed and returned by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

.
 For instance, the body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

 is equivalent to:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ val prefix = 
\begin_inset Quotes eld
\end_inset

WARN
\begin_inset Quotes erd
\end_inset

; (message => s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\end_inset

Whenever a new function is created using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(prefix)
\end_layout

\end_inset

, the (immutable) reference to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prefix
\end_layout

\end_inset

 is stored within the body of the newly created function.
 This is a general feature of nameless functions: the function's body captures
 references to all the outer-scope values it uses.
 One sometimes says that the function's body 
\begin_inset Quotes eld
\end_inset

closes over
\begin_inset Quotes erd
\end_inset

 those values; for this reason, nameless functions are also called 
\begin_inset Quotes eld
\end_inset


\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
closure
\end_layout

\end_inset

closures
\series default

\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
However, nameless functions do not 
\emph on
copy
\emph default
 values from outer scopes.
 Those values are captured by reference.
 This distinction is important in Scala as it supports mutable values (as
 well as classes that encapsulate mutable values).
\end_layout

\begin_layout Standard
Here is an example of a function body capturing references to variables:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

var c: Int = 10  // Mutable variable!
\end_layout

\begin_layout Plain Layout

val f: Int => Int = {
\end_layout

\begin_layout Plain Layout

  val p = 10
\end_layout

\begin_layout Plain Layout

  val q = 20
\end_layout

\begin_layout Plain Layout

  x => p + q * x + c
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The body of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => 10 + 20 * x + c }
\end_layout

\end_inset

.
 The values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p = 10
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q = 20
\end_layout

\end_inset

 are local constants captured in the function's body.
 However, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 is captured by reference.
 If we change 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

, the behavior of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 will also change:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f(10)
\end_layout

\begin_layout Plain Layout

res0: Int = 220
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> c = 1000
\end_layout

\begin_layout Plain Layout

c: Int = 1000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(10)
\end_layout

\begin_layout Plain Layout

res1: Int = 1210 
\end_layout

\end_inset

A captured reference to a mutable external variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 makes the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 itself mutable, even though 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 was defined as a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

.
 We will avoid such code in this book and instead use immutable values.
\end_layout

\begin_layout Subsection
Curried and uncurried functions
\end_layout

\begin_layout Standard
Reasoning mathematically about the following code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val info = logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

we would expect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 is 
\emph on
the same value
\emph default
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

, and so the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 should have the same effect as the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith("INFO")("hello")
\end_layout

\end_inset

.
 This is indeed so:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> logWith("INFO")("hello")
\end_layout

\begin_layout Plain Layout

INFO: hello
\end_layout

\end_inset

The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith("INFO")("hello")
\end_layout

\end_inset

 looks like the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 applied to 
\emph on
two
\emph default
 arguments.
 Yet, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 was defined as a function with a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
 This is not a contradiction because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 returns a function that accepts an additional argument.
 So, expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith(
\begin_inset Quotes eld
\end_inset

INFO
\begin_inset Quotes erd
\end_inset

)(
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 are both valid.
 In this sense, we are allowed to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 to one argument at a time.
\end_layout

\begin_layout Standard
A function that can be applied to arguments in this way is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
curried function
\end_layout

\end_inset


\series bold
curried
\series default
 function.
 
\end_layout

\begin_layout Standard
While a curried function can be applied to one argument at a time, an 
\series bold
uncurried
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurried function
\end_layout

\end_inset

 function must be applied to all arguments at once, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prefixLog(prefix: String, message: String): Unit = println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The type of the curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => (String => Unit)
\end_layout

\end_inset

.
 By Scala's syntax conventions, the function arrow (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

) groups to the 
\emph on
right
\emph default
.
 So, the parentheses in the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => (String => Unit)
\end_layout

\end_inset

 are not needed.
 The function's type can be written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String => Unit
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String => Unit
\end_layout

\end_inset

 is different from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String => String) => Unit
\end_layout

\end_inset

, which is the type of a function returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 and having a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
When an argument's type is a function type, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String => String
\end_layout

\end_inset

, it 
\emph on
must
\emph default
 be enclosed in parentheses, as in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(String => String) => Unit
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In general, a curried function takes an argument and returns another function
 that again takes an argument and returns another function, and so on, until
 finally a non-function type is returned.
 So, the type signature of a curried function generally looks like 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => ...
 => R => S
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R
\end_layout

\end_inset

 are the 
\series bold
curried arguments
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
curried arguments
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 result type.
\end_layout

\begin_layout Standard
For example, in the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => D
\end_layout

\end_inset

 the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 are the types of curried arguments, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

 is the final result type.
 It takes time to get used to reading this kind of syntax.
\end_layout

\begin_layout Standard
In Scala, functions defined with multiple argument lists (enclosed in multiple
 pairs of parentheses) are curried functions.
 We have seen examples of curried functions before:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
\end_layout

\begin_layout Plain Layout

def fmap[A, B](f: A => B)(xs: Option[A]): Option[B]
\end_layout

\begin_layout Plain Layout

def foldLeft[A, R](xs: Seq[A])(init: R)(update: (R, A) => R): R
\end_layout

\end_inset

The type signatures of these functions can be also written equivalently
 without argument names, although this is less convenient in practical coding:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B]: Seq[A] => (A => B) => Seq[B]
\end_layout

\begin_layout Plain Layout

def fmap[A, B]: (A => B) => Option[A] => Option[B]
\end_layout

\begin_layout Plain Layout

def foldLeft[A, R]: Seq[A] => R => ((R, A) => R) => R
\end_layout

\end_inset

Curried arguments of a 
\emph on
function type
\emph default
, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B)
\end_layout

\end_inset

, need parentheses.
\end_layout

\begin_layout Standard
To summarize, a curried function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 can be defined in three equivalent ways in Scala:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

def logWith1(prefix: String)(message: String): Unit = println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Plain Layout

def logWith2(prefix: String): String => Unit = { message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\begin_layout Plain Layout

def logWith3: String => String => Unit = { prefix => message => println(s
\begin_inset Quotes erd
\end_inset

$prefix: $message
\begin_inset Quotes erd
\end_inset

) }
\end_layout

\end_inset

For clarity, we will sometimes enclose nameless functions in parentheses
 or curly braces.
 
\end_layout

\begin_layout Standard
Line 3 above shows that the arrow symbols 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 group to the right within the 
\emph on
code
\emph default
 of nameless functions.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => expr
\end_layout

\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{x => {y => expr}}
\end_layout

\end_inset

, a nameless function taking an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returning a nameless function that takes an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

 and returns an expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

.
 This syntax convention is helpful since the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z
\end_layout

\end_inset

 visually corresponds to the curried function's type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C
\end_layout

\end_inset

, which uses the same syntax convention.
 Also, the syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y) => z
\end_layout

\end_inset

 could not possibly work for a nameless function because  matching a function
 against the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y
\end_layout

\end_inset

 makes no sense.
 If we matched a function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ t => t + 20 }
\end_layout

\end_inset

 against the pattern 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y
\end_layout

\end_inset

 by setting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = t
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = t + 20
\end_layout

\end_inset

, we would have no value for the bound variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

.
 (What would be the integer value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

?) So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => (y => z)
\end_layout

\end_inset

 is the only sensible way of adding parentheses to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Although the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y) => z
\end_layout

\end_inset

 is invalid, the type expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B) => C
\end_layout

\end_inset

 is valid.
 We may write a nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A => B) => C
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f => expr
\end_layout

\end_inset

 where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 is the argument and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 the body.
\end_layout

\begin_layout Subsection
Equivalence of curried and uncurried functions
\end_layout

\begin_layout Standard
We defined the curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

logWith
\end_layout

\end_inset

 in order to be able to create logger functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

info
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

warn
\end_layout

\end_inset

.
 However, some curried functions, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

foldLeft
\end_layout

\end_inset

, are almost always applied to all possible arguments.
 A curried function applied to all its possible arguments is equivalent
 to an uncurried function that takes all those arguments at once.
 Let us look at this equivalence in more detail.
\end_layout

\begin_layout Standard
Consider a curried function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

.
 This function takes an integer and returns an (uncurried) function taking
 an integer and returning an integer.
 An example of such a curried function is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1(x: Int): Int => Int = { y => x - y }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function takes an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returns the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => x - y
\end_layout

\end_inset

, which is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 The code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 can be written equivalently as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f1: Int => Int => Int = { x => y => x - y }
\end_layout

\end_inset

Let us rewrite 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 as a function that takes its two arguments at once:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2(x: Int, y: Int): Int = x - y
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 has type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset

.
 Calling 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 requires different syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f1(20)(4)
\end_layout

\begin_layout Plain Layout

res0: Int = 16
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f2(20, 4)
\end_layout

\begin_layout Plain Layout

res1: Int = 16
\end_layout

\end_inset

The main difference is that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 must be applied at once to both arguments, while 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 could be applied to just the first argument (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

).
 Applying a curried function to some but not all possible arguments is called
 a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

partial application
\series default
.
 The result of evaluating 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1(20)
\end_layout

\end_inset

 is a function that can be later applied to another argument:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r1 = f1(20)
\end_layout

\begin_layout Plain Layout

r1: Int => Int = <function1> 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r1(4)
\end_layout

\begin_layout Plain Layout

res2: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applying a curried function to all possible arguments is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
curried function!full application
\end_layout

\end_inset


\series bold
full
\series default
 application.
 A full application returns a value that is not of a function type.
 So, it cannot be applied to more arguments.
\end_layout

\begin_layout Standard
To partially apply an 
\emph on
uncurried
\emph default
 function, we can use the underscore (
\begin_inset Formula $\_$
\end_inset

) symbol:
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

scala> val r2: Int => Int = f2(20, _)
\end_layout

\begin_layout Plain Layout

r2: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r2(4)
\end_layout

\begin_layout Plain Layout

res3: Int = 16
\end_layout

\end_inset

(The type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 is required in line 1.) This code creates a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 to the first argument but not to the second.
 Then 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 is the same function as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

 defined above; i.e., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r2
\end_layout

\end_inset

 returns the same values for the same arguments as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

r1
\end_layout

\end_inset

.
 A more verbose syntax for a partial application is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val r3: Int => Int = { x => f2(20, x) }  // Same as r2 above.
\end_layout

\begin_layout Plain Layout

r3: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> r3(4)
\end_layout

\begin_layout Plain Layout

res4: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see that a curried function, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, is better adapted for partial application than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, because the syntax is shorter.
 However, the 
\emph on
types
\emph default
 of functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 are
\series bold
 equivalent
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type equivalence
\end_layout

\end_inset

: for any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

 we can reconstruct 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset

 and vice versa, without loss of information:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2new(x: Int, y: Int): Int = f1(x)(y)             // f2new is equal
 to f2
\end_layout

\begin_layout Plain Layout

def f1new: Int => Int => Int = { x => y => f2(x, y) } // f1new is equal
 to f1
\end_layout

\end_inset

It is clear that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1new
\end_layout

\end_inset

 computes the same results as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

, and that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2new
\end_layout

\end_inset

 computes the same results as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

.
 The equivalence of the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 is not 
\emph on
equality
\emph default
  â€” these functions are 
\emph on
different
\emph default
; but each of them can be reconstructed from the other.
 The one-to-one correspondence between all functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset

 and all functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int, Int) => Int
\end_layout

\end_inset

 is what we call the 
\begin_inset Quotes eld
\end_inset

equivalence of types
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
More generally, a curried function has a type signature of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => ...
 => R => S
\end_layout

\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, ..., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

S
\end_layout

\end_inset

 are some types.
 A function with this type signature is equivalent to an uncurried
\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurried function
\end_layout

\end_inset

 function with type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A,B,C,...,R) => S
\end_layout

\end_inset

.
 The uncurried function takes all arguments at once, while the curried function
 takes one argument at a time.
 Other than that, these two functions compute the same results given the
 same arguments.
\end_layout

\begin_layout Standard
We have seen how a curried function can be converted to an equivalent uncurried
 one, and vice versa.
 The Scala library defines the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 that convert between these forms of functions.
 To convert between 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val f1c = (f2 _).curried
\end_layout

\begin_layout Plain Layout

f1c: Int => (Int => Int) = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val f2u = Function.uncurried(f1c)
\end_layout

\begin_layout Plain Layout

f2u: (Int, Int) => Int = <function2> 
\end_layout

\end_inset

The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f2 _)
\end_layout

\end_inset

 is needed in Scala to convert methods to function values.
 Recall that Scala has two ways of defining a function: one as a method
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala method
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

), another as a function value
\begin_inset Index idx
status open

\begin_layout Plain Layout
function as a value
\end_layout

\end_inset

 (defined using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

).
 The extra underscore is unnecessary in Scala 3.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 are quick to implement (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-fully-parametric"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below).
 These functions are called the 
\series bold
currying
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
currying
\end_layout

\end_inset

 and 
\series bold
uncurrying
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurrying
\end_layout

\end_inset

 transformations.
\end_layout

\begin_layout Section
Fully parametric functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Fully-parametric-functions"

\end_inset


\end_layout

\begin_layout Standard
Scala code may declare functions with type parameters, which are set only
 when the function is applied to specific arguments.
 Examples of such functions are 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def map[A, B](xs: Seq[A])(f: A => B): Seq[B]
\end_layout

\begin_layout Plain Layout

def filter[A](xs: Seq[A])(p: A => Boolean): Seq[A]
\end_layout

\end_inset

Such functions can be applied to arguments of different types without changing
 the function's code.
 It is better to write a single function with type parameters instead of
 writing several functions with repeated code but working with different
 types.
\end_layout

\begin_layout Standard
When we apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map(xs)(f)
\end_layout

\end_inset

 to a specific value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq[Int]
\end_layout

\end_inset

, and a specific function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 of type, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => String
\end_layout

\end_inset

, the Scala compiler will automatically set the type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B = String
\end_layout

\end_inset

 in the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 We may also set type parameters explicitly and write, for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map[Int, String](xs)(f)
\end_layout

\end_inset

.
 This syntax shows a certain similarity between type parameters such as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 and 
\begin_inset Quotes eld
\end_inset

value parameters
\begin_inset Quotes erd
\end_inset

 (arguments) 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 Setting type parameters, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map[Int, String]
\end_layout

\end_inset

, means substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B = String
\end_layout

\end_inset

 into the type signature of the function, similarly to how setting value
 parameters means substituting specific values into the function body.
\end_layout

\begin_layout Standard
In the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 as just shown, some types are parameters while others are specific types,
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

.
 It is sometimes possible to replace 
\emph on
all
\emph default
 specific types in the type signature of a function by type parameters.
 The result is a 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset

 function.
\end_layout

\begin_layout Standard
We call a function 
\series bold
fully parametric
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!function|textit
\end_layout

\end_inset

 if its arguments have types described by type parameters, and the code
 of the function does not use any information about its argument types,
 other than assuming that those types correctly match the type signature.
 In addition to type parameters, a fully parametric function may use the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type, tuple types, disjunctive types, and function types.
 Fully parametric functions may not use any library-defined types such as
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
What kind of functions are fully parametric? To build up intuition, let
 us compare the following two functions that have the same type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cos_sin(p: (Double, Double)): (Double, Double) = p match {
\end_layout

\begin_layout Plain Layout

  case (x, y) =>
\end_layout

\begin_layout Plain Layout

    val r = math.sqrt(x * x + y * y)
\end_layout

\begin_layout Plain Layout

    (x / r, y / r)   // Return cos and sin of the angle, or `NaN` when undefined.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def swap(p: (Double, Double)): (Double, Double) = p match {
\end_layout

\begin_layout Plain Layout

  case (x, y) => (y, x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

We can introduce type parameters into the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 to make it fully parametric:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap[A, B](p: (A, B)): (B, A) = p match {
\end_layout

\begin_layout Plain Layout

  case (x, y) => (y, x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Converting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 into a fully parametric function is possible because the operation of swapping
 the parts of a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 works in the same way for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 No changes were made in the body of the function.
 The specialized version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 working on 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Double, Double)
\end_layout

\end_inset

 can be obtained from the fully parametric version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 if we set the type parameters as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Double
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B = Double
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In contrast, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 performs a computation that is specific to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 That computation cannot be generalized to an arbitrary type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 instead of the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 For instance, the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 uses the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

math.sqrt
\end_layout

\end_inset

, which is defined only for the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
To generalize 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 to a fully parametric function that works with a type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, we would need to replace all computations specific to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 by new arguments working with the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 For example, we could introduce two new arguments (named, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

distance
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ratio
\end_layout

\end_inset

) and replace 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 by the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin_parametric
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def cos_sin_parametric[A](p: (A, A), distance: (A, A) => A, ratio: (A, A)
 => A): (A, A) = p match {
\end_layout

\begin_layout Plain Layout

  case (x, y) =>
\end_layout

\begin_layout Plain Layout

    val r = distance(x, y)
\end_layout

\begin_layout Plain Layout

    (ratio(x, r), ratio(y, r))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A fully parametric function has all its arguments typed with type parameters
 or with some combinations of type parameters, i.e., 
\series bold
type expressions
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type expression
\end_layout

\end_inset

 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, B)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X => Either[X, Y]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 operation for pairs is already defined in the Scala library:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1, 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

).swap
\end_layout

\begin_layout Plain Layout

res0: (String, Int) = (abc,1)
\end_layout

\end_inset

If needed, other swapping functions can be implemented for tuples with more
 elements, e.g.:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swapAC[A, B, C]: ((A, B, C)) => (C, B, A) = { case (x, y, z) => (z,
 y, x) }
\end_layout

\end_inset

The Scala syntax requires 
\emph on
double
\emph default
 parentheses around tuple types
\begin_inset Index idx
status open

\begin_layout Plain Layout
tuples!as function arguments
\end_layout

\end_inset

 of arguments but not around the tuple type of a function's result.
 So, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cos_sin
\end_layout

\end_inset

 may be written as a value like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val cos_sin: ((Double, Double)) => (Double, Double) = ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Further examples of fully parametric functions are the identity function,
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 function, the function composition methods, and the currying / uncurrying
 transformations.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity function
\end_layout

\end_inset

identity function is available in the Scala library as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[T]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def identity[T]: T => T = (t => t)
\end_layout

\end_inset

In the mathematical notation, we write the identity function as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{id}$
\end_inset


\begin_inset Quotes erd
\end_inset

 for brevity.
\end_layout

\begin_layout Standard
The function available in the Scala library as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Function.const[C, X]
\end_layout

\end_inset

 takes an argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 and returns 
\emph on
a new function
\emph default
 that always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

c
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def const[C, X](c: C): X => C = (_ => c)
\end_layout

\end_inset

The syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_ => c
\end_layout

\end_inset

 is used to emphasize that the new returned function ignores its argument.
 One-argument functions that ignore their argument are called 
\series bold
constant functions
\series default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Function composition
\begin_inset CommandInset label
LatexCommand label
name "subsec:Examples-of-fully-parametric"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
function composition
\end_layout

\end_inset

Consider two functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Double
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g: Double => String
\end_layout

\end_inset

.
 We can apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to an integer argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and get a result 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

.
 Applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to that result gives a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(f(x))
\end_layout

\end_inset

.
 The transformation from an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 to a final 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g(f(x))
\end_layout

\end_inset

 can be viewed as a new function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => String
\end_layout

\end_inset

.
 That new function is called the 
\series bold
forward composition
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
forward composition
\end_layout

\end_inset

 of the two functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

.
 In Scala, the forward composition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 is written as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f: Int => Double = (x => 5.67 + x)
\end_layout

\begin_layout Plain Layout

val g: Double => String = (x => f"Result x = $x%3.2f")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val h = f andThen g       // h(x) is defined as g(f(x)).
\end_layout

\begin_layout Plain Layout

h: Int => String = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> h(40)
\end_layout

\begin_layout Plain Layout

res36: String = Result x = 45.67
\end_layout

\end_inset

The Scala compiler derives the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 automatically as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => String
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This book denotes the forward composition by the symbol 
\begin_inset Formula ${\displaystyle \bef}$
\end_inset

 (which can be read as 
\begin_inset Quotes eld
\end_inset

before
\begin_inset Quotes erd
\end_inset

).
 We define 
\begin_inset Formula $f\bef g$
\end_inset

 (reads 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset

 before 
\begin_inset Formula $g$
\end_inset


\begin_inset Quotes erd
\end_inset

) by:
\begin_inset Formula 
\begin{equation}
f\bef g\triangleq x\rightarrow g(f(x))\quad.\label{eq:def-of-forward-composition}
\end{equation}

\end_inset

The symbol 
\begin_inset Formula $\triangleq$
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

is defined as
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

is equal by definition to
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
We may implement the forward composition as a fully parametric function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def andThen[X, Y, Z](f: X => Y)(g: Y => Z): X => Z = { x => g(f(x)) }
\end_layout

\end_inset

This type signature requires the types of the function arguments to match
 in a certain way, or else the composition is undefined (and the code would
 produce a type error).
 The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

 is an example of a function that 
\emph on
both
\emph default
 returns a new function 
\emph on
and
\emph default
 takes other functions as arguments.
\end_layout

\begin_layout Standard
The 
\series bold
backward composition
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
backward composition
\end_layout

\end_inset

 of two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 works in the opposite order: first 
\begin_inset Formula $g$
\end_inset

 is applied and then 
\begin_inset Formula $f$
\end_inset

.
 This operation is denoted by the symbol 
\begin_inset Formula $\circ$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

after
\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula 
\begin{equation}
f\circ g\triangleq x\rightarrow f(g(x))\quad.\label{eq:def-of-backward-composition}
\end{equation}

\end_inset

In Scala, the backward composition is called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

 and used as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f compose g
\end_layout

\end_inset

.
 This method may be implemented as a fully parametric function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def compose[X, Y, Z](f: Y => X)(g: Z => Y): Z => X = { z => f(g(z)) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have already seen the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 from the Scala library.
 As an illustration, here is the code for the 
\series bold
uncurrying
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
uncurrying
\end_layout

\end_inset

 transformation (converting curried functions to uncurried):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def uncurry[A, B, R](f: A => B => R): ((A, B)) => R = { case (a, b) => f(a)(b)
 }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These examples show that fully parametric functions perform operations so
 general that they work in the same way for all types.
 Some arguments of fully parametric functions may have complicated types
 such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => R
\end_layout

\end_inset

, which are type expressions built up from type parameters.
 But fully parametric functions do not use values of specific types such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Functions with type parameters are often called 
\begin_inset Quotes eld
\end_inset

generic
\begin_inset Index idx
status open

\begin_layout Plain Layout
generic functions
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 This book uses the term 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!function
\end_layout

\end_inset


\series bold
fully parametric
\series default

\begin_inset Quotes erd
\end_inset

 to designate a certain restricted kind of generic functions.
\end_layout

\begin_layout Subsection
Laws of function composition
\begin_inset CommandInset label
LatexCommand label
name "subsec:Laws-of-function-composition"

\end_inset


\end_layout

\begin_layout Standard
The operations of function composition, introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-fully-parametric"
plural "false"
caps "false"
noprefix "false"

\end_inset

, have three important properties or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
The two 
\series bold
identity laws
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of function composition
\end_layout

\end_inset

: the composition of any function 
\begin_inset Formula $f$
\end_inset

 with an identity function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

) will give again the function 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Itemize
The 
\series bold
associativity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of function composition
\end_layout

\end_inset

: the consecutive composition of three functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

 does not depend on the order in which the pairs are composed.
\end_layout

\begin_layout Standard
These laws hold equally for the forward and the backward composition, since
 those are just syntactic variants of the same operation.
 Let us write these laws rigorously as equations and prove them.
\end_layout

\begin_layout Paragraph
Proofs with forward composition
\end_layout

\begin_layout Standard
The composition of the identity function with an arbitrary function 
\begin_inset Formula $f$
\end_inset

 on the left is written as 
\begin_inset Formula $f\bef\text{id}$
\end_inset

.
 The composition with the function 
\begin_inset Formula $f$
\end_inset

 on the right is written as 
\begin_inset Formula $\text{id}\bef f$
\end_inset

.
 In both cases, the result must be equal to the function 
\begin_inset Formula $f$
\end_inset

.
 The resulting two laws are:
\begin_inset Formula 
\begin{align*}
\text{left identity law of function composition}:\quad & \text{id}\bef f=f\quad,\\
\text{right identity law of function composition}:\quad & f\bef\text{id}=f\quad.
\end{align*}

\end_inset

To prove that these laws hold, we need to show that the functions at both
 sides of the laws  give the same result when applied to an arbitrary value
 
\begin_inset Formula $x$
\end_inset

.
 Let us first clarify how the type parameters must be set for all types
 to match consistently.
\end_layout

\begin_layout Standard
The laws must hold for an arbitrary function 
\begin_inset Formula $f$
\end_inset

.
 Assume that 
\begin_inset Formula $f$
\end_inset

 has the type signature 
\begin_inset Formula $A\rightarrow B$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are arbitrary types (type parameters).
 Consider the left identity law.
 The function 
\begin_inset Formula $(\text{id}\bef f)$
\end_inset

 is, by definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-forward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), a function that takes an argument 
\begin_inset Formula $x$
\end_inset

, applies 
\begin_inset Formula $\text{id}$
\end_inset

 to that 
\begin_inset Formula $x$
\end_inset

, and then applies 
\begin_inset Formula $f$
\end_inset

 to the result: 
\begin_inset Formula 
\[
\text{id}\bef f=\left(x\rightarrow f\left(\text{id}\,(x)\right)\right)\quad.
\]

\end_inset

If 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $A\rightarrow B$
\end_inset

, its argument must be of type 
\begin_inset Formula $A$
\end_inset

, or else the types will not match.
 Therefore, the identity function must have type 
\begin_inset Formula $A\rightarrow A$
\end_inset

, and the argument 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $A$
\end_inset

.
 With these choices of the type parameters, the function 
\begin_inset Formula $\left(x\rightarrow f(\text{id}(x))\right)$
\end_inset

 will have type 
\begin_inset Formula $A\rightarrow B$
\end_inset

.
 This type matches the right-hand side of the law, which is just 
\begin_inset Formula $f$
\end_inset

.
 We add type annotations to the code as 
\emph on
superscripts
\emph default
:
\begin_inset Formula 
\[
\text{id}^{:A\rightarrow A}\bef f^{:A\rightarrow B}=\big(x^{:A}\rightarrow f\left(\text{id}\,(x)\right)\big)^{:A\rightarrow B}\quad.
\]

\end_inset

In the Scala syntax, this formula may be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

identity[A] andThen (f: A => B) == { x: A => f(identity(x)) }: A => B
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will follow the convention where type parameters are single uppercase
 letters, as is common in Scala code (although this convention is not enforced
 by the Scala compiler).
 The colon symbol (
\begin_inset Formula $:$
\end_inset

) in the superscript 
\begin_inset Formula $x^{:A}$
\end_inset

 means a type annotation, as in Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x:A
\end_layout

\end_inset

.
 Superscripts 
\emph on
without
\emph default
 a colon, such as 
\begin_inset Formula $\text{id}^{A}$
\end_inset

, denote type parameters, as in Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

.
 Since the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => A
\end_layout

\end_inset

, we can write 
\begin_inset Formula $\text{id}^{A}$
\end_inset

 or equivalently (but more verbosely) 
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

 to denote that function.
\end_layout

\begin_layout Standard
Now we can prove the law.
 By definition of the identity function, we have 
\begin_inset Formula $\text{id}\,(x)=x$
\end_inset

, and so:
\begin_inset Formula 
\[
\text{id}\bef f=\left(x\rightarrow f(\text{id}\,(x))\right)=\left(x\rightarrow f(x)\right)=f\quad.
\]

\end_inset

The last step works since 
\begin_inset Formula $x\rightarrow f(x)$
\end_inset

 is a function that takes an argument 
\begin_inset Formula $x$
\end_inset

 and applies 
\begin_inset Formula $f$
\end_inset

 to that argument.
 This is the same function as 
\begin_inset Formula $f$
\end_inset

.
 We say that 
\begin_inset Formula $x\rightarrow f(x)$
\end_inset

 is an 
\series bold
expanded form
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
expanded form of a function
\end_layout

\end_inset

 of the function 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
We turn to the right identity law, 
\begin_inset Formula $f\bef\text{id}=f$
\end_inset

.
 Write out the left-hand side:
\begin_inset Formula 
\[
f\bef\text{id}=\left(x\rightarrow\text{id}\,(f(x))\right)\quad.
\]

\end_inset

To check that the types match, assume that 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Then 
\begin_inset Formula $x$
\end_inset

 must have type 
\begin_inset Formula $A$
\end_inset

, and the identity function must have type 
\begin_inset Formula $B\rightarrow B$
\end_inset

.
 The result of 
\begin_inset Formula $\text{id}\,(f(x))$
\end_inset

 will also have type 
\begin_inset Formula $B$
\end_inset

.
 With these choices of type parameters, all types match:
\begin_inset Formula 
\[
f^{:A\rightarrow B}\bef\text{id}^{:B\rightarrow B}=\big(x^{:A}\rightarrow\text{id}\,(f(x))\big)^{:A\rightarrow B}\quad.
\]

\end_inset

Since 
\begin_inset Formula $\text{id}\,(f(x))=f(x)$
\end_inset

, we find:
\begin_inset Formula 
\[
f\bef\text{id}=\left(x\rightarrow f(x)\right)=f\quad.
\]

\end_inset

In this way, we have demonstrated that both identity laws hold.
 
\end_layout

\begin_layout Standard
The associativity law is written as an equation like this:
\begin_inset Formula 
\begin{align}
\text{associativity law of function composition}:\quad & (f\bef g)\bef h=f\bef(g\bef h)\quad.\label{eq:associativity-of-function-composition}
\end{align}

\end_inset

Let us verify that the types match here.
 The types of the functions 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 must be such that all the function compositions match.
 If 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 for some type parameters 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, then the argument of 
\begin_inset Formula $g$
\end_inset

 must be of type 
\begin_inset Formula $B$
\end_inset

.
 So, we must have 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, where 
\begin_inset Formula $C$
\end_inset

 is another type parameter.
 The composition 
\begin_inset Formula $f\bef g$
\end_inset

 has type 
\begin_inset Formula $A\rightarrow C$
\end_inset

, so 
\begin_inset Formula $h$
\end_inset

 must have type 
\begin_inset Formula $C\rightarrow D$
\end_inset

 for some type 
\begin_inset Formula $D$
\end_inset

.
 Assuming the types as 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, and 
\begin_inset Formula $h^{:C\rightarrow D}$
\end_inset

, we find that the types in all the compositions 
\begin_inset Formula $f\bef g$
\end_inset

, 
\begin_inset Formula $g\bef h$
\end_inset

, 
\begin_inset Formula $(f\bef g)\bef h$
\end_inset

, and 
\begin_inset Formula $f\bef(g\bef h)$
\end_inset

 match.
 We can rewrite Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) with type annotations: 
\begin_inset Formula 
\begin{equation}
(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\bef h^{:C\rightarrow D}=f^{:A\rightarrow B}\bef(g^{:B\rightarrow C}\bef h^{:C\rightarrow D})\quad.\label{eq:associativity-law-for-function-composition-with-types}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
After checking the types, we are ready to verify the associativity law.
 Note that both sides of the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-for-function-composition-with-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) are functions of type 
\begin_inset Formula $A\rightarrow D$
\end_inset

.
 To prove that two functions are equal means to prove that they return the
 same results when applied to the same arguments.
 So, let us apply both sides of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-for-function-composition-with-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to an arbitrary value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 Using definition
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:def-of-forward-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for the forward composition, we find:
\begin_inset Formula 
\begin{align*}
\left((f\bef g)\bef h\right)(x) & =h\left(\left(f\bef g\right)(x)\right)=h(g(f(x)))\quad,\\
\left(f\bef(g\bef h)\right)(x) & =\left(g\bef h\right)(f(x))=h(g(f(x)))\quad.
\end{align*}

\end_inset

Both sides of the law are equal when applied to an arbitrary value 
\begin_inset Formula $x$
\end_inset

.
 This concludes the proof.
\end_layout

\begin_layout Standard
Because of the associativity law, we do not need parentheses when writing
 the expression 
\begin_inset Formula $f\bef g\bef h$
\end_inset

.
 The function 
\begin_inset Formula $(f\bef g)\bef h$
\end_inset

 is equal to the function 
\begin_inset Formula $f\bef(g\bef h)$
\end_inset

.
\end_layout

\begin_layout Standard
In the proof, we have omitted the type annotations since we already checked
 that all types match.
 Checking the types beforehand allows us to write shorter derivations.
\end_layout

\begin_layout Paragraph
Proofs with backward composition
\end_layout

\begin_layout Standard
This book prefers to use the 
\series bold
forward composition
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
forward composition
\end_layout

\end_inset

 
\begin_inset Formula $f\bef g$
\end_inset

 rather than the backward
\begin_inset Index idx
status open

\begin_layout Plain Layout
backward composition
\end_layout

\end_inset

 composition 
\begin_inset Formula $g\circ f$
\end_inset

.
 If desired, all equations can be converted from one notation to the other
 by reversing the order of compositions:
\begin_inset Formula 
\[
f\bef g\triangleq g\circ f
\]

\end_inset

for any functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

.
 Let us see how to prove the composition laws in the backward notation.
 We will just need to reverse the order of function compositions in the
 proofs above.
\end_layout

\begin_layout Standard
The left identity and right identity laws are:
\begin_inset Formula 
\[
f\circ\text{id}=f\quad\quad,\quad\text{id}\circ f=f\quad.
\]

\end_inset

To match the types, we need to choose the type parameters as:
\begin_inset Formula 
\[
f^{:A\rightarrow B}\circ\text{id}^{:A\rightarrow A}=f^{:A\rightarrow B}\quad\quad,\quad\text{id}^{B\rightarrow B}\circ f^{:A\rightarrow B}=f^{:A\rightarrow B}\quad.
\]

\end_inset

We now apply both sides of the laws to an arbitrary value 
\begin_inset Formula $x^{:A}$
\end_inset

.
 For the left identity law, we find:
\begin_inset Formula 
\begin{align*}
\text{use definition~(\ref{eq:def-of-backward-composition})}:\quad & f\circ\text{id}=\left(x\rightarrow f(\text{id}\,(x))\right)=\left(x\rightarrow f(x)\right)=f\quad.
\end{align*}

\end_inset

Similarly for the right identity law:
\begin_inset Formula 
\[
\text{id}\circ f=\left(x\rightarrow\text{id}\,(f(x))\right)=\left(x\rightarrow f\left(x\right)\right)=f\quad.
\]

\end_inset

The associativity law,
\begin_inset Formula 
\[
h\circ\left(g\circ f\right)=\left(h\circ g\right)\circ f\quad,
\]

\end_inset

is proved by applying both sides to an arbitrary value 
\begin_inset Formula $x$
\end_inset

 of a suitable type:
\begin_inset Formula 
\begin{align*}
\left(h\circ\left(g\circ f\right)\right)(x) & =h\left(\left(g\circ f\right)(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad,\\
\left(\left(h\circ g\right)\circ f\right)(x) & =\left(h\circ g\right)\left(f(x)\right)=h\left(g\left(f\left(x\right)\right)\right)\quad.
\end{align*}

\end_inset

The types are checked by assuming that 
\begin_inset Formula $f$
\end_inset

 has the type 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 The types in 
\begin_inset Formula $g\circ f$
\end_inset

 match only when 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

, and then 
\begin_inset Formula $g\circ f$
\end_inset

 is of type 
\begin_inset Formula $A\rightarrow C$
\end_inset

.
 The type of 
\begin_inset Formula $h$
\end_inset

 must be 
\begin_inset Formula $h^{:C\rightarrow D}$
\end_inset

 for the types in 
\begin_inset Formula $h\circ\left(g\circ f\right)$
\end_inset

 to match.
 We can write the associativity law with type annotations as:
\begin_inset Formula 
\begin{equation}
h^{:C\rightarrow D}\circ(g^{:B\rightarrow C}\circ f^{:A\rightarrow B})=(h^{:C\rightarrow D}\circ g^{:B\rightarrow C})\circ f^{:A\rightarrow B}\quad.\label{eq:assoc-law-for-composition-with-types-backward}
\end{equation}

\end_inset

The associativity law allows us to omit parentheses in the expression 
\begin_inset Formula $h\circ g\circ f$
\end_inset

.
 
\end_layout

\begin_layout Standard
The length of calculations is the same in the forward and the backward notation.
 One difference is that types of function compositions are more visually
 clear in the forward notation: it is harder to check that types match in
 Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:assoc-law-for-composition-with-types-backward"
plural "false"
caps "false"
noprefix "false"

\end_inset

) than in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-law-for-function-composition-with-types"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To make the backward notation easier to work with, one could write
\begin_inset Foot
status open

\begin_layout Plain Layout
This is done in the book 
\begin_inset Quotes eld
\end_inset

Program design by calculation
\begin_inset Quotes erd
\end_inset

 by J.
\begin_inset space ~
\end_inset

N.
\begin_inset space ~
\end_inset

Oliveira where the backward composition is used exclusively, see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://www4.di.uminho.pt/~jno/ps/pdbc.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 the function types in reverse as, e.g., 
\begin_inset Formula $g^{:C\leftarrow B}\circ f^{:B\leftarrow A}$
\end_inset

.
\end_layout

\begin_layout Subsection
Example: A function that is 
\emph on
not
\emph default
 fully parametric
\end_layout

\begin_layout Standard
Fully parametric functions do not make any decisions based on the actual
 types of arguments.
 As an example of code that is 
\emph on
not
\emph default
 fully parametric, consider the following 
\begin_inset Quotes eld
\end_inset

fake identity
\begin_inset Quotes erd
\end_inset

 function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fid[A]: A => A = {
\end_layout

\begin_layout Plain Layout

  case x: Int   => (x - 1).asInstanceOf[A]     // Special code for A = Int.
\end_layout

\begin_layout Plain Layout

  case x        =>  x                          // Standard code for all
 other types A.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

This function's type signature is the same as that of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

, and its behavior is the same for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 except for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fid("abc")
\end_layout

\begin_layout Plain Layout

res0: String = abc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fid(true)
\end_layout

\begin_layout Plain Layout

res1: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> fid(0)
\end_layout

\begin_layout Plain Layout

res2: Int = -1
\end_layout

\end_inset

While Scala allows us to write this kind of code, the result is confusing:
 the type signature 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => A
\end_layout

\end_inset

 does not indicate a special behavior with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

.
 In any case, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fid
\end_layout

\end_inset

 is not a fully parametric function.
\end_layout

\begin_layout Standard
Let us see whether the identity laws of function composition hold when using
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fid[A]
\end_layout

\end_inset

 instead of the correct function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset

.
 To see that, we compose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fid
\end_layout

\end_inset

 with a simple function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f_1: Int => Int = { x => x + 1 }
\end_layout

\end_inset

The composition (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1 andThen fid
\end_layout

\end_inset

) has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, Scala will automatically set the type parameter 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A = Int
\end_layout

\end_inset

 in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fid[A]
\end_layout

\end_inset

:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

scala> def f_2 = f_1 andThen fid    // $
\backslash
color{dkgreen} f_{2}=f_{1}
\backslash
bef
\backslash
text{fid}$
\end_layout

\begin_layout Plain Layout

f_2: Int => Int
\end_layout

\end_inset

By the identity law, we should have 
\begin_inset Formula $f_{2}=f_{1}\bef\text{id}=f_{1}$
\end_inset

.
 But we can check that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f_2
\end_layout

\end_inset

 are not equal:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f_1(0)
\end_layout

\begin_layout Plain Layout

res3: Int = 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f_2(0)
\end_layout

\begin_layout Plain Layout

res4: Int = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is important that we are able to detect that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fid
\end_layout

\end_inset

 is not a fully parametric function by checking whether some equation holds,
 without looking at the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fid
\end_layout

\end_inset

.
 In this book, we will always formulate any desired properties through equations
 or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

.
 To verify that a law holds, we will perform symbolic calculations
\begin_inset Index idx
status open

\begin_layout Plain Layout
symbolic calculations
\end_layout

\end_inset

 similar to the proofs in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These calculations are 
\series bold
symbolic
\series default
 in the sense that we are manipulating symbols (such as 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

) without substituting any specific values for these symbols but only using
 some general rules and properties.
 This is similar to symbolic calculations in mathematics, such as 
\begin_inset Formula $\left(x-y\right)(x^{2}+xy+y^{2})=x^{3}-y^{3}$
\end_inset

.
 In the next section, we will get more experience with symbolic calculations
 relevant to functional programming.
\end_layout

\begin_layout Section
Symbolic calculations with nameless functions
\end_layout

\begin_layout Subsection
Calculations with curried functions
\end_layout

\begin_layout Standard
In mathematics, functions are evaluated by substituting their argument values
 into their body.
 Each sub-expression is then evaluated and its result substituted into the
 larger expression.
\end_layout

\begin_layout Standard
Nameless functions are evaluated in the same way.
 For example, applying the nameless function 
\begin_inset Formula $x\rightarrow x+10$
\end_inset

 to an integer 
\begin_inset Formula $2$
\end_inset

, we substitute 
\begin_inset Formula $2$
\end_inset

 instead of 
\begin_inset Formula $x$
\end_inset

 in â€œ
\begin_inset Formula $x+10$
\end_inset

â€ and get the sub-expression â€œ
\begin_inset Formula $2+10$
\end_inset

â€.
 Then we evaluate that sub-expression to 
\begin_inset Formula $12$
\end_inset

.
 The computation is written like this:
\begin_inset Formula 
\[
(x\rightarrow x+10)(2)=2+10=12\quad.
\]

\end_inset

To run this computation in Scala, we need to add a type annotation to the
 nameless function as in 
\begin_inset Formula $(x^{:\text{Int}}\rightarrow x+10)(2)$
\end_inset

.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x: Int) => x + 10)(2)
\end_layout

\begin_layout Plain Layout

res0: Int = 12 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Curried function calls such as 
\begin_inset Formula $f(x)(y)$
\end_inset

 or 
\begin_inset Formula $\left(x\rightarrow\text{expr}(x)\right)(y)(z)$
\end_inset

 may look unfamiliar and confusing.
 We need to get some experience working with them.
\end_layout

\begin_layout Standard
Consider the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => y => x - y)(20)(4)
\end_layout

\end_inset

, and begin with the curried argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

.
 Applying a nameless function of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x => ...)
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

 means substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 20
\end_layout

\end_inset

 into the body of the function.
 After that substitution, we obtain the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => 20 - y
\end_layout

\end_inset

, which is again a nameless function.
 Applying that function to the remaining argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(4)
\end_layout

\end_inset

 means substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = 4
\end_layout

\end_inset

 into the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y => 20 - y
\end_layout

\end_inset

.
 We get the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20 - 4
\end_layout

\end_inset

, which equals 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

16
\end_layout

\end_inset

.
 Test in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x: Int) => (y: Int) => x - y)(20)(4)
\end_layout

\begin_layout Plain Layout

res1: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applying a curried function such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => y => z => expr(x,y,z)
\end_layout

\end_inset

 to three curried arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

20
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

30
\end_layout

\end_inset

 means substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x = 10
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y = 20
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z = 30
\end_layout

\end_inset

 into the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr(x,y,z)
\end_layout

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this way, we can apply a curried function to several curried arguments.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This calculation is made easier by the convention that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h)
\end_layout

\end_inset

 means first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 and then applying the result to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

.
 In other words, function application groups to the 
\emph on
left
\emph default
: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h) = (f(g))(h)
\end_layout

\end_inset

.
 It would be confusing if function application grouped to the right and
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g)(h)
\end_layout

\end_inset

 meant first applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

h
\end_layout

\end_inset

 and then applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to the result.
 If 
\emph on
that
\emph default
 were the syntax convention, it would be harder to reason about applying
 a curried function to its arguments.
\end_layout

\begin_layout Standard
We see that the right grouping of the function arrow 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 is well adapted to the left grouping of function applications.
 All functional languages follow these syntactic conventions.
\end_layout

\begin_layout Standard
To make calculations shorter, we will write code in a mathematical notation
 rather than in the Scala syntax.
 Type annotations are written with a 
\emph on
colon
\emph default
 in the superscript.
 For example, 
\begin_inset Formula $x^{:\text{Int}}\rightarrow x+10$
\end_inset

 is the code notation corresponding to the Scala expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int) => x + 10
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The symbolic evaluation of the Scala code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((x: Int) => (y: Int) => x - y)(20)(4)
\end_layout

\end_inset

 can be written as:
\begin_inset Formula 
\begin{align*}
 & (\gunderline{x^{:\text{Int}}}\rightarrow y^{:\text{Int}}\rightarrow\gunderline x-y)\gunderline{\left(20\right)}\left(4\right)\\
\text{apply function and substitute }x=20:\quad & =(\gunderline{y^{:\text{Int}}}\rightarrow20-\gunderline y)\gunderline{\left(4\right)}\\
\text{apply function and substitute }y=4:\quad & =20-4=16\quad.
\end{align*}

\end_inset

In the above step-by-step calculation, the colored underlines and comments
 at left are added for clarity.
 A colored underline indicates a sub-expression that is going to be rewritten
 at the 
\emph on
next
\emph default
 step.
\end_layout

\begin_layout Standard
Here we performed calculations by substituting an argument into a function
 at each step.
 A compiled Scala program is evaluated in a similar way at run time.
\end_layout

\begin_layout Standard
Nameless functions are 
\emph on
values
\emph default
 and can be used as part of larger expressions, just as any other values.
 For instance, nameless functions can be arguments of other functions (nameless
 or not).
 Here is an example of applying a nameless function 
\begin_inset Formula $f\rightarrow f(9)$
\end_inset

 to the nameless function 
\begin_inset Formula $x\rightarrow x\%\,4$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & (f\rightarrow\gunderline f(9))\left(x\rightarrow x\%\,4\right)\\
\text{substitute }f=\left(x\rightarrow x\%\,4\right):\quad & =(x\rightarrow\gunderline x\%\,4)(9)\\
\text{substitute }x=9:\quad & =9\%\,4=1\quad.
\end{align*}

\end_inset

In the nameless function 
\begin_inset Formula $f\rightarrow f(9)$
\end_inset

, the argument 
\begin_inset Formula $f$
\end_inset

 has to be itself a function, otherwise the expression 
\begin_inset Formula $f(9)$
\end_inset

 would make no sense.
 The argument 
\begin_inset Formula $x$
\end_inset

 of 
\begin_inset Formula $f(x)$
\end_inset

 must be an integer, or else we would not be able to compute 
\begin_inset Formula $x\%\,4$
\end_inset

.
 The result of computing 
\begin_inset Formula $f(9)$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

, an integer.
 We conclude that 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}$
\end_inset

, or else the types do not match.
\end_layout

\begin_layout Standard
To verify this result in Scala, we need to specify a type annotation for
 
\begin_inset Formula $f$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((f: Int => Int) => f(9))(x => x % 4)
\end_layout

\begin_layout Plain Layout

res2: Int = 1
\end_layout

\end_inset

No type annotation is needed for 
\begin_inset Formula $x\rightarrow x\%\,4$
\end_inset

 because the Scala compiler already knows the type of 
\begin_inset Formula $f$
\end_inset

 and figures out that 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $x\rightarrow x\%\,4$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us summarize the syntax conventions for curried nameless functions:
\end_layout

\begin_layout Itemize
Function expressions group everything to the right: 
\begin_inset Formula $x\rightarrow y\rightarrow z\rightarrow e$
\end_inset

 means 
\begin_inset Formula $x\rightarrow\left(y\rightarrow\left(z\rightarrow e\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Function calls group everything to the left: 
\begin_inset Formula $f(x)(y)(z)$
\end_inset

 means 
\begin_inset Formula $\big((f(x))(y)\big)(z)$
\end_inset

.
 The expression 
\begin_inset Formula $f(x)$
\end_inset

 is a new function that is applied to 
\begin_inset Formula $y$
\end_inset

, giving again a new function that is finally applied to 
\begin_inset Formula $z$
\end_inset

.
\end_layout

\begin_layout Itemize
Function applications group stronger than infix operations, so 
\begin_inset Formula $f(x)+y$
\end_inset

 means 
\begin_inset Formula $(f(x))+y$
\end_inset

, as usual in mathematics, and not 
\begin_inset Formula $f(x+y)$
\end_inset

.
\end_layout

\begin_layout Standard
Here are some more examples of performing function applications symbolically.
 Types are omitted for brevity; every non-function value is of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default
:
\begin_inset Formula 
\begin{align*}
\left(x\rightarrow x*2\right)(10) & =10*2=20\quad.\\
\left(p\rightarrow z\rightarrow z*p\right)\left(t\right) & =(z\rightarrow z*t)\quad.\\
\left(p\rightarrow z\rightarrow z*p\right)(t)(4) & =(z\rightarrow z*t)(4)=4*t\quad.
\end{align*}

\end_inset

Some results of these computation are integer values such as 
\begin_inset Formula $20$
\end_inset

; other results are nameless functions such as 
\begin_inset Formula $z\rightarrow z*t$
\end_inset

.
 Verify this in Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((x: Int) => x * 2)(10)
\end_layout

\begin_layout Plain Layout

res3: Int = 20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ((p: Int) => (z: Int) => z * p)(10)
\end_layout

\begin_layout Plain Layout

res4: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> ((p: Int) => (z: Int) => z * p)(10)(4)
\end_layout

\begin_layout Plain Layout

res5: Int = 40 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the following examples, some arguments are themselves functions.
 Consider an expression that uses the nameless function 
\begin_inset Formula $\left(g\rightarrow g(2)\right)$
\end_inset

 as an argument:
\begin_inset Formula 
\begin{align}
 & (f\rightarrow p\rightarrow\gunderline f(p))\left(g\rightarrow g(2)\right)\label{eq:higher-order-functions-derivation0}\\
\text{substitute }f=\left(g\rightarrow g(2)\right):\quad & =p\rightarrow(g\rightarrow\gunderline g(2))\,(p)\nonumber \\
\text{substitute }g=p:\quad & =p\rightarrow p(2)\quad.\label{eq:higher-order-functions-derivation1}
\end{align}

\end_inset

The final result, 
\begin_inset Formula $p\rightarrow p(2)$
\end_inset

, cannot be simplified any more.
 
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $p\rightarrow p(2)$
\end_inset

 applies 
\emph on
its
\emph default
 argument (
\begin_inset Formula $p$
\end_inset

) to the value 
\begin_inset Formula $2$
\end_inset

.
 A possible value for 
\begin_inset Formula $p$
\end_inset

 is the function 
\begin_inset Formula $x\rightarrow x+4$
\end_inset

.
 Let us apply expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:higher-order-functions-derivation0"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to 
\begin_inset Formula $x\rightarrow x+4$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\left(f\rightarrow p\rightarrow f(p)\right)\left(g\rightarrow g(2)\right)}\left(x\rightarrow x+4\right)\\
\text{use Eq.~(\ref{eq:higher-order-functions-derivation1})}:\quad & =(p\rightarrow\gunderline p(2))\left(x\rightarrow x+4\right)\\
\text{substitute }p=\left(x\rightarrow x+4\right):\quad & =(x\rightarrow\gunderline x+4)\left(2\right)\\
\text{substitute }x=2:\quad & =2+4=6\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify this calculation in Scala, we need to add appropriate type annotations
 for 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

.
 To figure out the types, we reason like this:
\end_layout

\begin_layout Standard
We know that the function 
\begin_inset Formula $f\rightarrow p\rightarrow f(p)$
\end_inset

 is being applied to the arguments 
\begin_inset Formula $f=\left(g\rightarrow g(2)\right)$
\end_inset

 and 
\begin_inset Formula $p=\left(x\rightarrow x+4\right)$
\end_inset

.
 So, the argument 
\begin_inset Formula $f$
\end_inset

 in 
\begin_inset Formula $f\rightarrow p\rightarrow f(p)$
\end_inset

 must be a function that takes 
\begin_inset Formula $p$
\end_inset

 as an argument.
\end_layout

\begin_layout Standard
The variable 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $x\rightarrow x+4$
\end_inset

 must be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 So, the type of the expression 
\begin_inset Formula $x\rightarrow x+4$
\end_inset

 is 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}$
\end_inset

, and the type of the argument 
\begin_inset Formula $p$
\end_inset

 must be the same.
 We write 
\begin_inset Formula $p^{:\text{Int}\rightarrow\text{Int}}$
\end_inset

.
\end_layout

\begin_layout Standard
Finally, we need to make sure that the types match in the function 
\begin_inset Formula $f\rightarrow p\rightarrow f(p)$
\end_inset

.
 Types match in 
\begin_inset Formula $f(p)$
\end_inset

 if the type of 
\begin_inset Formula $f$
\end_inset

's argument is the same as the type of 
\begin_inset Formula $p$
\end_inset

, which is 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}$
\end_inset

.
 So, 
\begin_inset Formula $f$
\end_inset

's type must be 
\begin_inset Formula $\left(\text{Int}\rightarrow\text{Int}\right)\rightarrow A$
\end_inset

 for some type 
\begin_inset Formula $A$
\end_inset

.
 Since in our example 
\begin_inset Formula $f=\left(g\rightarrow g(2)\right)$
\end_inset

, types match only if 
\begin_inset Formula $g$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}$
\end_inset

.
 But then 
\begin_inset Formula $g(2)$
\end_inset

 has type 
\begin_inset Formula $\text{Int}$
\end_inset

, and so we must have 
\begin_inset Formula $A=\text{Int}$
\end_inset

.
 Thus, the type of 
\begin_inset Formula $f$
\end_inset

 is 
\begin_inset Formula $\left(\text{Int}\rightarrow\text{Int}\right)\rightarrow\text{Int}$
\end_inset

.
 We know enough to write the Scala code now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((f: (Int => Int) => Int) => p => f(p))(g => g(2))(x => x + 4)
\end_layout

\begin_layout Plain Layout

res6: Int = 6
\end_layout

\end_inset

Type annotations for 
\begin_inset Formula $p$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 may be omitted: Scala's compiler can figure out the missing types from
 the given type of 
\begin_inset Formula $f$
\end_inset

.
 However, extra type annotations often make code clearer.
\end_layout

\begin_layout Subsection
Examples: Deriving a function's type from its code
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Checking that the types match is an important part of the functional programming
 paradigm, both in the practice of writing code and in theoretical derivations
 of laws for various functions.
 For instance, in the derivations of the composition laws (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Laws-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we were able to deduce the possible type parameters for 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, and 
\begin_inset Formula $h$
\end_inset

 in the expression 
\begin_inset Formula $f\bef g\bef h$
\end_inset

.
 This worked because the composition operation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

 (denoted by the symbol 
\begin_inset Formula $\bef$
\end_inset

) is fully parametric.
 Given a fully parametric function, one can derive the most general type
 signature that matches the body of that function.
 The same type-deriving procedure may also help in converting a given function
 to a fully parametric form.
\end_layout

\begin_layout Standard
Let us look at some examples of doing this.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
The functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 were defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-of-fully-parametric"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 What is the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 and what is its type? Determine the most general type parameters in the
 expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to treat the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 as values, since our goal is to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Write the code of these functions in a short notation:
\begin_inset Formula 
\[
\text{const}^{C,X}\triangleq c^{:C}\rightarrow\_^{:X}\rightarrow c\quad,\quad\quad\text{id}^{A}\triangleq a^{:A}\rightarrow a\quad.
\]

\end_inset

The types will match in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 only if the argument of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 has the same type as the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 is a curried function, we need to look at its 
\emph on
first
\emph default
 curried argument, which is of type 
\begin_inset Formula $C$
\end_inset

.
 The type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 is 
\begin_inset Formula $A\rightarrow A$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is (so far) an arbitrary type.
 So, the type parameter 
\begin_inset Formula $C$
\end_inset

 in 
\begin_inset Formula $\text{const}^{C,X}$
\end_inset

 must be equal to 
\begin_inset Formula $A\rightarrow A$
\end_inset

:
\begin_inset Formula 
\[
C=A\rightarrow A\quad.
\]

\end_inset

 The type parameter 
\begin_inset Formula $X$
\end_inset

 in 
\begin_inset Formula $\text{const}^{C,X}$
\end_inset

 is not constrained, so we keep it as 
\begin_inset Formula $X$
\end_inset

.
 The result of applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 is of type 
\begin_inset Formula $X\rightarrow C$
\end_inset

, which equals 
\begin_inset Formula $X\rightarrow A\rightarrow A$
\end_inset

.
 In this way, we find:
\begin_inset Formula 
\[
\text{const}^{A\rightarrow A,X}(\text{id}^{A}):X\rightarrow A\rightarrow A\quad.
\]

\end_inset

The types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset

 remain arbitrary.
 The type 
\begin_inset Formula $X\rightarrow A\rightarrow A$
\end_inset

 is the most general type for the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

 because we have not made any assumptions about the types except requiring
 that all functions must be always applied to arguments of the correct types.
\end_layout

\begin_layout Standard
To compute the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(id)
\end_layout

\end_inset

, it remains to substitute the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

.
 Since we already checked the types, we may omit all type annotations:
\begin_inset Formula 
\begin{align*}
 & \gunderline{\text{const}}\left(\text{id}\right)\\
\text{definition of const}:\quad & =(c\rightarrow x\rightarrow\gunderline c)(\text{id})\\
\text{apply function, substitute }c=\text{id}:\quad & =x\rightarrow\gunderline{\text{id}}\\
\text{definition of }\text{id}:\quad & =x\rightarrow a\rightarrow a\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $\left(x\rightarrow a\rightarrow a\right)$
\end_inset

 takes an argument 
\begin_inset Formula $x^{:X}$
\end_inset

 and returns the identity function 
\begin_inset Formula $a^{:A}\rightarrow a$
\end_inset

.
 It is clear that the argument 
\begin_inset Formula $x$
\end_inset

 is ignored by this function.
 So, we can rewrite it equivalently as:
\begin_inset Formula 
\[
\text{const}\left(\text{id}\right)=\_^{:X}\rightarrow a^{:A}\rightarrow a\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 that takes a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Int
\end_layout

\end_inset

 as its argument and returns a function that applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 twice.
 For instance, if the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => x + 3 }
\end_layout

\end_inset

, the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(f)
\end_layout

\end_inset

 should be equal to the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x + 6
\end_layout

\end_inset

.
 Test this with the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(x => x + 3)(10)
\end_layout

\end_inset

.
 After implementing the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

, generalize it to a fully parametric function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
According to the requirements, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 must return a new function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

.
 So, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = ???
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(f)
\end_layout

\end_inset

 must be a new function with an integer argument, we begin the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 by writing a new nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ (x: Int) => ...
 }
\end_layout

\end_inset

,
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = { (x: Int) => ??? }
\end_layout

\end_inset

The new function must apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 twice to its argument, that is, it must return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(f(x))
\end_layout

\end_inset

.
 We can finish the implementation now:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice(f: Int => Int): Int => Int = { x => f(f(x)) }
\end_layout

\end_inset

The type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int)
\end_layout

\end_inset

 can be omitted.
 Let us verify that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(x => x+3)(10)
\end_layout

\end_inset

 equals 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10 + 6
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val g = twice(x => x + 3)  // Expect g to be equal to the function
 { x => x + 6 }.
\end_layout

\begin_layout Plain Layout

g: Int => Int = <function1>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> g(10)                      // Expect twice(x => x + 3)(10) to be
 equal to (x => x + 6)(10) = 16.
\end_layout

\begin_layout Plain Layout

res0: Int = 16
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To transform 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 into a fully parametric function means replacing its type signature by
 a fully parameterized type signature while keeping the function body unchanged:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice[A, B, ...](f: ...): ...
 = { x => f(f(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To determine the type signature and the possible type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, ..., we need to determine the most general type that matches the function
 body.
 The function body is the expression 
\begin_inset Formula $x\rightarrow f(f(x))$
\end_inset

.
 Assume that 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

; for types to match in the sub-expression 
\begin_inset Formula $f(x)$
\end_inset

, we need 
\begin_inset Formula $f$
\end_inset

 to have type 
\begin_inset Formula $A\rightarrow B$
\end_inset

 for some type 
\begin_inset Formula $B$
\end_inset

.
 The sub-expression 
\begin_inset Formula $f(x)$
\end_inset

 will then have type 
\begin_inset Formula $B$
\end_inset

.
 For types to match in 
\begin_inset Formula $f(f(x))$
\end_inset

, the argument of 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $B$
\end_inset

; but we already assumed 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 This is consistent only if 
\begin_inset Formula $A=B$
\end_inset

.
 In this way, 
\begin_inset Formula $x^{:A}$
\end_inset

 implies 
\begin_inset Formula $f^{:A\rightarrow A}$
\end_inset

, and the expression 
\begin_inset Formula $x\rightarrow f(f(x))$
\end_inset

 has type 
\begin_inset Formula $A\rightarrow A$
\end_inset

.
 We can now write the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def twice[A](f: A => A): A => A = { x => f(f(x)) }
\end_layout

\end_inset

This fully parametric function can be written in the code notation as:
\begin_inset Formula 
\begin{equation}
\text{twice}^{A}\triangleq f^{:A\rightarrow A}\rightarrow x^{:A}\rightarrow f(f(x))=f^{:A\rightarrow A}\rightarrow f\bef f\quad.\label{eq:hof-def-of-twice-in-math-notation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The procedure of deriving the most general type for a given code is called
 
\series bold
type inference
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type inference|textit
\end_layout

\end_inset

.
 In Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the presence of the type parameter 
\begin_inset Formula $A$
\end_inset

 and the type signature 
\begin_inset Formula $\left(A\rightarrow A\right)\rightarrow A\rightarrow A$
\end_inset

 have been 
\begin_inset Quotes eld
\end_inset

inferred
\begin_inset Quotes erd
\end_inset

 from the code 
\begin_inset Formula $f\rightarrow x\rightarrow f(f(x))$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 defined in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 What is the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, and what computation does it perform? Test your answer on the expression
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)(x => x + 3)(10)
\end_layout

\end_inset

.
 What are the type parameters in that expression?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Note that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 means that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 is used as 
\emph on
its own
\emph default
 argument, i.e., this is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(f)
\end_layout

\end_inset

 with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f = twice
\end_layout

\end_inset

.
 We begin by assuming unknown type parameters as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[A](twice[B])
\end_layout

\end_inset

.
 The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[A]
\end_layout

\end_inset

 of type 
\begin_inset Formula $\left(A\rightarrow A\right)\rightarrow A\rightarrow A$
\end_inset

 can be applied to the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[B]
\end_layout

\end_inset

 only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[B]
\end_layout

\end_inset

 has type 
\begin_inset Formula $A\rightarrow A$
\end_inset

.
 But 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[B]
\end_layout

\end_inset

 is of type 
\begin_inset Formula $\left(B\rightarrow B\right)\rightarrow B\rightarrow B$
\end_inset

.
 The symbol 
\begin_inset Formula $\rightarrow$
\end_inset

 groups to the right, so we have:
\begin_inset Formula 
\[
\left(B\rightarrow B\right)\rightarrow B\rightarrow B=\left(B\rightarrow B\right)\rightarrow\left(B\rightarrow B\right)\quad.
\]

\end_inset

This can match with 
\begin_inset Formula $A\rightarrow A$
\end_inset

 only if we set 
\begin_inset Formula $A=\left(B\rightarrow B\right)$
\end_inset

.
 So, the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 is:
\begin_inset Formula 
\begin{equation}
\text{twice}^{B\rightarrow B}(\text{twice}^{B}):\left(B\rightarrow B\right)\rightarrow B\rightarrow B\quad.\label{eq:hof-twice-example-solved3}
\end{equation}

\end_inset

After checking that types match, we may omit types from further calculations.
\end_layout

\begin_layout Standard
Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 defined 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 syntax.
 To use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as an argument in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, it is convenient to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 as a value, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val twice = ...
\end_layout

\end_inset

 However, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 needs type parameters, and Scala 2 does not directly support 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 definitions with type parameters.
 Scala 3 supports type parameters appearing together with arguments in a
 nameless function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val twice = [A] => (f: A => A) => (x: A) => f(f(x)) // Valid only in Scala
 3.
\end_layout

\end_inset

Keeping this in mind, we use the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:hof-def-of-twice-in-math-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

): 
\begin_inset Formula $\text{twice}\,(f)=f\bef f$
\end_inset

, which omits the curried argument 
\begin_inset Formula $x^{:A}$
\end_inset

 and makes the calculation shorter.
 Substituting that into 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

, we find:
\begin_inset Formula 
\begin{align*}
 & \text{twice}\,(\text{twice})=\text{twice}\bef\text{twice}\\
\text{expand function composition}:\quad & =f\rightarrow\text{twice}\,(\gunderline{\text{twice}}\,(f))\quad.\\
\text{definition of }\text{twice}\,(f):\quad & =f\rightarrow\gunderline{\text{twice}}\,(f\bef f)\\
\text{definition of twice}:\quad & =f\rightarrow f\bef f\bef f\bef f\quad.
\end{align*}

\end_inset

This clearly shows that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 is a function applying its (function-typed) argument 
\emph on
four
\emph default
 times.
\end_layout

\begin_layout Standard
The types in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)(x => x + 3)
\end_layout

\end_inset

 follow from Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:hof-twice-example-solved3"
plural "false"
caps "false"
noprefix "false"

\end_inset

): since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x + 3
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, types will match only if we set 
\begin_inset Formula $B=\text{Int}$
\end_inset

.
 The result is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice[Int => Int](twice[Int])
\end_layout

\end_inset

.
 To test, we need to write at least one type parameter in the code, or else
 Scala cannot correctly infer the types in 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> twice(twice[Int])(x => x + 3)(10) // Or write `twice[Int => Int](twice)(x
 => x + 3)(10)` .
\end_layout

\begin_layout Plain Layout

res0: Int = 22
\end_layout

\end_inset

This confirms that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)(x => x + 3)
\end_layout

\end_inset

 equals the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => x + 12
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Infer a general type signature with type parameter(s) for the given function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[...]:...
 = { f => f(2) }
\end_layout

\end_inset


\series bold
(b)
\series default
 Could we choose the type parameters in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

 such that the types match?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 In the nameless function 
\begin_inset Formula $f\rightarrow f(2)$
\end_inset

, the argument 
\begin_inset Formula $f$
\end_inset

 must be itself a function with an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, otherwise the sub-expression 
\begin_inset Formula $f(2)$
\end_inset

 is ill-typed.
 So, types will match if 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}$
\end_inset

 or 
\begin_inset Formula $\text{Int}\rightarrow\text{String}$
\end_inset

 or similar.
 The most general case is when 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\rightarrow A$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is an arbitrary type (i.e., a type parameter); then the value 
\begin_inset Formula $f(2)$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

.
 Since the nameless function 
\begin_inset Formula $f\rightarrow f(2)$
\end_inset

 has an argument 
\begin_inset Formula $f$
\end_inset

 of type 
\begin_inset Formula $\text{Int}\rightarrow A$
\end_inset

 and a result 
\begin_inset Formula $f(2)$
\end_inset

 of type 
\begin_inset Formula $A$
\end_inset

, we find that the type of 
\begin_inset Formula $p$
\end_inset

 must be 
\begin_inset Formula $\left(\text{Int}\rightarrow A\right)\rightarrow A$
\end_inset

.
 With this type assignment, all types match.
 The type parameter 
\begin_inset Formula $A$
\end_inset

 remains undetermined and is added to the type signature of the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

.
 The code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p[A]: (Int => A) => A = { f => f(2) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 The expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

 applies 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 to itself, just as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 did in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Begin by writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

 with unknown type parameters: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A](p[B])
\end_layout

\end_inset

.
 Then  try to choose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 so that the types match in that expression.
 Does the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[B]
\end_layout

\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => B) => B
\end_layout

\end_inset

, match the type of the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A]
\end_layout

\end_inset

, which is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

, with some choice of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

? A function type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P => Q
\end_layout

\end_inset

 matches 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X => Y
\end_layout

\end_inset

 only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

P = X
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Q = Y
\end_layout

\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => B) => B
\end_layout

\end_inset

 can match 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => A
\end_layout

\end_inset

 only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => B
\end_layout

\end_inset

 matches 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 and if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B = A
\end_layout

\end_inset

.
 But it is impossible for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => B
\end_layout

\end_inset

 to match 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, no matter how we choose 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We conclude that the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p[A](p[B])
\end_layout

\end_inset

 has a problem: for any choice of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, some type will be mismatched.
 One says that the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p(p)
\end_layout

\end_inset

 is 
\series bold
not well-typed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
well-typed expression
\end_layout

\end_inset

.
 Such expressions contain a type error and are rejected by the Scala compiler.
 
\begin_inset Formula $\square$
\end_inset


\end_layout

\begin_layout Standard
In the examples seen so far, we inferred the most general type of a code
 expression simply by trying to make all function types match the types
 of their arguments.
 The Damas-Hindley-Milner algorithm
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W"
target "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W"
literal "false"

\end_inset


\end_layout

\end_inset

 performs type inference
\begin_inset Index idx
status open

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

 (or determines that there is a type error) for any code containing functions,
 tuples, and disjunctive types.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Comments
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
a value or an argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:\text{Int}}\rightarrow x+1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: Int) => x + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
a nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f^{A,B}\triangleq...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f[A, B] = ...
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
a function with type parameters
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\text{id}^{A}$
\end_inset

, also 
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

identity[A]
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
the standard 
\begin_inset Quotes eld
\end_inset

identity
\begin_inset Quotes erd
\end_inset

 function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $A\rightarrow B\rightarrow C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
the type of a curried function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f\bef g$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
forward composition of functions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $g\circ f$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

g compose f
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
backward composition of functions
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Some notation for symbolic reasoning about code.
\begin_inset CommandInset label
LatexCommand label
name "tab:Mathematical-notation-for-code"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Mathematical-notation-for-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the notations introduced in this chapter.
 
\end_layout

\begin_layout Standard
What can we do using this chapter's techniques?
\end_layout

\begin_layout Itemize
Make functions that return new functions and/or take functions as arguments.
\end_layout

\begin_layout Itemize
Simplify expressions symbolically when functions are applied to arguments.
\end_layout

\begin_layout Itemize
Derive a general type for a given code expression (perform type inference).
\end_layout

\begin_layout Itemize
Convert functions to a fully parametric form when possible.
\end_layout

\begin_layout Standard
The following examples and exercises illustrate these techniques further.
\end_layout

\begin_layout Subsection
Examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
examples (with code)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function that applies a given function 
\begin_inset Formula $f$
\end_inset

 repeatedly to an initial value 
\begin_inset Formula $x_{0}$
\end_inset

, until a given function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cond
\end_layout

\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def converge[X](f: X => X, x0: X, cond: X => Boolean): X = ???
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

find
\end_layout

\end_inset

 on an iterator that keeps applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

; this stops when the condition is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def converge[X](f: X => X, x0: X, cond: X => Boolean): X = 
\end_layout

\begin_layout Plain Layout

  Stream.iterate(x0)(f)   // Type is Stream[X].
\end_layout

\begin_layout Plain Layout

  .find(cond)             // Type is Option[X].
\end_layout

\begin_layout Plain Layout

  .get                    // Type is X.
\end_layout

\end_inset

The method 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 is a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial function
\end_layout

\end_inset

partial function that can be applied only to non-empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 values.
 It is safe to call 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get
\end_layout

\end_inset

 here, because the stream is unbounded and, if the condition 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cond
\end_layout

\end_inset

 never becomes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, the program will run out of memory (since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Stream.iterate
\end_layout

\end_inset

 keeps all computed values in memory) or the user will run out of patience.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

_.find(cond)
\end_layout

\end_inset

 can never return an empty 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option
\end_layout

\end_inset

 value.
 Of course, it is not satisfactory that the program crashes when the sequence
 does not converge.
 Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-8"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will implement a safer version of this function by limiting the allowed
 number of iterations.
\end_layout

\begin_layout Standard
A tail-recursive implementation that works in constant memory is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def converge[X](f: X => X, x0: X, cond: X => Boolean): X =
\end_layout

\begin_layout Plain Layout

  if (cond(x0)) x0 else converge(f, f(x0), cond)
\end_layout

\end_inset

To test this code, compute an approximation to 
\begin_inset Formula $\sqrt{q}\,$
\end_inset

 by Newton's method
\begin_inset Index idx
status open

\begin_layout Plain Layout
Newton's method
\end_layout

\end_inset

 with the iteration function 
\begin_inset Formula $f(x)=\frac{1}{2}\left(x+\frac{q}{x}\right)$
\end_inset

.
 We iterate 
\begin_inset Formula $f(x)$
\end_inset

 starting with 
\begin_inset Formula $x_{0}=q/2$
\end_inset

 until a given precision is obtained:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def approx_sqrt(q: Double, precision: Double): Double = {
\end_layout

\begin_layout Plain Layout

      def cond(x: Double): Boolean = math.abs(x * x - q) <= precision
\end_layout

\begin_layout Plain Layout

      def iterate_sqrt(x: Double): Double = 0.5 * (x + q / x)
\end_layout

\begin_layout Plain Layout

      converge(iterate_sqrt, q / 2, cond)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Newton's method for 
\begin_inset Formula $\sqrt{q}\,$
\end_inset

 is guaranteed to converge when 
\begin_inset Formula $q\geq0$
\end_inset

.
 Test it:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> approx_sqrt(25, 1.0e-8)
\end_layout

\begin_layout Plain Layout

res0: Double = 5.000000000016778
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using both 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, define a Scala function that takes an integer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and returns a function that adds 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to 
\emph on
its
\emph default
 argument.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Let us first write down the required type signature.
 The function must take an integer argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: Int
\end_layout

\end_inset

, and the return value must be a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add_x(x: Int): Int => Int = ???
\end_layout

\end_inset

We are required to return a function that adds 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to its argument.
 Let us call that argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

, to avoid confusion with the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 So, we are required to return the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ z => z + x }
\end_layout

\end_inset

.
 Since functions are values, we return a new function by writing a nameless
 function expression:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def add_x(x: Int): Int => Int = { z => z + x }
\end_layout

\end_inset

To implement the same function by using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, we first convert the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x
\end_layout

\end_inset

 to the equivalent curried type 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}\rightarrow\text{Int}$
\end_inset

.
 Now we can write the Scala code of a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x_v
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val add_x_v: Int => Int => Int = { x => z => z + x }
\end_layout

\end_inset

The function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x_v
\end_layout

\end_inset

 is equal to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x
\end_layout

\end_inset

 except for using the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 syntax instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

.
 We do not need to write the type of the arguments 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 since we already wrote the type 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}\rightarrow\text{Int}$
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add_x_v
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, implement a curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

 that takes a function 
\begin_inset Formula $f$
\end_inset

 and an integer 
\begin_inset Formula $x$
\end_inset

, and returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 when 
\begin_inset Formula $f(x)$
\end_inset

 is prime.
 Use the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

 from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Nameless-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
First, determine the required type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

.
 The value 
\begin_inset Formula $f(x)$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, or else we cannot check whether it is prime.
 So, 
\begin_inset Formula $f$
\end_inset

 must have type 
\begin_inset Formula $\text{Int}\rightarrow\text{Int}$
\end_inset

.
 Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

 should be a curried function, we need to put each argument into its own
 set of parentheses:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prime_f(f: Int => Int)(x: Int): Boolean = ???
\end_layout

\end_inset

To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

, we need to return the result of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

 applied to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
 A simple solution is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def prime_f(f: Int => Int)(x: Int): Boolean = isPrime(f(x))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To implement the same function using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

, rewrite its type signature as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = ???
\end_layout

\end_inset

(The parentheses around 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

 are mandatory as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int => Boolean
\end_layout

\end_inset

 would be a completely different type.) The implementation is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = { f => x => isPrime(f(x))
 }
\end_layout

\end_inset

The code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime(f(x))
\end_layout

\end_inset

 is a forward composition of the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

, so we can write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = (f => f andThen isPrime)
\end_layout

\end_inset

A nameless function of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f => f.something
\end_layout

\end_inset

 is equivalent to a shorter Scala syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(_.something)
\end_layout

\end_inset

.
 We finally rewrite the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

prime_f
\end_layout

\end_inset

 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val prime_f: (Int => Int) => Int => Boolean = (_ andThen isPrime)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-simple-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice(x, p, f, g)
\end_layout

\end_inset

 that takes a value 
\begin_inset Formula $x$
\end_inset

, a predicate 
\begin_inset Formula $p$
\end_inset

, and two functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 The return value must be 
\begin_inset Formula $f(x)$
\end_inset

 if 
\begin_inset Formula $p(x)$
\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

; otherwise the return value must be 
\begin_inset Formula $g(x)$
\end_inset

.
 Infer the most general type for this function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The code of this function must be:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def choice[...](x, p, f, g) = if (p(x)) f(x) else g(x)
\end_layout

\end_inset

To infer the most general type for this code, begin by assuming that 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is a type parameter.
 Then the predicate 
\begin_inset Formula $p$
\end_inset

 must have type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Boolean
\end_layout

\end_inset

.
 Since 
\begin_inset Formula $p$
\end_inset

 is an arbitrary predicate, the value 
\begin_inset Formula $p(x)$
\end_inset

 will be sometimes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 and sometimes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice(x, p, f, g)
\end_layout

\end_inset

 will sometimes compute 
\begin_inset Formula $f(x)$
\end_inset

 and sometimes 
\begin_inset Formula $g(x)$
\end_inset

.
 It follows that type 
\begin_inset Formula $A$
\end_inset

 must be the argument type of both 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

, which means that the most general types so far are 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:A\rightarrow C}$
\end_inset

, yielding the type signature:
\begin_inset Formula 
\[
\text{choice}(x^{:A},p^{:A\rightarrow\text{Boolean}},f^{:A\rightarrow B},g^{:A\rightarrow C})\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
What could be the return type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice(x, p, f, g)
\end_layout

\end_inset

? If 
\begin_inset Formula $p(x)$
\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 returns 
\begin_inset Formula $f(x)$
\end_inset

, which is of type 
\begin_inset Formula $B$
\end_inset

.
 Otherwise, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 returns 
\begin_inset Formula $g(x)$
\end_inset

, which is of type 
\begin_inset Formula $C$
\end_inset

.
 However, the type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 must be fixed in advance (at compile time) and cannot depend on the value
 
\begin_inset Formula $p(x)$
\end_inset

 computed at run time.
 So, the types of 
\begin_inset Formula $f(x)$
\end_inset

 and of 
\begin_inset Formula $g(x)$
\end_inset

 must be the same, 
\begin_inset Formula $B=C$
\end_inset

.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

choice
\end_layout

\end_inset

 will thus have only two type parameters, 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def choice[A, B](x: A, p: A => Boolean, f: A => B, g: A => B): B =
\end_layout

\begin_layout Plain Layout

  if (p(x)) f(x) else g(x)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-derive-types-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer the most general type for the fully parametric function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[...]: ...
 = { f => g => g(f) }
\end_layout

\end_inset

What types are inferred for the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

?
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To begin, assume 
\begin_inset Formula $f^{:A}$
\end_inset

 with a type parameter 
\begin_inset Formula $A$
\end_inset

.
 In the sub-expression 
\begin_inset Formula $g\rightarrow g(f)$
\end_inset

, the curried argument 
\begin_inset Formula $g$
\end_inset

 must itself be a function, because it is being applied to 
\begin_inset Formula $f$
\end_inset

 as 
\begin_inset Formula $g(f)$
\end_inset

.
 So, we assign types as 
\begin_inset Formula $f^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(f)$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are type parameters.
 Then the final returned value 
\begin_inset Formula $g(f)$
\end_inset

 has type 
\begin_inset Formula $B$
\end_inset

.
 Since there are no other constraints on the types, the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 remain arbitrary, so we add them to the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To match types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

, we first assume arbitrary type parameters and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B](q[C, D])
\end_layout

\end_inset

.
 We need to introduce new type parameters 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

 because those type parameters may need to be set differently from 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 when we try to match the types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The type of the first curried argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B]
\end_layout

\end_inset

, which is 
\begin_inset Formula $A$
\end_inset

, must match the entire type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[C, D]
\end_layout

\end_inset

, which is 
\begin_inset Formula $C\rightarrow\left(C\rightarrow D\right)\rightarrow D$
\end_inset

.
 So, we must choose 
\begin_inset Formula $A$
\end_inset

 as:
\begin_inset Formula 
\[
A=C\rightarrow\left(C\rightarrow D\right)\rightarrow D\quad.
\]

\end_inset

The type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 becomes:
\begin_inset Formula 
\begin{align*}
q^{A,B}(q^{C,D}) & :\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\quad,\\
 & \quad\text{where}\quad A=C\rightarrow\left(C\rightarrow D\right)\rightarrow D\quad.
\end{align*}

\end_inset

There are no other constraints on the type parameters 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Standard
We use this result to infer the most general type for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

.
 Denote 
\begin_inset Formula $r\triangleq q(q)$
\end_inset

 for brevity; then, as we just found, 
\begin_inset Formula $r$
\end_inset

 has type 
\begin_inset Formula $\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B$
\end_inset

.
 To infer types in the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(r)
\end_layout

\end_inset

, we introduce new type parameters 
\begin_inset Formula $E$
\end_inset

, 
\begin_inset Formula $F$
\end_inset

 and write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[E, F](r)
\end_layout

\end_inset

.
 The type of the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[E, F]
\end_layout

\end_inset

 is 
\begin_inset Formula $E$
\end_inset

, and this must be the same as the type of 
\begin_inset Formula $r$
\end_inset

.
 This gives the constraint:
\begin_inset Formula 
\[
E=\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\quad.
\]

\end_inset

Other than that, the type parameters are arbitrary.
 The type of the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 is 
\begin_inset Formula $\left(E\rightarrow F\right)\rightarrow F$
\end_inset

.
 We conclude that the most general type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 is:
\begin_inset Formula 
\begin{align*}
q^{E,F}(q^{A,B}(q^{C,D})) & :\left(\left(\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\right)\rightarrow F\right)\rightarrow F\quad,\\
\text{where}\quad & A=C\rightarrow\left(C\rightarrow D\right)\rightarrow D\\
\text{and}\quad & E=\left(\left(C\rightarrow\left(C\rightarrow D\right)\rightarrow D\right)\rightarrow B\right)\rightarrow B\quad.
\end{align*}

\end_inset

It is clear from this derivation that expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q(q)))
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q(q(q))))
\end_layout

\end_inset

, etc., are well-typed.
\end_layout

\begin_layout Standard
Let us test these results in Scala, renaming the type parameters for clarity
 to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

D
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def qq[A, B, C]: ((A => (A => B) => B) => C) => C = q(q)
\end_layout

\begin_layout Plain Layout

qq: [A, B, C]=> ((A => ((A => B) => B)) => C) => C
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> def qqq[A, B, C, D]: ((((A => (A => B) => B) => C) => C) => D) =>
 D = q(q(q))
\end_layout

\begin_layout Plain Layout

qqq: [A, B, C, D]=> ((((A => ((A => B) => B)) => C) => C) => D) => D
\end_layout

\end_inset

We did not need to write any type parameters within the expressions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q(q(q))
\end_layout

\end_inset

 because the full type signature was declared for each of these expressions.
 Since the Scala compiler did not print any error messages, we are assured
 that the types match correctly.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-not-typeable"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-not-typeable"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the following expressions, infer the most general types or show that
 the expression is not well-typed with simple types:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $f\rightarrow f(f)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $f\rightarrow f(h\rightarrow h(f))\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $f\rightarrow g\rightarrow f(h\rightarrow h(g))\quad.$
\end_inset


\end_layout

\begin_layout Standard
By 
\begin_inset Quotes eld
\end_inset

simple types
\begin_inset Quotes erd
\end_inset

 we mean that 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

 cannot have 
\emph on
their own
\emph default
 type parameters.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 The type of 
\begin_inset Formula $f$
\end_inset

 is unknown, so we begin by assigning an arbitrary type 
\begin_inset Formula $A$
\end_inset

 to it.
 Types now need to match in the expression 
\begin_inset Formula $f(f)$
\end_inset

 with 
\begin_inset Formula $f^{:A}$
\end_inset

.
 So, the type 
\begin_inset Formula $A$
\end_inset

 must be a function type whose argument is again of type 
\begin_inset Formula $A$
\end_inset

.
 We can write that function type as 
\begin_inset Formula $A\rightarrow B$
\end_inset

, where 
\begin_inset Formula $B$
\end_inset

 is another arbitrary type.
 Now, types match only if 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $A\rightarrow B$
\end_inset

 is the same type.
 But there are no simple types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 such that 
\begin_inset Formula $A=A\rightarrow B$
\end_inset

.
 So, the expression 
\begin_inset Formula $f\rightarrow f(f)$
\end_inset

 is not well-typed.
\end_layout

\begin_layout Standard
This conclusion holds only because we do not allow the function 
\begin_inset Formula $f$
\end_inset

 to have its own type parameters.
 Otherwise, the expression 
\begin_inset Formula $f(f)$
\end_inset

 could be well-typed.
 See, for instance, Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showing that the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)
\end_layout

\end_inset

 is well-typed.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 Begin by assigning type parameters as 
\begin_inset Formula $f^{:A}$
\end_inset

 and 
\begin_inset Formula $h^{:B}$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are unknown.
 To match types in 
\begin_inset Formula $h(f)$
\end_inset

, the type of 
\begin_inset Formula $h$
\end_inset

 must be a function type with an argument of type 
\begin_inset Formula $A$
\end_inset

.
 So, we must have 
\begin_inset Formula $B=A\rightarrow C$
\end_inset

, where 
\begin_inset Formula $C$
\end_inset

 is unknown.
 Then 
\begin_inset Formula $h(f)$
\end_inset

 has type 
\begin_inset Formula $C$
\end_inset

, and 
\begin_inset Formula $h\rightarrow h(f)$
\end_inset

 has type 
\begin_inset Formula $(A\rightarrow C)\rightarrow C$
\end_inset

.
 This is the type of an argument of 
\begin_inset Formula $f$
\end_inset

, so 
\begin_inset Formula $A=((A\rightarrow C)\rightarrow C)\rightarrow D$
\end_inset

, where 
\begin_inset Formula $D$
\end_inset

 is unknown.
 But we cannot have a simple type 
\begin_inset Formula $A$
\end_inset

 that satisfies the type equation 
\begin_inset Formula $A=((A\rightarrow C)\rightarrow C)\rightarrow D$
\end_inset

.
 We conclude that the expression 
\begin_inset Formula $f\rightarrow f(h\rightarrow h(f))$
\end_inset

 is not well-typed.
 
\end_layout

\begin_layout Standard

\series bold
(c) 
\series default
Begin by assigning type parameters as 
\begin_inset Formula $f^{:A}$
\end_inset

, 
\begin_inset Formula $g^{:B}$
\end_inset

, 
\begin_inset Formula $h^{:C}$
\end_inset

.
 To match types in 
\begin_inset Formula $h(g)$
\end_inset

, we must have 
\begin_inset Formula $C=B\rightarrow D$
\end_inset

.
 Then 
\begin_inset Formula $h\rightarrow h(f)$
\end_inset

 has type 
\begin_inset Formula $C\rightarrow D$
\end_inset

, and that must be the type of 
\begin_inset Formula $f$
\end_inset

's argument.
 So, we must have: 
\begin_inset Formula 
\[
A=(C\rightarrow D)\rightarrow E=((B\rightarrow D)\rightarrow D)\rightarrow E\quad.
\]

\end_inset

There are no other restrictions.
 We have found the most general type:
\begin_inset Formula 
\[
\big(f^{:((B\rightarrow D)\rightarrow D)\rightarrow E}\rightarrow g^{:B}\rightarrow f(h^{:B\rightarrow D}\rightarrow h(g))\big):(((B\rightarrow D)\rightarrow D)\rightarrow E)\rightarrow B\rightarrow E\quad.
\]

\end_inset

The type parameters 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

 remain arbitrary.
 
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-curried"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-curried"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types in the code expression:
\begin_inset Formula 
\[
\left(f\rightarrow g\rightarrow g(f)\right)\left(f\rightarrow g\rightarrow g(f)\right)\left(f\rightarrow f(10)\right)\quad,
\]

\end_inset

and simplify the code through symbolic calculations.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The given expression is a curried function 
\begin_inset Formula $f\rightarrow g\rightarrow g(f)$
\end_inset

 applied to two curried arguments.
 The plan is to consider each of these sub-expressions in turn, assigning
 types for them using type parameters, and then to figure out how to set
 the type parameters so that all types match.
\end_layout

\begin_layout Standard
Begin by renaming the shadowed variables (
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

) to remove shadowing:
\begin_inset Formula 
\begin{equation}
\left(f\rightarrow g\rightarrow g(f)\right)\left(x\rightarrow y\rightarrow y(x)\right)\left(h\rightarrow h(10)\right)\quad.\label{eq:example-hof-curried-function-solved1}
\end{equation}

\end_inset

 As we have seen in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the sub-expression 
\begin_inset Formula $f\rightarrow g\rightarrow g(f)$
\end_inset

 is typed as 
\begin_inset Formula $f^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(f)$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are some type parameters.
 The sub-expression 
\begin_inset Formula $x\rightarrow y\rightarrow y(x)$
\end_inset

 is the same function as 
\begin_inset Formula $f\rightarrow g\rightarrow g(f)$
\end_inset

 but with possibly different type parameters, say, 
\begin_inset Formula $x^{:C}\rightarrow y^{:C\rightarrow D}\rightarrow y(x)$
\end_inset

.
 The types 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

 are so far unknown.
\end_layout

\begin_layout Standard
Finally, the variable 
\begin_inset Formula $h$
\end_inset

 in the sub-expression 
\begin_inset Formula $h\rightarrow h(10)$
\end_inset

 must have type 
\begin_inset Formula $\text{Int}\rightarrow E$
\end_inset

, where 
\begin_inset Formula $E$
\end_inset

 is another type parameter.
 So, the sub-expression 
\begin_inset Formula $h\rightarrow h(10)$
\end_inset

 is a function of type 
\begin_inset Formula $\left(\text{Int}\rightarrow E\right)\rightarrow E$
\end_inset

.
\end_layout

\begin_layout Standard
The types must match in the entire expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved1"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset Formula 
\begin{equation}
(f^{:A}\rightarrow g^{:A\rightarrow B}\rightarrow g(f))(x^{:C}\rightarrow y^{:C\rightarrow D}\rightarrow y(x))(h^{:\text{Int}\rightarrow E}\rightarrow h(10))\quad.\label{eq:example-hof-curried-function-solved2}
\end{equation}

\end_inset

It follows that 
\begin_inset Formula $f$
\end_inset

 must have the same type as 
\begin_inset Formula $x\rightarrow y\rightarrow y(x)$
\end_inset

, while 
\begin_inset Formula $g$
\end_inset

 must have the same type as 
\begin_inset Formula $h\rightarrow h(10)$
\end_inset

.
 The type of 
\begin_inset Formula $g$
\end_inset

, which we know as 
\begin_inset Formula $A\rightarrow B$
\end_inset

, will match the type of 
\begin_inset Formula $h\rightarrow h(10)$
\end_inset

, which we know as 
\begin_inset Formula $\left(\text{Int}\rightarrow E\right)\rightarrow E$
\end_inset

, only if 
\begin_inset Formula $A=\left(\text{Int}\rightarrow E\right)$
\end_inset

 and 
\begin_inset Formula $B=E$
\end_inset

.
 It follows that 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $\text{Int}\rightarrow E$
\end_inset

.
 At the same time, the type of 
\begin_inset Formula $f$
\end_inset

 must match the type of 
\begin_inset Formula $x\rightarrow y\rightarrow y(x)$
\end_inset

, which is 
\begin_inset Formula $C\rightarrow(C\rightarrow D)\rightarrow D$
\end_inset

.
 This can work only if 
\begin_inset Formula $C=\text{Int}$
\end_inset

 and 
\begin_inset Formula $E=(C\rightarrow D)\rightarrow D=(\text{Int}\rightarrow D)\rightarrow D$
\end_inset

.
\end_layout

\begin_layout Standard
In this way, we have found all the relationships between the type parameters
 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

 in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The type 
\begin_inset Formula $D$
\end_inset

 remains arbitrary, while the type parameters 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

 are expressed as:
\begin_inset Formula 
\begin{align}
A & =\text{Int}\rightarrow\left(\text{Int}\rightarrow D\right)\rightarrow D\quad,\label{eq:example-hof-curried-solved3}\\
B & =E=\left(\text{Int}\rightarrow D\right)\rightarrow D\quad,\label{eq:example-hof-curried-solved4}\\
C & =\text{Int}\quad.\nonumber 
\end{align}

\end_inset

The entire expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is a full application of a curried function, and thus has the same type
 as the 
\begin_inset Quotes eld
\end_inset

final
\begin_inset Quotes erd
\end_inset

 result expression 
\begin_inset Formula $g(f)$
\end_inset

, which has type 
\begin_inset Formula $B$
\end_inset

.
 So, the entire expression in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

) has type 
\begin_inset Formula $B=\left(\text{Int}\rightarrow D\right)\rightarrow D$
\end_inset

.
\end_layout

\begin_layout Standard
Having established that types match, we can now omit the type annotations
 and rewrite the code:
\begin_inset Formula 
\begin{align*}
 & (\gunderline f\rightarrow g\rightarrow g(\gunderline f))\gunderline{\left(x\rightarrow y\rightarrow y(x)\right)}\left(h\rightarrow h(10)\right)\\
\text{substitute }f=x\rightarrow y\rightarrow y(x):\quad & =\big(\gunderline g\rightarrow\gunderline g(x\rightarrow y\rightarrow y(x))\big)\gunderline{\left(h\rightarrow h(10)\right)}\\
\text{substitute }g=h\rightarrow h(10):\quad & =(\gunderline h\rightarrow\gunderline h(10))\gunderline{\left(x\rightarrow y\rightarrow y(x)\right)}\\
\text{substitute }h=x\rightarrow y\rightarrow y(x):\quad & =(\gunderline x\rightarrow y\rightarrow y(\gunderline x))\gunderline{(10)}\\
\text{substitute }x=10:\quad & =y\rightarrow y(10)\quad.
\end{align*}

\end_inset

The type of this expression is 
\begin_inset Formula $\left(\text{Int}\rightarrow D\right)\rightarrow D$
\end_inset

 with a type parameter 
\begin_inset Formula $D$
\end_inset

.
 Since the argument 
\begin_inset Formula $y$
\end_inset

 is an arbitrary function, we cannot simplify either 
\begin_inset Formula $y(10)$
\end_inset

 or 
\begin_inset Formula $y\rightarrow y(10)$
\end_inset

 any further.
 So, the final simplified form of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is 
\begin_inset Formula $y^{:\text{Int}\rightarrow D}\rightarrow y(10)$
\end_inset

.
\end_layout

\begin_layout Standard
To test this, we first define the function 
\begin_inset Formula $f\rightarrow g\rightarrow g(f)$
\end_inset

 as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-5"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def q[A, B]: A => (A => B) => B = { f => g => g(f) }
\end_layout

\end_inset

We also define the function 
\begin_inset Formula $h\rightarrow h(10)$
\end_inset

 with a general type 
\begin_inset Formula $\left(\text{Int}\rightarrow E\right)\rightarrow E$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def r[E]: (Int => E) => E = { h => h(10) }
\end_layout

\end_inset

To help Scala evaluate Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-function-solved2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to set the type parameters for the first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q
\end_layout

\end_inset

 function as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

q[A, B]
\end_layout

\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are given by Eqs.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-solved3"
plural "false"
caps "false"
noprefix "false"

\end_inset

)â€“(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:example-hof-curried-solved4"
plural "false"
caps "false"
noprefix "false"

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def s[D] = q[Int => (Int => D) => D, (Int => D) => D](q)(r)
\end_layout

\begin_layout Plain Layout

s: [D]=> (Int => D) => D
\end_layout

\end_inset

To verify that the function 
\begin_inset Formula $s^{D}$
\end_inset

 indeed equals 
\begin_inset Formula $y^{:\text{Int}\rightarrow D}\rightarrow y(10)$
\end_inset

, we apply 
\begin_inset Formula $s^{D}$
\end_inset

 to some functions of type 
\begin_inset Formula $\text{Int}\rightarrow D$
\end_inset

, say, with 
\begin_inset Formula $D=\text{Boolean}$
\end_inset

 or 
\begin_inset Formula $D=\text{Int}$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> s(_ > 0)  // Set D = Boolean and evaluate (10 > 0).
\end_layout

\begin_layout Plain Layout

res6: Boolean = true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> s(_ + 20) // Set D = Int and evaluate (10 + 20).
\end_layout

\begin_layout Plain Layout

res7: Int = 30
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute 
\begin_inset Formula $\left(x\rightarrow y\rightarrow x(x(y))\right)\bef\left(p\rightarrow p(2)\right)\bef\left(z\rightarrow z+3\right)$
\end_inset

 symbolically and infer types.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
The forward composition 
\begin_inset Formula $f\bef g$
\end_inset

 substitutes the 
\emph on
body
\emph default
 of 
\begin_inset Formula $f$
\end_inset

 into the argument of 
\begin_inset Formula $g$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{substitute }y=f(x):\quad & (x\rightarrow f(x))\bef(\gunderline y\rightarrow\gunderline{g(y)})=\left(x\rightarrow g(f(x))\right)\quad.
\end{align*}

\end_inset

Here, we substituted 
\begin_inset Formula $f(x)$
\end_inset

 instead of 
\begin_inset Formula $y$
\end_inset

 in 
\begin_inset Formula $g(y)$
\end_inset

 and obtained 
\begin_inset Formula $g(f(x))$
\end_inset

.
 This shows how to compute the forward compositions left to right:
\begin_inset Formula 
\begin{align*}
 & \left(x\rightarrow y\rightarrow x(x(y))\right)\bef(p\rightarrow p(2))=x\rightarrow(y\rightarrow x(x(y)))(2)=x\rightarrow x(x(2))\quad.\\
 & \left(x\rightarrow x(x(2))\right)\bef\left(z\rightarrow z+3\right)=x\rightarrow x(x(2))+3\quad.
\end{align*}

\end_inset

Computing the pairwise combinations in another order, we get the same result:
\begin_inset Formula 
\begin{align*}
\text{first compute}:\quad & \left(p\rightarrow p(2)\right)\bef\left(z\rightarrow z+3\right)=p\rightarrow p(2)+3\quad.\\
\text{then compute}:\quad & \left(x\rightarrow y\rightarrow x(x(y))\right)\bef\left(p\rightarrow p(2)+3\right)\\
 & \quad=x\rightarrow\left(y\rightarrow x(x(y))\right)(2)+3\\
 & \quad=x\rightarrow x(x(2))+3\quad.
\end{align*}

\end_inset

This is to be expected due to the associativity law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:associativity-of-function-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Types are inferred as: 
\begin_inset Formula 
\[
\left(x\rightarrow y\rightarrow x(x(y))\right)^{:(\text{Int}\rightarrow\text{Int})\rightarrow(\text{Int}\rightarrow\text{Int})}\bef\left(p\rightarrow p(2)\right)^{:(\text{Int}\rightarrow\text{Int})\rightarrow\text{Int}}\bef\left(z\rightarrow z+3\right)^{:\text{Int}\rightarrow\text{Int}}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-hof-const-function"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-const-function"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
We are given a function 
\begin_inset Formula $q^{:A\rightarrow A}$
\end_inset

, and we only know that for any 
\begin_inset Formula $f^{:A\rightarrow A}$
\end_inset

 the law 
\begin_inset Formula $f\bef q=q\bef f$
\end_inset

 holds (i.e., 
\begin_inset Formula $q$
\end_inset

 commutes with every function).
 Show that 
\begin_inset Formula $q$
\end_inset

 must be an identity function.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Since the law must hold for any 
\begin_inset Formula $f$
\end_inset

, we may choose 
\begin_inset Formula $f$
\end_inset

 at will.
 Let us fix a value 
\begin_inset Formula $z^{:A}$
\end_inset

 and choose 
\begin_inset Formula $f\triangleq\_\rightarrow z$
\end_inset

, that is, a constant function returning 
\begin_inset Formula $z$
\end_inset

.
 Applying both sides of the law 
\begin_inset Formula $f\bef q=q\bef f$
\end_inset

 to an arbitrary 
\begin_inset Formula $x^{:A}$
\end_inset

, we get:
\begin_inset Formula 
\[
(f\bef q)(x)=q(f(x))=q(z)\quad,\quad\quad(q\bef f)(x)=f(q(x))=z\quad.
\]

\end_inset

It follows that 
\begin_inset Formula $q(z)=z$
\end_inset

 for any chosen 
\begin_inset Formula $z^{:A}$
\end_inset

.
 In other words, 
\begin_inset Formula $q$
\end_inset

 is an identity function (
\begin_inset Formula $\text{id}^{:A\rightarrow A}$
\end_inset

).
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Revise the function from Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset

, making it a curried function and replacing the hard-coded number 
\begin_inset Formula $100$
\end_inset

 by a 
\emph on
curried
\emph default
 first argument.
 The type signature should become 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => List[List[Int]] => List[List[Int]]
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

converge
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-simple-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a curried function with an additional argument to set the maximum number
 of iterations, returning 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Double]
\end_layout

\end_inset

 as the final result type.
 The new version of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

converge
\end_layout

\end_inset

 should return 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 if the convergence condition is not satisfied after the given maximum number
 of iterations.
 The type signature and an example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@tailrec def convergeN[X](cond: X => Boolean)(x0: X)(maxIter: Int)(f: X
 => X): Option[X] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> convergeN[Int](_ < 0)(0)(10)(_ + 1) // This does not converge.
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> convergeN[Double]{ x => math.abs(x * x - 25) < 1e-8 }(1.0)(10) { x
 => 0.5 * (x + 25 / x ) }
\end_layout

\begin_layout Plain Layout

res1: Option[Double] = Some(5.000000000053722)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-7-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-7-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Implement a fully parametric, information-preserving, curried function that
 recovers from an error using a given function argument.
 The type signature and an example test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def recover[E, A]: Option[Either[E, A]] => (E => A) => Option[A] = ???
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> recover(Some(Left(
\begin_inset Quotes eld
\end_inset

error
\begin_inset Quotes erd
\end_inset

))) { _ => 123 }
\end_layout

\begin_layout Plain Layout

res0: Option[Int] = Some(123)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const
\end_layout

\end_inset

 as defined above, what are the types of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(id)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(id)(id)
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(id(id))
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

id(const)
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

const(const)
\end_layout

\end_inset

? Simplify these code expressions by symbolic calculations.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, show that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice(f)))
\end_layout

\end_inset

 is the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice)(f)
\end_layout

\end_inset

 for any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Int
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
For the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 from Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-hof-derive-types-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

, infer the most general type for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice(twice(twice)))
\end_layout

\end_inset

.
 What does that function do? Test your answer on an example.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

thrice
\end_layout

\end_inset

 similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 except it should apply a given function 
\begin_inset Formula $3$
\end_inset

 times.
 What does the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

thrice(thrice(thrice)))
\end_layout

\end_inset

 do?
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ence
\end_layout

\end_inset

 similarly to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

twice
\end_layout

\end_inset

 except it should apply a given function 
\begin_inset Formula $n$
\end_inset

 times, where 
\begin_inset Formula $n$
\end_inset

 is an additional curried argument.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a fully parametric function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flip(f)
\end_layout

\end_inset

 that swaps arguments for any given uncurried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 having two arguments.
 To test: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int, y: Int) = x - y    // Expect f(10, 2) == 8.
\end_layout

\begin_layout Plain Layout

val g = flip(f)                  // Now expect g(2, 10) == 8.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> assert( f (10, 2) == 8 && g(2, 10) == 8 )
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-simple-8-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-simple-8-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Write a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curry2
\end_layout

\end_inset

 converting a function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, A) => A
\end_layout

\end_inset


\family default
 into an equivalent curried function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => A => A
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Apply the function 
\begin_inset Formula $\left(x\rightarrow\_\rightarrow x\right)$
\end_inset

 to the value 
\begin_inset Formula $\left(z\rightarrow z(q)\right)$
\end_inset

 where 
\begin_inset Formula $q^{:Q}$
\end_inset

 is a given value of type 
\begin_inset Formula $Q$
\end_inset

.
 Infer types in these expressions.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types in the following expressions and test in Scala:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow r\rightarrow p(q(r))\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow q(r\rightarrow p)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow q(r\rightarrow q(p))\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow q(r\rightarrow p(q))\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow p(r\rightarrow r(q))\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(f)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow q(r\rightarrow r(p(q)))\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the following expressions 
\emph on
cannot
\emph default
 be well-typed with simple types (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-not-typeable"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for reference):
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow p(q)(p(q))\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $p\rightarrow q\rightarrow q(r\rightarrow p(q(r)))\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-curried-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-curried-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types and simplify the following code expressions by symbolic calculations
:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $q\rightarrow\left(x\rightarrow y\rightarrow z\rightarrow x(z)(y(z))\right)\left(a\rightarrow a\right)\left(b\rightarrow b(q)\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\left(f\rightarrow g\rightarrow h\rightarrow f(g(h))\right)(x\rightarrow x)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(c)
\series default
 
\begin_inset Formula $\left(x\rightarrow y\rightarrow x(y)\right)\left(x\rightarrow y\rightarrow x\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(d)
\series default
 
\begin_inset Formula $\left(x\rightarrow y\rightarrow x(y)\right)\left(x\rightarrow y\rightarrow y\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(e)
\series default
 
\begin_inset Formula $x\rightarrow\left(f\rightarrow y\rightarrow f(y)(x)\right)\left(z\rightarrow\_\rightarrow z\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(f)
\series default
 
\begin_inset Formula $z\rightarrow\left(x\rightarrow y\rightarrow x\right)\left(x\rightarrow x(z)\right)(y\rightarrow y(z))\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-composition"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-composition"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Infer types and simplify the following code expressions by symbolic calculations
:
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 
\begin_inset Formula $\left(z\rightarrow z+1\right)\bef\left(x\rightarrow y\rightarrow x/y\right)\bef\left(p\rightarrow p(2)\right)\quad.$
\end_inset


\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 
\begin_inset Formula $\left(p\rightarrow q\rightarrow p+q+1\right)\bef\left(f\rightarrow f\bef f\right)\bef(x\rightarrow x(1))\quad.$
\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-hof-composition-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-hof-composition-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
In the following statements, the types 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are fixed, and functions are 
\emph on
not
\emph default
 assumed to be fully parametric in 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(a)
\series default
 Given a function 
\begin_inset Formula $h^{:A\rightarrow B}$
\end_inset

 that satisfies the law 
\begin_inset Formula $f^{:A\rightarrow A}\bef h^{:A\rightarrow B}=h^{:A\rightarrow B}$
\end_inset

 for any 
\begin_inset Formula $f^{:A\rightarrow A}$
\end_inset

, prove that the function 
\begin_inset Formula $h$
\end_inset

 must ignore its argument and return a fixed value of type 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
(b)
\series default
 We are given two functions 
\begin_inset Formula $g^{:A\rightarrow A}$
\end_inset

 and 
\begin_inset Formula $h^{:B\rightarrow B}$
\end_inset

.
 We only know that 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 satisfy the law 
\begin_inset Formula $f^{:A\rightarrow B}\bef h^{:B\rightarrow B}=g^{:A\rightarrow A}\bef f^{:A\rightarrow B}$
\end_inset

 for any function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

.
 Prove that both 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $h$
\end_inset

 must be equal to identity functions of suitable types: 
\begin_inset Formula $g^{:A\rightarrow A}=\text{id}^{A}$
\end_inset

 and 
\begin_inset Formula $h^{:B\rightarrow B}=\text{id}^{B}$
\end_inset

.
\end_layout

\begin_layout Standard
Hint: choose 
\begin_inset Formula $f$
\end_inset

 to be a suitable 
\emph on
constant
\emph default
 function
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset

 and substitute 
\begin_inset Formula $f$
\end_inset

 into the given laws.
\end_layout

\begin_layout Section
Discussion and further developments
\end_layout

\begin_layout Subsection
Higher-order functions
\end_layout

\begin_layout Standard
The 
\series bold
order
\begin_inset Index idx
status open

\begin_layout Plain Layout
order of a function
\end_layout

\end_inset


\series default
 of a function is the number of function arrows (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

) contained in the type signature of that function.
 If a function's type signature contains more than one arrow, the function
 is called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
higher-order function
\end_layout

\end_inset

higher-order
\series default
 function.
 Higher-order functions take functions as arguments and/or return functions.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

andThen
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compose
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

curried
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

uncurried
\end_layout

\end_inset

 are examples of higher-order functions that take other functions as arguments
 
\emph on
and
\emph default
 return new functions.
\end_layout

\begin_layout Standard
The following examples illustrate the concept of a function's 
\begin_inset Quotes eld
\end_inset

order
\begin_inset Quotes erd
\end_inset

.
 Consider the code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f1(x: Int): Int = x + 10
\end_layout

\end_inset

The function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f1
\end_layout

\end_inset


\family default
 has type signature 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset


\family default
 and order 
\begin_inset Formula $1$
\end_inset

, so it is 
\emph on
not
\emph default
 a higher-order function.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f2(x: Int): Int => Int = (z => z + x)
\end_layout

\end_inset

The function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset


\family default
 has type signature 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int => Int
\end_layout

\end_inset


\family default
 and is a higher-order function of order 
\begin_inset Formula $2$
\end_inset

.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f3(g: Int => Int): Int = g(123)
\end_layout

\end_inset

The function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset


\family default
 has type signature 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(Int => Int) => Int
\end_layout

\end_inset


\family default
 and is a higher-order function of order 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\begin_layout Standard
Note that 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset


\family default
 is a higher-order function only because its return value is of a function
 type.
 An equivalent computation can be performed by an uncurried function that
 is 
\emph on
not
\emph default
 higher-order:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def f2u(x: Int, z: Int): Int = z + x   // Type signature (Int, Int)
 => Int
\end_layout

\end_inset

Unlike 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f2
\end_layout

\end_inset

, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 
\emph on
cannot
\emph default
 be converted to a first-order function because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f3
\end_layout

\end_inset

 has an argument of a function type.
 Converting to an uncurried form cannot eliminate such arguments.
\end_layout

\begin_layout Subsection
Name shadowing and the scope of bound variables
\end_layout

\begin_layout Standard
Bound variables are introduced in nameless functions whenever an argument
 is defined.
 For example, in the nameless function 
\begin_inset Formula $x\rightarrow y\rightarrow x+y$
\end_inset

, the bound variables are the curried arguments 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
 The variable 
\begin_inset Formula $y$
\end_inset

 is only defined within the scope 
\begin_inset Formula $\left(y\rightarrow x+y\right)$
\end_inset

 of the inner function; the variable 
\begin_inset Formula $x$
\end_inset

 is defined within the entire scope of 
\begin_inset Formula $x\rightarrow y\rightarrow x+y$
\end_inset

.
\end_layout

\begin_layout Standard
Another way of introducing bound variables in Scala is to write a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 or a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

 within curly braces:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x = {
\end_layout

\begin_layout Plain Layout

  val y = 10          // Bound variable `y`.
\end_layout

\begin_layout Plain Layout

  y + y * y
\end_layout

\begin_layout Plain Layout

}     // Same as `val x = 10 + 10 * 10`.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A bound variable is invisible outside the scope that defines it.
 So, it is easy to rename a bound variable: no outside code could possibly
 use it and depend on its value.
\end_layout

\begin_layout Standard
However, outside code may define a variable that (by chance) has the same
 name as a bound variable inside the scope.
 Consider an example from calculus where a function 
\begin_inset Formula $f$
\end_inset

 is defined via an integral:
\begin_inset Formula 
\[
f(x)=\int_{0}^{x}\frac{dx}{1+x}\quad.
\]

\end_inset

Here, 
\emph on
two
\emph default
 bound variables named 
\begin_inset Formula $x$
\end_inset

 are defined in two scopes: one in the scope of 
\begin_inset Formula $f$
\end_inset

, another in the scope of the nameless function 
\begin_inset Formula $x\rightarrow\frac{1}{1+x}$
\end_inset

.
 The convention in mathematics is to treat these two 
\begin_inset Formula $x$
\end_inset

's as two 
\emph on
completely
\emph default
 
\emph on
different
\emph default
 variables that just happen to have the same name.
 In sub-expressions where both of these bound variables are visible, priority
 is given to the bound variable defined in the smaller inner scope.
 The outer definition of 
\begin_inset Formula $x$
\end_inset

 is then 
\series bold
shadowed
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
shadowed name
\end_layout

\end_inset

 (hidden) by the inner definition of 
\begin_inset Formula $x$
\end_inset

.
 For this reason, evaluating 
\begin_inset Formula $f(10)$
\end_inset

 will give:
\begin_inset Formula 
\[
f(10)=\int_{0}^{10}\frac{dx}{1+x}=\log_{e}(11)\approx2.398\quad,
\]

\end_inset

rather than 
\begin_inset Formula $\int_{0}^{10}\frac{dx}{1+10}=\frac{10}{11}$
\end_inset

.
 The outer definition 
\begin_inset Formula $x=10$
\end_inset

 is shadowed within the expression 
\begin_inset Formula $\frac{1}{1+x}$
\end_inset

 by the definition of 
\begin_inset Formula $x$
\end_inset

 in the smaller local scope of 
\begin_inset Formula $x\rightarrow\frac{1}{1+x}$
\end_inset

.
\end_layout

\begin_layout Standard
Since this is the standard mathematical convention, the same convention
 is adopted in functional programming.
 A variable defined in a function scope (i.e., a bound variable) will shadow
 any outside definitions of a variable with the same name.
\end_layout

\begin_layout Standard
Name shadowing is not advisable in practical programming, because it usually
 decreases the clarity of code and so invites errors.
 Consider the nameless function:
\begin_inset Formula 
\[
x\rightarrow x\rightarrow x\quad,
\]

\end_inset

and let us decipher this confusing syntax.
 The symbol 
\begin_inset Formula $\rightarrow$
\end_inset

 groups to the right, so 
\begin_inset Formula $x\rightarrow x\rightarrow x$
\end_inset

 is the same as 
\begin_inset Formula $x\rightarrow\left(x\rightarrow x\right)$
\end_inset

.
 It is a function that takes 
\begin_inset Formula $x$
\end_inset

 and returns 
\begin_inset Formula $x\rightarrow x$
\end_inset

.
 Since the argument 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $\left(x\rightarrow x\right)$
\end_inset

 may be renamed to y without changing the function, we can rewrite the code
 to:
\begin_inset Formula 
\[
x\rightarrow\left(y\rightarrow y\right)\quad.
\]

\end_inset

Having removed name shadowing, we can more easily understand this code and
 reason about it.
 For instance, it becomes clear that this function ignores its argument
 
\begin_inset Formula $x$
\end_inset

 and always returns the same value (the identity function 
\begin_inset Formula $y\rightarrow y$
\end_inset

).
 So, we can rewrite 
\begin_inset Formula $\left(x\rightarrow x\rightarrow x\right)$
\end_inset

 as 
\begin_inset Formula $\left(\_\rightarrow y\rightarrow y\right)$
\end_inset

, which is clearer.
\end_layout

\begin_layout Subsection
Operator syntax for function applications
\end_layout

\begin_layout Standard
In mathematics, function applications are sometimes written without parentheses,
 for instance: 
\begin_inset Formula $\cos x$
\end_inset

 or 
\begin_inset Formula $\log z$
\end_inset

.
 Commonly used formulas such as 
\begin_inset Formula $2\sin x\cos x$
\end_inset

 imply parentheses as 
\begin_inset Formula $2\cdot(\sin\left(x\right))\cdot(\cos\left(x\right))$
\end_inset

.
 This convention allows us to treat certain functions as 
\begin_inset Quotes eld
\end_inset

operators
\begin_inset Quotes erd
\end_inset

 that are written without parentheses, similar to the operators of summation,
 
\begin_inset Formula $\sum_{k}f(k)$
\end_inset

, or differentiation, 
\begin_inset Formula $\frac{d}{dx}f(x)$
\end_inset

.
\end_layout

\begin_layout Standard
Some programming languages (such as OCaml, Haskell, and F#) have adopted
 this 
\begin_inset Quotes eld
\end_inset

operator syntax
\begin_inset Index idx
status open

\begin_layout Plain Layout
operator syntax
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, making parentheses optional for all function arguments.
 In those languages, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f x
\end_layout

\end_inset

 means the same as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
The operator syntax has a long history in programming.
 It is used in Unix shell commands, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

cp file1 file2
\end_layout

\end_inset

, and also in the language 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Tcl
\end_layout

\end_inset

.
 In LISP-like languages, function applications are enclosed in parentheses
 but the arguments are space-separated, for example 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f 10 20)
\end_layout

\end_inset

.
\end_layout

\end_inset

 Parentheses are still used, for example, in expressions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(g x)
\end_layout

\end_inset

.
 For curried functions, function applications group to the left, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f x y z
\end_layout

\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((f x) y) z
\end_layout

\end_inset

.
 Function applications group stronger than infix operations, so 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f x + y
\end_layout

\end_inset

 means 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(f x) + y
\end_layout

\end_inset

, following the convention used in mathematics where 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\cos x+y$
\end_inset


\begin_inset Quotes erd
\end_inset

 groups 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\cos x$
\end_inset


\begin_inset Quotes erd
\end_inset

 stronger than the infix 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $+$
\end_inset


\begin_inset Quotes erd
\end_inset

 operation.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Thus, 
\begin_inset Formula $x\rightarrow y\rightarrow a\,b\,c+p\,q$
\end_inset

 means 
\begin_inset Formula $x\rightarrow\left(y\rightarrow\left(\left(a\,b\right)\,c\right)+(p\,q)\right)$
\end_inset

.
 When this notation becomes hard to read correctly, one needs to add parentheses
, e.g., writing 
\begin_inset Formula $f(x\rightarrow g\,h)$
\end_inset

 instead of 
\begin_inset Formula $f\,x\rightarrow g\,h$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This book does not use the 
\begin_inset Quotes eld
\end_inset

operator syntax
\begin_inset Quotes erd
\end_inset

 when reasoning about code.
 Scala does not support the parentheses-free operator syntax; parentheses
 are needed around each curried argument (or a curried list of arguments).
\end_layout

\begin_layout Standard
In programming language theory, curried functions are 
\begin_inset Quotes eld
\end_inset

simpler
\begin_inset Quotes erd
\end_inset

 because they always have a 
\emph on
single
\emph default
 argument (but may return a function that will consume further arguments).
 From the point of view of programming practice, curried functions are often
 harder to read and to write.
\end_layout

\begin_layout Standard
In the operator syntax, a curried function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 is applied to curried arguments as, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f 20 4
\end_layout

\end_inset

.
 This departs further from the mathematical tradition and requires some
 getting used to.
 If the two arguments are more complicated than just 
\begin_inset Formula $20$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

, the resulting expression may become harder to read, compared with the
 syntax where commas are used to separate the arguments.
 (Consider, for instance, the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f (g 10) (h 20) + 30
\end_layout

\end_inset

.) To improve readability of code, programmers may prefer to define names
 for complicated expressions and then use those names as curried arguments.
\end_layout

\begin_layout Standard
In Scala, the choice of whether to use curried or uncurried function signatures
 is mostly a matter of syntactic convenience.
 Most Scala code seems to be written with uncurried functions.
\end_layout

\begin_layout Standard
One of the syntactic features of Scala is the ability to give a curried
 argument using the curly brace syntax.
 Compare the two definitions of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation
\end_layout

\end_inset

 described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Nameless-functions-in-mathematical-notation"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def summation1(a: Int, b: Int, g: Int => Double): Double = (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def summation2(a: Int, b: Int)(g: Int => Double): Double = (a to b).map(g).sum
\end_layout

\end_inset

These functions are applied to arguments like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> summation1(1, 10, { x => x * x * x + 2 * x })
\end_layout

\begin_layout Plain Layout

res0: Double = 3135.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> summation2(1, 10) { x => x * x * x + 2 * x }
\end_layout

\begin_layout Plain Layout

res1: Double = 3135.0
\end_layout

\end_inset

The code that calls 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation2
\end_layout

\end_inset

 is easier to read because the curried argument is syntactically separated
 from the rest of the code by curly braces.
 This is especially useful when the curried argument is itself a function
 with a complicated body, since Scala's curly braces syntax allows function
 bodies to contain local definitions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

) of new bound variables.
\end_layout

\begin_layout Standard
Another feature of Scala is the 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax: for example, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs map f
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

xs.map(f)
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f andThen g
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f.andThen(g)
\end_layout

\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 syntax is available only for infix methods, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, defined on specific types such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Seq
\end_layout

\end_inset

.
 In Scala 3, the 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 syntax is generally enabled by the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

infix def
\end_layout

\end_inset

 annotation.
 Do not confuse Scala's 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 method syntax with the operator syntax used in Haskell and other languages.
\end_layout

\begin_layout Subsection
Deriving a function's code from its type
\begin_inset CommandInset label
LatexCommand label
name "subsec:Deriving-a-function-s-code"

\end_inset


\end_layout

\begin_layout Standard
We have seen how the procedure of type inference
\begin_inset Index idx
status open

\begin_layout Plain Layout
type inference
\end_layout

\end_inset

 derives the type signature from a function's code.
 A well-known algorithm for type inference is the Damas-Hindley-Milner algorithm
,
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"

\end_inset


\end_layout

\end_inset

 with a Scala implementation available.
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://dysphoria.net/2009/06/28/hindley-milner-type-inference-in-scala/"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is remarkable that one can sometimes perform 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
code inference
\end_layout

\end_inset

code inference
\begin_inset Quotes erd
\end_inset

: derive a function's 
\emph on
code
\emph default
 from the function's type signature.
 We will now look at some examples of this.
\end_layout

\begin_layout Standard
Consider a fully parametric function that performs partial applications
\begin_inset Index idx
status open

\begin_layout Plain Layout
partial application
\end_layout

\end_inset

 for arbitrary other functions.
 A possible type signature is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = ???
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How can we implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

? Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa(x)(f)
\end_layout

\end_inset

 must return a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B => C
\end_layout

\end_inset

, we have no choice other than to begin writing a nameless function in the
 code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y: B =>
\end_layout

\begin_layout Plain Layout

  ??? // Need to compute a value of type C in this scope.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inner scope, we need to compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

, and we have values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: B
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: (A, B) => C
\end_layout

\end_inset

.
 How can we compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

? If we knew that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C = Int
\end_layout

\end_inset

 when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa(x)(f)
\end_layout

\end_inset

 is applied, we could have simply selected a fixed integer value, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1
\end_layout

\end_inset

, as the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 If we knew that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C = String
\end_layout

\end_inset

, we could have selected a fixed string, say, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, as the value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

.
 But a fully parametric function cannot use any knowledge of the types of
 its actual arguments.
\end_layout

\begin_layout Standard
So, a fully parametric function cannot produce a value of an arbitrary type
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 from scratch.
 The only way of producing a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is by applying the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to arguments of types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
 Since the types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are arbitrary, we cannot obtain any values of these types other than 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y: B
\end_layout

\end_inset

.
 So, the only way of getting a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

C
\end_layout

\end_inset

 is to compute 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x, y)
\end_layout

\end_inset

.
 Thus, the body of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pa
\end_layout

\end_inset

 must be:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pa[A, B, C](x: A)(f: (A, B) => C): B => C = { y => f(x, y) }
\end_layout

\end_inset

In this way, we have 
\emph on
unambiguously
\emph default
 derived the body of this function from its type signature, by assuming
 that the function must be fully parametric.
\end_layout

\begin_layout Standard
Another example is the operation of forward composition 
\begin_inset Formula $f\bef g$
\end_inset

 viewed as a fully parametric function with type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = ???
\end_layout

\end_inset

To implement 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

before
\end_layout

\end_inset

, we need to create a nameless function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => C
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { x: A =>
\end_layout

\begin_layout Plain Layout

  ??? // Need to compute a value of type C in this scope.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

In the inner scope, we need to compute a value of type 
\begin_inset Formula $C$
\end_inset

 from the values 
\begin_inset Formula $x^{:A}$
\end_inset

, 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

.
 Since the type 
\begin_inset Formula $C$
\end_inset

 is arbitrary, the only way of obtaining a value of type 
\begin_inset Formula $C$
\end_inset

 is by applying 
\begin_inset Formula $g$
\end_inset

 to an argument of type 
\begin_inset Formula $B$
\end_inset

.
 In turn, the only way of obtaining a value of type 
\begin_inset Formula $B$
\end_inset

 is to apply 
\begin_inset Formula $f$
\end_inset

 to an argument of type 
\begin_inset Formula $A$
\end_inset

.
 Finally, we have only one value of type 
\begin_inset Formula $A$
\end_inset

, namely 
\begin_inset Formula $x^{:A}$
\end_inset

.
 So, the only way of obtaining the required result is to compute 
\begin_inset Formula $g(f(x))$
\end_inset

.
\end_layout

\begin_layout Standard
We have derived the body of the function from its type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def before[A, B, C](f: A => B, g: B => C): A => C = { x => g(f(x)) }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:5-Curry-Howard"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will show how code can be derived from type signatures for a wide range
 of fully parametric functions.
\end_layout

\end_body
\end_document
