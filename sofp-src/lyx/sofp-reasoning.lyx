#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Reasoning about code.
 Techniques of symbolic derivation
\begin_inset CommandInset label
LatexCommand label
name "chap:Reasoning-about-code"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\renewcommand{\gunderline}[1]{\mathunderline{greenunder}{#1}}
{\underline{{\color{teal}#1}}}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bef}{\forwardcompose}
{\fatsemi}
\end_inset


\begin_inset FormulaMacro
\renewcommand{\bbnum}[1]{\custombb{#1}}
{\underline{#1}}
\end_inset


\end_layout

\begin_layout Standard
In previous chapters, we have performed symbolic
\begin_inset Index idx
status open

\begin_layout Plain Layout
symbolic calculations
\end_layout

\end_inset

 derivations of some laws.
 To make the derivations more manageable, we gradually developed special
 notations and techniques of reasoning.
 This short chapter is a summary of those notations and techniques.
\end_layout

\begin_layout Section
This book's notation for code
\end_layout

\begin_layout Subsection
The nine constructions of fully parametric code
\end_layout

\begin_layout Standard
The eight basic constructions
\begin_inset Index idx
status open

\begin_layout Plain Layout
eight code constructions
\end_layout

\end_inset

 introduced in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Short-notation-for-eight-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, together with recursion, serve as a foundation for 
\series bold
fully parametric
\series default
 coding style.
 All major techniques and design patterns of functional programming can
 be implemented using only these constructions, i.e., by fully parametric
\begin_inset Index idx
status open

\begin_layout Plain Layout
fully parametric!code
\end_layout

\end_inset

 code.
 We will now define the code notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
code notation
\end_layout

\end_inset

 (summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Mathematical-notation-for-basic-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

) for each of the nine constructions.
\begin_inset Index idx
status open

\begin_layout Plain Layout
nine code constructions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Constructions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scala examples
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code notation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use constant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

()
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $\text{true}$
\end_inset

, 
\begin_inset Formula $\text{"abc"}$
\end_inset

, 
\begin_inset Formula $123$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use argument
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x: A) = { ...
 x ...
 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x^{:A})\triangleq...~x~...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x: A) => expr(x)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}\rightarrow\text{expr}\left(x\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.pipe(f)
\end_layout

\end_inset

 (Scala 2.13)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)$
\end_inset

 or 
\begin_inset Formula $x\triangleright f$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val p: (A, B) = (a, b)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p^{:A\times B}\triangleq a\times b$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $p\triangleright\pi_{1}$
\end_inset

 or 
\begin_inset Formula $p\triangleright\pi_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
create co-product
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Left[A, B](x)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Right[A, B](y)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x^{:A}+\bbnum 0^{:B}$
\end_inset

 or 
\begin_inset Formula $\bbnum 0^{:A}+y^{:B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
use co-product
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset space \hspace*{}
\length -1.3line%
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\size small
\begin_inset VSpace 28baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val p: Either[A, B] = ...
 
\end_layout

\begin_layout Plain Layout

val q: C = p match {
\end_layout

\begin_layout Plain Layout

    case Left(x)   => f(x)
\end_layout

\begin_layout Plain Layout

    case Right(y)  => g(y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset VSpace -10baselineskip%
\end_inset


\end_layout

\end_inset

 
\begin_inset space \hspace*{}
\length -0.9line%
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $q^{:C}\triangleq p^{:A+B}\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & x^{:A}\rightarrow f(x)\\
B & y^{:B}\rightarrow g(y)
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
recursive call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def f(x) = { ...
 f(y) ...
 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $f(x)\triangleq...~\overline{f}(y)~...$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
This book's notation for the nine basic code constructions.
\begin_inset CommandInset label
LatexCommand label
name "tab:Mathematical-notation-for-basic-code-constructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
1) Use a constant
\end_layout

\begin_layout Standard
Whenever we need a value of a fixed type, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, we may use a constant value of that type.
 We may also use a 
\begin_inset Quotes eld
\end_inset

named unit
\begin_inset Index idx
status open

\begin_layout Plain Layout
unit type!named
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[A]
\end_layout

\end_inset

 for any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 All named unit values are denoted by 
\begin_inset Formula $1$
\end_inset

 and are viewed as having type 
\begin_inset Formula $\bbnum 1$
\end_inset

.
 Functions taking 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

 type as an argument do not actually need to use their argument and may
 be written as 
\begin_inset Formula $\_\rightarrow\text{expr}$
\end_inset

.
\end_layout

\begin_layout Standard
Functions that do not use their argument are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
constant function
\end_layout

\end_inset


\series bold
constant functions
\series default
.
\end_layout

\begin_layout Standard
Scala example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A](x: A): Int = 123
\end_layout

\begin_layout Plain Layout

  // Or equivalently:
\end_layout

\begin_layout Plain Layout

def f[A]: A => Int = { _ => 123 }
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
f(x^{:A})\triangleq123\quad\quad\text{or}\quad\quad f\triangleq\_^{:A}\rightarrow123\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
2) Use a given argument
\end_layout

\begin_layout Standard
In any expression that has a bound variable
\begin_inset Index idx
status open

\begin_layout Plain Layout
bound variable
\end_layout

\end_inset

 (e.g., an argument within a function's body), we may use the bound variable
 at any place, as many times as we need.
 Scala example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[A](x: String, y: Int): Int = 123 + y + y
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
f(x^{:\text{String}},y^{:\text{Int}})\triangleq123+y+y\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
3) Create a function
\end_layout

\begin_layout Standard
We create a nameless function of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr }
\end_layout

\end_inset

 using a variable, say 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, and any expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 that may use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a free variable
\begin_inset Index idx
status open

\begin_layout Plain Layout
free variable
\end_layout

\end_inset

 (i.e., a variable that should be defined outside that expression).
 E.g., the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123 + x + x
\end_layout

\end_inset

 uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a free variable: indeed, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

123 + x + x
\end_layout

\end_inset

 makes sense only if 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 is already defined outside that expression.
 The Scala code for the corresponding nameless function is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ x: Int => 123 + x + x }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Code notation:
\begin_inset Formula 
\[
x^{:\text{Int}}\rightarrow123+x+x\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
If the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 already contains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 as a bound variable, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ x => expr }
\end_layout

\end_inset

 will have a name clash.
 An example is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => { x => x }
\end_layout

\end_inset

; here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{x => x}
\end_layout

\end_inset

.
 Such code is confusing.
 It is helpful to avoid the name clash by renaming the bound variables inside
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

expr
\end_layout

\end_inset

, e.g., to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ z => z }
\end_layout

\end_inset

.
 The resulting code is written in Scala as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ x: Int => { z: Int => z } }   // Or equivalently:
\end_layout

\begin_layout Plain Layout

(x: Int) => (z: Int) => z
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
x^{:\text{Int}}\rightarrow z^{:\text{Int}}\rightarrow z\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
4) Use a function
\end_layout

\begin_layout Standard
If a function is already defined, we can use it by applying it to an argument.
 A Scala example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val f = { x: Int => 123 + x + x }
\end_layout

\begin_layout Plain Layout

f(100)       // Evaluates to 323.
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
f\triangleq x^{:\text{Int}}\rightarrow123+x+x\quad,\quad\quad f(100)=323\quad.
\]

\end_inset


\end_layout

\begin_layout Paragraph
5) Create a tuple
\end_layout

\begin_layout Standard
Given two values 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

a: A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b: B
\end_layout

\end_inset

, we can create the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(a, b)
\end_layout

\end_inset

 as well as the tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(b, a)
\end_layout

\end_inset

.
 In the code notation, those tuples are written as 
\begin_inset Formula $a\times b$
\end_inset

 and 
\begin_inset Formula $b\times a$
\end_inset

.
\end_layout

\begin_layout Paragraph
6) Use a tuple
\end_layout

\begin_layout Standard
Given a tuple 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p == (a, b)
\end_layout

\end_inset

, we can extract each of the values via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p._2
\end_layout

\end_inset

.
 The corresponding code notation is 
\begin_inset Formula $p\triangleright\pi_{1}$
\end_inset

 and 
\begin_inset Formula $p\triangleright\pi_{2}$
\end_inset

.
 The standard functions 
\begin_inset Formula $\pi_{i}$
\end_inset

 (where 
\begin_inset Formula $i=1,2,...$
\end_inset

) may be used for tuples of any size.
 Example code defining these functions:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pi_1[A, B]: ((A, B)) => A = { case (a, b) => a } // Same as  p => p._1
\end_layout

\begin_layout Plain Layout

def pi_2[A, B]: ((A, B)) => B = { case (a, b) => b } // Same as  p => p._2
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\begin{align*}
\pi_{1}^{A,B} & \triangleq a^{:A}\times b^{:B}\rightarrow a\quad,\\
\pi_{2}^{A,B} & \triangleq a^{:A}\times b^{:B}\rightarrow b\quad.
\end{align*}

\end_inset

We use the notation 
\begin_inset Formula $a\times b$
\end_inset

 in an 
\emph on
argument
\emph default
 of a function to destructure tuples.
\end_layout

\begin_layout Paragraph
7) Create a disjunctive value
\end_layout

\begin_layout Standard
A disjunctive type is defined in Scala using named 
\begin_inset Quotes eld
\end_inset

constructors
\begin_inset Quotes erd
\end_inset

 (i.e., case classes).
 The same named constructors are used to create values of that type.
 In the code notation, constructor names are not written.
\end_layout

\begin_layout Standard
Scala example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sealed trait S
\end_layout

\begin_layout Plain Layout

final case class P(w: Int, x: Int)  extends S
\end_layout

\begin_layout Plain Layout

final case class Q(y: String)       extends S
\end_layout

\begin_layout Plain Layout

final case class R(z: Int)          extends S
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val s: S = P(10, 20) // Create a value of type S.
\end_layout

\begin_layout Plain Layout

val t: S = R(30)     // Another value of type S.
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\begin{align*}
S & \triangleq\text{Int}\times\text{Int}+\text{String}+\text{Int}\quad,\\
s^{:S} & \triangleq10\times20+\bbnum 0^{:\text{String}}+\bbnum 0^{:\text{Int}}\quad,\\
t^{:S} & \triangleq\bbnum 0^{:\text{Int}\times\text{Int}}+\bbnum 0^{:\text{String}}+30\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The code notation for disjunctive values, e.g., 
\begin_inset Formula $\bbnum 0+\bbnum 0+x$
\end_inset

, is more verbose than the Scala syntax such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R(x)
\end_layout

\end_inset

.
 The advantage is that we may explicitly annotate all types and show clearly
 the part of the disjunction that we are creating.
 Another advantage is that the notation 
\begin_inset Formula $\bbnum 0+\bbnum 0+x$
\end_inset

 is similar to a row vector, 
\begin_inset Formula $\,\begin{array}{|ccc|}
\bbnum 0 & \bbnum 0 & x\end{array}$
\end_inset


\begin_inset space ~
\end_inset

, which is well adapted to the matrix notation for 
\begin_inset Quotes eld
\end_inset

disjunctive functions
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
8) Use a disjunctive value
\end_layout

\begin_layout Standard
Once created, disjunctive values can be used as arguments of pattern-matching
 expressions (Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 syntax).
 Recall that functions that take a disjunctive value as an argument (
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive functions
\end_layout

\end_inset


\series bold
disjunctive functions
\series default

\begin_inset Quotes erd
\end_inset

) may be also written in Scala 
\emph on
without
\emph default
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 keyword.
 A Scala example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val compute: Option[Int] => Option[Int] = {
\end_layout

\begin_layout Plain Layout

    case None      => Some(100)
\end_layout

\begin_layout Plain Layout

    case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code notation for this disjunctive function is modeled after the Scala
 code:
\begin_inset Formula 
\[
\text{compute}^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & \_\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We will use this example to explain how disjunctive functions are written
 in the matrix notation
\begin_inset Index idx
status open

\begin_layout Plain Layout
matrix notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
disjunctive type!matrix notation
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Each row of a matrix corresponds to a part of the disjunctive type matched
 by one of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions.
 The column to the left of the double line shows the corresponding disjunctive
 subtypes.
 In this example, the disjunctive type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

 has two parts: the named unit 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 (denoted by 
\begin_inset Formula $\bbnum 1$
\end_inset

) and the case class 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Some[Int]
\end_layout

\end_inset

, which is equivalent to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 So, the matrix has two rows labeled 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\text{Int}$
\end_inset

, showing that the function's argument type is 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

.
\end_layout

\begin_layout Standard
The columns of the matrix correspond to the parts of the disjunctive type
 
\emph on
returned
\emph default
 by the function.
 In this example, the return type is also 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Option[Int]
\end_layout

\end_inset

, that is, 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

, so the matrix has two columns labeled 
\begin_inset Formula $\bbnum 1$
\end_inset

 and 
\begin_inset Formula $\text{Int}$
\end_inset

.
 If the return type is not disjunctive, the matrix will have one column.
\end_layout

\begin_layout Standard
What are the matrix elements? The idea of the matrix notation is to translate
 the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 expressions line by line.
 Look at the first 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

case
\end_layout

\end_inset

 line as if it were a standalone partial function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case None => Some(100) }
\end_layout

\end_inset

Since 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

None
\end_layout

\end_inset

 is a named unit and is denoted by 
\begin_inset Formula $1$
\end_inset

, this function is written in the code notation as 
\begin_inset Formula $1\rightarrow\bbnum 0^{:\bbnum 1}+100^{:\text{Int}}$
\end_inset

, or more concisely as 
\begin_inset Formula $\_\rightarrow\bbnum 0+100$
\end_inset

.
 
\end_layout

\begin_layout Standard
The second line is written in the form of a partial function as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ case Some(x) => Some(x / 2) }
\end_layout

\end_inset

The pattern variable on the left side is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 and has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, so we denote that function by 
\begin_inset Formula $x^{:\text{Int}}\rightarrow\bbnum 0^{:\bbnum 1}+(x/2)^{:\text{Int}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
To obtain the matrix code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compute
\end_layout

\end_inset

, we may begin by writing the two partial functions as two rows of a matrix:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val compute: Option[Int] => Option[Int] = {
\end_layout

\begin_layout Plain Layout

    case None      => Some(100)
\end_layout

\begin_layout Plain Layout

    case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

The code notation is:
\begin_inset Formula 
\[
\text{compute}^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\,\begin{array}{|c||c|}
 & \bbnum 1+\text{Int}\\
\hline \bbnum 1 & \_\rightarrow\bbnum 0+100\\
\text{Int} & x\rightarrow\bbnum 0+\frac{x}{2}
\end{array}\quad.
\]

\end_inset

This is already a valid matrix notation for the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compute
\end_layout

\end_inset

.
 So far, the matrix has two rows and one column.
 Then we notice that each row's return value is 
\emph on
known
\emph default
 to be in a specific subtype of the disjunctive type 
\begin_inset Formula $\bbnum 1+\text{Int}$
\end_inset

; in this example, both rows return values of the subtype 
\begin_inset Formula $\bbnum 0+\text{Int}$
\end_inset

.
 So, we split the column into two columns labeled 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\bbnum 1$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{Int}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 This gives a more useful code notation for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compute
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{compute}^{:\bbnum 1+\text{Int}\rightarrow\bbnum 1+\text{Int}}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & \_\rightarrow100\\
\text{Int} & \bbnum 0 & x^{:\text{Int}}\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset

The void type
\begin_inset Index idx
status open

\begin_layout Plain Layout
void type!in matrix notation
\end_layout

\end_inset

 (
\begin_inset Formula $\bbnum 0$
\end_inset

) is written in the first column to indicate that the disjunctive part in
 that column is not returned.
 There is no confusion with other columns because the type 
\begin_inset Formula $\bbnum 0$
\end_inset

 has no values.
 In this way, the matrix clearly displays the parts of disjunctive types
 that are being returned in each case.
\end_layout

\begin_layout Standard
Because only one part of a disjunctive type can ever be returned, a row
 can have at most one non-void value.
 That value will be in the column corresponding to the part being returned.
 
\end_layout

\begin_layout Standard
Partial functions are expressed in the matrix notation by writing 
\begin_inset Formula $\bbnum 0$
\end_inset

 in the missing rows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def get[A]: Option[A] => A = {
\end_layout

\begin_layout Plain Layout

    case Some(x) => x
\end_layout

\begin_layout Plain Layout

} // Partial function; fails on `None`.
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
\text{get}^{:\bbnum 1+A\rightarrow A}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & x^{:A}\rightarrow x
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline \bbnum 1 & \bbnum 0\\
A & \text{id}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Scala's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

match
\end_layout

\end_inset

 expression is equivalent to an application of a disjunctive function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val p: Option[Int] = Some(64)
\end_layout

\begin_layout Plain Layout

val q: Option[Int] = p match {
\end_layout

\begin_layout Plain Layout

    case None      => Some(100)
\end_layout

\begin_layout Plain Layout

    case Some(x)   => Some(x / 2)
\end_layout

\begin_layout Plain Layout

}    // The value of q equals Some(32).
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
p\triangleq\bbnum 0^{:\bbnum 1}+64^{:\text{Int}}\quad,\quad q\triangleq p\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & \_\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\quad.
\]

\end_inset

It is convenient to put the argument 
\begin_inset Formula $p$
\end_inset

 to the 
\emph on
left
\emph default
 of the disjunctive function, resembling the Scala syntax 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p match {...}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let us see how to compute function applications in the matrix notation.
 We view the disjunctive value 
\begin_inset Formula $\bbnum 0+64^{:\text{Int}}$
\end_inset

 as a 
\begin_inset Quotes eld
\end_inset

row vector
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\,\begin{array}{|cc|}
\bbnum 0 & 64\end{array}$
\end_inset


\begin_inset space ~
\end_inset

.
 Vectors are written with a single line at left, to distinguish them from
 function matrices.
 Calculations use the standard rules of a vector-matrix product:
\begin_inset Formula 
\begin{align*}
 & (\bbnum 0+64)\triangleright\,\begin{array}{||cc|}
\bbnum 0 & \_\rightarrow100\\
\bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 64\end{array}\,\triangleright\,\begin{array}{||cc|}
\bbnum 0 & \_\rightarrow100\\
\bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\\
 & =\,\begin{array}{|cc|}
\bbnum 0 & 64\triangleright(x\rightarrow\frac{x}{2})\end{array}\,=\,\begin{array}{|cc|}
\bbnum 0 & 32\end{array}\,=\bbnum 0^{:\bbnum 1}+32^{:\text{Int}}\quad.
\end{align*}

\end_inset

Instead of the multiplication of matrix elements as it would be done in
 linear algebra, we use the pipe (
\begin_inset Formula $\triangleright$
\end_inset

) operation, and we drop any terms containing 
\begin_inset Formula $\bbnum 0$
\end_inset

.
 (Type annotations are omitted because we already checked that the types
 match.) 
\end_layout

\begin_layout Paragraph
9) Use a recursive call
\end_layout

\begin_layout Standard
The last construction is to call a function recursively within its own definitio
n.
 This construction was not shown in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Short-notation-for-eight-code-constructions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 because the constructive propositional logic (which was the main focus
 of that chapter) cannot represent recursively defined values.
 However, this limitation of propositional logic means only that we do not
 have an algorithm for 
\emph on
automatic
\emph default
 derivation of recursive code.
 Those derivations can be performed by hand.
 
\end_layout

\begin_layout Standard
Recursive code is used often, and we need to get some experience reasoning
 about it.
 In derivations, this book denotes recursive calls by an 
\emph on
overline
\emph default
.
 For example, the standard 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 functor (see the solution of Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-rec-poly-functor-List"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is defined as:
\begin_inset Formula 
\[
\text{fmap}_{\text{List}}(f)\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\times\text{List}^{A}\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
A\times\text{List}^{A} & \bbnum 0 & h^{:A}\times t^{:\text{List}^{A}}\rightarrow f(h)\times\big(t\triangleright\overline{\text{fmap}}_{\text{List}}(f)\big)
\end{array}\quad.
\]

\end_inset

The recursive call to 
\begin_inset Formula $\text{fmap}_{\text{List}}$
\end_inset

 is applied to a list's tail (the value 
\begin_inset Formula $t$
\end_inset

).
\end_layout

\begin_layout Standard
In proofs of laws for recursive functions, it is necessary to use induction
 in the number of recursive self-calls.
 However, the proof does not need to separate the base case (no recursive
 calls) from the inductive step.
 In the proof, we write a symbolic calculation as usual, except that we
 assume that the law already holds for all recursive calls to the same function.
\end_layout

\begin_layout Standard
For example, a proof of the identity law of 
\begin_inset Formula $\text{fmap}_{\text{List}}$
\end_inset

: 
\begin_inset Formula 
\[
\text{fmap}_{\text{List}}(\text{id})=\text{id}\quad,
\]

\end_inset

proceeds by replacing the recursive call 
\begin_inset Formula $\overline{\text{fmap}}_{\text{List}}(\text{id})$
\end_inset

 by just 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\text{id}$
\end_inset


\begin_inset Quotes erd
\end_inset

 during calculations, as we did in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-rec-poly-functor-List"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{fmap}_{\text{List}}(\text{id})=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h^{:A}\times t^{:\text{List}^{A}}\rightarrow\text{id}(h)\times\big(\gunderline{t\triangleright\overline{\text{fmap}}_{\text{List}}(\text{id})}\big)
\end{array}\\
 & \quad\text{inductive assumption}:\quad\\
 & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & h\times t\rightarrow\gunderline{\text{id}(h)\times(t\triangleright\text{id})}
\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \gunderline{h\times t\rightarrow h\times t}
\end{array}\\
 & \quad\text{identity matrix}:\quad\\
 & =\,\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\,=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Function composition and the pipe notation
\end_layout

\begin_layout Standard
In addition to the basic code constructions, our derivations will often
 need to work with function compositions and lifted functions.
 It is often faster to perform calculations with functions when we do not
 write all of their arguments explicitly; e.g., writing the right identity
 law as 
\begin_inset Formula $f\bef\text{id}=f$
\end_inset

 instead of 
\begin_inset Formula $\text{id}\left(f(x)\right)=f(x)$
\end_inset

.
 This is known as calculating in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
point-free style|textit
\end_layout

\end_inset


\series bold
point-free
\series default
 style (meaning 
\begin_inset Quotes eld
\end_inset

argument-free
\begin_inset Quotes erd
\end_inset

).
 Many laws can be formulated and used more easily in the point-free form.
 
\end_layout

\begin_layout Standard
Calculations in point-free style almost always involve composing functions.
 This book prefers to use the 
\emph on
forward
\emph default
 function composition 
\begin_inset Formula $(f\bef g$
\end_inset

) defined for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

 by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f andThen g == { x => g(f(x)) }
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
f\bef g\triangleq x\rightarrow g(f(x))\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
A useful tool for calculations is the 
\series bold
pipe
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
$@
\begin_inset Formula $\triangleright$
\end_inset

-notation!see 
\begin_inset Quotes eld
\end_inset

pipe notation
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 operation, 
\begin_inset Formula $x\triangleright f$
\end_inset

, which means just the same as 
\begin_inset Formula $f(x)$
\end_inset

 but places the argument (
\begin_inset Formula $x$
\end_inset

) to the 
\emph on
left
\emph default
 of a function (
\begin_inset Formula $f$
\end_inset

).
 It is then natural to apply further functions at 
\emph on
right
\emph default
, for example, 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

 meaning 
\begin_inset Formula $g(f(x))$
\end_inset

.
 In Scala, methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 are often combined in this way:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x.map(f).filter(p)
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
x\triangleright\text{fmap}\,(f)\triangleright\text{filt}\,(p)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
To enable this common usage, the operation 
\begin_inset Formula $\triangleright$
\end_inset

 is defined to group towards the left.
 So, the parentheses in 
\begin_inset Formula $(x\triangleright f)\triangleright g=x\triangleright f\triangleright g$
\end_inset

 are not needed.
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation!operator precedence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $x\triangleright f\triangleright g=g(f(x))$
\end_inset

 by definition, it follows that the composition 
\begin_inset Formula $f\bef g$
\end_inset

 satisfies the equation:
\begin_inset Formula 
\[
x\triangleright f\triangleright g=x\triangleright(f\bef g)\quad.
\]

\end_inset

Such formulas are needed often, so we introduce the convention that the
 pipe operation (
\begin_inset Formula $\triangleright$
\end_inset

) groups weaker than the composition operation (
\begin_inset Formula $\bef$
\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
pipe notation!operator precedence
\end_layout

\end_inset

 We can then omit the parentheses: 
\begin_inset Formula $x\triangleright(f\bef g)=x\triangleright f\bef g$
\end_inset

.
 
\end_layout

\begin_layout Standard
Another common simplification occurs with function compositions of the form:
\begin_inset Formula 
\[
(x\rightarrow t\triangleright f)\bef g=x\rightarrow g(t\triangleright f)=x\rightarrow(t\triangleright f\triangleright g)=x\rightarrow t\triangleright f\bef g\quad.
\]

\end_inset

The function arrow groups weaker than the pipe operator: 
\begin_inset Formula $x\rightarrow t\triangleright f\bef g=x\rightarrow(t\triangleright f\bef g)$
\end_inset

.
\end_layout

\begin_layout Standard
How can we verify this and other similar computations where the operations
 
\begin_inset Formula $\triangleright$
\end_inset

 and 
\begin_inset Formula $\bef$
\end_inset

 are combined in some way? Instead of memorizing a large set of identities,
 we can rely on knowing only one rule that says how arguments are symbolically
 substituted as parameters into functions, for example:
\begin_inset Formula 
\begin{align*}
\text{substitute }x\text{ instead of }a:\quad & \gunderline x\triangleright(\gunderline a\rightarrow f(\gunderline a))=f(x)\quad.\\
\text{substitute }f(x)\text{ instead of }y:\quad & (x\rightarrow\gunderline{f(x)})\bef(\gunderline y\rightarrow g(\gunderline y))=x\rightarrow g(f(x))\quad.
\end{align*}

\end_inset

Whenever there is a doubt (is 
\begin_inset Formula $x\triangleright(f\triangleright g)$
\end_inset

 or 
\begin_inset Formula $(x\bef f)\triangleright g$
\end_inset

 the correct formula?), one can write functions in an expanded form (writing
 
\begin_inset Formula $x\rightarrow f(x)$
\end_inset

 instead of 
\begin_inset Formula $f$
\end_inset

) and perform calculations more verbosely.
 After getting some experience with the 
\begin_inset Formula $\triangleright$
\end_inset

 and 
\begin_inset Formula $\bef$
\end_inset

 operations, the reader will start using them more freely without writing
 functions in expanded form.
\end_layout

\begin_layout Standard
The matrix notation is adapted to the pipe operation and the forward function
 composition.
 As an example, let us write the composition of the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

compute
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

get[Int]
\end_layout

\end_inset

 shown above: 
\begin_inset Formula 
\begin{align*}
 & \text{compute}\bef\text{get}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0 & \_\rightarrow100\\
\text{Int} & \bbnum 0 & x\rightarrow\frac{x}{2}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & \text{Int}\\
\hline \bbnum 1 & \bbnum 0\\
\text{Int} & \text{id}
\end{array}\\
 & \quad=\,\begin{array}{|c||c|}
 & \text{Int}\\
\hline \bbnum 1 & (\_\rightarrow100)\bef\text{id}\\
\text{Int} & (x\rightarrow\frac{x}{2})\bef\text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & \text{Int}\\
\hline \bbnum 1 & \_\rightarrow100\\
\text{Int} & x\rightarrow\frac{x}{2}
\end{array}\quad.
\end{align*}

\end_inset

In such computations, we use the standard rules of matrix multiplication
 but apply the composition (
\begin_inset Formula $\bef$
\end_inset

) instead of the multiplication of matrix elements.
\end_layout

\begin_layout Standard
Why do the matrix multiplication rules work for function compositions? The
 reason is the equivalence 
\begin_inset Formula $x\triangleright f\triangleright g=x\triangleright f\bef g$
\end_inset

.
 We have defined the matrix form of functions to work with the 
\begin_inset Quotes eld
\end_inset

row-vector
\begin_inset Quotes erd
\end_inset

 form of disjunctive types, i.e., for the computation 
\begin_inset Formula $x\triangleright f$
\end_inset

 (where 
\begin_inset Formula $x$
\end_inset

 is a row vector representing a value of a disjunctive type).
 The result of computing 
\begin_inset Formula $x\triangleright f$
\end_inset

 is again a row vector, which we can pipe into another matrix 
\begin_inset Formula $g$
\end_inset

 as 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

.
 The standard rules of matrix multiplication make it associative.
 So, the result of 
\begin_inset Formula $x\triangleright f\triangleright g$
\end_inset

 is the same as the result of piping 
\begin_inset Formula $x$
\end_inset

 into the matrix product of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

.
 Therefore, the matrix product of 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 will yield the function 
\begin_inset Formula $f\bef g$
\end_inset

.
\end_layout

\begin_layout Standard
A function that does not take or return disjunctive types may be written
 as a 
\begin_inset Formula $1\times1$
\end_inset

 matrix, so its composition with disjunctive functions can be computed via
 the same rules.
 
\end_layout

\begin_layout Subsection
Functor and contrafunctor liftings
\end_layout

\begin_layout Standard
Functions and function compositions lifted to a functor (or to a contrafunctor)
 are used in derivations so often that the notation 
\begin_inset Formula $x\triangleright\text{fmap}_{F}(f)$
\end_inset

 and its Scala analog 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.map(f)
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 are not short enough.
 This book uses the notation 
\begin_inset Formula $x\triangleright f^{\uparrow F}$
\end_inset

 for functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $x\triangleright f^{\downarrow C}$
\end_inset

 for contrafunctors 
\begin_inset Formula $C$
\end_inset

.
 This notation graphically emphasizes the function 
\begin_inset Formula $f$
\end_inset

 being lifted and also shows the name of the relevant functors or contrafunctors.
 Compositions of lifted functions are visually easy to recognize, for example:
\begin_inset Formula 
\[
f^{\downarrow H}\bef g^{\downarrow H}=\left(g\bef f\right)^{\downarrow H}\quad,\quad\quad f^{\uparrow L}\bef g^{\uparrow L}\bef h^{\uparrow L}=\left(f\bef g\bef h\right)^{\uparrow L}\quad.
\]

\end_inset

In these formulas, the labels 
\begin_inset Formula $^{\downarrow H}$
\end_inset

 and 
\begin_inset Formula $^{\uparrow L}$
\end_inset

 clearly suggest that we may pull several functions under a single lifting.
 We may also split a lifted composition into a composition of liftings.
 
\end_layout

\begin_layout Standard
The lifting notation helps us recognize that those steps are possible more
 easily, just by looking at the formula.
 Of course, we still need to find a useful sequence of steps in a given
 derivation or proof.
\end_layout

\begin_layout Section
Derivation techniques
\end_layout

\begin_layout Subsection
Standard functions for working with products
\end_layout

\begin_layout Standard
The functions denoted by 
\begin_inset Formula $\pi_{1}$
\end_inset

, 
\begin_inset Formula $\pi_{2}$
\end_inset

, 
\begin_inset Formula $\Delta$
\end_inset

, and 
\begin_inset Formula $\boxtimes$
\end_inset

 proved to be helpful in derivations that involve tuples.
 (However, the last two functions are unlikely to be frequently used in
 practical programming.) 
\end_layout

\begin_layout Standard
We already saw the definition and the code for the functions 
\begin_inset Formula $\pi_{1}$
\end_inset

 and 
\begin_inset Formula $\pi_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

diagonal
\begin_inset Quotes erd
\end_inset

 function (
\begin_inset Formula $\Delta$
\end_inset

) is defined by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def delta[A]: A => (A, A) = { x => (x, x) }
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
\Delta^{A}:A\rightarrow A\times A\quad,\quad\quad\Delta\triangleq a^{:A}\rightarrow a\times a\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
It is clear that extracting any part of a pair 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delta(x) == (x, x)
\end_layout

\end_inset

 will give back the original 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

.
 This property can be written via equations or 
\begin_inset Quotes eld
\end_inset

laws
\begin_inset Quotes erd
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

delta(x)._1 == x   and   delta(x)._2 == x
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
\pi_{1}(\Delta(x))=x\quad,\quad\quad\pi_{2}(\Delta(x))=x\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
We can transform these laws into point-free equations.
 First, use the pipe notation:
\begin_inset Formula 
\[
\pi_{1}(\Delta(x))=(\Delta(x))\triangleright\pi_{1}=x\triangleright\Delta\triangleright\pi_{1}=x\triangleright\Delta\bef\pi_{1}\quad,
\]

\end_inset

which gives the equation 
\begin_inset Formula $x\triangleright\Delta\bef\pi_{1}=x=x\triangleright\text{id}$
\end_inset

.
 Then we omit 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x\,\triangleright$
\end_inset


\begin_inset Quotes erd
\end_inset

 and obtain a point-free equation: 
\begin_inset Formula 
\begin{align}
\Delta\text{ is a right inverse of }\pi_{1}:\quad & \Delta\bef\pi_{1}=\text{id}\quad.\label{eq:pair-identity-law-left}
\end{align}

\end_inset

The same property holds for 
\begin_inset Formula $\pi_{2}$
\end_inset

, namely: 
\begin_inset Formula $\Delta\bef\pi_{2}=\text{id}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pair product of functions|textit
\end_layout

\end_inset


\series bold
pair product
\series default
 operation 
\begin_inset Formula $f\boxtimes g$
\end_inset

 is defined for any functions 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 by:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pairProduct[A, B, P, Q](f: A => P, g: B => Q): ((A, B)) => (P, Q) =
 {
\end_layout

\begin_layout Plain Layout

    case (a, b) => (f(a), g(b))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
f\boxtimes g:A\times B\rightarrow P\times Q\quad,\quad\quad f\boxtimes g\triangleq a\times b\rightarrow f(a)\times g(b)\quad.
\]

\end_inset

Some  properties of this operation follow directly from its definition:
\begin_inset Index idx
status open

\begin_layout Plain Layout
composition law!of pair product
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
identity laws!of pair product
\end_layout

\end_inset


\begin_inset Formula 
\begin{align}
\text{composition law}:\quad & (f^{:A\rightarrow P}\boxtimes g^{:B\rightarrow Q})\bef(m^{:P\rightarrow X}\boxtimes n^{:Q\rightarrow Y})=(f\bef m)\boxtimes(g\bef n)\quad,\label{eq:pair-product-composition-law}\\
\text{left projection law}:\quad & (f^{:A\rightarrow P}\boxtimes g^{:B\rightarrow Q})\bef\pi_{1}=\pi_{1}\bef f\quad,\label{eq:pair-product-left-projection-law}\\
\text{right projection law}:\quad & (f^{:A\rightarrow P}\boxtimes g^{:B\rightarrow Q})\bef\pi_{2}=\pi_{2}\bef g\quad,\label{eq:pair-product-right-projection-law}\\
\text{identity law}:\quad & \text{id}^{A}\boxtimes\text{id}^{B}=\text{id}^{A\times B}\quad.\nonumber 
\end{align}

\end_inset

An equivalent way of defining 
\begin_inset Formula $f\boxtimes g$
\end_inset

 is via this Scala code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def pairProduct[A, B, P, Q](f: A => P, g: B => Q)(p: (A, B)): (P, Q) =
\end_layout

\begin_layout Plain Layout

  (f(p._1), g(p._2))
\end_layout

\end_inset


\begin_inset Formula 
\[
f\boxtimes g=p^{:A\times B}\rightarrow f(p\triangleright\pi_{1})\times g(p\triangleright\pi_{2})=p\rightarrow(p\triangleright\pi_{1}\triangleright f)\times(p\triangleright\pi_{2}\triangleright g)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
The pair product notation can shorten calculations with functors that involve
 product types (tuples).
 For example, the lifting for the functor 
\begin_inset Formula $F^{A}\triangleq A\times A\times Z$
\end_inset

 can be shortened to:
\begin_inset Formula 
\[
f^{\uparrow F}\triangleq\big(a_{1}^{:A}\times a_{2}^{:A}\times z^{:Z}\rightarrow f(a_{1})\times f(a_{2})\times z\big)=f\boxtimes f\boxtimes\text{id}\quad.
\]

\end_inset

The last formula is often more convenient in symbolic derivations.
 
\end_layout

\begin_layout Subsection
Deriving laws for functions with known implementations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Deriving-laws-for-functions-"

\end_inset


\end_layout

\begin_layout Standard
We will often need to prove a given law (an equation) for a function whose
 code is known.
 An example of such an equation is the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of the function 
\begin_inset Formula $\Delta$
\end_inset


\end_layout

\end_inset

naturality law of 
\begin_inset Formula $\Delta$
\end_inset

, which states that for any function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 we have:
\begin_inset Formula 
\begin{equation}
f\bef\Delta=\Delta\bef(f\boxtimes f)\quad.\label{eq:naturality-law-of-Delta}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Laws for fully parametric functions are often written without type annotations.
 However, it is important to check that types match.
 So, we begin by finding suitable type parameters for Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-Delta"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Since it is given that 
\begin_inset Formula $f$
\end_inset

 has type 
\begin_inset Formula $A\rightarrow B$
\end_inset

, the function 
\begin_inset Formula $\Delta$
\end_inset

 in the left-hand side of Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:naturality-law-of-Delta"
plural "false"
caps "false"
noprefix "false"

\end_inset

) must take arguments of type 
\begin_inset Formula $B$
\end_inset

 and thus returns a value of type 
\begin_inset Formula $B\times B$
\end_inset

.
 We see that the left-hand side must be a function of type 
\begin_inset Formula $A\rightarrow B\times B$
\end_inset

.
 So, the 
\begin_inset Formula $\Delta$
\end_inset

 in the right-hand side must take an argument of type 
\begin_inset Formula $A$
\end_inset

.
 It then returns a value of type 
\begin_inset Formula $A\times A$
\end_inset

, which is consumed by 
\begin_inset Formula $f\boxtimes f$
\end_inset

.
 In this way, we see that all types match.
 We can put the resulting types into a type diagram and write the law with
 type annotations:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.6pc}\xyScaleX{4.0pc}A\ar[d]\sb(0.45){f}\ar[r]\sp(0.45){\Delta^{A}} & A\times A\ar[d]\sp(0.45){f\boxtimes f}\\
B\ar[r]\sp(0.45){\Delta^{B}} & B\times B
}
\]

\end_inset


\begin_inset Formula 
\[
f^{:A\rightarrow B}\bef\Delta^{:B\rightarrow B\times B}=\Delta^{:A\rightarrow A\times A}\bef(f\boxtimes f)\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
To prove the law, we need to use the known code of the function 
\begin_inset Formula $\Delta$
\end_inset

.
 We substitute that code into the left-hand side of the law and into the
 right-hand side of the law, hoping to transform those two expressions until
 they are the same.
\end_layout

\begin_layout Standard
We perform this derivation in the Scala syntax and in the code notation:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x.pipe(f andThen delta)
\end_layout

\begin_layout Plain Layout

  == (f(x)).pipe { a => (a, a) }
\end_layout

\begin_layout Plain Layout

  == (f(x), f(x)) // Left-hand side.
\end_layout

\begin_layout Plain Layout

x.pipe(delta andThen { case (a, b) => (f(a), f(b)) })
\end_layout

\begin_layout Plain Layout

  == (x, x).pipe { case (a, b) => (f(a), f(b)) }
\end_layout

\begin_layout Plain Layout

  == (f(x), f(x)) // Right-hand side.
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & x\triangleright f\bef\Delta=f(x)\,\gunderline{\triangleright\,(b}\rightarrow b\times b)=f(x)\times f(x)\quad.\\
 & \gunderline{x\triangleright\Delta}\,\bef(f\boxtimes f)=(x\times x)\gunderline{\,\triangleright\,(a\times b}\rightarrow f(a)\times f(b))=f(x)\times f(x)\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
At each step of the derivation, there is often only one symbolic transformation
 we can perform.
 In the example above, each step either substitutes a definition of a known
 function or applies some function to an argument and computes the result.
 To help us remember what was done, we use a green underline as a hint indicatin
g a sub-expression to be modified in that step.
 
\end_layout

\begin_layout Standard
We will prefer to derive laws in the code notation rather than in Scala
 syntax.
 The code notation covers all fully parametric code, i.e., all programs that
 use only the nine basic code constructions.
\end_layout

\begin_layout Subsection
Working with disjunctive types in matrix notation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Working-with-disjunctive-functions"

\end_inset


\end_layout

\begin_layout Standard
The matrix notation provides a general way of performing symbolic derivations
 with disjunctive types in point-free style (the matrix elements are 
\emph on
functions
\emph default
).
 Writing all code matrices with type annotations makes it easier to translate
 between matrices and Scala code.
\end_layout

\begin_layout Standard
In many cases, the rules of matrix multiplication and function composition
 are sufficient for calculating with disjunctive types.
 For example, consider the following functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap[A]
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge[A]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap[A]: Either[A, A] => Either[A, A] = {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => Right(a)
\end_layout

\begin_layout Plain Layout

    case Right(a)   => Left(a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

def merge[A]: Either[A, A] => A = {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => a
\end_layout

\begin_layout Plain Layout

    case Right(a)   => a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
\text{swap}^{A}\triangleq\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & \bbnum 0 & \text{id}\\
A & \text{id} & \bbnum 0
\end{array}\quad,~\quad\text{merge}^{A}\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
Matrix composition proves that 
\begin_inset Formula $\text{swap}\bef\text{swap}=\text{id}$
\end_inset

 and 
\begin_inset Formula $\text{swap}\bef\text{merge}=\text{merge}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \text{swap}\bef\text{swap}=\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\\
\text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\\
\text{id} & \bbnum 0
\end{array}\,=\,\begin{array}{||cc|}
\text{id}\bef\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}\bef\text{id}
\end{array}\,=\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & \text{id}
\end{array}\,=\text{id}\quad,\\
 & \text{swap}\bef\text{merge}=\,\begin{array}{||cc|}
\bbnum 0 & \text{id}\\
\text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,=\,\begin{array}{||c|}
\text{id}\bef\text{id}\\
\text{id}\bef\text{id}
\end{array}\,=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,=\text{merge}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The identity function for any disjunctive type, e.g., 
\begin_inset Formula $A+B+C$
\end_inset

, is the 
\begin_inset Quotes eld
\end_inset

identity diagonal
\begin_inset Quotes erd
\end_inset

 matrix
\begin_inset Index idx
status open

\begin_layout Plain Layout
identity matrix
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{id}^{:A+B+C\rightarrow A+B+C}=\,\begin{array}{|c||ccc|}
 & A & B & C\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
B & \bbnum 0 & \text{id} & \bbnum 0\\
C & \bbnum 0 & \bbnum 0 & \text{id}
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
As another example, consider the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 for the functor 
\begin_inset Formula $E^{A}\triangleq A+A$
\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[A, B](f: A => B): Either[A, A] => Either[B, B] = {
\end_layout

\begin_layout Plain Layout

    case Left(a)    => Left(f(a))
\end_layout

\begin_layout Plain Layout

    case Right(a)   => Right(f(a))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow E}\triangleq\,\begin{array}{|c||cc|}
 & B & B\\
\hline A & f & \bbnum 0\\
A & \bbnum 0 & f
\end{array}\quad.
\]

\end_inset


\end_layout

\begin_layout Standard
With this definition, we can formulate a law of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 called the 
\begin_inset Quotes eld
\end_inset

naturality law
\begin_inset Index idx
status open

\begin_layout Plain Layout
naturality law!of 
\family typewriter
merge
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.6pc}\xyScaleX{4.0pc}A+A\ar[d]\sb(0.45){f^{\uparrow E}}\ar[r]\sp(0.55){\text{merge}^{A}} & A\ar[d]\sp(0.45){f}\\
B+B\ar[r]\sp(0.55){\text{merge}^{B}} & B
}
\]

\end_inset


\begin_inset Formula 
\[
(f^{:A\rightarrow B})^{\uparrow E}\bef\text{merge}^{B}=\text{merge}^{A}\bef f^{:A\rightarrow B}\quad.
\]

\end_inset

Proving this law is a short matrix calculation:
\begin_inset Formula 
\begin{align*}
\text{left-hand side}:\quad & f^{\uparrow E}\bef\text{merge}=\,\begin{array}{||cc|}
f & \bbnum 0\\
\bbnum 0 & f
\end{array}\,\bef\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,=\,\begin{array}{||c|}
f\bef\text{id}\\
f\bef\text{id}
\end{array}\,=\,\begin{array}{||c|}
f\\
f
\end{array}\quad,\\
\text{right-hand side}:\quad & \text{merge}\bef f=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,\bef\gunderline f=\,\begin{array}{||c|}
\text{id}\\
\text{id}
\end{array}\,\bef\,\begin{array}{||c|}
f\end{array}\,=\,\begin{array}{||c|}
\text{id}\bef f\\
\text{id}\bef f
\end{array}\,=\,\begin{array}{||c|}
f\\
f
\end{array}\quad.
\end{align*}

\end_inset

In the last line we replaced 
\begin_inset Formula $f$
\end_inset

 by a 
\begin_inset Formula $1\times1$
\end_inset

 matrix, 
\begin_inset Formula $\,\begin{array}{||c|}
f\end{array}$
\end_inset


\begin_inset space ~
\end_inset

, in order to apply matrix composition.
\end_layout

\begin_layout Standard
Matrix rows and columns can be split or merged when necessary to accommodate
 various disjunctive types.
 As an example, let us verify the 
\series bold
associativity law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
associativity law!of 
\family typewriter
merge
\end_layout

\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{4.5pc}E^{A+A}\ar[d]\sb(0.45){\text{merge}^{\uparrow E}}\ar[r]\sp(0.55){\text{merge}^{A+A}} & A+A\ar[d]\sp(0.45){\text{merge}^{A}}\\
E^{A}\ar[r]\sb(0.55){\text{merge}^{A}} & A
}
\]

\end_inset


\begin_inset Formula 
\[
(\text{merge}^{A})^{\uparrow E}\bef\text{merge}^{A}=\text{merge}^{A+A}\bef\text{merge}^{A}\quad.
\]

\end_inset

Both sides of this law are functions of type 
\begin_inset Formula $A+A+A+A\rightarrow A$
\end_inset

.
 To transform the left-hand side, we use the definition of 
\begin_inset Formula $^{\uparrow E}$
\end_inset

 and write:
\begin_inset Formula 
\[
\text{merge}^{\uparrow E}\bef\text{merge}=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A+A & \text{merge} & \bbnum 0\\
A+A & \bbnum 0 & \text{merge}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A+A & \text{merge}\\
A+A & \text{merge}
\end{array}\quad.
\]

\end_inset

However, we have not yet substituted the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

 into the matrix.
 To do that, add more rows to the matrix in order to accommodate the disjunctive
 type 
\begin_inset Formula $(A+A)+(A+A)$
\end_inset

:
\begin_inset Formula 
\[
\text{merge}^{\uparrow E}\bef\text{merge}=\,\begin{array}{|c||c|}
 & A\\
\hline A+A & \text{merge}\\
A+A & \text{merge}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}\\
A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset

Now we compute the right-hand side of the law by substituting the code of
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

:
\begin_inset Formula 
\[
\text{merge}^{A+A}\bef\text{merge}^{A}=\,\begin{array}{|c||c|}
 & A+A\\
\hline A+A & \text{id}\\
A+A & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset

We cannot proceed with matrix composition because the dimensions of the
 matrices do not match.
 We need to expand the rows and the columns of the first matrix.
 Then we can finish the proof of the law:
\begin_inset Formula 
\[
\begin{array}{|c||c|}
 & A+A\\
\hline A+A & \text{id}\\
A+A & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & A\\
\hline A & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}\\
A & \text{id} & \bbnum 0\\
A & \bbnum 0 & \text{id}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
A & \text{id}\\
A & \text{id}\\
A & \text{id}
\end{array}\quad.
\]

\end_inset

The matrix notation helps visualize how various types are transformed by
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

merge
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In some cases, we cannot fully split the rows or the columns of a matrix.
 For instance, if we are calculating with an arbitrary function 
\begin_inset Formula $f^{:\bbnum 1+A\rightarrow\bbnum 1+B}$
\end_inset

, we cannot write that function in a form of a 
\begin_inset Formula $2\times2$
\end_inset

 matrix because we do not know which parts of the disjunction are returned
 (the code of the function 
\begin_inset Formula $f$
\end_inset

 is arbitrary and unknown).
 At most, we could split the 
\emph on
rows
\emph default
 by expressing the function 
\begin_inset Formula $f$
\end_inset

 through two unknown functions 
\begin_inset Formula $g^{:\bbnum 1\rightarrow\bbnum 1+B}$
\end_inset

 and 
\begin_inset Formula $h^{:A\rightarrow\bbnum 1+B}$
\end_inset

:
\begin_inset Formula 
\[
f=\,\begin{array}{|c||c|}
 & \bbnum 1+B\\
\hline \bbnum 1 & g\\
A & h
\end{array}\quad.
\]

\end_inset

The single column of this matrix remains unsplit.
 Either that column will remain unsplit throughout the derivation, or additional
 information about 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $g$
\end_inset

, or 
\begin_inset Formula $h$
\end_inset

 will allow us to split that column.
\end_layout

\begin_layout Standard
Finally, there are two tricks that complement the matrix intuition and may
 sometimes simplify a disjunctive function.
\begin_inset Foot
status open

\begin_layout Plain Layout
These tricks are adapted from Section
\begin_inset space ~
\end_inset

2.8 of the book 
\begin_inset Quotes eld
\end_inset

Program design by calculation
\begin_inset Quotes erd
\end_inset

 (draft from October 2019), see 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "http://www4.di.uminho.pt/~jno/ps/pdbc.pdf"

\end_inset


\family default
 for the latest version.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ignored arguments
\end_layout

\begin_layout Standard
If all rows of the disjunctive function ignore their arguments and if all
 rows return the same result, we may collapse all the rows into one, as
 shown in this example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def same[A]: Either[A, Option[A]] => Option[A] = {
\end_layout

\begin_layout Plain Layout

    case Left(a)          => None
\end_layout

\begin_layout Plain Layout

    case Right(None)      => None
\end_layout

\begin_layout Plain Layout

    case Right(Some(a))   => None
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
\text{same}^{:A+\bbnum 1+A\rightarrow\bbnum 1+A}\triangleq\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline A & \_\rightarrow1 & \bbnum 0\\
\bbnum 1 & \_\rightarrow1 & \bbnum 0\\
A & \_\rightarrow1 & \bbnum 0
\end{array}=\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline A+\bbnum 1+A & \_\rightarrow1 & \bbnum 0
\end{array}\,=\_\rightarrow1+\bbnum 0^{:A}\quad.
\]

\end_inset

There is a more general formula for arbitrary functions 
\begin_inset Formula $f^{:X\rightarrow C}$
\end_inset

 containing this code:
\begin_inset Formula 
\begin{align*}
\text{the value }p\text{ is ignored}:\quad & x^{:X}\rightarrow p^{:A+B}\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & \_\rightarrow f(x)\\
B & \_\rightarrow f(x)
\end{array}\,=x^{:X}\rightarrow f(x)=f\quad.
\end{align*}

\end_inset

The code matrix is replaced by an ordinary (non-disjunctive) function.
\end_layout

\begin_layout Paragraph
Simplification of diagonal pair products
\end_layout

\begin_layout Standard
Consider the pair product of two disjunctive functions such as 
\begin_inset Formula $f^{:A+B\rightarrow R}$
\end_inset

 and 
\begin_inset Formula $g^{:P+Q\rightarrow S}$
\end_inset

.
 Computing 
\begin_inset Formula $f\boxtimes g$
\end_inset

 in the matrix notation requires, in general, to split the rows and the
 columns of the matrices because the input type of 
\begin_inset Formula $f\boxtimes g$
\end_inset

 is disjunctive:
\begin_inset Formula 
\begin{align*}
f\boxtimes g & :(A+B)\times(P+Q)\rightarrow R\times S\\
 & \cong A\times P+A\times Q+B\times P+B\times Q\rightarrow R\times S\quad.
\end{align*}

\end_inset

So, 
\emph on
in general
\emph default
 the pair product 
\begin_inset Formula $f\boxtimes g$
\end_inset

 must be written as a 
\begin_inset Formula $4\times1$
\end_inset

 matrix:
\begin_inset Formula 
\[
\text{if }f\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline A & f_{1}\\
B & f_{2}
\end{array}\quad\text{and}\quad g\triangleq\,\begin{array}{|c||c|}
 & S\\
\hline P & g_{1}\\
Q & g_{2}
\end{array}\quad\quad\text{then}\quad f\boxtimes g=\,\begin{array}{|c||c|}
 & R\times S\\
\hline A\times P & f_{1}\boxtimes g_{1}\\
A\times Q & f_{1}\boxtimes g_{2}\\
B\times P & f_{2}\boxtimes g_{1}\\
B\times Q & f_{2}\boxtimes g_{2}
\end{array}\quad.
\]

\end_inset

A simplification trick exists when 
\begin_inset Formula $f\boxtimes g$
\end_inset

 is composed with the diagonal function 
\begin_inset Formula $\Delta$
\end_inset

:
\begin_inset Formula 
\[
\Delta\bef(f\boxtimes g)=\Delta^{:A+B\rightarrow(A+B)\times(A+B)}\bef(f^{:A+B\rightarrow R}\boxtimes g^{:A+B\rightarrow S})=p\rightarrow f(p)\times g(p)\quad.
\]

\end_inset

This 
\begin_inset Quotes eld
\end_inset

diagonal pair product
\begin_inset Quotes erd
\end_inset

 is well-typed only if 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 have the same argument types.
 It turns out that the function 
\begin_inset Formula $\Delta\bef(f\boxtimes g)$
\end_inset

 can be written as a 
\begin_inset Formula $2\times1$
\end_inset

 matrix, i.e., we do not need to split the rows:
\begin_inset Formula 
\[
\text{if }f\triangleq\,\begin{array}{|c||c|}
 & R\\
\hline A & f_{1}\\
B & f_{2}
\end{array}\quad\text{and}\quad g\triangleq\,\begin{array}{|c||c|}
 & S\\
\hline A & g_{1}\\
B & g_{2}
\end{array}\quad\text{then}\quad\Delta\bef(f\boxtimes g)=\,\begin{array}{|c||c|}
 & R\times S\\
\hline A & \Delta\bef(f_{1}\boxtimes g_{1})\\
B & \Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\quad.
\]

\end_inset

The rules of matrix multiplication do not help in deriving this law directly.
 So, we use a more basic approach: show that both sides are equal when applied
 to arbitrary values 
\begin_inset Formula $p$
\end_inset

 of type 
\begin_inset Formula $A+B$
\end_inset

:
\begin_inset Formula 
\[
p^{:A+B}\triangleright\Delta\bef(f\boxtimes g)=f(p)\times g(p)\overset{?}{=}p\triangleright\,\begin{array}{|c||c|}
 & R\times S\\
\hline A & \Delta\bef(f_{1}\boxtimes g_{1})\\
B & \Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\quad.
\]

\end_inset

The type 
\begin_inset Formula $A+B$
\end_inset

 has two cases.
 Applying the left-hand side to 
\begin_inset Formula $p\triangleq a^{:A}+\bbnum 0^{:B}$
\end_inset

, we get:
\begin_inset Formula 
\begin{align*}
 & f(p)\times g(p)=\big((a^{:A}+\bbnum 0^{:B})\triangleright f\big)\times\big((a^{:A}+\bbnum 0^{:B})\triangleright g\big)\\
 & \quad=\big(\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
f_{1}\\
f_{2}
\end{array}\,\big)\times\big(\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
g_{1}\\
g_{2}
\end{array}\,\big)=\big(a\triangleright f_{1}\big)\times\big(a\triangleright g_{1}\big)=f_{1}(a)\times g_{1}(a)\quad.
\end{align*}

\end_inset

Applying the right-hand side to the same 
\begin_inset Formula $p$
\end_inset

, we write:
\begin_inset Formula 
\begin{align*}
 & \quad\quad\text{expect to equal }f_{1}(a)\times g_{1}(a):\quad\\
 & \gunderline p\triangleright\,\begin{array}{||c|}
\Delta\bef(f_{1}\boxtimes g_{1})\\
\Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\,=\,\begin{array}{|cc|}
a & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
\Delta\bef(f_{1}\boxtimes g_{1})\\
\Delta\bef(f_{2}\boxtimes g_{2})
\end{array}\,=\gunderline{a\triangleright\Delta}\,\bef(f_{1}\boxtimes g_{1})\\
 & \quad\quad\text{definition of }\Delta:\quad\\
 & \quad=(a\times a)\triangleright(f_{1}\boxtimes g_{1})=f_{1}(a)\times g_{1}(a)\quad.
\end{align*}

\end_inset

A similar calculation with 
\begin_inset Formula $p\triangleq\bbnum 0^{:A}+b^{:B}$
\end_inset

 shows that both sides of the law are equal to 
\begin_inset Formula $f_{2}(b)\times g_{2}(b)$
\end_inset

.
\end_layout

\begin_layout Subsection
Derivations involving unknown functions with laws
\end_layout

\begin_layout Standard
A harder task is to derive an equation that uses arbitrary functions about
 which we only know that they satisfy certain given laws.
 Such derivations usually proceed by trying to transform the code until
 the given laws can be applied.
\end_layout

\begin_layout Standard
As an example, let us derive the property that 
\begin_inset Formula $L^{A}\triangleq A\times F^{A}$
\end_inset

 is a functor if 
\begin_inset Formula $F$
\end_inset

 is known to be a functor.
 We are in the situation where we only know that the function 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

 exists and satisfies the functor laws, but we do not know the code of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

.
 Let us discover the derivation step by step.
\end_layout

\begin_layout Standard
First, we need to define 
\begin_inset Formula $\text{fmap}_{L}$
\end_inset

.
 We use the lifting notation 
\begin_inset Formula $^{\uparrow F}$
\end_inset

 and write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap_L[A, B](f: A => B): ((A, F[A])) => (B, F[B]) = {
\end_layout

\begin_layout Plain Layout

  case (a, p) => (f(a), p.map(f))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Formula 
\[
f^{\uparrow L}\triangleq a^{:A}\times p^{:F^{A}}\rightarrow f(a)\times(p\triangleright f^{\uparrow F})\quad.
\]

\end_inset

To verify the identity law of 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{id}^{\uparrow L}=a^{:A}\times p^{:F^{A}}\rightarrow\text{id}\,(a)\times(p\triangleright\text{id}^{\uparrow F})=\text{???}
\end{align*}

\end_inset

At this point, the only things we can simplify are the identity functions
 applied to arguments.
 We know that 
\begin_inset Formula $F$
\end_inset

 is a lawful functor; therefore, 
\begin_inset Formula $\text{id}^{\uparrow F}=\text{id}$
\end_inset

.
 So, we continue the derivation, omitting types:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }\text{id}:\quad & \text{id}^{\uparrow L}=a\times p\rightarrow\gunderline{\text{id}\,(a)}\times(p\triangleright\gunderline{\text{id}^{\uparrow F}})\\
\text{identity law of }F:\quad & =a\times p\rightarrow a\times(\gunderline{p\triangleright\text{id}})\\
\text{apply function}:\quad & =a\times p\rightarrow a\times p=\text{id}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To verify the composition law of 
\begin_inset Formula $L$
\end_inset

, we assume two arbitrary functions 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:B\rightarrow C}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & \quad\text{expect to equal }(f\bef g)^{\uparrow L}:\quad\\
 & f^{\uparrow L}\bef g^{\uparrow L}=\big(a\times p\rightarrow f(a)\times f^{\uparrow F}(p)\big)\bef\big(b\times q\rightarrow g(b)\times g^{\uparrow F}(q)\big)\quad.
\end{align*}

\end_inset

At this point, we pause and try to see how we might proceed.
 We do not know anything about 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

, so we cannot evaluate 
\begin_inset Formula $f(a)$
\end_inset

 or 
\begin_inset Formula $f^{\uparrow F}(p)$
\end_inset

.
 We also do not have the code of 
\begin_inset Formula $^{\uparrow F}$
\end_inset

 (i.e., of 
\begin_inset Formula $\text{fmap}_{F}$
\end_inset

).
 The only information we have about these functions is that 
\begin_inset Formula $F$
\end_inset

's composition law holds:
\begin_inset Formula 
\begin{equation}
f^{\uparrow F}\bef g^{\uparrow F}=(f\bef g)^{\uparrow F}\quad.\label{eq:composition-law-F-derivation1}
\end{equation}

\end_inset

We could make use of this law only if we somehow brought 
\begin_inset Formula $f^{\uparrow F}$
\end_inset

 and 
\begin_inset Formula $g^{\uparrow F}$
\end_inset

 together in the formula.
 The only way forward is to compute the function composition of the two
 functions whose code we 
\emph on
do
\emph default
 have:
\begin_inset Formula 
\begin{align*}
 & \big(a\times p\rightarrow f(a)\times f^{\uparrow F}(p)\big)\bef\big(b\times q\rightarrow g(b)\times g^{\uparrow F}(q)\big)\\
 & =a\times p\rightarrow g(f(a))\times g^{\uparrow F}(f^{\uparrow F}(p))\quad.
\end{align*}

\end_inset

In order to use the law
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:composition-law-F-derivation1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), we need to rewrite this code via the composition 
\begin_inset Formula $f\bef g$
\end_inset

.
 We notice that the formula contains exactly those function compositions:
\begin_inset Formula 
\[
g(f(a))\times g^{\uparrow F}(f^{\uparrow F}(p))=(a\triangleright f\bef g)\times(p\triangleright f^{\uparrow F}\bef g^{\uparrow F})\quad.
\]

\end_inset

So, we can now apply the composition law of 
\begin_inset Formula $F$
\end_inset

 and write up the complete derivation, adding hints:
\begin_inset Formula 
\begin{align*}
\text{expect to equal }(f\bef g)^{\uparrow L}:\quad & f^{\uparrow L}\bef g^{\uparrow L}\\
 & =\big(a\times p\rightarrow f(a)\times f^{\uparrow F}(p)\big)\bef\big(b\times q\rightarrow g(b)\times g^{\uparrow F}(q)\big)\\
\text{compute composition}:\quad & =a\times p\rightarrow\gunderline{g(f(a))}\times\gunderline{g^{\uparrow F}(f^{\uparrow F}(p))}\\
\triangleright\text{-notation}:\quad & =a\times p\rightarrow(a\triangleright f\bef g)\times\big(p\triangleright\gunderline{f^{\uparrow F}\bef g^{\uparrow F}}\big)\\
\text{composition law of }F:\quad & =a\times p\rightarrow(a\triangleright\gunderline{f\bef g})\times\big(p\triangleright(\gunderline{f\bef g})^{\uparrow F}\big)\\
\text{definition of }^{\uparrow L}:\quad & =(f\bef g)^{\uparrow L}\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The derivation becomes shorter if we use the pair product (
\begin_inset Formula $\boxtimes$
\end_inset

) to define 
\begin_inset Formula $^{\uparrow L}$
\end_inset

:
\begin_inset Formula 
\[
f^{\uparrow L}\triangleq\text{id}\boxtimes f^{\uparrow F}\quad.
\]

\end_inset

For instance, verifying the identity law then looks like this:
\begin_inset Formula 
\[
\text{id}^{\uparrow L}=\text{id}\boxtimes\text{id}^{\uparrow F}=\text{id}\boxtimes\text{id}=\text{id}\quad.
\]

\end_inset

This technique was used in the proof of Statement
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:functor-Statement-functor-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The cost of having a shorter proof is the need to remember the properties
 of the pair product (
\begin_inset Formula $\boxtimes$
\end_inset

), which is not often used in derivations.
\end_layout

\begin_layout Subsection
Exercises
\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show using matrix calculations that 
\begin_inset Formula $\text{swap}\bef\text{swap}=\text{id}$
\end_inset

, where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap
\end_layout

\end_inset

 is the function defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Working-with-disjunctive-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Now consider a different function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

swap[A, B]
\end_layout

\end_inset

 defined as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def swap[A, B]: ((A, B)) => (B, A) = { case (a, b) => (b, a) }
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
\text{swap}^{A,B}\triangleq a^{:A}\times b^{:B}\rightarrow b\times a\quad.
\]

\end_inset

Show that 
\begin_inset Formula $\Delta\bef\text{swap}=\Delta$
\end_inset

.
 Write out all types in this law and draw a type diagram.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given an arbitrary functor 
\begin_inset Formula $F$
\end_inset

, define the functor 
\begin_inset Formula $L^{A}\triangleq F^{A}\times F^{A}$
\end_inset

 and prove, for an arbitrary function 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, the 
\begin_inset Quotes eld
\end_inset

lifted naturality
\begin_inset Quotes erd
\end_inset

 law:
\begin_inset Formula 
\[
f^{\uparrow F}\bef\Delta=\Delta\bef f^{\uparrow L}\quad.
\]

\end_inset

Write out all types in that law and draw a type diagram.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that the types 
\begin_inset Formula $(\bbnum 1+\bbnum 1)\times A$
\end_inset

 and 
\begin_inset Formula $A+A$
\end_inset

 are equivalent.
 One direction of this equivalence is given by a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

two[A]
\end_layout

\end_inset

 with the type signature:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def two[A]: ((Either[Unit, Unit], A)) => Either[A, A] = ???
\end_layout

\end_inset

Code notation:
\begin_inset Formula 
\[
\text{two}^{A}:(\bbnum 1+\bbnum 1)\times A\rightarrow A+A\quad.
\]

\end_inset

Implement that function and prove that it satisfies the 
\begin_inset Quotes eld
\end_inset

naturality law
\begin_inset Quotes erd
\end_inset

: for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
(\text{id}\boxtimes f)\bef\text{two}=\text{two}\bef f^{\uparrow E}\quad.
\]

\end_inset

Here 
\begin_inset Formula $E^{A}\triangleq A+A$
\end_inset

 is the functor whose lifting (
\begin_inset Formula $...^{\uparrow E}$
\end_inset

) was defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Working-with-disjunctive-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Write out the types in that naturality law and draw a type diagram.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Prove that the following laws hold for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

 and 
\begin_inset Formula $g^{:C\rightarrow D}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{left projection law}:\quad & (f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f\quad,\\
\text{right projection law}:\quad & (f\boxtimes g)\bef\pi_{2}=\pi_{2}\bef g\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given arbitrary functors 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, define the functor 
\begin_inset Formula $L^{A}\triangleq F^{A}\times G^{A}$
\end_inset

 and prove that for arbitrary 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

,
\begin_inset Formula 
\[
f^{\uparrow L}\bef\pi_{1}=\pi_{1}\bef f^{\uparrow F}\quad.
\]

\end_inset

Write out the types in this naturality law and draw a type diagram.
 
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Consider the functor 
\begin_inset Formula $L$
\end_inset

 defined as:
\begin_inset Formula 
\[
L^{A}\triangleq\text{Int}\times\text{Int}+A\quad.
\]

\end_inset

Implement the functions 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

) and write their code in matrix notation:
\begin_inset Formula 
\begin{align*}
(f^{:A\rightarrow B})^{\uparrow L} & :\text{Int}\times\text{Int}+A\rightarrow\text{Int}\times\text{Int}+B\quad,\\
\text{ftn}_{L} & :\text{Int}\times\text{Int}+\text{Int}\times\text{Int}+A\rightarrow\text{Int}\times\text{Int}+A\quad.
\end{align*}

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Exercise-reasoning-1-3-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-3-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Show that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatten
\end_layout

\end_inset

 (denoted 
\begin_inset Formula $\text{ftn}_{L}$
\end_inset

) from Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Exercise-reasoning-1-3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 satisfies the naturality law: for any 
\begin_inset Formula $f^{:A\rightarrow B}$
\end_inset

, we have 
\begin_inset Formula $f^{\uparrow L\uparrow L}\bef\text{ftn}_{L}=\text{ftn}_{L}\bef f^{\uparrow L}$
\end_inset

.
\end_layout

\end_body
\end_document
