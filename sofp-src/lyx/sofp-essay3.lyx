#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Use a special "equal by definition" symbol.
\renewcommand*{\triangleq}{\overset{\lower1mm\hbox{\texttt{\tiny def}}} {=}}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{} % This does not work if cleardoubleempty is given as a class option!
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}

% Better symbol for the pair mapper instead of \ogreaterthan and \varogreaterthan.
\newcommand{\boxrightarrow}{\mathbin{\ensuremath{%
\mathchoice%
  {\displaystyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\boxminus\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\textstyle{\boxminus}\kern-5.35pt\raisebox{0.75pt}{$\scriptstyle{\succ}$}}%
  {\scriptstyle{\boxminus}\kern-3.7pt\raisebox{0.49pt}{$\scriptscriptstyle{\succ}$}}%
}% end of mathchoice with raisebox
\hspace{1.0pt}}}
\renewcommand{\ogreaterthan}{\boxrightarrow}
\renewcommand{\varogreaterthan}{\boxrightarrow}
\end_preamble
\options openright,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=12pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.4cm
\topmargin 1.3cm
\rightmargin 1.4cm
\bottommargin 1.5cm
\headsep 0.5cm
\footskip 0.8cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Addchap
\begin_inset Quotes eld
\end_inset

Applied functional type theory
\begin_inset Quotes erd
\end_inset

: A proposal
\begin_inset CommandInset label
LatexCommand label
name "chap:Applied-functional-type"

\end_inset


\end_layout

\begin_layout Standard
What exactly is the extent of 
\begin_inset Quotes eld
\end_inset

theory
\begin_inset Quotes erd
\end_inset

 that a software engineer should know in order to be a proficient functional
 programmer? This book proposes an answer to that question by presenting
 a coherent body of theoretical knowledge that, in the author's view, 
\emph on
is
\emph default
 the theory that underlies the practice of functional programming and guides
 software engineers in writing code.
 This body of knowledge may be viewed as a new emerging sub-branch of computer
 science, tentatively called 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
applied functional type theory
\end_layout

\end_inset

applied functional type theory
\series default
 (AFTT).
 
\end_layout

\begin_layout Standard
In order to discover the proper scope of AFTT, this book appraises the various
 inventions made in the field of functional programming in the last 30 years,
 such as the “functional pearls” papers
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://wiki.haskell.org/Research_papers/Functional_pearls"
target "https://wiki.haskell.org/Research_papers/Functional_pearls"
literal "false"

\end_inset


\end_layout

\end_inset

 and various online tutorials, looking for theoretical material that has
 demonstrated its pragmatic usefulness.
 As a first step towards formulating AFTT from the ground up, the results
 are presented in the form of a tutorial, with motivations and rigorous
 derivations of substantially all relevant mathematical facts.
\end_layout

\begin_layout Standard
In this book, code examples are written in Scala because the author is fluent
 in that language.
 However, most of the material will work equally well in Haskell, OCaml,
 and other FP languages.
 This is because AFTT is the science of functional programming and not a
 set of tricks specific to Scala or Haskell.
 An advanced user of any functional programming language will have to face
 the same questions and struggle with the same practical issues.
\end_layout

\begin_layout Addsec
AFTT is not covered by courses in computer science
\end_layout

\begin_layout Standard
Traditional courses of computer science (algorithms and data structures,
 complexity theory, distributed systems, databases, network systems, compilers,
 operating systems) are largely not relevant to AFTT.
 Courses in programming language theory are more relevant but are not presented
 at an appropriate level.
 To an academic computer scientist, the theory behind Haskell is 
\begin_inset Quotes eld
\end_inset

System 
\begin_inset Formula $F\omega$
\end_inset


\begin_inset Quotes erd
\end_inset

, a version of 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\begin_inset Index idx
status open

\begin_layout Plain Layout
System 
\begin_inset Formula $F\omega$
\end_inset

 (Haskell)
\end_layout

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://babel.ls.fi.upm.es/~pablo/Papers/Notes/f-fw.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 That theory guided the design of the Haskell language and defines rigorously
 what a Haskell program means in a mathematical sense.
 The theory behind Scala is called the 
\begin_inset Quotes eld
\end_inset

DOT
\begin_inset Quotes erd
\end_inset

 (dependent object type) calculus.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html"

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
dependent object type (DOT) calculus
\end_layout

\end_inset

 That theory guided the design of Scala version 3.
\end_layout

\begin_layout Standard
However, a practicing Haskell or Scala programmer is not concerned with
 designing Haskell or Scala, or with proving theoretical properties of those
 languages.
 Instead, the programmer is mainly concerned with 
\emph on
using
\emph default
 a chosen programming language to write code.
 
\end_layout

\begin_layout Standard
Knowing how to prove various properties of System 
\begin_inset Formula $F\omega$
\end_inset

 or DOT will not actually help programmers to write code.
 So, these theories are outside the scope of AFTT.
 The practice of functional programming does not require graduate-level
 theoretical studies.
\end_layout

\begin_layout Standard
As an example of theoretical material that 
\emph on
is
\emph default
 within the scope of AFTT, consider applicative functors (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:8-Applicative-functors,-contrafunctors"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout
applicative functors
\end_layout

\end_inset

 It is helpful for a practicing functional programmer to be able to recognize
 and use applicative functors.
 An applicative functor is a data structure specifying declaratively some
 operations that can run independently of each other.
 Programs may combine these operations, execute them in parallel, check
 for validity, or refactor for optimization or better maintainability.
\end_layout

\begin_layout Standard
To use this functionality, the programmer must begin by checking whether
 a given data structure satisfies the laws of applicative functors.
 In a given application, the choice of a data structure may be dictated
 in part by the business logic.
 The programmer first writes down the type of that data structure and the
 code implementing the required methods.
 The programmer can then check whether the laws hold.
 The data structure and the code may need to be adjusted in order to fit
 the definition of an applicative functor and to make the laws hold.
\end_layout

\begin_layout Standard
So, the programmer needs to perform a certain amount of symbolic derivations
 before coding.
 The derivations can be done using pen and paper by writing equations in
 a concise mathematical notation.
 Once the laws are verified, the programmer proceeds to write code.
\end_layout

\begin_layout Standard
The mathematical proofs and derivations assure that the chosen data structure
 will satisfy the laws of applicative functors, no matter how the rest of
 the program is written.
 So, for example, it is assured that the relevant operations can be automaticall
y parallelized and will still work correctly.
 In this way, AFTT directly guides the programmer and helps write correct
 code.
\end_layout

\begin_layout Standard
Applicative functors were discovered by practitioners who were using Haskell
 to implement parser combinators for compilers.
 However, applicative functors are not a feature of Haskell.
 Rather, they are a design pattern that may be used in Scala or in any other
 functional programming language.
 A prominent example of an applicative functor is Apache Spark's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RDD
\end_layout

\end_inset

 data type, which is widely used for implementing large-scale parallel computati
ons.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://spark.apache.org/docs/latest/rdd-programming-guide.html"
literal "false"

\end_inset


\end_layout

\end_inset

 And yet, no standard computer science course or textbook defines applicative
 functors, motivates their laws, explores their structure on examples, or
 shows data types that are 
\emph on
not
\emph default
 applicative functors (and explains why not).
 
\end_layout

\begin_layout Addsec
AFTT is not category theory, type theory, or formal logic
\end_layout

\begin_layout Standard
One often hears that functional programming is based on category theory.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.47deg.com/blog/science-behind-functional-programming/"
literal "false"

\end_inset


\end_layout

\end_inset

 Indeed, the material shown in this book includes a (small) number of notions
 from category theory, as well as from formal logic and type theory.
 However, software engineers would not benefit from traditional academic
 courses in those subjects: their presentation is too abstract and at the
 same time lacks specific results necessary for practical programming.
 Those courses answer questions that academic mathematicians have, not questions
 that practicing functional programmers have.
\end_layout

\begin_layout Standard
There exist books intended as presentations of category theory for computer
 scientists
\begin_inset Foot
status open

\begin_layout Plain Layout
See, e.g., 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.amazon.com/dp/0262660717"

\end_inset


\family default
 or 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 or for programmers.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/hmemcpy/milewski-ctfp-pdf"

\end_inset


\end_layout

\end_inset

 However, those books do not cover certain concepts relevant to programming,
 such as applicative
\begin_inset Foot
status open

\begin_layout Plain Layout
Applicative functors are known in mathematics as 
\begin_inset Quotes eld
\end_inset

monoidal
\begin_inset Quotes erd
\end_inset

: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Monoidal_functor"

\end_inset


\end_layout

\end_inset

 or traversable functors.
 Instead, those books dwell on concepts (e.g., limits, enriched categories,
 topoi) that have no applications in practical functional programming today.
\end_layout

\begin_layout Standard
Typical questions in academic books are 
\begin_inset Quotes eld
\end_inset

Is 
\begin_inset Formula $X$
\end_inset

 an introduction rule or an elimination rule
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Does property 
\begin_inset Formula $Y$
\end_inset

 hold in non-small categories or only in the category of sets
\begin_inset Quotes erd
\end_inset

.
 Questions a Scala programmer might ask are 
\begin_inset Quotes eld
\end_inset

Can we compute a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[Z, R => A]
\end_layout

\end_inset

 from a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

R => Either[Z, A]
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Is the type constructor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] = Option[(A,A,A)]
\end_layout

\end_inset

 a monad or only an applicative functor
\begin_inset Quotes erd
\end_inset

.
 The scope of AFTT includes answering the last two questions but 
\emph on
not
\emph default
 the first two.
\end_layout

\begin_layout Standard
A software engineer hoping to understand the theory behind functional programmin
g will not find the concepts of filterable, applicative, or traversable
 functors in any currently available books on category theory, including
 books intended for programmers.
 And yet these concepts are necessary for correct implementations of the
 important and widely used operations 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

zip
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fold
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To compensate for the lack of AFTT textbooks, programmers have written many
 online tutorials, aiming to explain the theoretical concepts necessary
 for practical work.
 The term 
\begin_inset Quotes eld
\end_inset

monad tutorial
\begin_inset Quotes erd
\end_inset

 became infamous because so many were  posted online.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://www.johndcook.com/blog/2014/03/03/monads-are-hard-because/"

\end_inset


\end_layout

\end_inset

 Tutorials were also written about applicative functors, traversable functors,
 free monads, etc., showing a real unfulfilled need for presenting practice-relev
ant fragments of theory in an applied setting.
 
\end_layout

\begin_layout Standard
For example, free monads became popular in the Scala community around 2015.
 Many talks about free monads were presented at Scala engineering conferences,
 giving different implementations but never formulating rigorously the propertie
s required of a valid implementation of a free monad.
 Without knowing the required mathematical properties of free monads, a
 programmer cannot make sure that a given implementation is correct.
 However, books on category theory define free monads in a way that is unsuitabl
e for programming applications (a free monad is an adjoint functor to a
 forgetful functor from a Kleisli category to the category of sets).
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\emph on
A monad is just a monoid in the category of endofunctors.
 What's the problem?
\emph default

\begin_inset Quotes erd
\end_inset

 is a well-known joke.
\begin_inset Index idx
status open

\begin_layout Plain Layout
jokes
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fn:A-monad-is-a-monoid-in-category-of-endofunctors-big-deal"

\end_inset

 See 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/3870088/"

\end_inset


\family default
 for background information about that joke.
 A related joke is in footnote
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fn:Whats-the-big-deal-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 on page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "fn:Whats-the-big-deal-monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 Such 
\begin_inset Quotes eld
\end_inset

academic
\begin_inset Quotes erd
\end_inset

 definitions can be used neither as guidance for writing code or checking
 code correctness, nor as a conceptual explanation that a learner would
 find helpful.
\end_layout

\begin_layout Standard
Perhaps the best selection of AFTT tutorial material today can be found
 in the 
\begin_inset Quotes eld
\end_inset

Haskell Wikibooks
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikibooks.org/wiki/Haskell"
target "https://en.wikibooks.org/wiki/Haskell"
literal "false"

\end_inset


\end_layout

\end_inset

 However, those tutorials are incomplete and limited to explaining the use
 of Haskell.
 Many of them are suitable neither as a first introduction nor as a reference
 on AFTT.
 Also, the Haskell Wikibooks tutorials rarely show any derivations of laws
 or explain the required techniques.
\end_layout

\begin_layout Standard
Apart from referring to some notions of category theory, AFTT also uses
 concepts from type theory and formal logic.
 However, existing textbooks of type theory and logic focus on formal semantics,
 domain theory, and proof theory.
 From a practicing programmer's viewpoint, these books present a lot of
 difficult-to-learn material that will not help in writing code.
 At the same time, those academic books never mention the practical techniques
 used in many functional programming libraries today, such as reasoning
 about and implementing types with quantifiers, types parameterized by type
 constructors, or partial type-to-value functions (known as 
\begin_inset Quotes eld
\end_inset

typeclasses
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
The proper scope of AFTT is to help the programmer with practical tasks
 such as:
\end_layout

\begin_layout Enumerate
Deciding whether two data types are equivalent and implementing the isomorphism
 transformations.
 For example, the Scala type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(A, Either[B, C])
\end_layout

\end_inset

 is equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[(A, B), (A, C)]
\end_layout

\end_inset

, but the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => Either[B, C]
\end_layout

\end_inset

 is 
\emph on
not
\emph default
 equivalent to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Either[A => B, A => C]
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Checking whether a definition of a recursive type is 
\begin_inset Quotes eld
\end_inset

valid
\begin_inset Quotes erd
\end_inset

, i.e., does not lead to infinite loops.
 A simple example of an 
\begin_inset Quotes eld
\end_inset

invalid
\begin_inset Quotes erd
\end_inset

 recursive type definition in Scala is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class Bad(x: Bad)
\end_layout

\end_inset

.
 A small change transforms that example into a 
\begin_inset Quotes eld
\end_inset

valid
\begin_inset Quotes erd
\end_inset

 recursive type: 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

class Good(x: Option[Good])
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Deciding whether a function with a given type signature can be implemented.
 For example, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f[Z,A,R]: (R => Either[Z, A]) => Either[Z, R => A] = ???   // Cannot
 be implemented.
\end_layout

\begin_layout Plain Layout

def g[Z,A,R]: Either[Z, R => A] => (R => Either[Z, A]) = ???   // Can be
 implemented.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Deriving an implementation of a function from its type signature and checking
 required laws.
 For example, deriving the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 method and checking its laws for the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Reader
\end_layout

\end_inset

 monad:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[Z, A, B](r: Z => A)(f: A => Z => B): Z => B = ???
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Deriving a simpler but equivalent code by calculating with functions and
 laws.
\end_layout

\begin_layout Standard
These are real-world applications of type theory and the Curry-Howard correspond
ence, but existing books on type theory and logic do not give practical
 recipes for performing these tasks.
\begin_inset Foot
status open

\begin_layout Plain Layout
Task 5 is addressed in several programming-oriented books such as 
\emph on
Pearls of functional algorithm design
\emph default
 by 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Richard Bird
\end_layout

\end_inset

Richard Bird (
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "https://www.cambridge.org/9780521513388"
literal "false"

\end_inset


\family default
).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Books such as 
\emph on
Scala with Cats
\emph default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://underscore.io/books/scala-with-cats/"
target "https://underscore.io/books/scala-with-cats/"
literal "false"

\end_inset


\end_layout

\end_inset

 
\emph on
Functional programming simplified
\emph default
,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://alvinalexander.com/scala/functional-programming-simplified-book"
target "https://alvinalexander.com/scala/functional-programming-simplified-book"
literal "false"

\end_inset


\end_layout

\end_inset

 and 
\emph on
Functional programming for mortals
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www.lulu.com/shop/search.ep?contributorId=1600066"

\end_inset


\end_layout

\end_inset

 are primarily focused on explaining practical aspects of functional programming
 and do not derive the mathematical laws for, e.g., filterable, monadic, applicati
ve, or traversable functors.
\end_layout

\begin_layout Standard
The only currently available Scala-based AFTT textbook is 
\emph on
Functional Programming in Scala
\emph default
.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://www.manning.com/books/functional-programming-in-scala"
target "https://www.manning.com/books/functional-programming-in-scala"
literal "false"

\end_inset


\end_layout

\end_inset

 It balances practical coding with theoretical developments and laws.
 
\emph on
Program design by calculation
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "http://www4.di.uminho.pt/~jno/ps/pdbc.pdf"

\end_inset


\end_layout

\end_inset

 is another (Haskell-oriented) AFTT book in progress.
 The present book is written at about the same level but aims at better
 motivation for mathematical concepts and a wider range of pedagogical examples
 that help build the necessary intuition and facility with the techniques
 of formal derivation.
 
\end_layout

\begin_layout Standard
Figures
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Randomly-chosen-pages-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Randomly-chosen-pages"
plural "false"
caps "false"
noprefix "false"

\end_inset

 illustrate the difference between AFTT books, programming books, and academic
 science books, by showing randomly chosen pages from such books.
 One gets a visual impression that programming-oriented books contain code
 examples and explanations in words but no formal derivations.
 Books on AFTT, as well as books on mathematics and science, will typically
 show equations, diagrams, and derivations.
 The present book contains both code examples and mathematical proofs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpsimplified-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming simplified
\emph default
, by A.
\begin_inset space ~
\end_inset

Alexander
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpmortals-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
\begin_inset VSpace -160baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming for mortals
\emph default
, by S.
\begin_inset space ~
\end_inset

Halliday
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-volpe-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
\begin_inset VSpace -190baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Practical functional programming in Scala
\emph default
, by G.
\begin_inset space ~
\end_inset

Volpe (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://leanpub.com/pfp-scala"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kalinin-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Mastering advanced Scala
\emph default
, by D.
\begin_inset space ~
\end_inset

Kalinin (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://leanpub.com/mastering-advanced-scala"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on Scala programming.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-hefferon-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -40baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Linear algebra
\emph default
, by J.
\begin_inset space ~
\end_inset

Hefferon (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "http://joshua.smcvt.edu/linearalgebra/"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-kibble-pdf-09.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Classical mechanics
\emph default
, by T.
\begin_inset space ~
\end_inset

W.
\begin_inset space ~
\end_inset

B.
\begin_inset space ~
\end_inset

Kibble and F.
\begin_inset space ~
\end_inset

H.
\begin_inset space ~
\end_inset

Berkshire (
\family typewriter
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://archive.org/details/116772449ClassicalMechanics"
literal "false"

\end_inset


\family default
\size default
)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 60baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on mathematics and physics.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-fpis-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -0baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Functional programming in Scala
\emph default
, by P.
\begin_inset space ~
\end_inset

Chiusano and R.
\begin_inset space ~
\end_inset

Bjarnason
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-03.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-04.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-pdbc-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -70baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
Program design by calculation
\emph default
, by J.
\begin_inset space ~
\end_inset

N.
\begin_inset space ~
\end_inset

Oliveira
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-00.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-01.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-02.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-05.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-06.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-07.png
	lyxscale 20
	height 2.51cm

\end_inset


\begin_inset Graphics
	filename random-pages/random-pages-from-sofp-pdf-08.png
	lyxscale 20
	height 2.51cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -30baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\emph on
The science of functional programming
\emph default
 (this book)
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 100baselineskip%
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Randomly chosen pages from books on applied functional type theory.
\begin_inset CommandInset label
LatexCommand label
name "fig:Randomly-chosen-pages"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Addchap
Essay: Why category theory is useful in functional programming
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
category theory!in functional programming
\end_layout

\end_inset

This essay is for readers who are already somewhat familiar with category
 theory.
\end_layout

\begin_layout Addsec
A 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category for a programming language
\end_layout

\begin_layout Standard
We consider programming languages that support various data types, such
 as integers (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

), floating-point numbers (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

), strings (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

), arrays of strings (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

), and so on.
 Such languages allow programmers to define functions with specified types
 of arguments and return values.
 The compiler will then verify that all functions are always applied to
 arguments of correct types, and also that all return values have the expected
 types.
 
\end_layout

\begin_layout Standard
To each programming language of that kind, there corresponds
\begin_inset Foot
status open

\begin_layout Plain Layout
Academically minded computer scientists say that this definition of a 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category is insufficiently rigorous.
 See the discussion in 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "https://math.andrej.com/2016/08/06/hask-is-not-a-category/"
target "https://math.andrej.com/2016/08/06/hask-is-not-a-category/"
literal "false"

\end_inset


\end_layout

\end_inset

 a 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category:
\end_layout

\begin_layout Itemize
The objects of the category are all the data types supported by the language
 (including user-defined data types).
 As an example, for Scala there will be an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

, an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, an object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

, and so on.
\end_layout

\begin_layout Itemize
The morphisms between objects 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

 are all functions implementable in the language (with finitely long program
 code) that take a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

B
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
We assume that the computer has countably infinite memory, so objects can
 be viewed as (at most) countably infinite sets.
 Morphisms will also form at most countably infinite sets.
\end_layout

\begin_layout Standard
The category defined in this way will typically have a large number of morphisms
 between most objects.
 For example, morphisms between objects 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 are functions that take a single argument of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 and return a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 There are as many such functions as pairs of integers.
 Scala code for one of those morphisms looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def morphismBooleanToInt: Boolean => Int = { b => if (b) 123 else 456 }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why do the category laws hold? The composition of morphisms corresponds
 to composition of functions, which we can implement by writing code that
 applies the first function and then applies the second function.
 In Scala:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def composeMorphisms[A, B, C](f: A => B, g: B => C): A => C   =   { a =>
 g(f(a)) }
\end_layout

\end_inset

Equivalent functionality can be implemented in most programming languages.
\end_layout

\begin_layout Standard
The category's identity law says that there must be a morphism between objects
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A
\end_layout

\end_inset

.
 This can be implemented in most programming languages as a function that
 returns its argument unchanged:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def identity[A]: A => A = { x => x }
\end_layout

\end_inset

One can check that morphism composition is associative and agrees with the
 identity morphism.
\end_layout

\begin_layout Standard
For a given programming language, we have thus defined the 
\begin_inset Quotes eld
\end_inset

types/functions category
\begin_inset Quotes erd
\end_inset

, which can be seen as a subcategory of the category of sets.
 Most of the time, we will be working with that category, or with the category
 of its endofunctors, or with a sub-category of these categories.
\end_layout

\begin_layout Standard
Different programming languages will give rise to different 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 categories, but all those categories have many common features that are
 especially important in languages designed for functional programming (the
 
\begin_inset Quotes eld
\end_inset

FP languages
\begin_inset Quotes erd
\end_inset

, such as OCaml, Haskell, Scala and others).
\end_layout

\begin_layout Addsec
The use of endofunctors
\end_layout

\begin_layout Standard
An endofunctor in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category is a mapping of types together with a mapping of functions.
 A good example is the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 data type.
 In some programming languages, the type of an array's elements can be specified
 and enforced throughout the code.
 For example, in Scala one can use the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Int]
\end_layout

\end_inset

 for an array of integers, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

 for an array of strings, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Array[Int]]
\end_layout

\end_inset

 for an array containing nested arrays of integers, etc.
 So, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 can be seen as a mapping from types to types: it maps the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Int]
\end_layout

\end_inset

, the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 to the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[String]
\end_layout

\end_inset

, etc.
 For any type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

, we have the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[X]
\end_layout

\end_inset

.
 This is the object-to-object map of an endofunctor.
\end_layout

\begin_layout Standard
An endofunctor also needs a map from morphisms to morphisms.
 Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: X => Y
\end_layout

\end_inset

, we need to implement a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[X] => Array[Y]
\end_layout

\end_inset

.
 This can be done by writing a loop over the array and applying the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to each element (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

).
 The resulting values (of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

) are then collected in a new array, of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[Y]
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This code can be written in many programming languages in a generic manner,
 using type parameters such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Y
\end_layout

\end_inset

.
 The same code will then work for arrays and functions of any given type.
 In Scala, the code could be written as the following function (usually
 called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 in FP libraries):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def fmap[X, Y: ClassTag](f: X => Y): Array[X] => Array[Y] = { arrayX: Array[X]
 =>
\end_layout

\begin_layout Plain Layout

  val arrayY = new Array[Y](arrayX.size)
\end_layout

\begin_layout Plain Layout

  for { i <- arrayX.indices } arrayY(i) = f(arrayX(i))
\end_layout

\begin_layout Plain Layout

  arrayY  // Return this array of type Array[Y].
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

One can then check that the code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 satisfies the identity and composition laws of endofunctors.
 This completes the implementation of the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 endofunctor.
\end_layout

\begin_layout Standard
Why does 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 satisfy the laws of endofunctors? The categorical properties of functions
 are preserved if we apply functions to each element of an array and collect
 the results 
\emph on
in the same order
\emph default
.
 An identity function applied to every element will not modify the array.
 Function composition is preserved because a composition of two functions
 will be applied separately to each array element.
\end_layout

\begin_layout Standard
The same construction can be applied to many data structures other than
 arrays.
 It turns out that many programs can be reformulated using the operation
 of applying a function to every value in a data structure (i.e., the function
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

).
 This reformulation leads to code that avoids loops: the loops are replaced
 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions of some endofunctors, and all those 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 functions are implemented in a standard library.
 In practice, code written via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 instead of loops is more concise and admits fewer opportunities for errors.
 The programmer's intuition about 
\begin_inset Quotes eld
\end_inset

applying functions to every value held within a data structure
\begin_inset Quotes erd
\end_inset

 is then directly represented by the formal laws of endofunctors.
 Once those laws are verified, the programmer is assured that the code written
 via 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 will work according to the programmer's intuitive expectations.
\end_layout

\begin_layout Addsec
The use of natural transformations
\end_layout

\begin_layout Standard
What is a natural transformation between endofunctors in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category? For two given endofunctors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

, a natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t: F ~> G
\end_layout

\end_inset

 is defined by its components.
 The component at object 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 is a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[X] => G[X]
\end_layout

\end_inset

; this must be defined for all 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

.
 Some programming languages support functions with type parameters.
 In Scala, the syntax is
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def t[X]: F[X] => G[X] = ...
\end_layout

\end_inset

The code of such a function is written once and will work in the same way
 for all types 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
An example of natural transformation is a function that reverses the order
 of elements in an array:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def reverse[X]: Array[X] => Array[X] = ...
\end_layout

\end_inset

The algorithm is 
\begin_inset Quotes eld
\end_inset

fully parametric
\begin_inset Quotes erd
\end_inset

: it is written in the same way for all type parameters 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It turns out that, by the Reynolds-Wadler parametricity theorem, any code
 written in a fully parametric manner will satisfy the law of a natural
 transformation (the naturality law).
 The naturality law states that applying the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

's morphism map before a natural transformation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 must be equal to applying the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

G
\end_layout

\end_inset

's map after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

.
 In Scala syntax, the law is written as
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

t(fmap_F(f)(x)) == fmap_G(f)(t(x))
\end_layout

\end_inset

This law can be verified directly for a given code of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 and with known code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap_F
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap_G
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Naturality laws are satisfied by transformations that rearrange data items
 in a data structure in some way that does not depend on specific values
 or types.
 In this way, the formal laws of natural transformations directly represent
 programmers' intuitions about code that works 
\begin_inset Quotes eld
\end_inset

in the same way for all type parameters
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
As we have just seen, the notions of endofunctors and natural transformations
 are useful in programming languages that support types with type parameters
 (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array[X]
\end_layout

\end_inset

) and functions with type parameters (such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reverse[X]
\end_layout

\end_inset

).
 Programming languages that do not support those features cannot benefit
 from the powerful reasoning tools of category theory.
\end_layout

\begin_layout Addsec
Other properties of the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category
\end_layout

\begin_layout Standard
Morphisms in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category are always functions of a single argument.
 However, programming languages usually support functions with many arguments.
 There are two ways to imitate such functions: tupling and currying.
\end_layout

\begin_layout Standard
Tupling means that we put all arguments into a compound structure (a pair,
 a triple, etc.).
 The function is still viewed as having a single argument, but the type
 of that argument is the type of a pair, or a triple, or a longer tuple
 type.
 This works when the programming language supports tuple types.
 A tupled function's type is written (in Scala) as, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

((A, B, C)) => D
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Tuple types correspond to finite products of objects in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
 So, it is useful if the category has (finite) products.
 
\end_layout

\begin_layout Standard
Currying means that we create a function that takes the first argument and
 returns a curried function that handles the rest of the arguments in the
 same way (takes the second argument and again returns a function, etc.).
 A curried function's type is written in Scala as, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

A => B => C => D
\end_layout

\end_inset

.
 To support this method, the programming language should have function types.
 The corresponding categorical construction is the 
\begin_inset Quotes eld
\end_inset

exponential
\begin_inset Quotes erd
\end_inset

 object.
 
\end_layout

\begin_layout Standard
In the practice of functional programming, it has been found useful to have
 the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Unit
\end_layout

\end_inset

, which has exactly one value, and the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Nothing
\end_layout

\end_inset

, which has no values.
 In the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category, these types correspond to the terminal and the initial objects.
\end_layout

\begin_layout Standard
Finally, disjunctive types correspond to co-products in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
\end_layout

\begin_layout Standard
In this way, we find that various well-known mathematical properties of
 the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category (initial and terminal objects, finite products and co-products,
 exponentials) correspond to properties of the programming language that
 proved useful in the practice of software engineering.
\end_layout

\begin_layout Addsec
Some useful sub-categories of endofunctors
\end_layout

\begin_layout Standard
Besides loops that apply functions to array elements, other frequently used
 computations are nested loops and 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

-loops that are repeated while a given condition holds and then stopped.
 It turns out that category theory provides a convenient language for reasoning
 about such computations.
 Similarly to representing loops via endofunctors, the various kinds of
 loops are encoded via certain sub-categories of endofunctors in the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
\end_layout

\begin_layout Standard
To see how this works, we need to define an auxiliary sub-category called
 the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

-lifted
\begin_inset Quotes erd
\end_inset

 (where 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

 may be any given endofunctor, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

).
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

-lifted sub-category is the image of the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

.
 The objects of that sub-category are types of the form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A]
\end_layout

\end_inset

.
 The morphisms of that sub-category are functions of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F[A] => F[B]
\end_layout

\end_inset

 (not necessarily obtained by lifting some function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: A => B
\end_layout

\end_inset

 through the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fmap
\end_layout

\end_inset

 method).
 
\end_layout

\begin_layout Subsection*
Filterable endofunctors
\end_layout

\begin_layout Standard
To describe 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

-loops using category theory, we begin by reformulating the loop as a 
\emph on
mathematical function
\emph default
 rather than as a sequence of computer instructions.
 To be specific, consider a program with a loop that stops when a certain
 condition first becomes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 A loop of this kind may be modeled by a function that takes an initial
 array as argument and returns a new array that is truncated when a given
 condition first becomes 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

false
\end_layout

\end_inset

.
 The condition is represented by a function evaluated on each element of
 the array.
 The Scala standard library includes such a function (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

).
 An example of its usage is:
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

scala> Array(1, 2, 3, 4, 5).takeWhile(x => x < 4)    // Truncate the array
 when $
\backslash
color{dkgreen} x 
\backslash
geq 4$ is first found.
\end_layout

\begin_layout Plain Layout

res0: Array[Int] = Array(1, 2, 3) 
\end_layout

\end_inset

The next step is to extend this function to work with arbitrary types instead
 of integers.
 The type signature of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 may be written as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def takeWhile[X](p: X => Boolean): Array[X] => Array[X]
\end_layout

\end_inset

Here 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 is a type parameter.
 The first argument (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

) is a predicate of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X => Boolean
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Finally, we write the laws that we expect this function to satisfy.
 For instance, if the given predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 always returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

, the function should not change the given array (the 
\begin_inset Quotes eld
\end_inset

identity law
\begin_inset Quotes erd
\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

takeWhile(x => true)  ==  identity
\end_layout

\end_inset

Another plausible law is called the 
\begin_inset Quotes eld
\end_inset

composition law
\begin_inset Quotes erd
\end_inset

.
 If we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 with a predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1
\end_layout

\end_inset

 and then again apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 with another predicate 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2
\end_layout

\end_inset

, the resulting truncated array should be the same as if we applied 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 just once with a Boolean conjunction of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p1
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2
\end_layout

\end_inset

: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

takeWhile(p1) andThen takeWhile(p2) == takeWhile( x => p1(x) && p2(x) )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The identity and composition laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 are analogous to the identity and composition laws of functors.
 More precisely, one can derive the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 from the laws of an auxiliary functor between a certain Kleisli category
 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

-lifted category (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-category-definition-of-filterable-functor"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details).
 That auxiliary functor exists only for some endofunctors 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

F
\end_layout

\end_inset

, which are called 
\begin_inset Quotes eld
\end_inset

filterable
\begin_inset Quotes erd
\end_inset

 in this book.
 Filterable endofunctors are a sub-category of all endofunctors of the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
 
\end_layout

\begin_layout Standard
With this construction, one may now regard the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 not as arbitrarily postulated properties but as a consequence of the functor
 laws.
 In this way, category theory validates the programmer's intuition for the
 choice of the laws for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection*
Monadic endofunctors
\end_layout

\begin_layout Standard
To evaluate a nested loop, which may be written in Scala as in this example:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for {
\end_layout

\begin_layout Plain Layout

  x <- 1 to 10
\end_layout

\begin_layout Plain Layout

  y <- 1 to x / 2
\end_layout

\begin_layout Plain Layout

} yield f(x, y) // Some computation that may use x and y.
\end_layout

\end_inset

the computer will perform ten repetitions of the inner loop over 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

y
\end_layout

\end_inset

.
 This computation is equivalent to converting the nested loop into an ordinary,
 
\begin_inset Quotes eld
\end_inset

flattened
\begin_inset Quotes erd
\end_inset

 loop that has a larger total number of repetitions (in this example, 
\begin_inset Formula $25$
\end_inset

 repetitions).
 To describe this situation using category theory, we start by reformulating
 a nested loop into a mathematical function.
 The arguments of that function are the first array (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

1 to 10
\end_layout

\end_inset

) for iterating with 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

, and a function from a value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 to the nested array (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => 1 to x / 2
\end_layout

\end_inset

).
 The function returns a 
\begin_inset Quotes eld
\end_inset

flattened
\begin_inset Quotes erd
\end_inset

 array of 
\begin_inset Formula $25$
\end_inset

 values.
 
\end_layout

\begin_layout Standard
The Scala library contains such a function, named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

.
 An example of usage is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).toArray.flatMap(x => 1 to x / 2)
\end_layout

\begin_layout Plain Layout

res0: Array[Int] = Array(1, 1, 1, 2, 1, 2, 1, 2, 3, 1, 2, 3, 1, 2, 3, 4,
 1, 2, 3, 4, 1, 2, 3, 4, 5)
\end_layout

\end_inset

This function can be used repeatedly to convert arbitrarily deeply nested
 loops into 
\begin_inset Quotes eld
\end_inset

flat
\begin_inset Quotes erd
\end_inset

 loops.
\end_layout

\begin_layout Standard
The next step is to formulate a fully parametric type signature for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def flatMap[A, B](f: A => Array[B]): Array[A] => Array[B]
\end_layout

\end_inset

In this way, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 can transform arrays with elements of any type.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 function must satisfy certain properties that are useful for practical
 programming.
 One of these properties is 
\begin_inset Quotes eld
\end_inset

associativity
\begin_inset Quotes erd
\end_inset

.
 A deeply nested loop may be flattened by applying 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 first to the outer layers and then to the inner layers, or by applying
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 first to the inner layers; the results must be the same.
 This and other properties of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 are analogous to the laws of a category: there are two identity laws and
 one associativity law.
 More precisely, one can derive the laws of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

flatMap
\end_layout

\end_inset

 from the requirement that the Kleisli category on the endofunctor 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 is well-defined (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Monads-in-category-theory-monad-morphisms"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details).
 This is equivalent to saying that 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Array
\end_layout

\end_inset

 is a monad.
 Monads form a sub-category of endofunctors of the 
\begin_inset Quotes eld
\end_inset

types/functions
\begin_inset Quotes erd
\end_inset

 category.
\end_layout

\begin_layout Addsec
Category theory and the laws of FP idioms
\end_layout

\begin_layout Standard
We have seen that 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

-loops and nested loops can be reformulated through type-parameterized functions
 satisfying certain laws.
 Those laws are then equivalent to the laws of suitably chosen functors
 or categories.
 This turns out to be a general pattern:
\end_layout

\begin_layout Itemize
Begin with a known idiom of computation (e.g., a certain kind of a loop).
\end_layout

\begin_layout Itemize
Reformulate that idiom through functions with parameterized argument types.
\end_layout

\begin_layout Itemize
Write the laws that programmers expect those functions to satisfy.
\end_layout

\begin_layout Itemize
Prove that those laws are equivalent to the laws of a suitable functor and/or
 category.
\end_layout

\begin_layout Standard
The derivations in Chapters
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Functors,-contrafunctors,-and"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:monad-transformers"
plural "false"
caps "false"
noprefix "false"

\end_inset

 of this book follow this pattern.
 One can show that this pattern holds for at least 
\emph on
eleven
\emph default
 sub-categories of endofunctors used in FP practice: functors, contrafunctors,
 filterable functors, filterable contrafunctors, applicative functors, applicati
ve contrafunctors, monads, comonads, traversable functors, monad transformers,
 and comonad transformers.
 
\end_layout

\begin_layout Standard
It appears that the basic tools of category theory (functors, natural transforma
tions, commutative diagrams) provide a convenient language for reasoning
 about laws of various FP idioms.
 By invoking category theory, programmers avoid having to memorize a large
 number of laws and constructions.
 Without the underlying categorical justification, the laws for different
 endofunctors will appear to be chosen arbitrarily, with no clearly recognizable
 system or pattern.
\end_layout

\begin_layout Standard
In addition, category theory guides programmers in creating highly abstract
 libraries that work uniformly with all endofunctors of a certain sub-category.
 In programmer's terms, such libraries contain functions parameterized by
 type constructors satisfying appropriate constraints.
 Examples are functions that define the product or the co-product of any
 two given functors, or define a free monad on a given functor.
 Implementing libraries of that kind requires formulating and verifying
 the relevant laws.
 Category theory is a reliable foundation for such libraries.
\end_layout

\end_body
\end_document
