%% LyX 2.3.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{beamer}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\ifx\hypersetup\undefined
  \AtBeginDocument{%
    \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
  }
\else
  \hypersetup{unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true}
\fi

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}
\newenvironment{lyxcode}
  {\par\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \setlength{\listparindent}{0pt}% needed for AMS classes
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \normalfont\ttfamily}%
   \def\{{\char`\{}
   \def\}{\char`\}}
   \def\textasciitilde{\char`\~}
   \item[]}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usetheme[secheader]{Boadilla}
\usecolortheme{seahorse}
\title[Reasoning about types and code]{Reasoning about types and code}
\subtitle{What we functional programmers need to know}
\author{Sergei Winitzki}
\date{2019-08-17}
\institute[ABTB]{Academy by the Bay}
\setbeamertemplate{headline}{} % disable headline at top
\setbeamertemplate{navigation symbols}{} % disable navigation bar at bottom
\usepackage[all]{xy} % xypic
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

\usepackage{relsize} % make math symbols larger or smaller
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.5pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}


% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.

\makeatother

\begin{document}
\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%
\frame{\titlepage}
\begin{frame}{Reasoning about types and code}

{\footnotesize{}\vspace{-0.15cm}}Practitioners of functional programming
need to know how to...
\begin{itemize}
\item ...reason about types:
\begin{itemize}
\item design the required custom data types for the given application
\item derive an equivalent simpler type when possible
\item use type constructions to create data types with required properties
\end{itemize}
\item ...reason about code:
\begin{itemize}
\item verify that given implementations satisfy the required laws (e.g.~monad)
\item derive lawful custom implementations of important typeclasses
\item verify that certain functions are computationally equivalent
\item derive an equivalent simpler code when possible
\end{itemize}
\end{itemize}
This requires a \emph{very limited} amount of mathematics (polynomials,
monoids)
\end{frame}

\begin{frame}{A new book: \emph{The Science of Functional programming}}

I am working on a new book,

\emph{The Science of Functional Programming: A tutorial, with examples
in Scala}

{\small{}\href{https://github.com/winitzki/sofp}{https://github.com/winitzki/sofp}
(free as in GNU FSF)}{\small\par}

{\small{}}%
\begin{minipage}[t]{0.75\columnwidth}%
\medskip{}
The book will explain (with examples and exercises):
\begin{itemize}
\item techniques of reasoning about types and type constructors
\item techniques for symbolic calculations with code
\item deriving and verifying laws symbolically (as equations for functions)
\item real-life motivations for (and applications of) these techniques
\end{itemize}
%
\end{minipage}{\small{}}%
\begin{minipage}[t][1\totalheight][c]{0.3\columnwidth}%
\includegraphics[width=3cm]{book-draft-cover}%
\end{minipage}{\small\par}
\end{frame}

\begin{frame}{Examples of reasoning tasks I}

\begin{enumerate}
\item []\setcounter{enumi}{0}{\footnotesize{}\vspace{-0.4cm}}{\footnotesize\par}
\item Can we compute a value of type \texttt{\textcolor{blue}{\footnotesize{}Either{[}Z,
R => A{]}}} given a value of type \texttt{\textcolor{blue}{\footnotesize{}R
=> Either{[}Z, A{]}}}? And conversely? (\texttt{\textcolor{blue}{\footnotesize{}A}},
\texttt{\textcolor{blue}{\footnotesize{}R}}, \texttt{\textcolor{blue}{\footnotesize{}Z}}
are type parameters.)
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~f{[}Z,~R,~A{]}(r:~R~=>~Either{[}Z,~A{]}):~Either{[}Z,~R~=>~A{]}~=~???}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~g{[}Z,~R,~A{]}(e:~Either{[}Z,~R~=>~A{]}):~R~=>~Either{[}Z,~A{]}~=~???}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item It turns out that \texttt{\textcolor{blue}{\footnotesize{}f}} cannot
be implemented, but \texttt{\textcolor{blue}{\footnotesize{}g}} can
be:
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~g{[}Z,~R,~A{]}(e:~Either{[}Z,~R~=>~A{]}):~R~=>~Either{[}Z,~A{]}~=~\{}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~r~=>~e.map(f~=>~f(r))~~~~~//~}{\footnotesize{}Scala~2.12}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}}{\footnotesize\par}
\end{lyxcode}
\end{frame}

\begin{frame}{Examples of reasoning tasks II}

\begin{enumerate}
\item []\setcounter{enumi}{1}{\footnotesize{}\vspace{-0.4cm}}{\footnotesize\par}
\item How to use \texttt{\textcolor{blue}{\footnotesize{}for}}/\texttt{\textcolor{blue}{\footnotesize{}yield}}
with \texttt{\textcolor{blue}{\footnotesize{}Either{[}Z, A{]}}} and
\texttt{\textcolor{blue}{\footnotesize{}Future{[}A{]}}} together?
\end{enumerate}
\begin{lyxcode}
{\footnotesize{}\vspace{-0.15cm}}\textcolor{blue}{\footnotesize{}val~result~=~for~\{~//~This~code~will~not~compile;~we~want~to~have...}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~a~<-~Future(...)~//~...~a~computation~that~takes~time~and~may~fail,}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~b~<-~Either(...)~//~a~computation~whose~result~may~be~unavailable,}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~c~<-~Future(...)~//~a~computation~that~takes~time~and~may~fail.}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}\}~yield~???~//~Continue~computations~when~results~are~available.}{\footnotesize\par}
\end{lyxcode}
~~~~~\hspace*{1.8mm}Should \texttt{\textcolor{blue}{\footnotesize{}result}}
have type \texttt{\textcolor{blue}{\footnotesize{}Either{[}Z,Future{[}A{]}{]}}}
or \texttt{\textcolor{blue}{\footnotesize{}Future{[}Either{[}Z,A{]}{]}}}?

~~~~~\hspace*{1.8mm}How to combine \texttt{\textcolor{blue}{\footnotesize{}Either}}
with \texttt{\textcolor{blue}{\footnotesize{}Future }}so that we can
use \texttt{\textcolor{blue}{\footnotesize{}flatMap}}?
\begin{itemize}
\item It turns out that \texttt{\textcolor{blue}{\footnotesize{}Either{[}Z,Future{[}A{]}{]}}}
is wrong (cannot implement \texttt{\textcolor{blue}{\footnotesize{}flatMap}}
correctly) but \texttt{\textcolor{blue}{\footnotesize{}Future{[}Either{[}Z,A{]}{]}}}
is the correct solution
\end{itemize}
\end{frame}

\begin{frame}{Examples of reasoning tasks III}

\begin{enumerate}
\item []\setcounter{enumi}{2}{\footnotesize{}\vspace{-0.4cm}}{\footnotesize\par}
\item Can we implement \texttt{\textcolor{blue}{\footnotesize{}flatMap}}
for the type constructor \texttt{\textcolor{blue}{\footnotesize{}Option{[}(A,
A, A){]}}}?
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}def~flatMap{[}A,~B{]}(fa:~Option{[}(A,~A,~A){]})(f:~A~=>~Option{[}(B,~B,~B){]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~:~Option{[}(B,~B,~B){]}~=~???}{\footnotesize\par}
\end{lyxcode}
\begin{itemize}
\item It turns out that \texttt{\textcolor{blue}{\footnotesize{}flatMap}}
\emph{can} be implemented but fails the laws
\end{itemize}
\end{frame}

\begin{frame}{Examples of reasoning tasks IV}

\begin{enumerate}
\item []\setcounter{enumi}{3}{\footnotesize{}\vspace{-0.4cm}}{\footnotesize\par}
\item What type describes a chain of \texttt{\textcolor{blue}{\footnotesize{}Future{[}A{]}}}
operations that, on any failure, will automatically execute specified
cleanups in reverse order?
\end{enumerate}
\begin{itemize}
\item The type \texttt{\textcolor{blue}{\footnotesize{}Future{[}(A, Unit
=> Unit){]}}} has the required properties
\item The ``cleanup'' operations \texttt{\textcolor{blue}{\footnotesize{}Unit
=> Unit}} form a monoid and can be merged into a single cleanup executing
in reverse order
\end{itemize}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}type~Tx{[}A{]}~=~(A,~Unit~=>~Unit)~}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}def~flatMap{[}A,B{]}(task:~Future{[}Tx{[}A{]}{]})(f:~A~=>~Future{[}Tx{[}B{]}{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~~~~~~~~(implicit~ec:~ExecutionContext):~Future{[}Tx{[}B{]}{]}~=}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~task.flatMap~\{~case~(a,~cleanup1)~=>~f(a).transform(}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~\{~case~(b,~cleanup2)~=>~(b,~cleanup1~|+|~cleanup2)~\},}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~\{~ex~=>~cleanup1(());~ex~\}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~)\}}{\footnotesize\par}
\end{lyxcode}
\end{frame}

\begin{frame}{Examples of reasoning tasks V}

\begin{enumerate}
\item []\setcounter{enumi}{4}{\footnotesize{}\vspace{-0.4cm}}{\footnotesize\par}
\item Different people define a ``free monad'' via different sets of case
classes. Are these definitions equivalent? What is the difference?
\item How to define a free monad generated by a \texttt{\textcolor{blue}{\footnotesize{}Pointed}}
functor (i.e.~when the functor already has the \texttt{\textcolor{blue}{\footnotesize{}pure}}
method)? Will that type have better performance than the standard
free monad generated by a functor?
\end{enumerate}
\end{frame}

\begin{frame}{Short notation for types}

\begin{itemize}
\item {\footnotesize{}\vspace{-0.2cm}}A concise mathematical notation for
types and type constructors:
\end{itemize}
\begin{center}
{\footnotesize{}\vspace{-0.35cm}}%
\begin{tabular}{|c|c|}
\hline 
\textbf{\small{}Scala syntax} & \textbf{\small{}Type notation}\tabularnewline
\hline 
\hline 
{\small{}type parameter} \texttt{\textcolor{blue}{\footnotesize{}A}} & $A$\tabularnewline
\hline 
{\small{}tuple type} \texttt{\textcolor{blue}{\footnotesize{}(A, B)}}{\footnotesize{}
or} \texttt{\textcolor{blue}{\footnotesize{}case class C(a:~A, b:~B)}} & $A\times B$\tabularnewline
\hline 
{\small{}disjunctive type} \texttt{\textcolor{blue}{\footnotesize{}Either{[}A,B{]}}}{\footnotesize{}
or }\texttt{\textcolor{blue}{\footnotesize{}trait/case class}}{\footnotesize{}es} & $A+B$\tabularnewline
\hline 
{\small{}function type} \texttt{\textcolor{blue}{\footnotesize{}A
=> B}} & $A\rightarrow B$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Unit}} {\small{}or an equivalent
named type} & $\bbnum 1$\tabularnewline
\hline 
{\small{}primitive type (}\texttt{\textcolor{blue}{\footnotesize{}Int}}{\small{},
}\texttt{\textcolor{blue}{\footnotesize{}String}}{\small{}, etc.)} & {\small{}$\text{Int}$, $\text{String}$, ...}\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}Nothing}} {\small{}(the void
type)} & $\bbnum 0$\tabularnewline
\hline 
{\small{}type constructor,} \texttt{\textcolor{blue}{\footnotesize{}type
P{[}A{]} = Option{[}(A,A,A){]}}} & $P^{A}\triangleq\bbnum 1+A\times A\times A$\tabularnewline
\hline 
{\small{}type constructor as a parameter,} \texttt{\textcolor{blue}{\footnotesize{}P{[}\_{]}}} & $P^{\bullet}$\tabularnewline
\hline 
{\small{}function with type parameter,} \texttt{\textcolor{blue}{\footnotesize{}def
f{[}A{]}:~A => (A, A)}} & $f^{A}:A\rightarrow A\times A$\tabularnewline
\hline 
\end{tabular}
\par\end{center}

{\footnotesize{}\vspace{-0.0cm}}This notation proved convenient for
reasoning about equivalence of types:
\begin{align*}
\left(A+B\right)\times C & \cong A\times C+B\times C\quad,\quad\quad A\rightarrow B\rightarrow C\cong A\times B\rightarrow C\quad,\\
\bbnum 0+A & \cong A\quad,\quad\quad\quad A+B\rightarrow C\cong\left(A\rightarrow C\right)\times\left(B\rightarrow C\right)\quad.
\end{align*}

\end{frame}

\begin{frame}{Short notation for code}

\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}A concise mathematical notation
for code:
\end{itemize}
\begin{center}
{\footnotesize{}\vspace{-0.35cm}}%
\begin{tabular}{|c|c|}
\hline 
\textbf{\small{}Scala syntax} & \textbf{\small{}Code notation}\tabularnewline
\hline 
\hline 
{\small{}variable, or function argument} \texttt{\textcolor{blue}{\footnotesize{}x:~A}} & $x^{:A}$\tabularnewline
\hline 
{\small{}tuple value} \texttt{\textcolor{blue}{\footnotesize{}(a,
b)}} & $a\times b$ or $a^{:A}\times b^{:B}$\tabularnewline
\hline 
{\small{}value of disjunctive type} \texttt{\textcolor{blue}{\footnotesize{}Left{[}A,
B{]}(x)}} & $x^{:A}+\bbnum 0^{:B}$\tabularnewline
\hline 
{\small{}nameless function} \texttt{\textcolor{blue}{\footnotesize{}\{
x: A => expr \}}} & $x^{:A}\rightarrow\text{expr}$\tabularnewline
\hline 
{\small{}the} \texttt{\textcolor{blue}{\footnotesize{}Unit}} {\small{}value,
}\texttt{\textcolor{blue}{\footnotesize{}()}} & $1$\tabularnewline
\hline 
\texttt{\textcolor{blue}{\footnotesize{}def f{[}A, B{]}:~A => B =>
A = x => \_ => x}} & {\small{}$f^{:A\rightarrow B\rightarrow A}\triangleq x^{:A}\rightarrow\_^{:B}\rightarrow x$}\tabularnewline
\hline 
{\small{}the identity function, }\texttt{\textcolor{blue}{\footnotesize{}identity{[}A{]}}} & $\text{id}^{A}$ or $\text{id}^{:A\rightarrow A}$\tabularnewline
\hline 
\emph{\small{}forward}{\small{} composition,} \texttt{\textcolor{blue}{\footnotesize{}f
andThen g}} & $f\bef g$ or $f^{:A\rightarrow B}\bef g^{:B\rightarrow C}$\tabularnewline
\hline 
{\small{}argument chaining,} \texttt{\textcolor{blue}{\footnotesize{}x.pipe(f)}}{\small{}
(Scala 2.13)} & $x\triangleright f$ where $x^{:A}$ and $f^{:A\rightarrow B}$\tabularnewline
\hline 
{\small{}lifted function,} \texttt{\textcolor{blue}{\footnotesize{}p.map(f)}}{\small{}
where }\texttt{\textcolor{blue}{\footnotesize{}p:~P{[}A{]}}} & $p\triangleright f^{\uparrow P}$ where $p^{:P^{A}}$ and $f^{:A\rightarrow B}$\tabularnewline
\hline 
\end{tabular}
\par\end{center}

{\footnotesize{}\vspace{-0.15cm}}This notation proved convenient
for reasoning about equational laws:
\[
f^{\uparrow P}\bef g^{\uparrow P}\bef h^{\uparrow P}=\left(f\bef g\bef h\right)^{\uparrow P}\quad,\quad\quad x\triangleright f\triangleright g=x\triangleright f\bef g\quad.
\]

\end{frame}

\begin{frame}{Example I. Free monad generated by a type constructor}

\vspace{-0.15cm}A free monad generated by a type constructor \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}
is...
\begin{enumerate}
\item \vspace{-0.0cm}From a \href{http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html}{blog post}
by Gabriel Gonzalez (2012), translated into Scala:
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Free1{[}F{[}\_{]},~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Pure{[}F{[}\_{]},~T{]}(t:~T)~~~~~~~~~~~~~~~~~extends~Free1{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Flatten{[}F{[}\_{]},~T{]}(f:~F{[}Free1{[}F,~T{]}{]})~extends~Free1{[}F,~T{]}}{\footnotesize\par}
\end{lyxcode}
\begin{enumerate}
\item []\setcounter{enumi}{1}\vspace{-0.9cm}
\item From a \href{http://functionaltalks.org/2014/11/23/runar-oli-bjarnason-free-monad/}{talk}
given by Rúnar Bjarnason (2014):
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Free2{[}F{[}\_{]},~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Pure{[}F{[}\_{]},~T{]}(t:~T)~extends~Free2{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}F{[}\_{]},~T,~A{]}(f:~F{[}A{]},~g:~A~=>~Free2{[}F,~T{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~extends~Free2{[}F,~T{]}}{\footnotesize\par}
\end{lyxcode}
\begin{enumerate}
\item []\setcounter{enumi}{2}\vspace{-0.9cm}
\item From a \href{https://www.slideshare.net/KelleyRobinson1/why-the-free-monad-isnt-free-61836547}{talk}
given by Kelley Robinson (2016):
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Free3{[}F{[}\_{]},~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Pure{[}F{[}\_{]},~T{]}(t:~T)~~~~~~~~~extends~Free3{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Suspend{[}F{[}\_{]},~T{]}(f:~F{[}T{]})~~~extends~Free3{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~FlatMap{[}F{[}\_{]},~T,~A{]}(f:~Free3{[}F,~A{]},~g:~A~=>~Free3{[}F,~T{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~extends~Free3{[}F,~T{]}}{\footnotesize\par}
\end{lyxcode}
\vspace{-0.1cm}Are these definitions different? How to reason about
them?
\end{frame}

\begin{frame}{Example I. Writing the definitions in the type notation}

\vspace{-0.15cm}A free monad generated by a type constructor \texttt{\textcolor{blue}{\footnotesize{}F{[}\_{]}}}
is...
\begin{enumerate}
\item \vspace{-0.0cm}From G.~Gonzalez: $\text{Free}_{1}^{F,T}\triangleq T+F^{\text{Free}_{1}^{F,T}}$
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Free1{[}F{[}\_{]},~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Pure{[}F{[}\_{]},~T{]}(t:~T)~~~~~~~~~~~~~~~~~extends~Free1{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Flatten{[}F{[}\_{]},~T{]}(f:~F{[}Free1{[}F,~T{]}{]})~extends~Free1{[}F,~T{]}}{\footnotesize\par}
\end{lyxcode}
\begin{enumerate}
\item []\setcounter{enumi}{1}\vspace{-0.8cm}
\item From R.~Bjarnason: $\text{Free}_{2}^{F,T}\triangleq T+\exists A.\,F^{A}\times(A\rightarrow\text{Free}_{2}^{F,T})$
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Free2{[}F{[}\_{]},~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Pure{[}F{[}\_{]},~T{]}(t:~T)~extends~Free2{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Bind{[}F{[}\_{]},~T,~A{]}(f:~F{[}A{]},~g:~A~=>~Free2{[}F,~T{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~extends~Free2{[}F,~T{]}}{\footnotesize\par}
\end{lyxcode}
\begin{enumerate}
\item []\setcounter{enumi}{2}\vspace{-0.8cm}
\item From K.~Robinson: $\text{Free}_{3}^{F,T}\triangleq T+F^{T}+\exists A.\,\text{Free}_{3}^{F,A}\times(A\rightarrow\text{Free}_{3}^{F,T})$
\end{enumerate}
\begin{lyxcode}
\textcolor{blue}{\footnotesize{}sealed~trait~Free3{[}F{[}\_{]},~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Pure{[}F{[}\_{]},~T{]}(t:~T)~~~~~~~~~extends~Free3{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~Suspend{[}F{[}\_{]},~T{]}(f:~F{[}T{]})~~~extends~Free3{[}F,~T{]}}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}case~class~FlatMap{[}F{[}\_{]},~T,~A{]}(f:~Free3{[}F,~A{]},~g:~A~=>~Free3{[}F,~T{]})}{\footnotesize\par}

\textcolor{blue}{\footnotesize{}~~~~~extends~Free3{[}F,~T{]}}{\footnotesize\par}
\end{lyxcode}
\end{frame}

\begin{frame}{Example I. Three definitions of the free monad}

What is the difference between definitions 1 and 2?
\begin{itemize}
\item Definition $\text{Free}_{1}^{F,T}\triangleq T+F^{\text{Free}_{1}^{F,T}}$
assumes that $F^{\bullet}$ is a functor
\item Definition $\text{Free}_{2}^{F,T}\triangleq T+\exists A.\,F^{A}\times(A\rightarrow\text{Free}_{2}^{F,T})$
works for any $F^{\bullet}$
\begin{itemize}
\item if $F^{\bullet}$ is a functor, the Yoneda identity gives $F^{B}\cong\exists A.\,F^{A}\times\left(A\rightarrow B\right)$ 
\item then $T+\exists A.\,F^{A}\times(A\rightarrow\text{Free}_{2}^{F,T})\cong T+F^{\text{Free}_{2}^{F,T}}$
\end{itemize}
\item So, definitions 1 and 2 are equivalent when $F^{\bullet}$ is a functor 
\end{itemize}
\end{frame}

\begin{frame}{Example I. Three definitions of the free monad}

What is the difference between definitions 2 and 3?
\begin{itemize}
\item Can we replace $\text{Free}_{3}^{F,A}$ by $F^{A}$ in definition
3?{\footnotesize{} Yes.\vspace{-0.15cm}
\begin{align*}
 & T+F^{T}+\exists A.\,\gunderline{\text{Free}_{3}^{F,A}}\times(A\rightarrow\text{Free}_{3}^{F,T})\\
 & =T+\gunderline{F^{T}}+\exists A.\,\left(A+F^{A}+\exists B.\,\text{Free}_{3}^{F,B}\times(B\rightarrow\text{Free}_{3}^{F,A})\right)\times(A\rightarrow\text{Free}_{3}^{F,T})\\
 & =T+\gunderline{\exists A.\,F^{A}\times(A\rightarrow T)}+\gunderline{\exists A.\,A\times(A\rightarrow\text{Free}_{3}^{F,T})}+\exists A.\,F^{A}\times(A\rightarrow\text{Free}_{3}^{F,T})\\
 & \quad\quad\quad+\exists A.\,\exists B.\,\gunderline{\text{Free}_{3}^{F,B}\times(B\rightarrow\text{Free}_{3}^{F,A})\times(A\rightarrow\text{Free}_{3}^{F,T})}\quad.
\end{align*}
}{\footnotesize\par}
\end{itemize}
{\footnotesize{}\vspace{-0.2cm}By the monad's associativity law,
we reduce $\text{Free}_{3}^{F,B}\times(B\rightarrow\text{Free}_{3}^{F,A})\times(A\rightarrow\text{Free}_{3}^{F,T})$
to $\text{Free}_{3}^{F,B}\times(B\rightarrow\text{Free}_{3}^{F,A}\times(A\rightarrow\text{Free}_{3}^{F,T}))$.
By inductive assumption, this is $\text{Free}_{3}^{F,B}\times(B\rightarrow\text{Free}_{3}^{F,T})$
and can be replaced by $F^{B}\times(B\rightarrow\text{Free}_{3}^{F,A})$.}{\footnotesize\par}
\end{frame}

\begin{frame}{Example II. The selection monad transformer}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}The selection monad is defined as
\texttt{\textcolor{blue}{\footnotesize{}Sel{[}A{]} = (A => R) => A}} 
\begin{itemize}
\item This is related to the ``search monad'', \texttt{\textcolor{blue}{\footnotesize{}(A
=> Boolean) => Option{[}A{]}}}{\footnotesize\par}
\begin{itemize}
\item but \emph{not} related to the ``search monad'' in Haskell's \href{http://hackage.haskell.org/package/monad-dijkstra-0.1.1.2/docs/Control-Monad-Search.html}{monad-dijkstra}
\end{itemize}
\end{itemize}
\item The paper ``Monad Transformers for Backtracking Search'' \href{https://arxiv.org/pdf/1406.2058.pdf}{https://arxiv.org/pdf/1406.2058.pdf}
defines the selection monad transformer \texttt{\textcolor{blue}{\footnotesize{}SelT{[}A{]}
= (A => M{[}R{]}) => M{[}A{]}}}. The author writes,
\end{itemize}
\begin{quote}
{\footnotesize{}\vspace{-0.15cm}}{\scriptsize{}The proof that the
selection monad satisfies the monad laws was found using an ad-hoc
computer program written by Martin Escardó {[}...{]} The author has
verified by hand that the selection monad transformer preserves the
unit laws, however the proof for the associativity law appears to
be unmanageable. The author is currently working on a formally verified
proof that the selection monad transformer preserves the monad laws.}{\scriptsize\par}
\end{quote}
\begin{itemize}
\item {\footnotesize{}\vspace{-0.15cm}}The proof was too hard because (most
likely) the author tried to write symbolic calculations in Haskell
syntax, which is not well adapted to proofs. (This would have been
worse if using Scala syntax.)
\begin{itemize}
\item Doing a formally verified proof is \emph{much harder} than proving
by hand!
\begin{itemize}
\item (and you \emph{already} need to know how to prove it by hand)
\end{itemize}
\end{itemize}
\item In the short code notation, the proof takes 5 lines of calculations
\end{itemize}
\end{frame}

\begin{frame}{Example II. Proof of the associativity law}

{\footnotesize{}\vspace{-0.15cm}The selection monad transformer's
type is $T^{M,A}\triangleq(A\rightarrow M^{R})\rightarrow M^{A}$}{\footnotesize\par}

{\footnotesize{}Define Kleisli functions $f:A\rightarrow T^{M,B}\triangleq A\rightarrow(B\rightarrow M^{R})\rightarrow M^{B}$}{\footnotesize\par}

{\footnotesize{}Use a trick: flip arguments, $f:(B\rightarrow M^{R})\rightarrow A\rightarrow M^{B}$
and $g:(C\rightarrow M^{R})\rightarrow B\rightarrow M^{C}$}{\footnotesize\par}

{\footnotesize{}Define Kleisli composition, $f\diamond_{T}g:(C\rightarrow M^{R})\rightarrow A\rightarrow M^{C}$
using the known $\diamond_{M}$ as
\[
f\diamond_{T}g\triangleq k^{:C\rightarrow M^{R}}\rightarrow f(g(k)\diamond_{M}k)\diamond_{M}g(k)
\]
The operation $\diamond_{M}$ already satisfies the associativity
law, $\left(p\diamond_{M}q\right)\diamond_{M}r=p\diamond_{M}\left(q\diamond_{M}r\right)$}{\footnotesize\par}

{\footnotesize{}Prepare the result of $g\diamond_{T}h$ to be used
later:
\[
(g\diamond_{T}h)(k)=\gunderline{g(h(k)\diamond_{M}k)\diamond_{M}h(k)}
\]
}{\footnotesize\par}

{\footnotesize{}\vspace{-0.15cm}Now check associativity law for the
flipped Kleisli composition $\diamond_{T}$:
\begin{align*}
 & (f\diamond_{T}g)\diamond_{T}h=k\rightarrow(\gunderline{f\diamond_{T}g})(h(k)\diamond_{M}k)\diamond_{M}h(k)\\
 & =k\rightarrow f(g(\gunderline{h(k)\diamond_{M}k})\diamond_{M}\gunderline{h(k)\diamond_{M}k})\diamond_{M}g(\gunderline{h(k)\diamond_{M}k})\diamond_{M}h(k)\quad,\\
 & f\diamond_{T}(g\diamond_{T}h)=k\rightarrow f((\gunderline{g\diamond_{T}h})(k)\diamond_{M}k)\diamond_{M}(\gunderline{g\diamond_{T}h})(k)\\
 & =k\rightarrow f(\gunderline{g(h(k)\diamond_{M}k)\diamond_{M}h(k)}\diamond_{M}k)\diamond_{M}g\gunderline{(h(k)\diamond_{M}k)\diamond_{M}h(k)}\quad.
\end{align*}
So we have proved the associativity law, $\left(f\diamond_{T}g\right)\diamond_{T}h=f\diamond_{T}\left(g\diamond_{T}h\right)$}{\footnotesize\par}

{\footnotesize{}In a similar way, can prove the laws for another transformer,
$T^{M,A}\triangleq(M^{A}\rightarrow R)\rightarrow M^{A}$}{\footnotesize\par}
\end{frame}

\begin{frame}{Summary}
\begin{itemize}
\item Mastering the type/code reasoning takes about 6 months of practice 
\begin{itemize}
\item and you will be able to use FP much more effectively in actual coding
\item the special notation helped me a lot
\end{itemize}
\item Lots of explanations, examples, and exercises in the upcoming book
\item Current progress: chapters 1--7 ready with 2 proofreading passes
\item Chapters 8 and 13 are in progress
\item Source (\LaTeX) for the book: \texttt{\href{https://github.com/winitzki/sofp}{https://github.com/winitzki/sofp}}
\end{itemize}
\end{frame}

\end{document}
