
\appendix

\chapter{Notations\label{chap:Appendix-Notations}}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%
\global\long\def\pplus{{\displaystyle }{+\negmedspace+}}%
This book chooses certain notations differently from what the functional
programming community currently uses. The proposed notation is well
adapted to reasoning about types and code, and especially for designing
data types and proving the laws of various typeclasses.

\section{Summary of notations}
\begin{description}
\item [{$A$}] \textemdash{} type parameter. Names of type parameters are
always capitalized.
\item [{$F^{A}$}] \textemdash{} type constructor $F$ with type argument
$A$. In Scala, \lstinline!F[A]!
\item [{$F^{\bullet}$}] \textemdash{} the type constructor $F$ understood
as a type-level function. In Scala, \lstinline!F[_]! 
\item [{$x^{:A}$}] \textemdash{} value $x$ has type $A$; in Scala, \lstinline!x:A!.
Value names are always in lowercase.
\item [{$\bbnum 1,\,1$}] \textemdash{} the unit type and its value; in
Scala, \lstinline!Unit! and \lstinline!()!
\item [{$\bbnum 0$}] \textemdash{} the void type. In Scala, \lstinline!Nothing!
\item [{$A+B$}] \textemdash{} a disjunctive type (co-product). In Scala,
this type is \lstinline!Either[A, B]! 
\item [{$x^{:A}+\bbnum 0^{:B}$}] \textemdash{} a value of a disjunctive
type $A+B$. In Scala, \lstinline!Left(x)!
\item [{$A\times B$}] \textemdash{} a product (tuple) type. In Scala,
this type is \lstinline!(A,B)!
\item [{$a^{:A}\times b^{:B}$}] value of a tuple type $A\times B$. In
Scala, \lstinline!(a, b)!
\item [{$A\rightarrow B$}] \textemdash{} the function type, mapping from
$A$ to $B$
\item [{$x^{:A}\rightarrow f$}] \textemdash{} a nameless function (as
a value). In Scala, \lstinline!{ x:A => f }!
\item [{$\text{id}$}] \textemdash{} an identity function; in Scala, \lstinline!identity[A]!
\item [{$\triangleq$}] \textemdash{} \textsf{``}is defined to be\textsf{''} or \textsf{``}is equal
by definition\textsf{''}
\item [{$\overset{!}{=}$}] \textemdash{} \textsf{``}must be equal according to
what we know\textsf{''}
\item [{$\overset{?}{=}$}] \textemdash{} \textsf{``}we ask \textemdash{} is it
equal? \textemdash{} because we still need to prove that\textsf{''}
\item [{$\square$}] \textemdash{} \textsf{``}this proof or this derivation or
this definition or this example is finished\textsf{''}
\item [{$\cong$}] \textemdash{} for types, a natural isomorphism between
types; for values, \textsf{``}equivalent\textsf{''} values according to an already
established isomorphism
\item [{$A^{:F^{B}}$}] \textemdash{} special type annotation, used for
defining unfunctors (GADTs)
\item [{$\wedge$}] \textemdash{} logical conjunction; $\alpha\wedge\beta$
means \textsf{``}both $\alpha$ and $\beta$ are true\textsf{''}
\item [{$\vee$}] \textemdash{} logical disjunction; $\alpha\vee\beta$
means \textsf{``}either $\alpha$ or $\beta$ or both are true\textsf{''}
\item [{$\Rightarrow$}] \textemdash{} logical implication; $\alpha\Rightarrow\beta$
means \textsf{``}if $\alpha$ is true then $\beta$ is true\textsf{''}
\item [{$\text{fmap}_{F}$}] \textemdash{} the standard method \lstinline!fmap!
of a functor $F$. In Scala, \lstinline!Functor[F].fmap!
\item [{$\text{flm}_{F},\text{ftn}_{F},\text{pu}_{F}$}] \textemdash{}
the standard methods \lstinline!flatMap!, \lstinline!flatten!, and
\lstinline!pure! of a monad $F$
\item [{$F^{\bullet}$}] \textemdash{} the type constructor $F$ understood
as a type-level function. In Scala, \lstinline!F[_]! 
\item [{$F^{\bullet}\leadsto G^{\bullet}$}] \textemdash{} or $F\leadsto G$
a natural transformation between functors $F$ and $G$. In Scala,
\lstinline!F ~> G!
\item [{$\forall A.\,P^{A}$}] \textemdash{} a universally quantified type
expression. In Scala 3, \lstinline![A] => P[A]!
\item [{$\exists A.\,P^{A}$}] \textemdash{} an existentially quantified
type expression. In Scala, \lstinline!{ type A; val x: P[A] }! 
\item [{$f\bef g$}] \textemdash{} the forward composition of functions:
$f\bef g$ is $x\rightarrow g(f(x))$. In Scala, \lstinline!f andThen g!
\item [{$f\circ g$}] \textemdash{} the backward composition of functions:
$f\circ g$ is $x\rightarrow f(g(x))$. In Scala, \lstinline!f compose g!
\item [{$F\circ G$}] \textemdash{} the backward composition of type constructors:
$F\circ G$ is $F^{G^{\bullet}}$. In Scala, \lstinline!F[G[A]]! 
\item [{$\triangleright$}] \textemdash{} use a value as the argument of
a function: $x\triangleright f$ is $f(x)$. In Scala, \lstinline!x.pipe(f)!
\item [{$f^{\uparrow G}$}] \textemdash{} a function $f$ lifted to a functor
$G$; same as $\text{fmap}_{G}(f)$
\item [{$f^{\uparrow G\uparrow H}$}] \textemdash{} a function lifted first
to $G$ and then to $H$. In Scala, \lstinline!h.map(_.map(f))! 
\item [{$f^{\downarrow H}$}] \textemdash{} a function $f$ lifted to a
contrafunctor $H$ 
\item [{$\diamond_{M}$}] \textemdash{} the Kleisli product operation for
the monad $M$
\item [{$L\varangle M$}] or equivalently $T_{L}^{M}$ \textemdash{} the
monad $L$\textsf{'}s transformer applied to a monad $M$
\item [{$\oplus$}] \textemdash{} the binary operation of a monoid. In
Scala, \lstinline!x |+| y!
\item [{$\Delta$}] \textemdash{} the \textsf{``}diagonal\textsf{''} function of type $\forall A.\,A\rightarrow A\times A$
\item [{$\pi_{1},\pi_{2},...$}] \textemdash{} the projections from a tuple
to its first, second, ..., parts
\item [{$\boxtimes$}] \textemdash{} pair product of functions: $(f\boxtimes g)(a\times b)\triangleq f(a)\times g(b)$
\item [{$\boxplus$}] \textemdash{} pair co-product of functions
\item [{$\ogreaterthan$}] \textemdash{} pair mapper of relations
\item [{$\left[a,b,c\right]$}] \textemdash{} an ordered sequence of values.
In Scala, \lstinline!Seq(a, b, c)!
\item [{$\begin{array}{||cc|}
x\rightarrow x & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}$}] ~ \textemdash{} a function that works with disjunctive types
(a \textsf{``}\index{disjunctive functions}disjunctive function\textsf{''})
\end{description}

\section{Detailed explanations}

$F^{A}$ means a type constructor $F$ with a type parameter $A$.
In Scala, this is \lstinline!F[A]!. Type parameters are uppercase
($A$, $B$, ...). Type constructors with multiple type parameters
are denoted by $F^{A,B,C}$. Nested type constructors such as Scala\textsf{'}s
\lstinline!F[G[A]]! are denoted by $F^{G^{A}}$, meaning $F^{(G^{A})}$.

$x^{:A}$ means a value $x$ that has type $A$; this is a \textbf{\index{type annotation}type
annotation}. In Scala, a type annotation is \lstinline!x:A!. The
colon symbol, $:$, in the superscript shows that $A$ is not a type
argument (as it would be in a type constructor, $F^{A}$). A less
concise notation for $x^{:A}$ is $x:A$.

$\bbnum 1$ means the unit type\index{unit type}, and $1$ means
the value of the unit type. In Scala, the unit type is \lstinline!Unit!,
and its value is \lstinline!()!. An example of this notation is $\bbnum 1+A$,
which corresponds to \lstinline!Option[A]! in Scala.

$\bbnum 0$ means the void\index{void type} type (the type with no
values). In Scala, this is the type \lstinline!Nothing!. The notation
$\bbnum 0$ is often used to denote an empty part of disjunctive types
or values. E.g., the disjunctive type \lstinline!Option[A]! has two
parts: \lstinline!Some[A]! and \lstinline!None!. These types are
denoted by $\bbnum 0+A$ and $\bbnum 1+\bbnum 0$ respectively. Similarly,
$A+\bbnum 0$ denotes the first part of the type $A+B$ (in Scala,
\lstinline!Left[A]!), while $\bbnum 0+B$ denotes its second part
(in Scala, \lstinline!Right[A]!). Values of disjunctive types are
denoted similarly. E.g., $x^{:A}+\bbnum 0^{:B}$ denotes a value of
the left part of the type $A+B$. In Scala, this value is written
with fully annotated types as \lstinline!Left[A,B](x)!.

$A+B$ means the disjunctive type made from types $A$ and $B$. In
Scala, this is the type \texttt{}\lstinline!Either[A, B]!.

$x^{:A}+\bbnum 0^{:B}$ denotes a value of a disjunctive type $A+B$,
where $x$ is the value of type $A$, which is the chosen case, and
$\bbnum 0$ stands for other possible cases. For example, $x^{:A}+\bbnum 0^{B}$
is \lstinline!Left[A,B](x)! in Scala. Type annotations $^{:A}$ and
$^{:B}$ may be omitted if the types are unambiguous from the context.

$A\times B$ means the product type made from types $A$ and $B$.
In Scala, this is the tuple type \lstinline!(A,B)!.

$a^{:A}\times b^{:B}$ means a value of a tuple type $A\times B$;
in Scala, this is the tuple value \lstinline!(a, b)!. Type annotations
$^{:A}$ and $^{:B}$ may be omitted if the types are unambiguous
from the context.

$A\rightarrow B$ means the type of functions $A$ to $B$. In Scala,
this is the type \lstinline!A => B!. The function type\textsf{'}s arrow binds
weaker than $+$, which binds weaker than $\times$. So, $A+B\rightarrow C\times D$
means $(A+B)\rightarrow(C\times D)$.

$x^{:A}\rightarrow y$ means a nameless function with argument $x$
of type $A$ and function body $y$. (Usually, the body $y$ will
be an expression that uses $x$. In Scala, this is \lstinline!{ x: A => y }!.
Type annotation $^{:A}$ may be omitted if the type is unambiguous
from the context.

$\text{id}$ means the identity function. The type of its argument
should be either specified as $\text{id}^{A}$ or $\text{id}^{:A\rightarrow A}$,
or else should be unambiguous from the context. In Scala,  \lstinline!identity[A]!
corresponds to $\text{id}^{A}$.

$\triangleq$ means \textsf{``}equal by definition\textsf{''}. A definition of a function
$f$ is written as $f\triangleq(x^{:\text{Int}}\rightarrow x+10)$;
in Scala, this is \lstinline!val f = { x: Int => x + 10 }!. A definition
of a type constructor $F$ is written as $F^{A}\triangleq\bbnum 1+A$;
in Scala, this is \lstinline!type F[A] = Option[A]!.

$\cong$ for types means an equivalence (an isomorphism) of types.
For example, $A+A\times B\cong A\times\left(\bbnum 1+B\right)$. The
same symbol $\cong$ for \emph{values} means \textsf{``}equivalent\textsf{''} according
to an equivalence relation that needs to be established in the text.
For example, if we have established an equivalence that allows nested
tuples to be reordered whenever needed, we can write $\left(a\times b\right)\times c\cong a\times\left(b\times c\right)$,
meaning that these values are mapped to each other by the established
isomorphism functions. 

$A^{:F^{B}}$ in type definitions means that the definition assigns
the type $F^{B}$ to the type expression $A$. This notation is used
for defining unfunctors (GADTs). For example, the Scala code:

\begin{lstlisting}
sealed trait F[A]
case class F1() extends F[Int]
case class F2[A](a: A) extends F[(A, String)]
\end{lstlisting}
defines an unfunctor\index{unfunctor} denoted by $F^{A}\triangleq\bbnum 1^{:F^{\text{Int}}}+A^{:F^{A\times\text{String}}}$.

$\wedge$ (conjunction), $\vee$ (disjunction), and $\Rightarrow$
(implication) are used in formulas of Boolean as well as constructive
logic in Chapter~\ref{chap:5-Curry-Howard}, e.g., $\alpha\wedge\beta$,
where Greek letters stand for logical propositions.

$\text{fmap}_{F}$ is a functor $F$\textsf{'}s the standard method \lstinline!fmap!
of the \lstinline!Functor! typeclass. In Scala, this may be written
as \texttt{}\lstinline!Functor[F].fmap!. Since each functor $F$
has its own specific implementation of $\text{fmap}_{F}$, the subscript
\textsf{``}$F$\textsf{''} is \emph{not} a type parameter of $\text{fmap}_{F}$. The
function $\text{fmap}_{F}$ has two type parameters, which may be
written as $\text{fmap}_{F}^{A,B}$, and we may write its type signature
as $\text{fmap}_{F}^{A,B}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}$.
In most cases, the type parameters $A$, $B$ can be omitted without
loss of clarity.

$\text{pu}_{F}$ denotes a monad $F$\textsf{'}s method \lstinline!pure!.
This function has type signature $A\rightarrow F^{A}$ and has a type
parameter $A$. In the code notation, the type parameter may be either
omitted or denoted as $\text{pu}_{F}^{A}$. If we are using \lstinline!pure!
with a complicated type, e.g., $\bbnum 1+P^{B}$, as of the type parameter
$A$, we may write the type parameter for clarity as $\text{pu}_{F}^{\bbnum 1+P^{B}}$.
The type signature of that function then becomes: 
\[
\text{pu}_{F}^{1+P^{B}}:\bbnum 1+P^{B}\rightarrow F^{\bbnum 1+P^{B}}\quad.
\]
But in most cases we will not need to write out the type parameters.

$\text{flm}_{F}$ denotes the curried version of a monad $F$\textsf{'}s method
\lstinline!flatMap!. The type signature of $\text{flm}_{F}$ is $\text{flm}_{F}:(A\rightarrow F^{B})\rightarrow F^{A}\rightarrow F^{B}$.
Note that Scala\textsf{'}s standard \lstinline!flatMap! type signature is
not curried. The curried method $\text{flm}_{F}$ is easier to use
in calculations involving the monad laws.

$\text{ftn}_{F}$ denotes a monad $F$\textsf{'}s method \lstinline!flatten!
with the type signature $\text{ftn}_{F}:F^{F^{A}}\rightarrow F^{A}$.

$F^{\bullet}$ means the type constructor $F$ understood as a type-level
function, \textemdash{} that is, with a type parameter unspecified.
In Scala, this is \lstinline!F[_]!. The bullet symbol, $\bullet$,
is used as a placeholder for the missing type parameter. When no type
parameter is needed, $F$ means the same as $F^{\bullet}$. (For example,
\textsf{``}a functor $F$\textsf{''} and \textsf{``}a functor $F^{\bullet}$\textsf{''} mean the same
thing.) However, it is useful for clarity to be able to indicate the
place where the type parameter would appear. For instance, functor
composition is denoted as $F^{G^{\bullet}}$; in Scala 2, this is
\texttt{}\lstinline!Lambda[X => F[G[X]]]! when using the \textsf{``}kind
projector\textsf{''}\index{kind@\textsf{``}kind projector\textsf{''} plugin} plugin.\footnote{\texttt{\href{https://github.com/typelevel/kind-projector}{https://github.com/typelevel/kind-projector}}}
When the type parameter $B$ of a bifunctor $P^{A,B}$ is fixed to
$Z$, we get a functor (with respect to $A$) denoted by $P^{\bullet,Z}$.
Another example: $T_{L}^{M,\bullet}$ denotes a monad transformer
for the base monad $L$ and the foreign monad $M$. The foreign monad
$M$ is a type parameter in $T_{L}^{M,\bullet}$. The symbol $\bullet$
stands for the transformer\textsf{'}s second type parameter. (The base monad
$L$ is not a type parameter in $T_{L}^{M,\bullet}$ because the construction
of the monad transformer depends on the internal details of $L$.)

$F^{\bullet}\leadsto G^{\bullet}$ or $F\leadsto G$ means a natural
transformation between two functors $F$ and $G$. In some Scala libraries,
this is denoted by \lstinline!F ~> G!.

$\forall A.\,P^{A}$ is a universally quantified type expression,
in which $A$ is a bound type parameter.

$\exists A.\,P^{A}$ is an existentially quantified type expression,
in which $A$ is a bound type parameter.

$\bef$ means the forward composition\index{forward composition}
of functions: $f\bef g$ (reads \textsf{``}$f$ before $g$\textsf{''}) is the function
defined as $x\rightarrow g(f(x))$.

$\circ$ means the backward composition\index{backward composition}
of functions: $f\circ g$ (reads \textsf{``}$f$ after $g$\textsf{''}) is the function
defined as $x\rightarrow f(g(x))$.

$\circ$ with type constructors means their (backward) composition,
for example $F\circ G$ denotes the type constructor $F^{G^{\bullet}}$.
In Scala, this is \lstinline!F[G[A]]!. 

$x\triangleright f$ (the \textbf{pipe notation})\index{pipe notation}\index{\$@$\triangleright$-notation!see \textsf{``}pipe notation\textsf{''}}
is a different syntax for $f(x)$. The value $x$ is passed as the
argument to the function $f$. In Scala, the expression $x\triangleright f$
is written as \lstinline!x.pipe(f)! or, if \lstinline!f! is a method,
\lstinline!x.f!. This syntax is used with many standard methods such
as \lstinline!size! or \lstinline!toSeq!. Because the argument $x$
is to the left of the function $f$ in this notation, forward compositions
of functions such as $x\triangleright f\triangleright g$ are naturally
grouped to the left as it is done in Scala code, for example \lstinline!x.toSeq.sorted!.
The operation $\triangleright$ (pronounced \textsf{``}pipe\textsf{''}) groups weaker
than the forward composition ($\bef$), and so we have $x\triangleright f\bef g=x\triangleright f\triangleright g$
in this notation. Reasoning about code in the pipe notation uses the
identities:
\begin{align*}
x\triangleright f=f(x)\quad,\quad\quad & \left(x\triangleright f\right)\triangleright g=x\triangleright f\triangleright g\quad,\\
x\triangleright f\bef g=x\triangleright\left(f\bef g\right)\quad,\quad\quad & x\triangleright f\triangleright g=x\triangleright f\bef g\quad.
\end{align*}
The pipe symbol groups stronger than the function arrow, so $x\rightarrow y\triangleright f$
is the same as $x\rightarrow(y\triangleright f)$. Here are some examples
of reasoning with functions in the pipe notation:
\begin{align*}
 & \left(a\rightarrow a\triangleright f\right)=\left(a\rightarrow f(a)\right)=f\quad,\\
 & f\triangleright\left(y\rightarrow a\triangleright y\right)=a\triangleright f=f(a)\quad,\\
 & f(y(x))=x\triangleright y\triangleright f\neq x\triangleright\left(y\triangleright f\right)=f(y)(x)\quad.
\end{align*}
The correspondence between the forward composition and the backward
composition:
\begin{align*}
 & f\bef g=g\circ f\quad,\\
 & x\triangleright(f\bef g)=x\triangleright f\bef g=x\triangleright f\triangleright g=g(f(x))=(g\circ f)(x)\quad.
\end{align*}

$f^{\uparrow G}$ means a function $f$ lifted to a functor $G$.
For a function $f^{:A\rightarrow B}$, the application of $f^{\uparrow G}$
to a value $g^{:G^{A}}$ is written as $f^{\uparrow G}(g)$ or as
$g\triangleright f^{\uparrow G}$. In Scala, this is \lstinline!g.map(f)!.
Nested lifting (i.e., lifting to the functor composition $H\circ G$)
can be written as $f^{\uparrow G\uparrow H}$, which means $\left(f^{\uparrow G}\right)^{\uparrow H}$,
and produces a function of type $H^{G^{A}}\rightarrow H^{G^{B}}$.
Applying a nested lifting to a value $h$ of type $H^{G^{A}}$ is
written as $h\triangleright f^{\uparrow G\uparrow H}$. In Scala,
this is \lstinline!h.map(_.map(f))!. The functor composition law
is written as:
\[
p^{\uparrow G}\bef q^{\uparrow G}=\left(p\bef q\right)^{\uparrow G}\quad.
\]
The notation $x\triangleright p^{\uparrow G}\triangleright q^{\uparrow G}$
is intended to be similar to the Scala code \lstinline!x.map(p).map(q)!.

$f^{\downarrow H}$ means a function $f$ lifted to a contrafunctor
$H$. For a function $f^{:A\rightarrow B}$, the application of $f^{\downarrow H}$
to a value $h:H^{B}$ is written as $h\triangleright f^{\downarrow H}$
and yields a value of type $H^{A}$. In Scala, this may be written
as \lstinline!h.contramap(f)!. Nested lifting is denoted as, e.g.,
$f^{\downarrow H\uparrow G}\triangleq(f^{\downarrow H})^{\uparrow G}$.

$\diamond_{M}$ means the Kleisli product operation for a given monad
$M$. This is a binary operation working on two Kleisli functions
of types $A\rightarrow M^{B}$ and $B\rightarrow M^{C}$ and yields
a new function of type $A\rightarrow M^{C}$.

$L\varangle M$ denotes the monad $L$\textsf{'}s transformer applied to a
foreign monad $M$. We define $(K\varangle L)\varangle M\triangleq K\varangle(L\varangle M)$,
which makes the monad transformer application into an associative
operation.

$\oplus$ means the binary operation of a monoid, e.g., $x\oplus y$.
For this expression to make sense, a specific monoid type should be
defined . In Scala libraries, $x\oplus y$ is often denoted as \lstinline!x |+| y!.

$\Delta$ means the standard \textsf{``}diagonal\textsf{''} function of type $\forall A.\,A\rightarrow A\times A$,
i.e., $\Delta\triangleq a^{:A}\rightarrow a\times a$. In Scala:
\begin{lstlisting}
def delta[A](a: A): (A, A) = (a, a)
\end{lstlisting}

$\pi_{1},\pi_{2},...$ denote the functions extracting the first,
second, ..., parts in a tuple. In Scala, $\pi_{1}$ is \lstinline!(_._1)!.

$\boxtimes$ means the pair product\index{pair product of functions}
of functions, defined by $(f\boxtimes g)(a\times b)=f(a)\times g(b)$.
In Scala, the pair product can be implemented as a higher-order function:
\begin{lstlisting}
def pair_product[A,B,P,Q](f: A => P, g: B => Q): ((A, B)) => (P, Q) = {
  case (a, b) => (f(a), g(b))
}
\end{lstlisting}
The operations $\Delta$, $\pi_{i}$ (where $i=1,2,...$), and $\boxtimes$
allow us to express any function operating on tuples. Useful properties
for reasoning about code of such functions: 
\begin{align*}
{\color{greenunder}\text{identity law}:}\quad & \Delta\bef\pi_{i}=\text{id}\quad,\\
{\color{greenunder}\text{naturality law}:}\quad & f\bef\Delta=\Delta\bef(f\boxtimes f)\quad,\\
{\color{greenunder}\text{left and right projection laws}:}\quad & (f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f\quad,\quad\quad(f\boxtimes g)\bef\pi_{2}=\pi_{2}\bef g\quad,\\
{\color{greenunder}\text{composition law}:}\quad & (f\boxtimes g)\bef(p\boxtimes q)=(f\bef p)\boxtimes(g\bef q)\quad,
\end{align*}
as well as the functor lifting laws for $\Delta$ and $\pi_{i}$:
\begin{align*}
 & f^{\uparrow F}\bef\Delta=\Delta\bef f^{\uparrow(F\times F)}=\Delta\bef(f^{\uparrow F}\boxtimes f^{\uparrow F})\quad,\\
 & (f^{\uparrow F}\boxtimes f^{\uparrow G})\bef\pi_{1}=f^{\uparrow(F\times G)}\bef\pi_{1}=\pi_{1}\bef f^{\uparrow F}\quad.
\end{align*}

$\left[a,b,c\right]$ means an ordered sequence of values, such as
a list or an array. In Scala, this can be \lstinline!List(a, b, c)!,
\lstinline!Vector(a, b, c)!, \lstinline!Array(a, b, c)!, or another
collection type.

$f^{:Z+A\rightarrow Z+A\times A}\triangleq\,\begin{array}{||cc|}
z\rightarrow z & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,\,$ is the \textbf{matrix notation}\index{matrix notation} for a function
whose input and/or output type is a disjunctive type (\index{disjunctive functions}a
\textbf{disjunctive function}). In Scala, the function $f$ is written
as:
\begin{lstlisting}
def f[Z, A]: Either[Z, A] => Either[Z, (A, A)] = {
  case Left(z)   => Left(z)       // Identity function on Z.
  case Right(a)  => Right((a, a)) // Delta on A.
}
\end{lstlisting}
The rows of the matrix indicate the different \lstinline!case!s in
the function\textsf{'}s code, corresponding to the different parts of the input
disjunctive type. If the input type is not disjunctive, there will
be only one row. The columns of the matrix indicate the parts of the
output disjunctive type. If the output type is not disjunctive, there
will be only one column.

A matrix may show all parts of the disjunctive types in separate \textsf{``}type
row\textsf{''} and \textsf{``}type column\textsf{''}:
\begin{equation}
f^{:Z+A\rightarrow Z+A\times A}\triangleq\,\begin{array}{|c||cc|}
 & Z & A\times A\\
\hline Z & \text{id} & \bbnum 0\\
A & \bbnum 0 & a\rightarrow a\times a
\end{array}\quad.
\end{equation}
This notation clearly indicates the input and the output types of
the function and is useful for reasoning about the code. The vertical
double line separates the \emph{input} types from the function code
(output types have a single line). In the code above, the \textsf{``}type
column\textsf{''} shows the parts of the input disjunctive type $Z+A$. The
\textsf{``}type row\textsf{''} shows the parts of the output disjunctive type $Z+A\times A$.

The matrix notation is adapted to \emph{forward} function composition
($f\bef g$). Assume that $A$ is a monoid type, and consider the
composition of the function $f$ shown above and the function $g$
defined as:
\begin{lstlisting}
def g[Z, A: Monoid]: Either[Z, (A, A)] => A = {
  case Left(_)          => Monoid[A].empty
  case Right((a1, a2))  => a1 |+| a2
}
\end{lstlisting}
In the matrix notation, the function $g$ is written (with and without
types) as:
\[
g\triangleq\,\begin{array}{|c||c|}
 & A\\
\hline Z & \_\rightarrow e^{:A}\\
A\times A & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad,\quad\quad g\triangleq\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\quad.
\]
The forward composition $f\bef g$ is computed by forward-composing
the matrix elements using the rules of the ordinary matrix multiplication,
omitting any terms containing $\bbnum 0$:
\begin{align*}
f\bef g & =\,\begin{array}{||cc|}
\text{id} & \bbnum 0\\
\bbnum 0 & a\rightarrow a\times a
\end{array}\,\bef\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\\
 & =\,\,\begin{array}{||c|}
\text{id}\bef(\_\rightarrow e^{:A})\\
\left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)
\end{array}\,=\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}\quad.
\end{align*}
Applying a function to a disjunctive value such as $x^{:Z+A}$ is
computed by writing $x$ as a row vector:
\[
x=z^{:Z}+\bbnum 0^{:A}=\,\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\quad.
\]
Then the computation $x\triangleright f\bef g$ again follows the
rules of matrix multiplication:
\[
x\triangleright f\bef g=\,\begin{array}{|cc|}
z^{:Z} & \bbnum 0\end{array}\,\triangleright\,\begin{array}{||c|}
\_\rightarrow e^{:A}\\
a\rightarrow a\oplus a
\end{array}\,=z\triangleright(\_\rightarrow e)=e\quad.
\]
Since the standard rules of matrix multiplication are associative,
the properties of the $\triangleright$-notation such as $x\triangleright(f\bef g)=(x\triangleright f)\triangleright g$
are guaranteed to hold with matrices.

To use the matrix notation with \emph{backward} compositions ($f\circ g$),
all code matrices need to be transposed. (A standard identity of matrix
calculus is that the transposition reverses the order of composition:
$\left(AB\right)^{T}=B^{T}A^{T}$.) The input types will then appear
in the \emph{top} \emph{row} and the output types in the left column.
The double line is at the top of a code matrix since that is where
the function inputs come from. The above calculations are then rewritten
as:
\begin{align*}
g\circ f & =\,\begin{array}{|c|cc|}
 & Z & A\times A\\
\hline\hline A & \_\rightarrow e^{:A} & a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}
\end{array}\,\circ\,\begin{array}{|c|cc|}
 & Z & A\\
\hline\hline Z & \text{id} & \bbnum 0\\
A\times A & \bbnum 0 & a\rightarrow a\times a
\end{array}\\
 & =\,\,\begin{array}{|cc|}
\hline\hline \text{id}\bef(\_\rightarrow e^{:A}) & \left(a\rightarrow a\times a\right)\bef\left(a_{1}\times a_{2}\rightarrow a_{1}\oplus a_{2}\right)\end{array}\,=\,\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\quad.\\
(g\circ f)(x) & =\,\begin{array}{|cc|}
\hline\hline \_\rightarrow e^{:A} & a\rightarrow a\oplus a\end{array}\,\,\begin{array}{|c|}
z^{:Z}\\
\bbnum 0
\end{array}\,=(\_\rightarrow e^{:A})(z)=e\quad.
\end{align*}
The \emph{forward} composition ($\bef$) may be easier to read and
to reason about in the matrix notation.

\chapter{Glossary of terms\label{chap:Appendix-Glossary-of-terms}}
\begin{description}
\item [{Code~notation}] \index{code notation}A mathematical notation
developed in this book for deriving properties of code in functional
programs. Variables have optional type annotations, such as $x^{:A}$
or $f^{:A\rightarrow B}$. Nameless functions are denoted by$x^{:A}\rightarrow f$,
products by $a\times b$, and values of a disjunctive type $A+B$
are written as $x^{:A}+\bbnum 0^{:B}$ or $\bbnum 0^{:A}+y^{:B}$.
Functions working with disjunctive types are denoted by matrices.
Lifting of functions to functors, such as $\text{fmap}_{L}(f)$, is
denoted by $f^{\uparrow L}$; function compositions are denoted by
$f\bef g$ (forward composition) and $f\circ g$ (backward composition);
and function applications by $f(x)$ or equivalently $x\triangleright f$.
See Appendix~\ref{chap:Appendix-Notations} for details.
\item [{\index{contrafunctor}Contrafunctor}] A type constructor having
the properties of a contravariant functor\index{contrafunctor} with
respect to a type parameter. Instead of \textsf{``}contravariant functor\textsf{''},
this book uses the shorter name \textsf{``}contrafunctor\textsf{''}.
\item [{Disjunctive~type}] \index{disjunctive type}A type representing
one of several distinct possibilities. In Scala, this is usually implemented
as a sealed trait extended by several case classes. The standard Scala
disjunction types are \lstinline!Option[A]! and \lstinline!Either[A, B]!.
Also known as \index{sum type!see \textsf{``}disjunctive type\textsf{''}}\textbf{sum
}type, \textbf{tagged union}\index{tagged union type!see \textsf{``}disjunctive type\textsf{''}}
type, \textbf{co-product}\index{co-product type!see \textsf{``}disjunctive type\textsf{''}}
type, and variant type (in Object Pascal and in OCaml). The shortest
name is \textsf{``}sum type,\textsf{''} but the English word \textsf{``}disjunctive\textsf{''} is
less ambiguous to the ear than \textsf{``}sum\textsf{''}.
\item [{Exponential-polynomial~type}] \index{exponential-polynomial type}A
type constructor built using products, disjunctions (sums or co-products),
and function types (\textsf{``}exponentials\textsf{''}), as well as type parameters
and fixed types. For example,  \lstinline!type F[A] = Either[(A,A), Int=>A]!
is an exponential-polynomial type constructor. Such type constructors
are always profunctors and can also be functors or contrafunctors.
\item [{\index{functor block}Functor~block}] A short syntax for composing
several \lstinline!map!, \lstinline!flatMap!, and \lstinline!filter!
operations applied to a functor-typed value. The type constructor
corresponding to that value must be a functor and is fixed throughout
the entire functor block. For example, the Scala code
\begin{lstlisting}
for { x <- List(1,2,3); y <- List(10, x); if y > 2 }
  yield 2 * y
\end{lstlisting}
is equivalent to the code
\begin{lstlisting}
List(1, 2, 3).flatMap(x => List(10, x))
  .filter(y => y > 1).map(y => 2 * y)
\end{lstlisting}
and computes the value \lstinline!List(20, 20, 20, 6)!. This is a
functor block that \textsf{``}raises\textsf{''} computations to the \lstinline!List!
functor. Similar syntax exists in a number of languages and is called
a \textbf{\textsf{``}for-comprehension\textsf{''}}\index{for-comprehensions (Python)@\texttt{for}-comprehensions (Python)}
or a \textsf{``}list comprehension\textsf{''} in Python, \textbf{\textsf{``}do-notation\textsf{''}}\index{do-notation (Haskell)@\texttt{do}-notation (Haskell)}
in Haskell, and \textbf{\textsf{``}computation expressions\textsf{''}}\index{computation expressions (F#)@computation expressions (F\#)}
in F\#. I use the name \textsf{``}functor block\textsf{''} in this book because it
is shorter and more descriptive. (The type constructor used in a functor
block needs to be at least a functor but does not have to be a monad.)
\item [{Kleisli~function}] \index{Kleisli!functions} A function with
type signature $A\rightarrow M^{B}$ (in Scala, \lstinline!A => M[B]!)
for some fixed monad $M$. Also called a Kleisli morphism\index{Kleisli!morphisms}
(a morphism in the Kleisli category corresponding to the monad $M$).
The monadic method $\text{pure}_{M}:A\rightarrow M^{A}$ has the type
signature of a Kleisli function. The Kleisli composition operation,
$\diamond_{M}$, is a binary operation that combines two Kleisli functions
(of types $A\rightarrow M^{B}$ and $B\rightarrow M^{C}$) into a
new Kleisli function (of type $A\rightarrow M^{C}$).
\item [{\index{method}Method}] This word is used in two ways: 1) A method$_{1}$
is a Scala function defined as a member of a typeclass. For example,
\lstinline!flatMap! is a method defined in the \lstinline!Monad!
typeclass. 2) A method$_{2}$ is a Scala function defined as a member
of a data type declared as a Java-compatible \lstinline!class! or
\lstinline!trait!. Trait methods$_{2}$ are necessary in Scala when
implementing functions whose arguments have type parameters (because
Scala function values defined via \lstinline!val! cannot have type
parameters). So, many typeclasses such as \lstinline!Functor! or
\lstinline!Monad!, whose methods$_{1}$ require type parameters,
will use Scala \lstinline!traits! with methods$_{2}$ for their implementation.
The same applies to type constructions with quantified types, such
as the Church encoding. 
\item [{Nameless~function}] \index{nameless function}An expression of
function type, representing a function. For example, \lstinline!(x: Int) => x * 2!.
Also known as function expression, function literal, anonymous function,\index{anonymous function!see \textsf{``}nameless functions\textsf{''}}
closure, \index{lambda-function!see \textsf{``}nameless function\textsf{''}}lambda-function,
lambda-expression, or simply a \textsf{``}lambda\textsf{''}.
\item [{Partial~type-to-value~function~(PTVF)}] A function with a type
parameter but defined only for a certain subset of types.\index{partial type-to-value function}
In Scala, PTVFs are implemented via a typeclass constraint:
\begin{lstlisting}
def double[T: Semigroup](t: T): T = implicitly[Semigroup[T]].combine(t, t)
\end{lstlisting}
This PTVF is defined only for types \lstinline!T! for which a \lstinline!Semigroup!
typeclass instance is available.
\item [{Polynomial~functor}] \index{polynomial functor}A type constructor
built using disjunctions (sums), products (tuples), type parameters
and fixed types. For example, in Scala, \lstinline!type F[A] = Either[(Int, A), A]!
is a polynomial functor with respect to the type parameter \lstinline!A!,
while \lstinline!Int! is a fixed type (not a type parameter). Polynomial
functors are also known as \textbf{algebraic data types}\index{algebraic data types}.
\item [{Product~type}] \index{product type}A type representing several
values given at once. In Scala, product types are the tuple types,
for example \lstinline!(Int, String)!, and case classes. Also known
as \index{tuples}\textbf{tuple} type, \textbf{struct} (in C and C++),
and \textbf{record}.
\item [{\index{profunctor}Profunctor}] A type constructor whose type parameter
occurs in both covariant and contravariant positions and satisfying
the appropriate laws; see Section~\ref{subsec:f-Profunctors}.
\item [{Type~notation}] \index{type notation}A mathematical notation
for type expressions developed in this book for easier reasoning about
types in functional programs. Disjunctive types are denoted by $+$,
product types by $\times$, and function types by $\rightarrow$.
The unit type is denoted by $\bbnum 1$, and the void type by $\bbnum 0$.
The function arrow $\rightarrow$ groups weaker than $+$, which in
turn groups weaker than $\times$. This means
\[
Z+A\rightarrow Z+A\times A\quad\text{is the same as}\quad\left(Z+A\right)\rightarrow\left(Z+\left(A\times A\right)\right)\quad.
\]
 Type parameters are denoted by superscripts. As an example, the Scala
definition\texttt{}
\begin{lstlisting}
type F[A] = Either[(A, A => Option[Int]), String => List[A]]
\end{lstlisting}
is written in the type notation as 
\[
F^{A}\triangleq A\times\left(A\rightarrow\bbnum 1+\text{Int}\right)+(\text{String}\rightarrow\text{List}^{A})\quad.
\]
\item [{\index{unfunctor}Unfunctor}] A type constructor that cannot possibly
be a functor, nor a contrafunctor, nor a profunctor. An example is
a type constructor with explicitly indexed type parameters, such as
$F^{A}\triangleq\left(A\times A\right)^{:F^{\text{Int}}}+\left(\text{Int}\times A\right)^{:F^{\bbnum 1}}$.
The Scala code for this type constructor is
\begin{lstlisting}
sealed trait F[A]
final case class F1[A](x: A, y: A)   extends F[Int]
final case class F2[A](s: Int, t: A) extends F[Unit]
\end{lstlisting}
This can be seen as a \index{GADT!see \textsf{``}unfunctor\textsf{''}}\textbf{GADT}
(generalized algebraic data type) that uses specific values of type
parameters instead of the type parameter $A$ in at least some of
its case classes.
\end{description}

\section{How the term \textquotedblleft algebra\textquotedblright{} is used
in functional programming}

This book avoids using the terms \textsf{``}algebra\index{algebra}\textsf{''} or
\textsf{``}algebraic\index{algebraic}\textsf{''} because these terms are too ambiguous.
As we will see, the FP community uses the word \textsf{``}algebra\textsf{''} in at
least \emph{three} incompatible ways.

\paragraph{Definition 0.}

In mathematics, an \textquotedblleft algebra\textquotedblright{} is
a vector space with a multiplication operation ($*$) satisfying certain
properties, such as distributivity: $z*(x+y)=z*x+z*y$. For example,
the set of all $10\times10$ matrices with real coefficients is a
$100$-dimensional vector space that satisfies the required properties.
Such matrices form an \textquotedblleft algebra\textquotedblright{}
in the mathematical sense. (This meaning of the word \textsf{``}algebra\textsf{''}
is \emph{not} used in FP.)

\paragraph{Definition 1.}

For a given functor $F$, an \textsf{``}$F$-algebra\textsf{''}\index{$F$-algebra}
is a type $T$ and a function with type signature $F^{T}\rightarrow T$.
(This definition comes from category theory. This book does not use
$F$-algebras because knowing their category-theoretic properties
does not help in practical programming.) The name \textsf{``}$F$-algebra\textsf{''}
emphasizes the dependence on a chosen functor $F$. There is no direct
connection between this \textsf{``}algebra\textsf{''} and Definition~0, except when
the functor $F$ is defined by $F^{A}\triangleq A\times A$: a function
of type $T\times T\rightarrow T$ may then be interpreted as a \textsf{``}multiplication\textsf{''}
operation for values of type $T$. However, even in that case $T$
will not necessarily satisfy the laws of a vector space.

A recursive type $T$ defined by $F^{T}\cong T$ has an isomorphism
$F^{T}\rightarrow T$ and so is an $F$-algebra. Recursive polynomial
types are known as \textsf{``}algebraic\textsf{''} in this sense:\footnote{For some proofs, see \texttt{\href{https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt}{https://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt}} }
they are $F$-algebras with a polynomial recursion scheme $F^{\bullet}$
and an added requirement of isomorphism for the map $F^{T}\rightarrow T$.

The \textsf{``}algebra\textsf{''} defined in this sense is also relevant to the Church
encoding of a free monad (also known as the \textsf{``}tagless final\index{tagless final}\textsf{''}
pattern), which is the type $\forall E^{\bullet}.\,(S^{E^{\bullet}}\leadsto E^{\bullet})\rightarrow E^{A}$.
This type uses a higher-order type $S^{E^{\bullet}}$ parameterized
by a \emph{type constructor} parameter $E^{\bullet}$. In this context,
one calls an \textsf{``}algebra\textsf{''} a value of type $S^{E^{\bullet}}\leadsto E^{\bullet}$,
which is an $S$-algebra in the category of type constructors. However,
knowing that $S^{E^{\bullet}}\leadsto E^{\bullet}$ is an $S$-algebra
in the category of type constructors does not provide any help or
additional insights for practical work with the Church encoding of
free monads.

The higher-order type constructor $S$ is used to parameterize the
effects described by a Church-encoded free monad, so this book calls
it the \textsf{``}effect constructor\textsf{''}.

\paragraph{Definition 2.}

Polynomial data types (for example, \lstinline!type F[A] = Option[(A, A)]!)
are called \textquotedblleft algebraic data types\index{algebraic data types}\textquotedblright .
Here, the word \textsf{``}algebraic\textsf{''} suggests \textsf{``}school-level algebra\textsf{''}
dealing with polynomials: those data types are built from \textsf{``}sums\textsf{''}
and \textsf{``}products\textsf{''} of types. The type \lstinline!F[A]! may admit
some binary or unary operations, but this does not turn it into an
algebra in the sense of Definitions~0 or 1. Instead of calling types
\textsf{``}algebraic\textsf{''}, this book uses more precise terms \textquotedblleft polynomial
types\textquotedblright{} and \textquotedblleft exponential-polynomial
types\textquotedblright . Data types containing functions, such as
\lstinline!Option[Int => (A, A)]!, are exponential-polynomial (but
not polynomial).

\paragraph{Definition 3.}

One talks about the \textquotedblleft algebra\textquotedblright{}
of properties of functions such as \lstinline!map! or \lstinline!flatMap!,
meaning that these functions satisfy certain \textsf{``}algebraic\textsf{''} laws
(e.g., the composition, naturality, or associativity laws). But these
laws do not make functions \lstinline!map! or \lstinline!flatMap!
into an algebra in the sense of Definition~0 or in the sense of Definition~1.
There is also no relation to the algebraic data types of Definition~2.
So, this is a different usage of the word \textsf{``}algebra\textsf{''}. However,
there is no general \textsf{``}algebra of laws\textsf{''} that we can use; every derivation
proceeds in a different way, specific to the laws being proved. In
mathematics, \textsf{``}algebraic\textsf{''} equations are distinguished from differential
or integral equations. In that sense, the laws used in FP are \emph{always}
algebraic: they are just equations with compositions and applications
of functions. So, there is no advantage in calling laws \textsf{``}algebraic\textsf{''}
within the context of FP. This book calls them \textsf{``}equations\textsf{''} or
just \textsf{``}laws\textsf{''}.

We find that the current usage of the word \textsf{``}algebra\textsf{''} in FP is
both inconsistent and unhelpful to software practitioners. In this
book, the word \textsf{``}algebra\textsf{''} always means a branch of mathematics,
as in \textsf{``}high-school algebra\textsf{''}. Instead of \textsf{``}algebras\textsf{''} as in Definitions~1
to~3, this book talks about \textsf{``}polynomial types\textsf{''} or \textsf{``}recursive
polynomial types\textsf{''}; \textsf{``}equations\textsf{''} or \textsf{``}laws\textsf{''}; and an \textsf{``}effect
constructor\textsf{''} $S$. 

\chapter{Deriving code from types. The LJT algorithm\label{app:The-LJT-algorithm}}

We have seen in Chapter~\ref{chap:5-Curry-Howard} how to derive
code from a type signature as long as one has a proof of the sequent
corresponding to that type signature. But Section~\ref{subsec:Example:-Proving-a-ch-proposition}
gave an example showing that the rules in Table~\ref{tab:Proof-rules-of-constructive-and-boolean}
do not provide an algorithm for finding a proof for a given sequent.

To illustrate this problem on another example, let us try proving
the sequent:
\[
A,B\vee C\vdash(A\wedge B)\vee C\quad.
\]
We expect that this sequent is provable because we can write the corresponding
Scala code:
\begin{lstlisting}
def f[A, B, C](a: A): Either[B, C] => Either[(A, B), C] = {
  case Left(b)    => Left((a, b))
  case Right(c)   => Right(c)
}
\end{lstlisting}
How can we obtain a proof of this sequent according to the rules in
Table~\ref{tab:Proof-rules-of-constructive-and-boolean}? We find
that we could potentially apply the rules \textsf{``}create \lstinline!Left!\textsf{''},
\textsf{``}create \lstinline!Right!\textsf{''}, \textsf{``}use \lstinline!Either!\textsf{''}, and
\textsf{``}use function\textsf{''}. However, no matter what rule we choose, we will
get stuck at the next step. Let us see why:

To apply \textsf{``}create \lstinline!Left!\textsf{''}, we first need to prove the
sequent $A,B\vee C\vdash A\wedge B$. But this sequent cannot be proved:
we do not necessarily have values of both types $A$ and $B$ if we
are only given values of type $A$ and of type \lstinline!Either[B, C]!.
To apply \textsf{``}create \lstinline!Right!\textsf{''}, we need to prove the sequent
$A,B\vee C\vdash C$. Again, we find that this sequent cannot be proved.
The next choice is the rule \textsf{``}use \lstinline!Either!\textsf{''} that matches
any goal of the sequent as the proposition $\gamma$. But we are then
required to choose two new propositions ($\alpha$ and $\beta$) such
that we can prove $A,B\vee C\vdash\alpha\vee\beta$ as well as $A,B\vee C,\alpha\vdash(A\wedge B)\vee C$
and $A,B\vee C,\beta\vdash(A\wedge B)\vee C$. It is not clear how
we should choose $\alpha$ and $\beta$ in order to make progress
in the proof. The remaining rule, \textsf{``}use function\textsf{''}, similarly requires
us to choose a new proposition $\alpha$ such that we can prove $A,B\vee C\vdash\alpha$
and $A,B\vee C\vdash\alpha\Rightarrow((A\wedge B)\vee C)$. Again,
the algorithm gives us no guidance about choosing $\alpha$.

We see that the rules in Table~\ref{tab:Proof-rules-for-constructive-logic}
are not helpful for proof search. Certain rules (\textsf{``}use function\textsf{''}
and \textsf{``}use \lstinline!Either!\textsf{''}) require us to choose new unknown
propositions and prove more complicated sequents than the ones we
had before. For instance, the rule \textsf{``}use function\textsf{''} gives a proof
of $\Gamma\vdash\beta$ if we first choose some other proposition
$\alpha$ and prove the sequents $\Gamma\vdash\alpha$ and $\Gamma\vdash\alpha\Rightarrow\beta$.
The rule does not say how to choose the proposition $\alpha$ correctly.
We need to guess the correct $\alpha$ by trial and error. Even after
choosing $\alpha$ in some way, we will have to prove a more complicated
sequent ($\Gamma\vdash\alpha\Rightarrow\beta$). It is not guaranteed
that we are getting closer to finding the proof of the initial sequent
($\Gamma\vdash\beta$). 

It is far from obvious how to overcome that difficulty. Mathematicians
have studied the constructive logic for more than 60 years, trying
to replace the rules in Table~\ref{tab:Proof-rules-of-constructive-and-boolean}
by a different but equivalent set of derivation rules that require
no guessing when looking for a proof. The first partial success came
in 1935 with an algorithm called \textsf{``}LJ\textsf{''}.\footnote{See \texttt{\href{https://en.wikipedia.org/wiki/Sequent_calculus\#Overview}{https://en.wikipedia.org/wiki/Sequent\_calculus\#Overview}}}
The LJ algorithm still had a significant problem: one of its derivation
rules may be applied infinitely many times. So, the LJ algorithm is
not guaranteed to terminate without some heuristics for avoiding an
infinite loop. A terminating version of the LJ algorithm, called \index{LJT algorithm}LJT,
was formulated in 1992.\footnote{The history of this research is outlined in \texttt{\href{https://research-repository.st-andrews.ac.uk/handle/10023/8824}{https://research-repository.st-andrews.ac.uk/handle/10023/8824}}.
An often cited paper by R.~Dyckhoff\index{Roy Dyckhoff} is \texttt{\href{https://philpapers.org/rec/DYCCSC}{https://philpapers.org/rec/DYCCSC}}} 

We will first present the LJ algorithm. Although that algorithm does
not guarantee termination, it is simpler to apply by hand. Then we
will show how to pass from the LJ algorithm to LJT.

\section{The LJ algorithm}

Figure~\ref{fig:Rules-of-the-LJ-algorithm} shows the LJ algorithm\textsf{'}s
axioms and derivation rules. Each rule says that the bottom sequent
will be proved if proofs are given for sequent(s) at the top. For
each possible sub-expression (conjunction $X\wedge Y$, disjunction
$X\vee Y$, and implication $X\Rightarrow Y$) there is one rule where
that sub-expression is a premise (at \textsf{``}left\textsf{''}) and one rule where
that sub-expression is the goal (at \textsf{``}right\textsf{''}). Those sub-expressions
are shown in blue in Figure~\ref{fig:Rules-of-the-LJ-algorithm}
to help us look for a proof. To find out which rules apply, we just
need to match some part of the sequent to a blue sub-expression in
the rules.

\begin{figure}
\begin{centering}
\fbox{\begin{minipage}[t]{0.7\linewidth}%
\begin{align*}
\frac{}{\Gamma,X\vdash{\color{blue}X}}~(\text{Id})\qquad & \qquad\frac{}{\Gamma\vdash{\color{blue}\top}}~(\text{True})\\
\frac{\Gamma,A\Rightarrow B\vdash A\quad\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\Rightarrow B}\vdash C}~(\text{Left}\Rightarrow)\qquad & \qquad\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\Rightarrow B}}~(\text{Right}\Rightarrow)\\
\frac{\Gamma,A_{i}\vdash C}{\Gamma,{\color{blue}A_{1}\wedge A_{2}}\vdash C}~(\text{Left}\wedge_{i})\qquad & \qquad\frac{\Gamma\vdash A\quad\quad\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\wedge B}}~(\text{Right}\wedge)\\
\frac{\Gamma,A\vdash C\quad\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\vee B}\vdash C}~(\text{Left}\vee)\qquad & \qquad\frac{\Gamma\vdash A_{i}}{\Gamma\vdash{\color{blue}A_{1}\vee A_{2}}}~(\text{Right}\vee_{i})
\end{align*}
%
\end{minipage}}
\par\end{centering}
\caption{Axioms and derivation rules of the LJ algorithm. Each of the rules
\textquotedblleft ($\text{Left}\wedge_{i}$)\textquotedblright{} and
\textquotedblleft ($\text{Right}\vee_{i}$)\textquotedblright{} have
two versions, with $i=1$ or $i=2$. \label{fig:Rules-of-the-LJ-algorithm}}
\end{figure}

It turns out that the rules in Figure~\ref{fig:Rules-of-the-LJ-algorithm}
are equivalent to the rules in Table~\ref{tab:Proof-rules-for-constructive-logic}.
The proof is beyond the scope of this book. We only remark that this
equivalence is far from obvious. To prove it, one needs to demonstrate
that any sequent derived through the first set of rules is also derivable
through the second set, and vice versa.

To illustrate the LJ algorithm, let us prove the sequent~(\ref{eq:ch-example-sequent-2}).
Denote that sequent by $S_{0}$:
\[
S_{0}\triangleq\emptyset\vdash\left(\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\right)\Rightarrow\beta\quad.
\]
 Since the goal of $S_{0}$ contains an implication, we use the rule
\textsf{``}($\text{Right}\Rightarrow$)\textsf{''} and get a sequent $S_{1}$:
\[
S_{1}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\vdash\beta\quad.
\]
Now the implication is in the premise, so we use the rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''}
and get two new sequents:
\[
S_{2}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\vdash\alpha\Rightarrow\alpha\quad,\quad\quad S_{3}\triangleq\beta\vdash\beta\quad.
\]
Sequent $S_{3}$ follows from the \textsf{``}(Id)\textsf{''} axiom, so it remains
to prove $S_{2}$. Since $S_{2}$ contains an implication both as
a premise and as the goal, we may apply either the rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''}
or the rule \textsf{``}($\text{Right}\Rightarrow$)\textsf{''}. We choose to apply
\textsf{``}($\text{Left}\Rightarrow$)\textsf{''} and get two new sequents:
\[
S_{4}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta\vdash\alpha\Rightarrow\alpha\quad,\quad\quad S_{5}:\beta\vdash\alpha\Rightarrow\alpha\quad.
\]
Notice that $S_{4}=S_{2}$. So, our proof search is getting into an
infinite loop trying to prove the same sequent $S_{2}$ over and over
again. We can prove $S_{5}$ but this will not help us break the loop.

Once we recognize the problem, we backtrack to the point where we
chose to apply \textsf{``}($\text{Left}\Rightarrow$)\textsf{''} to $S_{2}$. That
was a bad choice, so let us instead apply \textsf{``}($\text{Right}\Rightarrow$)\textsf{''}
to $S_{2}$. This yields a new sequent $S_{6}$:
\[
S_{6}\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta,\alpha\vdash\alpha\quad.
\]
This sequent follows from the \textsf{``}(Id)\textsf{''}axiom. There are no more sequents
to prove, so the proof of $S_{0}$ is finished. It can be drawn as
a \index{proof tree}\textbf{proof tree} like this:
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{4pc} &  &  & (\text{Id})\\
\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){S_{1}} & (\text{Left}\Rightarrow)\ar[r]\sp(0.5){S_{2}}\ar[ru]\sp(0.6){S_{3}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.65){S_{6}} & (\text{Id})
}
\]
The nodes of the proof tree are axioms or derivation rules, and the
edges are intermediate sequents required by the rules. Some rule nodes
branch into several sequents because some rules require more than
one new sequent to be proved. The leaves of the tree are axioms that
do not require proving any further sequents. 

\subsection{Extracting code from proofs}

In the Curry-Howard correspondence, a sequent (such as $A,B,...,C\vdash X$)
represents the task of writing a fully parametric code expression
of type $X$ that uses some given values of types $A$, $B$, ...,
$C$. The sequent is true (i.e., provable) if that code expression
can be found. So, the code serves as an \textsf{``}evidence of proof\textsf{''} for
the sequent.

\begin{figure}
\begin{centering}
\noindent\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{align*}
\frac{}{\Gamma,A\vdash{\color{blue}A}}~(\text{Id})\quad & \quad\text{Proof}\,(\Gamma,A\vdash A)_{\text{given }p^{:\Gamma},x^{:A}}=x\\
\frac{}{\Gamma\vdash{\color{blue}\top}}~(\text{True})\quad & \quad\text{Proof}\,(\Gamma\vdash\top)_{\text{given }p^{:\Gamma}}=1\\
\frac{\Gamma,A\Rightarrow B\vdash A\quad\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\Rightarrow B}\vdash C}~(\text{Left}\Rightarrow)\quad & \quad\text{Proof}\,(\Gamma,A\Rightarrow B\vdash C)_{\text{given }p^{:\Gamma},q^{:A\rightarrow B}}=\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p,b^{:B}}\\
 & \quad\quad\text{where}\quad b^{:B}\triangleq q\big(\text{Proof}\,(\Gamma,A\Rightarrow B\vdash A)_{\text{given }p,q}\big)\\
\frac{\Gamma,A\vdash B}{\Gamma\vdash{\color{blue}A\Rightarrow B}}~(\text{Right}\Rightarrow)\quad & \quad\text{Proof}\,(\Gamma\vdash A\Rightarrow B)_{\text{given }p^{:\Gamma}}=x^{:A}\rightarrow\text{Proof}\,(\Gamma,A\vdash B)_{\text{given }p^{:\Gamma},x^{:A}}\\
\frac{\Gamma,A\vdash C}{\Gamma,{\color{blue}A\wedge B}\vdash C}~(\text{Left}\wedge_{1})\quad & \quad\text{Proof}\,(\Gamma,A\wedge B\vdash C)_{\text{given }p^{:\Gamma},(a^{:A}\times b^{:B})}\\
 & \quad\quad=\text{Proof}\,(\Gamma,A\vdash C)_{\text{given }p^{:\Gamma},a^{:A}}\\
\frac{\Gamma,B\vdash C}{\Gamma,{\color{blue}A\wedge B}\vdash C}~(\text{Left}\wedge_{2})\quad & \quad\text{Proof}\,(\Gamma,A\wedge B\vdash C)_{\text{given }p^{:\Gamma},(a^{:A}\times b^{:B})}\\
 & \quad\quad=\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p^{:\Gamma},b^{:B}}\\
\frac{\Gamma\vdash A\quad\quad\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\wedge B}}~(\text{Right}\wedge)\quad & \quad\text{Proof}\,(\Gamma\vdash A\wedge B)_{\text{given }p^{:\Gamma}}\\
 & \quad\quad=\text{Proof}\,(\Gamma\vdash A)_{\text{given }p^{:\Gamma}}\times\text{Proof}\,(\Gamma\vdash B)_{\text{given }p^{:\Gamma}}\\
\frac{\Gamma,A\vdash C\quad\quad\Gamma,B\vdash C}{\Gamma,{\color{blue}A\vee B}\vdash C}~(\text{Left}\vee)\quad & \quad\text{Proof}\,(\Gamma,A\vee B\vdash C)_{\text{given }p^{:\Gamma},q^{:A+B}}\\
 & \quad\quad=q\triangleright\begin{array}{|c||c|}
 & C\\
\hline A & x^{:A}\rightarrow\text{Proof}\,(\Gamma,A\vdash C)_{\text{given }p,x}\\
B & y^{:B}\rightarrow\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p,y}
\end{array}\\
\frac{\Gamma\vdash A}{\Gamma\vdash{\color{blue}A\vee B}}~(\text{Right}\vee_{1})\quad & \quad\text{Proof}\,(\Gamma\vdash A\vee B)_{\text{given }p^{:\Gamma}}=\text{Proof}\,(\Gamma\vdash A)+\bbnum 0^{:B}\\
\frac{\Gamma\vdash B}{\Gamma\vdash{\color{blue}A\vee B}}~(\text{Right}\vee_{2})\quad & \quad\text{Proof}\,(\Gamma\vdash A\vee B)_{\text{given }p^{:\Gamma}}=\bbnum 0^{:A}+\text{Proof}\,(\Gamma\vdash B)
\end{align*}
%
\end{minipage}}
\par\end{centering}
\caption{\label{fig:proof-transformers-for-LJ-rules}Proof transformers for
the rules of the LJ algorithm.}
\end{figure}

In the previous section, we have found a proof of the sequent $S_{0}$,
which represents the task of writing a fully parametric function with
type signature $(\left(A\rightarrow A\right)\rightarrow B)\rightarrow B$).
Let us now see how we can extract the code of that function from the
proof of the sequent $S_{0}$.

We start from the leaves of the proof tree and move step by step towards
the initial sequent. At each step, we shorten the proof tree by replacing
some sequent by its corresponding evidence-of-proof code. Eventually
we will replace the initial sequent by its corresponding code. Let
us see how this procedure works for the proof tree of the sequent
$S_{0}$ shown in the previous section.

Since the leaves are axioms, let us write the code corresponding to
each axiom of LJ:
\begin{align*}
 & \frac{}{\Gamma,X\vdash X}~(\text{Id})\quad:\quad\quad\text{Proof}\,(\Gamma,X\vdash X)_{\text{given }p^{:\Gamma},x^{:X}}=x\quad;\\
 & \frac{}{\Gamma\vdash\top}~(\text{True})\quad:\quad\quad\text{Proof}\,(\Gamma\vdash\top)_{\text{given }p^{:\Gamma}}=1\quad.
\end{align*}
Here we denote explicitly the values (such as $p$ and $x$) given
as premises to the sequent. The notation $p^{:\Gamma}$ means all
values given in the set of premises $\Gamma$. Below we will assume
that the propositions $\alpha$ and $\beta$ correspond to types $A$
and $B$; that is, $\alpha\triangleq{\cal CH}(A)$ and $\beta\triangleq{\cal CH}(B)$.

The leaves in the proof tree for $S_{0}$ are the \textsf{``}($\text{Id}$)\textsf{''}
axioms used to prove the sequents $S_{3}$ and $S_{6}$. Let us write
the code that serves as the \textsf{``}evidence of proof\textsf{''} for these sequents.
For brevity, we denote $\gamma\triangleq\left(\alpha\Rightarrow\alpha\right)\Rightarrow\beta$
and $C\triangleq\left(A\rightarrow A\right)\rightarrow B$, so that
$\gamma={\cal CH}(C)$. Then we can write:
\begin{align*}
 & S_{3}\triangleq\beta\vdash\beta\quad,\quad\quad\text{Proof}\,(S_{3})_{\text{given }y^{:B}}=y\quad,\\
 & S_{6}\triangleq\gamma,\alpha\vdash\alpha\quad,\quad\quad\text{Proof}\,(S_{6})_{\text{given }q^{:C},x^{:A}}=x\quad.
\end{align*}
Note that the proof of $S_{6}$ does not use the first given value
$q^{:C}$ (corresponding to the premise $\gamma$).

We now shorten the proof tree by replacing the sequents $S_{3}$ and
$S_{6}$ by their \textsf{``}evidence of proof\textsf{''}:
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{4pc} &  &  & \square\\
\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){S_{1}} & (\text{Left}\Rightarrow)\ar[r]\sp(0.5){S_{2}}\ar[ru]\sp(0.6){(y)_{\text{given }y^{:B}}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.65){(x)_{\text{given }q^{:C},x^{:A}}} & \square
}
\]

The next step is to consider the proof of $S_{2}$, which is found
by applying the rule \textsf{``}($\text{Right}\Rightarrow$)\textsf{''}. This rule
promises to give a proof of $S_{2}$ if we have a proof of $S_{6}$.
In order to extract code from that rule, we can write a function that
transforms a proof of $S_{6}$ into a proof of $S_{2}$. We call this
function the \textbf{proof transformer}\index{Curry-Howard correspondence!proof transformer}\index{proof transformer}
corresponding to the rule \textsf{``}($\text{Right}\Rightarrow$)\textsf{''}. That
rule and its transformer are defined as:
\[
\frac{\Gamma,A\vdash B}{\Gamma\vdash A\Rightarrow B}~(\text{Right}\Rightarrow)\quad:\quad\quad\text{Proof}\,(\Gamma\vdash A\Rightarrow B)_{\text{given }p^{:\Gamma}}=x^{:A}\rightarrow\text{Proof}\,(\Gamma,A\vdash B)_{\text{given }p^{:\Gamma},x^{:A}}\quad.
\]
Applying the proof transformer to the known proof of $S_{6}$, we
obtain a proof of $S_{2}$:
\[
\text{Proof}\,(S_{2})_{\text{given }q^{:C}}=x^{:A}\rightarrow\text{Proof}\,(S_{6})_{\text{given }q^{:C},x^{:A}}=(x^{:A}\rightarrow x)_{\text{given }q^{:C}}\quad.
\]
The proof tree can be now shortened to:
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3.5pc} &  &  & \square\\
\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){S_{1}} & (\text{Left}\Rightarrow)\ar[rr]\sp(0.62){(x^{:A}\rightarrow x)_{\text{given }q^{:C}}}\ar[ru]\sp(0.6){(y)_{\text{given }y^{:B}}} &  & \square
}
\]

The next step is to get the proof of $S_{1}$ obtained by applying
the rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''}. That rule requires two
previous sequents, so its transformer is a function of two previously
obtained proofs:
\begin{align*}
 & \frac{\Gamma,A\Rightarrow B\vdash A\quad\quad\Gamma,B\vdash C}{\Gamma,A\Rightarrow B\vdash C}~(\text{Left}\Rightarrow)\quad:\\
 & \text{Proof}\,(\Gamma,A\Rightarrow B\vdash C)_{\text{given }p^{:\Gamma},q^{:A\rightarrow B}}=\text{Proof}\,(\Gamma,B\vdash C)_{\text{given }p^{:\Gamma},b^{:B}}\\
 & \quad\quad\text{where}\quad b^{:B}\triangleq q\big(\text{Proof}\,(\Gamma,A\Rightarrow B\vdash A)_{\text{given }p^{:\Gamma},q^{:A\rightarrow B}}\big)\quad.
\end{align*}
In the proof tree shown above, we obtain a proof of $S_{1}$ by applying
this proof transformer to the proofs of $S_{2}$ and $S_{3}$:
\begin{align*}
 & \text{Proof}\,(S_{1})_{\text{given }q^{:C}}=\text{Proof}\,(S_{3})_{\text{given }b^{:B}}\text{ where }b^{:B}\triangleq q(\text{Proof}\,(S_{2}))_{\text{given }q^{:C}}\\
 & \quad=b\text{ where }b^{:B}\triangleq q(x^{:A}\rightarrow x)_{\text{given }q^{:C}}=q(x^{:A}\rightarrow x)_{\text{given }q^{:C}}\quad.
\end{align*}
Substituting this proof into the proof tree, we shorten the tree to:
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{3.5pc}\ar[r]\sp(0.35){S_{0}} & (\text{Right}\Rightarrow)\ar[r]\sp(0.65){q(x^{:A}\rightarrow x)_{\text{given }q^{:C}}} & \square}
\]

It remains to obtain the proof of $S_{0}$ by applying the proof transformer
of the rule \textsf{``}($\text{Right}\Rightarrow$)\textsf{''}:
\begin{align*}
 & \text{Proof}\,(S_{0})=\text{Proof}\,(\emptyset\vdash(\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta)\\
 & =q^{:(A\rightarrow A)\rightarrow B}\rightarrow\text{Proof}\,(S_{1})_{\text{given }q^{:C}}=q^{:(A\rightarrow A)\rightarrow B}\rightarrow q(x^{:A}\rightarrow x)\quad.
\end{align*}
The proof tree is now shortened to a single code expression, $q^{:(A\rightarrow A)\rightarrow B}\rightarrow q(x^{:A}\rightarrow x)$,
that serves as an evidence of proof for $S_{0}$ because this code
has type $\left(\left(A\rightarrow A\right)\rightarrow B\right)\rightarrow B$.
In this way, we have derived the code of a fully parametric function
from its type signature.

Figure~\ref{fig:proof-transformers-for-LJ-rules} shows the proof
transformers for all the rules of the LJ algorithm. Apart from the
special rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''}, all other rules have
proof transformers using just one of the code constructions (\textsf{``}create
function\textsf{''}, \textsf{``}create tuple\textsf{''}, \textsf{``}use tuple\textsf{''}, etc.) allowed within
fully parametric code.

\section{The LJT algorithm}

As we have seen, the LJ algorithm can enter a loop if we apply the
rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''} and obtain a sequent we already
had at a previous step. That rule requires us to prove two new sequents:
\[
\frac{\Gamma,A\Rightarrow B\vdash A\quad\quad\Gamma,B\vdash C}{\Gamma,A\Rightarrow B\vdash C}~(\text{Left}\Rightarrow)\quad.
\]
A sign of trouble is that the first of these sequents ($\Gamma,A\Rightarrow B\vdash A$)
does not have a simpler form than the initial sequent ($\Gamma,A\Rightarrow B\vdash C$).
So, it is not clear that we are getting closer to completing the proof.
If $A=C$, the new sequent will simply repeat the initial sequent,
immediately creating a loop.

In some cases, a repeated sequent will occur after more than one step.
It is not easy to formulate rigorous conditions for stopping the loop
or for avoiding the rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''}.

The LJT algorithm solves this problem by removing the rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''}
from the LJ algorithm. Instead, \emph{four} new rules are introduced.
Each of these rules contains a different pattern instead of $A$ in
the premise $A\Rightarrow C$:
\begin{align*}
\text{(}A\text{ is atomic)\,}\frac{\Gamma,A,B\vdash D}{\Gamma,A,{\color{blue}A\Rightarrow B}\vdash D}~(\text{Left}\Rightarrow_{A})\qquad & \qquad\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\wedge B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\wedge})\\
\frac{\Gamma,B\Rightarrow C\vdash A\Rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\Rightarrow B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\Rightarrow})\qquad & \qquad\frac{\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\vee B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\vee})
\end{align*}
The rule \textsf{``}$\text{Left}\Rightarrow_{A}$\textsf{''} applies only if the implication
starts with an \textsf{``}atomic\textsf{''} type expression, i.e., a single type parameter
or a unit type. In all other cases, the implication must start with
a conjunction, a disjunction, or an implication, which means that
one of the three remaining rules will apply.

The LJT algorithm retains all the rules in Figure~\ref{fig:proof-transformers-for-LJ-rules}
except the rule \textsf{``}($\text{Left}\Rightarrow$)\textsf{''}, which is replaced
by the four new rules. It is far from obvious that the new rules are
equivalent to the old ones. It took mathematicians several decades
to come up with the LJT rules and to prove their validity. This book
will rely on that result and will not attempt to prove it.

The proof transformers for the new rules are shown in Figure~\ref{fig:proof-transformers-for-LJT-rules}.
Figures~\ref{fig:proof-transformers-for-LJ-rules}\textendash \ref{fig:proof-transformers-for-LJT-rules}
define the set of proof transformers sufficient for using the LJT
algorithm in practice. The \index{curryhoward library@\texttt{curryhoward} library}\lstinline!curryhoward!
library\texttt{}\footnote{See \texttt{\href{https://github.com/Chymyst/curryhoward}{https://github.com/Chymyst/curryhoward}}}
implements these proof transformers.

The most complicated of the new rules is the rule \textsf{``}($\text{Left}\Rightarrow_{\Rightarrow}$)\textsf{''}.
Applying that rule\textsf{'}s transformer results in evidence-of-proof code
that is longer than the code obtained via LJ\textsf{'}s rule transformers.
The resulting code will need to be simplified symbolically. 

As an example of using the LJT algorithm, we prove the sequent $S_{0}=\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta$
from the previous section. At each step, only one LJT rule applies
to each sequent. The initial part of the proof tree looks like this:\vspace{-1\baselineskip}
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{6pc} &  &  & ~\\
\ar[r]\sp(0.4){\emptyset\vdash((\alpha\Rightarrow\alpha)\Rightarrow\beta)\Rightarrow\beta} & (\text{Right}\Rightarrow)\ar[r]\sp(0.5){(\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta} & (\text{Left}\Rightarrow_{\Rightarrow})\ar[ru]\sp(0.65){\beta\vdash\beta}\ar[r]\sp(0.65){\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha} & ~
}
\]
The proofs for the sequents $\beta\vdash\beta$ and $\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha$
are the same as before:
\[
\text{Proof}\,(\beta\vdash\beta)_{\text{given }y^{:B}}=y\quad,\quad\quad\text{Proof}\,(\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha)_{\text{given }r^{:A\rightarrow B}}=x^{:A}\rightarrow x\quad.
\]
Substituting these proofs into the proof transformer of the rule \textsf{``}($\text{Left}\Rightarrow_{\Rightarrow}$)\textsf{''}
produces this code:
\begin{align*}
 & \text{Proof}\,((\alpha\Rightarrow\alpha)\Rightarrow\beta\vdash\beta)_{\text{given }q^{:(A\rightarrow A)\rightarrow B}}=q\big(\text{Proof}\,(\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha)_{\text{given }r^{:A\rightarrow B}}\big)\\
 & \quad\quad\text{where }r^{:A\rightarrow B}=a^{:A}\rightarrow q(\_^{:A}\rightarrow a)\\
 & =q(x^{:A}\rightarrow x)\quad.
\end{align*}
The proof of $\alpha\Rightarrow\beta\vdash\alpha\Rightarrow\alpha$
does not actually use the intermediate value $r^{:A\rightarrow B}$
provided by the proof transformer. As a symbolic simplification step,
we may simply omit the code of $r$. The \lstinline!curryhoward!
library always performs symbolic simplification after applying the
LJT algorithm. 

\begin{figure}
\begin{centering}
\noindent\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{align*}
\frac{\Gamma,A,B\vdash D}{\Gamma,A,{\color{blue}A\Rightarrow B}\vdash D}~(\text{Left}\Rightarrow_{A})\quad & \quad\text{Proof}\,(\Gamma,A,A\Rightarrow B\vdash D)_{\text{given }p^{:\Gamma},x^{:A},q^{:A\rightarrow B}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,A,B\vdash D)_{\text{given }p,x,q(x)}\\
\frac{\Gamma,A\Rightarrow B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\wedge B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\wedge})\quad & \quad\text{Proof}\,(\Gamma,(A\wedge B)\Rightarrow C\vdash D)_{\text{given }p^{:\Gamma},q^{:A\times B\rightarrow C}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,A\Rightarrow B\Rightarrow C\vdash D)_{\text{given }p,(a^{:A}\rightarrow b^{:B}\rightarrow q(a\times b))}\\
\frac{\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D}{\Gamma,{\color{blue}(A\vee B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\vee})\quad & \quad\text{Proof}\,(\Gamma,(A\vee B)\Rightarrow C\vdash D)_{\text{given }p^{:\Gamma},q^{:A+B\rightarrow C}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,A\Rightarrow C,B\Rightarrow C\vdash D)_{\text{given }p,r,s}\\
 & \quad\quad\text{where}~r\triangleq a^{:A}\rightarrow q(a+\bbnum 0)\text{ and }s\triangleq b^{:B}\rightarrow q(\bbnum 0+b)\\
\frac{\Gamma,B\Rightarrow C\vdash A\Rightarrow B\quad\quad\Gamma,C\vdash D}{\Gamma,{\color{blue}(A\Rightarrow B)\Rightarrow C}\vdash D}~(\text{Left}\Rightarrow_{\Rightarrow})\quad & \quad\text{Proof}\,(\Gamma,(A\Rightarrow B)\Rightarrow C\vdash D)_{\text{given }p^{:\Gamma},q^{:\left(A\rightarrow B\right)\rightarrow C}}\\
 & \quad\quad=\text{Proof}\,(\Gamma,C\vdash D)_{\text{given }p,c}\\
 & \quad\quad\text{ where}~c^{:C}\triangleq q\big(\text{Proof}\,(\Gamma,B\Rightarrow C\vdash A\Rightarrow B)_{\text{given }p,r}\big)\\
 & \quad\quad\text{ and }r^{:B\rightarrow C}\triangleq b^{:B}\rightarrow q(\_^{:A}\rightarrow b)
\end{align*}
%
\end{minipage}}
\par\end{centering}
\caption{\label{fig:proof-transformers-for-LJT-rules}Proof transformers for
the four new rules of the \index{LJT algorithm|textit}LJT algorithm.}
\end{figure}

The reason the LJT algorithm terminates is that each rule replaces
a given sequent by one or more sequents with simpler premises or goals.\footnote{The paper \texttt{\href{http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618}{http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2618}}
shows that the LJT algorithm terminates by giving an explicit decreasing
measure on proof trees.} This guarantees that the proof search will terminate either with
a complete proof or with a sequent to which no more rules apply. An
example of such a \textsf{``}dead-end\textsf{''} sequent is $\alpha\vdash\beta$ where
$\alpha$ and $\beta$ are different, unrelated propositions. In that
situation, the LJT algorithm concludes that the initial sequent cannot
be proved.

To \emph{prove} that there is no proof, one needs to use methods
that are beyond the scope of this book. An introduction to the required
techniques is in the book \textsf{``}Proof and Disproof in Formal Logic\textsf{''}
by R.~Bornat\index{Richard Bornat} (see footnote~\ref{fn:Bornat-proof-book}
on page~\pageref{fn:Bornat-proof-book}).

\chapter{Parametricity theorem and naturality laws\label{app:Proofs-of-naturality-parametricity}}

Functional programming focuses on a small set of language features
\textemdash{} the six type constructions and the nine code constructions\index{nine code constructions},
introduced in Sections~\ref{subsec:Type-notation-and-standard-type-constructions}
and~\ref{subsec:The-rules-of-proof}. These constructions, summarized
again in Tables~\ref{tab:Mathematical-notation-for-basic-code-constructions}
and \ref{tab:six-pure-type-constructions}\textendash \ref{tab:nine-pure-code-constructions},
create \textbf{fully parametric} programs\index{fully parametric!code}
and are sufficient to implement all design patterns of functional
programming. At the same time, restricting programs to be fully parametric
will enable several ways of mathematical reasoning about code. Examples
of such reasoning are treating programs as mathematical values (referential
transparency\index{referential transparency}); deriving the most
general type from code (type inference\index{type inference}); and
deriving code from type (code inference\index{code inference}).

Additionally, all fully parametric programs will automatically satisfy
certain laws derived from the so-called \textsf{``}parametricity theorem\textsf{''}.
The most often used laws of this kind are naturality laws for natural
transformations, i.e., for functions of type $\forall A.\,F^{A}\rightarrow G^{A}$
where both $F^{\bullet}$ and $G^{\bullet}$ are functors (or both
contrafunctors). Not having to verify naturality laws by hand saves
a lot of time.

Other laws that follow automatically from parametricity are composition
laws for functors, commutativity laws for bifunctors, and dinaturality
laws for profunctors. This Appendix presents sufficient theoretical
material to be able to derive all those laws. 

\begin{wraptable}{l}{0.545\columnwidth}%
\begin{centering}
\vspace{-0.2\baselineskip}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\small{}Type construction} & \textbf{\small{}Scala example} & \textbf{\small{}Type notation}\tabularnewline
\hline 
\hline 
{\small{}unit or \textsf{``}named unit\textsf{''}} & {\small{}}\lstinline!Unit!{\small{} or }\lstinline!None!{\small{} } & {\small{}$\bbnum 1$}\tabularnewline
\hline 
{\small{}type parameter} & {\small{}}\lstinline!A!{\small{} as in }\lstinline!F[A]!{\small{} } & {\small{}$A$ as in $F^{A}$}\tabularnewline
\hline 
{\small{}product type} & {\small{}}\lstinline!(A, B)! & {\small{}$A\times B$}\tabularnewline
\hline 
{\small{}co-product type} & {\small{}}\lstinline!Either[A, B]! & {\small{}$A+B$}\tabularnewline
\hline 
{\small{}function type} & {\small{}}\lstinline!A => B! & {\small{}$A\rightarrow B$}\tabularnewline
\hline 
{\small{}recursive type} & {\small{}}\lstinline!Fix[F[_]]! & {\small{}$\text{Fix}^{F^{\bullet}}$}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{\index{fully parametric!type constructions}The six type constructions
that may be used in fully parametric programs.\label{tab:six-pure-type-constructions}}
\vspace{-0.2\baselineskip}
\end{wraptable}%

\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{\small{}Code construction} & \textbf{\small{}Scala example} & \textbf{\small{}Code notation}\tabularnewline
\hline 
\hline 
{\small{}1. Use unit value} & {\small{}}\lstinline!()! & {\small{}$1$}\tabularnewline
\hline 
{\small{}2. Use given argument} & {\small{}}\lstinline!x! & {\small{}$x$}\tabularnewline
\hline 
{\small{}3. Create function} & {\small{}}\lstinline!x => expression! & {\small{}$x\rightarrow expression$}\tabularnewline
\hline 
{\small{}4. Use function} & {\small{}}\lstinline!f(x)! & $f(x)$ ~or~ $x\triangleright f$\tabularnewline
\hline 
{\small{}5. Create tuple} & {\small{}}\lstinline!(a, b)! & {\small{}$a\times b$}\tabularnewline
\hline 
{\small{}6. Use tuple} & {\small{}}\lstinline!{ case (a, b) => ... }!{\small{} or }\lstinline!p._1!{\small{}
or }\lstinline!p._2!{\small{} } & {\small{}$a\times b\rightarrow...$ ~or~ $p\triangleright\pi_{1}$
~or~ $p\triangleright\pi_{2}$}\tabularnewline
\hline 
{\small{}7. Create disjunctive value} & {\small{}}\lstinline!Left[A, B](a)! & {\small{}}%
\begin{minipage}[c]{0.19\columnwidth}%
{\small{}\vspace{0.2\baselineskip}
$a^{:A}+\bbnum 0^{:B}$ ~or~~ $\begin{array}{|cc|}
a & \bbnum 0\end{array}$\vspace{0.2\baselineskip}
}%
\end{minipage}\tabularnewline
\hline 
{\small{}8. Use disjunctive value} & {\small{}}%
\begin{minipage}[c]{0.33\columnwidth}%
{\small{}}\lstinline!p match { case Left(a)   => f(a)            case Right(b)  => g(b)          }!%
\end{minipage} & {\small{}}%
\begin{minipage}[c]{0.23\columnwidth}%
{\small{}\vspace{0.2\baselineskip}
$p\,\triangleright\,\begin{array}{|c||c|}
 & C\\
\hline A & a\rightarrow f(a)\\
B & b\rightarrow g(b)
\end{array}$\vspace{0.2\baselineskip}
}%
\end{minipage}\tabularnewline
\hline 
{\small{}9. Recursive call} & {\small{}}\lstinline!def f(x) = { ... f(y) ... }! & {\small{}$f(x)\triangleq...~\overline{f}(y)~...$}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{\index{fully parametric!code constructions}The nine code constructions
of fully parametric programs.\label{tab:nine-pure-code-constructions}}
\end{table}

The practical uses of parametricity were showcased in \index{Philip Wadler}P.~Wadler\textsf{'}s
paper\footnote{See \texttt{\href{https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf}{https://people.mpi-sws.org/$\sim$dreyer/tor/papers/wadler.pdf}}
and some further explanations in the blog posts \texttt{\href{https://reasonablypolymorphic.com/blog/theorems-for-free/}{https://reasonablypolymorphic.com/blog/theorems-for-free/}}
and \texttt{\href{https://bartoszmilewski.com/2014/09/22/}{https://bartoszmilewski.com/2014/09/22/}}\\
The title of the paper (\textsf{``}Theorems for free\textsf{''}\index{theorems for free})
is misleading. As we will see, the theorems are obtained only at the
cost of restricting all code to the nine FP code constructions, which
excludes most of the code in today\textsf{'}s real-world applications.} based on results derived by J.~Reynolds.\index{John Reynolds}\footnote{See \texttt{\href{https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf}{https://people.mpi-sws.org/$\sim$dreyer/tor/papers/reynolds.pdf}}.
This book does not use those results. } The Reynolds-Wadler approach first replaces functions of type $A\rightarrow B$
by many-to-many relations between values of types $A$ and $B$. Then
the parametricity theorem shows that a certain law holds for relations.
Since we are usually interested in deriving laws as equations rather
than relations, the last step replaces all relations by functions.

To use the relational approach to parametricity, one needs to learn
the techniques for working with relations, which will be unfamiliar
to most programmers.\footnote{Beginner-level tutorials on relations and relational parametricity
are rare. One is in a paper by \index{Ronald Backhouse}R.~Backhouse,
see \texttt{\href{https://www.researchgate.net/publication/262348393_On_a_Relation_on_Functions}{https://www.researchgate.net/publication/262348393\_On\_a\_Relation\_on\_Functions}}} Only a few parametricity properties can be proved without using relations.
However, a practicing programmer who only uses the \emph{formulations}
of the resulting laws will not need to learn any proofs. Adapting
the parametricity theorem to the needs of FP practitioners, this Appendix
will begin by summarizing the naturality laws and other properties
of fully parametric code. Then Section~\ref{sec:Parametricity-theorem-for-relations}
will prove the parametricity theorem in the relational approach.%
\begin{comment}
Section~\ref{sec:Commutativity-laws-for-type-constructors} proves
that fully parametric type constructors obey commutativity laws. Section~\ref{sec:Naturality-laws-for-fully-parametric-functions}
shows, without using relations, that fully parametric functions satisfy
dinaturality laws (a generalization of naturality laws to arbitrary
type signatures). An important consequence, proved in Section~\ref{sec:Uniqueness-of-functor-and-contrafunctor},
is that the code implementing the functor and contrafunctor typeclasses
is unique. Finally, Section~\ref{sec:Parametricity-theorem-for-relations}
explains the relational approach to parametricity and proves the relational
parametricity theorem. 

Additional literature:

{[}1{]}: Girard, J.-Y.; Scedrov, A. \& Scott, P. J. Normal Forms and
Cut-Free Proofs as Natural Transformations. Logic From Computer Science,
Mathematical Science Research Institute Publications 21, Springer-Verlag,
1992, 217-241. http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.811

{[}2{]}: Bainbridge, E. S.; Freyd, P. J.; Scedrov, A. \& Scott, P.
J. Functorial polymorphism. Theoretical computer science, Elsevier,
1990, 70, 35-64. https://core.ac.uk/display/82270459

{[}3{]}: De Lataillade, J. Dinatural Terms in System F. Logic in Computer
Science, 24th Annual IEEE Symposium, 267-276, 2009. https://www.irif.fr/\textasciitilde delatail/dinat.pdf

{[}4{]}: Pistone, P. On completeness and parametricity in the realizability
semantics of System F. https://arxiv.org/abs/1802.05143

{[}5{]}: https://libres.uncg.edu/ir/asu/f/Johann\_Patricia\_2014\_A\_Relationally\_Parametric\_Model\_Of\_Dependent\_Type\_Theory..pdf

See discussion here: https://cstheory.stackexchange.com/questions/42256/is-case-analysis-on-normal-forms-of-lambda-terms-sufficient-to-prove-parametrici
\end{comment}

Parametricity properties only hold for fully parametric programs.\index{fully parametric!program}
This restriction prohibits, for instance, any use of \index{GADT}GADTs
(\textsf{``}unfunctors\textsf{''}),\index{unfunctor} subtyping,\index{subtyping}
\lstinline!null! values, mutable values, multithreading, exceptions,
run-time JVM reflection, or calling any external libraries that are
not known to be fully parametric. Code that uses those features of
Scala will not be covered by the parametricity theorem proved in this
Appendix and may fail naturality laws. 

An example of such code is the following function:
\begin{lstlisting}
def headOptBad[A]: List[A] => Option[A] = {
  case Nil                   => None
  case (head: Int) :: tail   => Some((head + 100).asInstanceOf[A])
  case head :: tail          => Some(head)
}
\end{lstlisting}
This code has no side effects, is purely functional and referentially\index{referential transparency}
transparent. But it is clear that \lstinline!headOptBad[A]! does
not work in the same way for all type parameters \lstinline!A!. When
\lstinline!A! is set to \lstinline!Int!, the behavior is different
than for all other types. This leads to a failure of the naturality
law:
\begin{lstlisting}
scala> headOptBad[String](  List(1, 2, 3).map(x => s"value = $x")  )
res0: Option[String] = Some(value = 1)

scala> headOptBad[Int]( List(1, 2, 3) ).map(x => s"value = $x")
res1: Option[String] = Some(value = 101)
\end{lstlisting}
So, full parametricity is a stronger restriction on code than referential
transparency.

Here is an example of fully parametric code that uses all nine constructions:
\begin{lstlisting}
def fmap[A, B](f: A => B): List[(A, A)] => List[(B, B)] = {      // 3
   case Nil            => Nil
//   8   1                1,7 
   case head :: tail   => (f (head._1), f (head._2)) :: fmap(f)(tail)
//   8       6             2 4     6  5 2 4     6    7   9
}  // This code uses each of the nine fully parametric constructions.
\end{lstlisting}
For instance, the expression \lstinline!head :: tail! is a tuple
pattern that extracts the two parts of a tuple (construction 6). The
recursive call \lstinline!fmap(f)(tail)! corresponds to construction
9.

\section{Practical use of parametricity properties}

\subsection{Naturality and dinaturality laws\label{sec:Naturality-laws-for-fully-parametric-functions} }

Parametricity properties apply to fully parametric expressions (most
often, functions) with at least one type parameter. Examples of such
functions are the \lstinline!map!, \lstinline!filter!, and \lstinline!fold!
methods for the \lstinline!Option! functor (denoted by $\text{Opt}^{A}\triangleq\bbnum 1+A$),
with the following type signatures:
\begin{align*}
 & \text{fmap}_{\text{Opt}}^{A,B}:\left(A\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad,\\
 & \text{filt}_{\text{Opt}}^{A}:\left(A\rightarrow\bbnum 2\right)\rightarrow\text{Opt}^{A}\rightarrow\text{Opt}^{A}\quad,\\
 & \text{fold}_{\text{Opt}}^{A,B}:B\times\left(A\times B\rightarrow B\right)\rightarrow\text{Opt}^{A}\rightarrow B\quad.
\end{align*}
These methods satisfy appropriate naturality laws \textemdash{} one
law per type parameter. 

When a function\textsf{'}s type signature is that of a \emph{natural transformation}\index{natural transformation}
between functors or between contrafunctors, the naturality laws have
the form derived in Section~\ref{subsec:Naturality-laws-and-natural-transformations}.
If $p:\forall A.\,G^{A}\rightarrow H^{A}$ where $G^{\bullet}$ and
$H^{\bullet}$ are functors then $p$ obeys the naturality law:
\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad p^{A}\bef f^{\uparrow H}=f^{\uparrow G}\bef p^{B}\quad.\label{eq:naturality-law-for-functors}
\end{equation}
If $p:\forall A.\,G^{A}\rightarrow H^{A}$ where $G^{\bullet}$ and
$H^{\bullet}$ are contrafunctors then $p$ obeys the naturality law:
\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad f^{\downarrow G}\bef p^{A}=p^{B}\bef f^{\downarrow H}\quad.\label{eq:naturality-law-for-contrafunctors}
\end{equation}

For example, if we fix the type parameter $A$ in the \lstinline!fmap!
method, we obtain a type signature of the form $F^{B}\rightarrow G^{B}$
where $F^{\bullet}$ and $G^{\bullet}$ are functors:
\[
\text{fmap}_{\text{Opt}}^{A,B}:F^{B}\rightarrow G^{B}\quad,\quad\quad F^{B}\triangleq A\rightarrow B\quad,\quad\quad G^{B}\triangleq\text{Opt}^{A}\rightarrow\text{Opt}^{B}\quad.
\]
The corresponding naturality law is:
\[
\text{fmap}_{\text{Opt}}\bef f^{\uparrow G}=f^{\uparrow F}\bef\text{fmap}_{\text{Opt}}\quad.
\]

Fixing the type parameter $B$ in $\text{fold}_{\text{Opt}}^{A,B}\,$
produces a type signature of the form:
\[
\text{fold}_{\text{Opt}}^{A}:H^{A}\rightarrow K^{A}\quad,\quad\quad H^{A}\triangleq B\times\left(A\times B\rightarrow B\right)\quad,\quad\quad K^{A}\triangleq\text{Opt}^{A}\rightarrow B\quad,
\]
where $K$ and $H$ are contrafunctors. The corresponding naturality
law is:
\[
f^{\downarrow H}\bef\text{fold}_{\text{Opt}}=\text{fold}_{\text{Opt}}\bef f^{\downarrow K}\quad.
\]

However, fixing the type parameter $A$ in $\text{fold}_{\text{Opt}}^{A,B}$
gives a type signature that is \emph{not} of the form $\forall B.\,P^{B}\rightarrow Q^{B}$
(with any functors or contrafunctors $P$, $Q$) because $B$ is used
in too many places. In general, it is not obvious how to write naturality
laws for transformations with such type signatures. 

To make progress, note that each occurrence of a type parameter in
a type signature must be either in a covariant or in a contravariant
position. So, any fully parametric type signature may be written in
the form $\forall A.\,P^{A,A}$ using some \emph{profunctor} $P^{X,Y}$
(contravariant in $X$ and covariant in $Y$). For instance, we can
write in this way the type signature of \lstinline!fold! with the
parameter $A$ fixed:
\[
\text{fold}_{\text{Opt}}^{A,B}:P^{B,B}\quad,\quad\quad\text{where}\quad P^{X,Y}\triangleq X\times(A\times Y\rightarrow X)\rightarrow\text{Opt}^{A}\rightarrow Y\quad.
\]
The profunctor $P^{X,Y}$ is complicated but the form of the type
signature ($P^{B,B}$) is simpler.

Given a fully parametric expression $p$ with the type signature $p:\forall A.\,P^{A,A}$,
where $P^{X,Y}$ is some profunctor, one can write the \textbf{wedge
law}\index{wedge law!of profunctors} of $p$:

\begin{wrapfigure}[9]{l}{0.26\columnwidth}%
\vspace{-1.3\baselineskip}
\[
\xymatrix{\xyScaleY{2.0pc}\xyScaleX{3.0pc}\forall Z.\,P^{Z,Z}\ar[d]\sp(0.4){\text{set }Z=A}\ar[r]\sp(0.55){\text{set }Z=B} & P^{B,B}\ar[d]\sp(0.37){f^{\downarrow P^{\bullet,B}}}\\
P^{A,A}\ar[r]\sp(0.55){f^{\uparrow P^{A,\bullet}}} & P^{A,B}
}
\]

\vspace{-0.4\baselineskip}
\end{wrapfigure}%

~\vspace{-0.8\baselineskip}

\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=p^{B}\triangleright f^{\downarrow P^{\bullet,B}}\quad.\label{eq:wedge-law-for-profunctors}
\end{equation}
\vspace{-0.8\baselineskip}

\noindent The diagram is read by starting from a value $p$ of type
$\forall Z.\,P^{Z,Z}$. We set $Z=A$ and $Z=B$ in $p$ and obtain
two values, $p^{A}$ and $p^{B}$, of types $P^{A,A}$ and $P^{B,B}$
respectively. The values $p^{A}$ and $p^{B}$ must then satisfy Eq.~(\ref{eq:wedge-law-for-profunctors}). 

We will prove later in this Appendix that the wedge law~(\ref{eq:wedge-law-for-profunctors})
is a consequence of the parametricity theorem. In turn, the naturality
laws~(\ref{eq:naturality-law-for-functors}) and~(\ref{eq:naturality-law-for-contrafunctors})
are consequences of the wedge law, as will be shown in Statement~\ref{subsec:Statement-naturality-laws-from-wedge-law}
below.

The wedge law is not easy to use in practice because the profunctors
$P$ are often complicated (as the example of \lstinline!fold! shows).
When we need to derive naturality laws for \emph{function types},
it helps to specialize the wedge law to the case $P^{A,A}=G^{A,A}\rightarrow H^{A,A}$,
where $G^{X,Y}$ and $H^{X,Y}$ are some profunctors. The result (also
derived in Statement~\ref{subsec:Statement-naturality-laws-from-wedge-law})
is the \textbf{dinaturality law}\index{dinaturality law}:
\begin{equation}
\text{for all }A,B,f^{:A\rightarrow B}\quad:\quad f^{\downarrow G^{\bullet,A}}\bef p^{A}\bef f^{\uparrow H^{A,\bullet}}=f^{\uparrow G^{B,\bullet}}\bef p^{B}\bef f^{\downarrow H^{\bullet,B}}\quad.\label{eq:dinaturality-law-for-profunctors}
\end{equation}

\begin{wrapfigure}{l}{0.38\columnwidth}%
\vspace{-2.25\baselineskip}
\[
\xymatrix{\xyScaleY{1.5pc}\xyScaleX{2.0pc} & G^{A,A}\ar[r]\sb(0.5){p^{A}} & H^{A,A}\ar[rd]\sb(0.4){f^{\uparrow H^{A,\bullet}}}\\
G^{B,A}\negthickspace\negthickspace\negthickspace\ar[rd]\sp(0.55){\;\;f^{\uparrow G^{B,\bullet}}}\ar[ru]\sb(0.6){f^{\downarrow G^{\bullet,A}}} &  &  & \negthickspace\negthickspace\negthickspace H^{A,B}\\
 & G^{B,B}\ar[r]\sp(0.5){p^{B}} & H^{B,B}\ar[ru]\sp(0.45){f^{\downarrow H^{\bullet,B}}}
}
\]

\vspace{-1.7\baselineskip}
\end{wrapfigure}%

The diagram at left illustrates the dinaturality law as an equation
between functions of type $G^{B,A}\rightarrow H^{A,B}$. To build
up intuition for that law, notice that Eq.~(\ref{eq:dinaturality-law-for-profunctors})
combines the laws~(\ref{eq:naturality-law-for-functors})\textendash (\ref{eq:naturality-law-for-contrafunctors})
in the way required for all types to match. On the other hand, the
laws~(\ref{eq:naturality-law-for-functors}) and~(\ref{eq:naturality-law-for-contrafunctors})
will follow from Eq.~(\ref{eq:dinaturality-law-for-profunctors})
when $G^{A,A}$ and $H^{A,A}$ are both functors or both contrafunctors
with respect to $A$.

Functions $p:\forall A.\,G^{A,A}\rightarrow H^{A,A}$ satisfying Eq.~(\ref{eq:dinaturality-law-for-profunctors})
are called \textbf{dinatural transformations}\index{dinatural transformation}.
The property of dinaturality is weaker than naturality.\emph{ }A \emph{natural}
transformation between profunctors $G$ and $H$ would be a function
$t$ with type signature $\forall(A,B).\,G^{A,B}\rightarrow H^{A,B}$
defined for arbitrary (not necessarily equal) type parameters $A$,
$B$. If we are given a transformation $p^{A}:G^{A,A}\rightarrow H^{A,A}$
then, as a rule, it will be impossible to extend the code of $p^{A}$
to some $t^{A,B}:G^{A,B}\rightarrow H^{A,B}$ that works with arbitrary
type parameters $A$, $B$.

With the formulas~(\ref{eq:naturality-law-for-functors})\textendash (\ref{eq:dinaturality-law-for-profunctors}),
we can write naturality laws more quickly, starting from any given
type signature of the form $\forall A.\,P^{A,A}$. The following examples
show how we may derive naturality laws by specializing the general
law~(\ref{eq:dinaturality-law-for-profunctors}) to certain profunctors
$G$ and $H$.

\subsubsection{Example \label{subsec:Example-derive-naturality-of-filter-from-dinaturality}\ref{subsec:Example-derive-naturality-of-filter-from-dinaturality}
(naturality law of \lstinline!filter!)\index{solved examples}}

To derive the naturality law of \lstinline!filter!, express \lstinline!filter!\textsf{'}s
type signature through profunctors $G$ and $H$ as:
\[
\text{filt}_{F}^{A}:G^{A,A}\rightarrow H^{A,A}\quad,\quad\quad G^{X,Y}\triangleq(X\rightarrow\bbnum 2)\quad,\quad\quad H^{X,Y}\triangleq F^{X}\rightarrow F^{Y}\quad,
\]
and then write the law~(\ref{eq:dinaturality-law-for-profunctors}):
\begin{equation}
f^{\downarrow G^{\bullet,A}}\bef\text{filt}_{F}^{A}\bef f^{\uparrow H^{A,\bullet}}\overset{?}{=}f^{\uparrow G^{B,\bullet}}\bef\text{filt}_{F}^{B}\bef f^{\downarrow H^{\bullet,B}}\quad.\label{eq:filter-law-via-dinatural-transformation-derivation1}
\end{equation}
It remains to substitute the code for the liftings using the specific
types of $H$ and $G$:
\begin{align*}
(f^{:A\rightarrow B})^{\downarrow G^{\bullet,A}}=p^{:B\rightarrow\bbnum 2}\rightarrow f\bef p\quad, & \quad\quad f^{\uparrow G^{B,\bullet}}=\text{id}\quad,\\
(f^{:A\rightarrow B})^{\downarrow H^{\bullet,B}}=q^{:F^{B}\rightarrow F^{B}}\rightarrow f^{\uparrow F}\bef q\quad, & \quad\quad f^{\uparrow H^{A,\bullet}}=q^{:F^{A}\rightarrow F^{A}}\rightarrow q\bef f^{\uparrow F}\quad.
\end{align*}
Then we rewrite Eq.~(\ref{eq:filter-law-via-dinatural-transformation-derivation1})
as:
\[
(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\overset{?}{=}\text{id}\bef\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)\quad.
\]
To simplify the form of the naturality law, apply both sides to an
arbitrary $p^{:P^{B,A}}=p^{:B\rightarrow\bbnum 2}$:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p\triangleright(p\rightarrow f\bef p)\bef\text{filt}_{F}\bef(q\rightarrow q\bef f^{\uparrow F})\\
{\color{greenunder}\triangleright\text{-notation}:}\quad & \quad=\gunderline{p\triangleright(p}\rightarrow f\bef p)\triangleright\text{filt}_{F}\triangleright(q\rightarrow q\bef f^{\uparrow F})\\
{\color{greenunder}\text{apply functions}:}\quad & \quad=\gunderline{(f\bef p)\triangleright\text{filt}_{F}}\triangleright(q\rightarrow q\bef f^{\uparrow F})=\gunderline{\text{filt}_{F}(f\bef p)\triangleright(q}\rightarrow q\bef f^{\uparrow F})=\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p\triangleright\gunderline{\text{id}\bef}\text{filt}_{F}\bef(q\rightarrow f^{\uparrow F}\bef q)=p\triangleright\text{filt}_{F}\triangleright(q\rightarrow f^{\uparrow F}\bef q)\\
 & \quad=\gunderline{\text{filt}_{F}(p)\triangleright(q}\rightarrow f^{\uparrow F}\bef q)=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\end{align*}
We obtained the naturality law~(\ref{eq:naturality-law-of-filter})
of \lstinline!filter!:
\[
\text{filt}_{F}(f\bef p)\bef f^{\uparrow F}=f^{\uparrow F}\bef\text{filt}_{F}(p)\quad.
\]


\subsubsection{Example \label{subsec:Example-derive-naturality-of-fold-from-dinaturality}\ref{subsec:Example-derive-naturality-of-fold-from-dinaturality}
(naturality law of \lstinline!fold!)}

To derive the naturality law of \lstinline!fold! with respect to
the type parameter $B$, we write the type signature of \lstinline!fold!
as $G^{B,B}\rightarrow H^{B,B}$ with some profunctors $G$, $H$:
\[
\text{fold}_{F}^{A,B}:G^{B,B}\rightarrow H^{B,B}\quad\quad\text{where}\quad G^{X,Y}\triangleq Y\times(A\times X\rightarrow Y)\quad\text{ and }\quad H^{X,Y}\triangleq F^{A}\rightarrow Y\quad.
\]
Since the type parameter $A$ is fixed, let us write the law~(\ref{eq:dinaturality-law-for-profunctors})
with an arbitrary function $f^{:B\rightarrow C}$:
\begin{equation}
(f^{:B\rightarrow C})^{\downarrow G^{\bullet,B}}\bef\text{fold}_{F}^{B}\bef f^{\uparrow H^{B,\bullet}}\overset{!}{=}f^{\uparrow G^{C,\bullet}}\bef\text{fold}_{F}^{C}\bef f^{\downarrow H^{\bullet,C}}\quad.\label{eq:fold-naturality-from-profunctor-derivation2}
\end{equation}
The lifting code required for the profunctors $G^{X,Y}\triangleq Y\times\left(A\times X\rightarrow Y\right)$
and $H^{X,Y}\triangleq F^{A}\rightarrow Y$ is:
\begin{align*}
(f^{:B\rightarrow C})^{\downarrow G^{\bullet,B}}=\text{id}^{B}\boxtimes(h^{:A\times C\rightarrow B}\rightarrow a^{:A}\times b^{:B}\rightarrow h(a\times f(b)))\quad, & \quad\quad f^{\uparrow G^{C,\bullet}}=f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f)\quad,\\
(f^{:B\rightarrow C})^{\downarrow H^{\bullet,C}}=\text{id}\quad, & \quad\quad f^{\uparrow H^{B,\bullet}}=q^{:F^{A}\rightarrow B}\rightarrow q\bef f\quad.
\end{align*}
Substituting this code into the law~(\ref{eq:fold-naturality-from-profunctor-derivation2})
and applying to an arbitrary $p^{:G^{C,B}}=z^{:B}\times h^{:A\times C\rightarrow B}$,
we get:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (z\times h)\triangleright\gunderline{(f^{:B\rightarrow C})^{\downarrow G^{\bullet,B}}}\bef\text{fold}_{F}\bef\gunderline{f^{\uparrow H^{B,\bullet}}}\\
{\color{greenunder}\text{definitions of liftings}:}\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\gunderline{\bef}\text{fold}_{F}\gunderline{\bef}(q\rightarrow q\bef f)\\
{\color{greenunder}\triangleright\text{-notation}:}\quad & \quad=(z\times h)\triangleright(\text{id}\boxtimes(h\rightarrow a\times b\rightarrow h(a\times f(b))))\triangleright\text{fold}_{F}\triangleright(q\rightarrow q\bef f)\\
{\color{greenunder}\text{apply functions}:}\quad & \quad=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & (z\times h)\triangleright\gunderline{f^{\uparrow G^{C,\bullet}}}\bef\text{fold}_{F}\bef\gunderline{f^{\downarrow H^{\bullet,C}}}=(z\times h)\triangleright(f\boxtimes(h^{:A\times C\rightarrow B}\rightarrow h\bef f))\bef\text{fold}_{F}\bef\text{id}\\
{\color{greenunder}\text{apply functions}:}\quad & \quad=\text{fold}_{F}(f(z)\times(h\bef f))\quad.
\end{align*}
We obtain the following law of \lstinline!fold!:
\[
\text{fold}_{F}(f(z)\times(h\bef f))=\text{fold}_{F}(z\times(a\times b\rightarrow h(a\times f(b))))\bef f\quad.
\]


\subsubsection{Statement \label{subsec:Statement-naturality-laws-from-wedge-law}\ref{subsec:Statement-naturality-laws-from-wedge-law}}

The laws~(\ref{eq:naturality-law-for-functors})\textendash (\ref{eq:dinaturality-law-for-profunctors})
are special cases of the wedge law~(\ref{eq:wedge-law-for-profunctors}). 

\subparagraph{Proof}

We assume that the wedge law holds for any values $p$ of type $\forall A.\,P^{A,A}$.

To prove Eq.~(\ref{eq:naturality-law-for-functors}), we define $P^{X,Y}\triangleq G^{X}\rightarrow H^{Y}$.
The two liftings of a function $f^{:A\rightarrow B}$ to $P$ are:
\[
f^{\uparrow P^{A,\bullet}}=p^{:G^{A}\rightarrow H^{A}}\rightarrow p\bef f^{\uparrow H}\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=p^{:G^{B}\rightarrow H^{B}}\rightarrow f^{\uparrow G}\bef p\quad.
\]
So, the wedge law~(\ref{eq:wedge-law-for-profunctors}) gives:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=p^{A}\bef f^{\uparrow H}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p^{B}\triangleright f^{\downarrow P^{\bullet,B}}=f^{\uparrow G}\bef p^{B}\quad.
\end{align*}
We obtain $p^{A}\bef f^{\uparrow H}=f^{\uparrow G}\bef p^{B}$, which
is the same as Eq.~(\ref{eq:naturality-law-for-functors}).

To prove Eq.~(\ref{eq:naturality-law-for-contrafunctors}), we define
$P^{X,Y}\triangleq G^{Y}\rightarrow H^{X}$. The two liftings of a
function $f^{:A\rightarrow B}$ to $P$ are:
\[
f^{\uparrow P^{A,\bullet}}=p^{:G^{A}\rightarrow H^{A}}\rightarrow f^{\downarrow G}\bef p\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=p^{:G^{B}\rightarrow H^{B}}\rightarrow p\bef f^{\downarrow H}\quad.
\]
So, the wedge law~(\ref{eq:wedge-law-for-profunctors}) gives:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=f^{\downarrow G}\bef p^{A}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p^{B}\triangleright f^{\downarrow P^{\bullet,B}}=p^{B}\bef f^{\downarrow H}\quad.
\end{align*}
We obtain $f^{\downarrow G}\bef p^{A}=p^{B}\bef f^{\downarrow H}$,
which is the same as Eq.~(\ref{eq:naturality-law-for-contrafunctors}).

To prove Eq.~(\ref{eq:dinaturality-law-for-profunctors}), we define
$P^{X,Y}\triangleq G^{Y,X}\rightarrow H^{X,Y}$. Note that we need
to swap $X$ and $Y$ in $G^{Y,X}$ in order to conform to the required
variance of $P^{X,Y}$ (contravariant in $X$ and covariant in $Y$). 

The two liftings of a function $f^{:A\rightarrow B}$ to $P$ are
expressed as:
\[
f^{\uparrow P^{A,\bullet}}=p^{:G^{A,A}\rightarrow H^{A,A}}\rightarrow f^{\downarrow G^{\bullet,A}}\bef p\bef f^{\uparrow H^{A,\bullet}}\quad,\quad\quad f^{\downarrow P^{\bullet,B}}=p^{:G^{B,B}\rightarrow H^{B,B}}\rightarrow f^{\uparrow G^{B,\bullet}}\bef p\bef f^{\downarrow H^{\bullet,B}}\quad.
\]
So, the wedge law~(\ref{eq:wedge-law-for-profunctors}) gives:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{A}\triangleright f^{\uparrow P^{A,\bullet}}=f^{\downarrow G^{\bullet,A}}\bef p^{A}\bef f^{\uparrow H^{A,\bullet}}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & p^{B}\triangleright f^{\downarrow P^{\bullet,B}}=f^{\uparrow G^{B,\bullet}}\bef p^{B}\bef f^{\downarrow H^{\bullet,B}}\quad.
\end{align*}
We obtain $f^{\downarrow G^{\bullet,A}}\bef p^{A}\bef f^{\uparrow H^{A,\bullet}}=f^{\uparrow G^{B,\bullet}}\bef p^{B}\bef f^{\downarrow H^{\bullet,B}}$,
which is the same as Eq.~(\ref{eq:dinaturality-law-for-profunctors}).
$\square$

\subsection{Uniqueness of functor and contrafunctor liftings\label{sec:Uniqueness-of-functor-and-contrafunctor} }

All the laws shown here need to use function liftings such as $f^{\uparrow G}$
or $f^{\uparrow P^{A,\bullet}}$. How are these liftings defined?
Sections~\ref{subsec:f-Functor-constructions} and~\ref{subsec:f-Contrafunctor-constructions}
derived lawful and fully parametric implementations of the \lstinline!fmap!
and \lstinline!cmap! methods for all functors and contrafunctors
as long as they are built up from the six type constructions. The
naturality laws obtained from the parametricity theorem must use precisely
those \textsf{``}standard\textsf{''} implementations of \lstinline!fmap! and \lstinline!cmap!
because the proof of the parametricity theorem significantly depends
on the code of those implementations.

The structure of a given fully parametric type constructor $F^{A}$
dictates a unique implementation of a lifting $f^{\uparrow P}$ or
$f^{\downarrow P}$. Let us summarize these implementations for the
six type constructions:

\paragraph{Constant type}

If $F^{A}\triangleq Z$ where $Z$ is a fixed type then $f^{\uparrow F}=\text{id}^{:Z\rightarrow Z}$.

\paragraph{Type parameter}

If $F^{A}\triangleq A$ then $f^{\uparrow F}=f$. If $F^{A}\triangleq G^{H^{A}}$
then $f^{\uparrow F}=(f^{\uparrow H})^{\uparrow G}$ if both $G$
and $H$ are functors and $f^{\uparrow F}=(f^{\downarrow H})^{\downarrow G}$
if both $G$ and $H$ are contrafunctors.

\paragraph{Products}

If $F^{A}\triangleq G^{A}\times H^{A}$ then $f^{\uparrow F}=f^{\uparrow G}\boxtimes f^{\uparrow H}$.

\paragraph{Co-products}

If $F^{A}\triangleq G^{A}+H^{A}$ then $f^{\uparrow F}=f^{\uparrow G}\boxplus f^{\uparrow H}$.

\paragraph{Function types}

If $F^{A}\triangleq G^{A}\rightarrow H^{A}$ then $f^{\uparrow F}=p^{:G^{A}\rightarrow H^{A}}\rightarrow f^{\downarrow G}\bef p\bef f^{\uparrow H}$.

\paragraph{Recursive type}

If $F^{A}\triangleq S^{A,F^{A}}$ then $f^{\uparrow F}=f^{\uparrow S^{\bullet,F^{A}}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{B,\bullet}}$.
Here $\overline{f^{\uparrow F}}$ is a recursive call to $f^{\uparrow F}$.

In addition, we will need a seventh type construction: the universally
quantified\index{types!universally quantified} type.

\paragraph{Quantified type}

If $F^{A}\triangleq\forall X.\,P^{X,A}$ where $P^{X,A}$ is covariant
in $A$ then: 
\[
f^{\uparrow F}=\forall Y.\,p^{:\forall X.\,P^{X,A}}\rightarrow p^{Y}\triangleright f^{\uparrow P^{Y,\bullet}}\quad.
\]

It turns out that there no other lawful implementations of \lstinline!fmap!
for these type constructions:

\subsubsection{Statement \label{subsec:Statement-functor-is-unique}\ref{subsec:Statement-functor-is-unique}}

There is only one implementation of a given functor $F$\textsf{'}s \lstinline!fmap!
method that satisfies the identity, composition, and naturality laws.
In particular, fully parametric lawful implementations of \lstinline!fmap!
are unique.

\subparagraph{Proof}

Section~\ref{subsec:f-Functor-constructions} derived lawful implementations
of the \lstinline!fmap! method for all functors $F$ built up via
the six type constructions. Throughout this book, this standard lifting
code is denoted by $\text{fmap}_{F}(f)$ or by $f^{\uparrow F}$.
Now suppose that there exists \emph{another} lawful implementation
of \lstinline!fmap! for $F$, denoted by $\text{fmap}_{F}^{\prime}(f)$:
\[
\text{fmap}_{F}^{\prime}:\left(A\rightarrow B\right)\rightarrow F^{A}\rightarrow F^{B}\quad,\quad\quad\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B})=\text{???}^{:F^{A}\rightarrow F^{B}}\quad.
\]
We will now show that $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$.
Let us fix the type parameter $A$ and apply the naturality law to
$\text{fmap}_{F}^{\prime}$ with respect to $B$. The resulting law
involves an arbitrary $g^{:B\rightarrow C}$:
\[
\text{fmap}_{F}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]
By definition of naturality laws, the lifting $g^{\uparrow F}$ must
use the \textsf{``}standard\textsf{''} lifting code $g^{\uparrow F}\triangleq\text{fmap}_{F}(g)$.
By assumption, $\text{fmap}_{F}^{\prime}$ obeys the composition law,
so we may write:
\[
\text{fmap}_{F}^{\prime}(f\bef g)=\text{fmap}_{F}^{\prime}(f)\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(f)\bef g^{\uparrow F}\quad.
\]
Since $f^{:A\rightarrow B}$ is arbitrary, we can choose $A=B$ and
$f=\text{id}^{:B\rightarrow B}$ to obtain:
\[
\text{fmap}_{F}^{\prime}(\text{id})\bef\text{fmap}_{F}^{\prime}(g)\overset{!}{=}\text{fmap}_{F}^{\prime}(\text{id})\bef g^{\uparrow F}\quad.
\]
The identity law for $\text{fmap}_{F}^{\prime}$ gives $\text{fmap}_{F}^{\prime}(\text{id})=\text{id}$,
so we can simplify the last equation to:
\[
\text{fmap}_{F}^{\prime}(g)\overset{!}{=}g^{\uparrow F}=\text{fmap}_{F}(g)\quad.
\]
This must hold for arbitrary $g^{:B\rightarrow C}$, which proves
that $\text{fmap}_{F}^{\prime}=\text{fmap}_{F}$.

\subsubsection{Statement \label{subsec:Statement-contrafunctor-is-unique}\ref{subsec:Statement-contrafunctor-is-unique}}

Any contrafunctor $H$ has a unique implementation of a lawful \lstinline!cmap!
method. 

\subparagraph{Proof}

We use similar arguments as in the proof of Statement~\ref{subsec:Statement-functor-is-unique}.
For any lawful alternative implementation $\text{cmap}_{H}^{\prime}$,
the naturality law is:
\[
\text{cmap}_{H}^{\prime}(f^{:A\rightarrow B}\bef g^{:B\rightarrow C})\overset{!}{=}(g^{:B\rightarrow C})^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(f)\quad.
\]
By assumption, the identity and composition law hold for $\text{cmap}_{H}^{\prime}$.
Setting $f=\text{id}^{:B\rightarrow B}$, we get:
\[
\text{cmap}_{H}^{\prime}(\text{id}\bef g)=\text{cmap}_{H}^{\prime}(g)\overset{!}{=}g^{\downarrow H}\bef\text{cmap}_{H}^{\prime}(\text{id})=g^{\downarrow H}\quad.
\]
This must hold for arbitrary $g^{:B\rightarrow C}$, which shows that
$\text{cmap}_{H}^{\prime}(g)=g^{\downarrow H}=\text{cmap}_{H}(g)$
as required. $\square$

In this section, we proved that lawful implementations of \lstinline!fmap!
and \lstinline!cmap! are unique when they are fully parametric. However,
this does not yet prove that any implementation of \lstinline!fmap!
and \lstinline!cmap! satisfying only the functor laws must also be
fully parametric (Problem~\ref{subsec:Problem-unique-functor-liftings}).

\section{Commutativity laws for bifunctors and profunctors\label{sec:Commutativity-laws-for-type-constructors}}

A special property that holds as a consequence of parametricity is
the bifunctor commutativity law\index{commutativity law!of bifunctors}~(\ref{eq:f-fmap-fmap-bifunctor-commutativity})
introduced in Section~\ref{subsec:Bifunctors}. If a type constructor
$P^{A,B}$ is a functor with respect to $A$ and $B$ separately then
the liftings with respect to the two type parameters will commute:

\begin{wrapfigure}{l}{0.28\columnwidth}%
\vspace{-1.9\baselineskip}
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{3.0pc}P^{A,B}\ar[r]\sp(0.5){f^{\uparrow P^{\bullet,B}}}\ar[d]\sp(0.45){g^{\uparrow P^{A,\bullet}}} & P^{C,B}\ar[d]\sb(0.45){g^{\uparrow P^{C,\bullet}}}\\
P^{A,D}\ar[r]\sp(0.5){f^{\uparrow P^{\bullet,D}}} & P^{C,D}
}
\]

\vspace{-1\baselineskip}
\end{wrapfigure}%

~\vspace{-0.5\baselineskip}
\[
\text{for all }A,B,C,D,f^{:A\rightarrow C},g^{:B\rightarrow D}\quad:\quad f^{\uparrow P^{\bullet,B}}\bef g^{\uparrow P^{C,\bullet}}=g^{\uparrow P^{A,\bullet}}\bef f^{\uparrow P^{\bullet,D}}\quad.
\]

Similar properties hold for type constructors with any number of type
parameters that are either covariant or contravariant with respect
to each of those type parameters.

We will now prove that the commutativity law holds for any fully parametric
bifunctors and profunctors. The proof proceeds by induction on the
type structure of a given type constructor.\footnote{In the blog post \texttt{\href{https://byorgey.wordpress.com/2018/03/30/}{https://byorgey.wordpress.com/2018/03/30/}},
Brent Yorgey\index{Brent Yorgey} gave a proof of the commutativity
law for bifunctors based on the Reynolds-Wadler relational parametricity
theorem. } It turns out that the proof also requires the commutativity laws
for type constructors with \emph{contravariant} type parameters. All
those proofs are completely analogous, so we will first prove the
commutativity law for profunctors, which are type constructors with
one contravariant and one covariant type parameter. The profunctor
commutativity law will be used below in Statement~\ref{subsec:Statement-wedge-law-from-parametricity}.

\subsection{Proof of the profunctor commutativity law\label{subsec:Proof-of-the-profunctor-commutativity-law}}

Given an arbitrary type constructor $P^{A,B}$ contravariant with
respect to $A$ and covariant with respect to $B$, we formulate the
profunctor \textbf{commutativity law}\index{commutativity law!of profunctors}\index{profunctor!commutativity law}
by analogy with the bifunctor law~(\ref{eq:f-fmap-fmap-bifunctor-commutativity}):
\begin{align}
{\color{greenunder}\text{commutativity law of }P:}\quad & \text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})\bef\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{fmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,D}}(f)\quad,\nonumber \\
{\color{greenunder}\text{in a shorter notation}:}\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.\label{eq:profunctor-commutativity-law}
\end{align}

\begin{wrapfigure}{i}{0.37\columnwidth}%
\vspace{-1.7\baselineskip}
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,B}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})~~~}\ar[d]\sb(0.45){\text{fmap}_{P^{C,\bullet}}(g)} & P^{A,B}\ar[d]\sb(0.45){\text{fmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})}\\
P^{C,D}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,D}}(f)} & P^{A,D}
}
\]

\vspace{-1.7\baselineskip}
\end{wrapfigure}%

\noindent We will now prove that Eq.~(\ref{eq:profunctor-commutativity-law})
holds for any \textbf{fully parametric profunctor}\index{fully parametric!profunctor}
$P^{A,B}$, i.e., a profunctor built via the six type constructions
from Table~\ref{tab:six-pure-type-constructions}. We will assume
that all liftings such as $f^{\downarrow P^{\bullet,B}}$ or $g^{\uparrow P^{A,\bullet}}$
are implemented as shown in Chapter~\ref{chap:Functors,-contrafunctors,-and}
for functors and contrafunctors. (Section~\ref{sec:Uniqueness-of-functor-and-contrafunctor}
showed that the code from Chapter~\ref{chap:Functors,-contrafunctors,-and}
is the only possible lawful and fully parametric implementation of
the liftings.)

The proof goes by induction on the type structure of $P^{A,B}$. The
base case contains the first two constructions (the unit type and
the type parameter), which gives two possibilities: $P^{A,B}\triangleq\bbnum 1$
(constant profunctor) and $P^{A,B}\triangleq B$ (identity profunctor).
The other possibility of using a type parameter, $P^{A,B}\triangleq A$,
does not give a profunctor since $P^{A,B}$ must be contravariant
in $A$.

The commutativity law holds for $P^{A,B}\triangleq\bbnum 1$ because
all liftings are identity functions: $\text{cmap}_{P^{\bullet,B}}(f)=\text{id}$
and $\text{fmap}_{P^{A,\bullet}}(g)=\text{id}$. For the same reason,
the law will also hold for constant profunctors $P^{A,B}\triangleq Z$
where $Z$ is a fixed type (or a type parameter other than $A$ or
$B$).

For the profunctor $P^{A,B}\triangleq B$, the law holds because $\text{cmap}_{P^{\bullet,B}}(f)=\text{id}$.
So, the base case is proved.

The inductive step looks at the outer construction in the type expression
of $P^{A,B}$, which must be one of product, co-product, function,
or recursion. These constructions create larger type expressions out
of smaller ones; for example, $P^{A,B}\triangleq\left(A\rightarrow B\right)\times B$
uses the product construction with sub-expressions $A\rightarrow B$
and $B$, which can be viewed as profunctors $R^{A,B}\triangleq A\rightarrow B$
and $S^{A,B}\triangleq B$. The inductive assumption is that the commutativity
law is already proved for all sub-expression types (such as $R^{A,B}$
or $S^{A,B}$). We will then need to prove the law for the entire
type expression $P^{A,B}$.

\paragraph{Product type}

If the outer level of $P^{A,B}$ is a product, we must have $P^{A,B}=R^{A,B}\times S^{A,B}$
where $R^{A,B}$ and $S^{A,B}$ are some profunctors. The code for
liftings follows from Statement~\ref{subsec:functor-Statement-functor-product}
and Exercise~\ref{subsec:functor-Exercise-functor-laws}:
\[
f^{\downarrow P^{\bullet,B}}\triangleq f^{\downarrow R^{\bullet,B}}\boxtimes f^{\downarrow S^{\bullet,B}}\quad,\quad\quad g^{\uparrow P^{A,\bullet}}\triangleq g^{\uparrow R^{A,\bullet}}\boxtimes g^{\uparrow S^{A,\bullet}}\quad.
\]
By inductive assumption, $R$ and $S$ already satisfy the commutativity
law~(\ref{eq:profunctor-commutativity-law}). So, we compute:
\begin{align*}
{\color{greenunder}\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:}\quad & \gunderline{f^{\downarrow P^{\bullet,B}}}\bef\gunderline{g^{\uparrow P^{A,\bullet}}}=\big(f^{\downarrow R^{\bullet,B}}\boxtimes f^{\downarrow S^{\bullet,B}}\big)\bef\big(g^{\uparrow R^{A,\bullet}}\boxtimes g^{\uparrow S^{A,\bullet}}\big)\\
{\color{greenunder}\text{composition law~(\ref{eq:pair-product-composition-law})}:}\quad & =\big(\gunderline{f^{\downarrow R^{\bullet,B}}\bef g^{\uparrow R^{A,\bullet}}}\big)\boxtimes\big(\gunderline{f^{\downarrow S^{\bullet,B}}\bef g^{\uparrow S^{A,\bullet}}}\big)\\
{\color{greenunder}\text{inductive assumption}:}\quad & =\big(g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}}\big)\boxtimes\big(g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}\big)\\
{\color{greenunder}\text{composition law~(\ref{eq:pair-product-composition-law})}:}\quad & =\big(\gunderline{g^{\uparrow R^{C,\bullet}}\boxtimes g^{\uparrow S^{C,\bullet}}}\big)\bef\big(\gunderline{f^{\downarrow R^{\bullet,D}}\boxtimes f^{\downarrow S^{\bullet,D}}}\big)=g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.
\end{align*}


\paragraph{Co-product type}

In this case, we must have $P^{A,B}=R^{A,B}+S^{A,B}$ where $R^{A,B}$
and $S^{A,B}$ are some profunctors. The code for liftings follows
from Statement~\ref{subsec:functor-Statement-functor-coproduct}
and Exercise~\ref{subsec:functor-Exercise-functor-laws}:
\[
f^{\downarrow P^{\bullet,B}}\triangleq f^{\downarrow R^{\bullet,B}}\boxplus f^{\downarrow S^{\bullet,B}}=\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}\quad,\quad\quad g^{\uparrow P^{A,\bullet}}\triangleq g^{\uparrow R^{A,\bullet}}\boxplus g^{\uparrow S^{A,\bullet}}=\,\begin{array}{||cc|}
g^{\uparrow R^{A,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{A,\bullet}}
\end{array}\quad.
\]
By inductive assumption, $R$ and $S$ already satisfy the commutativity
law~(\ref{eq:profunctor-commutativity-law}). So, we compute:
\begin{align*}
{\color{greenunder}\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:}\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,B}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,B}}
\end{array}\,\bef\,\begin{array}{||cc|}
g^{\uparrow R^{A,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{A,\bullet}}
\end{array}\\
{\color{greenunder}\text{matrix composition}:}\quad & =\,\begin{array}{||cc|}
\gunderline{f^{\downarrow R^{\bullet,B}}\bef g^{\uparrow R^{A,\bullet}}} & \bbnum 0\\
\bbnum 0 & \gunderline{f^{\downarrow S^{\bullet,B}}\bef g^{\uparrow S^{A,\bullet}}}
\end{array}\\
{\color{greenunder}\text{inductive assumption}:}\quad & =\,\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}
\end{array}\quad.
\end{align*}
The right-hand side of the law, $g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}$,
can be rewritten as:
\begin{align*}
 & g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}=\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}
\end{array}\,\bef\,\begin{array}{||cc|}
f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & f^{\downarrow S^{\bullet,D}}
\end{array}\\
{\color{greenunder}\text{matrix composition}:}\quad & =\,\begin{array}{||cc|}
g^{\uparrow R^{C,\bullet}}\bef f^{\downarrow R^{\bullet,D}} & \bbnum 0\\
\bbnum 0 & g^{\uparrow S^{C,\bullet}}\bef f^{\downarrow S^{\bullet,D}}
\end{array}\quad.
\end{align*}
This coincides with the left-hand side of the law.

\paragraph{Function type}

The type expression $P^{A,B}\triangleq R^{B,A}\rightarrow S^{A,B}$
(note the swapped type parameters in $R^{B,A}$) is contravariant
in $A$ and covariant in $B$ when $R^{A,B}$ and $S^{A,B}$ are profunctors.
The lifting code follows from Statement~\ref{subsec:functor-Statement-functor-exponential}
and Exercise~\ref{subsec:functor-Exercise-contrafunctor-exponential}:
\[
(f^{:A\rightarrow C})^{\downarrow P^{\bullet,B}}\triangleq p^{:P^{C,B}}\rightarrow f^{\uparrow R^{B,\bullet}}\bef p\bef f^{\downarrow S^{\bullet,B}}\quad,\quad\quad(g^{:B\rightarrow D})^{\uparrow P^{A,\bullet}}\triangleq p^{:P^{A,B}}\rightarrow g^{\downarrow R^{\bullet,A}}\bef p\bef g^{\uparrow S^{A,\bullet}}\quad.
\]
By the inductive assumptions, $R$ and $S$ obey the commutativity
law~(\ref{eq:profunctor-commutativity-law}). Omitting types, we
write:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & f^{\downarrow P}\bef g^{\uparrow P}=\big(p\rightarrow f^{\uparrow R}\bef p\bef f^{\downarrow S}\big)\bef\big(p\rightarrow g^{\downarrow R}\bef p\bef g^{\uparrow S}\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\rightarrow\gunderline{g^{\downarrow R}\bef f^{\uparrow R}}\bef p\bef\gunderline{f^{\downarrow S}\bef g^{\uparrow S}}\\
{\color{greenunder}\text{inductive assumption}:}\quad & =p\rightarrow f^{\uparrow R}\bef g^{\downarrow R}\bef p\bef g^{\uparrow S}\bef f^{\downarrow S}\quad.
\end{align*}
The right-hand side of the law is then transformed to the same expression:
\begin{align*}
 & g^{\uparrow P}\bef f^{\downarrow P}=\big(p\rightarrow g^{\downarrow R}\bef p\bef g^{\uparrow S}\big)\bef\big(p\rightarrow f^{\uparrow R}\bef p\bef f^{\downarrow S}\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\rightarrow f^{\uparrow R}\bef g^{\downarrow R}\bef p\bef g^{\uparrow S}\bef f^{\downarrow S}\quad.
\end{align*}


\paragraph{Recursive type}

A recursive profunctor $P$ is defined using a type equation of the
form:
\[
P^{A,B}\triangleq S^{A,B,P^{A,B}}\quad,
\]
where $S^{A,B,R}$ must be contravariant in $A$ but covariant in
$B$ and $R$. The liftings are defined by:
\[
(f^{:A\rightarrow C})^{\downarrow P^{\bullet,B}}\triangleq f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\quad,\quad\quad(g^{:B\rightarrow D})^{\uparrow P^{A,\bullet}}\triangleq g^{\uparrow S^{A,\bullet,P^{A,B}}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\quad.
\]
There are two inductive assumptions. First, the recursively used lifting
to $P^{A,B}$ already satisfies the commutativity law. Second, the
profunctor $S^{A,B,R}$ satisfies the commutativity law with respect
to \emph{any} two parameters (we will prove that law for covariant
type parameters in Section~\ref{subsec:Proofs-of-commutativity-for-bifunctor}).

Both sides of the commutativity law are functions of type $P^{C,B}\rightarrow P^{A,D}$
or equivalently (if we expand the type recursion) of type $S^{C,B,P^{C,B}}\rightarrow S^{A,D,P^{A,D}}$.
To avoid mistakes, we write out the type parameters in this computation:
\begin{align*}
{\color{greenunder}\text{expect to equal }g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}:}\quad & f^{\downarrow P^{\bullet,B}}\bef g^{\uparrow P^{A,\bullet}}=f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef\gunderline{\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\bef g^{\uparrow S^{A,\bullet,P^{A,B}}}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\\
{\color{greenunder}^{B,R}\text{-commutativity of }S^{A,B,R}:}\quad & =\gunderline{f^{\downarrow S^{\bullet,B,P^{C,B}}}\bef g^{\uparrow S^{A,\bullet,P^{C,B}}}}\bef\big(f^{\overline{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,D,\bullet}}\bef\big(g^{\overline{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}\\
{\color{greenunder}^{A,B}\text{-commutativity of }S^{A,B,R}:}\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(\gunderline{f^{\overline{\downarrow P^{\bullet,B}}}\bef g^{\overline{\uparrow P^{A,\bullet}}}}\big)^{\uparrow S^{A,D,\bullet}}\\
{\color{greenunder}\text{inductive assumption}:}\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\bef f^{\overline{\downarrow P^{\bullet,D}}}\gunderline{\big)^{\uparrow S^{A,D,\bullet}}}\\
{\color{greenunder}\text{composition under }^{\uparrow S^{A,D,\bullet}}:}\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef\gunderline{f^{\downarrow S^{\bullet,D,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\big)^{\uparrow S^{A,D,\bullet}}}\bef\big(f^{\overline{\downarrow P^{\bullet,D}}}\big)^{\uparrow S^{A,D,\bullet}}\\
{\color{greenunder}^{A,R}\text{-commutativity of }S^{A,B,R}:}\quad & =g^{\uparrow S^{C,\bullet,P^{C,B}}}\bef\big(g^{\overline{\uparrow P^{C,\bullet}}}\big)^{\uparrow S^{C,D,\bullet}}\bef f^{\downarrow S^{\bullet,D,P^{C,D}}}\bef\big(f^{\overline{\downarrow P^{\bullet,D}}}\big)^{\uparrow S^{A,D,\bullet}}\\
{\color{greenunder}\text{definitions of liftings}:}\quad & =g^{\uparrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.
\end{align*}

This concludes the proof of the profunctor commutativity law.

\subsection{Commutativity laws for bifunctors and bi-contrafunctors\label{subsec:Proofs-of-commutativity-for-bifunctor}}

A bi-contrafunctor $P^{A,B}$ is a type constructor contravariant
with respect to both $A$ and $B$. The commutativity law for bi-contrafunctors
is formulated as:
\begin{align}
{\color{greenunder}\text{commutativity law of }P:}\quad & \text{cmap}_{P^{\bullet,D}}(f^{:A\rightarrow C})\bef\text{cmap}_{P^{A,\bullet}}(g^{:B\rightarrow D})=\text{cmap}_{P^{C,\bullet}}(g)\bef\text{cmap}_{P^{\bullet,B}}(f)\quad.\nonumber \\
{\color{greenunder}\text{shorter notation}:}\quad & f^{\downarrow P^{\bullet,D}}\bef g^{\downarrow P^{A,\bullet}}=g^{\downarrow P^{C,\bullet}}\bef f^{\downarrow P^{\bullet,B}}\quad.\label{eq:bi-contrafunctor-commutativity-law}
\end{align}

\begin{wrapfigure}{l}{0.43\columnwidth}%
\vspace{-1.7\baselineskip}
\[
\xymatrix{\xyScaleY{2.5pc}\xyScaleX{6.0pc}P^{C,D}\ar[r]\sp(0.55){\text{cmap}_{P^{\bullet,D}}(f^{:A\rightarrow C})~~~}\ar[d]\sb(0.45){\text{cmap}_{P^{C,\bullet}}(g^{:B\rightarrow D})} & P^{A,D}\ar[d]\sb(0.45){\text{cmap}_{P^{A,\bullet}}(g)}\\
P^{C,B}\ar[r]\sb(0.45){~~~~\text{cmap}_{P^{\bullet,B}}(f^{:A\rightarrow C})} & P^{A,B}
}
\]

\vspace{-1.7\baselineskip}
\end{wrapfigure}%

Any bifunctor or bi-contrafunctor whose type expression is built up
using the six type constructions (Table~\ref{tab:six-pure-type-constructions})
will satisfy its commutativity law. To prove that, we need to repeat
the same calculations as for profunctors in Section~\ref{subsec:Proof-of-the-profunctor-commutativity-law}
except for changing \lstinline!cmap! into \lstinline!fmap! or back
when needed. We only need to check that the proof will still work
after such changes. Looking over the proof in Section~\ref{subsec:Proof-of-the-profunctor-commutativity-law},
we find that we never used the functor or contrafunctor \emph{composition
law} for $P$. The only usage of the composition law was with respect
to the type parameter $R$ in the structure functor $S^{A,B,R}$ of
the recursive type construction. However, in all cases $S^{A,B,R}$
needs to be \emph{covariant} in $R$ because that is required by the
recursive type equation. So, we are assured that the same proof with
minor changes will work for bifunctors and bi-contrafunctors.

The same techniques and proofs apply to type constructors with more
than two type parameters.

\section{Relational formulation of parametricity\label{sec:Parametricity-theorem-for-relations}\label{subsec:Relations-between-types}}

Naturality laws are formulated using arbitrary functions $f^{:A\rightarrow B}$
between arbitrary types $A$ and $B$. Typically, a naturality law
is an equation that involves the function $f$ lifted to some functors.
For instance, $f^{\uparrow G}\bef t=t\bef f^{\uparrow H}$ is the
naturality law of a natural transformation $t:\forall A.\,G^{A}\rightarrow H^{A}$,
where $G$ and $H$ are some functors.

To prove that naturality laws hold for any fully parametric transformation
$t$, we need to use induction in the structure of the code of $t$.
The proof will decompose $t$ into smaller sub-expressions for which
the naturality law should hold by the inductive assumption. Some of
those sub-expressions will have types that are no longer of the form
$\forall A.\,G^{A}\rightarrow H^{A}$. So, we need to generalize naturality
laws to type signatures of the form $\forall A.\,P^{A,A}$, where
$P^{X,Y}$ is an exponential-polynomial profunctor (contravariant
in $X$ and covariant in $Y$). 

It is not possible to lift an arbitrary function $f^{:A\rightarrow B}$
to a function of type $P^{A,A}\rightarrow P^{B,B}$; for that, we
would need also a function of type $B\rightarrow A$. To solve this
problem, the Reynolds-Wadler approach replaces functions $f^{:A\rightarrow B}$
by arbitrary many-to-many relations (denoted by $r^{:A\leftrightarrow B}$)
between values of types $A$ and $B$. It turns out that any relation
$r$ of type $A\leftrightarrow B$ can be lifted to a relation (denoted
by $r^{\updownarrow P}$) of type $P^{A,A}\leftrightarrow P^{B,B}$.
The lifting operation can be defined for any exponential-polynomial
profunctor $P^{\bullet,\bullet}$. Using this technique, we will prove
the \textsf{``}relational parametricity theorem\textsf{''}: any fully parametric code
expression (not necessarily a function) of type $\forall A.\,P^{A,A}$
satisfies a specially formulated relational naturality law. That law
will then allow us to derive the wedge law~(\ref{eq:wedge-law-for-profunctors}).

\subsection{Relations between values of different types}

Programmers are familiar with relations as tables in relational databases.
The simplest relation is a table with two columns having values of
some fixed types, say \lstinline!INT! and \lstinline!FLOAT!. As
an example, consider a table called \lstinline!R! containing this
data:
\begin{center}
$R=$ %
\begin{tabular}{|c|c|}
\hline 
\lstinline!SAMPLE_COUNT: INT! & \lstinline!MEAN_VALUE: FLOAT!\tabularnewline
\hline 
\hline 
{\footnotesize{}150} & {\footnotesize{}0.92}\tabularnewline
\hline 
{\footnotesize{}150} & {\footnotesize{}0.95}\tabularnewline
\hline 
{\footnotesize{}180} & {\footnotesize{}0.95}\tabularnewline
\hline 
{\footnotesize{}180} & {\footnotesize{}1.02}\tabularnewline
\hline 
{\footnotesize{}200} & {\footnotesize{}0.95}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Each row of the table \lstinline!R! has a value of type \lstinline!INT!
and a value of type \lstinline!FLOAT! (we disallow \lstinline!NULL!
values here). The existence of a row $\left(180,0.95\right)$ means
that the values $180$ and $0.95$ are \textsf{``}in the relation\textsf{''} \lstinline!R!.

Two values $a^{:\text{Int}}$ and $b^{:\text{Float}}$ are in the
relation \lstinline!R! only if there exists a row $\left(a,b\right)$
in the table \lstinline!R!. All other pairs of values $\left(a,b\right)$
are \emph{not} in the relation \lstinline!R!. 

Note that the table \lstinline!R! contains several values in the
first column that correspond to the same value in the second column,
and vice versa. So, the relation \lstinline!R! is many-to-many and
cannot be represented by a function of type \lstinline!Int => Float!
or of type \lstinline!Float => Int!. Instead, we must view the relation
\lstinline!R! as a subset of the set of \emph{all} possible pairs
$(a^{:\text{Int}},b^{:\text{Float}})$. The table \lstinline!R! lists
the pairs in that subset.

Instead of listing the pairs, we may describe a relation by implementing
a function telling us whether two given values are in the relation.
The Scala type signature for such a function could be:
\begin{lstlisting}
def inRelationR(a: Int, b: Float): Boolean
\end{lstlisting}
In the short code notation, this function is written as $r:\text{Int}\times\text{Float}\rightarrow\bbnum 2$.
The function call $r(a\times b)$ returns \lstinline!true! when the
two given values $a$ and $b$ are in the relation $r$.

For proving the parametricity theorem, we will need relations between
values of arbitrary types. Replacing \lstinline!Int! and \lstinline!Float!
by type parameters $A$ and $B$, we get the following definition:

\subsubsection{Definition \label{subsec:Definition-relation-between-A-B}\ref{subsec:Definition-relation-between-A-B}}

A \textbf{relation} of\index{parametricity theorem!relation between values}\index{relations between values!see \textsf{``}value relation\textsf{''}}\index{value relation}
type $A\leftrightarrow B$ is a function $r:A\times B\rightarrow\bbnum 2$.
The type notation $A\leftrightarrow B$ indicates that relations are
more general than functions of types $A\rightarrow B$ or $B\rightarrow A$.
If values $x$ and $y$ are in a relation $r$, we write $(x,y)\in r$
or with full type annotations: $(x^{:A},y^{:B})\in r^{:A\leftrightarrow B}$.
The condition $(x,y)\in r$ is equivalent to writing $r(x,y)=\text{true}$. 

Defined in this sense, relations hold between values of given types.
Certain values $x^{:A}$ and $y^{:B}$ will be in a given relation
$r^{:A\leftrightarrow B}$, while other values of the same types will
not be in the relation $r$. This should not be confused with \index{type relation}\emph{type
relations} described in Section~\ref{subsec:Typeclasses-type-relations},
where certain \emph{types} will be in a given type relation while
other types will not be in that relation. Since we will not be using
any type relations in this Appendix, we will write simply \textsf{``}relations
between types $A$ and $B$\textsf{''} rather than \textsf{``}relations between \emph{values
of} types $A$ and $B$\textsf{''}. $\square$

A simple example of a relation is the \textbf{identity relation}\index{identity relation},
denoted by $\text{id}^{:A\leftrightarrow A}$. The identity relation
holds only when two values of type $A$ are equal:
\[
(x^{:A},y^{:A})\in\text{id}^{:A\leftrightarrow A}\quad\text{ means }\quad x=y\quad.
\]

To use the parametricity theorem in practice, we will need to convert
functions into relations. The relation of type $A\leftrightarrow B$
obtained from a function $f^{:A\rightarrow B}$ is denoted by $\left<f\right>$
and is defined as:
\[
(a^{:A},b^{:B})\in\left<f\right>\text{ means }b=f(a)\quad\text{or equivalently}:\quad a\triangleright f=b\quad.
\]
Functions $f$ of type $A\rightarrow B$ are converted to many-to-one
relations $\left<f\right>$ between types $A$ and $B$: one or more
values of type $A$ are related to a single value of type $B$.

A function $g$ of type $B\rightarrow A$ can be also converted to
a relation of type $A\leftrightarrow B$. However, $\left<g\right>$
will have type $B\leftrightarrow A$ in our notation. We note that
the relation types $A\leftrightarrow B$ and $B\leftrightarrow A$
are equivalent (isomorphic as types) because we can swap $x^{:A}$
and $y^{:B}$ in the condition $(x,y)\in r^{:A\leftrightarrow B}$
and obtain the \index{reverse relation}\textbf{reverse relation}
of type $B\leftrightarrow A$, denoted $\text{rev}\left(r\right)$,
such that $(y,x)\in\text{rev}\left(r\right)$. So, we will write $\text{rev}\left<g\right>$
if we need to convert a function $g^{:B\rightarrow A}$ into a relation
of type $A\leftrightarrow B$.

The operation \lstinline!rev! it is its own inverse, and so it is
an isomorphism between $A\leftrightarrow B$ and $B\leftrightarrow A$:
\[
\text{rev}\left(\text{rev}\left(r\right)\right)=r\quad.
\]
To prove this, substitute the definition of \lstinline!rev! twice:
\[
(x^{:A},y^{:B})\in\text{rev}\,\big(\text{rev}\,(r)\big)\quad\text{is the same as}:\quad(y,x)\in\text{rev}\,(r)\quad\text{and is the same as}:\quad(x,y)\in r\quad.
\]

Here is an example of a relation $r^{:A\leftrightarrow B}$ that is
\emph{not} equivalent to a function:
\[
(x^{:A},y^{:B})\in r\text{ means }p(x)=q(y)\text{ where }p^{:A\rightarrow C}\text{ and }q^{:B\rightarrow C}\text{ are some given functions}\quad.
\]
We call this a \textbf{pullback relation}\index{pullback relation|textit}
and denote it by $\text{pull}\,(p,q)$. For some choices of $p$ and
$q$, there will be many different values $x_{1}$, $x_{2}$, $y_{1}$,
$y_{2}$, ..., such that $p(x_{1})=p(x_{2})=q(y_{1})=q(y_{2})=...$
Then the pullback relation will be many-to-many and will not be equivalent
to $\left<f\right>$ or to $\text{rev}\left<f\right>$ for any function
$f$. 

In the derivations below, we will often use relations of type $P^{A,A}\leftrightarrow P^{B,B}$,
where $P^{X,Y}$ is a profunctor (contravariant in $X$ and covariant
in $Y$). For any function $f^{:A\rightarrow B}$, there is a special
pullback relation of type $P^{A,A}\leftrightarrow P^{B,B}$: 

\subsubsection{Definition \label{subsec:Definition-wedge-relation}\ref{subsec:Definition-wedge-relation}}

Given a profunctor\index{profunctor!wedge relation}\index{wedge relation|textit}
$P^{X,Y}$ and a function $f^{:A\rightarrow B}$, two values $x^{:P^{A,A}}$
and $y^{:P^{B,B}}$ are \textbf{in a} $\left(P,f\right)$-\textbf{wedge
relation} if $x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$.
This condition can be written more concisely as $(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})$.

The wedge relation comes up often in applications of the relational
parametricity theorem. The $\left(P,f\right)$-wedge relation generalizes
the wedge law~(\ref{eq:wedge-law-for-profunctors}) to two arbitrary
values $x$ and $y$. The wedge law of an expression $p:\forall A.\,P^{A,A}$
is equivalent to the requirement that $p^{A}$ and $p^{B}$ are in
the $\left(P,f\right)$-wedge relation for all $f^{:A\rightarrow B}$
and for all types $A$, $B$. 

\subsection{Relational product, co-product, and pair mapper. Relational lifting}

Lifting of relations to type constructors is necessary in order to
formulate naturality laws via relations. To see why, consider ordinary
naturality laws involving functions, such as Eq.~(\ref{eq:naturality-law-for-functors}).
These laws are formulated using an arbitrary function $f^{:A\rightarrow B}$
lifted to some functors or contrafunctors. Lifting a function $f^{:A\rightarrow B}$
to a functor $G$ yields a function $f^{\uparrow G}$ of type $G^{A}\rightarrow G^{B}$.
Lifting $f$ to a contrafunctor $H$ yields a function $f^{\downarrow H}:H^{B}\rightarrow H^{A}$.
As a first step towards writing naturality laws in terms of relations,
we need to define a lifting of an arbitrary relation $r^{:A\leftrightarrow B}$
to any type constructor $G^{\bullet}$. The lifted relation will have
type $G^{A}\leftrightarrow G^{B}$ and will be denoted by $r^{\updownarrow G}$.

As motivation, let us reformulate some known naturality laws in terms
of relations. Consider a natural transformation $t:\forall A.\,G^{A}\rightarrow H^{A}$
with its naturality law $f^{\uparrow G}\bef t=t\bef f^{\uparrow H}$.
To obtain a relational formulation of that law, we first apply both
sides to an arbitrary value $p^{:G^{A}}$:
\[
p\triangleright f^{\uparrow G}\triangleright t^{B}=p\triangleright t^{A}\triangleright f^{\uparrow H}\quad,\quad\quad\text{or equivalently}:\quad t^{B}(p\triangleright f^{\uparrow G})=t^{A}(p)\triangleright f^{\uparrow H}\quad,
\]
and define for brevity the value $q^{:G^{B}}\triangleq p\triangleright f^{\uparrow G}$.
This definition of $q$ is equivalent to the condition $(p,q)\in\langle f^{\uparrow G}\rangle$.
Now we can rewrite the naturality law of $t$ as a statement about
relations: 
\begin{equation}
\text{for any }f^{:A\rightarrow B},p^{:G^{A}},q^{:G^{B}}\quad:\quad\quad\text{when}\quad(p,q)\in\langle f^{\uparrow G}\rangle\quad\quad\text{then}\quad(t^{A}(p),t^{B}(q))\in\langle f^{\uparrow H}\rangle\quad.\label{eq:naturality-law-of-t-derivation1}
\end{equation}

We will define a concise notation for conditions of this form because
they are found often when working with relations.

\subsubsection{Definition \label{subsec:Definition-pair-mapper-of-relations}\ref{subsec:Definition-pair-mapper-of-relations}}

\index{pair mapper of relations}The \textbf{pair mapper of relations}
$r^{:A\leftrightarrow C}$ and $s^{:B\leftrightarrow D}$ is a relation
$r\varogreaterthan s$ defined by:
\begin{align*}
 & \big(r^{:A\leftrightarrow C}\varogreaterthan s^{:B\leftrightarrow D}\big):\left(A\rightarrow B\right)\leftrightarrow\left(C\rightarrow D\right)\quad,\\
 & (f^{:A\rightarrow B},g^{:C\rightarrow D})\in r\varogreaterthan s\quad\text{means}\quad\quad\forall x^{:A},y^{:C}\quad:\quad\text{if }(x,y)\in r\quad\text{then}\quad(f(x),g(y))\in s\quad.
\end{align*}

\begin{wrapfigure}{i}{0.2\columnwidth}%
\vspace{-2.8\baselineskip}
\[
\xymatrix{\xyScaleY{1.8pc}\xyScaleX{2.2pc}A\ar@{<->}[d]\sp(0.5){r}\ar[rr]\sp(0.5){f} & \ar@{<->}[d(0.9)]\sp(0.55){r\varogreaterthan s} & B\ar@{<->}[d]\sp(0.5){s}\\
C\ar[rr]\sb(0.5){g} &  & D
}
\]

\vspace{-2.5\baselineskip}
\end{wrapfigure}%

\noindent The operation $\ogreaterthan$ associates to the right,
so that $r\ogreaterthan s\ogreaterthan t\triangleq r\ogreaterthan\left(s\ogreaterthan t\right)$.
The type diagram at left illustrates the pair mapper construction.
To read the diagram, we need to start with two arbitrary values, $x^{:A}$
at the top left and $y^{:C}$ at the bottom left. Given two relations
$r^{:A\leftrightarrow C}$ and $s^{:B\leftrightarrow D}$, we define
a new relation $r\ogreaterthan s$ between functions of types $A\rightarrow B$
and $C\rightarrow D$. Two functions $\left(f,g\right)$ are in the
relation $r\varogreaterthan s$ if the diagram commutes, which means
that $(f(x),g(y))\in s$ for any $(x,y)\in r$. $\square$

Using Definition~\ref{subsec:Definition-pair-mapper-of-relations},
we can rewrite the naturality law~(\ref{eq:naturality-law-of-t-derivation1})
as:
\[
\text{for all }f^{:A\rightarrow B}\quad:\quad(t^{A},t^{B})\in\langle f^{\uparrow G}\rangle\ogreaterthan\langle f^{\uparrow H}\rangle\quad.
\]

It appears reasonable to expect that the relation $\left<f\right>$
lifted to $G$ is the same relation as $\langle f^{\uparrow G}\rangle$:
\[
\left<f\right>^{\updownarrow G}=\langle f^{\uparrow G}\rangle\quad.
\]
With this property (proved below in Statement~\ref{subsec:Statement-lifting-function-relation-covariant-1}),
we rewrite Eq.~(\ref{eq:naturality-law-of-t-derivation1}) as:
\[
\text{for all }f^{:A\rightarrow B}:\quad(t^{A},t^{B})\in\left<f\right>^{\updownarrow G}\ogreaterthan\left<f\right>^{\updownarrow H}\quad.
\]
We now replace $\left<f\right>$ by an arbitrary relation $r^{:A\leftrightarrow B}$
and obtain the\index{naturality law!in terms of relations} \textbf{relational
naturality law}:
\begin{equation}
\text{for any relation }r^{:A\leftrightarrow B}:\quad(t^{A},t^{B})\in r^{\updownarrow G}\ogreaterthan r^{\updownarrow H}\quad.\label{eq:naturality-law-of-t-derivation2}
\end{equation}

Note the similarity of the relation $r^{\updownarrow G}\ogreaterthan r^{\updownarrow H}$
and the type $G^{A}\rightarrow H^{A}$ of $t$. Denote the type signature
of $t$ by $P^{A}\triangleq G^{A}\rightarrow H^{A}$. If we \emph{define}
the lifting $r^{\updownarrow P}$ as $r^{\updownarrow G}\ogreaterthan r^{\updownarrow H}$,
the naturality law~(\ref{eq:naturality-law-of-t-derivation2}) will
be written as:
\begin{equation}
\text{for any relation }r^{:A\leftrightarrow B}:\quad(t^{A},t^{B})\in r^{\updownarrow P}\quad.\label{eq:naturality-law-of-t-derivation3}
\end{equation}
The generalization of the naturality law from functions to relations
now has a concise form: The components $t^{A}$ and $t^{B}$ of a
natural transformation $t$ belong to \emph{any} relation $r$ lifted
to $t$\textsf{'}s type signature (the type constructor $P^{\bullet}$). This
prepares us for the formulation of the parametricity theorem below.
At the same time, this motivates using the pair mapper operation ($\ogreaterthan$)
to define the lifting a relation to a function type constructor such
as $G^{A}\rightarrow H^{A}$.

What about lifting a relation to product ($G^{A}\times H^{A}$) or
co-product ($G^{A}+H^{A}$) type constructors? Recall that lifting
a function to $G^{A}\times H^{A}$ involves the pair product of functions\index{pair product of functions}
($\boxtimes$):
\[
\big(f^{:A\rightarrow C}\boxtimes g^{:B\rightarrow D}\big):A\times B\rightarrow C\times D\quad,\quad\quad f\boxtimes g\triangleq a\times b\rightarrow f(a)\times g(b)\quad.
\]
Namely, the lifting of a function $k^{:A\rightarrow B}$ to $G^{A}\times H^{A}$
is defined by $k^{\uparrow(G\times H)}\triangleq k^{\uparrow G}\boxtimes k^{\uparrow H}$. 

The pair co-product of functions\index{pair co-product of functions}
is defined by Exercise~\ref{subsec:Exercise-reasoning-1-4-1}(b):
\begin{align*}
 & \big(f^{:A\rightarrow C}\boxplus g^{:B\rightarrow D}\big):A+B\rightarrow C+D\quad,\\
 & (f\boxplus g)(a^{:A}+\bbnum 0^{:B})\triangleq f(a)+\bbnum 0^{:D}\quad,\quad\quad(f\boxplus g)(\bbnum 0+b^{:B})\triangleq\bbnum 0^{:C}+g(b)\quad,\\
 & (k^{:A\rightarrow B})^{\uparrow(G+H)}\triangleq k^{\uparrow G}\boxplus k^{\uparrow H}\quad.
\end{align*}

Let us now define the analogous constructions for relations.

\subsubsection{Definition \label{subsec:Definition-pair-product-of-relations}\ref{subsec:Definition-pair-product-of-relations}}

Given two relations $r^{:A\leftrightarrow C}$ and $s^{:B\leftrightarrow D}$,
the \textbf{pair product} \index{pair product of relations} $r\boxtimes s$
is a relation between values of the product types $A\times B$ and
$C\times D$:
\[
\big(r^{:A\leftrightarrow C}\boxtimes s^{:B\leftrightarrow D}\big):A\times B\leftrightarrow C\times D\quad,\quad\quad(a\times b,c\times d)\in r\boxtimes s\quad\text{when}\quad(a,c)\in r\text{ and }(b,d)\in s\quad.
\]

The second construction is the pair co-product of relations\index{pair co-product of relations},
which creates a relation between co-products of types. The definition
resembles that of the \index{pair co-product of functions}pair co-product
of functions:

\subsubsection{Definition \label{subsec:Definition-pair-co-product-of-relations}\ref{subsec:Definition-pair-co-product-of-relations}}

The \textbf{pair co-product} of relations $r^{:A\leftrightarrow C}$
and $s^{:B\leftrightarrow D}$ is a relation $r\boxplus s$ defined
by:
\begin{align*}
 & \big(r^{:A\leftrightarrow C}\boxplus s^{:B\leftrightarrow D}\big):A+B\leftrightarrow C+D\quad,\\
 & \text{either}\quad\quad(a^{:A}+\bbnum 0^{:B},c^{:C}+\bbnum 0^{:D})\in r\boxplus s\quad\text{when}\quad(a,c)\in r\quad,\\
 & \text{or}\quad\quad(\bbnum 0^{:A}+b^{:B},\bbnum 0^{:C}+d^{:D})\in r\boxplus s\quad\text{when}\quad(b,d)\in s\quad.
\end{align*}
Any other combinations of values (such as $a+\bbnum 0$ and $\bbnum 0+d$)
are not in the relation $r\boxplus s$. $\square$

The following example illustrates some properties of the relational
operations $\boxtimes$, $\boxplus$, and $\ogreaterthan$ when applied
to relations obtained from functions.

\subsubsection{Example \label{subsec:Example-pair-product-pair-mapper-relation}\ref{subsec:Example-pair-product-pair-mapper-relation}\index{solved examples}}

For arbitrary given functions $f^{:A\rightarrow B}$ and $g^{:C\rightarrow D}$,
prove that:

\textbf{(a)} $\left<f\right>\boxtimes\left<g\right>=\left<f\boxtimes g\right>$,
both relations having type $A\times C\leftrightarrow B\times D$.

\textbf{(b)} $\left<f\right>\boxplus\left<g\right>=\left<f\boxplus g\right>$,
both relations having type $A+C\leftrightarrow B+D$.

\textbf{(c)} $\left<f\right>\ogreaterthan\text{id}^{:C\leftrightarrow C}=\text{rev}\,\langle l^{:B\rightarrow C}\rightarrow f\bef l\rangle$,
both relations having type $\left(A\rightarrow C\right)\leftrightarrow\left(B\rightarrow C\right)$.

\textbf{(d)} $\text{id}^{:A\leftrightarrow A}\ogreaterthan\left<g\right>=\langle k^{:A\rightarrow C}\rightarrow k\bef g\rangle$,
both relations having type $\left(A\rightarrow C\right)\leftrightarrow\left(A\rightarrow D\right)$.

\textbf{(e)} $\left<f\right>\ogreaterthan\left<g\right>=\text{pull}\,(k^{:A\rightarrow C}\rightarrow k\bef g,\;l^{:B\rightarrow C}\rightarrow f\bef l)$,
both relations having type $\left(A\rightarrow C\right)\leftrightarrow\left(B\rightarrow D\right)$.

\textbf{(f)} $\big(\text{rev}\left<f\right>\big)\ogreaterthan\left<g\right>=\langle l^{:B\rightarrow C}\rightarrow f\bef l\bef g\rangle$,
both relations having type $\left(B\rightarrow C\right)\leftrightarrow\left(A\rightarrow D\right)$.

\subparagraph{Solution}

We will apply various relations to arbitrary values $a^{:A}$, $b^{:B}$,
$c^{:C}$, $d^{:D}$.

\textbf{(a)} The following conditions are equivalent:
\begin{align*}
 & (a\times c,b\times d)\in\left<f\right>\boxtimes\left<g\right>\quad\text{means}\quad(a,b)\in\left<f\right>\quad\text{and}\quad(c,d)\in\left<g\right>\quad\text{or}:\quad f(a)=b\text{ and }g(c)=b\quad,\\
 & (a\times c,b\times d)\in\left<f\boxtimes g\right>\quad\text{means}\quad(a\times c)\triangleright(f\boxtimes g)=b\times d\quad\text{or}:\quad f(a)\times g(c)=b\times d\quad.
\end{align*}

\textbf{(b)} The following conditions are equivalent:
\begin{align*}
 & (a+\bbnum 0,b+\bbnum 0)\in\left<f\right>\boxplus\left<g\right>\quad\text{means}\quad(a,b)\in\left<f\right>\quad\text{or equivalently}:\quad a\triangleright f=b\quad,\\
 & (a+\bbnum 0,b+\bbnum 0)\in\left<f\boxplus g\right>\quad\text{means}\quad(a+\bbnum 0)\triangleright(f\boxplus g)=b+\bbnum 0\quad\text{or equivalently}:\quad a\triangleright f=b\quad.
\end{align*}
Similarly we can show that the conditions $(\bbnum 0+c,\bbnum 0+d)\in\left<f\right>\boxplus\left<g\right>$
and $(\bbnum 0+c,\bbnum 0+d)\in\left<f\boxplus g\right>$ are equivalent.
Values from different parts of the disjunctions, such as $(a+\bbnum 0,\bbnum 0+d)$,
are not in the relation $\left<f\right>\boxplus\left<g\right>$ by
definition of $\boxplus$. They are also not in the relation $\left<f\boxplus g\right>$
since the function $f\boxplus g$ preserves the left and right parts
of the disjunctions.

\textbf{(c)} Two functions $k^{:A\rightarrow C}$ and $l^{:B\rightarrow C}$
are in the relation $\left<f\right>\ogreaterthan\text{id}^{:C\leftrightarrow C}$
if:
\[
\text{for all }a^{:A},b^{:B}\quad:\quad\text{when}\quad(a,b)\in\left<f\right>\quad\text{then}\quad(k(a),l(b))\in\text{id}^{:C\leftrightarrow C}\quad.
\]
Simplifying the last condition, we get:
\[
\text{for all }a^{:A}\quad:\quad k(a)=l(f(a))\quad,\quad\text{or equivalently}:\quad k=f\bef l\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $k=\psi(l)$
where the function $\psi$ is defined as:
\[
\psi:\left(B\rightarrow C\right)\rightarrow A\rightarrow C\quad,\quad\quad\psi\triangleq l^{:B\rightarrow C}\rightarrow f\bef l\quad.
\]
This relation is denoted by $\text{rev}\left<\psi\right>$. It follows
that $\left<f\right>\ogreaterthan\text{id}^{:C\leftrightarrow C}=\text{rev}\left<\psi\right>=\text{rev}\langle l^{:B\rightarrow C}\rightarrow f\bef l\rangle$.

\textbf{(d)} Two functions $k^{:A\rightarrow C}$ and $l^{:A\rightarrow D}$
are in the relation $\text{id}^{:A\leftrightarrow A}\ogreaterthan\left<g\right>$
if:
\[
\text{for all }x^{:A},y^{:A}\quad:\quad\text{when}\quad(x,y)\in\text{id}^{:A\leftrightarrow A}\quad\text{then}\quad(k(x),l(y))\in\left<g\right>\quad.
\]
Simplifying the last condition, we get:
\[
\text{for all }x^{:A}\quad:\quad g(k(x))=l(x)\quad,\quad\text{or equivalently}:\quad l=k\bef g\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $\phi(k)=l$
where:
\[
\phi:\left(A\rightarrow C\right)\rightarrow A\rightarrow D\quad,\quad\phi\triangleq k^{:A\rightarrow C}\rightarrow k\bef g\quad.
\]
This relation is denoted by $\left<\phi\right>$. It follows that
we may write $\text{id}^{:A\leftrightarrow A}\ogreaterthan\left<g\right>=\left<\phi\right>=\langle k^{:A\rightarrow C}\rightarrow k\bef g\rangle$.

\textbf{(e)} Two functions $k^{:A\rightarrow C}$ and $l^{:B\rightarrow D}$
are in the relation $\left<f\right>\ogreaterthan\left<g\right>$ if:
\[
\text{for all }a^{:A},b^{:B}\quad:\quad\text{when}\quad(a,b)\in\left<f\right>\quad\text{then}\quad(k(a),l(b))\in\left<g\right>\quad.
\]
Simplifying the last condition, we get:
\[
\text{for all }a^{:A}\quad:\quad g(k(a))=l(f(a))\quad,\quad\text{or equivalently}:\quad f\bef l=k\bef g\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $\phi(k)=\psi(l)$
where: 
\[
\phi:\left(A\rightarrow C\right)\rightarrow A\rightarrow D\quad,\quad\phi\triangleq k^{:A\rightarrow C}\rightarrow k\bef g\quad,\quad\psi:\left(B\rightarrow D\right)\rightarrow A\rightarrow D\quad,\quad\psi\triangleq l^{:B\rightarrow C}\rightarrow f\bef l\quad.
\]
 This is a pullback relation that we denote by $\text{pull}\,(\phi,\psi)=\text{pull}\,\big(k^{:A\rightarrow C}\rightarrow k\bef g,\;l^{:B\rightarrow C}\rightarrow f\bef l\big)$.

\textbf{(f)} Two functions $k^{:B\rightarrow C}$ and $l^{:A\rightarrow D}$
are in the relation $\text{rev}\left<f\right>\ogreaterthan\left<g\right>$
if:
\[
\text{for all }x^{:B},y^{:A}\quad:\quad\text{when}\quad(x,y)\in\text{rev}\left<f\right>\quad\text{then}\quad(k(x),l(y))\in\left<g\right>\quad.
\]
Simplifying the last condition, we get:
\[
\text{for all }y^{:A}\quad:\quad g(k(f(y)))=l(y)\quad,\quad\text{or equivalently}:\quad f\bef k\bef g=l\quad.
\]
So, the relation between $k$ and $l$ may be expressed as $\phi(k)=l$
where: 
\[
\phi:\left(B\rightarrow C\right)\rightarrow A\rightarrow D\quad,\quad\phi\triangleq k^{:B\rightarrow C}\rightarrow f\bef k\bef g\quad.
\]
 This relation is denoted by $\left<\phi\right>$. We get $\text{rev}\left<f\right>\ogreaterthan\left<g\right>=\left<\phi\right>=\langle k^{:B\rightarrow C}\rightarrow f\bef k\bef g\rangle$.
$\square$

We now turn to the question of how to define the lifting $r^{\updownarrow G}$
to an arbitrary type constructor $G^{\bullet}$. It turns out that
we will actually need to define a \emph{simultaneous} lifting of several
relations to a type constructor with several type parameters. For
clarity, we postpone that definition and begin by lifting a single
relation.

\subsubsection{Definition \label{subsec:Definition-relational-lifting}\ref{subsec:Definition-relational-lifting}
(relational lifting)}

Given a relation $r^{:A\leftrightarrow B}$ and a type constructor
$G^{\bullet}$, the relational lifting of $r$ to $G$, denoted by
$r^{\updownarrow G}$, is a new relation of type $G^{A}\leftrightarrow G^{B}$.
The relation $r^{\updownarrow G}$ is defined by induction on the
structure of $G$.

Below, the type constructors $K^{A}$, $L^{A}$, $H^{X,A}$, and $S^{A,R}$
are not assumed to be covariant or contravariant. They can be any
exponential-polynomial, fully parametric type constructors.

\textbf{(a)} If $G^{A}\triangleq Z$ with a fixed type $Z$, we define
$r^{\updownarrow G}\triangleq\text{id}^{:Z\leftrightarrow Z}$.

\textbf{(b)} If $G=\text{Id}$ (that is, $G^{A}\triangleq A$), we
define $r^{\updownarrow\text{Id}}\triangleq r$. 

\textbf{(c)} If $G^{A}\triangleq K^{A}\times L^{A}$ then we define
$r^{\updownarrow G}\triangleq r^{\updownarrow K}\boxtimes r^{\updownarrow L}$.
The inductive assumption is that the relational liftings $r^{\updownarrow K}$
and $r^{\updownarrow L}$ are already defined.

\textbf{(d)} If $G^{A}\triangleq K^{A}+L^{A}$ then we define $r^{\updownarrow G}\triangleq r^{\updownarrow K}\boxplus r^{\updownarrow L}$
with the same inductive assumptions.

\textbf{(e)} If $G^{A}\triangleq K^{A}\rightarrow L^{A}$ then we
define $r^{\updownarrow G}\triangleq r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}$
with the same inductive assumptions.

\textbf{(f)} If $G^{A}\triangleq S^{A,G^{A}}$ is defined recursively
via a recursion scheme $S^{\bullet,\bullet}$, we define $r^{\updownarrow G}$
by:
\[
r^{\updownarrow G}\triangleq\big(r,\overline{r^{\uparrow G}}\big)^{\updownarrow S}\quad.
\]
Here the notation $(r,s)^{\updownarrow S}$ means the simultaneous
lifting of the two relations $r$, $s$ to the type constructor $S^{\bullet,\bullet}$
(see Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
below). Also note that we use $\overline{r^{\updownarrow G}}$ recursively
within the definition of $r^{\updownarrow G}$. This is allowed since
we understand $r^{\updownarrow G}$ to be a function (of type $G^{A}\times G^{B}\rightarrow\bbnum 2$,
see Definition~\ref{subsec:Definition-relation-between-A-B}), and
it is permitted to define functions recursively. The inductive assumption
is that simultaneous liftings to $S^{\bullet,\bullet}$ are already
defined.

\textbf{(g)} If $G^{A}\triangleq\forall X.\,H^{X,A}$, we define $r^{\updownarrow G}$
of type $(\forall X.\,H^{X,A})\leftrightarrow(\forall Y.\,H^{Y,B})$
by:
\[
(p^{:\forall X.\,H^{X,A}},q^{:\forall X.\,H^{X,B}})\in r^{\updownarrow\forall X.\,H^{X,\bullet}}\quad\text{means}\quad\forall(X,Y).\,\forall s^{X\leftrightarrow Y}.\,(p^{X},q^{Y})\in(s,r)^{\updownarrow H}\quad.
\]
Here $(s,r)^{\updownarrow H}$ denotes the simultaneous lifting of
$s$ and $r$ to $H$ (see Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
below). A shorter way of writing the formula above is by formulating
a relation between $p^{X}$ and $q^{Y}$ directly:
\begin{equation}
\forall(X,Y):\quad\big(r^{\updownarrow\forall Z.\,H^{Z,\bullet}}\big)^{X,Y}\triangleq\forall s^{:X\leftrightarrow Y}.\,(s,r)^{\updownarrow H}\quad.\label{eq:relational-lifting-quantified-types-short}
\end{equation}
The inductive assumption is that simultaneous liftings to $H$ are
already defined. $\square$

We can see that Definition~\ref{subsec:Definition-relational-lifting}
translates the type structure of $G^{A}$ into an analogous relational
structure. Constant types ($Z$) are replaced by the corresponding
identity relations ($\text{id}^{:Z\leftrightarrow Z}$). Each occurrence
of $A$ in $G^{A}$ is replaced by an occurrence of the relation $r$
being lifted. Product types, co-product types, and function types
are replaced by the relational operations $\boxtimes$, $\boxplus$,
and $\ogreaterthan$. Recursive usage of types are replaced by the
recursive usage of the lifted relations. Universally quantified types
($\forall X$) are replaced by universally quantified new relations
between new types. 

So, an expression for a relational lifting $r^{\updownarrow G}$ can
be written immediately by looking at the structure of $G$. For instance,
lifting a relation $r^{:A\leftrightarrow B}$ to a type constructor
$G^{A}\triangleq\forall X.\,\left(A\rightarrow X\right)\times\left(X\rightarrow A+Z\right)$
is expressed as:
\[
\big(r^{\updownarrow G}\big)^{X,Y}=\forall s^{:X\leftrightarrow Y}.\,(r\ogreaterthan s)\boxtimes\big(s\ogreaterthan(r\boxplus\text{id}^{:Z\leftrightarrow Z})\big)\quad.
\]
 We will illustrate this technique further in Example~\ref{subsec:Example-relational-lifting}
below.

To get more intuition, let us consider relations $r$ obtained from
functions $f$ as $r=\left<f\right>$. In that case, one can sometimes
(but not always) express the lifted relation $\left<f\right>^{\updownarrow P}$
through ordinary function liftings $f^{\uparrow P}$ and $f^{\downarrow P}$
via the $\left(P,f\right)$-wedge condition.

\subsubsection{Example \label{subsec:Example-relational-lifting}\ref{subsec:Example-relational-lifting}\index{solved examples}}

A function $f^{:A\rightarrow B}$ gives rise to a relation $\left<f\right>$
of type $A\leftrightarrow B$. Use Definition~\ref{subsec:Definition-relational-lifting}
to compute the lifting $\left<f\right>^{\updownarrow P}$ for the
following type constructors $P^{\bullet}$:

\textbf{(a)} $P^{A}\triangleq A+A\times A\quad$.

\textbf{(b)} $P^{A}\triangleq(R\rightarrow A)\times(A\rightarrow S)$
where $R$ and $S$ are fixed types.

\textbf{(c)} $P^{A}\triangleq A\rightarrow A\quad$.

\textbf{(d)} $P^{A}\triangleq A\rightarrow\left(A\rightarrow R\right)\rightarrow R$
where $R$ is a fixed type.

\textbf{(e)} $P^{A}\triangleq\left(A\rightarrow A\right)\rightarrow A\quad$.

In each case \textbf{(a)}\textendash \textbf{(e)}, express $P^{A}\triangleq N^{A,A}$
where $N^{X,Y}$ is a suitable profunctor and compare the condition
$(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$ with the $\left(N,f\right)$-wedge
relation ($p_{1}\triangleright f^{\uparrow N}=p_{2}\triangleright f^{\downarrow N}$). 

\subparagraph{Solution}

In all cases, the lifted relation $\left<f\right>^{\updownarrow P}$
has type $P^{A}\leftrightarrow P^{B}$.

\textbf{(a)} At the top level, $P^{A}$ is a disjunction: $P^{A}=\text{Id}^{A}+H^{A}$
where $H^{A}\triangleq A\times A=\text{Id}^{A}\times\text{Id}^{A}$.
The lifting to the identity functor is given by $r^{\updownarrow\text{Id}}\triangleq r$
according to Definition~\ref{subsec:Definition-relational-lifting}(b).
So, the lifting $r^{\updownarrow P}$ can be written as:
\[
r^{\updownarrow P}=r^{\updownarrow\text{Id}}\boxplus r^{\updownarrow H}=r^{\updownarrow\text{Id}}\boxplus\big(r^{\updownarrow\text{Id}}\boxtimes r^{\updownarrow\text{Id}}\big)=r\boxplus\big(r\boxtimes r\big)\quad.
\]
We see that the relational formula $r^{\updownarrow P}=r\boxplus\big(r\boxtimes r\big)$
repeats the type structure $P^{A}=A+A\times A$.

Setting now $r=\left<f\right>$, we find:
\[
\left<f\right>^{\updownarrow P}=\left<f\right>\boxplus\left<f\right>^{\updownarrow H}=\left<f\right>\boxplus\big(\left<f\right>\boxtimes\left<f\right>\big)\quad.
\]
Use Definition~\ref{subsec:Definition-relational-lifting}(d) to
express the condition for some values $(x^{:P^{A}},y^{:P^{B}})$ to
be in the relation $\left<f\right>\boxplus\left<f\right>^{\updownarrow H}$:
\[
(x,y)\in\left<f\right>^{\updownarrow P}\text{ if }x=x_{1}+\bbnum 0,\,y=y_{1}+\bbnum 0,\,(x_{1},y_{1})\in\left<f\right>\text{ or }x=\bbnum 0+x_{2},\,y=\bbnum 0+y_{2},\,(x_{2},y_{2})\in\left<f\right>^{\updownarrow H}\quad.
\]
The condition $(x_{1},y_{1})\in\left<f\right>$ means $f(x_{1})=y_{1}$.
Finally, Definition~\ref{subsec:Definition-relational-lifting}(c)
gives:
\[
(a_{1}^{:A}\times a_{2}^{:A},b_{1}^{:B}\times b_{2}^{:B})\in\left<f\right>\boxtimes\left<f\right>\text{ if }(a_{1},b_{1})\in\left<f\right>\text{ and }(a_{2},b_{2})\in\left<f\right>\quad.
\]
The last condition is simplified to:
\[
(a_{1}^{:A}\times a_{2}^{:A},b_{1}^{:B}\times b_{2}^{:B})\in\left<f\right>^{\updownarrow H}\text{ if }f(a_{1})=b_{1}\text{ and }f(a_{2})=b_{2}\quad.
\]

Putting the pieces together, we obtain the following definition of
the relation $\left<f\right>^{\updownarrow P}$:
\[
(x^{:P^{A}},y^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ if }x=x_{1}+\bbnum 0\text{ and }y=f(x_{1})+\bbnum 0,\text{ or }x=\bbnum 0+a_{1}\times a_{2}\text{ and }y=\bbnum 0+f(a_{1})\times f(a_{2})\quad.
\]
We note that this condition is equivalent to applying $f^{\uparrow P}$:
\[
(x^{:P^{A}},y^{:P^{B}})\in\left<f\right>^{\updownarrow P}\text{ if }x\triangleright f^{\uparrow P}=y\quad,\quad\text{ or more concisely}:\quad\left<f\right>^{\updownarrow P}=\langle f^{\uparrow P}\rangle\quad.
\]

We will prove below (Statement~\ref{subsec:Statement-lifting-function-relation-covariant-1})
that this property holds for all functors $P$.

With $N^{X,Y}\triangleq P^{Y}$, the $\left(N,f\right)$-wedge relation
is equivalent to the equation $x\triangleright f^{\uparrow P}=y$.

\textbf{(b)} At the top level, $P^{A}$ is a product: $P^{A}=G^{A}\times H^{A}$
where $G^{A}\triangleq R\rightarrow A$ and $H^{A}\triangleq A\rightarrow S$.
By Definition~\ref{subsec:Definition-relational-lifting}(c), we
get $r^{\updownarrow P}=r^{\updownarrow G}\boxtimes r^{\updownarrow H}$.
To compute $r^{\updownarrow G}$, we note that $G$ is an exponential
functor construction, $G^{A}=K^{A}\rightarrow\text{Id}^{A}$, that
uses a constant functor $K^{A}\triangleq R$. Lifting to a constant
functor gives $r^{\updownarrow K}=\text{id}^{:R\leftrightarrow R}$
according to Definition~\ref{subsec:Definition-relational-lifting}(a).
So, we find:
\[
r^{\updownarrow G}=\text{id}^{:R\leftrightarrow R}\ogreaterthan r^{\updownarrow\text{Id}}=\text{id}^{:R\leftrightarrow R}\ogreaterthan r\quad.
\]
We treat $r^{\updownarrow H}$ similarly and obtain $r^{\updownarrow H}=r\ogreaterthan\text{id}^{:S\leftrightarrow S}$.
Put the pieces together:
\[
r^{\updownarrow P}=r^{\updownarrow G}\boxtimes r^{\updownarrow H}=(\text{id}^{:R\leftrightarrow R}\ogreaterthan r)\boxtimes(r\ogreaterthan\text{id}^{:S\leftrightarrow S})\quad.
\]
We see that $r^{\updownarrow P}$ repeats the type structure of $P^{A}=(R\rightarrow A)\times(A\rightarrow S)$.
The occurrences of $A$ in $P^{A}$ are replaced by $r$, while constant
types ($R$, $S$) are replaced by the corresponding identity relations
($\text{id}^{:R\leftrightarrow R}$ and $\text{id}^{:S\leftrightarrow S}$).
We will see a similar pattern in the remaining parts of this example.

We now set $r=\left<f\right>$ and transform $\left<f\right>^{\updownarrow P}$
to a more specific formula for a relation of type $P^{A}\leftrightarrow P^{B}$
where $A$, $B$ are arbitrary types. For arbitrary values $g_{1}^{:R\rightarrow A}$,
$g_{2}^{:R\rightarrow B}$, $h_{1}^{:A\rightarrow S}$, $h_{2}^{:B\rightarrow S}$,
we write:
\[
(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}\text{ means }(g_{1},g_{2})\in\text{id}^{:R\leftrightarrow R}\ogreaterthan\left<f\right>\text{ and }(h_{1},h_{2})\in\left<f\right>\ogreaterthan\text{id}^{:S\leftrightarrow S}\quad.
\]

The condition $(g_{1},g_{2})\in\text{id}\ogreaterthan\left<f\right>$
is rewritten using Definition~\ref{subsec:Definition-relational-lifting}(e):
\[
(g_{1}^{:R\rightarrow A},g_{2}^{:R\rightarrow B})\in\text{id}\ogreaterthan\left<f\right>\text{ means if }(r_{1}^{:R},r_{2}^{:R})\in\text{id}^{:R\leftrightarrow R}\text{ then }(g_{1}(r_{1}),g_{2}(r_{2}))\in\left<f\right>\quad.
\]
The identity relation between $r_{1}$ and $r_{2}$ holds only if
$r_{1}=r_{2}$. We find:
\[
(g_{1}^{:R\rightarrow A},g_{2}^{:R\rightarrow B})\in\text{id}^{:R\leftrightarrow R}\ogreaterthan\left<f\right>\text{ means }\forall r^{:R}.\,f(g_{1}(r))=g_{2}(r)\quad\text{or equivalently}:\quad g_{1}\bef f=g_{2}\quad.
\]

The condition $(h_{1},h_{2})\in\left<f\right>^{\updownarrow H}$ is
rewritten using the same definitions:
\[
(h_{1}^{:A\rightarrow S},h_{2}^{:B\rightarrow S})\in\left<f\right>\ogreaterthan\text{id}^{:S\leftrightarrow S}\text{ means if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(h_{1}(a),h_{2}(b))\in\text{id}\quad.
\]
We simplify this to:
\[
(h_{1}^{:A\rightarrow S},h_{2}^{:B\rightarrow S})\in\left<f\right>\ogreaterthan\text{id}^{:S\leftrightarrow S}\text{ means }h_{1}(a)=h_{2}(f(a))\quad\text{or equivalently}:\quad h_{1}=f\bef h_{2}\quad.
\]

Finally, the lifted relation $\left<f\right>^{\updownarrow P}$ is
expressed as:
\[
(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}\text{ if }g_{1}\bef f=g_{2}\text{ and }h_{1}=f\bef h_{2}\quad.
\]

Defining the profunctor $N^{X,Y}\triangleq\left(R\rightarrow Y\right)\times\left(X\rightarrow S\right)$,
we find that $g_{1}\times h_{1}$ has type $N^{A,A}$ and $g_{2}\times h_{2}$
has type $N^{B,B}$. Then the condition $(g_{1}\times h_{1},g_{2}\times h_{2})\in\left<f\right>^{\updownarrow P}$
is \emph{equivalent} to the $\left(N,f\right)$-wedge relation:
\[
(g_{1}\times h_{1})\triangleright f^{\uparrow N^{A,\bullet}}=(g_{2}\times h_{2})\triangleright f^{\downarrow N^{\bullet,B}}\quad.
\]

\textbf{(c)} Using Definition~\ref{subsec:Definition-relational-lifting}(b)
and (e), we get:
\begin{align*}
 & r^{\updownarrow P}=r^{\updownarrow\text{Id}}\ogreaterthan r^{\updownarrow\text{Id}}=r\ogreaterthan r\quad,\quad\quad\text{so}\quad\left<f\right>^{\updownarrow P}=\left<f\right>\ogreaterthan\left<f\right>\quad;\\
 & (p_{1}^{:A\rightarrow A},p_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad\text{if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(p_{1}(a),p_{2}(b))\in\left<f\right>\quad.
\end{align*}
The condition can be rewritten as a single equation:
\[
(p_{1}^{:A\rightarrow A},p_{2}^{:B\rightarrow B})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad f(p_{1}(a))=p_{2}(f(a))\quad\text{or equivalently}:\quad p_{1}\bef f=f\bef p_{2}\quad.
\]
This is the same as the $\left(N,f\right)$-wedge relation ($p_{1}\triangleright f^{\uparrow N}=p_{2}\triangleright f^{\downarrow N}$)
with the profunctor $N^{X,Y}\triangleq X\rightarrow Y$.

\textbf{(d)} Since $P^{A}=\text{Id}^{A}\rightarrow Q^{A}$ is a function
type (with $Q^{A}\triangleq\left(A\rightarrow R\right)\rightarrow R$),
we use Definition~\ref{subsec:Definition-relational-lifting}(e):
\[
r^{\updownarrow P}=r^{\updownarrow\text{Id}}\ogreaterthan r^{\updownarrow Q}=r\ogreaterthan(r\ogreaterthan\text{id}^{:R\leftrightarrow R})\ogreaterthan\text{id}^{:R\leftrightarrow R}\quad.
\]
Let us now substitute $r=\left<f\right>$ and simplify the conditions:
\[
(p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>\ogreaterthan\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad\text{if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(p_{1}(a),p_{2}(b))\in\left<f\right>^{\updownarrow Q}\quad.
\]
The definition of $\left<f\right>^{\updownarrow Q}$ is obtained if
we define $K^{A}\triangleq A\rightarrow R$:
\[
(q_{1}^{:Q^{A}},q_{2}^{:Q^{B}})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad\text{if }(k_{1}^{:A\rightarrow R},k_{2}^{:B\rightarrow R})\in\left<f\right>^{\updownarrow K}\text{ then }(q_{1}(k_{1}),q_{2}(k_{2}))\in\text{id}\quad.
\]
Expanding the definition of $\left<f\right>^{\updownarrow K}$ as
we did in part \textbf{(b)} of this example, we get:
\[
(q_{1},q_{2})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad\text{if }b=f(a)\text{ and }k_{1}(a)=k_{2}(b)\text{ then }q_{1}(k_{1})=q_{2}(k_{2})\quad.
\]
This simplifies to $k_{1}(a)=k_{2}(f(a))$, or $k_{1}=f\bef k_{2}$.
So, we finally express $\left<f\right>^{\updownarrow Q}$ and $\left<f\right>^{\updownarrow P}$
as:
\begin{align*}
 & (q_{1}^{:Q^{A}},q_{2}^{:Q^{B}})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad(k\rightarrow f\bef k)\bef q_{1}=q_{2}\quad,\\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad a\rightarrow\big((k\rightarrow f\bef k)\bef p_{1}(a)\big)=f\bef p_{2}\quad.
\end{align*}

Defining $N^{X,Y}\triangleq X\rightarrow\left(Y\rightarrow R\right)\rightarrow R$,
we find that the last formula is equivalent to the $\left(N,f\right)$-wedge
relation for $p_{1}$ and $p_{2}$:
\[
p_{1}\triangleright f^{\uparrow N}=p_{1}\bef(q\rightarrow(k\rightarrow f\bef k)\bef q)\quad,\quad\quad p_{2}\triangleright f^{\downarrow N}=f\bef p_{2}\quad.
\]

\textbf{(e)} We may write $P^{A}=Q^{A}\rightarrow\text{Id}^{A}$ with
$Q^{A}\triangleq A\rightarrow A$ and use Definition~\ref{subsec:Definition-relational-lifting}(e):
\begin{align*}
 & r^{\updownarrow P}=r^{\updownarrow Q}\ogreaterthan r^{\updownarrow\text{Id}}=(r\ogreaterthan r)\ogreaterthan r\quad,\quad\quad\left<f\right>^{\updownarrow P}=(\left<f\right>\ogreaterthan\left<f\right>)\ogreaterthan\left<f\right>\quad,\\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in(\left<f\right>\ogreaterthan\left<f\right>)\ogreaterthan\left<f\right>\quad\text{means}\quad\text{if }(q_{1}^{:A\rightarrow A},q_{2}^{:B\rightarrow B})\in\left<f\right>\ogreaterthan\left<f\right>\text{ then }(p_{1}(q_{1}),p_{2}(q_{2}))\in\left<f\right>\quad.\\
 & (q_{1}^{:A\rightarrow A},q_{2}^{:B\rightarrow B})\in\left<f\right>\ogreaterthan\left<f\right>\quad\text{means}\quad\text{if }(a^{:A},b^{:B})\in\left<f\right>\text{ then }(q_{1}(a),q_{2}(b))\in\left<f\right>\quad.
\end{align*}
Simplifying these conditions, we get:
\begin{align}
 & (q_{1},q_{2})\in\left<f\right>^{\updownarrow Q}\quad\text{ means }\quad q_{1}\bef f=f\bef q_{2}\quad,\nonumber \\
 & (p_{1}^{:P^{A}},p_{2}^{:P^{B}})\in\left<f\right>^{\updownarrow P}\quad\text{ means }\quad\text{if }q_{1}\bef f=f\bef q_{2}\text{ then }f(p_{1}(q_{1}))=p_{2}(q_{2})\quad.\label{eq:relational-lifting-example-e-derivation1}
\end{align}
The condition for $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$
\emph{cannot} be written as a single equation involving $p_{1}$ and
$p_{2}$ because we cannot express $q_{1}$ through $q_{2}$ or $q_{2}$
through $q_{1}$. The relation between $q_{1}$ and $q_{2}$ is many-to-many
and is not equivalent to a function.

Let us define $N^{X,Y}\triangleq\left(Y\rightarrow X\right)\rightarrow Y$
and write the $\left(N,f\right)$-wedge relation for $p_{1}^{:N^{A,A}}$
and $p_{2}^{:N^{B,B}}$:
\begin{equation}
k^{:B\rightarrow A}\triangleright(p_{1}\triangleright f^{\uparrow N})=k\triangleright(p_{2}\triangleright f^{\downarrow N})\quad\text{or equivalently}:\quad f(p_{1}(f\bef k))=p_{2}(k\bef f)\quad.\label{eq:N-f-wedge-relation-example-derivation1}
\end{equation}
We notice that if we set $q_{1}\triangleq f\bef k$ and $q_{2}\triangleq k\bef f$
then the precondition $q_{1}\bef f=f\bef q_{2}$ in Eq.~(\ref{eq:relational-lifting-example-e-derivation1})
will be satisfied, and it will follow that $f(p_{1}(q_{1}))=p_{2}(q_{2})$.
So, the $\left(N,f\right)$-wedge relation is a \emph{consequence}
of the relation $(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}$.
However, if we are given some functions $f$, $q_{1}$, and $q_{2}$
such that the precondition $q_{1}\bef f=f\bef q_{2}$ holds, it does
not follow that there exists a function $k$ such that $q_{1}=f\bef k$
and $q_{2}=k\bef f$. A simple counterexample is found when $f$ is
a constant function that ignores its argument and always returns a
fixed value:
\[
f^{:A\rightarrow B}\triangleq\_^{:A}\rightarrow b_{0}\quad,\quad\quad\text{where }b_{0}\text{ is a fixed value of type }B\quad.
\]
Then the precondition $q_{1}\bef f=f\bef q_{2}$ is reduced to the
condition $q_{2}(b_{0})=b_{0}$ with \emph{no} restrictions on $q_{1}$.
But if $q_{1}^{:A\rightarrow A}$ were expressed as $q_{1}=f\bef k$
with some $k^{:B\rightarrow A}$, we would have $q_{1}=\_\rightarrow k(b_{0})$.
So, functions $q_{1}$ expressed as $f\bef k$ are constant functions
that ignore their argument. This is a stronger restriction than $q_{1}\bef f=f\bef q_{2}$
because more pairs $\left(q_{1},q_{2}\right)$ satisfy $q_{1}\bef f=f\bef q_{2}$.
Accordingly, the $\left(N,f\right)$-wedge relation~(\ref{eq:N-f-wedge-relation-example-derivation1})
constrains the functions $\left(p_{1},p_{2}\right)$ weaker and is
satisfied by more pairs $\left(p_{1},p_{2}\right)$ than the relation
$\left<f\right>^{\updownarrow P}$. So, the $\left(N,f\right)$-wedge
relation is\emph{ weaker} than the relation $\left<f\right>^{\updownarrow P}$.
$\square$

Below we will prove (Statement~\ref{subsec:Statement-wedge-law-from-parametricity})
that the $\left(N,f\right)$-wedge relation is always a consequence
of the corresponding lifted relation $\left<f\right>^{\updownarrow P}$.
Example~\ref{subsec:Example-relational-lifting} shows that the $\left(N,f\right)$-wedge
relation is equivalent to $\left<f\right>^{\updownarrow P}$ only
when the type structure of $P$ is sufficiently simple.

\subsection{Properties of relational lifting. Simultaneous lifting}

Definition~\ref{subsec:Definition-relational-lifting} requires some
additional work to be fully usable. This section proves the properties
of relational lifting that will be needed later in this Appendix.

We begin by pointing out an ambiguity in applying Definition~\ref{subsec:Definition-relational-lifting}(g)
to $G^{A}\triangleq\forall X.\,H^{X,A}$ when $H^{X,A}$ does \emph{not}
actually depend on the type parameter $A$; that is, when $H^{X,A}=K^{X}$
with some $K^{\bullet}$. In that case, the type constructor $G$
is a constant functor: $G^{A}=Z\triangleq\forall X.\,K^{X}$. We may
lift a relation $r^{:A\leftrightarrow B}$ to $G^{A}\triangleq Z$
using Definition~\ref{subsec:Definition-relational-lifting}(a) and
obtain $r^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}$. To show
that Definition~\ref{subsec:Definition-relational-lifting} is consistent,
we need to prove that Definitions~\ref{subsec:Definition-relational-lifting}(a)
and~(g) define the same lifted relation $r^{\updownarrow G}$. This
will be shown in Statement~\ref{subsec:Statement-parametricity-gives-identity-relation}
below by using the relational naturality law~(\ref{eq:relational-naturality-law-simplified}).
That law is the result of the relational parametricity theorem (Section~\ref{subsec:Relational-parametricity-theorem}).
So, the relational parametricity theorem turns out to be a necessary
requirement for the consistency of Definition~\ref{subsec:Definition-relational-lifting}.

\subsubsection{Statement \label{subsec:Statement-parametricity-gives-identity-relation}\ref{subsec:Statement-parametricity-gives-identity-relation}}

For a quantified type $Z\triangleq\forall X.\ H^{X}$, the relation
$\text{id}^{:Z\leftrightarrow Z}$ has two equivalent forms:
\[
(p^{:\forall X.\,H^{X}},q^{:\forall Y.\,H^{Y}})\in\text{id}\quad\text{ is equivalent to}:\quad\forall(X,Y).\,\forall s^{:X\leftrightarrow Y}.\,(p^{X},q^{Y})\in s^{\updownarrow H}\quad.
\]
Here we assume that $p$ and $q$ are implemented via fully parametric
code.

\subparagraph{Proof}

We need to prove the equivalence in both directions.

If some $p$ and $q$ satisfy $(p^{X},q^{Y})\in s^{\updownarrow H}$
where we may choose $s$ arbitrarily, let us choose $s$ to be the
identity relation and force $X$ and $Y$ to be the same type:
\[
(x^{:X},y^{:Y})\in s\text{ only when }X=Y\text{ and }x=y\quad.
\]
Lifting an identity relation will produce an identity relation (Statement~\ref{subsec:Statement-relational-lifting-identity-law}),
so:
\[
\forall(X,Y).\,(p^{X},q^{Y})\in s^{\updownarrow H}\text{ with }s^{\updownarrow H}=\text{id}\quad\text{ means }\quad X=Y\text{ and }p^{X}=q^{X}\quad.
\]
This is the same as the identity relation between $p$ and $q$.

It remains to show that $(p^{X},q^{Y})\in s^{\updownarrow H}$ when
$p=q$. In other words, $(p^{X},p^{Y})\in s^{\updownarrow H}$ for
any $s^{:X\leftrightarrow Y}$. Since $p$ is fully parametric, it
obeys the naturality law~(\ref{eq:relational-naturality-law-simplified}),
which we will prove below without using this statement. We set $Q^{X}\triangleq H^{X}$,
$r\triangleq s$, and $t\triangleq p$ in the naturality law~(\ref{eq:relational-naturality-law-simplified})
and obtain:
\[
\forall(X,Y).\,\forall s^{:X\leftrightarrow Y}.\,(p^{X},p^{Y})\in s^{\updownarrow H}\quad.
\]
$\square$

Another construction required for Definition~\ref{subsec:Definition-relational-lifting}
is a simultaneous lifting of two relations to a type constructor with
two type parameters. To gain intuition, consider a bifunctor $S^{\bullet,\bullet}$
and two functions $f^{:A\rightarrow B}$ and $g^{:X\rightarrow Y}$.
We can lift $f$ and $g$ simultaneously with respect to the two parameters
of $S^{\bullet,\bullet}$ using the \lstinline!bimap! method of the
bifunctor $S$. The result is a function of type $S^{A,X}\rightarrow S^{B,Y}$:
\[
\text{bimap}_{S}(f)(g):S^{A,X}\rightarrow S^{B,Y}\quad,\quad\text{bimap}_{S}(f)(g)=f^{\uparrow S^{\bullet,X}}\bef g^{\uparrow S^{B,\bullet}}=g^{\uparrow S^{A,\bullet}}\bef f^{\uparrow S^{\bullet,Y}}\quad.
\]
The resulting function is independent of the order of liftings due
to the bifunctor commutativity law\index{commutativity law!of bifunctors}
(Section~\ref{sec:Commutativity-laws-for-type-constructors}). However,
it turns out that the analog of \lstinline!bimap! for relations is
an operation that \emph{cannot} be expressed via separate liftings
with respect to each type parameter. For this reason, we need to define
the simultaneous relational lifting as a special new operation.

\subsubsection{Definition \label{subsec:Definition-simultaneous-relational-lifting}\ref{subsec:Definition-simultaneous-relational-lifting}
(simultaneous relational lifting)}

Given any fully parametric type constructor with two type parameters
($G^{\bullet,\bullet}$), we lift two relations $r^{:A\leftrightarrow B}$
and $s^{:X\leftrightarrow Y}$ simultaneously to $G$. This creates
a new relation of type $G^{A,X}\leftrightarrow G^{B,Y}$, denoted
by $(r,s)^{\updownarrow G}$ and defined by induction on the structure
of $G$:

\textbf{(a)} If $G^{A,X}\triangleq Z$ with a fixed type $Z$, we
define $(r,s)^{\updownarrow G}\triangleq\text{id}^{:Z\leftrightarrow Z}$.

\textbf{(b)} If $G^{A,X}=A$, we define $(r,s)^{\updownarrow G}\triangleq r$.
If $G^{A,X}=X$, we define $(r,s)^{\updownarrow G}\triangleq s$.

\textbf{(c)} If $K^{\bullet,\bullet}$ and $L^{\bullet,\bullet}$
are any fully parametric type constructors, we define: 
\begin{align*}
{\color{greenunder}\text{for}\quad G^{A,X}\triangleq K^{A,X}\times L^{A,X}\quad:}\quad & (r,s)^{\updownarrow G}\triangleq(r,s)^{\updownarrow K}\boxtimes(r,s)^{\updownarrow L}\quad;\\
{\color{greenunder}\text{for}\quad G^{A,X}\triangleq K^{A,X}+L^{A,X}\quad:}\quad & (r,s)^{\updownarrow G}\triangleq(r,s)^{\updownarrow K}\boxplus(r,s)^{\updownarrow L}\quad;\\
{\color{greenunder}\text{for}\quad G^{A,X}\triangleq K^{A,X}\rightarrow L^{A,X}\quad:}\quad & (r,s)^{\updownarrow G}\triangleq(r,s)^{\updownarrow K}\ogreaterthan(r,s)^{\updownarrow L}\quad.
\end{align*}
The last relation is between functions of types $K^{A,X}\rightarrow L^{A,X}$
and $K^{B,Y}\rightarrow L^{B,Y}$. 

The inductive assumption is that simultaneous liftings to $K$ and
$L$ are already defined.

\textbf{(d)} If $G^{A,X}\triangleq S^{A,X,G^{A,X}}$ is defined recursively
via a recursion scheme $S^{\bullet,\bullet,\bullet}$, we define:
\[
(r,s)^{\updownarrow G}\triangleq\big(r,s,\overline{(r,s)^{\updownarrow G}}\big)^{\updownarrow S}\quad.
\]
Here we use $\overline{(r,s)^{\updownarrow G}}$ recursively within
the definition of $(r,s)^{\updownarrow G}$. This is allowed since
we understand $(r,s)^{\updownarrow G}$ to be a function, and it is
permitted to define functions recursively. The inductive assumption
is that simultaneous liftings of any \emph{three} relations to $S^{\bullet,\bullet,\bullet}$
are already defined. 

\textbf{(e)} If $G^{A,X}\triangleq\forall Z.\,H^{Z,A,X}$, we define
$(r,s)^{\updownarrow G}$ of type $(\forall U.\,H^{U,A,X})\leftrightarrow(\forall V.\,H^{V,B,Y})$
by:
\[
(p^{:\forall U.\,H^{U,A,X}},q^{:\forall V.\,H^{V,B,Y}})\in(r,s)^{\updownarrow\forall Z.\,H^{Z,\bullet,\bullet}}\quad\text{means}\quad\forall(U,V).\,\forall w^{U\leftrightarrow V}.\,(p^{U},q^{V})\in(w,r,s)^{\updownarrow H^{\bullet,\bullet,\bullet}}\quad.
\]
A shorter way of writing this definition is by formulating a relation
between $p^{U}$ and $q^{V}$ directly:
\begin{equation}
\forall(U,V):\quad\big((r,s)^{\updownarrow\forall Z.\,H^{Z,\bullet,\bullet}}\big)^{U,V}\triangleq\forall w^{:U\leftrightarrow V}.\,(w,r,s)^{\updownarrow H^{\bullet,\bullet,\bullet}}\quad.\label{eq:relational-lifting-quantified-types-short-1}
\end{equation}
The inductive assumption is that simultaneous liftings to $H^{\bullet,\bullet,\bullet}$
are already defined. $\square$

Parts (d) and (e) of Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
use a simultaneous lifting of \emph{three} relations. Comparing Definitions~\ref{subsec:Definition-relational-lifting}
and~\ref{subsec:Definition-simultaneous-relational-lifting}, we
see that a similar inductive definition can be given for simultaneous
liftings of $n$ relations (with $n=1,2,...$) to a type constructor
with $n$ type parameters. We omit the details. This book will only
need simultaneous liftings of two relations.

When working with dinaturality laws (Section~\ref{sec:Naturality-laws-for-fully-parametric-functions}),
we used profunctors $P^{X,Y}$ whose type parameters are set to the
same type (e.g., $G^{A}\triangleq P^{A,A}$). In that case, there
is an ambiguity in lifting a relation $r^{:A\leftrightarrow B}$ to
$G$: First, Definition~\ref{subsec:Definition-relational-lifting}
defines $r^{\updownarrow G}$ as a relation of type $G^{A}\leftrightarrow G^{B}$,
which is the same type as $P^{A,A}\leftrightarrow P^{B,B}$. Second,
we may lift the pair of two relations $\left(r,r\right)$ simultaneously
to $P^{\bullet,\bullet}$ according to Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
and obtain another relation $\left(r,r\right)^{\updownarrow P}$ of
the same type $P^{A,A}\leftrightarrow P^{B,B}$. The following statement
shows that the relations $r^{\updownarrow G}$ and $(r,r)^{\updownarrow P}$
are equivalent.

\subsubsection{Statement \label{subsec:Statement-relational-lifting-consistency-PAA}\ref{subsec:Statement-relational-lifting-consistency-PAA}}

Given any fully parametric type constructor $P^{X,Y}$, define $G^{A}\triangleq P^{A,A}$.
For any relation $r^{:A\leftrightarrow B}$, the liftings $r^{\updownarrow G}$
and $\left(r,r\right)^{\updownarrow P}$ will produce the same relation
of type $P^{A,A}\leftrightarrow P^{B,B}$.

\subparagraph{Proof}

We need to enumerate all cases of Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
for the type constructor $P^{\bullet,\bullet}$ and the corresponding
cases of Definition~\ref{subsec:Definition-relational-lifting} for
$G^{\bullet}$. In each case, we will show that $(r,r)^{\updownarrow H}=r^{\updownarrow G}$.

If $P^{A,X}\triangleq Z$ with a fixed type $Z$, we have also $G^{A}=Z$.
Then $(r,r)^{\updownarrow P}=\text{id}^{:Z\leftrightarrow Z}$ and
$r^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}$.

If $P^{A,X}\triangleq A$ or $P^{A,X}=X$, we have $G^{A}=A$. In
both cases $(r,r)^{\updownarrow H}\triangleq r$ and $r^{\updownarrow G}=r$.

If $P^{\bullet,\bullet}\triangleq K^{\bullet,\bullet}\times L^{\bullet,\bullet}$
then we have $G^{A}=K^{A,A}\times L^{A,A}$. Denote $M^{A}\triangleq K^{A,A}$
and $N^{A}\triangleq L^{A,A}$, so that $G^{A}=M^{A}\times N^{A}$.
The inductive assumptions are $(r,r)^{\updownarrow K}=r^{\updownarrow M}$
and $(r,r)^{\updownarrow L}=r^{\updownarrow N}$. We find:
\[
(r,r)^{\updownarrow P}=(r,r)^{\updownarrow K}\boxtimes(r,r)^{\updownarrow L}=r^{\updownarrow M}\boxtimes r^{\updownarrow N}=r^{\updownarrow(M\times N)}=r^{\updownarrow G}\quad.
\]

If $P^{\bullet,\bullet}\triangleq K^{\bullet,\bullet}+L^{\bullet,\bullet}$
with $G^{A}=M^{A}+N^{A}$ and the same inductive assumptions, we get:
\[
(r,r)^{\updownarrow P}=(r,r)^{\updownarrow K}\boxplus(r,r)^{\updownarrow L}=r^{\updownarrow M}\boxplus r^{\updownarrow N}=r^{\updownarrow(M+N)}=r^{\updownarrow G}\quad.
\]

If $P^{\bullet,\bullet}\triangleq K^{\bullet,\bullet}\rightarrow L^{\bullet,\bullet}$
with $G^{A}=M^{A}\rightarrow N^{A}$ and the same inductive assumptions,
we find: 
\[
(r,r)^{\updownarrow P}=(r,r)^{\updownarrow K}\ogreaterthan(r,r)^{\updownarrow L}=r^{\updownarrow M}\ogreaterthan r^{\updownarrow N}=r^{\updownarrow(M^{\bullet}\rightarrow N^{\bullet})}=r^{\updownarrow G}\quad.
\]

If $P^{A,X}\triangleq S^{A,X,P^{A,X}}$ with a recursion scheme $S^{\bullet,\bullet,\bullet}$,
the type constructor $G^{\bullet}$ is defined by: 
\[
G^{A}\triangleq P^{A,A}=S^{A,A,P^{A,A}}=S^{A,A,G^{A}}\quad.
\]
Denote $Q^{A,X}\triangleq S^{A,A,X}$ and obtain $G^{A}=Q^{A,G^{A}}$.
So, the lifting to $G$ is given by $r^{\updownarrow G}=\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow Q}$.
Now write the definition of lifting to $P$ and simplify:
\begin{align*}
 & (r,r)^{\updownarrow P}=\big(r,r,\overline{(r,r)^{\updownarrow P}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\overline{(r,r)^{\updownarrow P}}=\overline{r^{\updownarrow G}}:}\quad & =\big(r,r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow Q}=\big(r,r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S}:}\quad & =\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow Q}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =r^{\updownarrow G}\quad.
\end{align*}

If $P^{A,X}\triangleq\forall Z.\,S^{Z,A,X}$, the type constructor
$G^{\bullet}$ is $G^{A}=\forall Z.\,S^{Z,A,A}$. Denote $Q^{Z,A}\triangleq S^{Z,A,A}$
and obtain $G^{A}=\forall Z.\,Q^{Z,A}$. The lifting $(r,r)^{\updownarrow P}$
is a relation of type $\forall U.\,S^{U,A,A}\leftrightarrow\forall V.\,S^{V,A,A}$
written as:
\begin{align*}
 & \forall(U,V):\quad\big((r,r)^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}\big)^{U,V}=\forall w^{:U\leftrightarrow V}.\,(w,r,r)^{\updownarrow S^{\bullet,\bullet,\bullet}}\\
{\color{greenunder}\text{inductive assumption about lifting to }S:}\quad & =\forall w^{:U\leftrightarrow V}.\,(w,r)^{\updownarrow Q}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =\big(r^{\updownarrow G}\big)^{U,V}\quad.
\end{align*}


\subsection{Relational parametricity theorem\label{subsec:Relational-parametricity-theorem}}

Our goal is to prove that any fully parametric function $t:\forall A.\,P^{A}\rightarrow Q^{A}$
obeys the law~(\ref{eq:naturality-law-of-t-derivation2}):
\[
\forall A,B.\,\forall r^{:A\leftrightarrow B}.\,(t^{A},t^{B})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}\quad.
\]
The proof will need to go by induction on the structure of the code
of the function $t$, which is built from smaller sub-expressions
using the nine code constructions of Table~\ref{tab:nine-pure-code-constructions}.
The inductive assumption is that all sub-expressions already satisfy
the relational naturality law. An immediate difficulty with this approach
is that the sub-expressions of $t$ may not have the type signature
of a function and may also contain free variables. To illustrate,
write the code of $t$ as $t=z^{:P^{A}}\rightarrow\text{expr}(z)$,
or in Scala:
\begin{lstlisting}
def t[A] = { z: P[A] => expr(z) }
\end{lstlisting}
where \textsf{``}\lstinline!expr(z)!\textsf{''} is the function\textsf{'}s body. That function
body \emph{itself} does not necessarily have a type signature of the
form $K^{A}\rightarrow L^{A}$. Also, \textsf{``}\lstinline!expr(z)!\textsf{''} may
contain $z$ as a free variable defined outside the scope of \textsf{``}\lstinline!expr(z)!\textsf{''},
and the type of $z$ may depend on the type parameter $A$. So, we
cannot directly apply the relational naturality law~(\ref{eq:naturality-law-of-t-derivation2})
to the subexpressions, which prevents us from using induction. The
relational naturality law needs to be reformulated to describe function
\emph{bodies}, i.e., arbitrary expressions that may contain externally
defined variables. A suitable formulation of the relational naturality
law is given in the next definition and will be the goal of Statement~\ref{subsec:Statement-main-relational-parametricity-1}.

\subsubsection{Definition \label{subsec:Definition-relational-naturality-law}\ref{subsec:Definition-relational-naturality-law}
(relational naturality law)}

Consider any expression $t:\forall A.\,Q^{A}$ containing a single
free variable\index{free variable} $x^{:P^{A}}$, where $P^{\bullet}$
and $Q^{\bullet}$ are any type constructors. Define the \textbf{binding
function} $t^{\prime}:\forall A.\,P^{A}\rightarrow Q^{A}$ such that
$t=\tilde{t}(x)$ and $\tilde{t}$ has no free variables. (The binding
function describes how the expression $t$ depends on its free variable
$x$.) Then the \textbf{relational naturality law}\index{naturality law!in terms of relations}
of $t$ is written as:
\begin{equation}
\forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}\quad.\label{eq:relational-naturality-law-1}
\end{equation}
If $t$ contains several free variables ($x_{1}^{:P_{1}^{A}}$, $x_{2}^{:P_{2}^{A}}$,
etc.), we define the binding function $\tilde{t}$ as a curried function
of all the free variables. For example, with \emph{two} free variables
we will have $t=\tilde{t}(x_{1})(x_{2})$, so that $\tilde{t}^{A}$
will have type $P_{1}^{A}\rightarrow P_{2}^{A}\rightarrow Q^{A}$.
Then the relational naturality law is written as:
\begin{equation}
\forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow P_{1}}\ogreaterthan r^{\updownarrow P_{2}}\ogreaterthan r^{\updownarrow Q}\quad.\label{eq:relational-naturality-law-two-free-vars}
\end{equation}
The generalization to any number of free variables is straightforward.
$\square$

If $t$ contains no free variables, we may still write $t$ as $\tilde{t}(x)$
where $\tilde{t}$ does not depend on $x$, setting $P^{A}\triangleq\bbnum 1$
for simplicity. In that case, Eq.~(\ref{eq:relational-naturality-law-1})
is simplified to:
\begin{align}
 & \forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,\forall x_{1}^{:\bbnum 1},x_{2}^{:\bbnum 1}.\,\quad\text{if }x_{1}=x_{2}\text{ then }(\tilde{t}^{A}(x_{1}),\tilde{t}^{B}(x_{2}))\in r^{\updownarrow Q}\quad,\nonumber \\
{\color{greenunder}\text{or equivalently}:}\quad & \forall(A,B).\,\forall r^{:A\leftrightarrow B}.\,(t^{A},t^{B})\in r^{\updownarrow Q}\quad.\label{eq:relational-naturality-law-simplified}
\end{align}
Even in that case, to save time, we will keep using Eq.~(\ref{eq:relational-naturality-law-1})
and writing $t=\tilde{t}(x)$.

When an expression contains more than one free variable, we can gather
all the free variables into a tuple. This creates an equivalent expression
with just one free variable:

\subsubsection{Statement \label{subsec:Statement--relational-naturality-tuple-1}\ref{subsec:Statement--relational-naturality-tuple-1} }

The relational naturality law for an expression $t:\forall A.\,Q^{A}$
containing two free variables $z_{1}^{:K^{A}}$ and $z_{2}^{:L^{A}}$
and the binding function $\tilde{t}(z_{1})(z_{2})=t$ is equivalent
to the relational naturality law for the expression $u$ with \emph{one}
free variable $h$ defined as:
\[
h^{:K^{A}\times L^{A}}\triangleq z_{1}\times z_{2}\quad,\quad\quad u\triangleq\tilde{u}(h)\triangleq\tilde{t}(h\triangleright\pi_{1})(h\triangleright\pi_{2})\quad.
\]


\subparagraph{Proof}

The relational naturality laws for $t$ and $u$ say that, for all
types $A$, $B$, and relations $r^{:A\leftrightarrow B}$:
\[
(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}\ogreaterthan r^{\updownarrow Q}\quad,\quad\quad(\tilde{u}^{A},\tilde{u}^{B})\in r^{\updownarrow(K\times L)}\ogreaterthan r^{\updownarrow Q}\quad.
\]
We need to show that these two relations are equivalent given the
definition of $\tilde{u}$ via $\tilde{t}$. This is similar to the
equivalence of curried and uncurried function types: $A\rightarrow(B\rightarrow C)\cong A\times B\rightarrow C$.
We write out the definition of the pair mapper operation ($\ogreaterthan$)
and obtain: 
\begin{align*}
(\tilde{t}^{A},\tilde{t}^{B})\in r^{\updownarrow K}\ogreaterthan r^{\updownarrow L}\ogreaterthan r^{\updownarrow Q}\quad\text{means}\quad: & \quad\forall x_{1}^{:K^{A}},x_{2}^{:L^{A}},y_{1}^{:K^{B}},y_{2}^{:L^{B}}:\,\text{ if }(x_{1},y_{1})\in r^{\updownarrow K}\text{ and }(x_{2},y_{2})\in r^{\updownarrow L}\\
 & \quad\quad\text{ then }(\tilde{t}(x_{1})(x_{2}),\tilde{t}(y_{1})(y_{2}))\in r^{\updownarrow Q}\quad;\\
(\tilde{u}^{A},\tilde{u}^{B})\in r^{\updownarrow(K\times L)}\ogreaterthan r^{\updownarrow Q}\quad\text{means}\quad: & \quad\forall h^{:K^{A}\times L^{A}},w^{:K^{B}\times L^{B}}:\,\text{ if }(h,w)\in r^{\updownarrow(K\times L)}\\
 & \quad\quad\text{ then }(\tilde{u}(h),\tilde{u}(w))\in r^{\updownarrow Q}\quad.
\end{align*}
By Definition~\ref{subsec:Definition-relational-lifting}(c) we have
$r^{\updownarrow(K\times L)}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}$,
and so we may write: 
\[
(h,w)\in r^{\updownarrow(K\times L)}\quad\text{ if }\quad h=x_{1}\times x_{2}\quad,\quad w=y_{1}\times y_{2}\quad,\quad(x_{1},x_{2})\in r^{\updownarrow K}\quad,\quad\text{ and }\quad(y_{1},y_{2})\in r^{\updownarrow L}\quad.
\]
When $h=x_{1}\times x_{2}$ and $w=y_{1}\times y_{2}$, we will have
$\tilde{u}(h)=\tilde{t}(x_{1},x_{2})$ and $\tilde{u}(w)=\tilde{t}(y_{1},y_{2})$.
It follows that the relational naturality laws for $t$ and $u$ are
equivalent. $\square$

Due to Statement~\ref{subsec:Statement--relational-naturality-tuple-1},
we are allowed to assume that the expression $t$ always has a \emph{single}
free variable. This simplifies the formulation of the main theorem:

\subsubsection{Statement \label{subsec:Statement-main-relational-parametricity-1}\ref{subsec:Statement-main-relational-parametricity-1}
(relational parametricity theorem)}

Let $H$ and $Q$ be any fully parametric type constructors. Any fully
parametric expression $t:\forall A.\,Q^{A}$ of the form $t=\forall A.\,\tilde{t}^{A}(h)$
containing a single free variable $h^{:H^{A}}$ satisfies the relational
naturality law~(\ref{eq:relational-naturality-law-1}).

\subparagraph{Proof }

By assumption, $t$ is built up from the nine constructions of Table~\ref{tab:nine-pure-code-constructions}.
So, one of these nine constructions is at the top level in the syntax
tree of $t$. For each of those constructions, we will prove that
$t$ satisfies Eq.~(\ref{eq:relational-naturality-law-1}) as long
as all its sub-expressions do. Throughout the proof, all relational
naturality laws will involve an arbitrary relation $r^{:A\leftrightarrow B}$
between arbitrary types $A$, $B$. For brevity, we will not write
the quantifiers $\forall A,B,r^{:A\leftrightarrow B}$ in front of
all formulas.

To shorten the proof further, we note that in every inductive case
the expression $t$ and all its sub-expressions will contain the same
free variable $h$. So, all relational naturality laws will follow
the pattern \textsf{``}for all $h_{1}^{:H^{A}}$ and $h_{2}^{:H^{B}}$ satisfying
the relation $(h_{1},h_{2})\in r^{\updownarrow H}$, some other values
are in some other relation\textsf{''}. Let us choose arbitrary but fixed values
$h_{1}^{:H^{A}}$ and $h_{2}^{:H^{B}}$ satisfying $(h_{1},h_{2})\in r^{\updownarrow H}$,
denote $t_{1}\triangleq\tilde{t}^{A}(h_{1})$ and $t_{2}\triangleq\tilde{t}^{B}(h_{2})$,
and simplify the naturality law~(\ref{eq:relational-naturality-law-1})
to:
\begin{equation}
(t_{1},t_{2})\in r^{\updownarrow Q}\quad\text{where}\quad t_{1}\triangleq\tilde{t}^{A}(h_{1})\text{ and }t_{2}\triangleq\tilde{t}^{B}(h_{2})\quad.\label{eq:relational-naturality-law-with-fixed-h}
\end{equation}
We will now prove this form of the law. Inductive assumptions will
always begin with \textsf{``}for all $h_{1}$ and $h_{2}$ ...\textsf{''}, so we are
allowed to substitute the fixed values $h_{1}$, $h_{2}$ into each
of the inductive assumptions and write those assumptions also in the
form of Eq.~(\ref{eq:relational-naturality-law-with-fixed-h}).

\paragraph{Use unit value}

In this case, $t\triangleq1$ and has the unit type ($Q^{A}\triangleq\bbnum 1$).
Since $t$ contains no free variables, the law~(\ref{eq:relational-naturality-law-with-fixed-h})
becomes:
\[
(1,1)\in r^{\updownarrow Q}\quad.
\]
This holds because by Definition~\ref{subsec:Definition-relational-lifting}(a)
we have $r^{\updownarrow Q}=\text{id}$ regardless of $r$.

The same proof applies for $t\triangleq c$ where $c^{:C}$ is a fixed
value of a fixed type $C$.

\paragraph{Use argument}

In this case, $t\triangleq h$ where $h^{:H^{A}}$ is the free variable
(say, the argument of the function whose body is $t$). So, we must
have $Q=H$ and $\tilde{t}=\forall A.\,\text{id}^{:H^{A}\rightarrow H^{A}}$.
The law~(\ref{eq:relational-naturality-law-with-fixed-h}) then becomes:
\begin{align*}
 & (t_{1},t_{2})\in r^{\updownarrow H}\quad\text{where}\quad t_{1}\triangleq h_{1}\text{ and }t_{2}\triangleq h_{2}\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & (h_{1},h_{2})\in r^{\updownarrow H}\quad.
\end{align*}
The last condition holds trivially, since $(h_{1},h_{2})\in r^{\updownarrow H}$
is already assumed.

\paragraph{Create function}

In this case, $t\triangleq\forall A.\,p^{:P^{A}}\rightarrow\tilde{g}^{A}(h)(p)$
where the sub-expression $\tilde{g}^{A}(h)(p):G^{A}$ contains two
free variables ($h^{:H^{A}}$ and $p^{:P^{A}}$). Because $\tilde{g}(h)(p)$
is defined with curried arguments, the binding function $\tilde{t}$
satisfies:
\[
\tilde{t}(h)=t=p\rightarrow\tilde{g}(h)(p)=\tilde{g}(h)\quad,\quad\quad\text{or equivalently}:\quad\tilde{t}=\tilde{g}.
\]
The type of $\tilde{g}$ is $H^{A}\rightarrow Q^{A}$, where we set
$Q^{A}\triangleq P^{A}\rightarrow G^{A}$. Definition~\ref{subsec:Definition-relational-lifting}(e)
gives $r^{\updownarrow Q}=r^{\updownarrow P}\ogreaterthan r^{\updownarrow G}$.
So, the inductive assumption for $g$ may be written as:
\[
(g_{1},g_{2})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow G}\quad\text{where}\quad g_{1}\triangleq\tilde{g}^{A}(h_{1})=t_{1}\text{ and }g_{2}\triangleq\tilde{g}^{B}(h_{2})=t_{2}\quad.
\]
This is equivalent to:
\[
(t_{1},t_{2})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow G}=r^{\updownarrow Q}\quad,
\]
which is the law~(\ref{eq:relational-naturality-law-with-fixed-h})
we needed to prove.

\paragraph{Use function}

In this case, $t=\tilde{t}(h)\triangleq k(p)$ where $k^{:\forall A.\,P^{A}\rightarrow Q^{A}}$
and $p^{:\forall A.\,P^{A}}$ are some sub-expressions. Both $k$
and $p$ may contain $h^{:H^{A}}$ as a free variable: $k\triangleq\tilde{k}(h)$
and $p\triangleq\tilde{p}(h)$. Denote for brevity $K^{A}\triangleq P^{A}\rightarrow Q^{A}$.
The inductive assumptions say that the laws~(\ref{eq:relational-naturality-law-with-fixed-h})
already hold for both $k$ and $p$:
\begin{align*}
{\color{greenunder}\text{for }k:}\quad & (k_{1},k_{2})\in r^{\updownarrow K}=r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}\quad\quad\text{where}\quad k_{1}\triangleq\tilde{k}^{A}(h_{1})\text{ and }k_{2}\triangleq\tilde{k}^{B}(h_{2})\quad,\\
{\color{greenunder}\text{for }p:}\quad & (p_{1},p_{2})\in r^{\updownarrow P}\quad\quad\text{where}\quad p_{1}\triangleq\tilde{p}^{A}(h_{1})\text{ and }p_{2}\triangleq\tilde{p}^{B}(h_{2})\quad.
\end{align*}
We need to show that:
\[
(t_{1},t_{2})\in r^{\updownarrow Q}\quad\quad\text{where}\quad t_{1}\triangleq\tilde{t}^{A}(h_{1})=k_{1}(p_{1})\text{ and }t_{2}\triangleq\tilde{t}^{B}(h_{2})=k_{2}(p_{2})\quad.
\]
By definition of $\ogreaterthan$, the inductive assumption $(k_{1},k_{2})\in r^{\updownarrow P}\ogreaterthan r^{\updownarrow Q}$
means:
\[
(k_{1}(p_{1}),k_{2}(p_{2}))\in r^{\updownarrow Q}\quad\text{whenever}\quad(p_{1},p_{2})\in r^{\updownarrow P}\quad.
\]
Since $(p_{1},p_{2})\in r^{\updownarrow P}$ already holds by the
other inductive assumption, we obtain $(t_{1},t_{2})\in r^{\updownarrow Q}$.

\paragraph{Create tuple}

In this case, $t=\tilde{t}(h)\triangleq k^{:K^{A}}\times l^{:L^{A}}$,
where the sub-expressions $k$ and $l$ contain the free variable
$h^{:H^{A}}$ via $k\triangleq\tilde{k}(h)$ and $l\triangleq\tilde{l}(h)$.
We have $Q^{A}\triangleq K^{A}\times L^{A}$, so we use Definition~\ref{subsec:Definition-relational-lifting}(c)
for the lifting $r^{\updownarrow Q}$ to get $r^{\updownarrow Q}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}$.
We need to prove that:
\begin{align*}
 & (t_{1},t_{2})\in r^{\updownarrow Q}\quad\text{or equivalently}:\quad(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow K}\boxtimes r^{\updownarrow L}\quad,\\
 & \quad\text{where}\quad t_{1}\triangleq k_{1}\times l_{1}\triangleq\tilde{k}^{A}(h_{1})\times\tilde{l}^{A}(h_{1})\quad,\quad\quad t_{2}\triangleq k_{2}\times l_{2}\triangleq\tilde{k}^{A}(h_{2})\times\tilde{l}^{A}(h_{2})\quad.
\end{align*}
The inductive assumptions are that the relational naturality law~(\ref{eq:relational-naturality-law-with-fixed-h})
holds for $k$ and $l$:
\[
(k_{1},k_{2})\in r^{\updownarrow K}\quad,\quad\quad(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\]
By definition of $\boxtimes$ for relations, we obtain the required
property: $(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow K}\boxtimes r^{\updownarrow L}$.

\paragraph{Use tuple}

It is sufficient to consider the case $t\triangleq\pi_{1}(g)$ where
$g^{:\forall A.\,Q^{A}\times L^{A}}$ is a sub-expression that contains
the free variable $h^{:H^{A}}$. The proof for $t=\pi_{2}(g)$ is
analogous. 

We need to prove that $t$ satisfies the relational naturality law
if $g$ does. Define $g=\tilde{g}(h)$ and:
\[
g_{1}\triangleq\tilde{g}^{A}(h_{1})\quad,\quad\quad g_{2}\triangleq\tilde{g}^{B}(h_{2})\quad,\quad\quad t_{1}\triangleq\pi_{1}(g_{1})\quad,\quad\quad t_{2}\triangleq\pi_{1}(g_{2})\quad.
\]

The relational naturality law of $g$, which holds by the inductive
assumption, is:
\[
(g_{1},g_{2})\in r^{\updownarrow(Q\times L)}\quad.
\]
By Definition~\ref{subsec:Definition-relational-lifting}(c) for
the lifting $r^{\updownarrow(Q\times L)}$, we have:
\[
(g_{1},g_{2})\in r^{\updownarrow(Q\times L)}\quad\text{ means }\quad(\pi_{1}(g_{1}),\pi_{1}(g_{2}))\in r^{\updownarrow Q}\text{ and }(\pi_{2}(g_{1}),\pi_{2}(g_{2}))\in r^{\updownarrow L}\quad.
\]
The condition $(\pi_{1}(g_{1}),\pi_{1}(g_{2}))\in r^{\updownarrow Q}$
is the same as the relational naturality law of $t$.

\paragraph{Create disjunction}

We consider the case $t\triangleq g+\bbnum 0$ where $Q^{A}\triangleq K^{A}+L^{A}$
and $g^{:\forall A.\,K^{A}}$ is a sub-expression that contains the
free variable $h^{:H^{A}}$ via $g\triangleq\tilde{g}(h)$. Define
for convenience: 
\[
g_{1}\triangleq\tilde{g}^{A}(h_{1})\quad,\quad\quad g_{2}\triangleq\tilde{g}^{B}(h_{2})\quad,\quad\quad t_{1}=g_{1}+\bbnum 0\quad,\quad\quad t_{2}=g_{2}+\bbnum 0\quad.
\]
The inductive assumption is that $g(h)$ satisfies its relational
naturality law, which is $(g_{1},g_{2})\in r^{\updownarrow K}$. By
Definition~\ref{subsec:Definition-relational-lifting}(d) for the
lifting $r^{\updownarrow(K+L)}$, we have:
\[
(t_{1},t_{2})=(g_{1}+\bbnum 0,g_{2}+\bbnum 0)\in r^{\updownarrow(K+L)}=r^{\updownarrow K}\boxplus r^{\updownarrow L}\text{ when }(g_{1},g_{2})\in r^{\updownarrow K}\quad.
\]
So, the relational naturality law of $t$ holds. The proof for $t\triangleq\bbnum 0+g$
is analogous.

\paragraph{Use disjunction}

In this case, $t\triangleq\forall A.\,\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p\\
L^{A} & q
\end{array}\,\,$ is a pattern-matching function of type $\forall A.\,Q^{A}$ with
$Q^{A}\triangleq K^{A}+L^{A}\rightarrow G^{A}$. The sub-expressions
$p^{:\forall A.\,K^{A}\rightarrow G^{A}}$ and $q^{:\forall A.\,L^{A}\rightarrow G^{A}}$
contain the free variable $h^{:H^{A}}$. We define:
\[
p\triangleq\tilde{p}(h)\quad,\quad p_{1}\triangleq\tilde{p}^{A}(h_{1})\quad,\quad p_{2}\triangleq\tilde{p}^{B}(h_{2})\quad,\quad\quad q\triangleq\tilde{q}(h)\quad,\quad q_{1}\triangleq\tilde{q}^{A}(h_{1})\quad,\quad q_{2}\triangleq\tilde{q}^{B}(h_{2})\quad.
\]
Then we have:
\[
t_{1}=\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p_{1}\\
L^{A} & q_{1}
\end{array}\quad,\quad\quad t_{2}=\,\begin{array}{|c||c|}
 & G^{B}\\
\hline K^{B} & p_{2}\\
L^{B} & q_{2}
\end{array}\quad.
\]
By the inductive assumption, the relational naturality law already
holds for $p$ and $q$:
\begin{align*}
 & \text{if }(k_{1}^{:K^{A}},k_{2}^{:K^{B}})\in r^{\updownarrow K}\text{ then }\big(p_{1}(k_{1}),p_{2}(k_{2})\big)\in r^{\updownarrow G}\quad,\\
 & \text{if }(l_{1}^{:L^{A}},l_{2}^{:L^{B}})\in r^{\updownarrow L}\text{ then }\big(q_{1}(l_{1}),q_{2}(l_{2})\big)\in r^{\updownarrow G}\quad.
\end{align*}
To derive the specific form of the law for $t$, we use Definition~\ref{subsec:Definition-relational-lifting}(e)
for the lifting $r^{\updownarrow Q}$:
\[
\text{if }(x_{1}^{:K^{A}+L^{A}},x_{2}^{:K^{B}+L^{B}})\in r^{\updownarrow(K+L)}\text{ then }\big(t_{1}(x_{1}),t_{2}(x_{2})\big)\in r^{\updownarrow G}\quad.
\]
By Definition~\ref{subsec:Definition-relational-lifting}(d), the
values $x_{1}$ and $x_{2}$ are in relation $r^{\updownarrow(K+L)}$
only if both $x_{1}$ and $x_{2}$ are in the same part of the disjunction
($K^{\bullet}+L^{\bullet}$). We consider separately the case when
they are in the left part or in the right part.

If both $x_{1}$ and $x_{2}$ in the left part, we can write $x_{1}=k_{1}^{:K^{A}}+\bbnum 0$
and $x_{2}=k_{2}^{:K^{B}}+\bbnum 0$ with some $k_{1}$ and $k_{2}$.
Then the condition $(x_{1},x_{2})\in r^{\updownarrow(K+L)}$ is equivalent
to $(k_{1},k_{2})\in r^{\updownarrow K}$, while the values $t_{1}(x_{1})$
and $t_{2}(x_{2})$ are expressed as:
\[
t_{1}(x_{1})=(k_{1}+\bbnum 0)\triangleright\,\begin{array}{|c||c|}
 & G^{A}\\
\hline K^{A} & p_{1}\\
L^{A} & q_{1}
\end{array}\,=p_{1}(k_{1})\quad,\quad\quad t_{2}(x_{2})=(k_{2}+\bbnum 0)\triangleright\,\begin{array}{|c||c|}
 & G^{B}\\
\hline K^{B} & p_{2}\\
L^{B} & q_{2}
\end{array}\,=p_{2}(k_{2})\quad.
\]
So, the conclusion of the relational naturality law of $t$ holds
due to the relational law of $p$:
\[
\big(t_{1}(x_{1}),t_{2}(x_{2})\big)=\big(p_{1}(k_{1}),p_{2}(k_{2})\big)\in r^{\updownarrow G}\quad.
\]

A similar argument proves the law for the case when both $x_{1}$
and $x_{2}$ in the right part. We write $x_{1}=\bbnum 0+l_{1}^{:L^{A}}$
and $x_{2}=\bbnum 0+l_{2}^{:L^{B}}$ and reduce the relational naturality
law of $t$ to that of $q$.

\paragraph{Recursive call}

In this case, $t\triangleq g$ where $g$ is a recursive call to a
function (defined outside that expression). When proving a law of
a recursively defined function, we may assume that the law holds for
recursive calls to that function. So, the inductive assumption says
that $g$ is some expression for which the relational naturality law
already holds. It then holds for $t$ since $t=g$.

This completes the proof of the relational parametricity theorem.
$\square$ 

The relational formulation of parametricity is powerful but hard to
use for deriving laws as equations rather than as relations. To convert
the relational parametricity law such as Eq.~(\ref{eq:relational-naturality-law-simplified})
into an equation with functions, we first choose the relation $r$
as $r\triangleq\left<f\right>$ with a suitable function $f$. Then
we need to express the lifted relation $r^{\updownarrow Q}$ via an
equation and derive the corresponding equation for $t$. However,
Example~\ref{subsec:Example-relational-lifting}(e) shows that for
sufficiently complicated type constructors $Q$ the lifted relation
$\left<f\right>^{\updownarrow Q}$ will \emph{not} be expressible
as an equation. 

Nevertheless, this problem does not arise for most type signatures
found in practice, and the relational naturality law can be reduced
to the dinaturality law~(\ref{eq:dinaturality-law-for-profunctors})
via the wedge law~(\ref{eq:wedge-law-for-profunctors}). In a few
cases, a more powerful property called the \textsf{``}strong\textsf{''} dinaturality
law is required. In this book, strong dinaturality is only used to
prove Statements~\ref{subsec:relational-property-for-foldFn}, \ref{subsec:Statement-Church-encoding-recursive-type-covariant},
and~\ref{subsec:Statement-strong-dinaturality-property-of-fix},
while in all other places the wedge law is sufficient. The following
sections will prove that the wedge law and the strong dinaturality
law are consequences of the relational parametricity theorem.

\subsection{Deriving the wedge law from relational parametricity}

This section derives the wedge law from the relational naturality
law of \lstinline!xmap!.\footnote{The proof is based on the blog post by B.~Milewski\index{Bartosz Milewski}
(\texttt{\href{https://bartoszmilewski.com/2017/04/11/}{https://bartoszmilewski.com/2017/04/11/}}).
Another derivation of the dinaturality law from the relational parametricity
theorem was given by J.~Voigtl\"ander\index{Janis@Janis Voigtl\"ander}
in the paper \texttt{\href{https://arxiv.org/pdf/1908.07776.pdf}{https://arxiv.org/pdf/1908.07776.pdf}}.
A proof of the dinaturality law based on obtaining the syntactic normal
form of dinatural transformations (and \emph{without} using relational
parametricity) was shown by J.~de Lataillade\index{Joachim de Lataillade}
in the paper \textsf{``}Dinatural terms in System $F$\textsf{''}: see \texttt{\href{https://www.irif.fr/~delatail/dinat.pdf}{https://www.irif.fr/$\sim$delatail/dinat.pdf}}}  

\subsubsection{Statement \label{subsec:Statement-wedge-law-from-parametricity}\ref{subsec:Statement-wedge-law-from-parametricity}}

\textbf{(a)} For any fully parametric profunctor $P^{X,Y}$, define
$T^{A}\triangleq P^{A,A}$. Then:
\[
\text{for all }X,Y,f^{:X\rightarrow Y},x^{:P^{X,X}},y^{:P^{Y,Y}}\quad:\quad\text{if}\quad(x,y)\in\left<f\right>^{\updownarrow T}\quad\text{then}\quad x\triangleright f^{\uparrow P^{X,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,Y}}\quad.
\]
In other words, the $\left(P,f\right)$-wedge relation is a consequence
of the lifted relation $\left<f\right>$.

\textbf{(b)} Any fully parametric value $t$ of type $\forall A.\,P^{A,A}$
satisfies the wedge law\index{wedge law!of profunctors}~(\ref{eq:wedge-law-for-profunctors}):
\[
\text{for all }X,Y,f^{:X\rightarrow Y}\quad:\quad t^{X}\triangleright f^{\uparrow P^{X,\bullet}}=t^{Y}\triangleright f^{\downarrow P^{\bullet,Y}}\quad.
\]
In other words, $t^{X}$ and $t^{Y}$ are always in the $(P,f)$-wedge
relation\index{wedge relation} for any function $f^{:X\rightarrow Y}$.

\subparagraph{Proof}

\textbf{(a)} All profunctors $P$ have a \lstinline!xmap! method
with the type signature:
\[
\text{xmap}_{P}:\forall A,B,C,D.\,\left(B\rightarrow A\right)\rightarrow\left(C\rightarrow D\right)\rightarrow P^{A,C}\rightarrow P^{B,D}\quad.
\]
Since $P^{X,Y}$ is a fully parametric profunctor, its \lstinline!xmap!
satisfies the commutativity law (Section~\ref{subsec:Proof-of-the-profunctor-commutativity-law}):
\[
\text{xmap}_{P}(f^{:B\rightarrow A})(g^{:C\rightarrow D})=f^{\downarrow P^{\bullet,C}}\bef g^{\uparrow P^{A,\bullet}}=g^{\uparrow P^{B,\bullet}}\bef f^{\downarrow P^{\bullet,D}}\quad.
\]
Then the property we need to prove can be written in terms of \lstinline!xmap!
as:
\begin{equation}
\text{if}\quad(x,y)\in\left<f\right>^{\updownarrow T}\quad\text{then}\quad\text{xmap}_{P}(\text{id})(f)(x)=\text{xmap}_{P}(f)(\text{id})(y)\quad.\label{eq:wedge-law-from-parametricity-derivation1}
\end{equation}
Statement~\ref{subsec:Statement-main-relational-parametricity-1}
shows that \lstinline!xmap! also satisfies a relational naturality
law. Since \lstinline!xmap! has four type parameters ($A$, $B$,
$C$, $D$), its relational naturality law involves 8 arbitrary types
(denote them by $A$, $B$, $C$, $D$, $A^{\prime}$, $B^{\prime}$,
$C^{\prime}$, $D^{\prime}$) and 4 arbitrary relations (denote them
by $a^{:A\leftrightarrow A^{\prime}}$, $b^{:B\leftrightarrow B^{\prime}}$,
$c^{:C\leftrightarrow C^{\prime}}$, and $d^{:D\leftrightarrow D^{\prime}}$).
With these notations, we write the relational naturality law of \lstinline!xmap!
as:
\begin{equation}
\forall(a,b,c,d)\quad:\quad(\text{xmap}_{P}^{A,B,C,D},\text{xmap}_{P}^{A^{\prime},B^{\prime},C^{\prime},D^{\prime}})\in(b\ogreaterthan a)\ogreaterthan(c\ogreaterthan d)\ogreaterthan(a,c)^{\updownarrow P}\ogreaterthan(b,d)^{\updownarrow P}\quad,\label{eq:relational-naturality-law-of-xmap}
\end{equation}
where $(a,c)^{\updownarrow P}$ and $(b,d)^{\updownarrow P}$ are
simultaneous liftings to the profunctor $P$ (see Definition~\ref{subsec:Definition-simultaneous-relational-lifting}).
Writing out the definition of the pair mapper ($\ogreaterthan$),
we express this law as:
\begin{align}
 & \forall\big(a^{:A\leftrightarrow A^{\prime}},b^{:B\leftrightarrow B^{\prime}},c^{:C\leftrightarrow C^{\prime}},d^{:D\leftrightarrow D^{\prime}},g^{:B\rightarrow A},h^{:B^{\prime}\rightarrow A^{\prime}},k^{:C\rightarrow D},l^{:C^{\prime}\rightarrow D^{\prime}},x^{:P^{A,C}},y^{:P^{A^{\prime},C^{\prime}}}\big)\quad:\nonumber \\
 & \quad\text{if}\quad\quad(g,h)\in b\ogreaterthan a\quad,\quad(k,l)\in c\ogreaterthan d\quad,\quad\text{and}\quad(x,y)\in(a,c)^{\updownarrow P}\quad,\nonumber \\
 & \quad\text{then}\quad\quad\big(\text{xmap}_{P}(g)(k)(x),\,\text{xmap}_{P}(h)(l)(y)\big)\in(b,d)^{\updownarrow P}\quad.\label{eq:xmap-relational-law-derivation2}
\end{align}
The naturality law of \lstinline!xmap! now has the form of a condition
that holds for arbitrary choices of 8 types, 4 relations, and 4 functions,
in addition to the values $x$ and $y$. The plan of the proof is
to substitute certain carefully chosen functions and relations into
Eq.~(\ref{eq:xmap-relational-law-derivation2}) in order to derive
Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1}). 

We note that Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1})
says that two \lstinline!xmap(...)! values must be equal (both values
having type $P^{X,Y}$). This can be obtained from Eq.~(\ref{eq:xmap-relational-law-derivation2})
only if the relation $(b,d)^{\updownarrow P}$ is an identity relation
of type $P^{X,Y}\leftrightarrow P^{X,Y}$. We will prove in Statement~\ref{subsec:Statement-relational-lifting-identity-law}
below that a simultaneous lifting of two identity relations gives
again an identity relation. This suggests choosing $b=\text{id}$
and $d=\text{id}$, which also requires us to set the types as $B=B^{\prime}=X$
and $D=D^{\prime}=Y$.

The relations $a$ and $c$ need to be chosen such that the precondition
$(x,y)\in(a,c)^{\updownarrow P}$ in Eq.~(\ref{eq:xmap-relational-law-derivation2})
reproduces the precondition $(x,y)\in\left<f\right>^{\updownarrow T}$
in Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1}). Statement~\ref{subsec:Statement-relational-lifting-consistency-PAA}
shows that $r^{\updownarrow T}=(r,r)^{\updownarrow P}$ for any relation
$r$. In particular, $\left<f\right>^{\updownarrow T}=(\left<f\right>,\left<f\right>)^{\updownarrow P}$.
So, we need to set $a=c=\left<f\right>$ and the corresponding types
$A=C=X$ and $A^{\prime}=C^{\prime}=Y$.

The functions $g$, $h$, $k$, and $l$ in Eq.~(\ref{eq:xmap-relational-law-derivation2})
are chosen such that:
\[
\text{xmap}_{P}(g)(k)(x)=\text{xmap}_{P}(\text{id})(f)(x)\quad,\quad\quad\text{xmap}_{P}(h)(l)(x)=\text{xmap}_{P}(f)(\text{id})(x)\quad.
\]
This implies $g=\text{id}$, $h=k=f$, and $l=\text{id}$. With these
choices, the preconditions $(g,h)\in b\ogreaterthan a$ and $(k,l)\in c\ogreaterthan d$
will automatically hold in Eq.~(\ref{eq:xmap-relational-law-derivation2}).
So, the conclusion of Eq.~(\ref{eq:xmap-relational-law-derivation2})
also holds, which proves Eq.~(\ref{eq:wedge-law-from-parametricity-derivation1}). 

\textbf{(b)} The relational parametricity theorem (Statement~\ref{subsec:Statement-main-relational-parametricity-1})
gives $(t^{X},t^{Y})\in c^{\updownarrow T}$ for any relation $c^{:X\leftrightarrow Y}$.
We can now choose $c\triangleq\left<f\right>$ and use the result
of part \textbf{(a)} where we set $x\triangleq t^{X}$ and $y\triangleq t^{Y}$.
Then we obtain $t^{X}\triangleright f^{\uparrow P^{X,\bullet}}=t^{Y}\triangleright f^{\downarrow P^{\bullet,Y}}$,
which is the wedge law of $t$. $\square$

While proving Statement~\ref{subsec:Statement-wedge-law-from-parametricity},
we used the \textbf{identity laws}\index{identity laws!of relational lifting}
of the relational lifting:

\subsubsection{Statement \label{subsec:Statement-relational-lifting-identity-law}\ref{subsec:Statement-relational-lifting-identity-law}}

\textbf{(a)} An identity relation can be removed from a simultaneous
lifting. For instance, given any type constructor $H^{\bullet,\bullet}$,
a fixed type $T$, and any relation $r^{:A\leftrightarrow B}$, we
have: 
\[
(r,\text{id}^{:T\leftrightarrow T})^{\updownarrow H}=r^{\updownarrow G}\quad,\quad\quad\text{where we defined}:\quad G^{A}\triangleq H^{A,T}\quad.
\]

\textbf{(b)} Lifting one or more identity relations produces again
an identity relation: 
\[
\text{for any }G^{\bullet},H^{\bullet,\bullet},\text{etc}.:\quad(\text{id}^{:A\leftrightarrow A})^{\updownarrow G}=\text{id}^{:G^{A}\leftrightarrow G^{A}}\quad,\quad\quad(\text{id}^{:A\leftrightarrow A},\text{id}^{:X\leftrightarrow X})^{\updownarrow H}=\text{id}^{:H^{A,X}\leftrightarrow H^{A,X}}\quad,\quad\text{etc}.
\]


\subparagraph{Proof}

\textbf{(a)} Enumerate all cases of Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
for $H^{\bullet,\bullet}$.

If $H^{A,X}\triangleq Z$ with a fixed type $Z$, we have also $G^{A}=Z$.
Then $(r,s)^{\updownarrow H}\triangleq\text{id}^{:Z\leftrightarrow Z}$
and $r^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}$ for any
relations $r$, $s$. So, $(r,\text{id})^{\updownarrow H}=r^{\updownarrow G}$.

If $H^{A,X}\triangleq A$, we have $G^{A}=A$. Then $(r,s)^{\updownarrow H}\triangleq r$
and $r^{\updownarrow G}=r$ for any relation $r$, so we obtain $(r,\text{id})^{\updownarrow H}=r^{\updownarrow G}$.

The next three similar cases use the inductive assumptions $(r,\text{id})^{\updownarrow K}=r^{\updownarrow K^{\bullet,T}}$
and $(r,\text{id})^{\updownarrow L}=r^{\updownarrow L^{\bullet,T}}$:
\begin{align*}
{\color{greenunder}\text{if }H^{A,X}\triangleq K^{A,X}\times L^{A,X}:}\quad & (r,\text{id})^{\updownarrow H}=(r,\text{id})^{\updownarrow K}\boxtimes(r,\text{id})^{\updownarrow L}=r^{\updownarrow K^{\bullet,T}}\boxtimes r^{\updownarrow L^{\bullet,T}}=r^{\updownarrow(K^{\bullet,T}\times L^{\bullet,T})}=r^{\updownarrow G}\quad;\\
{\color{greenunder}\text{if }H^{A,X}\triangleq K^{A,X}+L^{A,X}:}\quad & (r,\text{id})^{\updownarrow H}=(r,\text{id})^{\updownarrow K}\boxplus(r,\text{id})^{\updownarrow L}=r^{\updownarrow K^{\bullet,T}}\boxplus r^{\updownarrow L^{\bullet,T}}=r^{\updownarrow(K^{\bullet,T}+L^{\bullet,T})}=r^{\updownarrow G}\quad;\\
{\color{greenunder}\text{if }H^{A,X}\triangleq K^{A,X}\rightarrow L^{A,X}:}\quad & (r,\text{id})^{\updownarrow H}=(r,\text{id})^{\updownarrow K}\ogreaterthan(r,\text{id})^{\updownarrow L}=r^{\updownarrow K^{\bullet,T}}\ogreaterthan r^{\updownarrow L^{\bullet,T}}=r^{\updownarrow(K^{\bullet,T}\rightarrow L^{\bullet,T})}=r^{\updownarrow G}\quad.
\end{align*}

If $H^{A,X}\triangleq S^{A,X,H^{A,X}}$ with a recursion scheme $S^{\bullet,\bullet,\bullet}$,
the type constructor $G^{\bullet}$ is defined by: 
\[
G^{A}\triangleq H^{A,T}=S^{A,T,H^{A,T}}=S^{A,T,G^{A}}\quad.
\]
So, the lifting to $G$ is given by $r^{\updownarrow G}=\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{\bullet,T,\bullet}}$.
Write the definition of lifting to $H$ and simplify:
\begin{align*}
 & (r,\text{id})^{\updownarrow H}=\big(r,\text{id},\overline{(r,\text{id})^{\updownarrow H}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\overline{(r,\text{id})^{\updownarrow H}}=\overline{r^{\updownarrow G}}:}\quad & =\big(r,\gunderline{\text{id}},\overline{r^{\updownarrow G}}\big)^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption about lifting id to }S^{\bullet,\bullet,\bullet}:}\quad & =\big(r,\overline{r^{\updownarrow G}}\big)^{\updownarrow S^{\bullet,T,\bullet}}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =r^{\updownarrow G}\quad.
\end{align*}

If $H^{A,X}\triangleq\forall Z.\,S^{Z,A,X}$, the type constructor
$G^{\bullet}$ is $G^{A}=\forall Z.\,S^{Z,A,T}$. The lifting $(r,\text{id})^{\updownarrow H}$
is a relation of type $\forall U.\,S^{U,A,X}\leftrightarrow\forall V.\,S^{V,A,X}$
written as:
\begin{align*}
 & \forall(U,V):\quad\big((r,\text{id})^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}\big)^{U,V}=\forall w^{:U\leftrightarrow V}.\,(w,r,\gunderline{\text{id}})^{\updownarrow S^{\bullet,\bullet,\bullet}}\\
{\color{greenunder}\text{omitting id from lifting to }S:}\quad & =\forall w^{:U\leftrightarrow V}.\,(w,r)^{\updownarrow S^{\bullet,\bullet,T}}\\
{\color{greenunder}\text{definition of lifting to }G:}\quad & =(r^{\updownarrow G})^{U,V}\quad.
\end{align*}
Here we used the inductive assumption that identity relations may
be omitted from liftings to $S^{\bullet,\bullet,\bullet}$.

\textbf{(b)} Enumerate all cases of Definition~\ref{subsec:Definition-relational-lifting}
for $G^{\bullet}$ or Definition~\ref{subsec:Definition-simultaneous-relational-lifting}
for $H^{\bullet,\bullet}$. The proofs are similar, so we will only
prove that $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.

If $H^{A,X}\triangleq Z$ with a fixed type $Z$, we have $(r,s)^{\updownarrow H}\triangleq\text{id}^{:Z\leftrightarrow Z}$
for any relations $r$, $s$.

If $H^{A,X}\triangleq A$, we have $(r,s)^{\updownarrow H}\triangleq r$
for any relation $r$, so we obtain $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.
Similarly if $H^{A,X}\triangleq X$ then we obtain $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.

The next three similar cases use the inductive assumptions $(\text{id},\text{id})^{\updownarrow K}=\text{id}$
and $(\text{id},\text{id})^{\updownarrow L}=\text{id}$:
\begin{align*}
{\color{greenunder}\text{if }H^{\bullet,\bullet}\triangleq K^{\bullet,\bullet}\times L^{\bullet,\bullet}:}\quad & (\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id})^{\updownarrow K}\boxtimes(\text{id},\text{id})^{\updownarrow L}=\text{id}\boxtimes\text{id}\quad;\\
{\color{greenunder}\text{if }H^{\bullet,\bullet}\triangleq K^{\bullet,\bullet}+L^{\bullet,\bullet}:}\quad & (\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id})^{\updownarrow K}\boxplus(\text{id},\text{id})^{\updownarrow L}=\text{id}\boxplus\text{id}\quad;\\
{\color{greenunder}\text{if }H^{\bullet,\bullet}\triangleq K^{\bullet,\bullet}\rightarrow L^{\bullet,\bullet}:}\quad & (\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id})^{\updownarrow K}\ogreaterthan(\text{id},\text{id})^{\updownarrow L}=\text{id}\ogreaterthan\text{id}\quad.
\end{align*}
It follows from Example~\ref{subsec:Example-pair-product-pair-mapper-relation}
with $f=\text{id}$ and $g=\text{id}$ that 
\[
\text{id}\boxtimes\text{id}=\text{id}\quad,\quad\quad\text{id}\boxplus\text{id}=\text{id}\quad,\quad\quad\text{and}\quad\quad\text{id}\ogreaterthan\text{id}=\text{id}\quad.
\]
So, in all three cases we obtain: $(\text{id},\text{id})^{\updownarrow H}=\text{id}$.

If $H^{A,X}\triangleq S^{A,X,H^{A,X}}$ with a recursion scheme $S^{\bullet,\bullet,\bullet}$,
we have:
\[
(\text{id},\text{id})^{\updownarrow H}=\big(\text{id},\text{id},\overline{(\text{id},\text{id})^{\updownarrow H}}\big)^{\updownarrow S}=(\text{id},\text{id},\text{id})^{\updownarrow S}\quad,
\]
because by the inductive assumption the identity law holds for the
recursive call: $\overline{(\text{id},\text{id})^{\updownarrow H}}=\text{id}$.
Another inductive assumption is that the identity law holds for the
liftings to $S^{\bullet,\bullet,\bullet}$. So, we get: 
\[
(\text{id},\text{id})^{\updownarrow H}=(\text{id},\text{id},\text{id})^{\updownarrow S}=\text{id}\quad.
\]

If $H^{A,X}\triangleq\forall Z.\,S^{Z,A,X}$, the lifting $(\text{id},\text{id})^{\updownarrow H}$
is a relation of type $\forall U.\,S^{U,A,X}\leftrightarrow\forall V.\,S^{V,A,X}$
written as:
\[
\forall(U,V):\quad\big((\text{id},\text{id})^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}\big)^{U,V}=\forall w^{:U\leftrightarrow V}.\,(w,\text{id},\text{id})^{\updownarrow H^{\bullet,\bullet,\bullet}}\quad.
\]
As we showed in part \textbf{(a)}, any identity relation may be omitted
from the lifting:
\[
\forall w^{:U\leftrightarrow V}.\,(w,\gunderline{\text{id}^{:A\leftrightarrow A}},\gunderline{\text{id}^{:X\leftrightarrow X}})^{\updownarrow H^{\bullet,\bullet,\bullet}}=\forall w^{:U\leftrightarrow V}.\,w^{\updownarrow H^{\bullet,A,X}}\quad.
\]
By Statement~\ref{subsec:Statement-parametricity-gives-identity-relation}
used for $H^{\bullet,A,X}$ as a type constructor with one type parameter,
the relation $\forall w.\,w^{\updownarrow H^{\bullet,A,X}}$ is the
identity relation for the type $\forall Z.\,H^{Z,A,X}$. We find that
$(\text{id},\text{id})^{\updownarrow\forall Z.\,S^{Z,\bullet,\bullet}}=\text{id}$.
$\square$

\begin{comment}
commutativity law does not hold!
\end{comment}


\subsection{Strong dinaturality: definition and general properties\label{subsec:Strong-dinaturality.-General-properties}}

While the dinaturality law is often sufficient for proofs involving
parametricity, some of the more complicated cases require a stronger
property that we will study in the rest of this Appendix. As motivation,
we begin by looking at the wedge law~(\ref{eq:wedge-law-for-profunctors})
in more detail.

We have seen in Statement~\ref{subsec:Statement-wedge-law-from-parametricity}
that fully parametric values automatically satisfy the wedge law.
The proof showed that the $\left(P,f\right)$-wedge relation is a
consequence of the relation $(x,y)\in\left<f\right>^{\updownarrow T}$
where $T^{A}\triangleq P^{A,A}$. Note that the type diagrams for
the wedge law~(\ref{eq:wedge-law-for-profunctors}), the dinaturality
law~(\ref{eq:dinaturality-law-for-profunctors}), and the commutativity
law~(\ref{eq:profunctor-commutativity-law}), involve three relations
between values $x^{:P^{A,A}}$ and $y^{:P^{B,B}}$:
\begin{align*}
{\color{greenunder}\text{a }\left(P,f\right)\text{-wedge relation}:}\quad & x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad,\quad\text{or}:\quad(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad,\\
{\color{greenunder}\text{the left part of a dinaturality diagram}:}\quad & \exists z^{:P^{B,A}}\quad\text{such that}\quad x=z\triangleright f^{\downarrow P^{\bullet,A}}\text{ and }y=z\triangleright f^{\uparrow P^{B,\bullet}}\quad,\\
{\color{greenunder}\text{a relation }\left<f\right>\text{ lifted to }T:}\quad & (x,y)\in\left<f\right>^{\updownarrow T}\quad.
\end{align*}
To make the notation shorter, we define the \textbf{pushout} \textbf{relation}\index{pushout relation|textit}
denoted by $\text{push}\,(p,q)$:
\[
(x^{:A},y^{:B})\in\text{push}\,(p,q)\text{ means }\exists z^{:C}\text{ such that }x=p(z)\text{ and }y=q(z)\quad.
\]
Here $A$, $B$, $C$ are any types and $p^{:C\rightarrow A}$ and
$q^{:C\rightarrow A}$ are any given functions. The left fragment
of the dinaturality diagram is then written as $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$.

The pullback and pushout relations may be used to reformulate the
commutativity law~(\ref{eq:profunctor-commutativity-law}) as: 
\[
\text{for any }x^{:P^{A,A}},y^{:P^{B,B}}\quad:\quad\text{if}\quad(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad\text{then}\quad(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad.
\]
We find that the $\left(P,f\right)$-wedge relation, denoted by $\text{pull}\,(f^{\uparrow P},f^{\downarrow P})$
, is a consequence of both the lifted relation $\left<f\right>^{\updownarrow T}$
and of the relation $\text{push}\,(f^{\downarrow P},f^{\uparrow P})$,
which we may call the $\left(P,f\right)$-pushout relation.

The $\left(P,f\right)$-pushout relation is generally stronger than
the lifted relation $\left<f\right>^{\updownarrow T}$:

\subsubsection{Statement \label{subsec:Statement-profunctor-pushout-entails-lifted-f}\ref{subsec:Statement-profunctor-pushout-entails-lifted-f}}

We assume a fully parametric profunctor $P^{\bullet,\bullet}$, arbitrary
types $X$, $Y$, and arbitrary values $x^{:P^{X,X}}$, $y^{:P^{Y,Y}}$,
and $f^{:X\rightarrow Y}$. If $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$
then $(x,y)\in\left<f\right>^{\updownarrow T}$ where $T^{A}\triangleq P^{A,A}$.

\subparagraph{Proof}

The relation $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$
means that there exists $z^{:P^{Y,X}}$ such that $x=z\triangleright f^{\downarrow P}$
and $y=z\triangleright f^{\uparrow P}$. Rewrite the expressions for
$x$ and $y$ using the \lstinline!xmap! method of $P$:
\[
x=\text{xmap}_{P}(f)(\text{id})(z)\quad,\quad\quad y=\text{xmap}_{P}(\text{id})(f)(z)\quad.
\]
We need to show that $(x,y)\in\left<f\right>^{\updownarrow T}$, which
we can write in terms of \lstinline!xmap! like this:
\begin{equation}
\forall z^{:P^{Y,X}}:\quad\big(\text{xmap}_{P}(f)(\text{id})(z),\,\text{xmap}_{P}(\text{id})(f)(z)\big)\in\left<f\right>^{\updownarrow T}\quad.\label{eq:pushout-relation-entails-lifted-derivation1}
\end{equation}
This equation is similar to the relational naturality law~(\ref{eq:relational-naturality-law-of-xmap})
of \lstinline!xmap! that was used in the proof of Statement~\ref{subsec:Statement-wedge-law-from-parametricity}:
\[
\forall(a,b,c,d)\quad:\quad(\text{xmap}_{P}^{A,B,C,D},\text{xmap}_{P}^{A^{\prime},B^{\prime},C^{\prime},D^{\prime}})\in(b\ogreaterthan a)\ogreaterthan(c\ogreaterthan d)\ogreaterthan(a,c)^{\updownarrow P}\ogreaterthan(b,d)^{\updownarrow P}\quad.
\]
As we did the proof of that statement, we will now choose specific
types and relations in this law in order to derive Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1}).
We begin by writing out the definition of $\ogreaterthan$:
\begin{align}
 & \forall\big(a^{:A\leftrightarrow A^{\prime}},b^{:B\leftrightarrow B^{\prime}},c^{:C\leftrightarrow C^{\prime}},d^{:D\leftrightarrow D^{\prime}},g^{:B\rightarrow A},h^{:B^{\prime}\rightarrow A^{\prime}},k^{:C\rightarrow D},l^{:C^{\prime}\rightarrow D^{\prime}},x^{:P^{A,C}},y^{:P^{A^{\prime},C^{\prime}}}\big)\quad:\nonumber \\
 & \quad\text{if}\quad\quad(g,h)\in b\ogreaterthan a\quad,\quad(k,l)\in c\ogreaterthan d\quad,\quad\text{and}\quad(x,y)\in(a,c)^{\updownarrow P}\quad,\nonumber \\
 & \quad\text{then}\quad\quad\big(\text{xmap}_{P}(g)(k)(x),\,\text{xmap}_{P}(h)(l)(y)\big)\in(b,d)^{\updownarrow P}\quad.\label{eq:xmap-relational-law-derivation3}
\end{align}

The conclusion of Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1})
is that two \lstinline!xmap(...)! values are in the relation $\left<f\right>^{\updownarrow T}$.
We can reproduce that conclusion using Eq.~(\ref{eq:xmap-relational-law-derivation3})
if we set $b=d=\left<f\right>$ since, by Statement~\ref{subsec:Statement-relational-lifting-consistency-PAA},
we will then have $(b,d)^{\updownarrow P}=(\left<f\right>,\left<f\right>)^{\updownarrow P}=\left<f\right>^{\updownarrow T}$.
The corresponding types need to be set as $B=D=X$ and $B^{\prime}=D^{\prime}=Y$.

Next, we need to find the values $g$, $h$, $k$, $l$, $x$, and
$y$ such that the \lstinline!xmap(...)! expressions in Eq.~(\ref{eq:xmap-relational-law-derivation3})
reproduce those in Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1}):
\[
\text{xmap}_{P}(g)(k)(x)=\text{xmap}_{P}(f)(\text{id})(z)\quad,\quad\quad\text{xmap}_{P}(h)(l)(y)=\text{xmap}_{P}(\text{id})(f)(z)\quad.
\]
It is clear that we need to set $g=l=f$, $h=\text{id}$, $k=\text{id}$,
and $x=y=z$. This also implies that we set the types as $B=C^{\prime}=X$,
$A=D^{\prime}=Y$, $A^{\prime}=B^{\prime}=Y$, and $C=D=X$.

Since we have $x=y$, the precondition $(x,y)\in(a,c)^{\updownarrow P}$
will hold if $(a,c)^{\updownarrow P}$ is an identity relation. To
achieve that, we choose $a=\text{id}$ and $c=\text{id}$, which also
means setting $A=A^{\prime}=Y$ and $C=C^{\prime}=X$. 

Finally, we can check that the preconditions $(g,h)\in b\ogreaterthan a$
and $(k,l)\in c\ogreaterthan d$ in Eq.~(\ref{eq:xmap-relational-law-derivation3})
will then hold automatically. So, we may use the conclusion of Eq.~(\ref{eq:xmap-relational-law-derivation3}),
which proves Eq.~(\ref{eq:pushout-relation-entails-lifted-derivation1}).
$\square$

It turns out that for some (but not all) profunctors $P$, the $\left(P,f\right)$-wedge
relation is \emph{equivalent} to the $\left(P,f\right)$-pushout relation:

\subsubsection{Definition \label{subsec:Definition-profunctor-pushout-property}\ref{subsec:Definition-profunctor-pushout-property}}

A profunctor $P^{X,Y}$ %
\begin{comment}
empty arrow
\end{comment}
{} has the \textbf{pushout property}\index{profunctor!pushout property}\index{pushout property of profunctors}
if the relation $\text{push}\,(f^{\downarrow P},f^{\uparrow P})$
is a

\begin{wrapfigure}{l}{0.415\columnwidth}%
\vspace{-2.3\baselineskip}
\[
\xymatrix{\xyScaleY{2.3pc}\xyScaleX{1.5pc} & P^{A,A}\ar[d]\sb(0.4){f^{\uparrow P^{A,\bullet}}} & \ar@{}[d]\sb(0.4){\displaystyle \Rightarrow} & P^{B,A}\ar[r]\sp(0.55){f^{\downarrow P^{\bullet,A}}}\ar[d]\sb(0.4){f^{\uparrow P^{B,\bullet}}} & P^{A,A}\ar[d]\sb(0.4){f^{\uparrow P^{A,\bullet}}}\\
P^{B,B}\ar[r]\sp(0.6){f^{\downarrow P^{\bullet,B}}} & P^{A,B} &  & P^{B,B}\ar[r]\sp(0.6){f^{\downarrow P^{\bullet,B}}} & P^{A,B}
}
\]

\vspace{-1.7\baselineskip}
\end{wrapfigure}%

\noindent consequence of $\text{pull}\,(f^{\uparrow P},f^{\downarrow P})$.
So, for any $x^{:P^{A,A}}$, $y^{:P^{B,B}}$:
\[
\text{if }(x,y)\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\text{ then }(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad.
\]

\noindent In other words, for any $f^{:A\rightarrow B}$ and any values
$x^{:P^{A,A}}$ and $y^{:P^{B,B}}$ in the $\left(P,f\right)$-wedge
relation ($x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$),
we can compute a value $p^{:P^{B,A}}$ such that $x=p\triangleright f^{\downarrow P^{\bullet,A}}$
and $y=p\triangleright f^{\uparrow P^{B,\bullet}}$. The type diagram
means that a wedge starting with arbitrary $x^{:P^{A,A}}$ and $y^{:P^{B,B}}$
can be always completed to a square that represents the profunctor
commutativity law~(\ref{eq:profunctor-commutativity-law}). $\square$

Below we will perform structural analysis for profunctors $P$ with
a pushout property and give some examples. The significance of those
$P$ is that we can obtain a property that is stronger than ordinary
dinaturality:

\subsubsection{Definition \label{subsec:Definition-strong-dinaturality}\ref{subsec:Definition-strong-dinaturality}}

A function $t^{A}:P^{A,A}\rightarrow Q^{A,A}$ is \textbf{strongly
dinatural} \index{strong dinaturality law}if for any $f^{:A\rightarrow B}$,
$x^{:P^{A,A}}$, and $y^{:P^{B,B}}$ the following property holds:\vspace{-0.3\baselineskip}
\begin{equation}
\text{when}\quad x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}=y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad.\label{eq:strong-dinaturality-law}
\end{equation}

\begin{wrapfigure}{i}{0.32\columnwidth}%
\vspace{-2.5\baselineskip}
\[
\xymatrix{\xyScaleY{1.2pc}\xyScaleX{1.0pc}P^{A,A}\ar[rd]\sb(0.35){f^{\uparrow P^{A,\bullet}}\negthickspace\negthickspace}\ar[rr]\sp(0.5){t^{A}} &  & Q^{A,A}\ar[rd]\sp(0.5){f^{\uparrow Q^{A,\bullet}}}\\
 & P^{A,B} & \negthickspace\Rightarrow & Q^{A,B}\\
P^{B,B}\ar[ru]\sp(0.5){f^{\downarrow P^{\bullet,B}}\negthickspace\negthickspace\negthickspace}\ar[rr]\sp(0.5){t^{B}} &  & Q^{B,B}\ar[ru]\sb(0.65){\negthickspace\negthickspace f^{\downarrow Q^{\bullet,B}}}
}
\]
\vspace{-2\baselineskip}
\end{wrapfigure}%

\noindent The strong dinaturality law is an equation (the \textsf{``}conclusion\textsf{''})
that is required to hold only when some values satisfy another equation
(the law\textsf{'}s \textsf{``}precondition\textsf{''}). The type diagram for that law, shown
at left, is a truncated form of the type diagram for Eq.~(\ref{eq:dinaturality-law-for-profunctors}).
The diagram starts with two arbitrary values of types $P^{A,A}$ and
$P^{B,B}$. The implication symbol ($\Rightarrow$) here means that
the left part of the diagram is an assumption used by the right part.

In terms of the wedge relations, strong dinaturality\textsf{'}s \textsf{``}precondition\textsf{''}
is the $\left(P,f\right)$-wedge relation for $(x,y)$, and the \textsf{``}conclusion\textsf{''}
is the $\left(Q,f\right)$-wedge relation for $(t^{A}(x),t^{B}(y))$.
So, the strong dinaturality condition~(\ref{eq:strong-dinaturality-law})
can be expressed as a relation using the pair mapper ($\ogreaterthan$):
\[
(t^{A},t^{B})\in\text{pull}\big(f^{\uparrow P^{A,\bullet}},f^{\downarrow P^{\bullet,B}}\big)\ogreaterthan\text{pull}\big(f^{\uparrow Q^{A,\bullet}},f^{\downarrow Q^{\bullet,B}}\big)\quad.
\]
For comparison, the ordinary dinaturality property of $t$ is written
in a similar way as:
\[
(t^{A},t^{B})\in\text{push}\,(f^{\downarrow P^{\bullet,A}},f^{\uparrow P^{B,\bullet}})\ogreaterthan\text{pull}\big(f^{\uparrow Q^{A,\bullet}},f^{\downarrow Q^{\bullet,B}}\big)\quad.
\]


\subsubsection{Statement \label{subsec:Statement-strong-dinaturality-pushout}\ref{subsec:Statement-strong-dinaturality-pushout}}

If a profunctor $P$ has the pushout property and $Q$ is any profunctor
then any fully parametric function $t:\forall A.\,P^{A,A}\rightarrow Q^{A,A}$
is strongly dinatural.

\subparagraph{Proof}

By Statements~\ref{subsec:Statement-naturality-laws-from-wedge-law}
and~\ref{subsec:Statement-wedge-law-from-parametricity}, the function
$t$ satisfies the ordinary dinaturality law:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
The pushout property of $P$ means:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})\quad.
\]
Chaining the implications, we find:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
This is the strong dinaturality law of $t$. $\square$

The name \textsf{``}strong dinaturality\textsf{''} suggests that this property is
stronger than the ordinary dinaturality. Indeed, strongly dinatural
transformations are always dinatural:

\subsubsection{Statement \label{subsec:Statement-strong-dinaturality-entails-dinaturality}\ref{subsec:Statement-strong-dinaturality-entails-dinaturality}}

\textbf{(a)} Any function $t^{A}:P^{A,A}\rightarrow Q^{A,A}$ satisfying
Eq.~(\ref{eq:strong-dinaturality-law}) will also satisfy Eq.~(\ref{eq:dinaturality-law-for-profunctors}).

\textbf{(b)} A natural transformation $t^{A}:F^{A}\rightarrow G^{A}$
(where $F$ and $G$ are both functors or both contrafunctors) is
strongly dinatural.

\textbf{(c)} A natural transformation $t^{X,Y}:P^{X,Y}\rightarrow Q^{X,Y}$
between profunctors $P$ and $Q$ gives a strongly dinatural transformation
$t^{A,A}:P^{A,A}\rightarrow Q^{A,A}$ if we set $X\triangleq A$ and
$Y\triangleq A$ in $t^{X,Y}$.

\subparagraph{Proof}

\textbf{(a)} The law~(\ref{eq:dinaturality-law-for-profunctors})
is an equality of functions of type $P^{B,A}\rightarrow Q^{A,B}$.
We will now show that those functions will give equal results when
applied to an arbitrary value $p:P^{B,A}$. Choose $x\triangleq p\triangleright f^{\downarrow P^{\bullet,A}}$
and $y\triangleq p\triangleright f^{\uparrow P^{B,\bullet}}$. The
precondition in Eq.~(\ref{eq:strong-dinaturality-law}) is satisfied
with these $x$ and $y$:
\begin{align*}
{\color{greenunder}\text{expect to equal }(y\triangleright f^{\downarrow P^{\bullet,B}}):}\quad & \gunderline x\triangleright f^{\uparrow P^{A,\bullet}}=p\,\gunderline{\triangleright\,f^{\downarrow P^{\bullet,A}}\triangleright f^{\uparrow P^{A,\bullet}}}\\
{\color{greenunder}\text{profunctor commutativity law of }P:}\quad & =p\triangleright f^{\uparrow P^{B,\bullet}}\triangleright f^{\downarrow P^{\bullet,B}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad.
\end{align*}
So, we can use the law~(\ref{eq:strong-dinaturality-law})\textsf{'}s conclusion
and obtain Eq.~(\ref{eq:dinaturality-law-for-profunctors}) applied
to $p$, completing the proof:
\begin{align*}
 & \gunderline x\triangleright t^{A}\triangleright f^{\uparrow Q^{A,\bullet}}\overset{!}{=}\gunderline y\triangleright t^{B}\triangleright f^{\downarrow Q^{\bullet,B}}\quad,\\
{\color{greenunder}\text{definitions of }x,y:}\quad & p\triangleright f^{\downarrow P^{\bullet,A}}\bef t^{A}\bef f^{\uparrow Q^{A,\bullet}}\overset{!}{=}p\triangleright f^{\uparrow P^{B,\bullet}}\bef t^{B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\end{align*}

\textbf{(b)} Consider the case where $F$ and $G$ are both functors.
We may view $t:F^{A}\rightarrow G^{A}$ as a function with the type
signature $t:P^{A,A}\rightarrow Q^{A,A}$ if we define the profunctors
$P^{X,Y}\triangleq F^{Y}$ and $Q^{X,Y}\triangleq G^{Y}$. Since $P^{X,Y}$
and $Q^{X,Y}$ ignore the type parameter $X$, we have the liftings
$f^{\uparrow P}=f^{\uparrow F}$, $f^{\downarrow P}=\text{id}$, $f^{\uparrow Q}=f^{\uparrow G}$,
and $f^{\downarrow Q}=\text{id}$. The strong dinaturality law of
$t$ is then written as:
\[
\text{when}\quad x^{:F^{A}}\triangleright f^{\uparrow F}=y^{:F^{B}}\quad\text{ then}\quad x\triangleright t\triangleright f^{\uparrow G}\overset{?}{=}y\triangleright t\quad.
\]
This is equivalent to $x\triangleright t\bef f^{\uparrow G}=x\triangleright f^{\uparrow F}\bef t$,
which holds by the assumed naturality of $t$.

A similar proof works when $F$ and $G$ are both contrafunctors.

We may also derive part \textbf{(b)} from part \textbf{(c)}.

\textbf{(c)} A natural transformation $t^{X,Y}:P^{X,Y}\rightarrow Q^{X,Y}$
satisfies naturality laws separately with respect to the type parameters
$X$ and $Y$. So, for all $f^{:A\rightarrow B}$ we have:
\[
f^{\uparrow P^{X,\bullet}}\bef t^{X,B}=t^{X,A}\bef f^{\uparrow Q^{X,\bullet}}\quad,\quad\quad f^{\downarrow P^{\bullet,Y}}\bef t^{A,Y}=t^{B,Y}\bef f^{\downarrow Q^{\bullet,Y}}\quad.
\]
We need to verify the strong dinaturality law of $t^{A,A}$:
\[
\text{when}\quad x^{:P^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:P^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{ then}\quad x\triangleright t^{A,A}\bef f^{\uparrow Q^{A,\bullet}}\overset{?}{=}y\triangleright t^{B,B}\bef f^{\downarrow Q^{\bullet,B}}\quad.
\]
Using the precondition of that law and the naturality laws of $t^{X,Y}$,
rewrite the conclusion of that law:
\begin{align*}
 & x\triangleright\gunderline{t^{A,A}\bef f^{\uparrow Q^{A,\bullet}}}=\gunderline{x\triangleright f^{\uparrow P^{A,\bullet}}}\bef t^{A,B}=y\triangleright f^{\downarrow P^{\bullet,B}}\bef t^{A,B}\\
 & \overset{?}{=}y\triangleright\gunderline{t^{B,B}\bef f^{\downarrow Q^{\bullet,B}}}=y\triangleright f^{\downarrow P^{\bullet,B}}\bef t^{A,B}\quad.
\end{align*}
The two sides of the strong dinaturality law are now equal. $\square$

Let us look at some examples of profunctors to see which ones have
the pushout property.

\subsubsection{Example \label{subsec:Example-weak-pullback-property-1}\ref{subsec:Example-weak-pullback-property-1}}

\textbf{(a)} Suppose a profunctor $P^{X,Y}$ does not depend on the
type parameter $X$ (so, $P^{X,Y}\triangleq G^{Y}$ with some functor
$G$). Then $P$ has the pushout property. 

\textbf{(b)} The pushout property holds for profunctors $P^{X,Y}\triangleq H^{X}$,
where $H$ is a contrafunctor.

\subparagraph{Proof}

\textbf{(a)} With the choice $P^{X,Y}\triangleq G^{Y}$, we have the
liftings $f^{\uparrow P}=f^{\uparrow G}$ and $f^{\downarrow P}=f$.
The pushout property of $P^{X,Y}$ says that, for any $f^{:A\rightarrow B}$,
$x^{:G^{A}}$, $y^{:G^{B}}$:
\[
\text{when}\quad x\triangleright f^{\uparrow G}=y\quad\text{ then }\quad\exists p^{:G^{A}}\text{ such that }x=p\text{ and }y=p\triangleright f^{\uparrow G}\quad.
\]
This property is satisfied by choosing $p\triangleq x$.

\textbf{(b)} With the choice $P^{X,Y}\triangleq H^{X}$, we have the
liftings $f^{\uparrow P}=f$ and $f^{\downarrow P}=f^{\downarrow H}$.
The pushout property of $P^{X,Y}$ says that, for any $f^{:A\rightarrow B}$,
$x^{:H^{A}}$, $y^{:H^{B}}$:
\[
\text{when}\quad x=y\triangleright f^{\downarrow H}\quad\text{ then }\quad\exists p^{:H^{A}}\text{ such that }x=p\triangleright f^{\downarrow H}\text{ and }y=p\quad.
\]
This property is satisfied by choosing $p\triangleq y$.

\subsubsection{Example \label{subsec:Example-weak-pullback-property}\ref{subsec:Example-weak-pullback-property}}

The profunctor $P^{X,Y}\triangleq X\rightarrow Y$ does \emph{not}
have the pushout property.

\subparagraph{Proof}

With $P^{X,Y}\triangleq X\rightarrow Y$, we rewrite the $\left(P,f\right)$-wedge
relation ($x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}$)
for arbitrary $f^{:A\rightarrow B}$, $x^{:A\rightarrow A}$, and
$y^{:B\rightarrow B}$ as:
\[
x\bef f=f\bef y\quad.
\]
The pushout property requires us to find a value $p^{:B\rightarrow A}$
such that $x=f\bef p$ and $y=p\bef f$. Choose $f$ as a constant
function ($f\triangleq\_\rightarrow b_{0}$ with a fixed value $b_{0}^{:B}$).
The $\left(P,f\right)$-wedge relation applied to an arbitrary value
$a^{:A}$ gives:
\[
a\triangleright x\bef f=b_{0}\overset{!}{=}a\triangleright f\bef y=y(b_{0})\quad.
\]
So, the wedge relation will hold for any $x^{:A\rightarrow A}$ and
for any $y^{:B\rightarrow B}$ such that $y(b_{0})=b_{0}$. In particular,
$y$ is not necessarily a constant function. But the condition $y=p\bef f=\_\rightarrow b_{0}$
can be satisfied only if $y$ is a constant function. So, there exists
no suitable value $p^{:P^{B,A}}$. $\square$

Structural analysis allows us to discover profunctors that have the
pushout property:

\subsubsection{Statement \label{subsec:Statement-weak-pullback-property}\ref{subsec:Statement-weak-pullback-property}}

A profunctor $P^{X,Y}$ has the pushout property if:

\textbf{(a)} $P^{X,Y}\triangleq F^{Y}$ with some (covariant) functor
$F$.

\textbf{(b)} $P^{X,Y}\triangleq G^{X}$ with some contrafunctor $G$.

\textbf{(c)} $P^{X,Y}\triangleq Z\rightarrow Q^{X,Y}$ with a fixed
type $Z$ and a profunctor $Q$ that has the pushout property.

\textbf{(d)} $P^{X,Y}\triangleq Q^{X,Y}\times R^{X,Y}$ with profunctors
$Q$ and $R$ that both have the pushout property.

\textbf{(e)} $P^{X,Y}\triangleq Q^{X,Y}+R^{X,Y}$ with profunctors
$Q$ and $R$ that both have the pushout property.

\subparagraph{Proof}

Consider some values $f^{:A\rightarrow B}$, $x^{:P^{A,A}}$, and
$y^{:P^{B,B}}$, for which the $\left(P,f\right)$-wedge relation
holds:
\[
x\triangleright f^{\uparrow P^{A,\bullet}}=y\triangleright f^{\downarrow P^{\bullet,B}}\quad.
\]

\textbf{(a)} If $P^{X,Y}=F^{Y}$ with a functor $F$, the wedge relation
is simplified to $x\triangleright f^{\uparrow F}=y$ with $x^{:F^{A}}$
and $y^{:F^{B}}$. We need to find $p^{:F^{A}}$ such that $x=p$
and $y=x\triangleright f^{\uparrow F}$. So, we define $p\triangleq x$
and complete the commuting square.

\textbf{(b)} If $P^{X,Y}=G^{X}$ with a contrafunctor $G$, the wedge
relation is simplified to $x=y\triangleright f^{\downarrow G}$ with
$x^{:G^{A}}$ and $y^{:G^{B}}$. We need to find $p^{:G^{B}}$ such
that $x=p\triangleright f^{\downarrow G}$ and $y=p$. So, we define
$p\triangleq y$ and complete the commuting square.

\textbf{(c)} Write the $\left(P,f\right)$-wedge relation for $x^{:Z\rightarrow Q^{A,A}}$
and $y^{:Z\rightarrow Q^{B,B}}$, applied to an arbitrary $z^{:Z}$:
\[
z\triangleright x\triangleright f^{\uparrow Q^{A,\bullet}}=z\triangleright y\triangleright f^{\downarrow Q^{\bullet,B}}\quad.
\]
Note that this is the same as the $\left(Q,f\right)$-wedge relation
for the values $z\triangleright x$ and $z\triangleright y$. By assumption,
$Q^{X,Y}$ has the pushout property. So, we may apply that property
to $z\triangleright x$ and $z\triangleright y$ and obtain a value
$q^{:Q^{B,A}}$ that satisfies the following two equations:
\begin{equation}
q\triangleright f^{\uparrow Q^{B,\bullet}}=z\triangleright y\quad,\quad\quad q\triangleright f^{\downarrow Q^{\bullet,A}}=z\triangleright x\quad.\label{eq:weak-pullback-c-derivation1}
\end{equation}
We need to find $p^{:Z\rightarrow Q^{B,A}}$ such that $x=p\bef f^{\downarrow Q^{\bullet,A}}$
and $y=p\bef f^{\uparrow Q^{B,\bullet}}$. These equations are the
same as Eq.~(\ref{eq:weak-pullback-c-derivation1}) if we define
$p(z)\triangleq q$. We have found a value $p$ that completes the
square diagram.

\textbf{(d)} Write the wedge relation for $x^{:Q^{A,A}\times R^{A,A}}=x_{1}^{:Q^{A,A}}\times x_{2}^{:R^{A,A}}$
and $y^{:Q^{B,B}\times R^{B,B}}=y_{1}^{:Q^{B,B}}\times y_{2}^{:R^{B,B}}$
as:
\[
(x_{1}\times x_{2})\triangleright f^{\uparrow(Q\times R)}=(x_{1}\triangleright f^{\uparrow Q})\times(x_{2}\triangleright f^{\uparrow R})\overset{!}{=}(y_{1}\times y_{2})\triangleright f^{\downarrow(Q\times R)}=(y_{1}\triangleright f^{\downarrow Q})\times(y_{2}\triangleright f^{\downarrow R})\quad.
\]
This equation is equivalent to the two equations:
\[
x_{1}\triangleright f^{\uparrow Q}\overset{!}{=}y_{1}\triangleright f^{\downarrow Q}\quad\text{ and }\quad x_{2}\triangleright f^{\uparrow R}\overset{!}{=}y_{2}\triangleright f^{\downarrow R}\quad,
\]
which are the $\left(Q,f\right)$- and $\left(R,f\right)$-wedge relations.
By assumption, $Q$ and $R$ have the pushout property. So, we may
compute values $p_{1}^{:Q^{B,A}}$ and $p_{2}^{:R^{B,A}}$ such that:
\[
p_{1}\triangleright f^{\downarrow Q}=x_{1}\quad,\quad\quad p_{1}\triangleright f^{\uparrow Q}=y_{1}\quad,\quad\quad p_{2}\triangleright f^{\downarrow R}=x_{2}\quad,\quad\quad p_{2}\triangleright f^{\uparrow R}=y_{2}\quad.
\]
If we define $p\triangleq p_{1}\times p_{2}$, we complete the square
diagram for $\left(Q\times R,f\right)$-wedge relation because:
\[
p\triangleright f^{\downarrow(Q\times R)}=(p_{1}\triangleright f^{\downarrow Q})\times(p_{2}\triangleright f^{\downarrow R})=x_{1}\times x_{2}\quad,\quad\quad p\triangleright f^{\uparrow(Q\times R)}=(p_{1}\triangleright f^{\uparrow Q})\times(p_{2}\triangleright f^{\uparrow R})=y_{1}\times y_{2}\quad.
\]

\textbf{(e)} Write the wedge relation for $x^{:Q^{A,A}+R^{A,A}}$
and $y^{:Q^{B,B}+R^{B,B}}$ as:
\[
x\triangleright\,\begin{array}{|c||cc|}
 & Q^{A,B} & R^{A,B}\\
\hline Q^{A,A} & f^{\uparrow Q^{A,\bullet}} & \bbnum 0\\
R^{A,A} & \bbnum 0 & f^{\uparrow R^{A,\bullet}}
\end{array}\,=y\triangleright\,\begin{array}{|c||cc|}
 & Q^{A,B} & R^{A,B}\\
\hline Q^{B,B} & f^{\downarrow Q^{\bullet,B}} & \bbnum 0\\
R^{B,B} & \bbnum 0 & f^{\downarrow R^{\bullet,B}}
\end{array}\quad.
\]
This equation can be satisfied only if both sides are either of type
$Q^{A,B}+\bbnum 0$ or of type $\bbnum 0+R^{A,B}$. Since the lifting
matrices are diagonal, this can happen only if $x$ has type $Q^{A,A}+\bbnum 0$
and $y$ has type $Q^{B,B}+\bbnum 0$, of if $x$ has type $\bbnum 0+R^{A,A}$
and $y$ has type $\bbnum 0+R^{B,B}$. In the first case, the property
becomes equivalent to that of the profunctor $Q$; in the second case,
to that of the profunctor $R$.

To see this in detail, consider two cases: $x\triangleq x_{1}^{:Q^{A,A}}+\bbnum 0$
and $x\triangleq\bbnum 0+x_{2}^{:R^{A,A}}$. In the first case, $x\triangleright f^{\uparrow P}=(x_{1}\triangleright f^{\uparrow Q})+\bbnum 0$.
This can be equal to $y\triangleright f^{\downarrow P}$ only if $y\triangleright f^{\downarrow P}$
is in the left part of the disjunction type $Q^{A,B}+R^{A,B}$. This
happens only when $y=y_{1}^{:Q^{B,B}}+\bbnum 0$ with some $y_{1}$.
So, the $\left(P,f\right)$-wedge relation implies $x_{1}\triangleright f^{\uparrow Q}=y_{1}\triangleright f^{\downarrow Q}$.
This is the $\left(Q,f\right)$-wedge relation for $(x_{1},y_{1})$.
By assumption, $Q$ has the pushout property. So, we can compute some
$p_{1}^{:Q^{B,A}}$ such that $x_{1}=p_{1}\triangleright f^{\downarrow Q}$
and $y_{1}=p_{1}\triangleright f^{\uparrow Q}$. If we now define
$p\triangleq p_{1}+\bbnum 0$, we will have $p\triangleright f^{\downarrow P}=x$
and $p\triangleright f^{\uparrow P}=y$, so the pushout property of
$P$ holds.

The case $x\triangleq\bbnum 0+x_{2}^{:R^{A,A}}$ is proved similarly
by using the pushout property of $R$. %
\begin{comment}
\textbf{(f)} Rewrite the wedge relation for $x^{:S^{A,A,P^{A,A}}}$
and $y^{:S^{B,B,P^{B,B}}}$ by using the explicit liftings to $S$:
\[
x\triangleright f^{\uparrow S^{A,\bullet,P^{A,A}}}\bef\big(\overline{f^{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,B,\bullet}}=y\triangleright f^{\downarrow S^{\bullet,B,P^{B,B}}}\bef\big(\overline{f^{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{A,B,\bullet}}\quad.
\]
Due to the commutativity law of $S$, we may exchange the order of
compositions here:
\[
f^{\uparrow S^{A,\bullet,P^{A,B}}}\big(x\triangleright(f^{\uparrow P^{A,\bullet}})^{\uparrow S^{A,A,\bullet}}\big)=y\triangleright\big(\overline{f^{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{B,B,\bullet}}\triangleright f^{\downarrow S^{\bullet,B,P^{A,B}}}\quad.
\]
Now we can use the pushout property of $S$ to obtain some $z:S^{B,A,P^{A,B}}$
such that
\[
x\triangleright\big(\overline{f^{\uparrow P^{A,\bullet}}}\big)^{\uparrow S^{A,A,\bullet}}=z\triangleright f^{\downarrow S^{\bullet,A,P^{A,B}}}\text{ and }y\triangleright\big(\overline{f^{\downarrow P^{\bullet,B}}}\big)^{\uparrow S^{B,B,\bullet}}=z\triangleright f^{\uparrow S^{B,\bullet,P^{A,B}}}\quad.
\]
We need to produce a value $t:S^{B,A,P^{B,A}}$ such that 
\[
x=t\triangleright f^{\downarrow S^{\bullet,A,P^{B,A}}}\bef\big(\overline{f^{\downarrow P^{\bullet,A}}}\big)^{\uparrow S^{A,A,\bullet}}\text{ and }y=t\triangleright f^{\uparrow S^{B,\bullet,P^{B,A}}}\bef\big(\overline{f^{\uparrow P^{B,\bullet}}}\big)^{\uparrow S^{B,B,\bullet}}\quad.
\]
\end{comment}
$\square$

The list of constructions in Statement~\ref{subsec:Statement-weak-pullback-property}
does not include the recursive type construction. It remains an open
question whether, say, a suitably limited form of the recursive type
construction would produce new profunctors having the pushout property.

However, profunctors $P$ with the pushout property are not the only
ones that produce strongly dinatural transformations. This is because
the pushout property is too restrictive. It is sufficient if the lifted
relation $\left<f\right>^{\updownarrow P}$ is a \emph{consequence}
of the $\left(P,f\right)$-wedge relation. We call this the \textsf{``}post-wedge\textsf{''}
property\index{profunctor!post-wedge property} of the profunctor
$P$.

Here and below, we will frequently need to use liftings $r^{\updownarrow T}$
to a type constructor $T^{\bullet}$ defined as $T^{A}\triangleq P^{A,A}$
with some profunctor $P^{X,Y}$. Statement~\ref{subsec:Statement-relational-lifting-consistency-PAA}
shows that $r^{\updownarrow T}=(r,r)^{\updownarrow P}$. So, we will
write the simultaneous lifting $(r,r)^{\updownarrow P}$ simply as
$r^{\updownarrow P}$ when this does not cause confusion.

\subsubsection{Definition \label{subsec:Definition-pre-post-wedge-property}\ref{subsec:Definition-pre-post-wedge-property}}

A profunctor $P$ has the \textbf{post-wedge property} if for any
$f^{:A\rightarrow B}$, $x^{:P^{A,A}}$, and $y^{:P^{B,B}}$:
\[
\text{if }\quad x\triangleright f^{\uparrow P}=x\triangleright f^{\downarrow P}\quad\text{ then }\quad(x,y)\in\left<f\right>^{\updownarrow P}\quad.
\]
In other words, the lifted relation $\left<f\right>^{\updownarrow P}$
always follows from the $\left(P,f\right)$-wedge relation. $\square$

By Statement~\ref{subsec:Statement-wedge-law-from-parametricity}(a),
the $\left(P,f\right)$-wedge relation is always a consequence of
the lifted relation $\left<f\right>^{\updownarrow P}$. So, the post-wedge
property of $P$ means that $\left<f\right>^{\updownarrow P}$ is
\emph{equivalent} to the $\left(P,f\right)$-wedge relation.

\subsubsection{Statement \label{subsec:Statement-post-wedge-entails-strong-dinaturality}\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}}

If $P$ is a profunctor with the post-wedge property and $Q$ is any
profunctor then any fully parametric function $t:\forall A.\,P^{A,A}\rightarrow Q^{A,A}$
is strongly dinatural.

\subparagraph{Proof}

The post-wedge property of $P$ means:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(x,y)\in\left<f\right>^{\updownarrow P}\quad.
\]
Since $t$ is fully parametric, it satisfies the relational naturality
law:
\[
\text{if}\quad(x,y)\in\left<f\right>^{\updownarrow P}\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\left<f\right>^{\updownarrow Q}\quad.
\]
By Statement~\ref{subsec:Statement-wedge-law-from-parametricity}(a),
the wedge law follows from the relational naturality law of $t$:
\[
\text{if}\quad(t^{A}(x),t^{B}(y))\in\left<f\right>^{\updownarrow Q}\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
Chaining the implications, we find:
\[
\text{if}\quad(x^{:P^{A,A}},y^{:P^{B,B}})\in\text{pull}\,(f^{\uparrow P},f^{\downarrow P})\quad\text{then}\quad(t^{A}(x),t^{B}(y))\in\text{pull}\,(f^{\uparrow Q},f^{\downarrow Q})\quad.
\]
This is the strong dinaturality law of $t$. $\square$

We will now do structural analysis to describe the profunctors with
the post-wedge property.\footnote{The following derivations are based on the talk slides: \texttt{\href{https://www.ioc.ee/~tarmo/tday-voore/vene-slides.pdf}{https://www.ioc.ee/$\sim$tarmo/tday-voore/vene-slides.pdf}}} 

\subsubsection{Statement \label{subsec:Statement-post-wedge}\ref{subsec:Statement-post-wedge}}

A profunctor $P$ will have the post-wedge property if:

\textbf{(a)} The type expression $P^{X,Y}$ does not depend either
on $X$ or on $Y$. That is, either $P^{X,Y}\triangleq Q^{Y}$ where
$Q$ is a functor or $P^{X,Y}\triangleq R^{X}$ where $R$ is a contrafunctor. 

\textbf{(b)} We have $P^{X,Y}\triangleq K^{X,Y}\times L^{X,Y}$, where
the profunctors $K$ and $L$ have the post-wedge property.

\textbf{(c)} We have $P^{X,Y}\triangleq K^{X,Y}+L^{X,Y}$, where the
profunctors $K$ and $L$ have the post-wedge property.

\textbf{(d)} We have $P^{X,Y}\triangleq K^{Y,X}\rightarrow L^{X,Y}$,
where the profunctor $K$ has the pushout property and the profunctor
$L$ has the post-wedge property.%
\begin{comment}
\textbf{(e)} We have a recursive type $P^{X,Y}\triangleq S^{X,Y,P^{X,Y}}$,
where $S^{X,Y,R}$ is contravariant in $X$ and covariant in $Y$
and $R$, and has the post-wedge property when viewed as a profunctor
with respect to $X$ and $Y$. Does the post-wedge really hold for
$P$?
\end{comment}


\subparagraph{Proof}

In each case, assuming the $\left(P,f\right)$-wedge relation for
$(x,y)$, we will show that $(x,y)\in\left<f\right>^{\updownarrow P}$. 

\textbf{(a)} If $P^{X,Y}$ does not depend on one of its type parameters
then we have either $P^{X,Y}\triangleq Q^{Y}$ or $P^{X,Y}\triangleq R^{X}$.
We know from Statement~\ref{subsec:Statement-weak-pullback-property}(a,
b) that $P$ will then have the pushout property. So, if any values
$x$ and $y$ are in the $\left(P,f\right)$-wedge relation then $(x,y)\in\text{push}\,(f^{\downarrow P},f^{\uparrow P})$.
By Statement~\ref{subsec:Statement-profunctor-pushout-entails-lifted-f},
we will also have $(x,y)\in\left<f\right>^{\uparrow P}$.

\textbf{(b)} We need to show that $P$ has the post-wedge property:
\[
\text{if }\quad(k_{1}^{:K^{A,A}}\times l_{1}^{:L^{A,A}})\triangleright f^{\uparrow P}=(k_{2}^{:K^{B,B}}\times l_{2}^{:L^{B,B}})\triangleright f^{\downarrow P}\quad\text{ then }\quad(k_{1}\times l_{1},k_{2}\times l_{2})\in\left<f\right>^{\updownarrow P}\quad.
\]
Using the definitions of the liftings $^{\updownarrow P}$, $^{\uparrow P}$,
and $^{\downarrow P}$, we rewrite the above condition as:
\[
\text{if }\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\text{ and }l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright f^{\downarrow L}\quad\text{ then }\quad(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\text{ and }(l_{1},l_{2})\in\left<f\right>^{\updownarrow L}\quad.
\]
This is the same as the conjunction of the post-wedge properties of
$K$ and $L$. 

\textbf{(c)} We need to show that $P$ has the post-wedge property:
\[
\text{if }\quad p_{1}^{:K^{A,A}+L^{A,A}}\triangleright f^{\uparrow P}=p_{2}^{:K^{B,B}+L^{B,B}}\triangleright f^{\downarrow P}\quad\text{ then }\quad(p_{1},p_{2})\in\left<f\right>^{\updownarrow P}\quad.
\]
The liftings $f^{\uparrow P}$ and $f^{\downarrow P}$ are defined
via the standard pattern-matching code for disjunctive types:
\[
f^{\uparrow P^{A,\bullet}}\triangleq\,\begin{array}{|c||cc|}
 & K^{A,B} & L^{A,B}\\
\hline K^{A,A} & f^{\uparrow K^{A,\bullet}} & \bbnum 0\\
L^{A,A} & \bbnum 0 & f^{\uparrow L^{A,\bullet}}
\end{array}\quad,\quad\quad f^{\downarrow P^{\bullet,B}}\triangleq\,\begin{array}{|c||cc|}
 & K^{A,B} & L^{A,B}\\
\hline K^{B,B} & f^{\downarrow K^{\bullet,B}} & \bbnum 0\\
L^{B,B} & \bbnum 0 & f^{\downarrow L^{\bullet,B}}
\end{array}\quad.
\]
Since both code matrices are diagonal, the two parts of the disjunctive
type $K+L$ do not mix. It follows that $p_{1}\triangleright f^{\uparrow P}=p_{2}\triangleright f^{\downarrow P}$
only if both $p_{1}$ and $p_{2}$ are in the same part of the disjunction
$K+L$. If both $p_{1}$ and $p_{2}$ are in the left part of the
disjunction, we have $p_{1}\triangleq k_{1}^{:K^{A,A}}+\bbnum 0$
and $p_{2}\triangleq k_{2}^{:K^{B,B}}+\bbnum 0$, and the $\left(P,f\right)$-wedge
relation for $p_{1}$ and $p_{2}$ reduces to the $\left(K,f\right)$-wedge
relation for $k_{1}$ and $k_{2}$:
\[
k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\quad.
\]
By Definition~\ref{subsec:Definition-relational-lifting}(d), the
values $p_{1}$ and $p_{2}$ will be in the relation $\left<f\right>^{\updownarrow P}$
only if $(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}$. Then the
post-wedge property of $P$ becomes:
\[
\text{if }\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}\quad\text{ then }\quad(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\quad.
\]
This holds because it is just the post-wedge property of $K$. Similarly,
we prove that if both $p_{1}$ and $p_{2}$ are in the right part
of the disjunction then the post-wedge property of $P$ is reduced
to the post-wedge property of $L$.

\textbf{(d)} Express the $\left(P,f\right)$-wedge relation and the
relation $\left<f\right>^{\updownarrow P}$ for $(x,y)$ through liftings
to $K$ and $L$:
\begin{align}
 & x^{:K^{A,A}\rightarrow L^{A,A}}\triangleright f^{\uparrow P^{A,\bullet}}=y^{:K^{B,B}\rightarrow L^{B,B}}\triangleright f^{\downarrow P^{\bullet,B}}\quad\text{or equivalently}:\quad f^{\downarrow K^{\bullet,A}}\bef x\bef f^{\uparrow L^{A,\bullet}}=f^{\uparrow K^{B,\bullet}}\bef y\bef f^{\downarrow L^{\bullet,B}}\quad,\label{eq:p-f-wedge-relation-x-y-derivation1}\\
 & (x^{:K^{A,A}\rightarrow L^{A,A}},y^{:K^{B,B}\rightarrow L^{B,B}})\in\left<f\right>^{\updownarrow P}\text{ means if }(k_{1}^{:K^{A,A}},k_{2}^{:K^{B,B}})\in\left<f\right>^{\updownarrow K}\text{ then }(x(k_{1}),y(k_{2}))\in\left<f\right>^{\updownarrow L}\quad.\nonumber 
\end{align}
Fix any $k_{1}^{:K^{A,A}}$ and $k_{2}^{:K^{B,B}}$ such that $(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}$.
We need to prove that $(x(k_{1}),y(k_{2}))\in\left<f\right>^{\updownarrow L}$
assuming Eq.~(\ref{eq:p-f-wedge-relation-x-y-derivation1}).

The pushout property of $K$ gives:
\[
\text{if }\quad k_{1}^{:K^{A,A}}\triangleright f^{\uparrow K}=k_{2}^{:K^{B,B}}\triangleright f^{\downarrow K}\quad\text{ then }\quad\exists k_{0}^{:K^{B,A}}\text{ such that }k_{1}=k_{0}\triangleright f^{\downarrow K^{\bullet,A}}\text{ and }k_{2}=k_{0}\triangleright f^{\uparrow K^{B,\bullet}}\quad.
\]
So, there exists a suitable value $k_{0}^{:K^{B,A}}$.%
\begin{comment}
By Statement~\ref{subsec:Statement-wedge-law-from-parametricity}(a),
the values $k_{1}$, $k_{2}$ are in the $\left(P,f\right)$-wedge
relation: $k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright f^{\downarrow K}$.
\end{comment}
{} Apply both sides of Eq.~(\ref{eq:p-f-wedge-relation-x-y-derivation1})
to that $k_{0}$:
\[
k_{0}\triangleright f^{\downarrow K^{\bullet,A}}\bef x\bef f^{\uparrow L^{A,\bullet}}=k_{0}\triangleright f^{\uparrow K^{B,\bullet}}\bef y\bef f^{\downarrow L^{\bullet,B}}\quad\text{or equivalently}:\quad k_{1}\triangleright x\triangleright f^{\uparrow L}=k_{2}\triangleright y\triangleright f^{\downarrow L}\quad.
\]
 It is also given that $L$ has the post-wedge property:
\[
\text{if }\quad l_{1}^{:L^{A,A}}\triangleright f^{\uparrow L}=l_{2}^{:L^{B,B}}\triangleright f^{\downarrow L}\quad\text{ then }\quad(l_{1},l_{2})\in\left<f\right>^{\updownarrow L}\quad.
\]
We now set $l_{1}\triangleq k_{1}\triangleright x$ and $l_{2}\triangleq k_{2}\triangleright y$
to obtain $(x(k_{1}),y(k_{2}))\in\left<f\right>^{\updownarrow L}$
as required. $\square$

As a consequence of Statement~\ref{subsec:Statement-post-wedge},
we can quickly prove (without structural analysis) that a function
relation lifted to functors or contrafunctors will yield another function
relation:

\subsubsection{Statement \label{subsec:Statement-lifting-function-relation-covariant-1}\ref{subsec:Statement-lifting-function-relation-covariant-1}}

Lifting a function $f^{:A\rightarrow B}$ to a fully parametric functor
or a contrafunctor $G$ agrees with lifting the relation $\left<f\right>$
to $G$. In detail: \textbf{(a)} $\left<f\right>^{\updownarrow G}=\langle f^{\uparrow G}\rangle$
if $G$ is a functor. \textbf{(b)} $\left<f\right>^{\updownarrow G}=\text{rev}\langle f^{\downarrow G}\rangle$
if $G$ is a contrafunctor.

\subparagraph{Proof}

Whether $G$ is a functor or a contrafunctor, Statement~\ref{subsec:Statement-post-wedge}(a)
shows that it has the post-wedge property. So, the relation $(\left<f\right>,\left<f\right>)^{\updownarrow P}$
is \emph{equivalent} to the $\left(P,f\right)$-wedge relation:
\[
(x,y)\in(\left<f\right>,\left<f\right>)^{\updownarrow P}\quad\text{is equivalent to}:\quad x\triangleright f^{\uparrow P}=y\triangleright f^{\downarrow P}\quad.
\]

\textbf{(a)} If $G$ is a functor, define $P^{X,Y}\triangleq G^{Y}$.
Simplifying $(\left<f\right>,\left<f\right>)^{\updownarrow P}=\left<f\right>^{\updownarrow G}$
and using the liftings $f^{\uparrow P}=f^{\uparrow G}$ and $f^{\downarrow P}=\text{id}$,
we get:
\[
(x,y)\in\left<f\right>^{\updownarrow G}\quad\text{is equivalent to}:\quad x\triangleright f^{\uparrow G}=y\quad\text{or equivalently}:\quad(x,y)\in\langle f^{\uparrow G}\rangle\quad.
\]
So, we find $\left<f\right>^{\updownarrow G}=\langle f^{\uparrow G}\rangle$
as required.

\textbf{(b)} If $G$ is a contrafunctor, define $P^{X,Y}\triangleq G^{X}$.
Simplifying $(\left<f\right>,\left<f\right>)^{\updownarrow P}=\left<f\right>^{\updownarrow G}$
and using the liftings $f^{\uparrow P}=\text{id}$ and $f^{\downarrow P}=f^{\downarrow G}$,
we get:
\[
(x,y)\in\left<f\right>^{\updownarrow G}\quad\text{is equivalent to}:\quad x=y\triangleright f^{\downarrow G}\quad\text{or equivalently}:\quad(x,y)\in\text{rev}\langle f^{\downarrow G}\rangle\quad.
\]
 So, we find $\left<f\right>^{\updownarrow G}=\text{rev}\langle f^{\downarrow G}\rangle$
as required. $\square$

Strong dinaturality holds only for type signatures $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
where the profunctor $K$ has a certain structure. Nevertheless, a
broad range of practically encountered functions have type signatures
of this form. Here are some examples.

\subsubsection{Example \label{subsec:Example-strong-dinaturality-for-some-type-signatures}\ref{subsec:Example-strong-dinaturality-for-some-type-signatures}\index{solved examples}}

Use Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}
to show that strong dinaturality holds for all fully parametric functions
with the following type signatures:

\textbf{(a)} $\forall A.\,F^{A}\rightarrow H^{A}\quad.$

\textbf{(b)} $\forall A.\,F^{A}\rightarrow G^{A}\rightarrow H^{A}\quad.$

\textbf{(c)} $\forall A.\,(F^{A}\rightarrow G^{A})\rightarrow H^{A}\quad.$

Here each of $F^{\bullet}$, $G^{\bullet}$, $H^{\bullet}$ is independently
either a functor or a contrafunctor. 

\subparagraph{Solution}

\textbf{(a)} and \textbf{(b)} We can represent these type signatures
as $\forall A.\,K^{A,A}\rightarrow L^{A,A}$ with some profunctors
$K^{X,Y}$ and $L^{X,Y}$. Then we will need to consider two cases
where $F$ is either covariant or contravariant. If $F$ is covariant,
we define $K^{X,Y}\triangleq F^{Y}$. If $F$ is contravariant, we
define $K^{X,Y}\triangleq F^{X}$. In every case, $K$ depends on
only one of its type parameters. We define $L^{X,Y}$ appropriately
for each case. By Statement~\ref{subsec:Statement-post-wedge}(a),
$K$ will have the post-wedge property. Strong dinaturality will then
follow from Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}.

\textbf{(c)} The type signature $\forall A.\,(F^{A}\rightarrow G^{A})\rightarrow H^{A}$
needs to be expressed as $\forall A.\,K^{A,A}\rightarrow L^{A,A}$
with some profunctors $K$ and $L$. We define $K^{X,Y}\triangleq M^{Y,X}\rightarrow N^{X,Y}$
with suitably chosen profunctors $M$ and $N$. Reasoning as before,
we find that the profunctors $M$ and $N$ will depend only on one
of their type parameters. So, they will have the post-wedge property.
In addition, Example~\ref{subsec:Example-weak-pullback-property-1}(a)
shows that $M$ has the pushout property. The post-wedge property
of $K$ is then established via Statement~\ref{subsec:Statement-post-wedge}(d).
So, the profunctor $K$ satisfies the conditions of Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}.
$\square$

Example~\ref{subsec:Example-strong-dinaturality-for-some-type-signatures}(c)
is used in Statement~\ref{subsec:Statement-Church-encoding-recursive-type-covariant}
for the Church encoding of recursive types.

\subsection{Strong dinaturality of \texttt{foldFn}}

This section will show that the function \lstinline!foldFn! used
in Statement~\ref{subsec:Statement-foldleft-foldmap-equivalence}
is strongly dinatural. The type signature of \lstinline!foldFn!,
\[
\text{foldFn}_{L}:\forall B.\,L^{B\rightarrow B}\rightarrow B\rightarrow B\quad,
\]
is not immediately covered by Statement~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}
because it contains the composition of an arbitrary functor $L$ and
a profunctor. To handle \lstinline!foldFn!, we will first need to
prove some additional properties.

\subsubsection{Statement \label{subsec:Statement-functor-post-pre-wedge}\ref{subsec:Statement-functor-post-pre-wedge}}

If $L^{\bullet}$ is a polynomial functor and $K^{\bullet,\bullet}$
is a profunctor with the post-wedge property then the profunctor $P^{X,Y}\triangleq L^{K^{X,Y}}$
also has the post-wedge property.

\subparagraph{Proof}

Assume any two values $x^{:L^{K^{A,A}}}$ and $y^{:L^{K^{B,B}}}$
that are in the $\left(P,f\right)$-wedge relation:
\[
(x,y)\in\text{pull}\,(f^{\uparrow K^{A,\bullet}\uparrow L},f^{\downarrow K^{\bullet,B}\uparrow L})\quad\text{or equivalently}:\quad x\triangleright f^{\uparrow K^{A,\bullet}\uparrow L}=y\triangleright f^{\downarrow K^{\bullet,B}\uparrow L}\quad.
\]
We need to show that $\left(x,y\right)\in\left<f\right>^{\updownarrow P}$.
As shown in Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
below, lifting a relation to $P$ means first lifting to $K$ and
then to $L$, so $\left<f\right>^{\updownarrow P}=\left<f\right>^{\updownarrow K\updownarrow L}$.
Since $K$ has the post-wedge property, the $\left(K,f\right)$-wedge
relation is equivalent to the relation $\left<f\right>^{\updownarrow K}$:
\[
(k_{1},k_{2})\in\left<f\right>^{\updownarrow K}\quad\text{is equivalent to}:\quad(k_{1},k_{2})\in\text{pull}\,(f^{\uparrow K^{A,\bullet}},f^{\downarrow K^{B,\bullet}})\quad.
\]
By Statement~\ref{subsec:Statement-pullback-lifted-to-functor} proved
below, lifting a pullback relation to $L$ gives again a pullback
relation:
\[
\left(x,y\right)\in\left<f\right>^{\updownarrow P}=\big(\text{pull}\,(f^{\uparrow K^{A,\bullet}},f^{\downarrow K^{B,\bullet}})\big)^{\updownarrow L}\quad\text{means}\quad(x,y)\in\text{pull}\,(f^{\uparrow K^{A,\bullet}\uparrow L},f^{\downarrow K^{\bullet,B}\uparrow L})\quad.
\]
So, $\left(x,y\right)$ are in the relation $\left<f\right>^{\updownarrow P}$.

\subsubsection{Statement \label{subsec:Statement-functor-composition-relational-lifting}\ref{subsec:Statement-functor-composition-relational-lifting}}

For any type constructors $G^{\bullet}$ and $H^{\bullet}$, define
$F\triangleq G\circ H$ or equivalently $F^{A}\triangleq G^{H^{A}}$.
Then the lifting of any relation $r^{:A\leftrightarrow B}$ to $F^{\bullet}$
can be expressed as $r^{\updownarrow F}=(r^{\updownarrow H})^{\updownarrow G}$,
which we may write more concisely as $r^{\updownarrow F}=r^{\updownarrow H\updownarrow G}$.

\subparagraph{Proof}

For each case of Definition~\ref{subsec:Definition-relational-lifting}
for the type constructor $G^{\bullet}$, we show that $r^{\updownarrow F}=(r^{\updownarrow H})^{\updownarrow G}$.

\paragraph{Constant type}

With $G^{A}\triangleq Z$ where $Z$ is a fixed type, we have $F^{A}=Z$,
so we write:
\[
r^{\updownarrow F}=\text{id}^{:Z\leftrightarrow Z}\quad\text{and}\quad(r^{\updownarrow H})^{\updownarrow G}=\text{id}^{:Z\leftrightarrow Z}\quad.
\]


\paragraph{Type parameter}

With $G^{A}\triangleq A$, we have $F^{A}=H^{A}$, so we write:
\[
r^{\updownarrow F}=r^{\updownarrow H}\quad\text{and}\quad(r^{\updownarrow H})^{\updownarrow G}=(r^{\updownarrow H})^{\updownarrow\text{Id}}=r^{\updownarrow H}\quad.
\]


\paragraph{Products}

With $G^{A}\triangleq K^{A}\times L^{A}$, we have $F^{A}=K^{H^{A}}\times L^{H^{A}}$.
Assuming that Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
already holds for $K\circ H$ and $L\circ H$, we write:
\begin{align*}
 & r^{\updownarrow F}=r^{\updownarrow(K\circ H)}\boxtimes r^{\updownarrow(L\circ H)}=r^{\updownarrow H\updownarrow K}\boxtimes r^{\updownarrow H\updownarrow L}=(r^{\updownarrow H})^{\updownarrow K}\boxtimes(r^{\updownarrow H})^{\updownarrow L}\quad,\\
 & (r^{\updownarrow H})^{\updownarrow G}=(r^{\updownarrow H})^{\updownarrow(K\times L)}=(r^{\updownarrow H})^{\updownarrow K}\boxtimes(r^{\updownarrow H})^{\updownarrow L}\quad.
\end{align*}
The two relations are now equal.

\paragraph{Co-products and function types}

The proofs are similar to that for products if we replace the operation
$\boxtimes$ by $\boxplus$ or by $\ogreaterthan$ everywhere as appropriate.

\paragraph{Recursive types}

With $G^{A}\triangleq S^{A,G^{A}}$, we have $F^{A}=S^{H^{A},G^{H^{A}}}=S^{H^{A},F^{A}}$.
Denoting $Q^{A,B}\triangleq S^{H^{A},B}$, we can write $F^{A}=Q^{A,F^{A}}$.
One inductive assumption is that Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
already holds separately with respect to each type parameter of $S^{\bullet,\bullet}$
and, in particular, a simultaneous lifting to $Q$ satisfies:
\[
(r,s)^{\updownarrow P}=(r,s)^{\updownarrow S^{H^{\bullet},\bullet}}=(r^{\updownarrow H},s)^{\updownarrow S^{\bullet,\bullet}}\quad.
\]
Then we can finish the derivation:
\begin{align*}
{\color{greenunder}\text{expect to equal }(r^{\updownarrow H})^{\updownarrow G}:}\quad & r^{\updownarrow F}=(r,\overline{r^{\updownarrow F}})^{\updownarrow P}=(r^{\updownarrow H},\overline{r^{\updownarrow F}})^{\updownarrow S}\\
{\color{greenunder}\text{inductive assumption }\overline{r^{\updownarrow F}}=\overline{r^{\updownarrow H\updownarrow G}}:}\quad & =(r^{\updownarrow H},\overline{r^{\updownarrow H\updownarrow G}})^{\updownarrow S}=(r^{\updownarrow H})^{\updownarrow G}\quad.
\end{align*}


\paragraph{Quantified types}

With $G^{A}\triangleq\forall X.\,P^{X,A}$, we have $F^{A}=\forall X.\,P^{X,H^{A}}$.
We may assume that Statement~\ref{subsec:Statement-functor-composition-relational-lifting}
already holds separately for liftings with respect to each type parameter
of $P^{\bullet,\bullet}$. In particular, if we denote $Q^{X,B}\triangleq P^{X,H^{B}}$
then:
\[
(s,r)^{\updownarrow Q}=(s,r)^{\updownarrow P^{\bullet,H^{\bullet}}}=(s,r^{\updownarrow H})^{\updownarrow P}\quad.
\]
For any types $A$, $B$, $X$, $Y$ and for any values $p^{:F^{A}}$
and $q^{:F^{B}}$, we write:
\begin{align*}
 & (p,q)\in r^{\updownarrow F}\quad\text{means}\quad\forall s^{:X\leftrightarrow Y}\,:\,(p^{X},q^{Y})\in(s,r)^{\updownarrow P^{\bullet,H^{\bullet}}}=(s,r^{\updownarrow H})^{\updownarrow P}\quad,\\
 & (p,q)\in(r^{\updownarrow H})^{\updownarrow G}\quad\text{means}\quad\forall s^{:X\leftrightarrow Y}\,:\,(p^{X},q^{Y})\in(s,r^{\updownarrow H})^{\updownarrow P^{\bullet,\bullet}}\quad.
\end{align*}
The two relations are now equal. 

\subsubsection{Statement \label{subsec:Statement-pullback-lifted-to-functor}\ref{subsec:Statement-pullback-lifted-to-functor}}

The lifting of a pullback relation to any polynomial functor $F$
is equivalent to a pullback relation with lifted functions:
\[
\text{for all }f^{:A\rightarrow C},g^{:B\rightarrow C}\quad:\quad\big(\text{pull}\,(f,g)\big)^{\updownarrow F}=\text{pull}\,(f^{\uparrow F},g^{\uparrow F})\quad.
\]


\subparagraph{Proof}

\begin{comment}
Most likely this is wrong for non-polynomial (although covariant)
functors $F$
\end{comment}
We enumerate the type constructions that $F$ is built from. Denote
$r^{:A\leftrightarrow B}\triangleq\text{pull}\,(f,g)$.

\paragraph{Constant types}

If $F^{A}\triangleq Z$ where $Z$ is a fixed type then $r^{\updownarrow F}=\text{id}^{:Z\leftrightarrow Z}$.
We write:
\[
\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(\text{id}^{:Z\leftrightarrow Z},\text{id}^{:Z\leftrightarrow Z})=\text{id}^{:Z\leftrightarrow Z}=r^{\updownarrow F}\quad.
\]


\paragraph{Type parameter}

If $F^{A}\triangleq A$ then $r^{\updownarrow F}=r$, $f^{\uparrow F}=f$,
and $g^{\uparrow F}=g$. We write:
\[
\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(f,g)=r=r^{\updownarrow F}\quad.
\]


\paragraph{Products}

If $F^{A}\triangleq K^{A}\times L^{A}$ then $r^{\updownarrow F}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}$,
$f^{\uparrow F}=f^{\uparrow K}\boxtimes f^{\uparrow L}$, and $g^{\uparrow F}=g^{\uparrow K}\boxtimes g^{\uparrow L}$.
For any values $k_{1}^{:K^{A}}$, $l_{1}^{:L^{A}}$, $k_{2}^{:K^{B}}$,
and $l_{2}^{:L^{B}}$, we write out the relation $r^{\updownarrow F}$:
\[
(k_{1}\times l_{1},k_{2}\times l_{2})\in r^{\updownarrow F}=r^{\updownarrow K}\boxtimes r^{\updownarrow L}\quad\text{means}\quad(k_{1},k_{2})\in r^{\updownarrow K}\text{ and }(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\]
The inductive assumptions for $K$ and $L$ allow us to rewrite the
last conditions as:
\[
(k_{1},k_{2})\in\text{pull}\,(f^{\uparrow K},g^{\uparrow K})\quad\text{ and }\quad(l_{1},l_{2})\in\text{pull}\,(f^{\uparrow L},g^{\uparrow L})\quad.
\]
Turning now to the pullback relation, $\text{pull}\,(f^{\uparrow F},g^{\uparrow F})$,
we write:
\begin{align*}
 & (k_{1}^{:K^{A}}\times l_{1}^{:L^{A}},k_{2}^{:K^{B}}\times l_{2}^{:L^{B}})\in\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(f^{\uparrow K}\boxtimes f^{\uparrow L},g^{\uparrow K}\boxtimes g^{\uparrow L})\\
 & \quad\text{means}\quad(k_{1}\times l_{1})\triangleright(f^{\uparrow K}\boxtimes f^{\uparrow L})=(k_{2}\times l_{2})\triangleright(g^{\uparrow K}\boxtimes g^{\uparrow L})\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright g^{\uparrow K}\quad\text{ and }\quad l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright g^{\uparrow L}\quad.
\end{align*}
The last conditions are now the same as for the relation $r^{\updownarrow F}$.

\paragraph{Co-products}

If $F^{A}\triangleq K^{A}+L^{A}$ then $r^{\updownarrow F}=r^{\updownarrow K}\boxplus r^{\updownarrow L}$,
$f^{\uparrow F}=f^{\uparrow K}\boxplus f^{\uparrow L}$, and $g^{\uparrow F}=g^{\uparrow K}\boxplus g^{\uparrow L}$.
For any values $k_{1}^{:K^{A}}$, $l_{1}^{:L^{A}}$, $k_{2}^{:K^{B}}$,
and $l_{2}^{:L^{B}}$, we write out the relation $r^{\updownarrow F}$:
\begin{align*}
{\color{greenunder}\text{either}:}\quad & (k_{1}+\bbnum 0,k_{2}+\bbnum 0)\in r^{\updownarrow K}\boxplus r^{\updownarrow L}\quad\text{when}\quad(k_{1},k_{2})\in r^{\updownarrow K}\quad,\\
{\color{greenunder}\text{or}:}\quad & (\bbnum 0+l_{1},\bbnum 0+l_{2})\in r^{\updownarrow K}\boxplus r^{\updownarrow L}\quad\text{when}\quad(l_{1},l_{2})\in r^{\updownarrow L}\quad.
\end{align*}
The inductive assumptions for $K$ and $L$ allow us to rewrite the
last conditions as:
\begin{align*}
 & (k_{1},k_{2})\in r^{\updownarrow K}=\text{pull}\,(f^{\uparrow K},g^{\uparrow K})\quad\text{or equivalently}:\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright g^{\uparrow K}\quad,\\
 & (l_{1},l_{2})\in r^{\updownarrow L}=\text{pull}\,(f^{\uparrow L},g^{\uparrow L})\quad\text{or equivalently}:\quad l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright g^{\uparrow L}\quad.
\end{align*}
Turning now to the pullback relation, $\text{pull}\,(f^{\uparrow F},g^{\uparrow F})$,
we write:
\begin{align}
 & (p_{1}^{:K^{A}+L^{A}},p_{2}^{:K^{B}+L^{B}})\in\text{pull}\,(f^{\uparrow F},g^{\uparrow F})=\text{pull}\,(f^{\uparrow K}\boxplus f^{\uparrow L},g^{\uparrow K}\boxplus g^{\uparrow L})\nonumber \\
 & \quad\text{means}\quad p_{1}\triangleright(f^{\uparrow K}\boxplus f^{\uparrow L})=p_{2}\triangleright(g^{\uparrow K}\boxplus g^{\uparrow L})\quad.\label{eq:p1-p2-condition-derivation1}
\end{align}
The pair co-product (such as $f^{\uparrow K}\boxplus f^{\uparrow L}$)
preserves the left and right parts of the disjunctive type, so the
condition~(\ref{eq:p1-p2-condition-derivation1}) is satisfied only
when $p_{1}$ and $p_{2}$ are both in the same part of the disjunction:
\begin{align*}
 & p_{1}\triangleright(f^{\uparrow K}\boxplus f^{\uparrow L})=p_{2}\triangleright(g^{\uparrow K}\boxplus g^{\uparrow L})\quad\text{means}\quad:\\
{\color{greenunder}\text{either}:}\quad & p_{1}=k_{1}+\bbnum 0\quad,\quad p_{2}=k_{2}+\bbnum 0\quad,\quad k_{1}\triangleright f^{\uparrow K}=k_{2}\triangleright g^{\uparrow K}\quad;\\
{\color{greenunder}\text{or}:}\quad & p_{1}=\bbnum 0+l_{1}\quad,\quad p_{2}=\bbnum 0+l_{2}\quad,\quad l_{1}\triangleright f^{\uparrow L}=l_{2}\triangleright g^{\uparrow L}\quad.
\end{align*}
The last conditions are now the same as for the relation $r^{\updownarrow F}$.

\paragraph{Function types}

We may not use this construction since $F$ is assumed to be a polynomial
functor.

\paragraph{Recursive types}

If $F^{A}\triangleq S^{A,F^{A}}$ where $S^{\bullet,\bullet}$ is
a polynomial bifunctor then:
\[
r^{\updownarrow F}=\big(r,\overline{r^{\updownarrow F}}\big)^{\updownarrow S}\quad,\quad\quad f^{\uparrow F}=f^{\uparrow S^{\bullet,F^{A}}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\quad,\quad\quad g^{\uparrow F}=g^{\uparrow S^{\bullet,F^{B}}}\bef\big(\overline{g^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\quad.
\]
The inductive assumptions are that Statement~\ref{subsec:Statement-pullback-lifted-to-functor}
already holds for the recursively used lifting $\overline{r^{\updownarrow F}}$
and for simultaneous liftings of \emph{two} pullback relations to
$S^{\bullet,\bullet}$. We can write these assumptions as:
\begin{align*}
{\color{greenunder}\text{for }\overline{r^{\updownarrow F}}:}\quad & \overline{r^{\updownarrow F}}\overset{!}{=}\text{pull}\,\big(\overline{f^{\uparrow F}},\overline{g^{\uparrow F}}\big)\quad,\\
{\color{greenunder}\text{for }S:}\quad & \big(\text{pull}\,(f^{:A\rightarrow C},g^{:B\rightarrow C}),\,\,\text{pull}\,(h^{:X\rightarrow Z},k^{:Y\rightarrow Z})\big)^{\updownarrow S}\overset{!}{=}\text{pull}\,(f^{\uparrow S^{\bullet,X}}\bef h^{\uparrow S^{C,\bullet}},\,\,g^{\uparrow S^{\bullet,Y}}\bef k^{\uparrow S^{C,\bullet}})\quad,
\end{align*}
where the last pullback relation involves functions of types $S^{A,X}\rightarrow S^{C,Z}$
and $S^{B,Y}\rightarrow S^{C,Z}$. We write:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pull}\,(f^{\uparrow F},g^{\uparrow F}):}\quad & r^{\updownarrow F}=\big(r,\overline{r^{\updownarrow F}}\big)^{\updownarrow S}=\big(\text{pull}\,(f,g),\,\,\text{pull}\,\big(\overline{f^{\uparrow F}},\overline{g^{\uparrow F}}\big)\big)^{\updownarrow S}\\
{\color{greenunder}\text{assumption for }S:}\quad & =\text{pull}\,\big(f^{\uparrow S^{\bullet,F^{A}}}\bef\big(\overline{f^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\,\,,g^{\uparrow S^{\bullet,F^{B}}}\bef\big(\overline{g^{\uparrow F}}\big)^{\uparrow S^{C,\bullet}}\big)\\
{\color{greenunder}\text{definitions of }(...)^{\uparrow F}:}\quad & =\text{pull}\,(f^{\uparrow F},g^{\uparrow F})\quad.
\end{align*}
$\square$

The strong dinaturality property of \lstinline!foldFn! is now proved
as a special case of Statement~\ref{subsec:Statement-functor-post-pre-wedge}:

\subsubsection{Example \label{subsec:Example-strong-dinaturality-proof-of-foldFn-law}\ref{subsec:Example-strong-dinaturality-proof-of-foldFn-law}\index{solved examples}}

Show that any fully parametric function $f:\forall A.\,L^{A\rightarrow A}\rightarrow A\rightarrow A$
is strongly dinatural when $L$ is any polynomial functor.

\subparagraph{Solution}

Define the profunctor $K^{X,Y}\triangleq X\rightarrow Y$ so that
the type signature of $f$ is written as:
\[
\forall A.\,L^{A\rightarrow A}\rightarrow A\rightarrow A=L^{K^{A,A}}\rightarrow K^{A,A}\quad.
\]
The profunctor $K$ has the post-wedge property by Statement~\ref{subsec:Statement-post-wedge}(a)
and (d). Then Statement~\ref{subsec:Statement-functor-post-pre-wedge}
means that the profunctor $L^{K^{X,Y}}$ also has the post-wedge property.
We can now use Statement~\ref{subsec:Statement-functor-post-pre-wedge}
to find that $f$ satisfies the strong dinaturality law. 

\section{Summary and further directions}

We have proved several properties that apply to all fully parametric
code:
\begin{itemize}
\item The lifting methods of any fully parametric bifunctor, profunctor,
or bi-contrafunctor obey the commutativity law such as Eq.~(\ref{eq:f-fmap-fmap-bifunctor-commutativity}). 
\item All fully parametric functions of type $P^{A,A}\rightarrow Q^{A,A}$
(where $P$, $Q$ are profunctors) obey the dinaturality law~(\ref{eq:dinaturality-law-for-profunctors}).
The form of the law depends only on the function\textsf{'}s type signature
and applies to all fully parametric implementations of that type signature. 
\item A given type constructor may have one fully parametric and lawful
implementation of the \lstinline!Functor! or \lstinline!Contrafunctor!
typeclass instance. (For most other typeclasses, such as \lstinline!Filterable!
or \lstinline!Monad!, many type constructors have several inequivalent
and lawful typeclass instances.) The unique implementations are defined
by the type constructions from Sections~\ref{subsec:f-Functor-constructions}
and~\ref{subsec:f-Contrafunctor-constructions}.
\item Parametricity theorem: Any fully parametric expression $t:\forall A.\,Q^{A}$
satisfies the relational naturality law~(\ref{eq:relational-naturality-law-1}).
In general, the relational naturality law expresses a property of
\emph{relations} rather than functions and is not equivalent to any
equation satisfied by $t$. 
\item If the type signature of $t$ satisfies the conditions of Statements~\ref{subsec:Statement-post-wedge-entails-strong-dinaturality}
or~\ref{subsec:Statement-functor-post-pre-wedge}, the function $t$
satisfies the \textsf{``}strong dinaturality\textsf{''} law~(\ref{eq:strong-dinaturality-law}),
which gives more information than the dinaturality law but is simpler
to use than the relational naturality law~(\ref{eq:relational-naturality-law-1}).
\end{itemize}
What remains unexplored:
\begin{itemize}
\item Relational databases give programmers many operations such as \lstinline!SELECT!
and \lstinline!JOIN!. Similar operations can be defined for binary
relations. For instance, two relations $r:A\leftrightarrow B$ and
$s:B\leftrightarrow C$ can be composed using an operation similar
to \lstinline!JOIN!, which yields a new relation (denoted by $r\circ s$)
of type $A\leftrightarrow C$. However, relational composition turns
out to be unnecessary for proving the practically useful parametricity
properties. At the same time, properties of relational composition
are complicated and not intuitive. For instance, it is not true that
$(r\circ s)^{\updownarrow F}=r^{\updownarrow F}\circ s^{\updownarrow F}$
for arbitrary type constructors $F$. It is also not possible to use
the relational composition as a replacement for the simultaneous lifting
construction (Definition~\ref{subsec:Definition-simultaneous-relational-lifting}).
\item Parametricity can be extended to types and code constructions beyond
those covered in this book. The scope of material in this Appendix
is intentionally limited to theory that has already proven its practical
importance for programmers. For instance, we did not cover parametricity
for functions with typeclass constraints. The corresponding theory
is complicated\footnote{The theory of parametricity applied to functions with typeclass constraints
is developed by J.~Voigtl\"ander\index{Janis@Janis Voigtl\"ander}
in the paper \texttt{\href{https://www.janis-voigtlaender.eu/papers/FreeTheoremsInvolvingTypeConstructorClasses.pdf}{https://www.janis-voigtlaender.eu/papers/FreeTheoremsInvolvingTypeConstructorClasses.pdf}}} and yet delivers few practically useful results. For example, that
theory does not seem to solve Problem~\ref{par:Problem-identity-natural-monad-morphism},
which considers functions with the following type signature:
\begin{lstlisting}
def epsilon[M[_]: Monad, A]: M[A] => M[A]
\end{lstlisting}
If \lstinline!epsilon! is a monad morphism that works in the same
way for all monads \lstinline!M! and all types \lstinline!A!, can
we prove that \lstinline!epsilon! is an identity function? The analogous
question involving functors can be answered by the parametricity theorem.
Using the Yoneda lemma for functors (Statement~\ref{subsec:Statement-covariant-yoneda-identity-for-type-constructors}),
one can prove that any fully parametric function with the type signature:
\begin{lstlisting}
def epsilon[F[_]: Functor, A]: F[A] => F[A]
\end{lstlisting}
must be an identity function.
\end{itemize}

\chapter{Solutions of some exercises}

\subsection*{Chapter \ref{chap:1-Values,-types,-expressions,}}

\subsubsection*{Exercise \ref{subsec:ch1-aggr-Exercise-1}}

~
\begin{lstlisting}
def at(n: Double, maxN: Int) = (0 to maxN)
  .map { k => 1.0*(1 - k % 2 * 2) / (2 * k + 1) / math.pow(n, 2 * k + 1) }
  .sum
def p(n: Int) = 16 * at(5, n) - 4 * at(239, n)

scala> p(12)
res0: Double = 3.141592653589794
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch1-aggr-Exercise-2}}

~
\begin{lstlisting}
def isPrime(n: Int) = (2 to n - 1).takeWhile(k => k * k <= n).forall(k => n % k != 0)
def ep(n: Int): Double = (2 to n)
  .filter(isPrime)
  .map  { k => 1.0 / (1.0 - 1.0 / k / k / k /k) }
  .product
val pi = 3.1415926535897932

scala> ep(100); pi*pi*pi*pi/90
res0_0: Double = 1.0823231553280295
res0_1: Double = 1.082323233711138 
\end{lstlisting}


\subsection*{Chapter \ref{chap:2-Mathematical-induction}}

\subsubsection*{Exercise \ref{tuples-Exercise-10}}

~
\begin{lstlisting}
numsLists.map(_.sortBy(- _).take(3))
\end{lstlisting}


\subsubsection*{Exercise \ref{tuples-Exercise-11}}

~
\begin{lstlisting}
a.flatMap(x => b.map(y => (x, y)))
\end{lstlisting}


\subsubsection*{Exercise \ref{tuples-Exercise-12}}

~
\begin{lstlisting}
def payments[Person, Amount](data: Seq[Map[Person, Amount]]): Map[Person, Seq[Amount]] =
  data.flatMap(_.toSeq).groupBy(_._1).mapValues(_.map(_._2))
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-2.2-foldleft-5}}

~
\begin{lstlisting}
def batching[A](xs: Seq[A], size: Int): Seq[Seq[A]] = {  
  type Acc = (Seq[Seq[A]], Seq[A], Int)
  val init: Acc = ((Seq(), Seq(), 0))
  val (result, rem, _) = xs.foldLeft(init){ case ((seq, rem, len), x) =>
    val newLen = len + 1
    if (newLen > size) (seq ++ Seq(rem), Seq(x), 1)
    else (seq, rem ++ Seq(x), newLen)
  }
  result ++ Seq(rem)
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-2.2-foldleft-5-1}}

~
\begin{lstlisting}
def weightBatching[A](xs: Seq[A], maxW: Double)(w: A => Double): Seq[Seq[A]] = {  
  type Acc = (Seq[Seq[A]], Seq[A], Double)
  val init: Acc = ((Seq(), Seq(), 0.0))
  val (result, rem, _) = xs.foldLeft(init) { case ((seq, rem, weight), x) =>
    val wx = w(x)
    if (wx > maxW) (seq ++ Seq(rem, Seq(x)), Seq(), 0.0)
    else {
      val newWeight = weight + wx
      if (newWeight > maxW) (seq ++ Seq(rem), Seq(x), wx)
      else (seq, rem ++ Seq(x), newWeight)
    }
  }
  result ++ Seq(rem)
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-2.2-foldleft-6}}

~
\begin{lstlisting}
def groupBy[A, K](xs: Seq[A])(by: A => K): Map[K, Seq[A]] = {  
  val init: Map[K, Seq[A]] = Map()
  xs.foldLeft(init) { (res, x) =>
    val key = by(x)
    val seq = res.getOrElse(key, Seq()) ++ Seq(x)
    res.updated(key, seq)
  }
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-3}}

~
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).toList
def cubeDigits(n: Int): Int = digitsOf(n).map(x => x*x*x).sum
def cubes(n: Int): Stream[Int] = Stream.iterate(n)(cubeDigits)

def stopRepeats[T](str: Stream[T]): Stream[T] = {
  val halfSpeed = str.flatMap(x => Seq(x, x))
  val result = halfSpeed.zip(str).drop(1).takeWhile{ case (h, s) => h != s }.map(_._2)
  if (result.isEmpty) str.take(1) else str
}
def cubesReach1(n: Int): Boolean = stopRepeats(cubes(n)).contains(1)
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-4}}

~
\begin{lstlisting}
def prod3(a: Set[Int], b: Set[Int], c: Set[Int]): Set[Set[Int]] =
  a.flatMap(x => b.flatMap(y => c.map(z => Set(x, y, z))))
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-5}}

~
\begin{lstlisting}
def prodSet(sets: Set[Set[Int]]): Set[Set[Int]] =
    sets.foldLeft(Set[Set[Int]](Set())) {
      // Combine each of results so far with each element in current set
      case (accumSet: Set[Set[Int]], currSet: Set[Int]) =>
        for {
          s <- accumSet
          i <- currSet
        } yield s + i
      }
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-4-1}}

~
\begin{lstlisting}
@tailrec def pairs(goal: Int, xs: Array[Int])(
  res: Set[(Int, Int)] = Set(), left: Int = 0, right: Int = xs.length): Set[(Int, Int)] =
    if (left == right) res else {
      val sum = xs(left) + xs(right - 1)
      val (newLeft, newRight, newRes) = if (sum == goal) 
                  (left + 1, right, res + ((xs(left), xs(right - 1)))) 
                else if (sum < goal)
                  (left + 1, right, res)
                else (left, right - 1, res)
      pairs(goal, xs)(newRes, newLeft, newRight)
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-6}}

~
\begin{lstlisting}
def revSentence(sentence: String): String = sentence.split(" ").reverse.mkString(" ")
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2revdigits-Exercise-seq-7}}

~
\begin{lstlisting}
def digitsOf(n: Int): Seq[Int] = Stream.iterate(n)(_ / 10).takeWhile(_ != 0).map(_ % 10).toList
def revDigits(n: Int): Int = digitsOf(n).foldLeft(0){case (acc, d) => acc * 10 + d }
def isPalindrome(n: Int): Boolean = revDigits(n) == n
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-8}}

~
\begin{lstlisting}
def findPalindrome(n: Int): Int = 
  Stream.iterate(n) { x => x + revDigits(x) } .filter(isPalindrome).head
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:ch2Exercise-seq-9-1}}

~
\begin{lstlisting}
def unfold2[A,B](init: A)(next: A => Option[(A,B)]): Stream[B] = next(init) match {
   case None           => Stream()
   case Some((a, b))   => Stream.cons(b, unfold2(a)(next))
}
\end{lstlisting}


\subsection*{Chapter \ref{chap:Disjunctive-types}}

\subsubsection*{Exercise \ref{subsec:Disjunctive-Exercise-non-empty-list-1}}

~
\begin{lstlisting}
def toList[A](nel: NEL[A]): List[A] = nel match {
  case Last(x)         => List(x)
  case More(x, tail)   => x :: toList(tail)
} // Not tail-recursive.
def toList[A](nel: NEL[A]): List[A] = foldLeft(nel)(Nil:List[A]) {
  (prev, x) =>  x :: prev
}.reverse // Tail-recursive, but performs two traversals.
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-disjunctive-EvenList}}

~
\begin{lstlisting}
sealed trait EvenList[A]
final case class Lempty[A]() extends EvenList[A]
final case class Lpair[A](x: A, y: A, tail: EvenList[A]) extends EvenList

def fmap[A, B](f: A => B): EvenList[A] => EvenList[B] = {
  case Lempty()            => Lempty[B]()
  case Lpair(x, y, tail)   => Lpair[B](f(x), f(y), fmap(f)(tail))
}
\end{lstlisting}


\subsection*{Chapter \ref{chap:Higher-order-functions}}

\subsubsection*{Exercise \ref{subsec:Exercise-hof-simple-8}}

~
\begin{lstlisting}
@tailrec def convergeN[X](p: X => Boolean)(x:X)(m:Int)(f: X => X): Option[X] =  {
              if (m <= 0) None
              else if (p(x)) Some(x) else converge(p)(f(x))(m-1)(f)             }
// Defining it as def convergeN[X]: (X => Boolean) => X => Int => (X => X) => Option[X] = ???
// will break tail recursion!
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-hof-simple-7-1}}

~
\begin{lstlisting}
def recover[E, A]: Option[Either[E, A]] => (E => A) => Option[A] = {
  case None             => _ => None
  case Some(Right(a))   => _ => Some(a)
  case Some(Left(e))    => f => Some(f(e))
}
\end{lstlisting}


\subsubsection*{Exercise \ref{subsec:Exercise-hof-composition-1}}

\textbf{(a)} Choose $f^{:A\rightarrow A}\triangleq(\_\rightarrow z)$
and compute $(f\bef h)(x)=h(z)\overset{!}{=}h(x)$, for any $x$.
So, $h(x)$ equals a fixed value $h(z)$. It follows that $h(x)$
does not depend on $x$, i.e., $h$ is a constant function.

\textbf{(b)} Choose $f^{:A\rightarrow B}\triangleq\_\rightarrow b$
and compute $(f\bef h)(x)=h(b)\overset{!}{=}(g\bef f)(x)=f(g(x))=b$.
It follows that $h(b)=b$ for any $b^{:B}$, so $h$ is an identity
function. Substitute that into the law and get $f=g\bef f$ for any
function $f$. Substitute $f\triangleq\text{id}$ into that and derive
$\text{id}=g\bef\text{id}=g$. So, $g$ is the identity function.

\subsection*{Chapter \ref{chap:5-Curry-Howard}}

\subsubsection*{Exercise \ref{subsec:Exercise-type-notation-2}}

The type expression is: $A\times\text{Int}+A\times\text{Char}+A\times\text{Float}$.

\subsection*{Chapter \ref{chap:Reasoning-about-code}}

\subsubsection*{Exercise \ref{subsec:Exercise-reasoning-1-4-1}}

It is assumed that $\phi:\forall A.\,F^{A}\rightarrow G^{A}$ satisfies
its naturality law: for any $f^{:A\rightarrow B}$,
\[
f^{\uparrow F}\bef\phi=\phi\bef f^{\uparrow G}\quad.
\]

\textbf{(a)} To verify the naturality law of $\phi^{\uparrow K}$:
for any $f^{:A\rightarrow B}$,
\begin{align*}
 & f^{\uparrow F\uparrow K}\bef\phi^{\uparrow K}\overset{?}{=}\phi^{\uparrow K}\bef f^{\uparrow G\uparrow K}\quad,\\
{\color{greenunder}\text{composition under }^{\uparrow K}:}\quad & (f^{\uparrow F}\bef\phi)^{\uparrow K}\overset{?}{=}(\phi\bef f^{\uparrow G})^{\uparrow K}\quad.
\end{align*}
The last equation holds due to the naturality law of $\phi$.

\textbf{(b)} The naturality law of the pair product ($\phi\boxtimes\psi$)
says that for any $p^{:A\rightarrow B}$,
\[
p^{\uparrow(F\times K)}\bef(\phi\boxtimes\psi)\overset{?}{=}(\phi\boxtimes\psi)\bef p^{\uparrow(G\times L)}\quad.
\]
Begin with the left-hand side of this equation:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{\uparrow(F\times K)}\bef(\phi\boxtimes\psi)\\
{\color{greenunder}\text{definition of }^{\uparrow(F\times K)}:}\quad & =\big(f^{:F^{A}}\times k^{:K^{A}}\rightarrow(f\triangleright p^{\uparrow F})\times(k\triangleright p^{\uparrow K})\big)\bef(\phi\boxtimes\psi)\\
{\color{greenunder}\text{definition of }\phi\boxtimes\psi:}\quad & =f\times k\rightarrow\phi(f\triangleright p^{\uparrow F})\times\psi(k\triangleright p^{\uparrow K})=f\times k\rightarrow(f\triangleright p^{\uparrow F}\bef\phi)\times(k\triangleright p^{\uparrow K}\bef\psi)\quad.
\end{align*}
To rewrite the right-hand side, introduce the function argument into
$\phi\boxtimes\psi$:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & (\phi\boxtimes\psi)\bef p^{\uparrow(G\times L)}=\big(f^{:F^{A}}\times k^{:K^{A}}\rightarrow(f\triangleright\phi)\times(k\triangleright\psi)\big)\bef p^{\uparrow(G\times L)}\\
{\color{greenunder}\text{definition of }^{\uparrow(G\times L)}:}\quad & =f\times k\rightarrow(f\triangleright\gunderline{\phi\triangleright p^{\uparrow G}})\times(k\triangleright\gunderline{\psi\triangleright p^{\uparrow L}})=f\times k\rightarrow(f\triangleright\phi\bef p^{\uparrow G})\times(k\triangleright\psi\bef p^{\uparrow L})\quad.
\end{align*}
The remaining differences between the two sides disappear due to the
naturality laws of $\phi$ and $\psi$:
\[
p^{\uparrow F}\bef\phi=\phi\bef p^{\uparrow G}\quad,\quad\quad p^{\uparrow K}\bef\psi=\psi\bef p^{\uparrow L}\quad.
\]

The naturality law of the pair co-product ($\phi\boxplus\psi$) says
that for any $p^{:A\rightarrow B}$,
\[
p^{\uparrow(F+K)}\bef(\phi\boxplus\psi)\overset{?}{=}(\phi\boxplus\psi)\bef p^{\uparrow(G+L)}\quad.
\]
Begin with the left-hand side of this equation:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p^{\uparrow(F+K)}\bef(\phi\boxplus\psi)\\
{\color{greenunder}\text{definitions of }^{\uparrow(F+K)}\text{ and of }\phi\boxplus\psi:}\quad & =\,\begin{array}{|c||cc|}
 & F^{B} & K^{B}\\
\hline F^{A} & p^{\uparrow F} & \bbnum 0\\
K^{A} & \bbnum 0 & p^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{B} & \phi & \bbnum 0\\
K^{B} & \bbnum 0 & \psi
\end{array}\\
{\color{greenunder}\text{matrix composition}:}\quad & =\,\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{A} & p^{\uparrow F}\bef\phi & \bbnum 0\\
K^{A} & \bbnum 0 & p^{\uparrow K}\bef\psi
\end{array}\quad.
\end{align*}
The right-hand side is rewritten in a similar way:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & (\phi\boxplus\psi)\bef p^{\uparrow(G+L)}\\
 & =\,\begin{array}{|c||cc|}
 & G^{A} & L^{A}\\
\hline F^{A} & \phi & \bbnum 0\\
K^{A} & \bbnum 0 & \psi
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline G^{A} & p^{\uparrow G} & \bbnum 0\\
L^{A} & \bbnum 0 & p^{\uparrow L}
\end{array}\,=\,\begin{array}{|c||cc|}
 & G^{B} & L^{B}\\
\hline F^{A} & \phi\bef p^{\uparrow G} & \bbnum 0\\
K^{A} & \bbnum 0 & \psi\bef p^{\uparrow L}
\end{array}\quad.
\end{align*}
The remaining differences between the two sides disappear due to the
naturality laws of $\phi$ and $\psi$. 

\subsection*{Chapter \ref{chap:Typeclasses-and-functions}}

\subsubsection*{Exercise \ref{subsec:tc-Exercise-3}}

\textbf{(a)}
\begin{lstlisting}
def monoidFunc[A: Monoid, R] = Monoid[R => A](
  { (x, y) => r => x(r) |+| y(r) }, _ => implicitly[Monoid[A]].empty
)
\end{lstlisting}

In the code notation:
\[
f^{:R\rightarrow A}\oplus g^{:R\rightarrow A}\triangleq a\rightarrow f(a)\oplus_{A}g(a)\quad,\quad\quad e\triangleq(\_\rightarrow e_{A})\quad.
\]
Proof of monoid laws:
\begin{align*}
 & a\triangleright\left(\left(f\oplus g\right)\oplus h\right)=\left(a\triangleright(f\oplus g)\right)\oplus_{A}h(a)=f(a)\oplus_{A}g(a)\oplus_{A}h(a)\quad.\\
 & a\triangleright\left(f\oplus\left(g\oplus h\right)\right)=f(a)\oplus_{A}\left(a\triangleright(g\oplus h)\right)=f(a)\oplus_{A}g(a)\oplus_{A}h(a)\quad.\\
 & a\triangleright\left(e\oplus f\right)=e(a)\oplus_{A}f(a)=e_{A}\oplus_{A}f(a)=f(a)=a\triangleright f\quad.\\
 & a\triangleright(f\oplus e)=f(a)\oplus_{A}e(a)=f(a)\oplus_{A}e_{A}=f(a)=a\triangleright f\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:tc-Exercise-9-1} }

\textbf{(a)} A counterexample is the functor $F^{A}\triangleq R\rightarrow A$,
where $R$ is a fixed type.

\textbf{(b)} The function $C^{A}\times C^{B}\rightarrow C^{A+B}$
cannot be implemented for $C^{A}\triangleq\left(A\rightarrow P\right)+\left(A\rightarrow Q\right)$.
This more complicated contrafunctor $C$ is necessary because the
simpler contrafunctor $C^{A}\triangleq A\rightarrow P$ does not provide
a counterexample.

\subsubsection*{Exercise \ref{subsec:tc-Exercise-9-1-1-1}}

Define the method $\text{ex}_{F}$ as:
\[
\text{ex}_{F}\triangleq x^{:F^{A}}\rightarrow x\triangleright(a^{:A}\rightarrow a\times1)^{\uparrow F}\triangleright q^{A,\bbnum 1}\triangleright\pi_{1}\quad\text{ or equivalently: }\quad\text{ex}_{F}\triangleq(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\pi_{1}\quad.
\]
To show that the naturality law ($f^{\uparrow F}\bef\text{ex}_{F}=\text{ex}_{F}\bef f$)
holds, use the identity $(f\boxtimes g)\bef\pi_{1}=\pi_{1}\bef f$:
\begin{align*}
 & f^{\uparrow F}\bef\text{ex}_{F}=\gunderline{f^{\uparrow F}\bef(a^{:A}\rightarrow a\times1)^{\uparrow F}}\bef q^{A,\bbnum 1}\bef\pi_{1}=(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef\gunderline{(f\boxtimes\text{id})^{\uparrow F}\bef q^{A,\bbnum 1}}\bef\pi_{1}\\
 & =(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\gunderline{(f\boxtimes\text{id}^{\uparrow F})\bef\pi_{1}}=\gunderline{(a^{:A}\rightarrow a\times1)^{\uparrow F}\bef q^{A,\bbnum 1}\bef\pi_{1}}\bef f=\text{ex}_{F}\bef f\quad.
\end{align*}

Given a method $\text{ex}_{F}$, define $q$ as:
\[
q^{A,B}\triangleq f^{:F^{A\times B}}\rightarrow(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright\pi_{2}^{\uparrow F})\quad\text{ or equivalently: }\quad q^{A,B}\triangleq\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id})\quad.
\]
Show that the required laws hold for $q$. Identity law: 
\[
f\triangleright q^{\bbnum 1,B}=(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{\bbnum 1})\times(f\triangleright\pi_{2}^{\uparrow F})=1\times(f\triangleright\pi_{2}^{\uparrow F})
\]
because $\text{ex}_{F}^{\bbnum 1}$ produces a value of type $\bbnum 1$,
which can only be $1$.

To prove the naturality law:
\begin{align*}
(f^{:A\rightarrow C}\boxtimes g^{:B\rightarrow D})^{\uparrow F}\bef\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id}) & =\Delta\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id})\bef f\boxtimes(g^{\uparrow F})\\
\Delta\bef((f\boxtimes g)^{\uparrow F}\boxtimes(f\boxtimes g)^{\uparrow F})\bef(\pi_{1}^{\uparrow F}\boxtimes\pi_{2}^{\uparrow F})\bef(\text{ex}_{F}^{A}\boxtimes\text{id}) & =\Delta\bef(\pi_{1}^{\uparrow F}\bef\text{ex}_{F}\bef f)\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F})\\
\Delta\bef(\pi_{1}^{\uparrow F}\bef\,\gunderline{f^{\uparrow F}\bef\text{ex}_{F}})\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F}) & =\Delta\bef(\pi_{1}^{\uparrow F}\bef\,\gunderline{\text{ex}_{F}\bef f})\boxtimes(\pi_{2}^{\uparrow F}\bef g^{\uparrow F})
\end{align*}
To prove the associativity law, write the left-hand side as:
\begin{align*}
 & f^{:F^{A\times B\times C}}\triangleright q^{A,B\times C}\bef(\text{id}^{A}\boxtimes q^{B,C})=(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright q^{B,C})\\
 & =(f\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{A})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright\pi_{1}^{\uparrow F}\triangleright\text{ex}_{F}^{B})\times(f\triangleright(a\times b\times c\rightarrow b\times c)^{\uparrow F}\triangleright\pi_{2}^{\uparrow F})\\
 & =\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a)\right)\times\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow b)\right)\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\quad.
\end{align*}
The right-hand side is then simplified to the same expression:
\begin{align*}
 & f^{:F^{A\times B\times C}}\triangleright q^{A\times B,C}=(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a\times b))\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\\
 & =\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow a)\right)\times\left(f\triangleright\text{ex}_{F}\triangleright(a\times b\times c\rightarrow b)\right)\times(f\triangleright(a\times b\times c\rightarrow c)^{\uparrow F})\quad.
\end{align*}


\subsection*{Chapter \ref{chap:Filterable-functors}}

\subsubsection*{Exercise \ref{subsec:filt-exercise-derive-liftOpt-equivalence-1}}

Starting from \lstinline!liftOpt!\textsf{'}s law, derive the naturality law:
\[
\text{liftOpt}\left(g\right)\bef\text{liftOpt}\,(f\bef\text{pu}_{\text{Opt}})=\text{liftOpt}(f\bef\text{pu}_{\text{Opt}}\diamond_{_{\text{Opt}}}g)=\text{liftOpt}(f\bef g)\quad.
\]
Now use the naturality-identity law and get $\text{liftOpt}\,(f\bef\text{pu}_{\text{Opt}})=f^{\downarrow C}$.
The result is the naturality law $\text{liftOpt}\left(f\bef g\right)=\text{liftOpt}\left(g\right)\bef f^{\downarrow C}$.

\subsubsection*{Exercise \ref{subsec:Exercise-filterable-laws-4}}

A counterexample is the functor $F^{A}\triangleq\bbnum 1+A\times\left(Z\rightarrow A\right)$.
For this functor, one can implement \lstinline!deflate!\textsf{'}s type signature,
but the code cannot obey the identity law because it must always return
$1+\bbnum 0$.

\subsection*{Chapter \ref{chap:Semimonads-and-monads}}

\subsubsection*{Exercise \ref{subsec:Exercise-1-monads-3-1}}

The given non-standard implementation of \lstinline!flatten! will
return the same results as the standard \lstinline!flatten! method
of the \lstinline!List! type constructor, except if one of the nested
sub-lists is empty. In that case, the \lstinline!flatten! function
returns an empty list (unlike \lstinline!List!\textsf{'}s standard \lstinline!flatten!
method). The \lstinline!pure! method remains unchanged. The code
is:
\begin{lstlisting}[mathescape=true]
def pure[A](x: A): List[A] = List(x) // $\color{dkgreen}\textrm{pu}_L$
def flatten[A](p: List[List[A]]): List[A] = if (p.exists(_.isEmpty)) Nil else p.flatten  // $\color{dkgreen}\textrm{ftn}_L$
\end{lstlisting}

To verify the monad laws, we use the known fact that the standard
\lstinline!List! monad obeys the laws. So, we only need to check
the laws in the cases when the new \lstinline!flatten! function is
applied to a value of type \lstinline!List[List[A]]! having an empty
nested sub-list. That case cannot arise in the identity laws since
neither $\text{pu}_{L}(x^{:A})$ nor $\text{pu}_{L}^{\uparrow L}(x^{:\text{List}^{A}})$
ever returns a value with a nested empty sub-list:
\begin{lstlisting}
pure(List(a, b, c)) == List(List(a, b, c))
List(a, b, c).map(pure) == List(List(a), List(b), List(c))
\end{lstlisting}
Applying \lstinline!flatten! to these values gives the initial list
\lstinline!List(a, b, c)!. So, both identity laws hold.

It remains to check the associativity law, which is an equality between
functions $\text{ftn}_{L}\bef\text{ftn}_{L}$ and $\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}$
of type \lstinline!List[List[List[A]]] => List[A]!. A value $p$
of type \lstinline!List[List[List[A]]]! could contain a nested empty
list at the first and/or the second nesting depth, for instance:
\begin{lstlisting}
val p1: List[List[List[Int]]] = List(List[List[Int]](), List(List(123), List(456)))
val p2: List[List[List[Int]]] = List(List(List[Int](), List(123)), List(List(456)))
\end{lstlisting}
Whenever $p$ contains an empty sub-list at the first nesting depth,
we will have $p\triangleright\text{ftn}_{L}=\text{Nil}$ because $\text{ftn}_{L}$
explicitly checks for the existence of an empty sub-list. So, $p\triangleright\text{ftn}_{L}\bef\text{ftn}_{L}=\text{Nil}$.
On the other hand, $p\triangleright\text{ftn}_{L}^{\uparrow L}$ will
be again a list containing an empty sub-list, for example:
\begin{lstlisting}
scala> p1.map(flatten)
res0: List[List[Int]] = List(List(), List(123, 456))
\end{lstlisting}
We will then have $p\triangleright\text{ftn}_{L}^{\uparrow L}\triangleright\text{ftn}_{L}=\text{Nil}$,
and the law holds. If $p$ contains an empty sub-list at the \emph{second}
nesting depth, $p\triangleright\text{ftn}_{L}$ will contain an empty
sub-list at the first nesting depth, for example:
\begin{lstlisting}
scala> flatten(p2)
res1: List[List[Int]] = List(List(), List(123), List(456)) 
\end{lstlisting}
So $p\triangleright\text{ftn}_{L}\bef\text{ftn}_{L}=\text{Nil}$.
On the other hand, $p\triangleright\text{ftn}_{L}^{\uparrow L}$ will
also be a list with an empty sub-list at the first nesting depth,
for example:
\begin{lstlisting}
scala> p2.map(flatten)
res2: List[List[Int]] = List(List(), List(456))
\end{lstlisting}
Applying $\text{ftn}_{L}$ to the last result, we will get an empty
list. Thus, $p\triangleright\text{ftn}_{L}\triangleright\text{ftn}_{L}=\text{Nil}$,
and the law again holds. So, we have shown that the associativity
law holds for the non-standard \lstinline!List! monad.

\subsubsection*{Exercise \ref{subsec:Exercise-flatten-concat-distributive-law}}

The values $p$ and $q$ must have type $\text{List}^{\text{List}^{A}}$.
There are two possibilities: $p$ is an empty list ($p=1+\bbnum 0$),
and $p=\bbnum 0+h\times t$. If $p$ is empty, so is $p\triangleright\text{ftn}$
and the law holds. In the other case, we have (due to the code of
$\pplus$) that:
\[
\left(\bbnum 0+h\times t\right)\pplus q=\bbnum 0+h\times\left(t\pplus q\right)\quad,
\]
and so:
\begin{align*}
 & \left(p\pplus q\right)\triangleright\text{ftn}=\left(\bbnum 0+h\times\left(t\pplus q\right)\right)\triangleright\text{ftn}=h\pplus\gunderline{\left(t\pplus q\right)\triangleright\overline{\text{ftn}}}\\
{\color{greenunder}\text{inductive assumption}:}\quad & =\gunderline{h\pplus(t\triangleright\overline{\text{ftn}})}\pplus(q\triangleright\overline{\text{ftn}})\\
{\color{greenunder}\text{code of }\text{ftn}:}\quad & =\left(\bbnum 0+h\times t\right)\triangleright\overline{\text{ftn}}\pplus(q\triangleright\overline{\text{ftn}})=\left(p\triangleright\text{ftn}\right)\pplus\left(q\triangleright\text{ftn}\right)\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-monad-of-monoid-is-monoid}}

Define the empty element ($e_{M}$) of the monoid $M^{W}$ as:
\[
e_{M}\triangleq\text{pu}_{M}(e_{W})\quad.
\]
The binary operation $\oplus_{M}$ of the monoid $M^{W}$ may be implemented
through $\oplus_{W}$ as:
\[
p\oplus_{M}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow q\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\quad.
\]
To check the left identity law of $M^{W}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }p:}\quad & e_{M}\oplus_{M}p=e_{W}\triangleright\gunderline{\text{pu}_{M}\triangleright\text{flm}_{M}}\big(u^{:W}\rightarrow p\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\\
 & =e_{W}\triangleright\big(u^{:W}\rightarrow p\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}\big)=p\triangleright(v\rightarrow\gunderline{e_{W}\oplus_{W}v})^{\uparrow M}\\
{\color{greenunder}\text{left identity law of }W:}\quad & =p\triangleright(v\rightarrow v)^{\uparrow M}=p\triangleright\text{id}^{\uparrow M}=p\quad.
\end{align*}
To check the right identity law of $M^{W}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }p:}\quad & p\oplus_{M}e_{M}=p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow e_{W}\triangleright\gunderline{\text{pu}_{M}\triangleright(v^{:W}\rightarrow u\oplus_{W}v)^{\uparrow M}}\big)\\
{\color{greenunder}\text{naturality of }\text{pu}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow\gunderline{e_{W}\triangleright(v^{:W}}\rightarrow u\oplus_{W}v)\triangleright\text{pu}_{M}\big)\\
{\color{greenunder}\text{apply function}:}\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow(\gunderline{u\oplus_{W}e_{W}})\triangleright\text{pu}_{M}\big)\\
{\color{greenunder}\text{right identity law of }W:}\quad & =p\triangleright\text{flm}_{M}\big(u^{:W}\rightarrow u\triangleright\text{pu}_{M}\big)=p\triangleright\text{id}=p\quad.
\end{align*}
To check the associativity law of $M^{W}$, we use the associativity
law of $\text{flm}_{M}$:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (p\oplus_{M}q)\oplus_{M}r\\
 & =p\triangleright\gunderline{\text{flm}_{M}}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v)^{\uparrow M}\big)\,\gunderline{\triangleright\text{flm}_{M}}\big(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M}\big)\\
{\color{greenunder}\text{associativity of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(\gunderline (u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v)^{\uparrow M}\gunderline{)\bef}\,\text{flm}_{M}(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M})\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{W}v\gunderline{)^{\uparrow M}\triangleright\text{flm}_{M}}(t\rightarrow r\triangleright(w\rightarrow t\oplus_{W}w)^{\uparrow M})\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow\gunderline{u\oplus_{W}v})\,\gunderline{\bef(t}\rightarrow r\triangleright(w\rightarrow\gunderline t\oplus_{W}w)^{\uparrow M}))\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow(u\oplus_{W}v)\oplus_{W}w)^{\uparrow M})\big)\quad.
\end{align*}
Now write the right-hand side of the law:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & p\oplus_{M}(q\oplus_{M}r)=p\triangleright\text{flm}_{M}\big(u\rightarrow(q\oplus r)\triangleright(t\rightarrow u\oplus_{W}t)^{\uparrow M}\big)\\
{\color{greenunder}\text{substitute }q\oplus r:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow v\oplus_{W}w)^{\uparrow M})\,\gunderline{\triangleright\,(}t\rightarrow u\oplus_{W}t\gunderline{)^{\uparrow M}}\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow u\oplus_{W}w\gunderline{)^{\uparrow M}\bef}\,(t\rightarrow u\oplus_{W}t\gunderline{)^{\uparrow M}})\big)\\
{\color{greenunder}\text{composition under }^{\uparrow M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright\text{flm}_{M}(v\rightarrow r\triangleright(w\rightarrow u\oplus_{W}(v\oplus_{W}w))^{\uparrow M})\big)\quad.
\end{align*}
 The difference between the two sides now vanishes due to the assumed
associativity law of $W$:
\[
(u\oplus_{W}v)\oplus_{W}w\overset{!}{=}u\oplus_{W}(v\oplus_{W}w)\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-1-monads-9-1}}

\textbf{(b)} The code is converted into monad methods like this:
\begin{align*}
 & r_{1}=p\triangleright\text{flm}_{M}(x\rightarrow q\triangleright(y\rightarrow f(x,y))^{\uparrow M})\quad,\\
 & r_{2}=q\triangleright\text{flm}_{M}(y\rightarrow p\triangleright(x\rightarrow f(x,y))^{\uparrow M})\quad.
\end{align*}
For a commutative monad $M$, we have $r_{1}=r_{2}$. The monoid operation
$\oplus_{M}$ is defined by:
\[
p^{:M^{\bbnum 1}}\oplus_{M}q^{:M^{\bbnum 1}}\triangleq p\triangleright\text{flm}_{M}(1\rightarrow q)\quad.
\]
Commutativity of $\oplus_{M}$ means that:
\[
p\triangleright\text{flm}_{M}(1\rightarrow q)=p\oplus_{M}q\overset{?}{=}q\oplus_{M}p=q\triangleright\text{flm}_{M}(1\rightarrow p)\quad.
\]
Use $f(x,y)\triangleq1$ in the definitions of $r_{1}$ and $r_{2}$;
then the above equation is equivalent to $r_{1}=r_{2}$.

\subsubsection*{Exercise \ref{subsec:Exercise-1-monads-12}}

The second definition, $\text{pu}_{L}\triangleq a\rightarrow\bbnum 0+\text{pu}_{F}(a)$,
fails the right identity law:
\begin{align*}
 & \text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\,\begin{array}{|c||ccc|}
 & A & F^{A} & F^{L^{A}}\\
\hline A & \bbnum 0 & \text{pu}_{F} & \bbnum 0\\
F^{A} & \bbnum 0 & \bbnum 0 & \text{pu}_{L}^{\uparrow F}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & F^{A}\\
\hline A & \text{id} & \bbnum 0\\
F^{A} & \bbnum 0 & \text{id}\\
F^{L^{A}} & \bbnum 0 & \gamma^{\uparrow F}\bef\text{ftn}_{F}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & F^{A}\\
\hline A & \bbnum 0 & \text{pu}_{F}\\
F^{A} & \bbnum 0 & ...
\end{array}\,\neq\text{id}\quad.
\end{align*}
This matrix cannot be equal to the identity function because it has
a missing diagonal element.

\subsubsection*{Exercise \ref{subsec:Exercise-monad-composition-mm}}

If $M$ is a semimonad, we have the Kleisli composition $\diamond_{_{M}}$
that satisfies the associativity law. Define $\diamond_{_{L}}$ by:
\[
f^{:A\rightarrow M^{M^{B}}}\diamond_{_{L}}g^{:B\rightarrow M^{M^{C}}}\triangleq f\bef\text{ftn}_{M}\diamond_{_{M}}g\quad.
\]
Here, the expression of the form $f\bef h\diamond_{_{M}}g$ does not
need parentheses (see Statement~\ref{subsec:Statement-equivalence-kleisli-composition-and-flatMap}).

It is inconvenient to mix the Kleisli composition and the \lstinline!flatten!
method, so we express \lstinline!flatten! as:
\[
\text{ftn}_{M}^{:M^{M^{A}}\rightarrow M^{A}}=\text{flm}_{M}(\text{id}^{:M^{A}\rightarrow M^{A}})=\text{id}^{:M^{M^{A}}\rightarrow M^{M^{A}}}\diamond_{_{M}}\text{id}^{:M^{A}\rightarrow M^{A}}\quad.
\]
For brevity, we will omit type annotations from now on. So, we can
express the Kleisli composition $\diamond_{_{L}}$ through $\diamond_{_{M}}$
by:
\[
f\diamond_{_{L}}g\triangleq f\bef\gunderline{\left(\text{id}\diamond_{_{M}}\text{id}\right)\diamond_{_{M}}g}=f\bef\left(\text{id}\diamond_{_{M}}\left(\text{id}\diamond_{_{M}}g\right)\right)=\left(f\bef\text{id}\right)\diamond_{_{M}}\left(\text{id}\diamond_{_{M}}g\right)=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\quad.
\]

Associativity of $\diamond_{_{L}}$ then follows from associativity
of $\diamond_{_{M}}$ as:
\begin{align*}
\left(f\diamond_{_{L}}g\right)\diamond_{_{L}}h & =\left(f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\right)\diamond_{_{M}}\text{id}\diamond_{_{M}}h=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\quad,\\
f\diamond_{_{L}}\left(g\diamond_{_{L}}h\right) & =f\diamond_{_{M}}\text{id}\diamond_{_{M}}\left(g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\right)=f\diamond_{_{M}}\text{id}\diamond_{_{M}}g\diamond_{_{M}}\text{id}\diamond_{_{M}}h\quad.
\end{align*}

This definition of $\diamond_{_{L}}$ corresponds to a definition
of $\text{ftn}_{L}$ that flattens the \emph{first} three layers of
$M$ in $M\circ M\circ M\circ M$:
\[
\text{ftn}_{L}\triangleq\text{ftn}_{M}\bef\text{ftn}_{M}\quad.
\]

An alternative definition will flatten the \emph{last} three layers:
\[
\text{ftn}_{L}\triangleq(\text{ftn}_{M}\bef\text{ftn}_{M})^{\uparrow M}\quad.
\]
Both definitions satisfy the associativity law and so define a semimonad
$L$,
\[
\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\text{ftn}_{L}\bef\text{ftn}_{L}\quad.
\]
Let us verify that directly. For the first definition:
\begin{align*}
 & \gunderline{(\text{ftn}_{M}\bef\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\big(\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{associativity of }M:}\quad & =\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}^{\uparrow M\uparrow M}}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}=\gunderline{\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\bef\gunderline{\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{associativity of }M:}\quad & =\text{ftn}_{M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\bef\text{ftn}_{M}\quad.
\end{align*}
For the second definition, we just apply $^{\uparrow M}$ to the preceding
derivation.

A definition of \lstinline!flatten! that flattens separately the
first two and the last two layers of $M$ ($\text{ftn}_{L}\triangleq\text{ftn}_{M}\bef\text{ftn}_{M}^{\uparrow M}$)
will fail the associativity law when $M$ is chosen in a suitable
way.

If $M$ is a full monad, we have $\text{pu}_{M}$ that satisfies the
identity laws. Define $\text{pu}_{L}$ by:
\[
\text{pu}_{L}\triangleq\text{pu}_{M}\bef\text{pu}_{M}\quad.
\]
There is no other way of defining $\text{pu}_{L}$ since we cannot
obtain a value of type $M^{A}$ other than via $\text{pu}_{M}$.

With any of the two possible definitions of $\text{ftn}_{L}$, at
least one of the identity laws for $\diamond_{_{L}}$ fails.

For the definition of $\text{ftn}_{L}$ that flattens the first three
layers, the right identity law will fail:
\[
\text{pu}_{L}^{\uparrow L}\bef\text{ftn}_{L}=\gunderline{(\text{pu}_{M}\bef\text{pu}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}}\bef\text{ftn}_{M}=\text{ftn}_{M}\bef\text{pu}_{M}^{\uparrow M}\bef\gunderline{\text{pu}_{M}^{\uparrow M}\bef\text{ftn}_{M}}=\text{ftn}_{M}\bef\text{pu}_{M}^{\uparrow M}\quad.
\]
In general, this function is not equal to an identity function, because
\lstinline!flatten! merges the two monadic layers of $M$ and in
that way loses information about a value of type $M^{M^{A}}$.

For the definition of $\text{ftn}_{L}$ that flattens the last three
layers, the left identity law will fail:
\[
\text{pu}_{L}\bef\text{ftn}_{L}=\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef(\text{ftn}_{M}}\bef\text{ftn}_{M})^{\uparrow M}=\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\bef\text{pu}_{M}\bef\text{ftn}_{M}^{\uparrow M}=\text{pu}_{M}\bef\text{ftn}_{M}^{\uparrow M}=\text{ftn}_{M}\bef\text{pu}_{M}\quad.
\]
In general, this function is not equal to an identity function.

\subsection*{Chapter \ref{chap:8-Applicative-functors,-contrafunctors}}

\subsubsection*{Exercise \ref{subsec:Exercise-simplify-law-omit-lifted-function}}

We may choose $f=\text{id}$ and derive $u=v$ from the given law.
Conversely, if $u=v$ then $u\bef f^{\uparrow F}=v\bef f^{\uparrow F}$
for any function $f$.

\subsubsection*{Exercise \ref{subsec:Exercise-applicative-II-4-1}}

To verify the law, write:
\begin{align*}
 & \text{ap}\,(r)(\text{pu}_{L}(a))=\text{zip}\big(r\times\text{pu}_{L}(a)\big)\triangleright\text{eval}^{\uparrow L}\\
{\color{greenunder}\text{right identity law of }\text{zip}:}\quad & =r\triangleright\left(f\rightarrow f\times a\right)^{\uparrow L}\bef\text{eval}^{\uparrow L}\\
{\color{greenunder}\text{composition under }^{\uparrow L}:}\quad & =r\triangleright(f\rightarrow f(a))\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-function-type-construction-not-applicative}}

\textbf{(a)} We cannot implement \lstinline!zip! as a fully parametric
function having this type:
\[
\text{zip}_{F}(p^{:(A\rightarrow P)\rightarrow Q}\times q^{:(B\rightarrow P)\rightarrow Q})\triangleq h^{:A\times B\rightarrow P}\rightarrow\text{???}^{:Q}\quad.
\]
\begin{lstlisting}
import io.chymyst.ch._
type S[A] = (A => P) => Q

scala> def zip[A, B](p: S[A], q: S[B]): S[(A, B)] = implement
type ((A => P) => Q) => ((B => P) => Q) => (Tuple2[A,B] => P) => Q cannot be implemented
\end{lstlisting}

The reason it cannot be implemented is that the only way of getting
a value of type $Q$ is to call the given functions $p$ or $q$.
But we cannot call $p$ or $q$ since we cannot supply their arguments:
we have a function of type $A\times B\rightarrow P$, and we cannot
produce a function of type $A\rightarrow P$ or $B\rightarrow P$
out of it.

The only solution is for \lstinline!zip! to ignore its arguments
and always return the empty value $e_{Q}$. However, that implementation
loses information and would fail the identity laws.

\textbf{(b)} We \emph{can} implement the type signature of \lstinline!zip!,
but only in a trivial way:
\[
\text{zip}_{F}(p^{:(A\rightarrow P)\rightarrow\bbnum 1+A}\times q^{:(B\rightarrow P)\rightarrow\bbnum 1+B})\triangleq h^{:A\times B\rightarrow P}\rightarrow\text{???}^{:\bbnum 1+A\times B}\quad.
\]
The functions $p$ and $q$ cannot be called since we cannot supply
their arguments, just as in part \textbf{(a)}. The only solution is
that \lstinline!zip! should ignore its arguments and always return
$1+\bbnum 0^{:A\times B}$. However, that implementation loses information
and would fail the identity laws.

\subsubsection*{Exercise \ref{subsec:Exercise-additional-law-of-ap}}

We define $\text{ex}_{F}(h\times g)\triangleq\text{ex}_{H}(h)$ and
obtain:
\begin{align*}
 & \text{ex}_{F}(\text{zip}_{F}(h_{1}\times g_{1}\times h_{2}\times g_{2}))=\text{ex}_{F}(\text{zip}_{H}(h_{1}\times h_{2})\times\text{zip}_{G}(g_{1}\times g_{2}))=\text{ex}_{H}(\text{zip}_{H}(h_{1}\times h_{2}))\quad,\\
 & \text{ex}_{F}(h_{1}\times g_{1})\times\text{ex}_{F}(h_{2}\times g_{2})=\text{ex}_{H}(h_{1})\times\text{ex}_{H}(h_{2})\quad.
\end{align*}
The two sides are equal due to the compatibility law of $\text{zip}_{H}$
and $\text{ex}_{H}$.

\subsubsection*{Exercise \ref{subsec:Exercise-profunctor-example}}

The first and the third occurrences of $A$ in $Q^{A}$ are contravariant
while the others are covariant. So, we define a profunctor $P^{X,Y}$
and get:
\[
P^{X,Y}\triangleq\left(X\rightarrow\text{Int}\right)\times Y\times\left(X\rightarrow Y\right)\quad,\quad\quad Q^{A}=P^{A,A}\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-applicative-II-11}(b)}

Hint: Use $P^{A}\triangleq A\rightarrow Z$ as a counterexample.

\subsection*{Chapter \ref{chap:9-Traversable-functors-and}}

\subsubsection*{Exercise \ref{subsec:Exercise-traversables-1}}

First, we express \lstinline!consume! via \lstinline!sequence! and
back:
\begin{align}
 & \text{consume}_{L}(f^{:L^{A}\rightarrow B})(p^{:L^{F^{A}}})=p\triangleright\text{seq}_{L}\triangleright f^{\uparrow F}\quad,\quad\text{or equivalently}:\quad\text{consume}_{L}(f)=\text{seq}_{L}\bef f^{\uparrow F}\quad,\label{eq:consume-via-seq}\\
 & \text{seq}_{L}=\text{consume}_{L}(\text{id}^{:L^{A}\rightarrow L^{A}})\quad.\label{eq:seq-via-consume}
\end{align}
The pattern is similar to that in Statement~\ref{subsec:Statement-tr-equivalent-to-ftr}
and to the equivalence of \lstinline!sequence! and \lstinline!traverse!.

We need to derive the equivalence between \lstinline!consume! and
\lstinline!sequence! in both directions. To figure out the necessary
naturality law, we begin with the direction that restores \lstinline!consume!
from \lstinline!sequence! because \lstinline!consume! is the more
complicated function (having two type parameters).

\textbf{(a)} Given a function \lstinline!consume!, we define \lstinline!sequence!
via Eq.~(\ref{eq:seq-via-consume}) and then define a new function
\lstinline!consume!$^{\prime}$ via Eq.~(\ref{eq:consume-via-seq}).
Then we need to show that \lstinline!consume!$^{\prime}$ equals
\lstinline!consume!. For an arbitrary $f^{:L^{A}\rightarrow B}$,
we write:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{consume}_{L}(f):}\quad & \text{consume}_{L}^{\prime}(f)=\text{seq}_{L}\bef f^{\uparrow F}=\text{consume}_{L}(\text{id})\bef f^{\uparrow F}=???
\end{align*}
If we know nothing about \lstinline!consume!, we cannot conclude
that $\text{consume}_{L}(f)\overset{?}{=}\text{consume}_{L}(\text{id})\bef f^{\uparrow F}$
because the function $f$ is arbitrary and the value $\text{consume}_{L}(f)$
does not need to be related in any way to $\text{consume}_{L}(\text{id})$.
We must use a naturality law involving a lifted function applied after
\lstinline!consume!:
\begin{equation}
\text{consume}_{L}(f^{:L^{A}\rightarrow B})\bef(g^{:B\rightarrow C})^{\uparrow F}=\text{consume}_{L}(f\bef g)\quad.\label{eq:consume-naturality-law}
\end{equation}
If this law holds, we can derive the required equation:
\[
\text{consume}_{L}^{\prime}(f)=\text{consume}_{L}(\text{id})\bef f^{\uparrow F}=\text{consume}_{L}(\text{id}\bef f)=\text{consume}_{L}(f)\quad.
\]

\textbf{(b)} Given a function \lstinline!sequence!, we first define
\lstinline!consume! via Eq.~(\ref{eq:consume-via-seq}) and then
define a new function \lstinline!sequence!$^{\prime}$ via Eq.~(\ref{eq:seq-via-consume}).
We then show that \lstinline!sequence!$^{\prime}$ equals \lstinline!sequence!:
\[
\text{seq}_{L}^{\prime}=\text{consume}_{L}(\text{id})=\text{seq}_{L}\bef\gunderline{\text{id}^{\uparrow F}}=\text{seq}\quad.
\]

If a function \lstinline!consume! is defined via \lstinline!sequence!,
the naturality law~(\ref{eq:consume-naturality-law}) will hold automatically:
\[
\text{consume}_{L}(f)\bef g^{\uparrow F}=\text{seq}_{L}\bef\gunderline{f^{\uparrow F}\bef g^{\uparrow F}}=\text{seq}_{L}\bef(f\bef g)^{\uparrow F}=\text{consume}_{L}\left(f\bef g\right)\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-traversables-laws-1}}

The naturality law of \lstinline!ftr! with respect to the type parameter
$B$ is:
\begin{equation}
\text{ftr}\,(f^{:A\rightarrow G^{B}})\bef(g^{:B\rightarrow C})^{\uparrow H}=\text{ftr}\,(f\bef g^{\uparrow G})\quad.\label{eq:ftr-right-naturality-law}
\end{equation}
The type signature of \lstinline!tr! has only one type parameter,
so \lstinline!tr! has only one naturality law:
\begin{equation}
(f^{:A\rightarrow B})^{\uparrow G\uparrow F}\bef\text{tr}=\text{tr}\bef f^{\uparrow H}\quad.\label{eq:tr-naturality-law}
\end{equation}

1) We show that the naturality law~(\ref{eq:tr-naturality-law})
of \lstinline!tr! follows from the two naturality laws of \lstinline!ftr!.
Express \lstinline!tr! as $\text{ftr}\left(\text{id}\right)$ and
substitute into the two sides of \lstinline!tr!\textsf{'}s naturality law:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & f^{\uparrow G\uparrow F}\bef\text{tr}=f^{\uparrow G\uparrow F}\bef\text{ftr}\left(\text{id}\right)\\
{\color{greenunder}\text{naturality law~(\ref{eq:ftr-left-naturality-law})}:}\quad & \quad=\text{ftr}\,(f^{\uparrow G}\bef\text{id})=\text{ftr}\,(f^{\uparrow G})\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{tr}\bef f^{\uparrow H}=\text{ftr}\left(\text{id}\right)\bef f^{\uparrow H}\\
{\color{greenunder}\text{naturality law~(\ref{eq:ftr-right-naturality-law})}:}\quad & \quad=\text{ftr}\,(\text{id}\bef f^{\uparrow G})=\text{ftr}\,(f^{\uparrow G})\quad.
\end{align*}
The two sides of the law are now equal.

2) We show that the second naturality law of \lstinline!ftr! follows
from the naturality law of \lstinline!tr!. Express \lstinline!ftr!
through \lstinline!tr! as $\text{ftr}\,(f)=f^{\uparrow F}\bef\text{tr}$,
and substitute into the two sides of \lstinline!ftr!\textsf{'}s naturality
law~(\ref{eq:ftr-right-naturality-law}): 
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \text{ftr}\,(f\big)\bef g^{\uparrow H}=f^{\uparrow F}\bef\gunderline{\text{tr}\bef g^{\uparrow H}}\\
{\color{greenunder}\text{naturality law~(\ref{eq:tr-naturality-law}) of }\text{tr}:}\quad & =f^{\uparrow F}\bef g^{\uparrow G\uparrow F}\bef\text{tr}=(f\bef g^{\uparrow G})^{\uparrow F}\bef\text{tr}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{ftr}\,(f\bef g^{\uparrow G})=(f\bef g^{\uparrow G})^{\uparrow F}\bef\text{tr}\quad.
\end{align*}
The two sides of the law are now equal.

\subsubsection*{Exercise \ref{subsec:Exercise-traversables-5}}

To verify the identity law~(\ref{eq:identity-law-of-sequence}),
set $F=\text{Id}$ in the definition~(\ref{eq:def-sequence-for-functor-composition})
of $\text{seq}_{L}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{id}:}\quad & \text{seq}_{L}^{\text{Id},A}=(\text{seq}_{N}^{\text{Id},A})^{\uparrow M}\bef\text{seq}_{M}^{\text{Id},N^{A}}\\
{\color{greenunder}\text{identity laws of }\text{seq}_{M}\text{ and }\text{seq}_{N}:}\quad & =\text{id}^{\uparrow M}\bef\text{id}=\text{id}\quad.
\end{align*}

To verify the composition law~(\ref{eq:composition-law-of-sequence}),
begin with the left-hand side:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{seq}_{L}^{F\circ G,A}:}\quad & \text{seq}_{L}^{F,G^{A}}\bef(\text{seq}_{L}^{G,A})^{\uparrow F}\\
 & \quad=(\text{seq}_{N}^{F,G^{A}})^{\uparrow M}\bef\gunderline{\text{seq}_{M}^{F,N^{G^{A}}}\bef\big((\text{seq}_{N}^{G,A})^{\uparrow M}}\bef\text{seq}_{M}^{G,N^{A}}\big)^{\uparrow F}\\
{\color{greenunder}\text{naturality law of }\text{seq}_{M}:}\quad & \quad=(\text{seq}_{N}^{F,G^{A}})^{\uparrow M}\bef(\text{seq}_{N}^{G,A})^{\uparrow F\uparrow M}\bef\text{seq}_{M}^{F,G^{N^{A}}}\bef(\text{seq}_{M}^{G,N^{A}})^{\uparrow F}\\
{\color{greenunder}\text{composition laws of }\text{seq}_{M}\text{ and }\text{seq}_{N}:}\quad & \quad=(\text{seq}_{N}^{F\circ G,A})^{\uparrow M}\bef\text{seq}_{M}^{F\circ G,N^{A}}=\text{seq}_{L}^{F\circ G,A}\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-traversables-10}}

The empty elements of the monoids $M^{R}$ and $M^{S}$ are, by definition,
$\text{pu}_{M}(e_{R})$ and $\text{pu}_{M}(e_{S})$ respectively.
The binary operations of $M^{R}$ and $M^{S}$ are:
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{M^{S}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:S}\rightarrow q\triangleright(v^{:S}\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\quad.
\end{align*}
To verify the properties of the monoid morphism, begin with the identity
law:
\begin{align*}
{\color{greenunder}\text{expect to equal }e_{M^{S}}:}\quad & \gunderline{e_{M^{R}}}\triangleright\phi^{\uparrow M}=e_{R}\triangleright\gunderline{\text{pu}_{M}\triangleright\phi^{\uparrow M}}=\gunderline{e_{R}\triangleright\phi}\triangleright\text{pu}_{M}=e_{S}\triangleright\text{pu}_{M}=e_{M^{S}}\quad.
\end{align*}
Now check the composition law. For any $p^{:M^{R}}$ and $q^{:M^{R}}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}:}\quad & (p\triangleright\phi^{\uparrow M})\underset{M^{S}}{\oplus}(q\triangleright\phi^{\uparrow M})\\
 & =(p\triangleright\gunderline{\phi^{\uparrow M})\triangleright\text{flm}_{M}}\big(u\rightarrow q\triangleright\phi^{\uparrow M}\triangleright(v\rightarrow u\oplus_{S}v)^{\uparrow M}\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(\gunderline{\phi\bef(}v\rightarrow\phi(u)\oplus_{S}v))^{\uparrow M}\big)\\
{\color{greenunder}\text{compute composition}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\gunderline{\phi(u)\oplus_{S}\phi(v)}))^{\uparrow M}\big)\\
{\color{greenunder}\text{composition law of }\phi:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow\phi(u\oplus_{R}v))^{\uparrow M}\big)\\
{\color{greenunder}\text{move }\phi^{\uparrow M}\text{ outside}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi^{\uparrow M}\big)\\
{\color{greenunder}\text{naturality of }\text{flm}_{M}:}\quad & =\gunderline{p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)}\bef\phi^{\uparrow M}\\
 & =(p\underset{M^{R}}{\oplus}q)\triangleright\phi^{\uparrow M}\quad.
\end{align*}


\subsubsection*{Exercise \ref{subsec:Exercise-traversables-10-1}}

The empty elements of the monoids $M^{R}$ and $N^{R}$ are, by definition,
are $\text{pu}_{M}(e_{R})$ and $\text{pu}_{N}(e_{R})$ respectively.
The binary operations of $M^{R}$ and $N^{R}$ are:
\begin{align*}
 & p\underset{M^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{M}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\quad,\\
 & p\underset{N^{R}}{\oplus}q\triangleq p\triangleright\text{flm}_{N}\big(u^{:R}\rightarrow q\triangleright(v^{:R}\rightarrow u\oplus_{R}v)^{\uparrow N}\big)\quad.
\end{align*}
To verify the properties of the monoid morphism, begin with the identity
law:
\begin{align*}
{\color{greenunder}\text{expect to equal }e_{N^{R}}:}\quad & \gunderline{e_{M^{R}}}\triangleright\phi=\gunderline{e_{R}\triangleright\text{pu}_{M}}\triangleright\phi=e_{R}\triangleright\text{pu}_{N}=e_{N^{R}}\quad.
\end{align*}
Now check the composition law. For any $p^{:M^{R}}$ and $q^{:M^{R}}$:
\begin{align*}
{\color{greenunder}\text{expect to equal }(p\underset{M^{R}}{\oplus}q)\triangleright\phi:}\quad & (p\triangleright\phi)\underset{N^{R}}{\oplus}(q\triangleright\phi)=(p\triangleright\phi)\triangleright\text{flm}_{N}\big(u\rightarrow q\triangleright\gunderline{\phi\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow N}}\big)\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =p\triangleright\gunderline{\phi\bef\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\bef\phi\big)^{\uparrow N}}\bef\text{ftn}_{N}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)^{\uparrow M}\bef\gunderline{\phi\bef\phi^{\uparrow N}\bef\text{ftn}_{N}}\\
{\color{greenunder}\text{composition law of }\phi:}\quad & =p\triangleright\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\gunderline{\big)^{\uparrow M}\bef\text{ftn}_{M}}\bef\phi\\
{\color{greenunder}\text{definition of }\text{ftn}_{M}:}\quad & =p\triangleright\text{flm}_{M}\big(u\rightarrow q\triangleright(v\rightarrow u\oplus_{R}v)^{\uparrow M}\big)\bef\phi=(p\underset{M^{R}}{\oplus}q)\triangleright\phi\quad.
\end{align*}


\subsection*{Chapter \ref{chap:monad-transformers}}

\subsubsection*{Exercise \ref{subsec:Exercise-monad-transformer-extra-layer}}

The identity law of monad morphisms is:
\[
\text{pu}_{\text{Id}}\bef\phi=\text{pu}_{M}\quad.
\]
Since $\text{pu}_{\text{Id}}=\text{id}$, we get $\phi=\text{pu}_{M}$.
So, there can be no other monad morphisms $\text{Id}\leadsto M$.

\subsubsection*{Exercise \ref{subsec:Exercise-monad-transformer-extra-layer-5}}

The identity law of monad morphisms says that $\text{pu}_{\bbnum 1}\bef\phi=\text{pu}_{M}$.
However, $\text{pu}_{\bbnum 1}=\_^{:A}\rightarrow1$ and ignores its
argument. So, $\text{pu}_{M}$ is also a function that ignores its
argument. By the monad $M$\textsf{'}s left identity law, $\text{pu}_{M}\bef\text{ftn}_{M}=\text{id}^{:M^{A}\rightarrow M^{A}}$.
So, the identity function $\text{id}:M^{A}\rightarrow M^{A}$ ignores
its argument. It always returns the same value of type $M^{A}$, say
$m_{0}$. It follows that the type $M^{A}$ has only one distinct
value, namely $m_{0}$. So $M^{A}\cong\bbnum 1$. This argument holds
for each type $A$. 

\subsubsection*{Exercise \ref{subsec:Exercise-monad-transformer-extra-layer-3}}

\textbf{(a)} For any monad morphism $\phi:M\leadsto N$, the monadic
naturality law must hold:
\[
\text{dbl}\bef\phi\overset{?}{=}\phi\bef\text{dbl}\quad.
\]
The left-hand side applied to an arbitrary value $m^{:M^{A}}$ is:
\begin{align*}
 & m\triangleright\text{dbl}\bef\phi=m\triangleright(\_\rightarrow m)^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\phi}\\
{\color{greenunder}\text{monad morphism law of }\phi:}\quad & =m\triangleright\gunderline{(\_\rightarrow m)^{\uparrow M}\bef\phi^{\uparrow M}}\bef\phi\bef\text{ftn}_{M}\\
{\color{greenunder}\text{compute composition}:}\quad & =m\triangleright\gunderline{(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\phi}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{naturality of }\phi:}\quad & =m\triangleright\phi\bef(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}
The right-hand side applied to $m$ is:
\begin{align*}
 & m\triangleright\phi\bef\text{dbl}=m\triangleright\phi\triangleright\text{dbl}=m\triangleright\phi\triangleright(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =m\triangleright\phi\bef(\_\rightarrow m\triangleright\phi)^{\uparrow M}\bef\text{ftn}_{M}\quad.
\end{align*}
Both sides are now equal.

\textbf{(b)} The identity law holds:
\[
a\triangleright\text{pu}_{M}\bef\text{dbl}=a\triangleright\text{pu}_{M}\triangleright\text{flm}_{M}(\_\rightarrow a\triangleright\text{pu}_{M})=a\triangleright(\_\rightarrow a\triangleright\text{pu}_{M})=a\triangleright\text{pu}_{M}\quad.
\]
The composition law:
\[
\text{dbl}^{\uparrow M}\bef\text{dbl}\bef\text{ftn}_{M}\overset{?}{=}\text{ftn}_{M}\bef\text{dbl}\quad.
\]
Simplify the left-hand side, applying to an arbitrary value $p:M^{M^{A}}$.
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & p\triangleright\text{dbl}^{\uparrow M}\bef\text{dbl}\bef\text{ftn}_{M}=p\triangleright\text{dbl}^{\uparrow M}\triangleright(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})^{\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{associativity law of }M:}\quad & =p\triangleright\text{dbl}^{\uparrow M}\bef(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})^{\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\big(\text{dbl}\bef(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M})\bef\text{ftn})\big)^{\uparrow M}\bef\text{ftn}_{M}=p\triangleright\big(\_\rightarrow p\triangleright\text{dbl}^{\uparrow M}\bef\text{ftn}_{M})\big)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\text{flm}_{M}\big(\_\rightarrow p\triangleright\text{flm}_{M}(\text{dbl})\big)\quad.
\end{align*}
The right-hand side:
\begin{align*}
{\color{greenunder}\text{right-hand side}:}\quad & p\triangleright\text{ftn}_{M}\bef\text{dbl}=p\triangleright\gunderline{\text{ftn}_{M}\bef(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M}}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{naturality of }\text{ftn}_{M}:}\quad & =p\triangleright(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\gunderline{\text{ftn}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{associativity law of }M:}\quad & =p\triangleright(\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M\uparrow M}\bef\text{ftn}_{M}^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\big((\_\rightarrow p\triangleright\text{ftn}_{M})^{\uparrow M}\bef\text{ftn}_{M}\big)^{\uparrow M}\bef\text{ftn}_{M}\\
 & =p\triangleright\text{flm}_{M}\big(\text{flm}_{M}(\_\rightarrow p\triangleright\text{ftn}_{M})\big)\quad.
\end{align*}
The simplification is stuck \textemdash{} we cannot make the two sides
coincide; no law can be applied to simplify further.

Choosing specific values $p=\text{pu}_{M}(m)$ or $p=\text{pu}_{M}^{\uparrow M}(m)$
does not help to obtain a counter-example: the laws hold for those
specific choices.

To obtain a counter-example, consider a specific non-commutative monad,
such as \lstinline!List!. For the \lstinline!List! monad, the \lstinline!double!
function repeats the entire list as many times as elements in the
list:
\begin{lstlisting}
scala> double(List(1, 2))
res0: List[Int] = List(1, 2, 1, 2)

scala> val ll = List(List(1, 2), List(3))
ll: List[List[Int]] = List(List(1, 2), List(3))

scala> double(ll.flatten)
res1: List[Int] = List(1, 2, 3, 1, 2, 3, 1, 2, 3)

scala> double(ll.map(double))
res2: List[List[Int]] = List(List(1, 2, 1, 2), List(3), List(1, 2, 1, 2), List(3)) 

scala> double(ll.map(double)).flatten
res3: List[Int] = List(1, 2, 1, 2, 3, 1, 2, 1, 2, 3)
\end{lstlisting}
The composition law does not hold.

\subsubsection*{Exercise \ref{subsec:Statement-search-and-selector-monads}}

The identity law does not hold:
\begin{align*}
{\color{greenunder}\text{expect to equal }a\triangleright\text{pu}_{\text{Search}}:}\quad & a\triangleright\text{pu}_{\text{Sel}}\bef\text{finder}=(\_^{:A\rightarrow\bbnum 1+P}\rightarrow a)\triangleright\text{finder}\\
 & =p\rightarrow p(a)\triangleright\,\begin{array}{|c||cc|}
 & \bbnum 1 & A\\
\hline \bbnum 1 & \text{id} & \bbnum 0\\
P & \bbnum 0 & a
\end{array}\,=p\rightarrow a\triangleright p\bef(\_\rightarrow a)^{\uparrow\text{Opt}}\neq p\rightarrow\bbnum 0+a\quad.
\end{align*}
The result should have been $\text{pu}_{\text{Search}}(a)=\_\rightarrow\text{pu}_{\text{Opt}}(a)=\_\rightarrow\bbnum 0+a$.

\subsubsection*{Exercise \ref{subsec:Exercise-selector-and-continuation-monads}}

To verify the identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }a\triangleright\text{pu}_{\text{Cont}}:}\quad & a\triangleright\text{pu}_{\text{Sel}}\bef\text{scc}=f\rightarrow f(f\triangleright(\gunderline{a\triangleright\text{pu}_{\text{Sel}}}))\\
{\color{greenunder}\text{use definition of }\text{pu}_{\text{Sel}}:}\quad & =f\rightarrow f(f\triangleright(\_\rightarrow a))=f\rightarrow f(a)=a\triangleright\text{pu}_{\text{Cont}}\quad.
\end{align*}
To verify the composition law, we begin with the flipped Kleisli formulation
of the two monads. The flipped Kleisli functions have types $\left(B\rightarrow P\right)\rightarrow A\rightarrow P$
(for \lstinline!Cont!) and $\left(B\rightarrow P\right)\rightarrow A\rightarrow B$
(for \lstinline!Sel!).
\begin{align*}
 & f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow P}\tilde{\diamond}_{_{\text{Cont}}}g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow P}\triangleq h^{:C\rightarrow P}\rightarrow h\triangleright g\triangleright f=g\bef f\quad,\\
 & f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow B}\tilde{\diamond}_{_{\text{Sel}}}g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow C}\triangleq h^{:C\rightarrow P}\rightarrow f(g(h)\bef h)\bef g(h)\quad.
\end{align*}
We need to check that \lstinline!Sel!\textsf{'}s Kleisli composition ($\tilde{\diamond}_{_{\text{Sel}}}$)
is mapped to \lstinline!Cont!\textsf{'}s Kleisli composition ($\tilde{\diamond}_{_{\text{Cont}}}$).
First, we need to modify \lstinline!scc! so that it works on the
flipped Kleisli functions:
\[
\tilde{\text{scc}}^{A,B}:\left(\left(B\rightarrow P\right)\rightarrow A\rightarrow B\right)\rightarrow\left(B\rightarrow P\right)\rightarrow A\rightarrow P\quad,\quad\tilde{\text{scc}}=c^{:\left(\left(B\rightarrow P\right)\rightarrow A\rightarrow B\right)}\rightarrow k^{:B\rightarrow P}\rightarrow c(k)\bef k\quad.
\]

Note that the implementation of \lstinline!scc! is uniquely determined
by its type signature, and so is the implementation of $\tilde{\text{scc}}$.
So, we can spare ourselves the effort of translating $\text{scc}$
into $\tilde{\text{scc}}$.

Now it remains to show that for any $f^{:\left(B\rightarrow P\right)\rightarrow A\rightarrow B}$
and $g^{:\left(C\rightarrow P\right)\rightarrow B\rightarrow C}$
the law holds:
\[
(f\triangleright\tilde{\text{scc}}^{A,B})\tilde{\diamond}_{_{\text{Cont}}}(g\triangleright\tilde{\text{scc}}^{B,C})=(f\tilde{\diamond}_{_{\text{Sel}}}g)\triangleright\tilde{\text{scc}}^{A,C}\quad.
\]
Rewrite the two sides of the law separately:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & (f\triangleright\tilde{\text{scc}})\tilde{\diamond}_{_{\text{Cont}}}(g\triangleright\tilde{\text{scc}})=(g\triangleright\tilde{\text{scc}})\bef(f\triangleright\tilde{\text{scc}})=(k\rightarrow g(k)\bef k)\bef(h\rightarrow f(h)\bef h)\\
 & \quad=k\rightarrow f(g(k)\bef k)\bef g(k)\bef k\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & (f\tilde{\diamond}_{_{\text{Sel}}}g)\triangleright\tilde{\text{scc}}=\big(h\rightarrow f(g(h)\bef h)\bef g(h)\big)\triangleright\tilde{\text{scc}}=k\rightarrow\big(h\rightarrow f(g(h)\bef h)\bef g(h)\big)(k)\bef k\\
 & \quad=k\rightarrow f(g(k)\bef k)\bef g(k)\bef k\quad.
\end{align*}
Both sides are now equal.

\subsubsection*{Exercise \ref{par:Exercise-mt-3-1}}

The operations $\text{pu}_{N}$ and $\text{ftn}_{N}$ are defined
by:
\[
\text{pu}_{N}\triangleq\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\quad,\quad\quad\text{ftn}_{N}\triangleq\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\]

To verify the identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{M}:}\quad & \text{pu}_{N}\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\text{pu}_{M}\quad.
\end{align*}
To verify the composition law, transform separately the two sides
of the law:
\begin{align*}
{\color{greenunder}\text{left-hand side}:}\quad & \gamma_{M}\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{N^{A}}\\
\hline N^{A} & \text{pu}_{M}\\
M^{N^{A}} & \text{id}
\end{array}\,\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline N^{A} & \gunderline{\text{pu}_{M}\bef\gamma_{M}^{\uparrow M}}\bef\text{ftn}_{M}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\\
 & \quad=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline N^{A} & \gamma_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad,\\
{\color{greenunder}\text{right-hand side}:}\quad & \text{ftn}_{N}\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}\\
M^{N^{A}} & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\end{align*}
The two sides are now equal.

\subsubsection*{Exercise \ref{par:Exercise-mt-3}}

The operations $\text{ftn}_{L}$ and $\text{ftn}_{N}$ are defined
as usual for a free pointed monad:
\begin{align*}
 & \text{ftn}_{L}\triangleq\,\begin{array}{|c||c|}
 & L^{A}\\
\hline L^{A} & \text{id}\\
K^{L^{A}} & k\rightarrow\bbnum 0+k\triangleright\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\quad,\\
 & \text{ftn}_{N}\triangleq\,\begin{array}{|c||c|}
 & N^{A}\\
\hline N^{A} & \text{id}\\
M^{N^{A}} & m\rightarrow\bbnum 0+m\triangleright\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad.
\end{align*}

We define $\psi$ by:
\[
\psi=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\quad.
\]

To verify the identity law for $\psi$:
\[
\text{pu}_{L}\bef\psi=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0
\end{array}\,=\text{pu}_{N}\quad.
\]

To verify the composition law for $\psi$, write both sides of the
law separately:
\begin{align*}
\psi^{\uparrow L}\bef\psi\bef\text{ftn}_{N} & =\,\begin{array}{|c||ccc|}
 & A & M^{A} & K^{N^{A}}\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
K^{A} & \bbnum 0 & \phi & \bbnum 0\\
K^{L^{A}} & \bbnum 0 & \bbnum 0 & \psi^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||ccc|}
 & A & M^{A} & M^{N^{A}}\\
\hline A & \text{id} & \bbnum 0 & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id} & \bbnum 0\\
K^{N^{A}} & \bbnum 0 & \bbnum 0 & \phi
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
M^{A} & \bbnum 0 & \text{id}\\
M^{N^{A}} & \bbnum 0 & \gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\\
 & =\,\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi\\
K^{L^{A}} & \bbnum 0 & \psi^{\uparrow K}\bef\phi\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}
\end{array}\quad,\\
\text{ftn}_{L}\bef\psi & =\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,\bef\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi
\end{array}\quad.
\end{align*}
It remains to show that:
\[
\psi^{\uparrow K}\bef\phi\bef\gamma_{M}^{\uparrow M}\bef\text{ftn}_{M}\overset{?}{=}\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\phi\quad.
\]
The monad morphism law for $\phi$ gives:
\[
\phi\bef\phi^{\uparrow M}\bef\text{ftn}_{M}=\text{ftn}_{K}\bef\phi\quad.
\]
It remains to show that:
\begin{align*}
 & \gunderline{\psi^{\uparrow K}\bef\phi}\bef\gamma_{M}^{\uparrow M}\overset{?}{=}\gunderline{\gamma_{K}^{\uparrow K}\bef\phi}\bef\phi^{\uparrow M}\quad.\\
 & \phi\bef\psi^{\uparrow M}\bef\gamma_{M}^{\uparrow M}=\phi\bef(\psi\bef\gamma_{M})^{\uparrow M}\overset{?}{=}\phi\bef\gamma_{K}^{\uparrow M}\bef\phi^{\uparrow M}=\phi\bef(\gamma_{K}\bef\phi)^{\uparrow M}\quad.
\end{align*}
It remains to show that $\psi\bef\gamma_{M}=\gamma_{K}\bef\phi$.
For that, we use the identity law of $\phi$:
\begin{align*}
 & \psi\bef\gamma_{M}=\,\begin{array}{|c||cc|}
 & A & M^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \phi
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
M^{A} & \text{id}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \phi
\end{array}\quad,\\
 & \gamma_{K}\bef\phi=\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\,\bef\phi=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \gunderline{\text{pu}_{K}\bef\phi}\\
K^{A} & \phi
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \phi
\end{array}\quad.
\end{align*}


\subsubsection*{Exercise \ref{par:Exercise-mt-3-3}}

\textbf{(a)} Verify the naturality law of $\psi$, assuming the naturality
laws of $\phi$ and $\chi$:
\begin{align*}
 & (f^{:A\rightarrow B})^{\uparrow(K+L)}\bef\psi=\,\begin{array}{|c||cc|}
 & K^{B} & L^{B}\\
\hline K^{A} & f^{\uparrow K} & \bbnum 0\\
L^{A} & \bbnum 0 & f^{\uparrow L}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{B} & \phi\\
L^{B} & \chi
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \gunderline{f^{\uparrow K}\bef\phi}\\
L^{A} & \gunderline{f^{\uparrow L}\bef\chi}
\end{array}\,=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \phi\bef f^{\uparrow M}\\
L^{A} & \chi\bef f^{\uparrow M}
\end{array}\quad,\\
 & \psi\bef f^{\uparrow M}=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline K^{A} & \phi\\
L^{A} & \chi
\end{array}\,\bef f^{\uparrow M}=\,\begin{array}{|c||c|}
 & M^{B}\\
\hline K^{A} & \phi\bef f^{\uparrow M}\\
L^{A} & \chi\bef f^{\uparrow M}
\end{array}\quad.
\end{align*}

\textbf{(b)} Given the definitions of $\phi$ and $\chi$, we can
write $\psi$ as:
\[
\psi=\,\begin{array}{|c||c|}
 & M^{A}\\
\hline K^{A} & \phi\\
L^{A} & \chi
\end{array}\quad.
\]
Assuming the naturality law of $\psi$, verify the naturality law
of $\phi$ by applying to an arbitrary value $k^{:K^{A}}$ and expressing
$f^{\uparrow K}$ through $f^{\uparrow(K+L)}$: 
\begin{align*}
{\color{greenunder}\text{expect to equal }k\triangleright\phi\bef f^{\uparrow M}:}\quad & k\triangleright f^{\uparrow K}\bef\phi=k\triangleright f^{\uparrow K}\triangleright(k\rightarrow k+\bbnum 0)\triangleright\psi=\big((k\triangleright f^{\uparrow K})+\bbnum 0\big)\triangleright\psi\\
 & =(k+\bbnum 0)\triangleright\,\begin{array}{|c||cc|}
 & K^{B} & L^{B}\\
\hline K^{A} & f^{\uparrow K} & \bbnum 0\\
L^{A} & \bbnum 0 & f^{\uparrow L}
\end{array}\,\bef\psi=(k+\bbnum 0)\triangleright\gunderline{f^{\uparrow(K+L)}\bef\psi}\\
{\color{greenunder}\text{naturality law of }\psi:}\quad & =(\gunderline{k+\bbnum 0})\triangleright\psi\bef f^{\uparrow M}=k\triangleright\gunderline{(x\rightarrow x+\bbnum 0)\bef\psi}\bef f^{\uparrow M}=k\triangleright\phi\bef f^{\uparrow M}\quad.
\end{align*}

The proof of the naturality law of $\chi$ is analogous.

\subsubsection*{Exercise \ref{par:Exercise-mt-3-2-1}}

\textbf{(a)} Choose the monads $K^{A}\triangleq R\rightarrow A$ and
$M^{A}\triangleq S\rightarrow A$, where $R$, $S$ are fixed (but
arbitrary) types. Define $P^{A}\triangleq A+T_{K}^{M,A}$ and show
that there exist no monad morphisms $\phi:M^{A}\rightarrow P^{A}$.
If such $\phi$ exists, it must satisfy the identity law, $\text{pu}_{M}\bef\phi=\text{pu}_{P}$.
The type signature of $\phi$ is:
\[
\phi:(R\rightarrow A)\rightarrow A+(S\rightarrow R\rightarrow A)\quad.
\]
The only fully parametric implementation is:
\[
\phi:f^{:R\rightarrow A}\rightarrow\bbnum 0+(\_^{:S}\rightarrow f)\quad,
\]
because we cannot produce values of type $A+\bbnum 0$ since we cannot
create values of the unknown type $R$. However, this implementation
of $\phi$ does not satisfy the identity law since $\text{pu}_{P}$
must return values of type $A+\bbnum 0$.

\textbf{(b)} Given $\theta_{K}:K^{A}\rightarrow M^{A}$, we define:
\[
\theta_{L}:L^{A}\rightarrow M^{A}\quad,\quad\quad\theta_{L}\triangleq\,\begin{array}{|c||c|}
 & M^{A}\\
\hline A & \text{pu}_{M}\\
K^{A} & \theta_{K}
\end{array}\quad.
\]
The proof becomes shorter if we express $\theta_{L}$ as:
\[
\theta_{L}=\gamma_{K}\bef\theta_{K}\quad,\quad\quad\gamma_{K}\triangleq\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\quad.
\]
We already know that $\gamma_{K}:L\leadsto K$ is a monad morphism
(Exercise~\ref{par:Exercise-mt-3-1}). So, $\theta_{L}$ is a composition
of monad morphisms.

\textbf{(c)} Choose $K^{A}\triangleq\bbnum 1$ (the unit monad) and
note that $L^{A}=A+\bbnum 1$ is the standard \lstinline!Option!
monad (there are no other lawful monad implementations for the type
constructor $L^{A}\triangleq A+\bbnum 1$). Choose $M\triangleq L$,
so that a monad morphism $\theta_{L}\triangleq\text{id}^{:L\leadsto M}$
exists. If it were possible to define a monad morphism $K\leadsto M$,
we would have a monad morphism $\bbnum 1\rightarrow\bbnum 1+A$, but
this is impossible: the only natural transformation of type $\bbnum 1\rightarrow\bbnum 1+A$
is $1\rightarrow1+\bbnum 0$, which does not satisfy the identity
law of monad morphisms, $\text{pu}_{K}\bef\theta_{K}=\text{pu}_{M}$,
since it never returns any values of type $\bbnum 0+A$. (Generally,
the existence of a monad morphism $\bbnum 1\leadsto M$ means that
$M=\bbnum 1$.)

\textbf{(d)} By Exercise~\ref{par:Exercise-mt-3-3}, we have a natural
transformation $\theta_{K}:K^{A}\rightarrow A$ defined by:
\[
\theta_{K}\triangleq(k\rightarrow\bbnum 0+k)\bef\theta_{L}\quad.
\]
The given runner $\theta_{L}$ is then expressed through $\theta_{K}$
as:
\[
\theta_{L}=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\quad,
\]
because the natural transformation in the upper row of the matrix
has the type signature $A\rightarrow A$ and so must be an identity
function.

It remains to verify the monad morphism laws of $\theta_{K}:K\leadsto\text{Id}$.
The identity law is:
\[
\text{pu}_{K}\bef\theta_{K}\overset{?}{=}\text{pu}_{\text{Id}}=\text{id}\quad.
\]
 Since the function $p\triangleq\text{pu}_{K}\bef\theta_{K}$ has
type signature $A\rightarrow A$ and is a natural transformation (as
a composition of two natural transformations), that function must
satisfy $p\bef f=f\bef p$ for any function $f^{:A\rightarrow B}$,
and so $p$ must be equal to the identity function.

The composition law of $\theta_{K}$ is an equation for functions
of type $K^{K^{A}}\rightarrow A$:
\[
\text{ftn}_{K}\bef\theta_{K}\overset{?}{=}\theta_{K}^{\uparrow K}\bef\theta_{K}\bef\text{ftn}_{\text{Id}}=\theta_{K}\bef\theta_{K}\quad.
\]
Applied to an arbitrary value $k:K^{K^{A}}$, this law becomes:
\[
k\triangleright\text{ftn}_{K}\bef\theta_{K}\overset{?}{=}k\triangleright\theta_{K}^{\uparrow K}\bef\theta_{K}\quad.
\]
Since $\theta_{K}$ is defined via $\theta_{L}$, we need to use the
composition law of $\theta_{L}$:
\[
\text{ftn}_{L}\bef\theta_{L}\overset{!}{=}\theta_{L}^{\uparrow L}\bef\theta_{L}\bef\text{ftn}_{\text{Id}}=\theta_{L}^{\uparrow K}\bef\theta_{L}\quad.
\]
Rewrite this law as:
\begin{align*}
 & \text{ftn}_{L}\bef\theta_{L}=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}\\
K^{L^{A}} & \gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}
\end{array}\quad,\\
 & \theta_{L}^{\uparrow L}\bef\theta_{L}=\,\begin{array}{|c||cc|}
 & A & K^{A}\\
\hline A & \text{id} & \bbnum 0\\
K^{A} & \bbnum 0 & \text{id}\\
K^{L^{A}} & \bbnum 0 & \theta_{L}^{\uparrow K}
\end{array}\,\bef\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}
\end{array}\,=\,\begin{array}{|c||c|}
 & A\\
\hline A & \text{id}\\
K^{A} & \theta_{K}\\
K^{L^{A}} & \theta_{L}^{\uparrow K}\bef\theta_{K}
\end{array}\quad.
\end{align*}
The third rows of the matrices give the equation for functions of
type $K^{L^{A}}\rightarrow A$:
\[
\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}\theta_{L}^{\uparrow K}\bef\theta_{K}\quad.
\]
Apply both sides of this equation to an arbitrary value $p$ of type
$K^{\bbnum 0+K^{A}}$, defined via an arbitrary value $k^{:K^{K^{A}}}$
as $p\triangleq k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}$:
\begin{align*}
 & p\triangleright\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}p\triangleright\theta_{L}^{\uparrow K}\bef\theta_{K}\quad,\\
{\color{greenunder}\text{or equivalently}:}\quad & k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}\bef\gamma_{K}^{\uparrow K}\bef\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}k\triangleright(x\rightarrow\bbnum 0+x)^{\uparrow K}\bef\theta_{L}^{\uparrow K}\bef\theta_{K}\quad.
\end{align*}
We compute some sub-expressions separately:
\begin{align*}
 & (x\rightarrow\bbnum 0+x)\bef\gamma_{K}=(x\rightarrow\bbnum 0+x)\bef\,\begin{array}{|c||c|}
 & K^{A}\\
\hline A & \text{pu}_{K}\\
K^{A} & \text{id}
\end{array}\,=x\rightarrow x=\text{id}\quad,\\
 & (x\rightarrow\bbnum 0+x)\bef\theta_{L}=\theta_{K}\quad.
\end{align*}
After these simplifications, the composition law of $\theta_{L}$
gives:
\[
k\triangleright\text{ftn}_{K}\bef\theta_{K}\overset{!}{=}k\triangleright\theta_{K}^{\uparrow K}\bef\theta_{K}\quad.
\]
This is the composition law of $\theta_{K}$.

\subsubsection*{Exercise \ref{par:Exercise-mt-3-2}}

Consider the monad morphism $\varepsilon:K\leadsto\bbnum 1$ defined
by $\varepsilon\triangleq\_\rightarrow1$. (This is a monad morphism
because all its laws reduce to the equation $1=1$.) By Exercise~\ref{par:Exercise-mt-3},
we can implement a corresponding monad morphism between free pointed
monads $\text{Id}+K\leadsto\text{Id}+\bbnum 1$. Define $\delta$
as that monad morphism. The monad $\text{Id}+\bbnum 1$ (the free
pointed monad on $\bbnum 1$) is the standard \lstinline!Option!
monad. So, we have implemented a monad morphism $\delta:A+K^{A}\rightarrow\text{Opt}^{A}$.

\subsubsection*{Exercise \ref{subsec:Exercise-effectful-list-not-monad}}

\textbf{(a)} Consider the requirement of mapping $L^{L^{A}}\rightarrow L^{A}$
via a \lstinline!flatten! function:
\[
\text{ftn}_{L}:\bbnum 1+L^{A}\times M^{L^{L^{A}}}\rightarrow\bbnum 1+A\times M^{L^{A}}\quad,\quad\quad\text{ftn}_{L}=\text{???}
\]
The result value of this function cannot always be $1$, or else it
will fail the monad laws. This function must sometimes return a pair
of type $A\times M^{L^{A}}$. Let us rewrite the type signature of
\lstinline!flatten! as
\[
\text{ftn}_{L}:\bbnum 1+(\bbnum 1+A\times M^{L^{A}})\times M^{L^{L^{A}}}\rightarrow\bbnum 1+A\times M^{L^{A}}\quad.
\]
Consider input values of the form:
\[
x\triangleq\bbnum 0^{:\bbnum 1}+(1+\bbnum 0^{:A\times M^{L^{A}}})\times m^{:M^{L^{L^{A}}}}\quad.
\]
the result of evaluating $\text{ftn}_{L}(x)$ must be $1+\bbnum 0$:
a fully parametric function cannot extract values of type $A$ from
a value of type $M^{A}$ with an unknown monad $M$. Note that the
value $(1+\bbnum 0^{:A\times M^{L^{A}}})$ represents an empty list;
let us denote that value by $\text{Nil}^{:L^{A}}$. So, we must have:
\[
\text{ftn}_{L}(\bbnum 0+\text{Nil}\times(...))=\text{Nil}\quad.
\]
Since the only way to extract list values is to run the $M$-effects,
the implementation of $\text{ftn}_{L}$ must proceed recursively,
extracting list elements left to right. Now consider $M=\text{Id}$
(so we can simply omit the functor layers of $M$) and the nested
list value:
\[
z\triangleq\left[p,q,\text{Nil},r,s,...\right]\quad,
\]
 where $p$, $q$, $r$, $s$ are some sub-lists of type $L^{A}$
with some type $A$. Then the value $z$ has the form:
\[
z=\bbnum 0+p\times(\bbnum 0+q\times(\bbnum 0+\text{Nil}\times(\bbnum 0+r\times(\bbnum 0+s\times(1+\bbnum 0)))))\quad.
\]
As we must have $\text{ftn}_{L}(\bbnum 0+\text{Nil}\times t)=\text{Nil}$
for any $t^{:M^{L^{L^{A}}}}$, the recursive evaluation of $\text{ftn}_{L}(z)$
will give:
\[
\text{ftn}_{L}(z)=...\text{ftn}_{L}(\bbnum 0+\text{Nil}\times(\bbnum 0+r\times(\bbnum 0+s\times(1+\bbnum 0))))=...\text{Nil}\quad.
\]
So, the result may be some function of $p$ and $q$ (which could
be $p\pplus q$) but cannot depend on $r$ and $s$. We have shown
that $\text{ftn}_{L}$ must ignore all sub-lists that follow an empty
sub-list. A possible behavior of $\text{ftn}_{L}$ is:
\[
\text{ftn}_{L}(\left[\left[1,2\right],\left[3,4\right],\left[\right],\left[5,6,7,8\right]\right])=\left[1,2,3,4\right]\quad,
\]
instead of the full flattened list $\left[1,2,3,4,5,6,7,8\right]$.
Regardless of how we implement $\text{ftn}_{L}$ (and whether it satisfies
the monad laws), the result of evaluating $\text{ftn}_{L}(z)$ cannot
be the full concatenation $p\pplus q\pplus r\pplus s$ because the
computation must ignore the sub-lists $r$ and $s$.

\textbf{(b)} The code for the non-standard \lstinline!flatten! function
is:
\begin{lstlisting}[mathescape=true]
def flatten[A](p: List[List[A]]): List[A] = p.takeWhile(_.nonEmpty).flatten  // $\color{dkgreen}\textrm{ftn}_L$
\end{lstlisting}
The new \lstinline!flatten! function gives  the same results as \lstinline!List!\textsf{'}s
standard \lstinline!flatten! method, except if one of the nested
sub-lists is empty. Then the \lstinline!flatten! function truncates
the result after the first empty sub-list.

It turns out that this code fails the monad\textsf{'}s associativity law of
\lstinline!flatten!. That law is an equality of functions $\text{ftn}_{L}\bef\text{ftn}_{L}$
and $\text{ftn}_{L}^{\uparrow L}\bef\text{ftn}_{L}$ of type \lstinline!List[List[List[A]]] => List[A]!.
The failure is found when a value $p$ of type \lstinline!List[List[List[A]]]!
contains a nested empty list at the \emph{second} nesting depth, following
some non-empty lists. Here is an example that triggers the failure
of the law:
\begin{lstlisting}
val p: List[List[List[Int]]] = List(List(List(1, 2, 3)), List(List(4), Nil), List(List(5, 6)))
\end{lstlisting}
Here the nested list \lstinline!List(List(4), Nil)! contains an empty
list (\lstinline!Nil!) after a non-empty list. Applying both sides
of the law to \lstinline!p!, we find that the two sides of the law
are not equal:
\begin{lstlisting}
scala> flatten(flatten(p))
res0: List[List[Int]] = List(1, 2, 3, 4)

scala> flatten(p.map(flatten))
res1: List[List[Int]] = List(1, 2, 3, 4, 5, 6)
\end{lstlisting}

\textbf{(c)} Try implementing the method $\text{flift}:M^{A}\rightarrow L^{A}$.
The function \lstinline!flift! must produce a value of type $L^{A}\cong\bbnum 1+A\times M^{L^{A}}$.
Since $M$ is an arbitrary monad, we cannot extract a value of type
$A$ out of $M^{A}$ while keeping the code fully parametric. So,
we can implement \lstinline!flift! only by defining $\text{flift}\triangleq\_^{:M^{A}}\rightarrow\text{Nil}^{:L^{A}}$.
However, that implementation loses information and fails the identity
law:
\[
\text{pu}_{M}\bef\text{flift}=(\_\rightarrow\text{Nil})\neq\text{pu}_{L}\quad.
\]


\subsubsection*{Exercise \ref{subsec:Exercise-combined-codensity-monad}}

\textbf{(a)} Denote for brevity $\text{Cod}_{F}^{M,A}\triangleq C^{A}$.
The naturality law for functions $c^{:C^{A}}$ says that for any $k^{:A\rightarrow F^{X}}$
and $q^{:X\rightarrow Y}$, we have:
\[
(k^{:A\rightarrow F^{X}}\bef q^{\uparrow F})\triangleright c^{Y}=k\triangleright c^{X}\bef q^{\uparrow M\uparrow F}\quad.
\]

The flipped Kleisli method $\tilde{\text{pu}}_{C}$ is defined by:
\[
\tilde{\text{pu}}_{C}:\forall X.\,(A\rightarrow F^{X})\rightarrow A\rightarrow F^{M^{X}}\quad,\quad\quad\tilde{\text{pu}}_{C}\triangleq\forall X.\,k^{:A\rightarrow F^{X}}\rightarrow k\bef\text{pu}_{M}^{\uparrow F}\quad.
\]

To verify the left identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }g:}\quad & \tilde{\text{pu}}_{C}\tilde{\diamond}\,g^{:\forall Y.\,(B\rightarrow F^{Y})\rightarrow A\rightarrow F^{M^{Y}}}=\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{k\triangleright g^{Z}\triangleright\tilde{\text{pu}}_{C}^{M^{Z}}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & =\forall Z.\,k^{:C\rightarrow F^{Z}}\rightarrow\big(g^{Z}(k)\bef\gunderline{\text{pu}_{M}^{\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}}\\
{\color{greenunder}\text{left identity law of }M:}\quad & =\forall Z.\,k^{:C\rightarrow F^{Z}}\rightarrow g^{Z}(k)=g\quad.
\end{align*}

To verify the right identity law:
\begin{align*}
{\color{greenunder}\text{expect to equal }f:}\quad & f^{:\forall X.\,(B\rightarrow F^{X})\rightarrow A\rightarrow F^{M^{X}}}\tilde{\diamond}\,\tilde{\text{pu}}_{C}=\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{k\triangleright\tilde{\text{pu}}_{C}^{Z}}\triangleright f^{M^{Z}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(\gunderline{(k\bef\text{pu}_{M}^{\uparrow F})\triangleright f^{M^{Z}}}\big)\bef\text{ftn}_{M}^{\uparrow F}\\
{\color{greenunder}\text{naturality law of }f:}\quad & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow\big(k\triangleright f^{Z}\bef\gunderline{\text{pu}_{M}^{\uparrow M\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}}\\
{\color{greenunder}\text{right identity law of }M:}\quad & =\forall Z.\,k^{:B\rightarrow F^{Z}}\rightarrow k\triangleright f^{Z}=f\quad.
\end{align*}

To verify the associativity law, write its two sides separately; omit
all types for brevity:
\begin{align*}
 & (f\,\tilde{\diamond}\,g)\,\tilde{\diamond}\,h=l\rightarrow\big(l\triangleright h\triangleright(\gunderline{f\,\tilde{\diamond}\,g})\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow\big(\gunderline{l\triangleright h\triangleright(k}\rightarrow(k\triangleright g\triangleright f)\bef\text{ftn}_{M}^{\uparrow F})\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & \quad=l\rightarrow\big((l\triangleright h\triangleright g\triangleright f)\bef\text{ftn}_{M}^{\uparrow F}\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow l\triangleright h\bef g\bef f\bef\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad,\\
 & f\,\tilde{\diamond}\,(g\,\tilde{\diamond}\,h)=l\rightarrow\big(l\triangleright(g\,\tilde{\diamond}\,h)\triangleright f\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow\big(l\triangleright(k\rightarrow(k\triangleright h\triangleright g)\bef\text{ftn}_{M}^{\uparrow F})\triangleright f\big)\bef\text{ftn}_{M}^{\uparrow F}\\
 & \quad=l\rightarrow\big(\big((l\triangleright h\triangleright g)\bef\gunderline{\text{ftn}_{M}^{\uparrow F}\big)\triangleright f}\big)\bef\text{ftn}_{M}^{\uparrow F}=l\rightarrow l\triangleright h\triangleright g\triangleright f\bef\text{ftn}_{M}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad.
\end{align*}
In the last line, we have used the naturality law of $f$. The remaining
difference between the two sides is:
\[
\text{ftn}_{M}^{\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\overset{?}{=}\text{ftn}_{M}^{\uparrow M\uparrow F}\bef\text{ftn}_{M}^{\uparrow F}\quad,
\]
which follows from the associativity law of $\text{ftn}_{M}$.

\textbf{(b)} The \lstinline!flatMap! method must have the type signature:
\[
\text{flm}_{L}:\big((A\rightarrow X)\rightarrow M^{X}\big)\rightarrow(A\rightarrow(B\rightarrow X)\rightarrow M^{X})\rightarrow(B\rightarrow X)\rightarrow M^{X}\quad.
\]
Choose $M^{A}\triangleq\bbnum 1+A$; now we need to implement the
type signature:
\begin{align*}
 & \text{flm}_{L}:\big((A\rightarrow X)\rightarrow\bbnum 1+X\big)\rightarrow\left(A\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\right)\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\quad,\\
 & \text{flm}_{L}\triangleq p^{:(A\rightarrow X)\rightarrow\bbnum 1+X}\rightarrow q^{:\left(A\rightarrow(B\rightarrow X)\rightarrow\bbnum 1+X\right)}\rightarrow r^{:B\rightarrow X}\rightarrow\text{???}^{:\bbnum 1+X}\quad.
\end{align*}
Can this function ever return a value of type $\bbnum 0+X$? When
we try filling out the typed hole $\text{???}^{:\bbnum 1+X}$, we
cannot apply the function $r$ since we have no available values of
type $B$. We could substitute $r$ into the second curried argument
of $q$, obtaining a function of type $A\rightarrow\bbnum 1+X$. But
we have no available values of type $A$. We also cannot apply the
function $p$ since its argument is of type $A\rightarrow X$, but
we only have $A\rightarrow\bbnum 1+X$, which is not guaranteed to
return nonempty values. So, the only way of implementing \lstinline!flatMap!
via fully parametric code is to return the constant value $1+\bbnum 0^{:X}$.
This would lose information and violate an identity law of monads.

\chapter{A humorous disclaimer}

\index{jokes}\emph{The following text is quoted in part from an anonymous
online source (\textsf{``}Project Guten Tag\textsf{''}) dating back at least to 1997.
The original text is no longer available on the Internet.}

\medskip{}

\noun{Warranto Limitensis; Disclamatantus Damagensis}

Solus exceptus \textsf{``}Rectum Replacator Refundiens\textsf{''} describitus ecci,
\begin{enumerate}
\item Projectus (etque nunquam partum quis hic etext remitibus cum \noun{Project
Guten Tag}$^{\text{TM}}$ identificator) disclamabat omni liabilitus
tuus damagensis, pecuniensisque, includibantus pecunia legalitus,
et 
\item \noun{Remedia Negligentitia Non Habet Tuus, Warrantus Destructi\-bus
Contractus Nullibus Ni Liabilitus Sumus, Inclutatibus Non Limitatus
Destructio Directibus, Consequentius, Punitio, O Incidentus, Non Sunt
Si Nos Notificat Vobis}. 
\end{enumerate}
Sit discubriatus defectus en etextum sic entram diariam noventam recibidio,
pecuniam tuum refundatorium receptorus posset, sic scribatis vendor.
Sit veniabat medium physicalis, vobis idem reternat et replacator
possit copius. Sit venitabat electronicabilis, sic viri datus chansus
segundibus. 

\noun{Hic Etext Venid \textsf{``}Como-asi\textsf{''}. Nihil Warranti Nunquam Classum,
Expressito Ni Implicato, Le Macchen Como Si Etexto Bene Sit O Il Medio
Bene Sit, Inclutat Et Non Limitat Warranti Mercatensis, Appropriatensis
Purposem. }

Statuen varias non permitatent disclamabaris ni warranti implicatoren
ni exclusioni limitatio damagaren consequentialis, ecco lo qua disclamatori
exclusato\-rique non vobis applicant, et potat optia alia legali.

\twocolumn

\chapter{GNU Free Documentation License\label{sec:GFDL} }

{\footnotesize{}Version 1.2, November 2002}{\footnotesize\par}

{\tiny{}Copyright (c) 2000,2001,2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA}{\tiny\par}

{\tiny{}Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.}{\tiny\par}

{\tiny{}\setcounter{subsection}{-1}}{\tiny\par}

\subsection*{{\tiny{}Preamble}}

{\tiny{}The purpose of this License is to make a manual, textbook,
or other functional and useful document free in the sense of freedom:
to assure everyone the effective freedom to copy and redistribute
it, with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a
way to get credit for their work, while not being considered responsible
for modifications made by others.}{\tiny\par}

{\tiny{}This License is a kind of \textquotedblleft copyleft\textsf{''}, which
means that derivative works of the document must themselves be free
in the same sense. It complements the GNU General Public License,
which is a copyleft license designed for free software.}{\tiny\par}

{\tiny{}We have designed this License in order to use it for manuals
for free software, because free software needs free documentation:
a free program should come with manuals providing the same freedoms
that the software does. But this License is not limited to software
manuals; it can be used for any textual work, regardless of subject
matter or whether it is published as a printed book. We recommend
this License principally for works whose purpose is instruction or
reference.}{\tiny\par}

\subsection{Applicability and definitions\label{subsec:1Applicability-and-definitions}}

{\tiny{}This License applies to any manual or other work, in any medium,
that contains a notice placed by the copyright holder saying it can
be distributed under the terms of this License. Such a notice grants
a world-wide, royalty-free license, unlimited in duration, to use
that work under the conditions stated herein. The \textquotedblleft Document\textsf{''},
below, refers to any such manual or work. Any member of the public
is a licensee, and is addressed as \textquotedblleft you\textsf{''}. You accept
the license if you copy, modify or distribute the work in a way requiring
permission under copyright law.}{\tiny\par}

{\tiny{}A \textquotedblleft Modified Version\textsf{''} of the Document means
any work containing the Document or a portion of it, either copied
verbatim, or with modifications and/or translated into another language.}{\tiny\par}

{\tiny{}A \textquotedblleft Secondary Section\textsf{''} is a named appendix
or a front-matter section of the Document that deals exclusively with
the relationship of the publishers or authors of the Document to the
Document\textsf{'}s overall subject (or to related matters) and contains nothing
that could fall directly within that overall subject. (Thus, if the
Document is in part a textbook of mathematics, a Secondary Section
may not explain any mathematics.) The relationship could be a matter
of historical connection with the subject or with related matters,
or of legal, commercial, philosophical, ethical or political position
regarding them.}{\tiny\par}

{\tiny{}The \textquotedblleft Invariant Sections\textsf{''} are certain Secondary
Sections whose titles are designated, as being those of Invariant
Sections, in the notice that says that the Document is released under
this License. If a section does not fit the above definition of Secondary
then it is not allowed to be designated as Invariant. The Document
may contain zero Invariant Sections. If the Document does not identify
any Invariant Sections then there are none.}{\tiny\par}

{\tiny{}The \textquotedblleft Cover Texts\textsf{''} are certain short passages
of text that are listed, as Front-Cover Texts or Back-Cover Texts,
in the notice that says that the Document is released under this License.
A Front-Cover Text may be at most 5 words, and a Back-Cover Text may
be at most 25 words.}{\tiny\par}

{\tiny{}A \textquotedblleft Transparent\textsf{''} copy of the Document means
a machine-readable copy, represented in a format whose specification
is available to the general public, that is suitable for revising
the document straightforwardly with generic text editors or (for images
composed of pixels) generic paint programs or (for drawings) some
widely available drawing editor, and that is suitable for input to
text formatters or for automatic translation to a variety of formats
suitable for input to text formatters. A copy made in an otherwise
Transparent file format whose markup, or absence of markup, has been
arranged to thwart or discourage subsequent modification by readers
is not Transparent. An image format is not Transparent if used for
any substantial amount of text. A copy that is not \textquotedblleft Transparent\textsf{''}
is called \textquotedblleft Opaque\textsf{''}.}{\tiny\par}

{\tiny{}Examples of suitable formats for Transparent copies include
plain ASCII without markup, Texinfo input format, \LaTeX{} input format,
SGML or XML using a publicly available DTD, and standard-conforming
simple HTML, PostScript or PDF designed for human modification. Examples
of transparent image formats include PNG, XCF and JPG. Opaque formats
include proprietary formats that can be read and edited only by proprietary
word processors, SGML or XML for which the DTD and/or processing tools
are not generally available, and the machine-generated HTML, PostScript
or PDF produced by some word processors for output purposes only.}{\tiny\par}

{\tiny{}The \textsf{``}Title Page\textsf{''} means, for a printed book, the title
page itself, plus such following pages as are needed to hold, legibly,
the material this License requires to appear in the title page. For
works in formats which do not have any title page as such, \textquotedblleft Title
Page\textquotedblright{} means the text near the most prominent appearance
of the work\textsf{'}s title, preceding the beginning of the body of the text.}{\tiny\par}

{\tiny{}A section \textsf{``}Entitled XYZ\textsf{''} means a named subunit of the
Document whose title either is precisely XYZ or contains XYZ in parentheses
following text that translates XYZ in another language. (Here XYZ
stands for a specific section name mentioned below, such as \textquotedblleft Acknowledgements\textquotedblright ,
\textquotedblleft Dedications\textquotedblright , \textquotedblleft Endorsements\textquotedblright ,
or \textquotedblleft History\textquotedblright .) To \textquotedblleft Preserve
the Title\textquotedblright{} of such a section when you modify the
Document means that it remains a section \textquotedblleft Entitled
XYZ\textquotedblright{} according to this definition.}{\tiny\par}

{\tiny{}The Document may include Warranty Disclaimers next to the
notice which states that this License applies to the Document. These
Warranty Disclaimers are considered to be included by reference in
this License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.}{\tiny\par}

\subsection{Verbatim copying\label{subsec:2Verbatim-copying}}

{\tiny{}You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the copyright
notices, and the license notice saying this License applies to the
Document are reproduced in all copies, and that you add no other conditions
whatsoever to those of this License. You may not use technical measures
to obstruct or control the reading or further copying of the copies
you make or distribute. However, you may accept compensation in exchange
for copies. If you distribute a large enough number of copies you
must also follow the conditions in section~\ref{subsec:3Copying-in-quantity}.}{\tiny\par}

{\tiny{}You may also lend copies, under the same conditions stated
above, and you may publicly display copies.}{\tiny\par}

\subsection{Copying in quantity\label{subsec:3Copying-in-quantity}}

{\tiny{}If you publish printed copies (or copies in media that commonly
have printed covers) of the Document, numbering more than 100, and
the Document\textsf{'}s license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts
on the back cover. Both covers must also clearly and legibly identify
you as the publisher of these copies. The front cover must present
the full title with all words of the title equally prominent and visible.
You may add other material on the covers in addition. Copying with
changes limited to the covers, as long as they preserve the title
of the Document and satisfy these conditions, can be treated as verbatim
copying in other respects.}{\tiny\par}

{\tiny{}If the required texts for either cover are too voluminous
to fit legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.}{\tiny\par}

{\tiny{}If you publish or distribute Opaque copies of the Document
numbering more than 100, you must either include a machine-readable
Transparent copy along with each Opaque copy, or state in or with
each Opaque copy a computer-network location from which the general
network-using public has access to download using public-standard
network protocols a complete Transparent copy of the Document, free
of added material. If you use the latter option, you must take reasonably
prudent steps, when you begin distribution of Opaque copies in quantity,
to ensure that this Transparent copy will remain thus accessible at
the stated location until at least one year after the last time you
distribute an Opaque copy (directly or through your agents or retailers)
of that edition to the public.}{\tiny\par}

{\tiny{}It is requested, but not required, that you contact the authors
of the Document well before redistributing any large number of copies,
to give them a chance to provide you with an updated version of the
Document.}{\tiny\par}

\subsection{Modifications\label{subsec:4Modifications}}

{\tiny{}You may copy and distribute a Modified Version of the Document
under the conditions of sections~\ref{subsec:2Verbatim-copying}
and \ref{subsec:3Copying-in-quantity} above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it. In addition, you must do these things in the Modified Version:}{\tiny\par}

{\tiny{}A. Use in the Title Page (and on the covers, if any) a title
distinct from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document). You may use the same title as a previous version
if the original publisher of that version gives permission.}{\tiny\par}

{\tiny{}B. List on the Title Page, as authors, one or more persons
or entities responsible for authorship of the modifications in the
Modified Version, together with at least five of the principal authors
of the Document (all of its principal authors, if it has fewer than
five), unless they release you from this requirement.}{\tiny\par}

{\tiny{}C. State on the Title page the name of the publisher of the
Modified Version, as the publisher.}{\tiny\par}

{\tiny{}D. Preserve all the copyright notices of the Document.}{\tiny\par}

{\tiny{}E. Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.}{\tiny\par}

{\tiny{}F. Include, immediately after the copyright notices, a license
notice giving the public permission to use the Modified Version under
the terms of this License, in the form shown in the Addendum below.}{\tiny\par}

{\tiny{}G. Preserve in that license notice the full lists of Invariant
Sections and required Cover Texts given in the Document\textsf{'}s license
notice.}{\tiny\par}

{\tiny{}H. Include an unaltered copy of this License.}{\tiny\par}

{\tiny{}I. Preserve the section Entitled \textsf{``}History\textsf{''}, Preserve its
Title, and add to it an item stating at least the title, year, new
authors, and publisher of the Modified Version as given on the Title
Page. If there is no section Entitled \textquotedblleft History\textquotedblright{}
in the Document, create one stating the title, year, authors, and
publisher of the Document as given on its Title Page, then add an
item describing the Modified Version as stated in the previous sentence.}{\tiny\par}

{\tiny{}J. Preserve the network location, if any, given in the Document
for public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on. These may be placed in the \textsf{``}History\textsf{''} section.
You may omit a network location for a work that was published at least
four years before the Document itself, or if the original publisher
of the version it refers to gives permission.}{\tiny\par}

{\tiny{}K. For any section Entitled \textsf{``}Acknowledgements\textsf{''} or \textsf{``}Dedications\textsf{''},
Preserve the Title of the section, and preserve in the section all
the substance and tone of each of the contributor acknowledgements
and/or dedications given therein.}{\tiny\par}

{\tiny{}L. Preserve all the Invariant Sections of the Document, unaltered
in their text and in their titles. Section numbers or the equivalent
are not considered part of the section titles.}{\tiny\par}

{\tiny{}M. Delete any section Entitled \textsf{``}Endorsements\textsf{''}. Such a
section may not be included in the Modified Version.}{\tiny\par}

{\tiny{}N. Do not retitle any existing section to be Entitled \textsf{``}Endorsements\textsf{''}
or to conflict in title with any Invariant Section.}{\tiny\par}

{\tiny{}O. Preserve any Warranty Disclaimers.}{\tiny\par}

{\tiny{}If the Modified Version includes new front-matter sections
or appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or
all of these sections as invariant. To do this, add their titles to
the list of Invariant Sections in the Modified Version\textsf{'}s license notice.
These titles must be distinct from any other section titles.}{\tiny\par}

{\tiny{}You may add a section Entitled \textsf{``}Endorsements\textsf{''}, provided
it contains nothing but endorsements of your Modified Version by various
parties \textemdash{} for example, statements of peer review or that
the text has been approved by an organization as the authoritative
definition of a standard.}{\tiny\par}

{\tiny{}You may add a passage of up to five words as a Front-Cover
Text, and a passage of up to 25 words as a Back-Cover Text, to the
end of the list of Cover Texts in the Modified Version. Only one passage
of Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity. If the Document already
includes a cover text for the same cover, previously added by you
or by arrangement made by the same entity you are acting on behalf
of, you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.}{\tiny\par}

{\tiny{}The author(s) and publisher(s) of the Document do not by this
License give permission to use their names for publicity for or to
assert or imply endorsement of any Modified Version.}{\tiny\par}

\subsection*{{\tiny{}Combining documents}}

{\tiny{}You may combine the Document with other documents released
under this License, under the terms defined in section 4 above for
modified versions, provided that you include in the combination all
of the Invariant Sections of all of the original documents, unmodified,
and list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.}{\tiny\par}

{\tiny{}The combined work need only contain one copy of this License,
and multiple identical Invariant Sections may be replaced with a single
copy. If there are multiple Invariant Sections with the same name
but different contents, make the title of each such section unique
by adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of Invariant
Sections in the license notice of the combined work.}{\tiny\par}

{\tiny{}In the combination, you must combine any sections Entitled
\textquotedblleft History\textquotedblright{} in the various original
documents, forming one section Entitled \textquotedblleft History\textquotedblright ;
likewise combine any sections Entitled \textquotedblleft Acknowledgements\textquotedblright ,
and any sections Entitled \textquotedblleft Dedications\textquotedblright .
You must delete all sections Entitled \textquotedblleft Endorsements.\textquotedblright{}}{\tiny\par}

\subsection*{{\tiny{}Collections of documents}}

{\tiny{}You may make a collection consisting of the Document and other
documents released under this License, and replace the individual
copies of this License in the various documents with a single copy
that is included in the collection, provided that you follow the rules
of this License for verbatim copying of each of the documents in all
other respects.}{\tiny\par}

{\tiny{}You may extract a single document from such a collection,
and distribute it individually under this License, provided you insert
a copy of this License into the extracted document, and follow this
License in all other respects regarding verbatim copying of that document.}{\tiny\par}

\subsection*{{\tiny{}Aggregation with independent works}}

{\tiny{}A compilation of the Document or its derivatives with other
separate and independent documents or works, in or on a volume of
a storage or distribution medium, is called an \textquotedblleft aggregate\textquotedblright{}
if the copyright resulting from the compilation is not used to limit
the legal rights of the compilation\textsf{'}s users beyond what the individual
works permit. When the Document is included an aggregate, this License
does not apply to the other works in the aggregate which are not themselves
derivative works of the Document.}{\tiny\par}

{\tiny{}If the Cover Text requirement of section~\ref{subsec:3Copying-in-quantity}
is applicable to these copies of the Document, then if the Document
is less than one half of the entire aggregate, the Document\textsf{'}s Cover
Texts may be placed on covers that bracket the Document within the
aggregate, or the electronic equivalent of covers if the Document
is in electronic form. Otherwise they must appear on printed covers
that bracket the whole aggregate.}{\tiny\par}

\subsection*{{\tiny{}Translation}}

{\tiny{}Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section~\ref{subsec:4Modifications}.
Replacing Invariant Sections with translations requires special permission
from their copyright holders, but you may include translations of
some or all Invariant Sections in addition to the original versions
of these Invariant Sections. You may include a translation of this
License, and all the license notices in the Document, and any Warranty
Disclaimers, provided that you also include the original English version
of this License and the original versions of those notices and disclaimers.
In case of a disagreement between the translation and the original
version of this License or a notice or disclaimer, the original version
will prevail.}{\tiny\par}

{\tiny{}If a section in the Document is Entitled \textquotedblleft Acknowledgements\textquotedblright ,
\textquotedblleft Dedications\textquotedblright , or \textquotedblleft History\textquotedblright ,
the requirement (section~\ref{subsec:4Modifications}) to Preserve
its Title (section~\ref{subsec:1Applicability-and-definitions})
will typically require changing the actual title.}{\tiny\par}

\subsection*{{\tiny{}Termination}}

{\tiny{}You may not copy, modify, sublicense, or distribute the Document
except as expressly provided for under this License. Any other attempt
to copy, modify, sublicense or distribute the Document is void, and
will automatically terminate your rights under this License. However,
parties who have received copies, or rights, from you under this License
will not have their licenses terminated so long as such parties remain
in full compliance.}{\tiny\par}

\subsection*{{\tiny{}Future revisions of this license}}

{\tiny{}The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns. See \url{http://www.gnu.org/copyleft/}.}{\tiny\par}

{\tiny{}Each version of the License is given a distinguishing version
number. If the Document specifies that a particular numbered version
of this License \textquotedblleft or any later version\textquotedblright{}
applies to it, you have the option of following the terms and conditions
either of that specified version or of any later version that has
been published (not as a draft) by the Free Software Foundation. If
the Document does not specify a version number of this License, you
may choose any version ever published (not as a draft) by the Free
Software Foundation.}{\tiny\par}

\subsection*{\noun{\tiny{}Addendum}{\tiny{}: How to use this License for your
documents}}

{\tiny{}To use this License in a document you have written, include
a copy of the License in the document and put the following copyright
and license notices just after the title page:}{\tiny\par}

{\tiny{}Copyright (c) <year> <your name>. Permission is granted to
copy, distribute and/or modify this document under the terms of the
GNU Free Documentation License, Version 1.2 or any later version published
by the Free Software Foundation; with no Invariant Sections, no Front-Cover
Texts, and no Back-Cover Texts. A copy of the license is included
in the section entitled \textquotedblleft GNU Free Documentation License\textquotedblright .}{\tiny\par}

{\tiny{}If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the \textquotedblleft with...Texts.\textquotedblright{}
line with this:}{\tiny\par}

{\tiny{}with the Invariant Sections being <list their titles>, with
the Front-Cover Texts being <list>, and with the Back-Cover Texts
being <list>.}{\tiny\par}

{\tiny{}If you have Invariant Sections without Cover Texts, or some
other combination of the three, merge those two alternatives to suit
the situation.}{\tiny\par}

{\tiny{}If your document contains nontrivial examples of program code,
we recommend releasing these examples in parallel under your choice
of free software license, such as the GNU General Public License,
to permit their use in free software.}{\tiny\par}

\subsection*{{\tiny{}Copyright }}

{\tiny{}Copyright (c) 2000, 2001, 2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA}{\tiny\par}

{\tiny{}Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.}{\tiny\par}
