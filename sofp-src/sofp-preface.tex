
\addchap{Preface}

\global\long\def\gunderline#1{\mathunderline{greenunder}{#1}}%
\global\long\def\bef{\forwardcompose}%
\global\long\def\bbnum#1{\custombb{#1}}%
This book is at once a reference text and a tutorial that teaches
functional programmers how to reason mathematically about types and
code, in a manner directly relevant to software practice.

The material ranges from introductory to advanced. Readers will need
to learn some difficult concepts through prolonged mental concentration
and effort. The book assumes a certain amount of mathematical experience,
\textemdash{} at the level of familiarity with high-school algebra
or calculus.

The presentation is self-contained, defining and explaining all required
ideas, notations, and Scala language features from scratch. The goal
is to make all mathematical notions and derivations understandable.
To achieve a clearer presentation of the material, the book uses some
non-standard notations (Appendix~\ref{chap:Appendix-Notations})
and terminology (Appendix~\ref{chap:Appendix-Glossary-of-terms}).

The vision of this book is to explain the mathematical principles
that guide the practice of functional programming \textemdash{} i.e.~principles
that help us write code. So, all mathematical developments in this
book are motivated and justified by practical programming issues and
are accompanied by Scala code that illustrates their usage. For instance,
the laws for standard typeclasses (functors, monads, etc.) are first
motivated heuristically through code examples. Only then the laws
are formulated as mathematical equations and verified by explicit
step-by-step derivations.

Each concept or technique is motivated and explained to make it as
simple as possible (``but not simpler'') and also clarified via
solved examples and exercises, which the readers \emph{will} be able
to solve after reading the chapter. More difficult examples and exercises
are marked by an asterisk ({*}).

A software engineer needs to know only a few fragments of mathematical
theory; namely, the fragments that answer questions arising in the
practice of functional programming. So this book keeps theoretical
material at the minimum; \emph{ars longa, vita brevis}. (Chapter~\ref{chap:Applied-functional-type}
discusses the scope of the required theory.) Mathematical generalizations
are not pursued beyond proven practical relevance or immediate pedagogical
usefulness. This reduces the required mathematical knowledge to first
notions of category theory, type theory, and formal logic. Concepts
such as functors or natural transformations arise organically from
the practice of reasoning about code and are introduced without reference
to category theory. This book does not use ``introduction/elimination
rules'', ``strong normalization'', ``complete partial order domains'',
``adjoint functors'', ``pullbacks'', or ``topoi'', because learning
these concepts will not help a programmer write code. 

This book is also \emph{not} an introduction to current theoretical
research in functional programming. Instead, the focus is on material
known to be practically useful \textemdash{} including constructions
such as the ``filterable functor'' and ``applicative contrafunctor'',
but excluding a number of theoretical developments that do not (yet?)
appear to have significant applications.

The first part of the book is introductory and may be suitable for
beginners in programming. Starting from Chapter~\ref{chap:3-3-The-formal-logic-curry-howard},
the material becomes unsuitable for beginners.

Readers already familiar with functional programming could skim the
glossary (Appendix~\ref{chap:Appendix-Glossary-of-terms}) to see
the unfamiliar terminology and then begin the book at Chapter~\ref{chap:3-3-The-formal-logic-curry-howard}.

Chapters~\ref{chap:3-3-The-formal-logic-curry-howard}\textendash \ref{chap:Functors,-contrafunctors,-and}
begin showing derivations in the code notation, such as Eq.~(\ref{eq:f-functor-exponential-def-of-fmap}).
If that notation appears difficult to follow, readers could benefit
from working through Chapter~\ref{chap:Reasoning-about-code} where
the code notation is summarized and clarified with additional examples.

All code examples are intended only for explanation and illustration.
As a rule, the code is not optimized for performance or stack safety.

The author thanks Joseph Kim and Jim Kleck for doing some of the exercises
and reporting some errors in earlier versions of this book.

\addsec{Formatting conventions used in this book}
\begin{itemize}
\item Text in boldface indicates a new concept or term that is being defined
at that place in the text. Italics means logical emphasis. Example:
\end{itemize}
\begin{quotation}
An \textbf{aggregation\index{aggregation}} is a function from a sequence
of values to a \emph{single} value.
\end{quotation}
\begin{itemize}
\item Equations are numbered per chapter: Eq.~(\ref{eq:prime-formula-function}).
Statements, examples, and exercises are numbered per subsection: Example~\ref{subsec:ch1-aggr-Example-6}
is in subsection~\ref{subsec:Aggregation-solved-examples}, which
belongs to Chapter~\ref{chap:1-Values,-types,-expressions,}.
\item Scala code is written inline using a small monospaced font, such as
\lstinline!.flatMap! or \lstinline!val a = "xyz"!. Longer code examples
are written in separate code blocks and may also show the Scala interpreter's
output for certain lines:
\begin{lstlisting}[mathescape=true]
val s = (1 to 10).toList

scala> s.product
res0: Int = 3628800 
\end{lstlisting}
\item In the introductory chapters, type expressions and code examples are
written in the syntax of Scala. Starting from Chapters~\ref{chap:Higher-order-functions}\textendash \ref{chap:3-3-The-formal-logic-curry-howard},
the book introduces a new notation for types where e.g.~the Scala
type expression \lstinline!((A, B)) => Option[A]! is written as $A\times B\rightarrow\bbnum 1+A$.
Also, a new notation for code is introduced and developed in Chapters~\ref{chap:3-3-The-formal-logic-curry-howard}\textendash \ref{chap:Reasoning-about-code}
for efficient reasoning about typeclass laws. For example, the functor
composition law is written in the code notation as
\[
f^{\uparrow L}\bef g^{\uparrow L}=\left(f\bef g\right)^{\uparrow L}\quad,
\]
where $L$ is a functor and $f^{:A\rightarrow B}$ and $g^{:B\rightarrow C}$
are arbitrary functions of the specified types. The notation $f^{\uparrow L}$
denotes the function $f$ lifted to the functor $L$ and replaces
Scala's syntax \lstinline!x.map(f)! where \lstinline!x! is of type
\lstinline!L[A]!. The symbol $\bef$ denotes the forward composition
of functions (Scala's \lstinline!andThen! method). Appendix~\ref{chap:Appendix-Notations}
summarizes the notation conventions for types and code.
\item Frequently used methods of standard typeclasses, such as \lstinline!pure!,
\lstinline!flatMap!, \lstinline!flatten!, \lstinline!filter!, etc.,
are denoted by shorter words and are labeled by the type constructor
they belong to. For instance, the text talks about typeclass methods
\lstinline!pure!, \lstinline!flatten!, and \lstinline!flatMap!
for a monad $M$ but denotes the same methods by $\text{pu}_{M}$,
$\text{ftn}_{M}$, and $\text{flm}_{M}$ when writing code formulas.
\item Derivations are written in a two-column format where the right column
contains formulas in the code notation and the left column gives a
line-by-line explanation or indicates the property or law used to
derive the expression at right. A green underline in an expression
shows the parts to be rewritten using the law or equation indicated
in the \emph{next} line:
\begin{align*}
{\color{greenunder}\text{expect to equal }\text{pu}_{M}:}\quad & \gunderline{\text{pu}_{M}^{\uparrow\text{Id}}}\bef\text{pu}_{M}\bef\text{ftn}_{M}\\
{\color{greenunder}\text{lifting to the identity functor}:}\quad & =\text{pu}_{M}\bef\gunderline{\text{pu}_{M}\bef\text{ftn}_{M}}\\
{\color{greenunder}\text{left identity law of }M:}\quad & =\text{pu}_{M}\quad.
\end{align*}
A green underline is sometimes also used at the \emph{last} step of
a derivation, to indicate the part of the expression that resulted
from the most recent rewriting. Other than providing hints that help
remember the steps of a derivation, the green underlines \emph{play
no role} in symbolic calculations.
\end{itemize}

