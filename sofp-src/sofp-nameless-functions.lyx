#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
\usepackage[all]{xy} % xypic

% pstricks with support for pdflatex
%\usepackage{pdftricks}
%\begin{psinputs}
%   \usepackage{pstricks}
%   \usepackage{multido}
%\end{psinputs}
\usepackage{pstricks}

% Cover picture on first page.
\usepackage{wallpaper}
% Custom commands for cover page.
\usepackage[absolute,overlay]{textpos}

% No page numbers on "Part" pages.
\renewcommand*{\partpagestyle}{empty}

% Running head: works, but results are not satisfactory.
%\usepackage{scrlayer-scrpage}
%\automark[subsection]{chapter}


% "Better text justification"? Actually, this causes a fatal error "auto expansion is only possible with scalable fonts".
%\usepackage{microtype}

% Fix the numbering of exercises: subsubsections appear as paragraphs but are numbered.
%\usepackage{titlesec} % Incompatible with komascript's later versions.
% See https://tex.stackexchange.com/questions/7627/how-to-reference-paragraph
% See the `titlesec` package documentation at http://www.ctex.org/documents/packages/layout/titlesec.pdf
%\titleformat{\subsubsection}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subsubsection}{0pt}{5pt}{3\wordsep}
%\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{}{0pt}{}
%\titlespacing{\subparagraph}{\parindent}{\parskip}{3\wordsep}
%\titlespacing{\paragraph}{0pt}{3pt}{2\wordsep}

\renewcommand*{\subsubsectionformat}{}
\RedeclareSectionCommand[ % Statement 1.2.3.4
  runin=true,
  afterskip=2ex,
  beforeskip=2.5pt plus 0.3pt minus 0.05pt,
  afterindent=false,
  font={\normalfont\normalsize\bfseries}
]{subsubsection}
\RedeclareSectionCommand[ % Proof
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterindent=false,
  afterskip=2ex,
  beforeskip=0pt
]{subparagraph}
\RedeclareSectionCommand[
  runin=true,
  font={\normalfont\normalsize\bfseries},
  afterskip=1.3ex,
  beforeskip=0pt
]{paragraph}

% Make page headers and page numbers smaller
\addtokomafont{pagehead}{\small}
\addtokomafont{pagenumber}{\small}

% Double-stroked fonts to replace the non-working \mathbb{1}.
\usepackage{bbold}
\DeclareMathAlphabet{\bbnumcustom}{U}{BOONDOX-ds}{m}{n} % Use BOONDOX-ds or bbold.
\newcommand{\custombb}[1]{\bbnumcustom{#1}}
% The LyX document will define a macro \bbnum{#1} that calls \custombb{#1}.

% Scala syntax highlighting. See https://tex.stackexchange.com/questions/202479/unable-to-define-scala-language-with-listings
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
%\usepackage{beramono}
%\usepackage{listings}
% The listing settings are now supported by LyX in a separate section "Listings".
\usepackage{xcolor}

\definecolor{scalakeyword}{rgb}{0.16,0.07,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{aqua}{rgb}{0.9,0.96,0.999}
\definecolor{scalatype}{rgb}{0.2,0.3,0.2}
\definecolor{teal}{rgb}{0,0.6,0}

% These settings are now in the Listings tab in LyX.
%\lstdefinestyle{myScalastyle}{
%  language=scala, % This should be defined first!!! Otherwise it overrides all customization via morekeywords / otherkeywords.
%  otherkeywords={{=,=>,<-,<\%,<:,>:,\#,@,*,+,-,/,::,:,[,]}},
%  frame=tb,
%  aboveskip=2mm,
%  belowskip=2mm,
%  showstringspaces=false,
%  columns=flexible,
%  basicstyle={\small\ttfamily},
%  extendedchars=true,
%  %numbers=none,
%  numberstyle=\tiny\color{gray},
%  keywordstyle=\color{blue},
%  commentstyle=\color{dkgreen},
%  stringstyle=\color{mauve},
%  frame=single,
%  framerule=0.01mm,
%  breaklines=true,
%  breakatwhitespace=true,
%  tabsize=3,
%  framexleftmargin=4mm, framexrightmargin=4mm,
%  xleftmargin=4mm, xrightmargin=4mm, % Making these margins the same has a good effect.
%  framextopmargin=0.5mm, framexbottommargin=.5mm,
%  fillcolor=\color{aqua},
%  rulecolor=\color{aqua},
%  rulesepcolor=\color{aqua},
%  backgroundcolor=\color{aqua},
%  mathescape=true,
%}

% Example usage: \begin{lstlisting}[style=myScalastyle]  object blah \end{lstlisting}
%\newenvironment{scala}{\begin{lstlisting}[style=myScalastyle]}{\end{lstlisting}}
%\lstnewenvironment{scala}{\lstset{style=myScalastyle}}{}

\usepackage[nocenter]{qtree} % simple tree drawing
\usepackage{relsize} % make math symbols larger or smaller; supports \smaller etc.
\usepackage{stmaryrd} % some extra symbols such as \fatsemi
% Note: using \forwardcompose inside a \text{} will cause a LaTeX error!
\newcommand{\forwardcompose}{\hspace{1.2pt}\ensuremath\mathsmaller{\fatsemi}\hspace{1.5pt}}
% this is ugly, I used this before I found \fatsemi:
%\newcommand{\bef}{\hspace{1.0pt}\ensuremath\raisebox{2pt}{$\mathsmaller{\mathsmaller{\circ}}$}\hspace{-2.9pt},}
%\makeatletter
% Macros to assist LyX with XYpic when using scaling.
\newcommand{\xyScaleX}[1]{%
\makeatletter
\xydef@\xymatrixcolsep@{#1}
\makeatother
} % end of \xyScaleX
\makeatletter
\newcommand{\xyScaleY}[1]{%
\makeatletter
\xydef@\xymatrixrowsep@{#1}
\makeatother
} % end of \xyScaleY

% Increase the default vertical space inside table cells.
\renewcommand\arraystretch{1.4}

% Color for PDF hyperlinks.
\definecolor{hlink}{rgb}{0.06, 0.14, 0.48}

% Make underline green.
\definecolor{greenunder}{rgb}{0.1,0.6,0.2}
%\newcommand{\munderline}[1]{{\color{greenunder}\underline{{\color{black}#1}}\color{black}}}
\def\mathunderline#1#2{\color{#1}\underline{{\color{black}#2}}\color{black}}
% The LyX document will define a macro \gunderline{#1} that will use \mathunderline with the color `greenunder`.
%\def\gunderline#1{\mathunderline{greenunder}{#1}} % This is now defined by LyX itself with GUI support.


% Prepare settings for imposing a color background for all displayed math. This will be done by a script later.
\usepackage{empheq} % Background on all displayed equations.
\definecolor{mathbg}{rgb}{1.0, .98, .87}
\newcommand*\mymathbgbox[1]{%
\setlength{\fboxsep}{0pt}%
\colorbox{mathbg}{\hspace{0.5mm}#1\hspace{0.5mm}}}
%\renewenvironment{align}{%
%\begin{empheq}[box=\mymathbgbox]{align}}{%
%\endalign\end{empheq}}
% Run a command such as LC_ALL=C sed -i bak -e 's|\\begin{align}|\\begin{empheq}[box=\\mymathbgbox]{align}|; s|\\end{align}|\\end{empheq}|' sofp-filterable.tex
% This is not used now because the results are not great.

% Better text quotes.
\renewcommand\textquotedblleft{``}
\renewcommand\textquotedblright{''}
\end_preamble
\options open=any,numbers=noenddot,index=totoc,bibliography=totoc,listof=totoc,fontsize=10pt
\use_default_options true
\master sofp.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "cmtt" "default"
\font_math "newtxmath" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_title "The Science of Functional Programming: A Tutorial, with Examples in Scala"
\pdf_author "Sergei Winitzki"
\pdf_subject "Functional programming"
\pdf_keywords "Functional programming, Scala, Type theory, Category theory, Formal logic, Programming languages"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=hlink"
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 7.444in
\paperheight 9.68in
\leftmargin 2.2cm
\topmargin 1.175cm
\rightmargin 1.3cm
\bottommargin 1.275cm
\headsep 0.4cm
\footskip 0.72cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "language=Scala,morekeywords={{scala}},otherkeywords={=,=>,<-,<\%,<:,>:,\#,@,:,[,],.,???},keywordstyle={\color{scalakeyword}},morekeywords={[2]{String,Short,Int,Long,Char,Boolean,Double,Float,BigDecimal,Seq,Map,Set,Option,Either,Future,Successful,LazyList,Vector,Range,IndexedSeq,true,false,None,List,Nil,Try,Success,Failure,Some,Left,Right,Nothing,Any,Array,Unit,Iterator,Stream,Throwable,Integer,Object}},keywordstyle={[2]{\color{scalatype}}},frame=tb,aboveskip={1.5mm},belowskip={0.5mm},showstringspaces=false,columns=fullflexible,keepspaces=true,basicstyle={\smaller\ttfamily},extendedchars=true,numbers=none,numberstyle={\tiny\color{gray}},commentstyle={\color{dkgreen}},stringstyle={\color{mauve}},frame=single,framerule={0.0mm},breaklines=true,breakatwhitespace=true,tabsize=3,framexleftmargin={0.5mm},framexrightmargin={0.5mm},xleftmargin={1.5mm},xrightmargin={1.5mm},framextopmargin={0.5mm},framexbottommargin={0.5mm},fillcolor={\color{aqua}},rulecolor={\color{aqua}},rulesepcolor={\color{aqua}},backgroundcolor={\color{aqua}},mathescape=false,extendedchars=true"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Mathematical formulas as code.
 I.
 Nameless functions
\begin_inset CommandInset label
LatexCommand label
name "chap:1-Values,-types,-expressions,"

\end_inset


\end_layout

\begin_layout Section
Translating mathematics into code
\end_layout

\begin_layout Subsection
First examples
\end_layout

\begin_layout Standard
We begin by implementing some computational tasks in Scala.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-Factorial-of-10"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-Factorial-of-10"
plural "false"
caps "false"
noprefix "false"

\end_inset

: Factorial of 10
\end_layout

\begin_layout Standard
Find the product of integers from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $10$
\end_inset

 (the 
\series bold
factorial
\begin_inset Index idx
status open

\begin_layout Plain Layout
factorial function
\end_layout

\end_inset


\series default
 of 10).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
First, we write a mathematical formula for the result (usually denoted by
 
\begin_inset Formula $10!$
\end_inset

):
\begin_inset Formula 
\[
10!=1*2*...*10\quad,\quad\quad\text{or in mathematical notation}:\quad10!=\prod_{k=1}^{10}k\quad.
\]

\end_inset

We can then write Scala code in a way that resembles the last formula:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).product
\end_layout

\begin_layout Plain Layout

res0: Int = 3628800
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to 10).product
\end_layout

\end_inset


\family default
 is an 
\series bold
expression
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
expression
\end_layout

\end_inset

, which means that (1) the code can be evaluated and yields a value, and
 (2) the code can be used inside a larger expression.
 For example, we could write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> 100 + (1 to 10).product + 100   // This code contains `(1 to 10).product`
 as a sub-expression.
\end_layout

\begin_layout Plain Layout

res0: Int = 3629000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> 3628800 == (1 to 10).product 
\end_layout

\begin_layout Plain Layout

res1: Boolean = true
\end_layout

\end_inset

The Scala interpreter indicates that the result of 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to 10).product
\end_layout

\end_inset


\family default
 is a value 
\begin_inset Formula $3628800$
\end_inset

 of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
 If we need to define a name for that value, we use the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val fac10 = (1 to 10).product
\end_layout

\begin_layout Plain Layout

fac10: Int = 3628800
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-Factorial-as-a-function"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-Factorial-as-a-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

: Factorial as a function
\end_layout

\begin_layout Standard
Define a function to compute the factorial of an integer 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
A mathematical formula for this function can be written as:
\begin_inset Formula 
\[
f\left(n\right)=\prod_{k=1}^{n}k\quad.
\]

\end_inset

The corresponding Scala code is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(n: Int) = (1 to n).product
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Scala's 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset


\family default
 syntax, we need to specify the type of a function's argument; in this case,
 we write 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

.
 In the usual mathematical notation, types of arguments are either not written
 at all, or written separately from the formula:
\begin_inset Formula 
\begin{equation}
f(n)=\prod_{k=1}^{n}k\quad,\quad\quad\forall n\in\mathbb{N}\quad.\label{eq:factorial-as-function}
\end{equation}

\end_inset

Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:factorial-as-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

) indicates that 
\begin_inset Formula $n$
\end_inset

 must be from the set of positive integers, denoted by 
\begin_inset Formula $\mathbb{N}$
\end_inset

 in mathematics.
 This is similar to specifying the type 
\family typewriter
(
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

)
\family default
 in the Scala code.
 So, the argument's type in the code specifies the 
\series bold
domain
\series default
 of a function
\begin_inset Index idx
status open

\begin_layout Plain Layout
domain of a function
\end_layout

\end_inset

 (the set of admissible arguments).
\end_layout

\begin_layout Standard
Having defined the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

, we can now apply it to an integer value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

 (or, as programmers say, 
\begin_inset Quotes eld
\end_inset

call
\begin_inset Quotes erd
\end_inset

 the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 with argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

):
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f(10)
\end_layout

\begin_layout Plain Layout

res6: Int = 3628800
\end_layout

\end_inset

It is a 
\series bold
type error
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
type error
\end_layout

\end_inset

 to apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 to a non-integer value:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> f("abc")
\end_layout

\begin_layout Plain Layout

<console>:13: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("abc")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nameless functions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Nameless-functions"

\end_inset


\end_layout

\begin_layout Standard
Both the code written above and Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:factorial-as-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

) involve 
\emph on
naming
\emph default
 the function as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Sometimes a function does not really need a name, — say, if the function
 is used only once.
 
\begin_inset Quotes eld
\end_inset

Nameless
\begin_inset Quotes erd
\end_inset

 mathematical functions may be denoted using the symbol 
\begin_inset Formula $\rightarrow$
\end_inset

 (pronounced 
\begin_inset Quotes eld
\end_inset

maps to
\begin_inset Quotes erd
\end_inset

) like this: 
\begin_inset Formula 
\[
x\rightarrow\left(\text{some formula}\right)\quad.
\]

\end_inset

So, the mathematical notation for the nameless factorial function is:
\begin_inset Formula 
\[
n\rightarrow\prod_{k=1}^{n}k\quad.
\]

\end_inset

This reads as 
\begin_inset Quotes eld
\end_inset

a function that maps 
\begin_inset Formula $n$
\end_inset

 to the product of all 
\begin_inset Formula $k$
\end_inset

 where 
\begin_inset Formula $k$
\end_inset

 goes from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The Scala expression implementing this mathematical formula is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(n: Int) => (1 to n).product
\end_layout

\end_inset

This expression shows Scala's syntax for a 
\series bold
nameless function
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
nameless function
\end_layout

\end_inset

.
 Here, 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

n: Int
\end_layout

\end_inset

is the function's 
\series bold
argument
\series default
, while
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to n).product
\end_layout

\end_inset

is the function's 
\series bold
body
\series default
.
 The function arrow (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

) separates the argument from the body.
\begin_inset Foot
status open

\begin_layout Plain Layout
In mathematics, the 
\begin_inset Quotes eld
\end_inset

maps to
\begin_inset Quotes erd
\end_inset

 symbol is 
\begin_inset Formula $\mapsto$
\end_inset

, but this book uses a simpler arrow symbol (
\begin_inset Formula $\rightarrow$
\end_inset

) that is visually similar.
 Many programming languages use the symbols 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

->
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

=>
\end_layout

\end_inset

 for the function arrow; see Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lambda-functions-table"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Functions in Scala (whether named or nameless) are treated as values
\begin_inset Index idx
status open

\begin_layout Plain Layout
function as a value
\end_layout

\end_inset

, which means that we can also define a Scala value as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val fac = (n: Int) => (1 to n).product
\end_layout

\begin_layout Plain Layout

fac: Int => Int = <function1>
\end_layout

\end_inset

We see that the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac
\end_layout

\end_inset

 has the type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Int
\end_layout

\end_inset

, which means that the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac
\end_layout

\end_inset

 takes an integer (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

) argument and returns an integer result value.
 What is the value of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac
\end_layout

\end_inset

 
\emph on
itself
\emph default
? As we have just seen, the Scala interpreter prints 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

<function1>
\end_layout

\end_inset

 as the 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac
\end_layout

\end_inset

.
 An alternative Scala interpreter called 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ammonite
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://ammonite.io/"
target "https://ammonite.io/"
literal "false"

\end_inset


\end_layout

\end_inset

 prints this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala@ val fac = (n: Int) => (1 to n).product  //IGNORETHIS
\end_layout

\begin_layout Plain Layout

fac: Int => Int = ammonite.$sess.cmd0$$$Lambda$1675/2107543287@1e44b638
\end_layout

\end_inset

The long number could indicate an address in memory.
 So, we may imagine that a 
\begin_inset Quotes eld
\end_inset

function value
\begin_inset Quotes erd
\end_inset

 represents a block
\emph on
 
\emph default
of compiled code.
 That code will run and evaluate the function's body whenever the function
 is applied to an argument.
\end_layout

\begin_layout Standard
Once defined, a function can be applied to an argument like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> fac(10)
\end_layout

\begin_layout Plain Layout

res1: Int = 3628800
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, functions can be used without naming them.
 We may directly apply a nameless factorial function to an integer argument
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

 instead of writing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fac(10)
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "42col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> ((n: Int) => (1 to n).product)(10)
\end_layout

\begin_layout Plain Layout

res2: Int = 3628800
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We would rarely write code like this.
 Instead of creating a nameless function and then applying it right away
 to an argument, it is easier to evaluate the expression symbolically by
 substituting 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

10
\end_layout

\end_inset

 instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 in the function body:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

((n: Int) => (1 to n).product)(10) == (1 to 10).product
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If a nameless function uses the argument several times, as in this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

((n: Int) => n*n*n + n*n)(12345)
\end_layout

\end_inset

it is still easier to substitute the argument and to eliminate the nameless
 function.
 We could write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

12345*12345*12345 + 12345*12345
\end_layout

\end_inset

but, of course, it is better to avoid repeating the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

12345
\end_layout

\end_inset

.
 To achieve that, we may define 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset


\family default
 as a value in an 
\series bold
expression block
\begin_inset Index idx
status open

\begin_layout Plain Layout
expression block
\end_layout

\end_inset


\series default
 like this:
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> { val n = 12345; n*n*n + n*n }
\end_layout

\begin_layout Plain Layout

res3: Int = 322687002
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Defined in this way, the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is visible only within the expression block.
 Outside the block, another value named 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 could be defined independently of this 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

.
 For this reason, the definition of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is called a 
\series bold
local-scope
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset

 definition.
\end_layout

\begin_layout Standard
Nameless functions are convenient when they are themselves arguments of
 other functions, as we will see next.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Example-prime-numbers"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Example-prime-numbers"
plural "false"
caps "false"
noprefix "false"

\end_inset

: prime numbers
\end_layout

\begin_layout Standard
Define a function that takes an integer argument 
\begin_inset Formula $n$
\end_inset

 and determines whether 
\begin_inset Formula $n$
\end_inset

 is a prime number.
\end_layout

\begin_layout Standard
A simple mathematical formula for this function can be written using the
 
\begin_inset Quotes eld
\end_inset

forall
\begin_inset Quotes erd
\end_inset

 symbol (
\begin_inset Formula $\forall$
\end_inset

) as:
\begin_inset Formula 
\begin{equation}
\text{isPrime}\left(n\right)=\forall k\in\left[2,n-1\right].\ (n\%k)\neq0\quad.\label{eq:is_prime_def}
\end{equation}

\end_inset

This formula has two clearly separated parts: first, a range of integers
 from 
\begin_inset Formula $2$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset

, and second, a requirement that all these integers 
\begin_inset Formula $k$
\end_inset

 should satisfy the given condition: 
\begin_inset Formula $(n\%k)\neq0$
\end_inset

.
 Formula
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is translated into Scala code as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isPrime(n: Int) = (2 to n-1).forall(k => n % k != 0)
\end_layout

\end_inset

This code looks closely similar to the mathematical notation, except for
 the arrow after 
\begin_inset Formula $k$
\end_inset

 that introduces a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k => n % k != 0
\end_layout

\end_inset

.
 We do not need to specify the type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset


\family default
 for the argument 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 of that nameless function.
 The Scala compiler knows that 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 is going to iterate over the 
\emph on
integer
\emph default
 elements of the range 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(2 to n-1)
\end_layout

\end_inset

, which effectively forces 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 to be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 because types must match.
\end_layout

\begin_layout Standard
We can now apply the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

 to some integer values:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> isPrime(12)
\end_layout

\begin_layout Plain Layout

res3: Boolean = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> isPrime(13)
\end_layout

\begin_layout Plain Layout

res4: Boolean = true
\end_layout

\end_inset

As we can see from the output above, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

 returns a value of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

.
 Therefore, the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

 has type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int => Boolean
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A function that returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 value is called a 
\series bold
predicate
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
predicate
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In Scala, it is strongly recommended (although often not mandatory) to specify
 the return type of named functions.
 The required syntax looks like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isPrime(n: Int): Boolean = (2 to n-1).forall(k => n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nameless functions and bound variables
\end_layout

\begin_layout Standard
The code for 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset


\family default
 differs from the mathematical formula
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

) in two ways.
\end_layout

\begin_layout Standard
One difference is that the interval 
\begin_inset Formula $\left[2,n-1\right]$
\end_inset

 is in front of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset

.
 Another is that the Scala code uses a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k => n % k != 0)
\end_layout

\end_inset

, while Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"
plural "false"
caps "false"
noprefix "false"

\end_inset

) does not seem to use such a function.
\end_layout

\begin_layout Standard
To understand the first difference, we need to keep in mind that the Scala
 syntax such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(2 to n-1).forall(k => ...)
\end_layout

\end_inset


\family default
 means to apply a function called 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset


\family default
 to 
\emph on
two
\emph default
 arguments: the first argument is the range 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(2 to n-1)
\end_layout

\end_inset

,
\family default
 and the second argument is the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k => ...)
\end_layout

\end_inset

.
 In Scala, the 
\series bold
method
\series default
 syntax
\begin_inset Index idx
status open

\begin_layout Plain Layout
method syntax
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.f(z)
\end_layout

\end_inset

, and the equivalent 
\series bold
infix
\series default
 syntax
\begin_inset Index idx
status open

\begin_layout Plain Layout
infix syntax
\end_layout

\end_inset

 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x f z
\end_layout

\end_inset

, means that a function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset


\family default
 is applied to its 
\emph on
two
\emph default
 arguments, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

.
 In the ordinary mathematical notation, this would be 
\begin_inset Formula $f(x,z)$
\end_inset

.
 Infix notation is widely used when it is easier to read: for instance,
 we write 
\begin_inset Formula $x+y$
\end_inset

 rather than something like 
\begin_inset Formula $plus\,(x,y)$
\end_inset

.
\end_layout

\begin_layout Standard
A single-argument function could be also defined as a method, and then the
 syntax is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x.f
\end_layout

\end_inset

, as in the expression 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).product
\end_layout

\end_inset


\family default
 we have seen before.
\end_layout

\begin_layout Standard
The methods 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

product
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset


\family default
 are already provided in the Scala standard library, so it is natural to
 use them.
 If we want to avoid the method syntax, we could define a function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forAll
\end_layout

\end_inset


\family default
 with two arguments and write code like this:
\begin_inset space \hfill{}
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

forAll(2 to n-1, k => n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset

This would bring the syntax closer to Eq.
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

).
 However, there still remains the second difference: The symbol 
\begin_inset Formula $k$
\end_inset

 is used as an 
\emph on
argument
\emph default
 of a nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k => n % k != 0)
\end_layout

\end_inset

 in the Scala code, while the formula:
\begin_inset Formula 
\begin{equation}
\forall k\in\left[2,n-1\right].\ (n\%k)\neq0\label{eq:prime-formula-function}
\end{equation}

\end_inset

does not seem to define such a function but defines the symbol 
\begin_inset Formula $k$
\end_inset

 that goes over the range 
\begin_inset Formula $\left[2,n-1\right]$
\end_inset

.
 The variable 
\begin_inset Formula $k$
\end_inset

 is then used for writing the predicate 
\begin_inset Formula $(n\%k)\neq0$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let us investigate the role of 
\begin_inset Formula $k$
\end_inset

 more closely.
 The mathematical variable 
\begin_inset Formula $k$
\end_inset

 is actually defined 
\emph on
only inside
\emph default
 the expression 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\forall k:...$
\end_inset


\begin_inset Quotes erd
\end_inset

 and makes no sense outside that expression.
 This becomes clear by looking at Eq.
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

): The variable 
\begin_inset Formula $k$
\end_inset

 is not present in the left-hand side and could not possibly be used there.
 The name 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $k$
\end_inset


\begin_inset Quotes erd
\end_inset

 is defined only in the right-hand side, where it is first mentioned as
 the arbitrary element 
\begin_inset Formula $k\in\left[2,n-1\right]$
\end_inset

 and then used in the sub-expression 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $n\%k$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
So, the mathematical notation in Eq.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:prime-formula-function"
plural "false"
caps "false"
noprefix "false"

\end_inset

) says two things: First, we use the name 
\begin_inset Formula $k$
\end_inset

 for integers from 
\begin_inset Formula $2$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset

.
 Second, for each of those 
\begin_inset Formula $k$
\end_inset

 we evaluate the expression 
\begin_inset Formula $(n\%k)\neq0$
\end_inset

, which can be viewed as a certain given 
\emph on
function
\emph default
 
\emph on
of
\emph default
 
\begin_inset Formula $k$
\end_inset

 that returns a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

 value.
 Translating the mathematical notation into code, it is therefore natural
 to use the nameless function 
\begin_inset Formula $k\rightarrow(n\%k)\neq0$
\end_inset

 and to write Scala code applying this nameless function to each element
 of the range 
\begin_inset Formula $\left[2,n-1\right]$
\end_inset

 and checking that all result values be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset space \hfill{}
\end_inset


\begin_inset space ~
\end_inset

 
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "40col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(2 to n-1).forall(k => n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset

Just as the mathematical notation defines the variable 
\begin_inset Formula $k$
\end_inset

 only in the right-hand side of Eq.
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

), the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

 of the nameless Scala function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k => n % k != 0
\end_layout

\end_inset

 is defined only within that function's body and cannot be used in any code
 outside the expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n % k != 0
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Variables that are defined only inside an expression and are invisible outside
 are called 
\series bold
bound variables
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
bound variable|textit
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

variables bound in an expression
\begin_inset Quotes erd
\end_inset

.
 Variables that are used in an expression but are defined outside it are
 called 
\series bold
free variables
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
free variable
\end_layout

\end_inset

, or 
\begin_inset Quotes eld
\end_inset

variables occurring free in an expression
\begin_inset Quotes erd
\end_inset

.
 These concepts apply equally well to mathematical formulas and to Scala
 code.
 For example, in the mathematical expression 
\begin_inset Formula $k\rightarrow(n\%k)\neq0$
\end_inset

 (which is a nameless function), the variable 
\begin_inset Formula $k$
\end_inset

 is bound (it is defined only within that expression) but the variable 
\begin_inset Formula $n$
\end_inset

 is free (it is defined outside that expression).
\end_layout

\begin_layout Standard
The main difference between free and bound variables is that bound variables
 can be 
\emph on
locally renamed
\emph default
 at will, unlike free variables.
 To see this, consider that we could rename 
\begin_inset Formula $k$
\end_inset

 to 
\begin_inset Formula $z$
\end_inset

 and write instead of Eq.
\begin_inset space \space{}
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:is_prime_def"

\end_inset

) an equivalent definition:
\begin_inset Formula 
\[
\text{isPrime}\left(n\right)=\forall z\in\left[2,n-1\right].\ (n\%z)\neq0\quad.
\]

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isPrime(n: Int): Boolean = (2 to n-1).forall(z => n % z != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

 in the nameless function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z => n % z != 0
\end_layout

\end_inset

 may be renamed without changing the result of the entire program.
 No code outside that function needs to be changed after renaming 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z
\end_layout

\end_inset

.
 But the value 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 is defined outside and cannot be renamed 
\begin_inset Quotes eld
\end_inset

locally
\begin_inset Quotes erd
\end_inset

 (i.e., only within the sub-expression).
 If we wanted to rename 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 in the sub-expression 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

z => n % z != 0
\end_layout

\end_inset

, we would also need to change all other code that defines and uses 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

n
\end_layout

\end_inset

 
\emph on
outside
\emph default
 that expression, or else the program would become incorrect.
\end_layout

\begin_layout Standard
Mathematical formulas use bound variables in various constructions such
 as 
\begin_inset Formula $\forall k.\,p(k)$
\end_inset

, 
\begin_inset Formula $\exists k.\,p(k)$
\end_inset

, 
\begin_inset Formula $\sum_{k=a}^{b}f(k)$
\end_inset

, 
\begin_inset Formula $\int_{0}^{1}k^{2}dk$
\end_inset

, 
\begin_inset Formula $\lim_{n\rightarrow\infty}f(n)$
\end_inset

, and 
\begin_inset Formula $\text{argmax}_{k}f\left(k\right)$
\end_inset

.
 When translating mathematical expressions into code, we need to recognize
 the presence of bound variables, which the mathematical notation does not
 make quite so explicit.
 For each bound variable, we create a nameless function whose argument is
 that variable, e.g., 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k=>p(k)
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k=>f(k)
\end_layout

\end_inset

 for the examples just shown.
 Then our code will correctly reproduce the behavior of bound variables
 in mathematical expressions.
\end_layout

\begin_layout Standard
As an example, the mathematical formula 
\begin_inset Formula $\forall k\in\left[1,n\right].\,p\left(k\right)$
\end_inset

 has a bound variable 
\begin_inset Formula $k$
\end_inset

 and is translated into Scala code as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to n).forall(k => p(k))
\end_layout

\end_inset

At this point we can apply a simplification trick to this code.
 The nameless function 
\begin_inset Formula $k\rightarrow p(k)$
\end_inset

 does exactly the same thing as the (named) function 
\begin_inset Formula $p$
\end_inset

: It takes an argument, which we may call 
\begin_inset Formula $k$
\end_inset

, and returns 
\begin_inset Formula $p(k)$
\end_inset

.
 So, we can simplify the Scala code above to:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to n).forall(p)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The simplification of 
\begin_inset Formula $x\rightarrow f(x)$
\end_inset

 to just 
\begin_inset Formula $f$
\end_inset

 is always possible for functions 
\begin_inset Formula $f$
\end_inset

 of a single argument.
\begin_inset Foot
status open

\begin_layout Plain Layout
Certain features of Scala allow programmers to write code that looks like
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f(x)
\end_layout

\end_inset

 but actually uses an automatic type conversion for the argument 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset

 or additional hidden arguments of the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

.
 In those cases, replacing the code 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => f(x)
\end_layout

\end_inset

 by 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f
\end_layout

\end_inset

 will fail to compile.
 This problem does not appear when working with simple functions.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Aggregating data from sequences
\end_layout

\begin_layout Standard
Consider the task of counting how many even numbers there are in a given
 list 
\begin_inset Formula $L$
\end_inset

 of integers.
 For example, the list 
\begin_inset Formula $\left[5,6,7,8,9\right]$
\end_inset

 contains 
\emph on
two
\emph default
 even numbers: 
\begin_inset Formula $6$
\end_inset

 and 
\begin_inset Formula $8$
\end_inset

.
\end_layout

\begin_layout Standard
A mathematical formula for this task can be written using the 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 operation (denoted by 
\begin_inset Formula $\sum$
\end_inset

):
\begin_inset Formula 
\begin{align*}
\text{countEven}\left(L\right) & =\sum_{k\in L}\text{isEven}\left(k\right)\quad,\\
\text{isEven}\left(k\right) & =\begin{cases}
1 & \text{if }(k\%2)=0\quad,\\
0 & \text{otherwise}\quad.
\end{cases}
\end{align*}

\end_inset

Here we defined a helper function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isEven
\end_layout

\end_inset


\family default
 in order to write more easily a formula for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

countEven
\end_layout

\end_inset

.
 In mathematics, complicated formulas are often split into simpler parts
 by defining helper expressions.
 
\end_layout

\begin_layout Standard
We can write the Scala code similarly.
 We first define the helper function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isEven
\end_layout

\end_inset

; the Scala code can be written in a style quite similar to the mathematical
 formula:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isEven(k: Int): Int = (k % 2) match {
\end_layout

\begin_layout Plain Layout

  case 0 => 1 // First, check if it is zero.
\end_layout

\begin_layout Plain Layout

  case _ => 0 // The underscore matches everything else.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For such a simple computation, we could also write shorter code using a
 nameless function:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val isEven = (k: Int) => if (k % 2 == 0) 1 else 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given this function, we now need to translate into Scala code the expression
 
\begin_inset Formula $\sum_{k\in L}\text{is\_even}\left(k\right)$
\end_inset

.
 We can represent the list 
\begin_inset Formula $L$
\end_inset

 using the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

 from the Scala standard library.
\end_layout

\begin_layout Standard
To compute 
\begin_inset Formula $\sum_{k\in L}\text{is\_even}\left(k\right)$
\end_inset

, we must apply the function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isEven
\end_layout

\end_inset


\family default
 to each element of the list 
\begin_inset Formula $L$
\end_inset

, which will produce a list of some (integer) results, and then we will
 need to add all those results together.
 It is convenient to perform these two steps separately.
 This can be done with the functions 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, defined in the Scala standard library as methods for the data type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The method 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset


\family default
 is similar to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

product
\end_layout

\end_inset

 and is defined for any 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List
\end_layout

\end_inset

 of numerical types (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

, etc.).
 It computes the sum of all numbers in the list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3).sum
\end_layout

\begin_layout Plain Layout

res0: Int = 6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The method 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\family default
 needs more explanation.
 This method takes a 
\emph on
function
\emph default
 as its second argument and applies that function to each element of the
 list.
 All the results are stored in a 
\emph on
new 
\emph default
list, which is then returned as the result value:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3).map(x => x*x + 100*x)
\end_layout

\begin_layout Plain Layout

res1: List[Int] = List(101, 204, 309)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example, the argument of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

 is the nameless function 
\begin_inset Formula $x\rightarrow x^{2}+100x$
\end_inset

.
 This function will be used repeatedly by 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\family default
 to transform each integer from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List(1, 2, 3)
\end_layout

\end_inset

, creating a new list as a result.
\end_layout

\begin_layout Standard
It is equally possible to define the transforming function separately, give
 it a name, and then use it as the argument to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def func1(x: Int): Int = x*x + 100*x
\end_layout

\begin_layout Plain Layout

func1: (x: Int)Int 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(1, 2, 3).map(func1)
\end_layout

\begin_layout Plain Layout

res2: List[Int] = List(101, 204, 309)
\end_layout

\end_inset

Short functions are often defined inline, while longer functions are defined
 separately with a name.
\end_layout

\begin_layout Standard
A method, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, can be also used with a 
\begin_inset Quotes eld
\end_inset

dotless
\begin_inset Quotes erd
\end_inset

 (
\series bold
infix
\series default
) syntax
\begin_inset Index idx
status open

\begin_layout Plain Layout
infix syntax
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3) map func1       // Same as List(1, 2, 3).map(func1)
\end_layout

\begin_layout Plain Layout

res3: List[Int] = List(101, 204, 309)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the transforming function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func1
\end_layout

\end_inset

 is used only once, and especially for a simple computation such as 
\begin_inset Formula $x\rightarrow x*x+100*x$
\end_inset

, it is easier to work with a nameless function.
\end_layout

\begin_layout Standard
We can now combine the methods 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset


\family default
 to define 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

countEven
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countEven(s: List[Int]) = s.map(isEven).sum
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code can be also written using a nameless function instead of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isEven
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def countEven(s: List[Int]): Int = s
\end_layout

\begin_layout Plain Layout

    .map { k => if (k % 2 == 0) 1 else 0 }
\end_layout

\begin_layout Plain Layout

    .sum
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Scala, methods are often used one after another, as if in a chain.
 For instance, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.map(...).sum
\end_layout

\end_inset

 means: first apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.map(...)
\end_layout

\end_inset

, which returns a 
\emph on
new
\emph default
 list; then apply 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset


\family default
 to that new list.
 To make the code more readable, we may put each of the chained methods
 on a new line.
 
\end_layout

\begin_layout Standard
To test this code, let us run it in the Scala interpreter.
 In order to let the interpreter work correctly with code entered line by
 line, the dot character needs to be at the 
\emph on
end
\emph default
 of the line.
 (In compiled code, the dots may be at the beginning of line since the compiler
 reads the entire file at once.)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> def countEven(s: List[Int]): Int = s.
\end_layout

\begin_layout Plain Layout

         map { k => if (k % 2 == 0) 1 else 0 }.
\end_layout

\begin_layout Plain Layout

         sum
\end_layout

\begin_layout Plain Layout

countEven: (s: List[Int])Int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countEven(List(1,2,3,4,5))
\end_layout

\begin_layout Plain Layout

res0: Int = 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> countEven( List(1,2,3,4,5).map(x => x * 2) )
\end_layout

\begin_layout Plain Layout

res1: Int = 5
\end_layout

\end_inset

Note that the Scala interpreter prints the types differently for named functions
 (i.e., functions declared using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

def
\end_layout

\end_inset

).
 It prints 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(s: List[Int])Int
\end_layout

\end_inset

 for a function of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int] => Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Filtering and truncating a sequence 
\end_layout

\begin_layout Standard
In addition to the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

product
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset


\family default
 that we have already seen, the Scala standard library defines many other
 useful methods.
 We will now take a look at using the methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exists
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

, and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

size
\end_layout

\end_inset


\family default
 are self-explanatory:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(10, 20, 30).max
\end_layout

\begin_layout Plain Layout

res2: Int = 30
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(10, 20, 30).min
\end_layout

\begin_layout Plain Layout

res3: Int = 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> List(10, 20, 30).size
\end_layout

\begin_layout Plain Layout

res4: Int = 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exists
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset


\family default
 require a predicate as an argument.
 The 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

forall
\end_layout

\end_inset


\family default
 method returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
 if and only if the predicate returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

 for all values in the list.
 The 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

exists
\end_layout

\end_inset


\family default
 method returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
 if and only if the predicate holds (returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

) for at least one value in the list.
 These methods can be written as mathematical formulas like this:
\begin_inset Formula 
\begin{align*}
\text{forall}\left(S,p\right) & =\forall k\in S.\,\big(p(k)=\text{true}\big)\quad,\\
\text{exists}\left(S,p\right) & =\exists k\in S.\,\big(p(k)=\text{true}\big)\quad.
\end{align*}

\end_inset

However, we will use Scala syntax for operations such as 
\begin_inset Quotes eld
\end_inset

removing elements from a list
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 method returns a list that contains only the values for which a predicate
 returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3, 4, 5).filter(k => k != 3)           // Exclude the value
 3.
\end_layout

\begin_layout Plain Layout

res5: List[Int] = List(1, 2, 4, 5)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset


\family default
 method truncates a given list.
 More precisely, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 returns a new list that contains the initial portion of values from the
 original list for which predicate remains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> List(1, 2, 3, 4, 5).takeWhile(k => k != 3)    // Truncate at the value
 3.
\end_layout

\begin_layout Plain Layout

res6: List[Int] = List(1, 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all these cases, the predicate's argument, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset

, will be of the same type as the elements in the list.
 In the examples shown above, the elements are integers (i.e., the lists have
 type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

), therefore 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

k
\end_layout

\end_inset


\family default
 must be of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

product
\end_layout

\end_inset


\family default
 are defined for lists of numeric types, such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Float
\end_layout

\end_inset

.
 The methods 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset

 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

min
\end_layout

\end_inset

 are defined on lists of 
\begin_inset Quotes eld
\end_inset

orderable
\begin_inset Quotes erd
\end_inset

 types (including 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Boolean
\end_layout

\end_inset

, and the numeric types).
 The other methods are defined for lists of all types.
\end_layout

\begin_layout Standard
Using these methods, we can solve many problems that involve transforming
 and aggregating data stored in lists, arrays, sets, and other data structures
 that work as 
\begin_inset Quotes eld
\end_inset

containers storing values
\begin_inset Quotes erd
\end_inset

.
 In this context, a 
\series bold
transformation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
data transformation
\end_layout

\end_inset

 is a function taking a container with values and returning a new container
 with changed values.
 (We speak of 
\begin_inset Quotes eld
\end_inset

transformation
\begin_inset Quotes erd
\end_inset

 even though the original container 
\emph on
remains unchanged
\emph default
.) Examples of transformations are 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

.
 An 
\series bold
aggregation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
aggregation
\end_layout

\end_inset

 is a function taking a container of values and returning a 
\emph on
single
\emph default
 value.
 Examples of aggregations are 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

max
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Writing programs by chaining together various methods of transformation
 and aggregation is known as programming in the 
\series bold
map/reduce
\series default
 
\series bold
style
\series default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
map
\family default
/
\family typewriter
reduce
\family default
 programming style|textit
\end_layout

\end_inset


\end_layout

\begin_layout Section
Solved examples
\begin_inset Index idx
status open

\begin_layout Plain Layout
solved examples
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aggregations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Aggregation-solved-examples"

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Improve the code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

 by limiting the search to 
\begin_inset Formula $k\leq\sqrt{n}$
\end_inset

:
\begin_inset Formula 
\[
\text{isPrime}\left(n\right)=\forall k\in\left[2,n-1\right]\text{ such that if }k*k\leq n\text{ then }(n\%k)\neq0\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Use 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

 to truncate the initial list when 
\begin_inset Formula $k*k\leq n$
\end_inset

 becomes false:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def isPrime(n: Int): Boolean =
\end_layout

\begin_layout Plain Layout

  (2 to n-1)
\end_layout

\begin_layout Plain Layout

    .takeWhile(k =>  k*k <= n)
\end_layout

\begin_layout Plain Layout

    .forall(k =>  n % k != 0)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute this product of absolute values: 
\begin_inset Formula $\prod_{k=1}^{10}\left|\sin\left(k+2\right)\right|$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to 10)
\end_layout

\begin_layout Plain Layout

  .map(k => math.abs(math.sin(k + 2)))
\end_layout

\begin_layout Plain Layout

  .product
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute 
\begin_inset Formula $\sum_{k\in[1,10];~\cos k>0}\sqrt{\cos k}$
\end_inset

 (the sum goes only over 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $\cos k>0$
\end_inset

).
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to 10)
\end_layout

\begin_layout Plain Layout

  .filter(k => math.cos(k) > 0)
\end_layout

\begin_layout Plain Layout

  .map(k => math.sqrt(math.cos(k)))
\end_layout

\begin_layout Plain Layout

  .sum
\end_layout

\end_inset

It is safe to compute 
\begin_inset Formula $\sqrt{\cos k}$
\end_inset

, because we have first filtered the list by keeping only values 
\begin_inset Formula $k$
\end_inset

 for which 
\begin_inset Formula $\cos k>0$
\end_inset

.
 Let us check that this is so:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).toList.filter(k => math.cos(k) > 0).map(x => math.cos(x))
\end_layout

\begin_layout Plain Layout

res0: List[Double] = List(0.5403023058681398, 0.28366218546322625, 0.96017028665036
61, 0.7539022543433046)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Compute the average of a non-empty list of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Double]
\end_layout

\end_inset

,
\begin_inset Formula 
\[
\text{average}\left(s\right)=\frac{1}{n}\sum_{i=0}^{n-1}s_{i}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
We need to divide the sum by the length of the list:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def average(s: List[Double]): Double = s.sum / s.size
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> average(List(1.0, 2.0, 3.0))
\end_layout

\begin_layout Plain Layout

res0: Double = 2.0
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-5-Wallis-product"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-5-Wallis-product"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $n$
\end_inset

, compute the Wallis product
\begin_inset Index idx
status open

\begin_layout Plain Layout
Wallis product
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Wallis_product"
target "https://en.wikipedia.org/wiki/Wallis_product"
literal "false"

\end_inset


\end_layout

\end_inset

 truncated up to 
\begin_inset Formula $\frac{2n}{2n+1}$
\end_inset

: 
\begin_inset Formula 
\[
\text{wallis}\left(n\right)=\frac{2}{1}\frac{2}{3}\frac{4}{3}\frac{4}{5}\frac{6}{5}\frac{6}{7}...\frac{2n}{2n+1}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Define the helper function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wallis_frac(i)
\end_layout

\end_inset

 that computes the 
\begin_inset Formula $i^{\text{th}}$
\end_inset

 fraction.
 The method 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

toDouble
\end_layout

\end_inset


\family default
 converts integers to 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset


\family default
 numbers:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def wallis_frac(i: Int): Double = (2*i).toDouble/(2*i - 1)*(2*i)/(2*i + 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def wallis(n: Int) = (1 to n).map(wallis_frac).product
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> math.cos(wallis(10000))  // Should be close to 0.
\end_layout

\begin_layout Plain Layout

res0: Double = 3.9267453954401036E-5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> math.cos(wallis(100000)) // Should be even closer to 0.
\end_layout

\begin_layout Plain Layout

res1: Double = 3.926966362362075E-6
\end_layout

\end_inset

The cosine of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wallis(n)
\end_layout

\end_inset

 tends to zero for large 
\begin_inset Formula $n$
\end_inset

 because the limit of the Wallis product is 
\begin_inset Formula $\frac{\pi}{2}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-6"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-6"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Check numerically that 
\begin_inset Formula $\sum_{k=1}^{\infty}\frac{1}{k^{2}}=\frac{\pi^{2}}{6}$
\end_inset

.
 First, define a function of 
\begin_inset Formula $n$
\end_inset

 that computes a partial sum of that series until 
\begin_inset Formula $k=n$
\end_inset

.
 Then compute the partial sum for a large value of 
\begin_inset Formula $n$
\end_inset

 and compare with the limit value.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def euler_series(n: Int): Double = (1 to n).map(k => 1.0 / k / k).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> euler_series(100000)
\end_layout

\begin_layout Plain Layout

res0: Double = 1.6449240668982423
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> val pi = math.Pi
\end_layout

\begin_layout Plain Layout

pi: Double = 3.141592653589793
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> pi * pi / 6
\end_layout

\begin_layout Plain Layout

res1: Double = 1.6449340668482264 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-7"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-7"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Check numerically the infinite product formula:
\begin_inset Formula 
\[
\prod_{k=1}^{\infty}\left(1-\frac{x^{2}}{k^{2}}\right)=\frac{\sin\pi x}{\pi x}\quad.
\]

\end_inset


\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
Compute this product up to 
\begin_inset Formula $k=n$
\end_inset

 for 
\begin_inset Formula $x=0.1$
\end_inset

 with a large value of 
\begin_inset Formula $n$
\end_inset

, say 
\begin_inset Formula $n=10^{5}$
\end_inset

, and compare with the right-hand side:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sine_product(n: Int, x: Double): Double = (1 to n).map(k => 1.0 - x*x/k/k).prod
uct
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> sine_product(n = 100000, x = 0.1) // Arguments may be named, for clarity.
\end_layout

\begin_layout Plain Layout

res0: Double = 0.9836317414461351
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> math.sin(pi * 0.1) / pi / 0.1
\end_layout

\begin_layout Plain Layout

res1: Double = 0.9836316430834658
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Example-8"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-8"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset Formula $p$
\end_inset

 that takes a list of integers and a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Int
\end_layout

\end_inset

, and returns the largest value of 
\begin_inset Formula $f(x)$
\end_inset

 among all 
\begin_inset Formula $x$
\end_inset

 in the list.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def p(s: List[Int], f: Int => Int): Int = s.map(f).max
\end_layout

\end_inset

Here is a test for this function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> p(List(2, 3, 4, 5), x => 60 / x)
\end_layout

\begin_layout Plain Layout

res0: Int = 30
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Transformations
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-Example-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-Example-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a list of lists, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s: List[List[Int]]
\end_layout

\end_inset

, select the inner lists of size at least 
\begin_inset Formula $3$
\end_inset

.
 The result must be again of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
To 
\begin_inset Quotes eld
\end_inset

select the inner lists
\begin_inset Quotes erd
\end_inset

 means to compute a 
\emph on
new
\emph default
 list containing only the desired inner lists.
 We use 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\family default
 on the outer list 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

.
 The predicate for the filter is a function that takes an inner list and
 returns 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset


\family default
 if the size of that list is at least 
\begin_inset Formula $3$
\end_inset

.
 Write the predicate as a nameless function, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t => t.size >= 3
\end_layout

\end_inset

, where 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset


\family default
 is of type 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(s: List[List[Int]]): List[List[Int]] = s.filter(t => t.size >= 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> f(List(  List(1,2), List(1,2,3), List(1,2,3,4)  ))
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(1, 2, 3), List(1, 2, 3, 4)) 
\end_layout

\end_inset

The Scala compiler deduces from the code that the type of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

t
\end_layout

\end_inset

 is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Int]
\end_layout

\end_inset

 because we apply 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 to a 
\emph on
list of lists
\emph default
 of integers.
\end_layout

\begin_layout Subsubsection
Example 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-Example-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-Example-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Find all integers 
\begin_inset Formula $k\in\left[1,10\right]$
\end_inset

 such that there are at least three different integers 
\begin_inset Formula $j$
\end_inset

, where 
\begin_inset Formula $1\leq j\leq k$
\end_inset

, each 
\begin_inset Formula $j$
\end_inset

 satisfying the condition 
\begin_inset Formula $j*j>2*k$
\end_inset

.
\end_layout

\begin_layout Subparagraph
Solution
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> (1 to 10).toList.filter(k => (1 to k).filter(j => j*j > 2*k).size >=
 3)
\end_layout

\begin_layout Plain Layout

res0: List[Int] = List(6, 7, 8, 9, 10) 
\end_layout

\end_inset

The argument of the outer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

 is a nameless function that also uses a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

.
 The inner expression
\end_layout

\begin_layout Standard
\noindent
\begin_inset Wrap figure
lines 0
placement l
overhang 0in
width "45col%"
status open

\begin_layout Plain Layout
\begin_inset VSpace -80baselineskip%
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(1 to k).filter(j => j*j > 2*k).size >= 3
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -150baselineskip%
\end_inset


\end_layout

\end_inset

 (shown at left) computes the list of 
\begin_inset Formula $j$
\end_inset

's that satisfy the condition 
\begin_inset Formula $j*j>2*k$
\end_inset

, and then compares the size of that list with 
\begin_inset Formula $3$
\end_inset

.
 In this way, we impose the requirement that there should be at least 
\begin_inset Formula $3$
\end_inset

 values of 
\begin_inset Formula $j$
\end_inset

.
 We can see how the Scala code closely follows the mathematical formulation
 of the task.
\end_layout

\begin_layout Section
Summary
\end_layout

\begin_layout Standard
Functional programs are mathematical formulas translated into code.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:translating-mathematics-into-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how to implement some often used mathematical constructions in Scala.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Mathematical notation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Scala code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x\rightarrow\sqrt{x^{2}+1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x => math.sqrt(x*x + 1)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[1,~2,~...,~n\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[f(1),~...,~f(n)\right]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).map(k => f(k))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\sum_{k=1}^{n}k^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).map(k => k*k).sum
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\prod_{k=1}^{n}f(k)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).map(f).product
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall k\in[1,...,n].\,p(k)\text{ holds}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).forall(k => p(k))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\exists k\in[1,...,n].\,p(k)\text{ holds}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(1 to n).exists(k => p(k))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \sum_{k\in S\text{ such that }p(k)\text{ holds}}}f(k)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.filter(p).map(f).sum
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Translating mathematics into code.
\begin_inset CommandInset label
LatexCommand label
name "tab:translating-mathematics-into-code"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
What problems can one solve with this knowledge?
\end_layout

\begin_layout Itemize
Compute mathematical expressions involving sums, products, and quantifiers,
 based on integer ranges, such as 
\begin_inset Formula $\sum_{k=1}^{n}f(k)$
\end_inset

.
\end_layout

\begin_layout Itemize
Transform and aggregate data from lists using 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

,
\series bold
 
\series default

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and other methods from the Scala standard library.
\end_layout

\begin_layout Standard
What are examples of problems that are 
\emph on
not
\emph default
 solvable with these tools?
\end_layout

\begin_layout Itemize
Example
\begin_inset space ~
\end_inset

1: Compute the smallest 
\begin_inset Formula $n\geq1$
\end_inset

 such that 
\begin_inset Formula $f(f(f(...f(0)...)))\geq1000$
\end_inset

, where the given function 
\begin_inset Formula $f$
\end_inset

 is applied 
\begin_inset Formula $n$
\end_inset

 times.
\end_layout

\begin_layout Itemize
Example
\begin_inset space ~
\end_inset

2: Given a list 
\begin_inset Formula $s$
\end_inset

 of numbers, compute the list 
\begin_inset Formula $r$
\end_inset

 of running averages: 
\begin_inset Formula 
\[
r_{n}=\frac{1}{n}\sum_{k=0}^{n-1}s_{k}\quad.
\]

\end_inset


\end_layout

\begin_layout Itemize
Example
\begin_inset space ~
\end_inset

3: Perform binary search over a sorted list of integers.
\end_layout

\begin_layout Standard
These computations involve a general case of 
\emph on
mathematical induction
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Library functions we have seen so far, such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\family default
 and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, implement a restricted class of iterative operations on lists: namely,
 operations that process each element of a given list independently and
 accumulate results.
 In those cases, the number of iterations is known (or at least bounded)
 in advance.
 For instance, when computing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s.map(f)
\end_layout

\end_inset

, the number of function applications is given by the size of the initial
 list.
 However, Example
\begin_inset space \space{}
\end_inset

1 requires applying a function 
\begin_inset Formula $f$
\end_inset

 repeatedly until a given condition holds — that is, repeating for an 
\emph on
initially unknown
\emph default
 number of times.
 So it is impossible to write an expression containing 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

takeWhile
\end_layout

\end_inset

, etc., that solves Example
\begin_inset space \space{}
\end_inset

1.
 We could write the solution of Example
\begin_inset space \space{}
\end_inset

1 as a formula by using mathematical induction, but we have not yet seen
 how to implement that in Scala code.
 
\end_layout

\begin_layout Standard
Example
\begin_inset space \space{}
\end_inset

2 can be formulated as a definition of a new list 
\begin_inset Formula $r$
\end_inset

 by induction: the base case is 
\begin_inset Formula $r_{0}=s_{0}$
\end_inset

, and the inductive step is 
\begin_inset Formula $r_{i}=s_{i}+r_{i-1}$
\end_inset

 for 
\begin_inset Formula $i=1,2,3,...$
\end_inset

 However, operations such as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset


\family default
 and 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\family default
 cannot compute 
\begin_inset Formula $r_{i}$
\end_inset

 depending on the value of 
\begin_inset Formula $r_{i-1}$
\end_inset

.
\end_layout

\begin_layout Standard
Example
\begin_inset space \space{}
\end_inset

3 defines the search result by induction: the list is split in half, and
 search is performed recursively (i.e., using the inductive hypothesis) in
 the half that contains the required value.
 This computation requires an initially unknown number of steps.
\end_layout

\begin_layout Standard
Chapter
\begin_inset space \space{}
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:2-Mathematical-induction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 explains how to implement these tasks using recursion.
\end_layout

\begin_layout Section
Exercises
\begin_inset CommandInset label
LatexCommand label
name "sec:beginner-Exercises"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
exercises
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aggregations
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Exercise-1-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Exercise-1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function that computes a 
\begin_inset Quotes eld
\end_inset

staggered factorial
\begin_inset Index idx
status open

\begin_layout Plain Layout
staggered factorial function
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 (denoted by 
\begin_inset Formula $n!!$
\end_inset

) for positive integers.
 It is defined as either 
\begin_inset Formula $1\cdot3\cdot...\cdot n$
\end_inset

 or as 
\begin_inset Formula $2\cdot4\cdot...\cdot n$
\end_inset

, depending on whether 
\begin_inset Formula $n$
\end_inset

 is even or odd.
 For example, 
\begin_inset Formula $8!!=384$
\end_inset

 and 
\begin_inset Formula $9!!=945$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Machin's formula
\begin_inset Index idx
status open

\begin_layout Plain Layout
Machin's formula
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "http://turner.faculty.swau.edu/mathematics/materialslibrary/pi/machin.html"
target "http://turner.faculty.swau.edu/mathematics/materialslibrary/pi/machin.html"
literal "false"

\end_inset


\end_layout

\end_inset

 converges to 
\begin_inset Formula $\pi$
\end_inset

 faster than Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Example-5-Wallis-product"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
\frac{\pi}{4} & =4\arctan\frac{1}{5}-\arctan\frac{1}{239}\quad,\\
\arctan\frac{1}{n} & =\frac{1}{n}-\frac{1}{3}\frac{1}{n^{3}}+\frac{1}{5}\frac{1}{n^{5}}-...=\sum_{k=0}^{\infty}\frac{\left(-1\right)^{k}}{2k+1}n^{-2k-1}\quad.
\end{align*}

\end_inset

Implement a function that computes the series for 
\begin_inset Formula $\arctan\frac{1}{n}$
\end_inset

 up to a given number of terms, and compute an approximation of 
\begin_inset Formula $\pi$
\end_inset

 using this formula.
 Show that 
\begin_inset Formula $12$
\end_inset

 terms of the series are already sufficient for a full-precision 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Double
\end_layout

\end_inset

 approximation of 
\begin_inset Formula $\pi$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-aggr-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-aggr-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Using the function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

isPrime
\end_layout

\end_inset

, check numerically the Euler product
\begin_inset Index idx
status open

\begin_layout Plain Layout
Euler product
\end_layout

\end_inset

 formula
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Proof_of_the_Euler_product_formula_for_the_Riemann_zeta_function"
target "https://en.wikipedia.org/wiki/Proof_of_the_Euler_product_formula_for_the_Riemann_zeta_function"
literal "false"

\end_inset


\end_layout

\end_inset

 for the Riemann's zeta function
\begin_inset Index idx
status open

\begin_layout Plain Layout
Riemann's zeta function
\end_layout

\end_inset

 
\begin_inset Formula $\zeta\left(4\right)$
\end_inset

.
 It is known
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
name "https://tinyurl.com/yxey4tsd"
target "https://ocw.mit.edu/courses/mathematics/18-104-seminar-in-analysis-applications-to-number-theory-fall-2006/projects/chan.pdf"
literal "false"

\end_inset


\end_layout

\end_inset

 that 
\begin_inset Formula $\zeta\left(4\right)=\frac{\pi^{4}}{90}$
\end_inset

:
\begin_inset Formula 
\[
\zeta\left(4\right)=\prod_{k\geq2;~k\text{ is prime}}\frac{1}{1-\frac{1}{p^{4}}}=\frac{\pi^{4}}{90}\quad.
\]

\end_inset


\end_layout

\begin_layout Subsection
Transformations
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-1"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

add20
\end_layout

\end_inset


\family default
 of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]] => List[List[Int]]
\end_layout

\end_inset


\family default
 that adds 
\begin_inset Formula $20$
\end_inset

 to every element of every inner list.
 A sample test:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> add20( List( List(1), List(2, 3) ) )
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(21), List(22, 23))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-2"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
An integer 
\begin_inset Formula $n$
\end_inset

 is called a 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-factor
\begin_inset Quotes erd
\end_inset

 if it is divisible by only three different integers 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $2\leq j<n$
\end_inset

.
 Compute the set of all 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-factor
\begin_inset Quotes erd
\end_inset

 integers 
\begin_inset Formula $n$
\end_inset

 among 
\begin_inset Formula $n\in[1,...,1000]$
\end_inset

 .
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-3"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-3"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Given a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

f: Int => Boolean
\end_layout

\end_inset

, an integer 
\begin_inset Formula $n$
\end_inset

 is called a 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-
\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

 if there are only three different integers 
\begin_inset Formula $j\in[1,...,n]$
\end_inset

 such that 
\begin_inset Formula $f(j)$
\end_inset

 returns 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

true
\end_layout

\end_inset

.
 Define a function that takes 
\begin_inset Formula $f$
\end_inset

 as an argument and returns a sequence of all 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $3$
\end_inset

-
\begin_inset Formula $f$
\end_inset


\begin_inset Quotes erd
\end_inset

 integers among 
\begin_inset Formula $n\in[1,...,1000]$
\end_inset

.
 What is the type of that function? Implement Exercise
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using that function.
\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-4"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-4"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

see100
\end_layout

\end_inset

 of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[List[Int]] => List[List[Int]]
\end_layout

\end_inset


\family default
 that selects only those inner lists whose largest value is at least 
\begin_inset Formula $100$
\end_inset

.
 Test with:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> see100( List( List(0, 1, 100), List(60, 80), List(1000) ) )
\end_layout

\begin_layout Plain Layout

res0: List[List[Int]] = List(List(0, 1, 100), List(1000))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Exercise 
\begin_inset CommandInset label
LatexCommand label
name "subsec:ch1-transf-Exercise-5"

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:ch1-transf-Exercise-5"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
Define a function of type 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

List[Double] => List[Double]
\end_layout

\end_inset


\family default
 that 
\begin_inset Quotes eld
\end_inset

normalizes
\begin_inset Quotes erd
\end_inset

 the list: it finds the element having the largest absolute value and, if
 that value is nonzero, divides all elements by that value and returns a
 new list; otherwise returns the original list.
 Test with:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> normalize(List(1.0, 4.0, 2.0))
\end_layout

\begin_layout Plain Layout

res0: List[Double] = List(0.25, 1.0, 0.5)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Subsection
Functional programming as a paradigm
\end_layout

\begin_layout Standard
Functional programming
\begin_inset Index idx
status open

\begin_layout Plain Layout
functional programming paradigm
\end_layout

\end_inset

 (FP) is a 
\series bold
paradigm
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
paradigm of programming
\end_layout

\end_inset

 of programming — an approach that guides programmers to write code in specific
 ways, applicable to a wide range of tasks.
\end_layout

\begin_layout Standard
The main idea of FP is to write code 
\emph on
as a mathematical expression or formula
\emph default
.
 This approach allows programmers to derive code through logical reasoning
 rather than through guessing, similarly to how books on mathematics reason
 about mathematical formulas and derive results systematically, without
 guessing or 
\begin_inset Quotes eld
\end_inset

debugging.
\begin_inset Quotes erd
\end_inset

 Like mathematicians and scientists who reason about formulas, functional
 programmers can 
\emph on
reason about code
\emph default
 systematically and logically, based on rigorous principles.
 This is possible only because code is written as a mathematical formula.
\end_layout

\begin_layout Standard
Mathematical intuition is useful for programming tasks because it is backed
 by the vast experience of working with data over millennia of human history.
 It took centuries to invent flexible and powerful notation, such as 
\begin_inset Formula $\sum_{k\in S}p(k)$
\end_inset

, and to develop the corresponding rules of calculation.
 Converting formulas into code, FP capitalizes on the power of these reasoning
 tools.
\end_layout

\begin_layout Standard
As we have seen, the Scala code for certain computational tasks corresponds
 quite closely to mathematical formulas (although programmers do have to
 write out some details that are omitted in the mathematical notation).
 Just as in mathematics, large code expressions may be split into smaller
 expressions when needed.
 Expressions can be easily reused, composed in various ways, and written
 independently from each other.
 Over the years, the FP community has developed a toolkit of functions (such
 as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset


\family default
, etc.) that proved to be especially useful in real-life programming, although
 many of them are not standard in mathematical literature.
\end_layout

\begin_layout Standard
Mastering FP involves practicing to reason about programs as formulas 
\begin_inset Quotes eld
\end_inset

translated into code
\begin_inset Quotes erd
\end_inset

, building up the specific kind of applied mathematical intuition, and getting
 familiar with mathematical concepts adapted to a programmer's needs.
 The FP community has discovered a number of specific programming idioms
 founded on mathematical principles but driven by practical necessities
 of writing software.
 This book explains the theory behind those idioms, starting from code examples
 and heuristic ideas, and gradually building up the techniques of rigorous
 reasoning.
\end_layout

\begin_layout Standard
This chapter explored the first significant idiom of FP: iterative calculations
 performed without loops, in the style of mathematical expressions.
 This technique can be easily used in any programming language that supports
 nameless functions.
 
\end_layout

\begin_layout Subsection
The mathematical meaning of 
\begin_inset Quotes eld
\end_inset

variables
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The usage of variables in functional programming is similar to how mathematical
 literature uses variables.
 In mathematics, 
\series bold
variables
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
variable
\end_layout

\end_inset

 are used first of all as 
\emph on
arguments
\emph default
 of functions; e.g., the formula:
\begin_inset Formula 
\[
f(x)=x^{2}+x
\]

\end_inset

contains the variable 
\begin_inset Formula $x$
\end_inset

 and defines a function 
\begin_inset Formula $f$
\end_inset

 that takes 
\begin_inset Formula $x$
\end_inset

 as its argument (to be definite, assume that 
\begin_inset Formula $x$
\end_inset

 is an integer) and computes the value 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 The body of the function is the expression 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 
\end_layout

\begin_layout Standard
Mathematics has the convention that a variable, such as 
\begin_inset Formula $x$
\end_inset

, does not change its value within a formula.
 Indeed, there is no mathematical notation even to talk about 
\begin_inset Quotes eld
\end_inset

changing
\begin_inset Quotes erd
\end_inset

 the value of 
\begin_inset Formula $x$
\end_inset

 
\emph on
inside
\emph default
 the formula 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 It would be quite confusing if a mathematics textbook said 
\begin_inset Quotes eld
\end_inset

before adding the last 
\begin_inset Formula $x$
\end_inset

 in the formula 
\begin_inset Formula $x^{2}+x$
\end_inset

, we change that 
\begin_inset Formula $x$
\end_inset

 by adding 
\begin_inset Formula $4$
\end_inset

 to it
\begin_inset Quotes erd
\end_inset

.
 If the 
\begin_inset Quotes eld
\end_inset

last 
\begin_inset Formula $x$
\end_inset


\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Formula $x^{2}+x$
\end_inset

 needs to have a 
\begin_inset Formula $4$
\end_inset

 added to it, a mathematics textbook will just write the formula 
\begin_inset Formula $x^{2}+x+4$
\end_inset

.
\end_layout

\begin_layout Standard
Arguments of nameless functions are also immutable.
 Consider, for example:
\begin_inset Formula 
\[
f(n)=\sum_{k=0}^{n}\,(k^{2}+k)\quad.
\]

\end_inset

Here, 
\begin_inset Formula $n$
\end_inset

 is the argument of the function 
\begin_inset Formula $f$
\end_inset

, while 
\begin_inset Formula $k$
\end_inset

 is the argument of the nameless function 
\begin_inset Formula $k\rightarrow k^{2}+k$
\end_inset

.
 Neither 
\begin_inset Formula $n$
\end_inset

 nor 
\begin_inset Formula $k$
\end_inset

 can be 
\begin_inset Quotes eld
\end_inset

modified
\begin_inset Quotes erd
\end_inset

 in any sense within the expressions where they are used.
 The symbols 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 stand for some integer values, and these values are immutable.
 Indeed, it is meaningless to say that we 
\begin_inset Quotes eld
\end_inset

modified the integer 
\begin_inset Formula $4$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 In the same way, we cannot modify 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
So, a variable in mathematics remains constant 
\emph on
within
\emph default
 
\emph on
the expression
\emph default
 where it is defined; in that expression, a variable is essentially a 
\begin_inset Quotes eld
\end_inset

named constant
\begin_inset Quotes erd
\end_inset

.
 Of course, a function 
\begin_inset Formula $f$
\end_inset

 can be applied to different values 
\begin_inset Formula $x$
\end_inset

, to compute a different result 
\begin_inset Formula $f(x)$
\end_inset

 each time.
 However, a given value of 
\begin_inset Formula $x$
\end_inset

 will remain unmodified within the body of the function 
\begin_inset Formula $f$
\end_inset

 while 
\begin_inset Formula $f(x)$
\end_inset

 is being computed.
\end_layout

\begin_layout Standard
Functional programming adopts this convention from mathematics: variables
 are immutable named constants.
 (Scala also has 
\emph on
mutable
\emph default
 variables, but we will not consider them in this book.)
\end_layout

\begin_layout Standard
In Scala, function arguments are immutable within the function body:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def f(x: Int) = x * x + x // Cannot modify `x` here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
type
\emph default
 of each mathematical variable (such as integer, vector, etc.) is also fixed.
 Each variable is a value from a specific set (e.g., the set of all integers,
 the set of all vectors, etc.).
 Mathematical formulas such as 
\begin_inset Formula $x^{2}+x$
\end_inset

 do not express any 
\begin_inset Quotes eld
\end_inset

checking
\begin_inset Quotes erd
\end_inset

 that 
\begin_inset Formula $x$
\end_inset

 is indeed an integer and not, say, a vector, in the middle of evaluating
 
\begin_inset Formula $x^{2}+x$
\end_inset

.
 The types of all variables are checked in advance.
\end_layout

\begin_layout Standard
Functional programming adopts the same view: Each argument of each function
 must have a 
\series bold
type
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
types
\end_layout

\end_inset

 that represents the set of possible allowed values for that function argument.
 The programming language's compiler will automatically check the types
 of all arguments in advance, 
\emph on
before
\emph default
 the program runs.
 A program that calls functions on arguments of incorrect types will not
 compile.
\end_layout

\begin_layout Standard
The second usage of 
\series bold
variables
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
variable
\end_layout

\end_inset

 in mathematics is to denote expressions that will be reused.
 For example, one writes: let 
\begin_inset Formula $z=\frac{x-y}{x+y}$
\end_inset

 and now compute 
\begin_inset Formula $\cos z+\cos2z+\cos3z$
\end_inset

.
 Again, the variable 
\begin_inset Formula $z$
\end_inset

 remains immutable, and its type remains fixed.
\end_layout

\begin_layout Standard
In Scala, this construction (defining an expression to be reused later)
 is written with the 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 syntax.
 Each variable defined using 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is a named constant, and its type and value are fixed at the time of definition.
 Type annotations for 
\begin_inset Quotes eld
\end_inset


\begin_inset listings
inline true
status open

\begin_layout Plain Layout

val
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

s are optional in Scala.
 For instance, we could write:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x: Int = 123
\end_layout

\end_inset

or we could omit the type annotation 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

:Int
\end_layout

\end_inset

 and write more concisely:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

val x = 123
\end_layout

\end_inset

Here, it is clear that this 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x
\end_layout

\end_inset


\family default
 is an integer.
 Nevertheless, it is often helpful to write out the types.
 If we do so, the compiler will check that the types match correctly and
 give an error message whenever wrong types are used.
 For example, a type error is detected when using a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

String
\end_layout

\end_inset

 instead of an 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Int
\end_layout

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

scala> val x: Int = "123"
\end_layout

\begin_layout Plain Layout

<console>:11: error: type mismatch;
\end_layout

\begin_layout Plain Layout

 found   : String("123")
\end_layout

\begin_layout Plain Layout

 required: Int
\end_layout

\begin_layout Plain Layout

        val x: Int = "123"
\end_layout

\begin_layout Plain Layout

                     ^
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Iteration without loops
\end_layout

\begin_layout Standard
A distinctive feature of the FP paradigm is handling of iteration without
 writing loops.
\end_layout

\begin_layout Standard
Iterative computations are ubiquitous in mathematics.
 As an example, consider the formula for the standard deviation (
\begin_inset Formula $\sigma$
\end_inset

) estimated from a data sample 
\begin_inset Formula $\left[x_{1},...,x_{n}\right]$
\end_inset

:
\begin_inset Formula 
\[
\sigma=\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}x_{i}^{2}-\frac{1}{n\left(n-1\right)}\left(\sum_{i=1}^{n}x_{i}\right)^{2}}\quad.
\]

\end_inset

This expression is computed by iterating over values of the index 
\begin_inset Formula $i$
\end_inset

.
 And yet, no mathematics textbook uses loops or says 
\begin_inset Quotes eld
\end_inset

now repeat this formula ten times
\begin_inset Quotes erd
\end_inset

.
 Indeed, it would be pointless to evaluate a formula such as 
\begin_inset Formula $x^{2}+x$
\end_inset

 ten times, because the result of 
\begin_inset Formula $x^{2}+x$
\end_inset

 remains the same every time.
 It is also meaningless to 
\begin_inset Quotes eld
\end_inset

repeat
\begin_inset Quotes erd
\end_inset

 an equation such as 
\begin_inset Formula $\left(x-1\right)(x^{2}+x+1)=x^{3}-1$
\end_inset

.
\end_layout

\begin_layout Standard
Instead of loops, mathematicians write 
\emph on
expressions
\emph default
 such as 
\begin_inset Formula $\sum_{i=1}^{n}s_{i}$
\end_inset

, where symbols such as 
\begin_inset Formula $\sum_{i=1}^{n}$
\end_inset

 denote the results of entire iterative computations.
 Such computations are defined using mathematical induction
\begin_inset Index idx
status open

\begin_layout Plain Layout
mathematical induction
\end_layout

\end_inset

.
 The FP paradigm has developed rich tools for translating mathematical induction
 into code.
 This chapter focuses on methods such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, that implement certain kinds of iterative computations.
 These and other similar methods can be combined in flexible ways, enabling
 programmers to write iterative code without loops.
 For example, the computation of 
\begin_inset Formula $\sigma$
\end_inset

 according to the formula shown above may be implemented by code that looks
 like this:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def sigma(xs: Seq[Double]): Double = {
\end_layout

\begin_layout Plain Layout

  val n = xs.length.toDouble
\end_layout

\begin_layout Plain Layout

  val xsum = xs.sum
\end_layout

\begin_layout Plain Layout

  val x2sum = xs.map(x => x * x).sum
\end_layout

\begin_layout Plain Layout

  math.sqrt(x2sum / (n - 1) - xsum * xsum / n / (n - 1))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> sigma(Seq(10, 20, 30))
\end_layout

\begin_layout Plain Layout

res0: Double = 10.0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The programmer can avoid writing loops because all iterative computations
 are delegated to functions such as 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

filter
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

sum
\end_layout

\end_inset

, and others.
 It is the job of the library and the compiler to translate those high-level
 functions into low-level machine code.
 The machine code 
\emph on
will
\emph default
 likely contain loops, but the programmer does not need to see that machine
 code or to reason about it.
\end_layout

\begin_layout Subsection
Nameless functions in mathematical notation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Nameless-functions-in-mathematical-notation"

\end_inset


\end_layout

\begin_layout Standard
Functions in mathematics are mappings from one set to another.
 A function does not necessarily 
\emph on
need
\emph default
 a name; the mapping just needs to be defined.
 However, nameless functions have not been widely used in the conventional
 mathematical notation.
 It turns out that nameless functions are important in functional programming
 because, in particular, they allow programmers to write code with a straightfor
ward and consistent syntax.
\end_layout

\begin_layout Standard
Nameless functions contain bound variables that are invisible outside the
 function's scope.
 This property is directly reflected by the prevailing mathematical conventions.
 Compare the formulas:
\begin_inset Formula 
\[
f\left(x\right)=\int_{0}^{x}\frac{dx}{1+x}\quad;\quad f\left(x\right)=\int_{0}^{x}\frac{dz}{1+z}\quad.
\]

\end_inset

The mathematical convention is that one may rename the integration variable
 at will, and so these formulas define the same function 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
In programming, the only situation when a variable 
\begin_inset Quotes eld
\end_inset

may be renamed at will
\begin_inset Quotes erd
\end_inset

 is when the variable represents an argument of a function.
 It follows that the notations 
\begin_inset Formula $\frac{dx}{1+x}$
\end_inset

 and 
\begin_inset Formula $\frac{dz}{1+z}$
\end_inset

 correspond to a nameless function whose argument was renamed from 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $z$
\end_inset

.
 In FP notation, this nameless function would be denoted as 
\begin_inset Formula $z\rightarrow\frac{1}{1+z}$
\end_inset

, and the integral rewritten as code such as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

integration(0, x, { z => 1.0 / (1 + z) } )
\end_layout

\end_inset

Now consider the traditional mathematical notation for summation, for instance:
\begin_inset Formula 
\[
\sum_{k=0}^{x}\frac{1}{1+k}\quad.
\]

\end_inset

In that sum, the bound variable 
\begin_inset Formula $k$
\end_inset

 is introduced under the 
\begin_inset Formula $\sum$
\end_inset

 symbol; but in integrals, the bound variable follows the special symbol
 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $d$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 This notational inconsistency could be removed if we were to use nameless
 functions explicitly, for example:
\begin_inset Formula 
\begin{align*}
\text{denote summation by }\sum_{0}^{x} & \left(k\rightarrow\frac{1}{1+k}\right)\text{ instead of }\sum_{k=0}^{x}\frac{1}{1+k}\quad,\\
\text{denote integration by }\int_{0}^{x} & \left(z\rightarrow\frac{1}{1+z}\right)\text{ instead of }\int_{0}^{x}\frac{dz}{1+z}\quad.
\end{align*}

\end_inset

In this notation, the new summation symbol 
\begin_inset Formula $\sum_{0}^{x}$
\end_inset

 does not mention the name 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $k$
\end_inset


\begin_inset Quotes erd
\end_inset

 but takes a function as an argument.
 Similarly, the new integration symbol 
\begin_inset Formula $\int_{0}^{x}$
\end_inset

 does not mention 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $z$
\end_inset


\begin_inset Quotes erd
\end_inset

 and does not use the special symbol 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $d$
\end_inset


\begin_inset Quotes erd
\end_inset

 but now takes a function as an argument.
 Written in this way, the operations of summation and integration become
 
\emph on
functions
\emph default
 that take functions as arguments.
 The above summation may be written in a consistent and straightforward
 manner as a Scala function:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

summation(0, x, { y => 1.0 / (1 + y) } )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We could implement 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

summation(a, b, g)
\end_layout

\end_inset


\family default
 as:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def summation(a: Int, b: Int, g: Int => Double): Double = (a to b).map(g).sum
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> summation(1, 10, x => math.sqrt(x))
\end_layout

\begin_layout Plain Layout

res0: Double = 22.4682781862041
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Integration requires longer code since the computations are more complicated.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Simpson's rule
\end_layout

\end_inset

Simpson's rule
\begin_inset Foot
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Simpson%27s_rule"
literal "false"

\end_inset


\end_layout

\end_inset

 is an algorithm for approximate numerical integration, defined by the formulas:
\begin_inset Formula 
\begin{align*}
\text{integration}\left(a,b,g,\varepsilon\right) & =\frac{\delta}{3}\big(g(a)+g(b)+4s_{1}+2s_{2}\big)\quad,\\
\text{where }~~~n & =2\left\lfloor \frac{b-a}{\varepsilon}\right\rfloor ,\quad\delta_{x}=\frac{b-a}{n}\quad,\\
s_{1}=\sum_{k=1,3,...,n-1}g(a+k\delta_{x}) & \quad,\quad\quad s_{2}=\sum_{k=2,4,...,n-2}g(a+k\delta_{x})\quad.
\end{align*}

\end_inset

 Here is a straightforward line-by-line translation of these formulas into
 Scala, with some tests:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def integration(a: Double, b: Double, g: Double => Double, eps: Double):
 Double = {
\end_layout

\begin_layout Plain Layout

   // First, we define some helper values and functions corresponding
\end_layout

\begin_layout Plain Layout

   // to the definitions 
\begin_inset Quotes eld
\end_inset

where n = ...
\begin_inset Quotes erd
\end_inset

 in the mathematical formulas.
\end_layout

\begin_layout Plain Layout

   val n: Int = 2 * ((b - a) / eps).toInt
\end_layout

\begin_layout Plain Layout

   val delta_x = (b - a) / n
\end_layout

\begin_layout Plain Layout

   val s1 = (1 to (n - 1) by 2).map { k => g(a + k * delta_x) }.sum
\end_layout

\begin_layout Plain Layout

   val s2 = (2 to (n - 2) by 2).map { k => g(a + k * delta_x) }.sum
\end_layout

\begin_layout Plain Layout

   // Now we can write the expression for the final result.
\end_layout

\begin_layout Plain Layout

   delta_x / 3 * (g(a) + g(b) + 4 * s1 + 2 * s2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> integration(0, 5, x => x*x*x*x, eps = 0.01)     // The exact answer
 is 625.
\end_layout

\begin_layout Plain Layout

res0: Double = 625.0000000004167
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

scala> integration(0, 7, x => x*x*x*x*x*x, eps = 0.01) // The exact answer
 is 117649.
\end_layout

\begin_layout Plain Layout

res1: Double = 117649.00000014296
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The entire code is one large 
\emph on
expression
\emph default
, with a few sub-expressions (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s1
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s2
\end_layout

\end_inset

, etc.) defined for within the 
\series bold
local scope
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
local scope
\end_layout

\end_inset

 of the function (that is, within the function's body).
 The code contains no loops.
 This is similar to the way a mathematical text would define Simpson's rule.
 In other words, this code is written in the FP paradigm.
 Similar code can be written in any programming language that supports nameless
 functions as arguments of other functions.
 
\end_layout

\begin_layout Subsection
Named and nameless expressions and their uses
\end_layout

\begin_layout Standard
It is a significant advantage if a programming language supports unnamed
 (or 
\begin_inset Quotes eld
\end_inset

nameless
\begin_inset Quotes erd
\end_inset

) expressions.
 To see this, consider a familiar situation where we take the absence of
 names for granted.
\end_layout

\begin_layout Standard
In today's programming languages, we may directly write expressions such
 as 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x+123)*y/(4+x)
\end_layout

\end_inset


\family default
.
 Note that the entire expression does not need to have a name.
 Parts of that expression (e.g., the sub-expressions 
\family typewriter

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

x+123
\end_layout

\end_inset


\family default
 or 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

4+x
\end_layout

\end_inset

) also do not have separate names.
 It would be inconvenient if we 
\emph on
needed
\emph default
 to assign a name to each sub-expression.
 The code for 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(x+123)*y/(4+x)
\end_layout

\end_inset

 would then look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  val r0 = 123
\end_layout

\begin_layout Plain Layout

  val r1 = x + r0
\end_layout

\begin_layout Plain Layout

  val r2 = r1 * y
\end_layout

\begin_layout Plain Layout

  val r3 = 4 
\end_layout

\begin_layout Plain Layout

  val r4 = r3 + x
\end_layout

\begin_layout Plain Layout

  val r5 = r2 / r4     // Do we still remember what `r2` means?
\end_layout

\begin_layout Plain Layout

  r5
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This style of programming resembles assembly languages
\begin_inset Index idx
status open

\begin_layout Plain Layout
assembly language
\end_layout

\end_inset

, where every sub-expression — that is, every step of every calculation
 — must be assigned a separate memory address or a CPU register.
\end_layout

\begin_layout Standard
Programmers become more productive when their programming language supports
 nameless expressions.
 This is also common practice in mathematics; names are assigned when needed,
 but most expressions remain nameless.
\end_layout

\begin_layout Standard
It is also useful if data structures can be created without names.
 For instance, a 
\series bold
dictionary
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dictionary
\end_layout

\end_inset

 (also called a 
\begin_inset Quotes eld
\end_inset

map
\begin_inset Quotes erd
\end_inset

 or a 
\begin_inset Quotes eld
\end_inset

hashmap
\begin_inset Quotes erd
\end_inset

) may be created in Scala with this code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Map("a" -> 1, "b" -> 2, "c" -> 3)
\end_layout

\end_inset

This is a nameless expression whose value is a dictionary.
 In programming languages that do not have such a construction, programmers
 have to write special code that creates an initially empty dictionary and
 then fills it step by step with values:
\begin_inset listings
lstparams "language=Java"
inline false
status open

\begin_layout Plain Layout

// Scala code creating a dictionary:
\end_layout

\begin_layout Plain Layout

Map("a" -> 1, "b" -> 2, "c" -> 3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Shortest Java code for the same:
\end_layout

\begin_layout Plain Layout

new HashMap<String, Integer>() {{
\end_layout

\begin_layout Plain Layout

   put("a", 1);
\end_layout

\begin_layout Plain Layout

   put("b", 2);
\end_layout

\begin_layout Plain Layout

   put(
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

, 3);
\end_layout

\begin_layout Plain Layout

}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nameless functions are useful for the same reason as other nameless values:
 they allow us to build larger programs from simpler parts in a uniform
 way.
\end_layout

\begin_layout Subsection
Historical perspective on nameless functions
\end_layout

\begin_layout Standard
\begin_inset Wrap table
lines 0
placement r
overhang 0in
width "60col%"
status open

\begin_layout Plain Layout
\align center
\begin_inset VSpace -100baselineskip%
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="25" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Language
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Year
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Code for 
\series default

\begin_inset Formula $k\rightarrow k+1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1936
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda k.~add~k~1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1940
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda k:int.~add~k~1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
LISP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1958
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(lambda (k) (+ k 1))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Standard ML
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1973
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fn (k: int) => k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Caml
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1985
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fun (k: int) -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Haskell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1990
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout


\backslash
 k -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Oz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1991
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fun {$ K} K + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1993
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function(k) k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Python 1.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1994
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lambda k: k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JavaScript
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1995
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function(k) { return k + 1; }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Mercury
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1995
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func(K) = K + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Ruby
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1995
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

lambda { |k| k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lua 3.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
1998
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function(k) return k + 1 end
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Scala
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2003
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(k: Int) => k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
F#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2005
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fun (k: int) -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
C# 3.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2007
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

delegate(int k) { return k + 1; }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Clojure
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2009
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(fn [k] (+ k 1))
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
C++ 11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2011
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

[] (int k) { return k + 1; }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Go
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2012
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

func(k int) { return k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Julia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2012
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

function(k:: Int) k + 1 end
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Kotlin
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2012
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ k: Int -> k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Swift
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2014
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

{ (k:int) -> int in return k + 1 }
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Java 8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2014
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

(int k) -> k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Rust
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
2015
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

|k: i32| k + 1
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Nameless functions in programming languages.
\begin_inset CommandInset label
LatexCommand label
name "lambda-functions-table"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -300baselineskip%
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nameless functions were first used in 1936 in a theoretical programming
 language called 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\lambda$
\end_inset

-calculus
\begin_inset Index idx
status open

\begin_layout Plain Layout
$lambda$@
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 In that language,
\begin_inset Foot
status open

\begin_layout Plain Layout
Although called a 
\begin_inset Quotes eld
\end_inset

calculus,
\begin_inset Quotes erd
\end_inset

 it is a (drastically simplified) 
\emph on
programming
\emph default
 
\emph on
language
\emph default
, not related to differential or integral calculus.
 Also, the symbol 
\begin_inset Formula $\lambda$
\end_inset

 has no particular significance other than a syntactic separator used in
  functions.
 Practitioners of functional programming usually do not need to study any
 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 The practically relevant knowledge that comes from 
\begin_inset Formula $\lambda$
\end_inset

-calculus will be explained in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Higher-order-functions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 all functions are nameless and have a single argument.
 The Greek letter 
\begin_inset Formula $\lambda$
\end_inset

 (pronounced as 
\begin_inset Quotes eld
\end_inset

lambda
\begin_inset Quotes erd
\end_inset

) is a syntax separator that denotes function arguments in nameless functions.
 For example, the nameless function 
\begin_inset Formula $x\rightarrow x+1$
\end_inset

 could be written as 
\begin_inset Formula $\lambda x.~add~x~1$
\end_inset

 in 
\begin_inset Formula $\lambda$
\end_inset

-calculus if it had a function 
\begin_inset Formula $add$
\end_inset

 for adding integers (but it does not).
\end_layout

\begin_layout Standard
In most programming languages that were in use until around 1990, all functions
 required names.
 But by 2015, the use of nameless functions in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

map
\end_layout

\end_inset

/
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

reduce
\end_layout

\end_inset

 programming style
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
map
\family default
/
\family typewriter
reduce
\family default
 programming style
\end_layout

\end_inset

 turned out to be so productive that most newly created languages included
 nameless functions, while older languages added that feature.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lambda-functions-table"

\end_inset

 shows the year when various languages supported nameless functions.
\end_layout

\begin_layout Standard
What this book calls a 
\begin_inset Quotes eld
\end_inset

nameless function
\begin_inset Quotes erd
\end_inset

 is also known as an anonymous function,
\begin_inset Index idx
status open

\begin_layout Plain Layout
anonymous function!see 
\begin_inset Quotes eld
\end_inset

nameless functions
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 a function expression, a function literal, a closure, a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
lambda-function!see 
\begin_inset Quotes eld
\end_inset

nameless function
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

lambda function, a lambda expression, or just a 
\begin_inset Quotes eld
\end_inset

lambda
\begin_inset Quotes erd
\end_inset

.
 This book prefers the clearer term 
\begin_inset Quotes eld
\end_inset

nameless function
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_body
\end_document
